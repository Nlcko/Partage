=== MERGED LUA FILES FROM WeakAurasOptions ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIContainer-WeakAurasInlineGroup.lua ===
--[[-----------------------------------------------------------------------------
WeakAurasInlineGroup based on InlineGroup Container
Simple container widget that has the same API as a InlineGroup, without actually
showing any borders or a title.
-------------------------------------------------------------------------------]]
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasInlineGroup", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(300)
		self:SetHeight(100)
		self:SetTitle("")
	end,

	-- ["OnRelease"] = nil,

	["SetTitle"] = function(self)
    -- Do nothing
	end,


	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight(height or 0)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		content:SetWidth(width)
		content.width = width
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		content:SetHeight(height)
		content.height = height
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	--Container Support
	local content = CreateFrame("Frame", nil, frame)
	content:SetPoint("TOPLEFT", 0, 0)
	content:SetPoint("BOTTOMRIGHT", 0, 0)

  --- @type table<string, any>
	local widget = {
		frame     = frame,
		content   = content,
		type      = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIContainer-WeakAurasInlineGroup.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIContainer-WeakAurasTreeGroup.lua ===
--[[-----------------------------------------------------------------------------
WeakAurasTreeGroup Container
Container that uses a tree control to switch between groups.
This file was forked from AceGUIContainer-TreeGroup.lua version 41
-------------------------------------------------------------------------------]]
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasTreeGroup", 3
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local WoW80 = select(4, GetBuildInfo()) >= 80000

-- Lua APIs
local next, pairs, ipairs, assert, type = next, pairs, ipairs, assert, type
local math_min, math_max, floor = math.min, math.max, floor
local select, tremove, unpack, tconcat = select, table.remove, unpack, table.concat

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: GameTooltip, FONT_COLOR_CODE_CLOSE

-- Recycling functions
local new, del
do
	local pool = setmetatable({},{__mode='k'})
	function new()
		local t = next(pool)
		if t then
			pool[t] = nil
			return t
		else
			return {}
		end
	end
	function del(t)
		for k in pairs(t) do
			t[k] = nil
		end
		pool[t] = true
	end
end

local DEFAULT_TREE_WIDTH = 175
local DEFAULT_TREE_SIZABLE = true

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function GetButtonUniqueValue(line)
	local parent = line.parent
	if parent and parent.value then
		return GetButtonUniqueValue(parent).."\001"..line.value
	else
		return line.value
	end
end

local function UpdateButton(button, treeline, selected, canExpand, isExpanded)
	local self = button.obj
	local toggle = button.toggle
	local text = treeline.text or ""
	local icon = treeline.icon
	local iconCoords = treeline.iconCoords
	local level = treeline.level
	local value = treeline.value
	local fileId = treeline.fileId
	local uniquevalue = treeline.uniquevalue
	local disabled = treeline.disabled

	button.treeline = treeline
	button.value = value
	button.fileId = fileId
	button.uniquevalue = uniquevalue
	if selected then
		button:LockHighlight()
		button.selected = true
	else
		button:UnlockHighlight()
		button.selected = false
	end
	button.level = level
	if level == 1 then
		button:SetNormalFontObject("GameFontNormal")
		button:SetHighlightFontObject("GameFontHighlight")
		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8, 2)
	else
		button:SetNormalFontObject("GameFontHighlightSmall")
		button:SetHighlightFontObject("GameFontHighlightSmall")
		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8 * level, 2)
	end

	if disabled then
		button:EnableMouse(false)
		button.text:SetText("|cff808080"..text..FONT_COLOR_CODE_CLOSE)
	else
		button.text:SetText(text)
		button:EnableMouse(true)
	end

	if icon then
		button.icon:SetTexture(icon)
		button.icon:SetPoint("LEFT", 8 * level, (level == 1) and 0 or 1)
	else
		button.icon:SetTexture(nil)
	end

	if iconCoords then
		button.icon:SetTexCoord(unpack(iconCoords))
	else
		button.icon:SetTexCoord(0, 1, 0, 1)
	end

	if canExpand then
		if not isExpanded then
			toggle:SetNormalTexture(130838) -- Interface\\Buttons\\UI-PlusButton-UP
			toggle:SetPushedTexture(130836) -- Interface\\Buttons\\UI-PlusButton-DOWN
		else
			toggle:SetNormalTexture(130821) -- Interface\\Buttons\\UI-MinusButton-UP
			toggle:SetPushedTexture(130820) -- Interface\\Buttons\\UI-MinusButton-DOWN
		end
		toggle:Show()
	else
		toggle:Hide()
	end
end

local function ShouldDisplayLevel(tree)
	local result = false
	for k, v in ipairs(tree) do
		if v.children == nil and v.visible ~= false then
			result = true
		elseif v.children then
			result = result or ShouldDisplayLevel(v.children)
		end
		if result then return result end
	end
	return false
end

local function addLine(self, v, tree, level, parent)
	local line = new()
	line.value = v.value
	line.text = v.text
	line.icon = v.icon
	line.iconCoords = v.iconCoords
	line.disabled = v.disabled
	line.tree = tree
	line.level = level
	line.parent = parent
	line.visible = v.visible
	line.uniquevalue = GetButtonUniqueValue(line)
	line.fileId = v.fileId
	if v.children then
		line.hasChildren = true
	else
		line.hasChildren = nil
	end
	self.lines[#self.lines+1] = line
	return line
end

--fire an update after one frame to catch the treeframes height
local function FirstFrameUpdate(frame)
	local self = frame.obj
	frame:SetScript("OnUpdate", nil)
	self:RefreshTree(nil, true)
end

local function BuildUniqueValue(...)
	local n = select('#', ...)
	if n == 1 then
		return ...
	else
		return (...).."\001"..BuildUniqueValue(select(2,...))
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Expand_OnClick(frame)
	local button = frame.button
	local self = button.obj
	local status = (self.status or self.localstatus).groups
	status[button.uniquevalue] = not status[button.uniquevalue]
	self:RefreshTree()
end

local function Button_OnClick(frame)
	local self = frame.obj
	self:Fire("OnClick", frame.uniquevalue, frame.selected)
	if not frame.selected then
		self:SetSelected(frame.uniquevalue, frame.fileId)
		frame.selected = true
		frame:LockHighlight()
		self:RefreshTree()
	end
	AceGUI:ClearFocus()
end

local function Button_OnDoubleClick(button)
	local self = button.obj
	local status = (self.status or self.localstatus).groups
	status[button.uniquevalue] = not status[button.uniquevalue]
	self:RefreshTree()
end

local function Button_OnEnter(frame)
	local self = frame.obj
	self:Fire("OnButtonEnter", frame.uniquevalue, frame)

	if self.enabletooltips then
		GameTooltip:SetOwner(frame, "ANCHOR_NONE")
		GameTooltip:SetPoint("LEFT",frame,"RIGHT")
		GameTooltip:SetText(frame.text:GetText() or "", 1, .82, 0, true)

		GameTooltip:Show()
	end
end

local function Button_OnLeave(frame)
	local self = frame.obj
	self:Fire("OnButtonLeave", frame.uniquevalue, frame)

	if self.enabletooltips then
		GameTooltip:Hide()
	end
end

local function OnScrollValueChanged(frame, value)
	if frame.obj.noupdate then return end
	local self = frame.obj
	local status = self.status or self.localstatus
	status.scrollvalue = floor(value + 0.5)
	self:RefreshTree()
	AceGUI:ClearFocus()
end

local function Tree_OnSizeChanged(frame)
	frame.obj:RefreshTree()
end

local function Tree_OnMouseWheel(frame, delta)
	local self = frame.obj
	if self.showscroll then
		local scrollbar = self.scrollbar
		local min, max = scrollbar:GetMinMaxValues()
		local value = scrollbar:GetValue()
		local newvalue = math_min(max,math_max(min,value - delta))
		if value ~= newvalue then
			scrollbar:SetValue(newvalue)
		end
	end
end

local function Dragger_OnLeave(frame)
	frame:SetBackdropColor(1, 1, 1, 0)
end

local function Dragger_OnEnter(frame)
	frame:SetBackdropColor(1, 1, 1, 0.8)
end

local function Dragger_OnMouseDown(frame)
	local treeframe = frame:GetParent()
	treeframe:StartSizing("RIGHT")
end

local function Dragger_OnMouseUp(frame)
	local treeframe = frame:GetParent()
	local self = treeframe.obj
	local parentFrame = treeframe:GetParent()
	treeframe:StopMovingOrSizing()
	--treeframe:SetScript("OnUpdate", nil)
	treeframe:SetUserPlaced(false)
	--Without this :GetHeight will get stuck on the current height, causing the tree contents to not resize
	treeframe:SetHeight(0)
	treeframe:SetPoint("TOPLEFT", parentFrame, "TOPLEFT",0,0)
	treeframe:SetPoint("BOTTOMLEFT", parentFrame, "BOTTOMLEFT",0,0)

	local status = self.status or self.localstatus
	status.treewidth = treeframe:GetWidth()

	treeframe.obj:Fire("OnTreeResize",treeframe:GetWidth())
	-- recalculate the content width
	treeframe.obj:OnWidthSet(status.fullwidth)
	-- update the layout of the content
	treeframe.obj:DoLayout()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetTreeWidth(DEFAULT_TREE_WIDTH, DEFAULT_TREE_SIZABLE)
		self:EnableButtonTooltips(true)
		self.frame:SetScript("OnUpdate", FirstFrameUpdate)
	end,

	["OnRelease"] = function(self)
		self.status = nil
		self.tree = nil
		self.frame:SetScript("OnUpdate", nil)
		for k, v in pairs(self.localstatus) do
			if k == "groups" then
				for k2 in pairs(v) do
					v[k2] = nil
				end
			else
				self.localstatus[k] = nil
			end
		end
		self.localstatus.scrollvalue = 0
		self.localstatus.treewidth = DEFAULT_TREE_WIDTH
		self.localstatus.treesizable = DEFAULT_TREE_SIZABLE
	end,

	["EnableButtonTooltips"] = function(self, enable)
		self.enabletooltips = enable
	end,

	["CreateButton"] = function(self)
		local num = AceGUI:GetNextWidgetNum("TreeGroupButton")
		local button = CreateFrame("Button", ("AceGUI30TreeButton%d"):format(num), self.treeframe, "OptionsListButtonTemplate")
		button.obj = self

		local icon = button:CreateTexture(nil, "OVERLAY")
		icon:SetWidth(14)
		icon:SetHeight(14)
		button.icon = icon

		button:SetScript("OnClick",Button_OnClick)
		button:SetScript("OnDoubleClick", Button_OnDoubleClick)
		button:SetScript("OnEnter",Button_OnEnter)
		button:SetScript("OnLeave",Button_OnLeave)

		button.toggle.button = button
		button.toggle:SetScript("OnClick",Expand_OnClick)

		button.text:SetHeight(14) -- Prevents text wrapping

		return button
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
		if not status.groups then
			status.groups = {}
		end
		if not status.scrollvalue then
			status.scrollvalue = 0
		end
		if not status.treewidth then
			status.treewidth = DEFAULT_TREE_WIDTH
		end
		if status.treesizable == nil then
			status.treesizable = DEFAULT_TREE_SIZABLE
		end
		self:SetTreeWidth(status.treewidth,status.treesizable)
		self:RefreshTree()
	end,

	--sets the tree to be displayed
	["SetTree"] = function(self, tree, filter)
		self.filter = filter
		if tree then
			assert(type(tree) == "table")
		end
		self.tree = tree
		self:RefreshTree()
	end,

	["BuildLevel"] = function(self, tree, level, parent)
		local groups = (self.status or self.localstatus).groups

		for i, v in ipairs(tree) do
			if v.children then
				if not self.filter or ShouldDisplayLevel(v.children) then
					local line = addLine(self, v, tree, level, parent)
					if groups[line.uniquevalue] then
						self:BuildLevel(v.children, level+1, line)
					end
				end
			elseif v.visible ~= false or not self.filter then
				addLine(self, v, tree, level, parent)
			end
		end
	end,

	["RefreshTree"] = function(self,scrollToSelection,fromOnUpdate)
		local buttons = self.buttons
		local lines = self.lines

		for i, v in ipairs(buttons) do
			v:Hide()
		end
		while lines[1] do
			local t = tremove(lines)
			for k in pairs(t) do
				t[k] = nil
			end
			del(t)
		end

		if not self.tree then return end
		--Build the list of visible entries from the tree and status tables
		local status = self.status or self.localstatus
		local groupstatus = status.groups
		local tree = self.tree

		local treeframe = self.treeframe

		status.scrollToSelection = status.scrollToSelection or scrollToSelection	-- needs to be cached in case the control hasn't been drawn yet (code bails out below)

		self:BuildLevel(tree, 1)

		local numlines = #lines

		local maxlines = (floor(((self.treeframe:GetHeight()or 0) - 20 ) / 18))
		if maxlines <= 0 then return end

		-- WORKAROUND for lag spikes on WoW 8.0
		if WoW80 and self.frame:GetParent() == UIParent and not fromOnUpdate then
			self.frame:SetScript("OnUpdate", FirstFrameUpdate)
			return
		end

		local first, last

		scrollToSelection = status.scrollToSelection
		status.scrollToSelection = nil

		if numlines <= maxlines then
			--the whole tree fits in the frame
			status.scrollvalue = 0
			self:ShowScroll(false)
			first, last = 1, numlines
		else
			self:ShowScroll(true)
			--scrolling will be needed
			self.noupdate = true
			self.scrollbar:SetMinMaxValues(0, numlines - maxlines)
			--check if we are scrolled down too far
			if numlines - status.scrollvalue < maxlines then
				status.scrollvalue = numlines - maxlines
			end
			self.noupdate = nil
			first, last = status.scrollvalue+1, status.scrollvalue + maxlines
			--show selection?
			if scrollToSelection and status.selected then
				local show
				for i,line in ipairs(lines) do	-- find the line number
					if line.uniquevalue==status.selected then
						show=i
					end
				end
				if not show then
					-- selection was deleted or something?
				elseif show >= first and show <= last then
					-- all good
				else
					-- scrolling needed!
					if show < first then
						status.scrollvalue = show - 1
					else
						status.scrollvalue = show-maxlines
					end
					first, last = status.scrollvalue + 1, status.scrollvalue + maxlines
				end
			end
			if self.scrollbar:GetValue() ~= status.scrollvalue then
				self.scrollbar:SetValue(status.scrollvalue)
			end
		end

		local buttonnum = 1
		for i = first, last do
			local line = lines[i]
			local button = buttons[buttonnum]
			if not button then
				button = self:CreateButton()

				buttons[buttonnum] = button
				button:SetParent(treeframe)
				button:SetFrameLevel(treeframe:GetFrameLevel() + 1)
				button:ClearAllPoints()
				if buttonnum == 1 then
					if self.showscroll then
						button:SetPoint("TOPRIGHT", -22, -10)
						button:SetPoint("TOPLEFT", 0, -10)
					else
						button:SetPoint("TOPRIGHT", 0, -10)
						button:SetPoint("TOPLEFT", 0, -10)
					end
				else
					button:SetPoint("TOPRIGHT", buttons[buttonnum - 1], "BOTTOMRIGHT", 0, 0)
					button:SetPoint("TOPLEFT", buttons[buttonnum - 1], "BOTTOMLEFT", 0, 0)
				end
			end

			UpdateButton(button, line, status.selected == line.uniquevalue, line.hasChildren, groupstatus[line.uniquevalue])
			button:Show()
			buttonnum = buttonnum + 1
		end

	end,

	["SetSelected"] = function(self, value, fileId)
		local status = self.status or self.localstatus
		if status.selected ~= value then
			status.selected = value
			self:Fire("OnGroupSelected", value, fileId)
		end
	end,

	["Select"] = function(self, uniquevalue, ...)
		self.filter = false
		local status = self.status or self.localstatus
		local groups = status.groups
		local path = {...}
		for i = 1, #path do
			groups[tconcat(path, "\001", 1, i)] = true
		end
		status.selected = uniquevalue
		self:RefreshTree(true)

		self:Fire("OnGroupSelected", uniquevalue)
	end,

	["SelectByPath"] = function(self, ...)
		self:Select(BuildUniqueValue(...), ...)
	end,

	["SelectByValue"] = function(self, uniquevalue)
		self:Select(uniquevalue, ("\001"):split(uniquevalue))
	end,

	["ShowScroll"] = function(self, show)
		self.showscroll = show
		if show then
			self.scrollbar:Show()
			if self.buttons[1] then
				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe, "TOPRIGHT", -22, -10)
			end
		else
			self.scrollbar:Hide()
			if self.buttons[1] then
				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe, "TOPRIGHT", 0, -10)
			end
		end
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local treeframe = self.treeframe
		local status = self.status or self.localstatus
		status.fullwidth = width

		local contentwidth = width - status.treewidth - 20
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth

		local maxtreewidth = math_min(400, width - 50)

		if maxtreewidth > 100 and status.treewidth > maxtreewidth then
			self:SetTreeWidth(maxtreewidth, status.treesizable)
		end
		-- treeframe:SetMaxResize(maxtreewidth, 1600)
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 20
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["SetTreeWidth"] = function(self, treewidth, resizable)
		if not resizable then
			if type(treewidth) == 'number' then
				resizable = false
			elseif type(treewidth) == 'boolean' then
				resizable = treewidth
				treewidth = DEFAULT_TREE_WIDTH
			else
				resizable = false
				treewidth = DEFAULT_TREE_WIDTH
			end
		end
		self.treeframe:SetWidth(treewidth)
		self.dragger:EnableMouse(resizable)

		local status = self.status or self.localstatus
		status.treewidth = treewidth
		status.treesizable = resizable

		-- recalculate the content width
		if status.fullwidth then
			self:OnWidthSet(status.fullwidth)
		end
	end,

	["GetTreeWidth"] = function(self)
		local status = self.status or self.localstatus
		return status.treewidth or DEFAULT_TREE_WIDTH
	end,

	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight((height or 0) + 20)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local DraggerBackdrop  = {
	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
	edgeFile = nil,
	tile = true, tileSize = 16,
	insets = { left = 3, right = 3, top = 7, bottom = 7 }
}

local function Constructor()
	local num = AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Frame", nil, UIParent)

	local treeframe = CreateFrame("Frame", nil, frame)
	treeframe:SetPoint("TOPLEFT")
	treeframe:SetPoint("BOTTOMLEFT")
	treeframe:SetWidth(DEFAULT_TREE_WIDTH)
	treeframe:EnableMouseWheel(true)

	treeframe:SetResizable(true)
	treeframe:SetResizeBounds(100, 1, 400, 1600)
	treeframe:SetScript("OnUpdate", FirstFrameUpdate)
	treeframe:SetScript("OnSizeChanged", Tree_OnSizeChanged)
	treeframe:SetScript("OnMouseWheel", Tree_OnMouseWheel)

	local treeframeBG = CreateFrame("Frame", nil, treeframe, "BackdropTemplate")
	treeframeBG:SetBackdrop(PaneBackdrop)
	treeframeBG:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	treeframeBG:SetBackdropBorderColor(0.4, 0.4, 0.4)
	treeframeBG:SetAllPoints(treeframe)

	local dragger = CreateFrame("Frame", nil, treeframe, "BackdropTemplate")
	dragger:SetWidth(8)
	dragger:SetPoint("TOP", treeframe, "TOPRIGHT")
	dragger:SetPoint("BOTTOM", treeframe, "BOTTOMRIGHT")
	dragger:SetBackdrop(DraggerBackdrop)
	dragger:SetBackdropColor(1, 1, 1, 0)
	dragger:SetScript("OnEnter", Dragger_OnEnter)
	dragger:SetScript("OnLeave", Dragger_OnLeave)
	dragger:SetScript("OnMouseDown", Dragger_OnMouseDown)
	dragger:SetScript("OnMouseUp", Dragger_OnMouseUp)

	local scrollbar = CreateFrame("Slider", ("AceConfigDialogTreeGroup%dScrollBar"):format(num), treeframe, "UIPanelScrollBarTemplate")
	scrollbar:SetScript("OnValueChanged", nil)
	scrollbar:SetPoint("TOPRIGHT", -10, -26)
	scrollbar:SetPoint("BOTTOMRIGHT", -10, 26)
	scrollbar:SetMinMaxValues(0, 0)
	scrollbar:SetValueStep(1)
	scrollbar:SetValue(0)
	scrollbar:SetWidth(16)
	scrollbar:SetScript("OnValueChanged", OnScrollValueChanged)

	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
	scrollbg:SetAllPoints(scrollbar)
	scrollbg:SetColorTexture(0, 0, 0, 0.4)

	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
	border:SetPoint("TOPLEFT", treeframe, "TOPRIGHT")
	border:SetPoint("BOTTOMRIGHT")
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	border:SetBackdropBorderColor(0.4, 0.4, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		frame        = frame,
		lines        = {},
		levels       = {},
		buttons      = {},
		hasChildren  = {},
		localstatus  = { groups = {}, scrollvalue = 0 },
		filter       = false,
		treeframe    = treeframe,
		dragger      = dragger,
		scrollbar    = scrollbar,
		border       = border,
		content      = content,
		type         = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	treeframe.obj, dragger.obj, scrollbar.obj = widget, widget, widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIContainer-WeakAurasTreeGroup.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasAnchorButtons.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasAnchorButtons", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local directions = { "TOPLEFT", "TOP", "TOPRIGHT", "LEFT", "CENTER", "RIGHT", "BOTTOMLEFT", "BOTTOM", "BOTTOMRIGHT" }
local buttonSize = 10
local frameWidth = 100
local frameHeight = 50
local titleHeight = 15

local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(frameWidth + buttonSize)
    self:SetHeight(frameHeight + buttonSize + titleHeight + 2)
    self:SetDisabled(false)
  end,

  ["SetValue"] = function(self, text)
    if not tContains(directions, text) then return end
    for direction, button in pairs(self.buttons) do
      if direction == text then
        button.tex:SetVertexColor(0.9, 0.9, 0, 1)
      else
        button.tex:SetVertexColor(0.3, 0.3, 0.3, 1)
      end
      button:SetNormalTexture(button.tex)
    end
    self.value = text
  end,

  ["GetValue"] = function(self)
    return self.value
  end,

  ["SetLabel"] = function(self, text)
    if text and text ~= "" then
      self.label:SetText(text);
      self.label:Show()
    else
      self.label:SetText("")
      self.label:Hide()
    end
  end,

  ["SetList"] = function() end,

  ["SetDisabled"] = function(self, disabled)
    self.disabled = disabled
    if disabled then
      self.label:SetTextColor(0.5,0.5,0.5)
      for _, button in pairs(self.buttons) do
        button:EnableMouse(false)
      end
    else
      self.label:SetTextColor(1,.82,0)
      for _, button in pairs(self.buttons) do
        button:EnableMouse(true)
      end
    end
  end,
}

local function buttonClicked(self)
  AceGUI:ClearFocus()
  local frame = self:GetParent()
  local widget = frame.obj
  widget:SetValue(self.value)
  widget:Fire("OnValueChanged", self.value)
end

local function Constructor()
  local name = "WeakAurasAnchorButtons" .. AceGUI:GetNextWidgetNum(Type)
  local frame = CreateFrame("Frame", name, UIParent)
  frame:SetSize(frameWidth, frameHeight)
  frame:SetFrameStrata("FULLSCREEN_DIALOG")

  local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall");
  label:SetHeight(titleHeight);
  label:SetJustifyH("CENTER");
  label:SetPoint("TOP", frame, "TOP");

  local background = CreateFrame("Frame", nil, frame, "BackdropTemplate")
  background:SetSize(frameWidth, frameHeight)
  background:SetPoint("TOP", frame, "TOP", 0, -(titleHeight + 4))
  background:SetBackdrop({
     bgFile = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite.tga",
     edgeFile = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite.tga",
     tile = true,
     tileEdge = true,
     --tileSize = 8,
     edgeSize = 2
     --insets = { left = 1, right = 1, top = 1, bottom = 1 },
  })
  background:SetBackdropColor(0.2,0.2,0.2,0.5)
  background:SetBackdropBorderColor(1,1,1,0.6)

  local buttons = {}
  for _, direction in ipairs(directions) do
    local button = CreateFrame("Button", nil, frame)
    button:SetSize(buttonSize, buttonSize)
    button:SetPoint(
      "CENTER",
      background,
      direction
    )

    local buttonTex = button:CreateTexture()
    buttonTex:SetAllPoints()
    buttonTex:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite.tga")
    buttonTex:SetVertexColor(0.3, 0.3, 0.3, 1)
    button:SetNormalTexture(buttonTex)
    button.tex = buttonTex
    button.value = direction

    button:SetScript("OnClick", buttonClicked)
    buttons[direction] = button
  end

  --- @type table<string, any>
  local widget = {
    frame = frame,
    type = Type,
    buttons = buttons,
    label = label
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget);
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasAnchorButtons.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasDisplayButton.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local tinsert, tremove = table.insert, table.remove
local select, pairs, type, unpack = select, pairs, type, unpack
local error = error

local Type, Version = "WeakAurasDisplayButton", 60
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
local LibDD = LibStub:GetLibrary("LibUIDropDownMenu-4.0")

local L = WeakAuras.L;
local fullName;
local clipboard = {};

local function IsRegionAGroup(data)
  return data and (data.regionType == "group" or data.regionType == "dynamicgroup");
end

local ignoreForCopyingDisplay = {
  triggers = true,
  conditions = true,
  load = true,
  actions = true,
  animation = true,
  id = true,
  parent = true,
  controlledChildren = true,
  uid = true,
  authorOptions = true,
  config = true,
  url = true,
  semver = true,
  version = true,
  internalVersion = true,
  tocversion = true
}

local function copyAuraPart(source, destination, part)
  local all = (part == "all");
  if (part == "display" or all) then
    for k, v in pairs(source) do
      if (not ignoreForCopyingDisplay[k]) then
        if (type(v) == "table") then
          destination[k] = CopyTable(v);
        else
          destination[k] = v;
        end
      end
    end
  end
  if (part == "trigger" or all) and not IsRegionAGroup(source) then
    destination.triggers = CopyTable(source.triggers);
  end
  if (part == "condition" or all) and not IsRegionAGroup(source) then
    destination.conditions = CopyTable(source.conditions);
  end
  if (part == "load" or all) and not IsRegionAGroup(source) then
    destination.load = CopyTable(source.load);
  end
  if (part == "action" or all) and not IsRegionAGroup(source) then
    destination.actions = CopyTable(source.actions);
  end
  if (part == "animation" or all) and not IsRegionAGroup(source) then
    destination.animation = CopyTable(source.animation);
  end
  if (part == "authorOptions" or all) and not IsRegionAGroup(source) then
    destination.authorOptions = CopyTable(source.authorOptions);
  end
  if (part == "config" or all) and not IsRegionAGroup(source) then
    destination.config = CopyTable(source.config);
  end

end

local function CopyToClipboard(part, description)
  clipboard.part = part;
  clipboard.pasteText = description;
  clipboard.source = CopyTable(clipboard.current);
end

clipboard.pasteMenuEntry = {
  text = nil, -- Hidden by default
  notCheckable = true,
  func = function()
    if (not IsRegionAGroup(clipboard.source) and IsRegionAGroup(clipboard.current)) then
      -- Copy from a single aura to a group => paste it to each individual aura
      for child in OptionsPrivate.Private.TraverseLeafs(clipboard.current) do
        copyAuraPart(clipboard.source, child, clipboard.part);
        WeakAuras.Add(child)
        WeakAuras.ClearAndUpdateOptions(child.id)
      end
    else
      copyAuraPart(clipboard.source, clipboard.current, clipboard.part);
      WeakAuras.Add(clipboard.current)
      WeakAuras.ClearAndUpdateOptions(clipboard.current.id)
    end

    WeakAuras.FillOptions()
    OptionsPrivate.Private.ScanForLoads({[clipboard.current.id] = true});
    OptionsPrivate.SortDisplayButtons(nil, true);
    WeakAuras.PickDisplay(clipboard.current.id);
    WeakAuras.UpdateThumbnail(clipboard.current.id);
    WeakAuras.ClearAndUpdateOptions(clipboard.current.id);
  end
}

clipboard.copyEverythingEntry = {
  text = L["Everything"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("all", L["Paste Settings"])
  end
};

clipboard.copyGroupEntry = {
  text = L["Group"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("display", L["Paste Group Settings"])
  end
};

clipboard.copyDisplayEntry = {
  text = L["Display"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("display", L["Paste Display Settings"])
  end
};

clipboard.copyTriggerEntry = {
  text = L["Trigger"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("trigger", L["Paste Trigger Settings"])
  end
};

clipboard.copyConditionsEntry = {
  text = L["Conditions"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("condition", L["Paste Condition Settings"])
  end
};

clipboard.copyLoadEntry = {
  text = L["Load"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("load", L["Paste Load Settings"])
  end
};

clipboard.copyActionsEntry = {
  text = L["Actions"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("action", L["Paste Action Settings"])
  end
};

clipboard.copyAnimationsEntry = {
  text = L["Animations"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("animation", L["Paste Animations Settings"])
  end
};

clipboard.copyAuthorOptionsEntry = {
  text = L["Author Options"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("authorOptions", L["Paste Author Options Settings"])
  end
};

clipboard.copyUserConfigEntry = {
  text = L["Custom Configuration"],
  notCheckable = true,
  func = function()
    LibDD:CloseDropDownMenus()
    CopyToClipboard("config", L["Paste Custom Configuration"])
  end
};

local function UpdateClipboardMenuEntry(data)
  clipboard.current = data;

  if (IsRegionAGroup(clipboard.source) and not IsRegionAGroup(clipboard.current)) then
    -- Don't copy from a group to a non group
    clipboard.pasteMenuEntry.text = nil;
  else
    clipboard.pasteMenuEntry.text = clipboard.pasteText;
  end

  if (IsRegionAGroup(clipboard.current)) then
    clipboard.copyEverythingEntry.text = nil;
    clipboard.copyDisplayEntry.text = nil;
    clipboard.copyTriggerEntry.text = nil;
    clipboard.copyConditionsEntry.text = nil;
    clipboard.copyLoadEntry.text = nil;
    clipboard.copyActionsEntry.text = nil;
    clipboard.copyAnimationsEntry.text = nil;
    clipboard.copyAuthorOptionsEntry = nil;
    clipboard.copyUserConfigEntry = nil;
    clipboard.copyGroupEntry.text = L["Group"];
  else
    clipboard.copyEverythingEntry.text = L["Everything"];
    clipboard.copyDisplayEntry.text = L["Display"];
    clipboard.copyTriggerEntry.text = L["Trigger"];
    clipboard.copyConditionsEntry.text = L["Conditions"];
    clipboard.copyLoadEntry.text = L["Load"];
    clipboard.copyActionsEntry.text = L["Actions"];
    clipboard.copyAnimationsEntry.text = L["Animations"];
    clipboard.copyAuthorOptionsEntry = L["Author Options"];
    clipboard.copyUserConfigEntry = L["Custom Configuration"];
    clipboard.copyGroupEntry.text = nil;
  end
end

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:ClearAllPoints()
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

local function Show_Long_Tooltip(owner, description)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:ClearAllPoints()
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  local line = 1;
  for i,v in pairs(description) do
    if(type(v) == "string") then
      if(line > 1) then
        GameTooltip:AddLine(v, 1, 1, 1, 1);
      else
        GameTooltip:AddLine(v);
      end
    elseif(type(v) == "table") then
      if(i == 1) then
        GameTooltip:AddDoubleLine(v[1], v[2]..(v[3] and (" |T"..v[3]..":12:12:0:0:64:64:4:60:4:60|t") or ""));
      else
        GameTooltip:AddDoubleLine(v[1], v[2]..(v[3] and (" |T"..v[3]..":12:12:0:0:64:64:4:60:4:60|t") or ""),
                                  1, 1, 1, 1, 1, 1, 1, 1);
      end
    end
    line = line + 1;
  end
  GameTooltip:Show();
end

local function ensure(t, k, v)
  return t and k and v and t[k] == v
end

local statusIconPool = CreateFramePool("Button")

--[[     Actions     ]]--

local Actions = {
  -- move source into group or top-level list / optionally place it before or after target
  ["Group"] = function(source, groupId, target, before)
    if source and not source.data.parent then
      if groupId then
        local group = OptionsPrivate.GetDisplayButton(groupId)
        if group and group:IsGroup() then
          local children = group.data.controlledChildren
          if target then
            local index = target:GetGroupOrder()
            if ensure(children, index, target.data.id) then
              -- account for insert position
              index = before and index or index+1
              tinsert(children, index, source.data.id)
            else
              error("Calling 'Group' with invalid target. Reload your UI to fix the display list.")
            end
          else
            -- move source into group as the first child
            tinsert(children, 1, source.data.id)
          end
          source:SetGroup(groupId)
          source.data.parent = groupId
          WeakAuras.Add(source.data)
          WeakAuras.Add(group.data)
          OptionsPrivate.Private.AddParents(group.data)
          WeakAuras.UpdateGroupOrders(group.data)
          WeakAuras.ClearAndUpdateOptions(group.data.id)
          WeakAuras.ClearAndUpdateOptions(source.data.id)
          group.callbacks.UpdateExpandButton();
          group:UpdateParentWarning()
          group:ReloadTooltip()
        else
          WeakAuras.Add(source.data)
          WeakAuras.ClearAndUpdateOptions(source.data.id)
        end
      else
        -- move source into the top-level list
        WeakAuras.Add(source.data)
        WeakAuras.ClearAndUpdateOptions(source.data.id)
      end
    else
      error("Calling 'Group' with invalid source. Reload your UI to fix the display list.")
    end
  end,
  -- remove source from its group or top-level list
  ["Ungroup"] =  function(source)
    if source and source.data.parent then
      local parent = WeakAuras.GetData(source.data.parent)
      local children = parent.controlledChildren
      local index = source:GetGroupOrder()
      if ensure(children, index, source.data.id) then
        tremove(children, index)
        source:SetGroup()
        source.data.parent = nil
        WeakAuras.Add(parent);
        OptionsPrivate.Private.AddParents(parent)
        WeakAuras.UpdateGroupOrders(parent);
        WeakAuras.ClearAndUpdateOptions(parent.id);
        local group = OptionsPrivate.GetDisplayButton(parent.id)
        group.callbacks.UpdateExpandButton();
        group:UpdateParentWarning()
        group:ReloadTooltip()
      else
        error("Display thinks it is a member of a group which does not control it")
      end
    else
      error("Calling 'Ungroup' with invalid source. Reload your UI to fix the display list.")
    end
  end
}


local function GetAction(target, area)
  if target and area then
    if area == "GROUP" then
      return function(_source, _target)
        if _source.data.parent then
          Actions["Ungroup"](_source)
        end
        Actions["Group"](_source, _target.data.id)
      end
    else -- BEFORE or AFTER
      -- Insert into target's parent, at the right position
      if target.data.parent then
        return function(_source, _target)
          if _source.data.parent then
            Actions["Ungroup"](_source)
          end
          Actions["Group"](_source, _target.data.parent, _target, area == "BEFORE")
        end
      end
    end
  end
end

-------------------------

local function GetDropTarget()
  local buttonList = OptionsPrivate.displayButtons

  for id, button in pairs(buttonList) do
    if not button.dragging and button:IsEnabled() and button:IsShown() then
      local halfHeight = button.frame:GetHeight() / 2
      local height = button.frame:GetHeight()
      if button.data.controlledChildren then
        if button.data.parent == nil and button.frame:IsMouseOver(1, -1) then
          -- Top level group, always group into
          return id, button, "GROUP"
        end

        -- For sub groups, middle third is for grouping
        if button.frame:IsMouseOver(-height / 3, height / 3) then
          return id, button, "GROUP"
        end
      end

      if button.frame:IsMouseOver(1, height / 2) then
        return id, button, "BEFORE"
      elseif button.frame:IsMouseOver(-height / 2, -1) then
        return id, button, "AFTER"
      end
    end
  end
end

local function Show_DropIndicator(id)
  local indicator = OptionsPrivate.DropIndicator()
  local source = OptionsPrivate.GetDisplayButton(id)
  local target, pos
  if source then
    target, pos = select(2, GetDropTarget())
  end
  local action = GetAction(target, pos)
  if action then
    indicator:ShowAction(target, pos)
  else
    indicator:Hide()
  end
end

-- WORKAROUND
-- Blizzard in its infinite wisdom did:
-- * Force enable the profanity filter for the chinese region
-- * Add a realm name's part to the profanity filter
local function ObfuscateName(name)
  if (GetCurrentRegion() == 5) then
    local result = ""
    for i = 1, #name do
      local b = name:byte(i)
      if (b >= 196 and i ~= 1) then
        -- UTF8 Start byte
        result = result .. string.char(46, b)
      else
        result = result .. string.char(b)
      end
    end
    return result
  else
    return name
  end
end

local function IsParentRecursive(needle, parent)
  if needle.id == parent.id then
    return true
  end
  if needle.parent then
    local needleParent = WeakAuras.GetData(needle.parent)
    return IsParentRecursive(needleParent, parent)
  end
end

local tabsForWarning = {
  tts_condition = "conditions",
  sound_condition = "conditions",
  tts_action = "action",
  sound_action = "action",
  spammy_event_warning = "trigger"
}

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(1000);
    self:SetHeight(32);
    self.hasThumbnail = false
    self.first = false
    self.last = false
  end,
  ["Initialize"] = function(self)
    self.callbacks = {};

    function self.callbacks.OnClickNormal(_, mouseButton)
      if(IsControlKeyDown() and not self.data.controlledChildren) then
        if (OptionsPrivate.IsDisplayPicked(self.data.id)) then
          OptionsPrivate.ClearPick(self.data.id);
        else
          OptionsPrivate.PickDisplayMultiple(self.data.id);
        end
        self:ReloadTooltip();
      elseif(IsShiftKeyDown()) then
        local editbox = GetCurrentKeyBoardFocus();
        if(editbox) then
          if (not fullName) then
            local name, realm = UnitFullName("player")
            if realm then
              fullName = name.."-".. ObfuscateName(realm)
            else
              fullName = name
            end
          end

          if not (GetCurrentRegion() == 5 or GetLocale() == "zhCN") then -- China region (5), and chinese locale profanity filter doesn't allow links in chat
            local url = ""
            if self.data.url then
              url = " ".. self.data.url
            end
            editbox:Insert("[WeakAuras: "..fullName.." - "..self.data.id.."]"..url)
          else
            editbox:Insert("[WeakAuras: "..fullName.." - "..self.data.id.."]")
          end

          OptionsPrivate.Private.linked = OptionsPrivate.Private.linked or {}
          OptionsPrivate.Private.linked[self.data.id] = GetTime()
        elseif not self.data.controlledChildren then
          -- select all buttons between 1st select and current
          OptionsPrivate.PickDisplayMultipleShift(self.data.id)
        end
      else
        if(mouseButton == "RightButton") then
          Hide_Tooltip();
          if(OptionsPrivate.IsDisplayPicked(self.data.id) and OptionsPrivate.IsPickedMultiple()) then
            LibDD:EasyMenu(OptionsPrivate.MultipleDisplayTooltipMenu(), WeakAuras_DropDownMenu, self.frame, 0, 0, "MENU");
          else
            UpdateClipboardMenuEntry(self.data);
            LibDD:EasyMenu(self.menu, WeakAuras_DropDownMenu, self.frame, 0, 0, "MENU");
            if not(OptionsPrivate.IsDisplayPicked(self.data.id)) then
              if self.data.controlledChildren then
                WeakAuras.PickDisplay(self.data.id, "group")
              else
                WeakAuras.PickDisplay(self.data.id);
              end
            end
          end
        else
          if (OptionsPrivate.IsDisplayPicked(self.data.id)) then
            OptionsPrivate.ClearPicks();
          else
            if self.data.controlledChildren then
              WeakAuras.PickDisplay(self.data.id, "group")
            else
              WeakAuras.PickDisplay(self.data.id);
            end
          end
          self:ReloadTooltip();
        end
      end
    end

    function self.callbacks.UpdateExpandButton()
      if(not self.data.controlledChildren or #self.data.controlledChildren == 0) then
        self:DisableExpand();
      else
        self:EnableExpand();
      end
    end


    function self.callbacks.OnClickGrouping()
      if (WeakAuras.IsImporting()) then return end;
      for index, selectedId in ipairs(self.grouping) do
        local selectedData = WeakAuras.GetData(selectedId);
        tinsert(self.data.controlledChildren, selectedId);
        local selectedButton = OptionsPrivate.GetDisplayButton(selectedId);
        while selectedData.parent do
          selectedButton:Ungroup();
        end
        selectedButton:SetGroup(self.data.id, self.data.regionType == "dynamicgroup");
        selectedButton:SetGroupOrder(#self.data.controlledChildren, #self.data.controlledChildren);
        selectedData.parent = self.data.id;
        if (self.data.regionType == "dynamicgroup") then
          selectedData.xOffset = 0
          selectedData.yOffset = 0
        end
        WeakAuras.Add(selectedData);
        OptionsPrivate.ClearOptions(selectedId)

        if (selectedData.controlledChildren) then
          for child in OptionsPrivate.Private.TraverseAllChildren(selectedData) do
            local childButton = OptionsPrivate.GetDisplayButton(child.id)
            childButton:UpdateOffset()
          end
        end
      end

      WeakAuras.Add(self.data);
      OptionsPrivate.Private.AddParents(self.data)
      self.callbacks.UpdateExpandButton();
      self:UpdateParentWarning();
      OptionsPrivate.StopGrouping();
      OptionsPrivate.ClearOptions(self.data.id);
      WeakAuras.FillOptions();
      WeakAuras.UpdateGroupOrders(self.data);
      OptionsPrivate.SortDisplayButtons();
      self:ReloadTooltip();
      self:Expand()
      OptionsPrivate.ResetMoverSizer();
    end

    function self.callbacks.OnClickGroupingSelf()
      OptionsPrivate.StopGrouping();
      self:ReloadTooltip();
    end

    function self.callbacks.OnGroupClick()
      OptionsPrivate.StartGrouping(self.data);
    end

    local function addParents(hash, data)
      local parent = data.parent
      if parent then
        hash[parent] = true
        local parentData = WeakAuras.GetData(parent)
        if parentData then
          addParents(hash, parentData)
        end
      end
    end

    function self.callbacks.OnDeleteClick()
      if (WeakAuras.IsImporting()) then return end;
      local toDelete = {self.data}
      local parents = {}
      addParents(parents, self.data)
      OptionsPrivate.ConfirmDelete(toDelete, parents)
    end

    local function DuplicateGroups(sourceParent, targetParent, mapping)
      for index, childId in pairs(sourceParent.controlledChildren) do
        local childData = WeakAuras.GetData(childId)
        if childData.controlledChildren then
          local newChildGroup = OptionsPrivate.DuplicateAura(childData, targetParent.id)
          mapping[childData] = newChildGroup
          DuplicateGroups(childData, newChildGroup, mapping)
        end
      end
    end

    local function DuplicateAuras(sourceParent, targetParent, mapping)
      for index, childId in pairs(sourceParent.controlledChildren) do
        local childData = WeakAuras.GetData(childId)
        if childData.controlledChildren then
          DuplicateAuras(childData, mapping[childData], mapping)
        else
          OptionsPrivate.DuplicateAura(childData, targetParent.id, true, index)
        end
      end
    end

    function self.callbacks.OnDuplicateClick()
      if (WeakAuras.IsImporting()) then return end;
      if self.data.controlledChildren then
        local newGroup = OptionsPrivate.DuplicateAura(self.data)

        local mapping = {}
        -- This builds the group skeleton
        DuplicateGroups(self.data, newGroup, mapping)
        -- Do this after duplicating all groups
        local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
        -- And this fills in the leafs
        DuplicateAuras(self.data, newGroup, mapping)

        local button = OptionsPrivate.GetDisplayButton(newGroup.id)
        button.callbacks.UpdateExpandButton()
        button:UpdateParentWarning()

        for old, new in pairs(mapping) do
          local button = OptionsPrivate.GetDisplayButton(new.id)
          button.callbacks.UpdateExpandButton()
          button:UpdateParentWarning()
        end

        OptionsPrivate.SortDisplayButtons(nil, true)
        OptionsPrivate.PickAndEditDisplay(newGroup.id)

        OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
      else
        local new = OptionsPrivate.DuplicateAura(self.data)
        OptionsPrivate.SortDisplayButtons(nil, true)
        OptionsPrivate.PickAndEditDisplay(new.id)
      end
    end

    function self.callbacks.OnDeleteAllClick()
      if (WeakAuras.IsImporting()) then return end;
      local toDelete = {}
      if(self.data.controlledChildren) then
        for child in OptionsPrivate.Private.TraverseAllChildren(self.data) do
          tinsert(toDelete, child);
        end
      end
      tinsert(toDelete, self.data)
      local parents = {}
      addParents(parents, self.data)
      OptionsPrivate.ConfirmDelete(toDelete, parents);
    end

    function self.callbacks.OnUngroupClick()
      OptionsPrivate.Ungroup(self.data);
    end

    function self.callbacks.OnUpGroupClick()
      if (WeakAuras.IsImporting()) then return end;
      if(self.data.parent) then
        local id = self.data.id;
        local parentData = WeakAuras.GetData(self.data.parent);
        local index;
        for childIndex, childId in pairs(parentData.controlledChildren) do
          if(childId == id) then
            index = childIndex;
            break;
          end
        end
        if(index) then
          if(index <= 1) then
            error("Attempt to move up the first element in a group");
          else
            tremove(parentData.controlledChildren, index);
            tinsert(parentData.controlledChildren, index - 1, id);
            WeakAuras.Add(parentData);
            OptionsPrivate.Private.AddParents(parentData)
            WeakAuras.ClearAndUpdateOptions(parentData.id)
            self:SetGroupOrder(index - 1, #parentData.controlledChildren);
            local otherbutton = OptionsPrivate.GetDisplayButton(parentData.controlledChildren[index]);
            otherbutton:SetGroupOrder(index, #parentData.controlledChildren);
            OptionsPrivate.SortDisplayButtons();
            local updata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = -32};
            local downdata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = 32};
            OptionsPrivate.Private.Animate("button", WeakAuras.GetData(parentData.controlledChildren[index-1]).uid, "main", updata, self.frame, true, function() OptionsPrivate.SortDisplayButtons() end);
            OptionsPrivate.Private.Animate("button", WeakAuras.GetData(parentData.controlledChildren[index]).uid, "main", downdata, otherbutton.frame, true, function() OptionsPrivate.SortDisplayButtons() end);
            WeakAuras.FillOptions()
          end
        else
          error("Display thinks it is a member of a group which does not control it");
        end
      else
        error("This display is not in a group. You should not have been able to click this button");
      end
    end

    function self.callbacks.OnDownGroupClick()
      if (WeakAuras.IsImporting()) then return end;
      if(self.data.parent) then
        local id = self.data.id;
        local parentData = WeakAuras.GetData(self.data.parent);
        local index;
        for childIndex, childId in pairs(parentData.controlledChildren) do
          if(childId == id) then
            index = childIndex;
            break;
          end
        end
        if(index) then
          if(index >= #parentData.controlledChildren) then
            error("Attempt to move down the last element in a group");
          else
            tremove(parentData.controlledChildren, index);
            tinsert(parentData.controlledChildren, index + 1, id);
            WeakAuras.Add(parentData);
            OptionsPrivate.Private.AddParents(parentData)
            WeakAuras.ClearAndUpdateOptions(parentData.id)
            self:SetGroupOrder(index + 1, #parentData.controlledChildren);
            local otherbutton = OptionsPrivate.GetDisplayButton(parentData.controlledChildren[index]);
            otherbutton:SetGroupOrder(index, #parentData.controlledChildren);
            OptionsPrivate.SortDisplayButtons()
            local updata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = -32};
            local downdata = {duration = 0.15, type = "custom", use_translate = true, x = 0, y = 32};
            OptionsPrivate.Private.Animate("button", WeakAuras.GetData(parentData.controlledChildren[index+1]).uid, "main", downdata, self.frame, true, function() OptionsPrivate.SortDisplayButtons() end);
            OptionsPrivate.Private.Animate("button", WeakAuras.GetData(parentData.controlledChildren[index]).uid, "main", updata, otherbutton.frame, true, function() OptionsPrivate.SortDisplayButtons() end);
            WeakAuras.FillOptions()
          end
        else
          error("Display thinks it is a member of a group which does not control it");
        end
      else
        error("This display is not in a group. You should not have been able to click this button");
      end
    end

    function self.callbacks.OnViewClick()
      local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
      if(self.view.visibility == 2) then
        for child in OptionsPrivate.Private.TraverseAllChildren(self.data) do
          OptionsPrivate.GetDisplayButton(child.id):PriorityHide(2);
        end
        self:PriorityHide(2)
      else
        for child in OptionsPrivate.Private.TraverseAllChildren(self.data) do
          OptionsPrivate.GetDisplayButton(child.id):PriorityShow(2);
        end
        self:PriorityShow(2)
      end
      self:RecheckParentVisibility()
      OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
    end

    function self.callbacks.OnRenameClick()
      if (WeakAuras.IsImporting()) then return end;
      if(self.title:IsVisible()) then
        self.title:Hide();
        self.renamebox:SetText(self.title:GetText());
        self.renamebox:Show();
      else
        self.title:Show();
        self.renamebox:Hide();
      end
    end

    function self.callbacks.OnRenameAction(newid)
      if (WeakAuras.IsImporting()) then return end;
      local oldid = self.data.id;
      if not(newid == oldid) then
        WeakAuras.Rename(self.data, newid);
      end
      self:UpdateParentWarning()
    end

    function self.callbacks.OnDragStart()
      if WeakAuras.IsImporting() then return end;
      if not OptionsPrivate.IsDisplayPicked(self.data.id) then
        WeakAuras.PickDisplay(self.data.id)
      end
      OptionsPrivate.StartDrag(self.data);
    end

    function self.callbacks.OnDragStop()
      if not self.dragging then return end
      local target, area = select(2, GetDropTarget())
      local action = GetAction(target, area)
      OptionsPrivate.Drop(self.data, target, action, area)
    end

    function self.callbacks.OnKeyDown(self, key)
      if (key == "ESCAPE") then
        OptionsPrivate.DragReset()
      end
    end

    self.frame:SetScript("OnEnter", function()
      if(OptionsPrivate.IsPickedMultiple() and OptionsPrivate.IsDisplayPicked(self.frame.id)) then
        Show_Long_Tooltip(self.frame, OptionsPrivate.MultipleDisplayTooltipDesc());
      else
        if not self.grouping then
          self:SetNormalTooltip();
        end
        Show_Long_Tooltip(self.frame, self.frame.description);
      end
    end);
    self.frame:SetScript("OnLeave", Hide_Tooltip);

    local copyEntries = {};
    tinsert(copyEntries, clipboard.copyEverythingEntry);
    tinsert(copyEntries, clipboard.copyGroupEntry);
    tinsert(copyEntries, clipboard.copyDisplayEntry);
    tinsert(copyEntries, clipboard.copyTriggerEntry);
    tinsert(copyEntries, clipboard.copyConditionsEntry);
    tinsert(copyEntries, clipboard.copyLoadEntry);
    tinsert(copyEntries, clipboard.copyActionsEntry);
    tinsert(copyEntries, clipboard.copyAnimationsEntry);
    tinsert(copyEntries, clipboard.copyAuthorOptionsEntry);
    tinsert(copyEntries, clipboard.copyUserConfigEntry);

    self:SetTitle(self.data.id);
    self.menu = {
      {
        text = L["Rename"],
        notCheckable = true,
        func = self.callbacks.OnRenameClick
      },
      {
        text = L["Copy settings..."],
        notCheckable = true,
        hasArrow = true,
        menuList = copyEntries;
      },
    };

    tinsert(self.menu, clipboard.pasteMenuEntry);

    if (not self.data.controlledChildren) then
      local convertMenu = {};
      for regionType, regionData in pairs(OptionsPrivate.Private.regionOptions) do
        if(regionType ~= "group" and regionType ~= "dynamicgroup" and regionType ~= self.data.regionType) then
          tinsert(convertMenu, {
            text = regionData.displayName,
            notCheckable = true,
            func = function()
              OptionsPrivate.ConvertDisplay(self.data, regionType);
              LibDD:CloseDropDownMenus()
            end
          });
        end
      end
      tinsert(self.menu, {
        text = L["Convert to..."],
        notCheckable = true,
        hasArrow = true,
        menuList = convertMenu
      });
    end

    tinsert(self.menu, {
      text = L["Duplicate"],
      notCheckable = true,
      func = self.callbacks.OnDuplicateClick
    });

    tinsert(self.menu, {
      text = L["Export..."],
      notCheckable = true,
      func = function() OptionsPrivate.ExportToString(self.data.id) end
    });
    tinsert(self.menu, {
      text = L["Export debug table..."],
      notCheckable = true,
      func = function() OptionsPrivate.ExportToTable(self.data.id) end
    });

    tinsert(self.menu, {
      text = " ",
      notClickable = true,
      notCheckable = true,
    });
    if not self.data.controlledChildren then
      tinsert(self.menu, {
        text = L["Delete"],
        notCheckable = true,
        func = self.callbacks.OnDeleteClick
      });
    end

    if (self.data.controlledChildren) then
      tinsert(self.menu, {
        text = L["Delete children and group"],
        notCheckable = true,
        func = self.callbacks.OnDeleteAllClick
      });
    end
    tinsert(self.menu, {
      text = " ",
      notClickable = true,
      notCheckable = true,
    });
    tinsert(self.menu, {
      text = L["Close"],
      notCheckable = true,
      func = function() LibDD:CloseDropDownMenus() end
    });
    if(self.data.controlledChildren) then
      self.expand:Show();
      self.callbacks.UpdateExpandButton();
      self:SetOnExpandCollapse(function() OptionsPrivate.SortDisplayButtons(nil, true) end);
    else
      self.expand:Hide();
    end
    self.group:Show();

    self:SetNormalTooltip();
    self.frame:SetScript("OnClick", self.callbacks.OnClickNormal);
    self.frame:SetScript("OnKeyDown", self.callbacks.OnKeyDown);
    self.frame:EnableKeyboard(false);
    self.frame:SetMovable(true);
    self.frame:RegisterForDrag("LeftButton");
    self.frame:SetScript("OnDragStart", self.callbacks.OnDragStart);
    self.frame:SetScript("OnDragStop", self.callbacks.OnDragStop);

    self:Enable();
    self:SetRenameAction(self.callbacks.OnRenameAction);
    self.group:SetScript("OnClick", self.callbacks.OnGroupClick);
    self.ungroup:SetScript("OnClick", self.callbacks.OnUngroupClick);
    self.upgroup:SetScript("OnClick", self.callbacks.OnUpGroupClick);
    self.downgroup:SetScript("OnClick", self.callbacks.OnDownGroupClick);
    self.view:SetScript("OnClick", self.callbacks.OnViewClick);

    if self.data.parent then
      local parentData = WeakAuras.GetData(self.data.parent);
      local index;
      for childIndex, childId in pairs(parentData.controlledChildren) do
        if(childId == self.data.id) then
          index = childIndex;
          break;
        end
      end
      if(index) then
        self:SetGroup(self.data.parent);
        self:SetGroupOrder(index, #parentData.controlledChildren);
      else
        error("Display \""..self.data.id.."\" thinks it is a member of group \""..self.data.parent.."\" which does not control it");
      end
    end

    self.frame:Hide()
  end,
  ["SetNormalTooltip"] = function(self)
    local data = self.data;
    local namestable = {};
    if(data.controlledChildren) then
      namestable[1] = "";
      local function addChildrenNames(data, indent)
        for index, childId in pairs(data.controlledChildren) do
          tinsert(namestable, indent .. childId);
          local childData = WeakAuras.GetData(childId)
          if not childData then
            return
          end
          if (childData.controlledChildren) then
            addChildrenNames(childData, indent .. "  ")
          end
        end
      end
      addChildrenNames(data, "  ")

      if (#namestable > 30) then
        local size = #namestable;
        namestable[26] = {" ", "[...]"};
        namestable[27] = {L[string.format(L["%s total auras"], #namestable)], " " }
        for i = 28, size do
          namestable[i] = nil;
        end
      end

      if(#namestable > 1) then
        namestable[1] = L["Children:"];
      else
        namestable[1] = L["No Children"];
      end
    else
      OptionsPrivate.Private.GetTriggerDescription(data, -1, namestable)
    end

    local hasDescription = data.desc and data.desc ~= "";
    local hasUrl = data.url and data.url ~= "";
    local hasVersion = (data.semver and data.semver ~= "") or (data.version and data.version ~= "");

    if(hasDescription or hasUrl or hasVersion) then
      tinsert(namestable, " ");
    end

    if(hasDescription) then
      tinsert(namestable, "|cFFFFD100\""..data.desc.."\"");
    end

    if (hasUrl) then
      tinsert(namestable, "|cFFFFD100" .. data.url .. "|r");
    end

    if (hasVersion) then
      tinsert(namestable, "|cFFFFD100" .. L["Version: "]  .. (data.semver or data.version) .. "|r");
    end

    tinsert(namestable, " ");
    tinsert(namestable, {" ", "|cFF00FFFF"..L["Right-click for more options"]});
    tinsert(namestable, {" ", "|cFF00FFFF"..L["Drag to move"]});
    if not(data.controlledChildren) then
      tinsert(namestable, {" ", "|cFF00FFFF"..L["Control-click to select multiple displays"]});
    end
    tinsert(namestable, {" ", "|cFF00FFFF"..L["Shift-click to create chat link"]});
    local regionData = OptionsPrivate.Private.regionOptions[data.regionType or ""]
    local displayName = regionData and regionData.displayName or "";
    self:SetDescription({data.id, displayName}, unpack(namestable));
  end,
  ["ReloadTooltip"] = function(self)
    if(OptionsPrivate.IsPickedMultiple() and OptionsPrivate.IsDisplayPicked(self.data.id)) then
      Show_Long_Tooltip(self.frame, OptionsPrivate.MultipleDisplayTooltipDesc());
    else
      Show_Long_Tooltip(self.frame, self.frame.description);
    end
  end,
  ["StartGrouping"] = function(self, groupingData, selected, groupingGroup, childOfGrouping)
    self.grouping = groupingData;
    self:UpdateIconsVisible()
    if(selected) then
      self.frame:SetScript("OnClick", self.callbacks.OnClickGroupingSelf);
      self:SetDescription(L["Cancel"], L["Do not group this display"]);
    elseif (childOfGrouping) then
      self:Disable();
    else
      if(self.data.regionType == "dynamicgroup" and groupingGroup) then
        self:Disable();
      elseif (self.data.regionType == "group" or self.data.regionType == "dynamicgroup") then
        self.frame:SetScript("OnClick", self.callbacks.OnClickGrouping);
        self:SetDescription(self.data.id, L["Add to group %s"]:format(self.data.id));
      else
        self:Disable();
      end
    end
  end,
  ["StopGrouping"] = function(self)
    if self.grouping then
      self.grouping = nil
      self:UpdateIconsVisible()
      self:SetNormalTooltip()
      self.frame:SetScript("OnClick", self.callbacks.OnClickNormal)
      self:Enable()
    end
  end,
  ["Ungroup"] = function(self)
    if (WeakAuras.IsImporting()) then return end;
    local parentData = WeakAuras.GetData(self.data.parent);
    if not parentData then return end;
    local index = tIndexOf(parentData.controlledChildren, self.data.id);
    if(index) then
      tremove(parentData.controlledChildren, index);
      WeakAuras.Add(parentData);
      OptionsPrivate.Private.AddParents(parentData)
      WeakAuras.ClearAndUpdateOptions(parentData.id);
    else
      error("Display thinks it is a member of a group which does not control it");
    end

    local newParent = parentData.parent and WeakAuras.GetData(parentData.parent)
    if newParent then
      local insertIndex = tIndexOf(newParent.controlledChildren, parentData.id)
      if not insertIndex then
        error("Parent Display thinks it is a member of a group which does not control it");
      end
      insertIndex = insertIndex + 1
      tinsert(newParent.controlledChildren, insertIndex, self.data.id)
    end

    self:SetGroup(newParent and newParent.id);
    self.data.parent = newParent and newParent.id;
    WeakAuras.Add(self.data);
    self:UpdateIconsVisible()
    if newParent then
      WeakAuras.Add(newParent)
      OptionsPrivate.Private.AddParents(newParent)
      WeakAuras.ClearAndUpdateOptions(newParent.id)
      WeakAuras.UpdateGroupOrders(newParent)
    end
    WeakAuras.ClearAndUpdateOptions(self.data.id);
    WeakAuras.UpdateGroupOrders(parentData);
    local parentButton = OptionsPrivate.GetDisplayButton(parentData.id)
    if(#parentData.controlledChildren == 0) then
      parentButton:DisableExpand()
    end
    parentButton:UpdateParentWarning()

    for child in OptionsPrivate.Private.TraverseAllChildren(self.data) do
      local button = OptionsPrivate.GetDisplayButton(child.id)
      button:UpdateOffset()
    end

    OptionsPrivate.SortDisplayButtons();
  end,
  ["UpdateIconsVisible"] = function(self)
    if self.dragging or self.grouping then
      self.downgroup:Hide()
      self.group:Hide()
      self.ungroup:Hide()
      self.upgroup:Hide()
    else
      self.group:Show()
      if self.data.parent then
        self.downgroup:Show()
        self.ungroup:Show()
        self.upgroup:Show()
      else
        self.downgroup:Hide()
        self.ungroup:Hide()
        self.upgroup:Hide()
      end
    end
  end,
  ["DragStart"] = function(self, mode, picked, mainAura, size)
    self.frame:SetScript("OnClick", nil)
    self.view:Hide()
    self.expand:Hide()
    self.statusIcons:Hide()
    Hide_Tooltip()
    if picked then
      self.frame:EnableKeyboard(true)
      local uiscale, scale = UIParent:GetScale(), self.frame:GetEffectiveScale()
      local x, w = self.frame:GetLeft(), self.frame:GetWidth()
      local _, y = GetCursorPosition()
      -- mark as being dragged, attach to mouse and raise frame strata
      self.dragging = true
      self.frame:StartMoving()
      self.frame:ClearAllPoints()
      self.frame.temp = {
        parent = self.frame:GetParent(),
        strata = self.frame:GetFrameStrata(),
      }
      self.frame:SetParent(UIParent)
      self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
      if self.data.id == mainAura.id then
        self.frame:SetPoint("Center", UIParent, "BOTTOMLEFT", (x+w/2)*scale/uiscale, y/uiscale)
        if mode == "MULTI" then
          -- change label & icon
          self.frame:SetPoint("Center", UIParent, "BOTTOMLEFT", (x+w/2)*scale/uiscale, y/uiscale)
          self.frame.temp.title = self.title:GetText()
          self.title:SetText((L["%i auras selected"]):format(size))
          self:OverrideIcon();
        end
      else
        -- Hide frames
        self.frame:StopMovingOrSizing()
        self.frame:Hide()
      end
      -- attach OnUpdate event to update drop indicator
      if self.data.id == mainAura.id then
        local id = self.data.id
        self.frame:SetScript("OnUpdate", function(self,elapsed)
          self.elapsed = (self.elapsed or 0) + elapsed
          if self.elapsed > 0.1 then
            Show_DropIndicator(id)
            self.elapsed = 0
          end
        end)
        Show_DropIndicator(id)
      end
      self:UpdateIconsVisible()
    else
      -- Are we a valid target?
      -- Top level auras that aren't groups aren't
      if not self.data.parent and not self:IsGroup() then
        self:Disable()
      end

      -- If we are dragging a group, dynamic groups aren't valid targets
      if mode == "GROUP" then
        if self.data.regionType == "dynamicgroup" then
          self:Disable()
        else
          local parentData = self.data.parent and WeakAuras.GetData(self.data.parent)
          if (parentData and parentData.regionType == "dynamicgroup") then
            self:Disable()
          end
        end
      end
    end
  end,
  ["Drop"] = function(self, mode, mainAura, target, func)
    if mode == "MULTI" or mode == "SINGLE" then
      if self.dragging then
        if func and target then
          func(self, target)
        end
      end
    elseif mode == "GROUP" then
      if mainAura.id == self.data.id then
        if func and target then
          func(self, target)
        end
      end
    end
    self:DropEnd()
  end,
  ["IsDragging"] = function(self)
    return self.dragging
  end,
  ["DragReset"] = function(self)
    self:DropEnd()
  end,
  ["DropEnd"] = function(self)
    Show_DropIndicator()

    self.frame:SetScript("OnClick", self.callbacks.OnClickNormal)
    self.frame:EnableKeyboard(false); -- disables self.callbacks.OnKeyDown
    self.view:Show()
    self.statusIcons:Show()
    if self.data.controlledChildren then
      self.expand:Show()
    end
    self:Enable()

    -- get action and execute it
    self.frame:StopMovingOrSizing()
    self.frame:SetScript("OnUpdate", nil)
    if self.dragging then
      if self.frame.temp.title then
        -- restore title and icon
        self.title:SetText(self.frame.temp.title)
        self:RestoreIcon();
      end
      self.frame:SetParent(self.frame.temp.parent)
      self.frame:SetFrameStrata(self.frame.temp.strata)
      self.frame.temp = nil
    end
    self.dragging = false
    self:UpdateIconsVisible()
  end,
  ["ShowTooltip"] = function(self)
  end,
  ["UpdateOffset"] = function(self)
    local group = self.frame.dgroup
    if group then
      local depth = 0
      while(group) do
        depth = depth + 1
        group = WeakAuras.GetData(group).parent
      end
      self.offset:SetWidth(depth * 8 + 1)
    else
      self.offset:SetWidth(1)
    end
  end,
  ["GetOffset"] = function(self)
    return self.offset:GetWidth()
  end,
  ["GetGroupOrCopying"] = function(self)
    return self.group;
  end,
  ["SetTitle"] = function(self, title)
    self.titletext = title;
    self.title:SetText(title);
  end,
  ["GetTitle"] = function(self)
    return self.titletext;
  end,
  ["SetDescription"] = function(self, ...)
    self.frame.description = {...};
  end,
  ["SetRenameAction"] = function(self, func)
    self.renamebox.func = function()
      func(self.renamebox:GetText());
    end
  end,
  ["EnableGroup"] = function(self)

  end,
  ["SetIds"] = function(self, ids)
    self.renamebox.ids = ids;
  end,
  ["SetGroup"] = function(self, group)
    self.frame.dgroup = group;
    if(group) then
      self.icon:SetPoint("LEFT", self.ungroup, "RIGHT");
      self.background:SetPoint("LEFT", self.offset, "RIGHT");
    else
      self.icon:SetPoint("LEFT", self.frame, "LEFT");
      self.background:SetPoint("LEFT", self.frame, "LEFT");
    end
    self:UpdateIconsVisible()
    self:UpdateOffset()
  end,
  ["GetGroup"] = function(self)
    return self.frame.dgroup;
  end,
  ["IsGroup"] = function(self)
    return self.data.regionType == "group" or self.data.regionType == "dynamicgroup"
  end,
  ["SetData"] = function(self, data)
    self.data = data;
    self.frame.id = data.id;
  end,
  ["GetData"] = function(self)
    return self.data;
  end,
  ["Expand"] = function(self, reloadTooltip)
    self.expand:Enable();
    OptionsPrivate.SetCollapsed(self.data.id, "displayButton", "", false)
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-MinusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-MinusButton-Down.blp");
    self.expand.title = L["Collapse"];
    self.expand.desc = L["Hide this group's children"];
    self.expand:SetScript("OnClick", function() self:Collapse(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
    end
  end,
  ["Collapse"] = function(self, reloadTooltip)
    self.expand:Enable();
    OptionsPrivate.SetCollapsed(self.data.id, "displayButton", "", true)
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-PlusButton-Down.blp");
    self.expand.title = L["Expand"];
    self.expand.desc = L["Show this group's children"];
    self.expand:SetScript("OnClick", function() self:Expand(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
    end
  end,
  ["SetOnExpandCollapse"] = function(self, func)
    self.expand.func = func;
  end,
  ["GetExpanded"] = function(self)
    return not OptionsPrivate.IsCollapsed(self.data.id, "displayButton", "", true)
  end,
  ["DisableExpand"] = function(self)
    if self.expand.disabled then
      return
    end
    self.expand:Disable();
    self.expand.disabled = true;
    self.expand.expanded = false;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  end,
  ["EnableExpand"] = function(self)
    if not self.expand.disabled then
      return
    end
    self.expand.disabled = false;
    if(self:GetExpanded()) then
      self:Expand();
    else
      self:Collapse();
    end
  end,
  ["UpdateStatusIcon"] = function(self, key, prio, icon, title, tooltip, onClick)
    local iconButton
    for _, button in ipairs(self.statusIcons.buttons) do
      if button.key == key then
        iconButton = button
        break
      end
    end
    if not iconButton then
      iconButton = statusIconPool:Acquire()
      iconButton:RegisterForClicks("LeftButtonUp", "RightButtonUp")
      tinsert(self.statusIcons.buttons, iconButton)
      iconButton:SetParent(self.statusIcons)
      iconButton.key = key
      iconButton:SetSize(16, 16)
    end
    iconButton.prio = prio
    if C_Texture.GetAtlasInfo(icon) then
      iconButton:SetNormalAtlas(icon)
    else
      iconButton:SetNormalTexture(icon)
    end
    if title then
      iconButton:SetScript("OnEnter", function()
        Show_Tooltip(
          self.frame,
          title,
          tooltip
        )
      end)
      iconButton:SetScript("OnLeave", Hide_Tooltip)
    else
      iconButton:SetScript("OnEnter", nil)
    end
    iconButton:SetScript("OnClick", onClick)
    iconButton:Show()
  end,
  ["ClearStatusIcon"] = function(self, key)
    for index, button in ipairs(self.statusIcons.buttons) do
      if button.key == key then
        statusIconPool:Release(button)
        table.remove(self.statusIcons.buttons, index)
        return
      end
    end
  end,
  ["SortStatusIcons"] = function(self)
    table.sort(self.statusIcons.buttons, function(a, b)
      return a.prio < b.prio
    end)
    local lastAnchor = self.statusIcons
    if self:IsGroup() then
      self.statusIcons:SetWidth(17)
    else
      self.statusIcons:SetWidth(1)
    end
    for _, button in ipairs(self.statusIcons.buttons) do
      button:ClearAllPoints()
      button:SetPoint("BOTTOMLEFT", lastAnchor, "BOTTOMRIGHT", 4, 0)
      lastAnchor = button
    end
  end,
  ["UpdateWarning"] = function(self)
    local warnings = OptionsPrivate.Private.AuraWarnings.GetAllWarnings(self.data.uid)
    local warningTypes = {"info", "sound", "tts", "warning", "error"}
    for _, key in ipairs(warningTypes) do
      self:ClearStatusIcon(key)
    end
    if warnings then
      for severity, warning in pairs(warnings) do
        local onClick
        if severity == "sound" or severity == "tts" then
          local soundText = L["Show Sound Setting"]
          local removeText = L["Remove All Sounds"]
          if severity == "tts" then
            soundText = L["Show Text To Speech Setting"]
            removeText = L["Remove All Text To Speech"]
          end
          onClick = function()
            MenuUtil.CreateContextMenu(UIParent, function(ownerRegion, root)
              root:CreateButton(soundText, function()
                WeakAuras.PickDisplay(warning.auraId, tabsForWarning[warning.key] or "information")
              end)
              root:CreateButton(removeText, function()
                OptionsPrivate.Private.ClearSounds(self.data.uid, severity)
              end)
            end)
          end
        else
          onClick = function()
            WeakAuras.PickDisplay(warning.auraId, tabsForWarning[warning.key] or "information")
          end
        end

        self:UpdateStatusIcon(severity, warning.prio, warning.icon, warning.title, warning.message, onClick)
      end
    end
    self:SortStatusIcons()
  end,
  ["UpdateParentWarning"] = function(self)
    self:UpdateWarning()
    for parent in OptionsPrivate.Private.TraverseParents(self.data) do
      local parentButton = OptionsPrivate.GetDisplayButton(parent.id)
      if parentButton then
        parentButton:UpdateWarning()
      end
    end
  end,
  ["SetGroupOrder"] = function(self, order, max)
    self.first = (order == 1)
    self.last = (order == max)
    self.frame.dgrouporder = order;
    self:UpdateUpDownButtons()
  end,
  ["UpdateUpDownButtons"] = function(self)
    if self.first or not self:IsEnabled() then
      self.upgroup:Disable();
      self.upgroup.texture:SetVertexColor(0.3, 0.3, 0.3);
    else
      self.upgroup:Enable();
      self.upgroup.texture:SetVertexColor(1, 1, 1);
    end

    if self.last or not self:IsEnabled() then
      self.downgroup:Disable();
      self.downgroup.texture:SetVertexColor(0.3, 0.3, 0.3);
    else
      self.downgroup:Enable();
      self.downgroup.texture:SetVertexColor(1, 1, 1);
    end
  end,
  ["GetGroupOrder"] = function(self)
    return self.frame.dgrouporder;
  end,
  ["ClearLoaded"] = function(self)
    self:ClearStatusIcon("load")
    self:SortStatusIcons()
  end,
  ["SetLoaded"] = function(self, prio, file, title, description)
    self:UpdateStatusIcon("load", prio, "Interface\\AddOns\\WeakAuras\\Media\\Textures\\" .. file, title, description, nil)
    self:SortStatusIcons()
  end,
  ["IsLoaded"] = function(self)
    return OptionsPrivate.Private.loaded[self.data.id] == true
  end,
  ["IsStandby"] = function(self)
    return OptionsPrivate.Private.loaded[self.data.id] == false
  end,
  ["IsUnloaded"] = function(self)
    return OptionsPrivate.Private.loaded[self.data.id] == nil
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
    self:PriorityShow(1);
    self:RecheckParentVisibility()
  end,
  ["ClearPick"] = function(self, noHide)
    self.frame:UnlockHighlight();
    if not noHide then
      self:PriorityHide(1);
      self:RecheckParentVisibility()
    end
  end,
  ["SyncVisibility"] = function(self)
    if (not WeakAuras.IsOptionsOpen()) then
      return;
    end
    if self.view.visibility >= 1 then
      if not OptionsPrivate.Private.IsGroupType(self.data) then
        OptionsPrivate.Private.FakeStatesFor(self.data.id, true)
      end
      if (OptionsPrivate.Private.personalRessourceDisplayFrame) then
        OptionsPrivate.Private.personalRessourceDisplayFrame:expand(self.data.id);
      end
      if (OptionsPrivate.Private.mouseFrame) then
        OptionsPrivate.Private.mouseFrame:expand(self.data.id);
      end
    else
      if not OptionsPrivate.Private.IsGroupType(self.data) then
        OptionsPrivate.Private.FakeStatesFor(self.data.id, false)
      end
      if (OptionsPrivate.Private.personalRessourceDisplayFrame) then
        OptionsPrivate.Private.personalRessourceDisplayFrame:collapse(self.data.id);
      end
      if (OptionsPrivate.Private.mouseFrame) then
        OptionsPrivate.Private.mouseFrame:collapse(self.data.id);
      end
    end
  end,
  ["PriorityShow"] = function(self, priority)
    if (not WeakAuras.IsOptionsOpen()) then
      return;
    end
    if(priority >= self.view.visibility and self.view.visibility ~= priority) then
      self.view.visibility = priority;
      self:SyncVisibility()
      self:UpdateViewTexture()
    end
    local region = OptionsPrivate.Private.EnsureRegion(self.data.id)
    if region and region.ClickToPick then
      region:ClickToPick();
    end
  end,
  ["PriorityHide"] = function(self, priority)
    if (not WeakAuras.IsOptionsOpen()) then
      return;
    end
    if(priority >= self.view.visibility and self.view.visibility ~= 0) then
      self.view.visibility = 0;
      self:SyncVisibility()
      self:UpdateViewTexture()
    end
  end,
  ["RecheckParentVisibility"] = function(self)
    if self.data.parent then
      local parentButton = OptionsPrivate.GetDisplayButton(self.data.parent)
      parentButton:RecheckVisibility()
    else
      OptionsPrivate.Private.OptionsFrame().loadedButton:RecheckVisibility()
      OptionsPrivate.Private.OptionsFrame().unloadedButton:RecheckVisibility()
    end
  end,
  ["RecheckVisibility"] = function(self)
    local none, all = true, true;
    for child in OptionsPrivate.Private.TraverseAllChildren(self.data) do
      local childButton = OptionsPrivate.GetDisplayButton(child.id);
      if(childButton) then
        if(childButton:GetVisibility() ~= 2) then
          all = false;
        end
        if(childButton:GetVisibility() ~= 0) then
          none = false;
        end
      end
    end
    local newVisibility
    if(all) then
      newVisibility = 2;
    elseif(none) then
      newVisibility = 0;
    else
      newVisibility = 1;
    end
    if newVisibility ~= self.view.visibility then
      self.view.visibility = newVisibility
      self:UpdateViewTexture()

      self:RecheckParentVisibility()
    end
  end,
  ["UpdateViewTexture"] = function(self)
    local visibility = self.view.visibility
    if(visibility == 2) then
      self.view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking0.blp");
    elseif(visibility == 1) then
      self.view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking2.blp");
    else
      self.view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking4.blp");
    end
  end,
  ["GetVisibility"] = function(self)
    return self.view.visibility;
  end,
  ["Disable"] = function(self)
    self.background:Hide();
    self.frame:Disable();
    self.view:Disable();
    self.group:Disable();
    self.ungroup:Disable();
    self.expand:Disable();
    for _, button in ipairs(self.statusIcons.buttons) do
      button:Disable();
    end
    self:UpdateUpDownButtons()
  end,
  ["Enable"] = function(self)
    self.background:Show();
    self.frame:Enable();
    self.view:Enable();
    self.group:Enable();
    self.ungroup:Enable();
    for _, button in ipairs(self.statusIcons.buttons) do
      button:Enable();
    end
    self:UpdateUpDownButtons()
    if not(self.expand.disabled) then
      self.expand:Enable();
    end
  end,
  ["IsEnabled"] = function(self)
    return self.frame:IsEnabled();
  end,
  ["OnRelease"] = function(self)
    self:ReleaseThumbnail()
    self:Enable();
    self:SetGroup();
    self.renamebox:Hide();
    self.title:Show();
    local id = self.data.id;
    self.frame:SetScript("OnEnter", nil);
    self.frame:SetScript("OnLeave", nil);
    self.frame:SetScript("OnClick", nil);
    self.frame:SetScript("OnDragStart", nil);
    self.frame:SetScript("OnDragStop", nil);
    --self.frame:EnableMouse(false);
    self.frame:ClearAllPoints();
    self.frame:Hide();
    for _, button in ipairs(self.statusIcons.buttons) do
      statusIconPool:Release(button)
    end
    wipe(self.statusIcons.buttons)
    self.frame = nil;
    self.data = nil;
  end,
  ["UpdateThumbnail"] = function(self)
    if not self.hasThumbnail then
      return
    end

    if self.data.regionType ~= self.thumbnailType then
      self:ReleaseThumbnail()
      self:AcquireThumbnail()
    else
      local option = OptionsPrivate.Private.regionOptions[self.thumbnailType]
      if option and option.modifyThumbnail then
        option.modifyThumbnail(self.frame, self.thumbnail, self.data)
      end
    end
  end,
  ["ReleaseThumbnail"] = function(self)
    if not self.hasThumbnail then
      return
    end
    self.hasThumbnail = false

    if self.thumbnail then
      local regionType = self.thumbnailType
      local option = OptionsPrivate.Private.regionOptions[regionType]
      option.releaseThumbnail(self.thumbnail)
      self.thumbnail = nil
    end
  end,
  ["AcquireThumbnail"] = function(self)
    if self.hasThumbnail then
      return
    end

    if not self.data then
      return
    end

    self.hasThumbnail = true

    local button = self.frame
    local regionType = self.data.regionType
    self.thumbnailType = regionType

    local option = OptionsPrivate.Private.regionOptions[regionType]
    if option and option.acquireThumbnail then
      self.thumbnail = option.acquireThumbnail(button, self.data)
      self:SetIcon(self.thumbnail)
    else
      self:SetIcon("Interface\\Icons\\INV_Misc_QuestionMark")
    end
  end,
  ["SetIcon"] = function(self, icon)
    self.orgIcon = icon;
    if(type(icon) == "string" or type(icon) == "number") then
      self.icon:SetTexture(icon);
      self.icon:Show();
      if(self.iconRegion and self.iconRegion.Hide) then
        self.iconRegion:Hide();
      end
    else
      self.iconRegion = icon;
      icon:SetAllPoints(self.icon);
      icon:SetParent(self.frame);
      icon:Show()
      self.iconRegion:Show();
      self.icon:Hide();
    end
  end,
  ["OverrideIcon"] = function(self)
    self.icon:SetTexture("Interface\\Addons\\WeakAuras\\Media\\Textures\\icon.blp")
    self.icon:Show()
    if(self.iconRegion and self.iconRegion.Hide) then
      self.iconRegion:Hide();
    end
  end,
  ["RestoreIcon"] = function(self)
    self:SetIcon(self.orgIcon);
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = "WeakAurasDisplayButton"..AceGUI:GetNextWidgetNum(Type);
  ---@class Button
  local button = CreateFrame("Button", name, UIParent, "OptionsListButtonTemplate");
  button:SetHeight(32);
  button:SetWidth(1000);
  button.dgroup = nil;
  button.data = {};

  local offset = CreateFrame("Frame", nil, button)
  button.offset = offset
  offset:SetPoint("TOP", button, "TOP");
  offset:SetPoint("BOTTOM", button, "BOTTOM");
  offset:SetPoint("LEFT", button, "LEFT");
  offset:SetWidth(1)

  local background = button:CreateTexture(nil, "BACKGROUND");
  button.background = background;
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
  background:SetBlendMode("ADD");
  background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
  background:SetPoint("TOP", button, "TOP");
  background:SetPoint("BOTTOM", button, "BOTTOM");
  background:SetPoint("LEFT", button, "LEFT")
  background:SetPoint("RIGHT", button, "RIGHT");

  local icon = button:CreateTexture(nil, "OVERLAY");
  button.icon = icon;
  icon:SetWidth(32);
  icon:SetHeight(32);
  icon:SetPoint("LEFT", offset, "RIGHT");

  local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormal");
  button.title = title;
  title:SetHeight(14);
  title:SetJustifyH("LEFT");
  title:SetPoint("TOP", button, "TOP", 0, -2);
  title:SetPoint("LEFT", icon, "RIGHT", 2, 0);
  title:SetPoint("RIGHT", button, "RIGHT");

  button.description = {};

  ---@class Button
  local view = CreateFrame("Button", nil, button);
  button.view = view;
  view:SetWidth(16);
  view:SetHeight(16);
  view:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -2, 0);
  local viewTexture = view:CreateTexture()
  view.texture = viewTexture;
  viewTexture:SetTexture("Interface\\LFGFrame\\BattlenetWorking4.blp");
  viewTexture:SetTexCoord(0.1, 0.9, 0.1, 0.9);
  viewTexture:SetAllPoints(view);
  view:SetNormalTexture(viewTexture);
  view:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  view:SetScript("OnEnter", function() Show_Tooltip(button, L["View"], L["Toggle the visibility of this display"]) end);
  view:SetScript("OnLeave", Hide_Tooltip);

  view.visibility = 0;

  local renamebox = CreateFrame("EditBox", nil, button, "InputBoxTemplate");
  renamebox:SetHeight(14);
  renamebox:SetPoint("TOP", button, "TOP");
  renamebox:SetPoint("LEFT", icon, "RIGHT", 6, 0);
  renamebox:SetPoint("RIGHT", button, "RIGHT", -4, 0);
  renamebox:SetFont(STANDARD_TEXT_FONT, 10, "");
  renamebox:Hide();

  renamebox.func = function() --[[By default, do nothing!]] end;
  renamebox:SetScript("OnEnterPressed", function()
    local oldid = button.title:GetText();
    local newid = renamebox:GetText();
    if(newid == "" or (newid ~= oldid and WeakAuras.GetData(newid))) then
      renamebox:SetText(button.title:GetText());
    else
      renamebox.func();
      title:SetText(renamebox:GetText());
      title:Show();
      renamebox:Hide();
    end
  end);

  renamebox:SetScript("OnEscapePressed", function()
    title:Show();
    renamebox:Hide();
  end);

  local group = CreateFrame("Button", nil, button);
  button.group = group;
  group:SetWidth(16);
  group:SetHeight(16);
  group:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -18, 0);
  local grouptexture = group:CreateTexture(nil, "OVERLAY");
  group.texture = grouptexture;
  grouptexture:SetTexture("Interface\\GLUES\\CharacterCreate\\UI-RotationRight-Big-Up.blp");
  grouptexture:SetTexCoord(0.15, 0.85, 0.15, 0.85);
  grouptexture:SetAllPoints(group);
  group:SetNormalTexture(grouptexture);
  group:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  group:SetScript("OnEnter", function() Show_Tooltip(button, L["Group (verb)"], L["Put this display in a group"]) end);
  group:SetScript("OnLeave", Hide_Tooltip);

  local ungroup = CreateFrame("Button", nil, button);
  button.ungroup = ungroup;
  ungroup:SetWidth(11);
  ungroup:SetHeight(11);
  ungroup:SetPoint("LEFT", offset, "RIGHT", 0, 0);
  local ungrouptexture = group:CreateTexture(nil, "OVERLAY");
  ungrouptexture:SetTexture("Interface\\MoneyFrame\\Arrow-Left-Down.blp");
  ungrouptexture:SetTexCoord(0.5, 0, 0.5, 1, 1, 0, 1, 1);
  ungrouptexture:SetAllPoints(ungroup);
  ungroup:SetNormalTexture(ungrouptexture);
  ungroup:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  ungroup:SetScript("OnEnter", function() Show_Tooltip(button, L["Ungroup"], L["Remove this display from its group"]) end);
  ungroup:SetScript("OnLeave", Hide_Tooltip);
  ungroup:Hide();

  local upgroup = CreateFrame("Button", nil, button);
  button.upgroup = upgroup;
  upgroup:SetWidth(11);
  upgroup:SetHeight(11);
  upgroup:SetPoint("TOPLEFT", offset, "TOPRIGHT", 0, 0);
  local upgrouptexture = group:CreateTexture(nil, "OVERLAY");
  upgroup.texture = upgrouptexture;
  upgrouptexture:SetTexture("Interface\\MoneyFrame\\Arrow-Left-Down.blp");
  upgrouptexture:SetTexCoord(0.5, 1, 1, 1, 0.5, 0, 1, 0);
  upgrouptexture:SetVertexColor(1, 1, 1);
  upgrouptexture:SetAllPoints(upgroup);
  upgroup:SetNormalTexture(upgrouptexture);
  upgroup:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  upgroup:SetScript("OnEnter", function() Show_Tooltip(button, L["Move Up"], L["Move this display up in its group's order"]) end);
  upgroup:SetScript("OnLeave", Hide_Tooltip);
  upgroup:Hide();

  local downgroup = CreateFrame("Button", nil, button);
  button.downgroup = downgroup;
  downgroup:SetWidth(11);
  downgroup:SetHeight(11);
  downgroup:SetPoint("BOTTOMLEFT", offset, "BOTTOMRIGHT", 0, 0);
  local downgrouptexture = group:CreateTexture(nil, "OVERLAY");
  downgroup.texture = downgrouptexture;
  downgrouptexture:SetTexture("Interface\\MoneyFrame\\Arrow-Left-Down.blp");
  downgrouptexture:SetTexCoord(1, 0, 0.5, 0, 1, 1, 0.5, 1);
  downgrouptexture:SetAllPoints(downgroup);
  downgroup:SetNormalTexture(downgrouptexture);
  downgroup:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  downgroup:SetScript("OnEnter", function()
    Show_Tooltip(button, L["Move Down"], L["Move this display down in its group's order"])
  end)
  downgroup:SetScript("OnLeave", Hide_Tooltip);
  downgroup:Hide();

  ---@class Button
  local expand = CreateFrame("Button", nil, button);
  button.expand = expand;
  expand.expanded = true;
  expand.disabled = true;
  expand.func = function() end;
  expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  expand:Disable();
  expand:SetWidth(16);
  expand:SetHeight(16);
  expand:SetPoint("BOTTOM", button, "BOTTOM");
  expand:SetPoint("LEFT", icon, "RIGHT", 0, 0);
  expand:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  expand.title = L["Disabled"];
  expand.desc = L["Expansion is disabled because this group has no children"];
  expand:SetScript("OnEnter", function() Show_Tooltip(button, expand.title, expand.desc) end);
  expand:SetScript("OnLeave", Hide_Tooltip);

  local statusIcons = CreateFrame("Frame", nil, button);
  button.statusIcons = statusIcons
  statusIcons:SetPoint("BOTTOM", button, "BOTTOM", 0, 1);
  statusIcons:SetPoint("LEFT", icon, "RIGHT");
  statusIcons:SetSize(1,1)
  statusIcons.buttons = {}

  local widget = {
    frame = button,
    title = title,
    icon = icon,
    view = view,
    renamebox = renamebox,
    group = group,
    ungroup = ungroup,
    upgroup = upgroup,
    downgroup = downgroup,
    background = background,
    expand = expand,
    statusIcons = statusIcons,
    type = Type,
    offset = offset
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget);
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasDisplayButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasDropDownItemCurrency.lua ===
-- Item: Toggle
-- Some sort of checkbox for dropdown menus.
-- Does not close the pullout on click.
-- Based on the AceGUI Toggle Item. Extracts the icon from the text

local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
local ItemBase = LibStub("AceGUI-3.0-DropDown-ItemBase"):GetItemBase()

local widgetType = "Dropdown-Currency"
local widgetVersion = 1

local function UpdateToggle(self)
  if self.value and not self.isHeader then
    self.check:Show()
  else
    self.check:Hide()
  end
end

local function OnRelease(self)
  ItemBase.OnRelease(self)
  self:SetValue(nil)
end

local function Frame_OnClick(this, button)
  local self = this.obj
  if self.disabled then return end
  self.value = not self.value
  if self.value then
    PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
  else
    PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
  end
  UpdateToggle(self)
  self:Fire("OnValueChanged", self.value)
end

local function Frame_OnShow(self)
  local userdata = self.obj.userdata
  local key = userdata and userdata.value
  local dropDownUserData = userdata and userdata.obj and userdata.obj.userdata
  local headers = dropDownUserData and dropDownUserData.option and dropDownUserData.option.headers
  if type(headers) == "function" then
    headers = headers()
  end

  local isHeader = headers and key and headers[key]
  self.obj.isHeader = isHeader

  if isHeader then
    self:SetScript("OnClick", nil)
    self.obj.text:SetTextColor(1, 1, 0)
    self.obj.useHighlight = false

    self.obj.text:ClearAllPoints()
    self.obj.text:SetPoint("TOPLEFT", self, "TOPLEFT", 7, 0)
    self.obj.text:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -8, 0)
    self.obj.icon:Hide()
  else
    self:SetScript("OnClick", Frame_OnClick)
    self.obj.text:SetTextColor(1, 1, 1)
    self.obj.useHighlight = true

    if self.obj.hasIcon then
      self.obj.icon:Show()
      self.obj.text:ClearAllPoints()
      self.obj.text:SetPoint("TOPLEFT", self, "TOPLEFT", 34, 0)
      self.obj.text:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -8, 0)
    else
      self.obj.icon:Hide()
      self.obj.text:ClearAllPoints()
      self.obj.text:SetPoint("TOPLEFT", self, "TOPLEFT", 18, 0)
      self.obj.text:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -8, 0)
    end

  end
  UpdateToggle(self.obj)
end

-- exported
local function SetValue(self, value)
  self.value = value
  UpdateToggle(self)
end

-- exported
local function GetValue(self)
  return self.value
end

local function SetText(self, text)
  text = text or ""
  local pos = text:find("|t", 1, true)

  if pos then
    ItemBase.SetText(self, text:sub(pos + 2))

    local firstColon = text:find(":", 1, true)
    local icon = text:sub(3, firstColon - 1)
    self.icon:SetTexture(icon)
    self.hasIcon = true
  else
    ItemBase.SetText(self, text)
    self.hasIcon = false
  end
  self.fullText = text
end


local function Constructor()
  local self = ItemBase.Create(widgetType)

  self.text:SetPoint("TOPLEFT", self.frame, "TOPLEFT", 34, 0)

  self.icon = self.frame:CreateTexture(nil, "OVERLAY")
  self.icon:SetPoint("TOPLEFT", self.frame, "TOPLEFT", 18, -2)
  self.icon:SetWidth(12)
  self.icon:SetHeight(12)

  self.frame:SetScript("OnClick", Frame_OnClick)
  self.frame:SetScript("OnShow", Frame_OnShow)

  self.SetValue = SetValue
  self.GetValue = GetValue
  self.OnRelease = OnRelease
  self.SetText = SetText

  AceGUI:RegisterAsWidget(self)
  return self
end

AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasDropDownItemCurrency.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasExpand.lua ===
--[[-----------------------------------------------------------------------------
Button Widget for our Expand button
-------------------------------------------------------------------------------]]
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasExpand", 6

local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local select, pairs = select, pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function Button_OnClick(frame, button)
	frame.obj:Fire("OnClick", button)
	AceGUI:ClearFocus()
end

local function OnFrameShow(frame)
	local self = frame.obj
	local fontObject = self.userdata and self.userdata.option and self.userdata.option.fontObject
	self:SetFontObject(fontObject or GameFontHighlightLarge)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetHeight(110)
		self:SetWidth(110)
		self:SetLabel()
		self:SetImage(nil)
		self:SetImageSize(64, 64)
		self:SetDisabled(false)
	end,

	-- ["OnRelease"] = nil,

	["SetLabel"] = function(self, text)
		if text and text ~= "" then
			self.label:Show()
			self.label:SetText(text)
			self:SetHeight(max(self.label:GetStringHeight(), self.image:GetHeight()))
		else
			self.label:Hide()
			self:SetHeight(self.image:GetHeight())
		end
	end,

	["SetImage"] = function(self, path, ...)
		local image = self.image
		image:SetTexture(path)

		if image:GetTexture() then
			local n = select("#", ...)
			if n == 4 or n == 8 then
				image:SetTexCoord(...)
			else
				image:SetTexCoord(0, 1, 0, 1)
			end
		end
	end,

	["SetImageSize"] = function(self, width, height)
		self.image:SetWidth(width)
		self.image:SetHeight(height)
		--self.frame:SetWidth(width + 30)
		if self.label:IsShown() then
			self:SetHeight(max(self.label:GetStringHeight(), self.image:GetHeight()))
		else
			self:SetHeight(self.image:GetHeight())
		end
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.label:SetTextColor(0.5, 0.5, 0.5)
			self.image:SetVertexColor(0.5, 0.5, 0.5, 0.5)
		else
			self.frame:Enable()
			self.label:SetTextColor(1, 1, 1)
			self.image:SetVertexColor(1, 1, 1, 1)
		end
	end,

  ["SetFontObject"] = function(self, fontObject)
    self.label:SetFontObject(fontObject)
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Button", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnClick", Button_OnClick)
	frame:SetScript("OnShow", OnFrameShow)

	local image = frame:CreateTexture(nil, "BACKGROUND")
	image:SetWidth(64)
	image:SetHeight(64)
	image:SetPoint("LEFT", 0, 0)

	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlightLarge")
	label:SetJustifyH("LEFT")
	label:SetJustifyV("MIDDLE")
	label:SetPoint("LEFT", image, "RIGHT", 5, 0)
	label:SetPoint("TOP")
	label:SetPoint("BOTTOM")
	label:SetPoint("RIGHT")

	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	highlight:SetAllPoints(frame)
	highlight:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White")
	highlight:SetVertexColor(0.2, 0.4, 0.8, 0.2)
	highlight:SetBlendMode("ADD")

	local widget = {
		label = label,
		image = image,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasExpand.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasExpandAnchor.lua ===
--[[-----------------------------------------------------------------------------
Anchor for a Expandable section
-------------------------------------------------------------------------------]]
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)
local Type, Version = "WeakAurasExpandAnchor", 3
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local methods = {
  ["OnAcquire"] = function(self)
    self:SetHeight(1)
    self:SetWidth(1)
  end,

  -- ["OnRelease"] = nil,

  ["OnWidthSet"] = function(self, width)
  end,

  ["SetText"] = function(self, text)
  end,

  ["SetFontObject"] = function(self, font)
  end,
}

local function OnFrameShow(frame)
  local self = frame.obj
  local option = self.userdata.option
  if option and option.arg and option.arg.expanderName then
    OptionsPrivate.expanderAnchors[option.arg.expanderName] = self
    local otherWidget = OptionsPrivate.expanderButtons[option.arg.expanderName]
    if otherWidget then
      otherWidget:SetAnchor(self)
    end
  end
end

local function OnFrameHide(frame)
  local self = frame.obj
  local option = self.userdata.option
  if option and option.arg and option.arg.expanderName then
    OptionsPrivate.expanderAnchors[option.arg.expanderName] = nil

    local otherWidget = OptionsPrivate.expanderButtons[option.arg.expanderName]
    if otherWidget then
      otherWidget:SetAnchor(nil)
    end
  end
end


local function Constructor()
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:Hide()

  frame:SetScript("OnShow", OnFrameShow)
  frame:SetScript("OnHide", OnFrameHide)

  -- create widget
  local widget = {
    frame = frame,
    type  = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasExpandAnchor.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasExpandSmall.lua ===
--[[-----------------------------------------------------------------------------
Button Widget for our Expand button
-------------------------------------------------------------------------------]]
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local Type, Version = "WeakAurasExpandSmall", 4

local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local select, pairs = select, pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
  frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
  frame.obj:Fire("OnLeave")
end

local function Button_OnClick(frame, button)
  frame.obj:Fire("OnClick", button)
  AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetHeight(20)
    self:SetWidth(110)
    self:SetLabel()
    self:SetImage(nil)
    self:SetImageSize(24, 24)
    self:SetDisabled(false)
  end,

  -- ["OnRelease"] = nil,

  ["SetLabel"] = function(self, text)
    if text and text ~= "" then
      self.label:Show()
      self.label:SetText(text)
      self:SetHeight(max(self.label:GetStringHeight(), self.image:GetHeight()))
    else
      self.label:Hide()
      self:SetHeight(self.image:GetHeight())
    end
  end,

  ["SetImage"] = function(self, path, ...)
    local image = self.image
    if path == "collapsed" then
      self:SetExpandedState(false)
      path = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\gear"
    elseif path == "expanded" then
      self:SetExpandedState(true)
      path = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\geardown"
    else
      self:SetExpandedState(false)
    end
    image:SetTexture(path)

    if image:GetTexture() then
      local n = select("#", ...)
      if n == 4 or n == 8 then
        image:SetTexCoord(...)
      else
        image:SetTexCoord(0, 1, 0, 1)
      end
    end
  end,

  ["SetExpandedState"] = function(self, state)
    self.expanded = state
    if state then
      self.expandedBackground:Show()
      self.expandedHighlight:Show()
    else
      self.expandedBackground:Hide()
      self.expandedHighlight:Hide()
    end
  end,

  ["GetExpandedState"] = function(self)
    return self.expanded
  end,

  ["SetImageSize"] = function(self, width, height)
    self.image:SetWidth(width)
    self.image:SetHeight(height)
    self:UpdateWidth()
    if self.label:IsShown() then
      self:SetHeight(max(self.label:GetStringHeight(), self.image:GetHeight()))
    else
      self:SetHeight(self.image:GetHeight())
    end
  end,

  ["SetDisabled"] = function(self, disabled)
    self.disabled = disabled
    if disabled then
      self.frame:Disable()
      self.label:SetTextColor(0.5, 0.5, 0.5)
      self.image:SetVertexColor(0.5, 0.5, 0.5, 0.5)
    else
      self.frame:Enable()
      self.label:SetTextColor(1, 1, 1)
      self.image:SetVertexColor(1, 1, 1, 1)
    end
  end,

  ["OnWidthSet"] = function(self, width)
    self:UpdateWidth()
  end,

  ["UpdateWidth"] = function(self)
    self.label:SetWidth(self.frame:GetWidth() - self.image:GetWidth())
    if self.label:IsShown() then
      self:SetHeight(max(self.label:GetStringHeight(), self.image:GetHeight(), 20))
    else
      self:SetHeight(self.image:GetHeight())
    end
    self.expandedBackground:SetHeight(self.frame:GetHeight()*2)
  end,

  ["SetAnchor"] = function(self, otherWidget)
    local expandedBackground = self.expandedBackground
    if otherWidget then
      expandedBackground:SetPoint("BOTTOMLEFT", otherWidget.frame, "TOPLEFT", -4, -2)
    end
  end
}

local function OnFrameShow(frame)
  local self = frame.obj
  local option = self.userdata.option
  if option and option.arg and option.arg.expanderName then
    OptionsPrivate.expanderButtons[option.arg.expanderName] = self

    local otherWidget = OptionsPrivate.expanderAnchors[option.arg.expanderName]
    if otherWidget then
      self:SetAnchor(otherWidget)
    end
  end
end

local function OnFrameHide(frame)
  local self = frame.obj
  local option = self.userdata.option
  if option and option.arg and option.arg.expanderName then
    OptionsPrivate.expanderButtons[option.arg.expanderName] = nil

    local otherWidget = OptionsPrivate.expanderAnchors[option.arg.expanderName]
    if otherWidget then
      self:SetAnchor(nil)
    end
  end
end




--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
  local frame = CreateFrame("Button", nil, UIParent)
  frame:Hide()

  frame:EnableMouse(true)
  frame:SetScript("OnEnter", Control_OnEnter)
  frame:SetScript("OnLeave", Control_OnLeave)
  frame:SetScript("OnClick", Button_OnClick)
  frame:SetScript("OnShow", OnFrameShow)
  frame:SetScript("OnHide", OnFrameHide)

  local image = frame:CreateTexture(nil, "BACKGROUND")
  image:SetWidth(64)
  image:SetHeight(64)
  image:SetPoint("LEFT", 2, 0)

  local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlight")
  label:SetJustifyH("LEFT")
  label:SetJustifyV("MIDDLE")
  label:SetPoint("RIGHT")
  label:SetPoint("TOP")
  label:SetPoint("BOTTOM")
  label:SetPoint("LEFT", image, "RIGHT", 5, 0)

  local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
  highlight:SetAllPoints(frame)
  highlight:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White")
  highlight:SetVertexColor(0.2, 0.4, 0.8, 0.2)
  highlight:SetBlendMode("ADD")

  local expandedHighlight = frame:CreateTexture(nil, "BACKGROUND")
  expandedHighlight:SetPoint("TOPLEFT", frame, -2, 0)
  expandedHighlight:SetPoint("BOTTOMRIGHT", frame, 0, 0)
  expandedHighlight:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White")
  expandedHighlight:SetVertexColor(1, 0.8, 0, 0.1)
  expandedHighlight:SetBlendMode("ADD")

  local expandedBackground = frame:CreateTexture(nil, "BACKGROUND")
  expandedBackground:SetPoint("TOPLEFT", frame, "BOTTOMLEFT", -1, -1)
  expandedBackground:SetWidth(128)
  expandedBackground:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_AlphaGradient")
  expandedBackground:SetVertexColor(1, 0.8, 0, 0.15)
  expandedBackground:SetBlendMode("ADD")

  local widget = {
    label = label,
    image = image,
    frame = frame,
    type  = Type,
    expanded = false,
    expandedBackground = expandedBackground,
    expandedHighlight = expandedHighlight,
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasExpandSmall.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasIcon.lua ===
--[[-----------------------------------------------------------------------------
Icon Widget that allows for a tooltip, by preventing SetLabel from actually
setting a label
Graphical Button.
-------------------------------------------------------------------------------]]
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasIcon", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local function Constructor()
	local button = AceGUI:Create("Icon")
	button.type = Type
	button.SetLabel = function() end
	return button
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasIcon.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasIconButton.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasIconButton", 22
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("BOTTOM", owner, "TOP");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(52);
    self:SetHeight(52);
  end,
  ["OnRelease"] = function(self)
    self:ClearPick();
    self.texture:SetTexture();
  end,
  ["SetName"] = function(self, name)
    self.texture.name = name;
  end,
  ["GetName"] = function(self)
    return self.texture.name;
  end,
  ["SetTexture"] = function(self, texturePath)
    self.texture.path = texturePath;
    local success = self.texture:SetTexture(texturePath);
    if not(success) then
      self.texture:SetTexture("Interface\\BUTTONS\\UI-Quickslot-Depress.blp");
    end
    return success;
  end,
  ["GetTexturePath"] = function(self)
    return self.texture.path;
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
  end,
  ["ClearPick"] = function(self)
    self.frame:UnlockHighlight();
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local button = CreateFrame("Button", nil, UIParent);
  button:SetHeight(52);
  button:SetWidth(52);

  local highlighttexture = button:CreateTexture(nil, "OVERLAY");
  --highlighttexture:SetTexture("Interface\\BUTTONS\\ButtonHilight-SquareQuickslot.blp");
  --highlighttexture:SetTexCoord(0.175, 0.875, 0.125, 0.825);
  highlighttexture:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp");
  highlighttexture:SetVertexColor(0.25, 0.5, 1);
  highlighttexture:SetPoint("BOTTOMLEFT", button, 4, 4);
  highlighttexture:SetPoint("TOPRIGHT", button, -4, -4);
  button:SetHighlightTexture(highlighttexture);

  local texture = button:CreateTexture(nil, "OVERLAY");
  texture:SetAllPoints(button);
  texture.name = "Undefined";

  button:SetScript("OnEnter", function() Show_Tooltip(button, texture.name, texture.path) end);
  button:SetScript("OnLeave", Hide_Tooltip);

  local widget = {
    frame = button,
    texture = texture,
    type = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasIconButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasImportButton.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasImportButton", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local L = WeakAuras.L;

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(380);
    self:SetHeight(18);
  end,
  ["SetTitle"] = function(self, title)
    self.title:SetText(title);
  end,
  ["GetTitle"] = function(self)
    return self.title:GetText();
  end,
  ["SetDescription"] = function(self, desc)
    self.frame.description = desc;
  end,
  ["SetIcon"] = function(self, iconPath)
    if(iconPath) then
      local icon = self.frame:CreateTexture();
      icon:SetTexture(iconPath);
      icon:SetPoint("RIGHT", self.frame, "RIGHT");
      icon:SetPoint("BOTTOM", self.frame, "BOTTOM");
      icon:SetWidth(16);
      icon:SetHeight(16);
      self.title:SetPoint("RIGHT", icon, "LEFT");
    end
  end,
  -- ["SetChecked"] = function(self, value)
  -- print("SetChecked", self.title:GetText(), value);
  -- self.checkbox:SetChecked(value);
  -- print("After SetChecked", self.checkbox:GetChecked(), self:GetChecked());
  -- end,
  -- ["GetChecked"] = function(self)
  -- local checked = self.checkbox:GetChecked();
  -- print("GetChecked", self.title:GetText(), checked);
  -- return checked;
  -- end,
  ["SetClick"] = function(self, func)
    self.checkbox:SetScript("OnClick", func);
  end,
  ["Expand"] = function(self, reloadTooltip)
    self.expand:Enable();
    self.expand.expanded = true;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-MinusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-MinusButton-Down.blp");
    self.expand.title = L["Collapse"];
    self.expand:SetScript("OnClick", function() self:Collapse(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, nil);
    end
  end,
  ["Collapse"] = function(self, reloadTooltip)
    self.expand:Enable();
    self.expand.expanded = nil;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-PlusButton-Down.blp");
    self.expand.title = L["Expand"];
    self.expand:SetScript("OnClick", function() self:Expand(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, nil);
    end
  end,
  ["SetOnExpandCollapse"] = function(self, func)
    self.expand.func = func;
  end,
  ["GetExpanded"] = function(self)
    return self.expand.expanded;
  end,
  ["DisableExpand"] = function(self)
    self.expand:Disable();
    self.expand.disabled = true;
    self.expand.expanded = false;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  end,
  ["EnableExpand"] = function(self)
    self.expand.disabled = false;
    if(self:GetExpanded()) then
      self:Expand();
    else
      self:Collapse();
    end
  end,
  ["SetExpandVisible"] = function(self, value)
    if(value) then
      self.expand:Show();
    else
      self.expand:Hide();
    end
  end,
  ["SetLevel"] = function(self, level)
    self.checkbox:SetPoint("left", self.frame, "left", level * 16, 0);
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = "WeakAurasImportButton"..AceGUI:GetNextWidgetNum(Type);
  local button = CreateFrame("Button", name, UIParent, "OptionsListButtonTemplate");
  button:SetHeight(18);
  button:SetWidth(380);
  button.dgroup = nil;

  local background = button:CreateTexture(nil, "BACKGROUND");
  button.background = background;
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
  background:SetBlendMode("ADD");
  background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
  background:SetAllPoints(button);

  local expand = CreateFrame("Button", nil, button);
  button.expand = expand;
  expand.expanded = true;
  expand.disabled = true;
  expand.func = function() end;
  expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  expand:Disable();
  expand:SetWidth(16);
  expand:SetHeight(16);
  expand:SetPoint("BOTTOM", button, "BOTTOM");
  expand:SetPoint("LEFT", button, "LEFT");
  expand:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  expand.title = L["Disabled"];
  expand:SetScript("OnEnter", function() Show_Tooltip(button, expand.title, nil) end);
  expand:SetScript("OnLeave", Hide_Tooltip);

  local checkbox = CreateFrame("CheckButton", nil, button, "ChatConfigCheckButtonTemplate");
  button.checkbox = checkbox;
  checkbox:EnableMouse(false);
  checkbox:SetWidth(18);
  checkbox:SetHeight(18);
  checkbox:SetPoint("BOTTOM", button, "BOTTOM");
  checkbox:SetPoint("LEFT", button, "LEFT", 16);

  local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge");
  button.title = title;
  title:SetHeight(14);
  title:SetJustifyH("LEFT");
  title:SetPoint("LEFT", checkbox, "RIGHT", 2, 0);
  title:SetPoint("RIGHT", button, "RIGHT");

  button.description = "";

  button:SetScript("OnEnter", function() Show_Tooltip(button, title:GetText(), button.description) end);
  button:SetScript("OnLeave", Hide_Tooltip);

  button:SetScript("OnClick", function() checkbox:Click() end);

  local widget = {
    frame = button,
    title = title,
    checkbox = checkbox,
    expand = expand,
    background = background,
    type = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasImportButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasInput.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasInput", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local eventCallbacks = {
  OnEditFocusGained = "OnEditFocusGained",
  OnEditFocusLost = "OnEditFocusLost",
  OnEnterPressed = "OnEnterPressed",
  OnShow = "OnShow"
}

local function EventHandler(frame, event)
  local self = frame.obj
  local option = self.userdata.option
  if option and option.callbacks and option.callbacks[event] then
    option.callbacks[event](self)
  end
end

local function Constructor()
  local widget = AceGUI:Create("EditBox")
  widget.type = Type

  for event, callback in pairs(eventCallbacks) do
    widget.editbox:HookScript(event, function(frame) EventHandler(frame, callback) end)
  end

  return widget
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasInput.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasInputFocus.lua ===
--[[-----------------------------------------------------------------------------
Input Widget that allows to show an alternative text when it does not have focus
-------------------------------------------------------------------------------]]
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasInputFocus", 1
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local OnEditFocusGained = function(self)
	local textWithFocus = self.obj.textWithFocus
	if textWithFocus and self:GetText() == self.obj.textWithoutFocus then
		self:SetText(textWithFocus)
	end
	AceGUI:SetFocus(self.obj)
end


local function Constructor()
	local button = AceGUI:Create("EditBox")
	button.type = Type

	button.editbox:SetScript("OnEditFocusGained", OnEditFocusGained)

	local oldSetText = button.SetText
	button.SetText = function(self, text)
		text = text or ""
		local pos = string.find(text, "\0", nil, true)
		if pos then
			self.textWithoutFocus = text:sub(1, pos -1)
			self.textWithFocus = text:sub(pos + 1)
			oldSetText(self, self.textWithoutFocus)
		else
			self.textWithFocus = nil
			self.textWithoutFocus = nil
			oldSetText(self, text)
		end
	end

	return button
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasInputFocus.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasInputWithIndentation.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasInputWithIndentation", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local tostring, pairs = tostring, pairs

-- WoW APIs
local PlaySound = PlaySound
local GetCursorInfo, ClearCursor = GetCursorInfo, ClearCursor
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = _G

if not AceGUIWeakAurasInputWithIndentationInsertLink then
  -- upgradeable hook
  hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIWeakAurasInputWithIndentationInsertLink(...) end)
end

function _G.AceGUIWeakAurasInputWithIndentationInsertLink(text)
  for i = 1, AceGUI:GetWidgetCount(Type) do
    local editbox = _G[("WeakAurasInputWithIndentation%uEdit"):format(i)]
    if editbox and editbox:IsVisible() and editbox:HasFocus() then
      text = text:gsub("|", "||")
      editbox:Insert(text)
      return true
    end
  end
end

local function ShowButton(self)
  if not self.disablebutton then
    self.button:Show()
    self.editbox:SetTextInsets(0, 20, 3, 3)
  end
end

local function HideButton(self)
  self.button:Hide()
  self.editbox:SetTextInsets(0, 0, 3, 3)
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
  frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
  frame.obj:Fire("OnLeave")
end

local function Frame_OnShowFocus(frame)
  frame.obj.editbox:SetFocus()
  frame:SetScript("OnShow", nil)
end

local function EditBox_OnEscapePressed(frame)
  AceGUI:ClearFocus()
end

local function EditBox_OnEnterPressed(frame)
  local self = frame.obj
  local value = frame:GetText()
  local cancel = self:Fire("OnEnterPressed", value)
  if not cancel then
    PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
    HideButton(self)
  end
end

local function EditBox_OnReceiveDrag(frame)
  local self = frame.obj
  local type, id, info, extra = GetCursorInfo()
  local name
  if type == "item" then
    name = info
  elseif type == "spell" then
    if C_Spell and C_Spell.GetSpellName then
      name = C_Spell.GetSpellName(extra)
    else
      name = GetSpellInfo(id, info)
    end
  elseif type == "macro" then
    name = GetMacroInfo(id)
  end
  if name then
    self:SetText(name)
    self:Fire("OnEnterPressed", name)
    ClearCursor()
    HideButton(self)
    AceGUI:ClearFocus()
  end
end

local function EditBox_OnTextChanged(frame)
  local self = frame.obj
  local value = frame:GetText()
  if tostring(value) ~= tostring(self.lasttext) then
    self:Fire("OnTextChanged", value)
    self.lasttext = value
    ShowButton(self)
  end
end

local function EditBox_OnFocusGained(frame)
  AceGUI:SetFocus(frame.obj)
end

local function Button_OnClick(frame)
  local editbox = frame.obj.editbox
  editbox:ClearFocus()
  EditBox_OnEnterPressed(editbox)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    -- height is controlled by SetLabel
    self:SetWidth(200)
    self:SetDisabled(false)
    self:SetLabel()
    self:SetText()
    self:DisableButton(false)
    self:SetMaxLetters(0)
  end,

  ["OnRelease"] = function(self)
    self:ClearFocus()
  end,

  ["SetDisabled"] = function(self, disabled)
    self.disabled = disabled
    if disabled then
      self.editbox:EnableMouse(false)
      self.editbox:ClearFocus()
      self.editbox:SetTextColor(0.5,0.5,0.5)
      self.label:SetTextColor(0.5,0.5,0.5)
    else
      self.editbox:EnableMouse(true)
      self.editbox:SetTextColor(1,1,1)
      self.label:SetTextColor(1,.82,0)
    end
  end,

  ["SetText"] = function(self, text)
    self.lasttext = text or ""
    self.editbox:SetText(text or "")
    self.editbox:SetCursorPosition(0)
    HideButton(self)
  end,

  ["GetText"] = function(self, text)
    return self.editbox:GetText()
  end,

  ["SetLabel"] = function(self, text)
    if text and text ~= "" then
      self.label:SetText(text)
      self.label:Show()
      self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,-18)
      self:SetHeight(44)
      self.alignoffset = 30
    else
      self.label:SetText("")
      self.label:Hide()
      self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,0)
      self:SetHeight(26)
      self.alignoffset = 12
    end
  end,

  ["DisableButton"] = function(self, disabled)
    self.disablebutton = disabled
    if disabled then
      HideButton(self)
    end
  end,

  ["SetMaxLetters"] = function (self, num)
    self.editbox:SetMaxLetters(num or 0)
  end,

  ["ClearFocus"] = function(self)
    self.editbox:ClearFocus()
    self.frame:SetScript("OnShow", nil)
  end,

  ["SetFocus"] = function(self)
    self.editbox:SetFocus()
    if not self.frame:IsShown() then
      self.frame:SetScript("OnShow", Frame_OnShowFocus)
    end
  end,

  ["HighlightText"] = function(self, from, to)
    self.editbox:HighlightText(from, to)
  end
}


local eventCallbacks = {
  OnEditFocusGained = "OnEditFocusGained",
  OnEditFocusLost = "OnEditFocusLost",
  OnEnterPressed = "OnEnterPressed",
  OnShow = "OnShow"
}

local function EventHandler(frame, event)
  local self = frame.obj
  local option = self.userdata.option
  if option and option.callbacks and option.callbacks[event] then
    option.callbacks[event](self)
  end
end

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
  local num  = AceGUI:GetNextWidgetNum(Type)
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:Hide()

  local editbox = CreateFrame("EditBox", string.format("WeakAurasInputWithIndentation%uEdit", format(num)), frame, "InputBoxTemplate")
  editbox:SetAutoFocus(false)
  editbox:SetFontObject(ChatFontNormal)
  editbox:SetScript("OnEnter", Control_OnEnter)
  editbox:SetScript("OnLeave", Control_OnLeave)
  editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
  editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
  editbox:SetScript("OnTextChanged", EditBox_OnTextChanged)
  editbox:SetScript("OnReceiveDrag", EditBox_OnReceiveDrag)
  editbox:SetScript("OnMouseDown", EditBox_OnReceiveDrag)
  editbox:SetScript("OnEditFocusGained", EditBox_OnFocusGained)
  editbox:SetTextInsets(0, 0, 3, 3)
  editbox:SetMaxLetters(256)
  editbox:SetPoint("BOTTOMLEFT", 6, 0)
  editbox:SetPoint("BOTTOMRIGHT")
  editbox:SetHeight(19)

  local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
  label:SetPoint("TOPLEFT", 0, -2)
  label:SetPoint("TOPRIGHT", 0, -2)
  label:SetJustifyH("LEFT")
  label:SetHeight(18)

  local button = CreateFrame("Button", nil, editbox, "UIPanelButtonTemplate")
  button:SetWidth(40)
  button:SetHeight(20)
  button:SetPoint("RIGHT", -2, 0)
  button:SetText(OKAY)
  button:SetScript("OnClick", Button_OnClick)
  button:Hide()

  local widget = {
    alignoffset = 30,
    editbox     = editbox,
    label       = label,
    button      = button,
    frame       = frame,
    type        = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end
  editbox.obj, button.obj = widget, widget

  for event, callback in pairs(eventCallbacks) do
    widget.editbox:HookScript(event, function(frame) EventHandler(frame, callback) end)
  end

  local GetText = widget.editbox.GetText
  widget.editbox.GetText = function(self)
    return IndentationLib.decode(GetText(self))
  end

  local SetText = widget.editbox.SetText
  widget.editbox.SetText = function(self, text)
    SetText(self, IndentationLib.encode(text))
  end

  return AceGUI:RegisterAsWidget(widget)
end


AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasInputWithIndentation.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasLoadedHeaderButton.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasLoadedHeaderButton", 22
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local L = WeakAuras.L

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(1000);
    self:SetHeight(20);
  end,
  ["SetText"] = function(self, text)
    self.frame:SetText(" "..text);
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["Disable"] = function(self)
    self.frame:Disable();
  end,
  ["Enable"] = function(self)
    self.frame:Enable();
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
  end,
  ["ClearPick"] = function(self)
    self.frame:UnlockHighlight();
  end,
  ["Expand"] = function(self, reloadTooltip)
    self.expand:Enable();
    self.expanded = true;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-MinusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-MinusButton-Down.blp");
    self.expand.title = L["Collapse"];
    self.expand.desc = self.expand.collapsedesc;
    self.expand:SetScript("OnClick", function() self:Collapse(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
    end
  end,
  ["Collapse"] = function(self, reloadTooltip)
    self.expand:Enable();
    self.expanded = false;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Up.blp");
    self.expand:SetPushedTexture("Interface\\BUTTONS\\UI-PlusButton-Down.blp");
    self.expand.title = L["Expand"];
    self.expand.desc = self.expand.expanddesc;
    self.expand:SetScript("OnClick", function() self:Expand(true) end);
    self.expand.func();
    if(reloadTooltip) then
      Hide_Tooltip();
      Show_Tooltip(self.frame, self.expand.title, self.expand.desc);
    end
  end,
  ["SetOnExpandCollapse"] = function(self, func)
    self.expand.func = func;
  end,
  ["GetExpanded"] = function(self)
    return self.expanded;
  end,
  ["DisableExpand"] = function(self)
    self.expand:Disable();
    self.expand.disabled = true;
    self.expand.expanded = false;
    self.expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  end,
  ["EnableExpand"] = function(self)
    self.expand.disabled = false;
    if(self:GetExpanded()) then
      self:Expand();
    else
      self:Collapse();
    end
  end,
  ["SetViewClick"] = function(self, func)
    self.view:SetScript("OnClick", func);
  end,
  ["PriorityShow"] = function(self, priority)
    if (not WeakAuras.IsOptionsOpen()) then
      return;
    end
    if(priority >= self.view.visibility and self.view.visibility ~= priority) then
      self.view.visibility = priority;
      self:UpdateViewTexture()
    end
  end,
  ["PriorityHide"] = function(self, priority)
    if (not WeakAuras.IsOptionsOpen()) then
      return;
    end
    if(priority >= self.view.visibility and self.view.visibility ~= 0) then
      self.view.visibility = 0;
      self:UpdateViewTexture()
    end
  end,
  ["UpdateViewTexture"] = function(self)
    local visibility = self.view.visibility
    if(visibility == 2) then
      self.view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking0.blp");
    elseif(visibility == 1) then
      self.view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking2.blp");
    else
      self.view.texture:SetTexture("Interface\\LFGFrame\\BattlenetWorking4.blp");
    end
  end,
  ["SetViewDescription"] = function(self, desc)
    self.view.desc = desc;
  end,
  ["SetExpandDescription"] = function(self, desc)
    self.expand.expanddesc = desc;
  end,
  ["SetCollapseDescription"] = function(self, desc)
    self.expand.collapsedesc = desc;
    self.expand.desc = desc;
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = Type..AceGUI:GetNextWidgetNum(Type)
  local button = CreateFrame("Button", name, UIParent, "OptionsListButtonTemplate");
  button:SetHeight(20);
  button:SetWidth(1000);
  button:SetDisabledFontObject("GameFontNormal");

  local background = button:CreateTexture(nil, "BACKGROUND");
  button.background = background;
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
  background:SetBlendMode("ADD");
  background:SetVertexColor(0.5, 0.5, 0.5, 0.6);
  background:SetAllPoints(button);

  local expand = CreateFrame("Button", nil, button);
  button.expand = expand;
  expand.expanded = true;
  expand.disabled = true;
  expand.func = function() end;
  expand:SetNormalTexture("Interface\\BUTTONS\\UI-PlusButton-Disabled.blp");
  expand:Disable();
  expand:SetWidth(16);
  expand:SetHeight(16);
  expand:SetPoint("RIGHT", button, "RIGHT");
  expand:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  expand.title = L["Disabled"];
  expand.desc = L["Expansion is disabled because this group has no children"];
  expand.expanddesc = "";
  expand.collapsedesc = "";
  expand:SetScript("OnEnter", function() Show_Tooltip(button, expand.title, expand.desc) end);
  expand:SetScript("OnLeave", Hide_Tooltip);

  local view = CreateFrame("Button", nil, button);
  button.view = view;
  view:SetWidth(16);
  view:SetHeight(16);
  view:SetPoint("RIGHT", button, "RIGHT", -16, 0);
  local viewTexture = view:CreateTexture()
  view.texture = viewTexture;
  viewTexture:SetTexture("Interface\\LFGFrame\\BattlenetWorking4.blp");
  viewTexture:SetTexCoord(0.1, 0.9, 0.1, 0.9);
  viewTexture:SetAllPoints(view);
  view:SetNormalTexture(viewTexture);
  view:SetHighlightTexture("Interface\\BUTTONS\\UI-Panel-MinimizeButton-Highlight.blp");
  view.desc = "";
  view:SetScript("OnEnter", function() Show_Tooltip(button, L["View"], view.desc) end);
  view:SetScript("OnLeave", Hide_Tooltip);
  view.visibility = 0;

  local widget = {
    frame = button,
    expand = expand,
    view = view,
    type = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasLoadedHeaderButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_Cata.lua ===
if not WeakAuras.IsLibsOK() then
  return
end

local widgetType, widgetVersion = "WeakAurasMiniTalent", 3
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(widgetType) or 0) >= widgetVersion then
  return
end
local L = WeakAuras.L

local buttonSize = 32
local buttonSizePadded = 45

local function CreateTalentButton(parent)
  local button = CreateFrame("Button", nil, parent)
  button.obj = parent
  button:SetSize(buttonSize, buttonSize)

  local cover = button:CreateTexture(nil, "OVERLAY")
  cover:SetTexture("interface/buttons/checkbuttonglow")
  cover:SetPoint("CENTER")
  cover:SetSize(buttonSize + 20, buttonSize + 20)
  cover:SetBlendMode("ADD")
  cover:Hide()
  button.cover = cover
  button:SetHighlightTexture("Interface/Buttons/ButtonHilight-Square", "ADD")
  function button:Yellow()
    self.cover:Show()
    self.cover:SetVertexColor(1, 1, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 1, 1, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:Red()
    self.cover:Show()
    self.cover:SetVertexColor(1, 0, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 0, 0, 1)
    end
    if not self.line1 then
      local line1 = button:CreateLine()
      line1:SetColorTexture(1, 0, 0, 1)
      line1:SetStartPoint("TOPLEFT", 3, -3)
      line1:SetEndPoint("BOTTOMRIGHT", -3, 3)
      line1:SetBlendMode("ADD")
      line1:SetThickness(2)
      local line2 = button:CreateLine()
      line2:SetColorTexture(1, 0, 0, 1)
      line2:SetStartPoint("TOPRIGHT", -3, -3)
      line2:SetEndPoint("BOTTOMLEFT", 3, 3)
      line2:SetBlendMode("ADD")
      line2:SetThickness(2)
      self.line1 = line1
      self.line2 = line2
    end
    self.line1:Show()
    self.line2:Show()
  end
  function button:Clear()
    self.cover:Hide()
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(0.3, 0.3, 0.3, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:UpdateTexture()
    if self.state == nil then
      self:Clear()
    elseif self.state == true then
      self:Yellow()
    elseif self.state == false then
      self:Red()
    end
  end
  function button:SetValue(value)
    self.state = value
    self:UpdateTexture()
  end
  button:SetScript("OnClick", function(self)
    if self.state == true then
      self:SetValue(false)
    elseif self.state == false then
      self:SetValue(nil)
    else
      self:SetValue(true)
    end
    self.obj.obj:Fire("OnValueChanged", self.index, self.state)
  end)
  button:SetScript("OnEnter", function(self)
    GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
    GameTooltip:SetTalent(self.tab, self.index - (self.tab - 1) * MAX_NUM_TALENTS, false, false, false, false)
  end)
  button:Clear()
  return button
end

local function Button_ShowToolTip(self)
  if self.spellId then
    GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
    GameTooltip:SetSpellByID(self.spellId)
  end
end
local function Button_HideToolTip(self)
  GameTooltip:Hide()
end

local function TalentFrame_Update(self)
  local buttonShownCount = 0
  if self.list then
    for _, button in ipairs(self.buttons) do
      local data = self.list[button.index]
      if not data then
        button:Hide()
      else
        local icon, tier, column, spellId = unpack(data)
        if spellId == nil then
          local talentId = button.index - (button.tab - 1) * MAX_NUM_TALENTS
          local name = GetTalentInfo(button.tab, talentId)
          print("Please report on WeakAuras Discord:\nspell missing", button.tab, tier, column, name)
        end
        button.tier = tier
        button.column = column
        button:SetNormalTexture(icon)
        button.spellId = spellId
        button:UpdateTexture()
        button:ClearAllPoints()
        button:SetScript("OnEnter", Button_ShowToolTip)
        button:SetScript("OnLeave", Button_HideToolTip)
        button:SetMotionScriptsWhileDisabled(true)
        if self.open then
          button:SetPoint("TOPLEFT", button.obj, "TOPLEFT", buttonSizePadded * (column - 1) + (button.tab - 1) * buttonSizePadded * 4 + 5, -buttonSizePadded * (tier - 1) - 5)
          button:SetEnabled(true)
          button:SetMouseClickEnabled(true)
          button:Show()
        else
          if button.state ~= nil then
            buttonShownCount = buttonShownCount + 1
            button:SetPoint(
              "TOPLEFT",
              button.obj,
              "TOPLEFT",
              7 + ((buttonShownCount - 1) % 7) * (buttonSizePadded + 4),
              -7 + -1 * (ceil(buttonShownCount / 7) - 1) * (buttonSizePadded + 4)
            )
            button:SetEnabled(false)
            button:SetMouseClickEnabled(false)
            button:Show()
          else
            button:Hide()
          end
        end
      end
    end
  end
  if self.open then
    self.frame:SetHeight(self.saveSize.fullHeight)
  else
    local rows = ceil(buttonShownCount / 7)
    if rows > 0 then
      self.frame:SetHeight(self.saveSize.collapsedRowHeight * rows)
    else
      self.frame:SetHeight(1)
    end
  end
  if self.list then
    local backgroundIndex = MAX_NUM_TALENTS * GetNumTalentTabs() + 1
    for tab = 1, GetNumTalentTabs() do
      local background = self.backgrounds[tab]
      local texture = self.list[backgroundIndex][tab]
      local base = "Interface\\TalentFrame\\" .. texture .. "-"
      background:SetTexture(base .. "TopLeft")
      if self.open then
        background:Show()
      else
        background:Hide()
      end
    end
  end
end

local methods = {
  OnAcquire = function(self)
    self:SetDisabled(false)
  end,

  OnRelease = function(self)
    self:SetDisabled(true)
    self:SetMultiselect(false)
    self.value = nil
    self.list = nil
  end,

  SetList = function(self, list)
    self.list = list or {}
    TalentFrame_Update(self)
  end,

  SetDisabled = function(self, disabled)
    if disabled then
      for _, button in pairs(self.buttons) do
        button:Hide()
      end
      for _, background in pairs(self.backgrounds) do
        background:Hide()
      end
      self.open = nil
      self.toggle.frame:Hide()
      self.frame:Hide()
    else
      self.open = nil
      TalentFrame_Update(self)
      self.toggle.frame:Show()
      self.frame:Show()
    end
  end,

  SetItemValue = function(self, item, value)
    if self.buttons[item] then
      self.buttons[item]:SetValue(value)
      TalentFrame_Update(self)
    end
  end,

  SetValue = function(self, value) end,
  SetLabel = function(self, text) end,
  SetMultiselect = function(self, multi) end,

  ToggleView = function(self)
    if not self.open then
      self.open = true
    else
      self.open = nil
    end
    TalentFrame_Update(self)
    self.parent:DoLayout()
  end,
}

local function Constructor()
  local name = widgetType .. AceGUI:GetNextWidgetNum(widgetType)

  local talentFrame = CreateFrame("Button", name, UIParent)
  talentFrame:SetFrameStrata("FULLSCREEN_DIALOG")

  local buttons = {}
  for i = 1, MAX_NUM_TALENTS * GetNumTalentTabs() do
    local button = CreateTalentButton(talentFrame)
    button.index = i
    button.tab = ceil(i / MAX_NUM_TALENTS)
    table.insert(buttons, button)
  end
  local backgrounds = {}
  for tab = 1, GetNumTalentTabs() do
    local background = talentFrame:CreateTexture(nil, "BACKGROUND")
    background:SetPoint("TOPLEFT", talentFrame, "TOPLEFT", (tab - 1) * buttonSizePadded * 4, 0)
    background:SetPoint("BOTTOMRIGHT", talentFrame, "BOTTOMLEFT", tab * buttonSizePadded * 4, 0)
    background:SetTexCoord(0, 1, 0, 1)
    background:Show()
    table.insert(backgrounds, background)
  end
  -- rescale buttons and resize frame to fit in weakauras options
  local width = buttonSizePadded * 4 * 3 + 10
  local height = buttonSizePadded * 7 + 10
  local finalWidth = 440
  local scale = (finalWidth / width)
  local finalHeight = height * scale
  for _, button in ipairs(buttons) do
    button:SetScale(scale)
  end
  for _, background in ipairs(backgrounds) do
    background:SetScale(scale)
  end
  talentFrame:SetSize(finalWidth, finalHeight)
  talentFrame:SetScript("OnClick", function(self)
    self.obj:ToggleView()
  end)

  local toggle = AceGUI:Create("WeakAurasToolbarButton")
  toggle:SetText(L["Select Talent"])
  toggle:SetTexture("interface/buttons/ui-microbutton-talents-up")
  toggle.icon:ClearAllPoints()
  toggle.icon:SetPoint("LEFT", toggle.frame, "LEFT", 0, 10)
  toggle.icon:SetSize(28, 58)
  toggle.icon:SetScale(0.6)
  toggle.frame:SetPoint("BOTTOMRIGHT", talentFrame, "TOPRIGHT", 0, 2)
  toggle.frame:SetParent(talentFrame)
  toggle.frame.obj.text:SetVertexColor(1, 1, 1, 1)
  toggle.frame:Show()

  toggle:SetCallback("OnClick", function(self)
    local parent = self.frame:GetParent()
    parent.obj:ToggleView()
  end)

  local widget = {
    frame = talentFrame,
    type = widgetType,
    buttons = buttons,
    toggle = toggle,
    backgrounds = backgrounds,
    saveSize = {
      fullWidth = finalWidth,
      fullHeight = finalHeight,
      collapsedRowHeight = (buttonSizePadded + 5) * scale,
    },
  }

  for method, func in pairs(methods) do
    widget[method] = func
  end
  talentFrame.obj = widget

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_Cata.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_Mists.lua ===
if not WeakAuras.IsLibsOK() then
  return
end

local widgetType, widgetVersion = "WeakAurasMiniTalent", 1
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(widgetType) or 0) >= widgetVersion then
  return
end
local L = WeakAuras.L

local buttonSize = 32
local buttonSizePadded = 45

local function CreateTalentButton(parent)
  local button = CreateFrame("Button", nil, parent)
  button.obj = parent
  button:SetSize(buttonSize, buttonSize)

  local cover = button:CreateTexture(nil, "OVERLAY")
  cover:SetTexture("interface/buttons/checkbuttonglow")
  cover:SetPoint("CENTER")
  cover:SetSize(buttonSize + 20, buttonSize + 20)
  cover:SetBlendMode("ADD")
  cover:Hide()
  button.cover = cover
  button:SetHighlightTexture("Interface/Buttons/ButtonHilight-Square", "ADD")
  function button:Yellow()
    self.cover:Show()
    self.cover:SetVertexColor(1, 1, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 1, 1, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:Red()
    self.cover:Show()
    self.cover:SetVertexColor(1, 0, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 0, 0, 1)
    end
    if not self.line1 then
      local line1 = button:CreateLine()
      line1:SetColorTexture(1, 0, 0, 1)
      line1:SetStartPoint("TOPLEFT", 3, -3)
      line1:SetEndPoint("BOTTOMRIGHT", -3, 3)
      line1:SetBlendMode("ADD")
      line1:SetThickness(2)
      local line2 = button:CreateLine()
      line2:SetColorTexture(1, 0, 0, 1)
      line2:SetStartPoint("TOPRIGHT", -3, -3)
      line2:SetEndPoint("BOTTOMLEFT", 3, 3)
      line2:SetBlendMode("ADD")
      line2:SetThickness(2)
      self.line1 = line1
      self.line2 = line2
    end
    self.line1:Show()
    self.line2:Show()
  end
  function button:Clear()
    self.cover:Hide()
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(0.3, 0.3, 0.3, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:UpdateTexture()
    if self.state == nil then
      self:Clear()
    elseif self.state == true then
      self:Yellow()
    elseif self.state == false then
      self:Red()
    end
  end
  function button:SetValue(value)
    self.state = value
    self:UpdateTexture()
  end
  button:SetScript("OnClick", function(self)
    if self.state == true then
      self:SetValue(false)
    elseif self.state == false then
      self:SetValue(nil)
    else
      self:SetValue(true)
    end
    self.obj.obj:Fire("OnValueChanged", self.index, self.state)
  end)
  button:Clear()
  return button
end

local function Button_ShowToolTip(self)
  if self.spellId then
    GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
    GameTooltip:SetSpellByID(self.spellId)
  end
end
local function Button_HideToolTip(self)
  GameTooltip:Hide()
end

local function TalentFrame_Update(self)
  local buttonShownCount = 0
  if self.list then
    for _, button in ipairs(self.buttons) do
      local data = self.list[button.index]
      if not data then
        button:Hide()
      else
        local icon, tier, column, spellId = unpack(data)
        button.tier = tier
        button.column = column
        button:SetNormalTexture(icon)
        button.spellId = spellId
        button:UpdateTexture()
        button:ClearAllPoints()
        button:SetScript("OnEnter", Button_ShowToolTip)
        button:SetScript("OnLeave", Button_HideToolTip)
        button:SetMotionScriptsWhileDisabled(true)
        if self.open then
          button:SetPoint("TOPLEFT", button.obj, "TOP", buttonSizePadded * (column - 2), -buttonSizePadded * (tier - 1) - 5)
          button:SetEnabled(true)
          button:SetMouseClickEnabled(true)
          button:Show()
        else
          if button.state ~= nil then
            buttonShownCount = buttonShownCount + 1
            button:SetPoint(
              "TOPLEFT",
              button.obj,
              "TOPLEFT",
              7 + ((buttonShownCount - 1) % 7) * (buttonSizePadded + 4),
              -7 + -1 * (ceil(buttonShownCount / 7) - 1) * (buttonSizePadded + 4)
            )
            button:SetEnabled(false)
            button:SetMouseClickEnabled(false)
            button:Show()
          else
            button:Hide()
          end
        end
      end
    end
  end
  if self.open then
    self.frame:SetHeight(self.saveSize.fullHeight)
  else
    local rows = ceil(buttonShownCount / 3)
    if rows > 0 then
      self.frame:SetHeight(self.saveSize.collapsedRowHeight * rows)
    else
      self.frame:SetHeight(1)
    end
  end
end

local methods = {
  OnAcquire = function(self)
    self:SetDisabled(false)
  end,

  OnRelease = function(self)
    self:SetDisabled(true)
    self:SetMultiselect(false)
    self.value = nil
    self.list = nil
  end,

  SetList = function(self, list)
    self.list = list or {}
    TalentFrame_Update(self)
  end,

  SetDisabled = function(self, disabled)
    if disabled then
      for _, button in pairs(self.buttons) do
        button:Hide()
      end
      self.open = nil
      self.toggle.frame:Hide()
      self.frame:Hide()
    else
      self.open = nil
      TalentFrame_Update(self)
      self.toggle.frame:Show()
      self.frame:Show()
    end
  end,

  SetItemValue = function(self, item, value)
    if self.buttons[item] then
      self.buttons[item]:SetValue(value)
      TalentFrame_Update(self)
    end
  end,

  SetValue = function(self, value) end,
  SetLabel = function(self, text) end,
  SetMultiselect = function(self, multi) end,

  ToggleView = function(self)
    if not self.open then
      self.open = true
    else
      self.open = nil
    end
    TalentFrame_Update(self)
    self.parent:DoLayout()
  end,
}

local function Constructor()
  local name = widgetType .. AceGUI:GetNextWidgetNum(widgetType)

  local talentFrame = CreateFrame("Button", name, UIParent)
  talentFrame:SetFrameStrata("FULLSCREEN_DIALOG")

  local buttons = {}
  for i = 1, MAX_NUM_TALENTS do
    local button = CreateTalentButton(talentFrame)
    button.index = i
    button.tier = math.ceil(i / 3)
    button.column = (i - 1) % 3 + 1
    table.insert(buttons, button)
  end

  -- rescale buttons and resize frame to fit in weakauras options
  local width = buttonSizePadded * 3 + 400
  local height = buttonSizePadded * 6 + 10
  local finalWidth = 440
  local scale = (finalWidth / width)
  local finalHeight = height * scale
  for _, button in ipairs(buttons) do
    button:SetScale(scale)
  end

  talentFrame:SetSize(finalWidth, finalHeight)
  talentFrame:SetScript("OnClick", function(self)
    self.obj:ToggleView()
  end)

  local toggle = AceGUI:Create("WeakAurasToolbarButton")
  toggle:SetText(L["Select Talent"])
  toggle:SetTexture("interface/buttons/ui-microbutton-talents-up")
  toggle.icon:ClearAllPoints()
  toggle.icon:SetPoint("LEFT", toggle.frame, "LEFT", 0, 10)
  toggle.icon:SetSize(28, 58)
  toggle.icon:SetScale(0.6)
  toggle.frame:SetPoint("BOTTOMRIGHT", talentFrame, "TOPRIGHT", 0, 2)
  toggle.frame:SetParent(talentFrame)
  toggle.frame.obj.text:SetVertexColor(1, 1, 1, 1)
  toggle.frame:Show()

  toggle:SetCallback("OnClick", function(self)
    local parent = self.frame:GetParent()
    parent.obj:ToggleView()
  end)

  local widget = {
    frame = talentFrame,
    type = widgetType,
    buttons = buttons,
    toggle = toggle,
    saveSize = {
      fullWidth = finalWidth,
      fullHeight = finalHeight,
      collapsedRowHeight = (buttonSizePadded + 5) * scale,
    },
  }

  for method, func in pairs(methods) do
    widget[method] = func
  end
  talentFrame.obj = widget

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_Mists.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_TWW.lua ===
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

if not WeakAuras.IsLibsOK() then
  return
end

local keepOpenForReload = {}

local widgetType, widgetVersion = "WeakAurasMiniTalent", 4
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(widgetType) or 0) >= widgetVersion then
  return
end
local L = WeakAuras.L

local buttonSize = 32
local buttonSizePadded = 45

local function Button_ShowToolTip(self)
  if self.spellId then
    GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
    GameTooltip:SetSpellByID(self.spellId, false, false, true)
  end
end
local function Button_HideToolTip()
  GameTooltip:Hide()
end

local function CreateTalentButton()
  local button = CreateFrame("Button")
  button:SetSize(buttonSize, buttonSize)

  local cover = button:CreateTexture(nil, "OVERLAY")
  cover:SetTexture("interface/buttons/checkbuttonglow")
  cover:SetIgnoreParentScale(true)
  cover:SetPoint("TOPLEFT", button, "TOPLEFT", -10, 10)
  cover:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", 10, -10)
  cover:SetBlendMode("ADD")
  cover:Hide()
  button.cover = cover
  button:SetHighlightTexture("Interface/Buttons/ButtonHilight-Square", "ADD")
  function button:Yellow()
    self.cover:Show()
    self.cover:SetVertexColor(1, 1, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 1, 1, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:Red()
    self.cover:Show()
    self.cover:SetVertexColor(1, 0, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 0, 0, 1)
    end
    if not self.line1 then
      local line1 = button:CreateLine()
      line1:SetColorTexture(1, 0, 0, 1)
      line1:SetStartPoint("TOPLEFT", 3, -3)
      line1:SetEndPoint("BOTTOMRIGHT", -3, 3)
      line1:SetBlendMode("ADD")
      line1:SetThickness(2)
      local line2 = button:CreateLine()
      line2:SetColorTexture(1, 0, 0, 1)
      line2:SetStartPoint("TOPRIGHT", -3, -3)
      line2:SetEndPoint("BOTTOMLEFT", 3, 3)
      line2:SetBlendMode("ADD")
      line2:SetThickness(2)
      self.line1 = line1
      self.line2 = line2
    end
    self.line1:Show()
    self.line2:Show()
  end
  function button:Clear()
    self.cover:Hide()
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(0.3, 0.3, 0.3, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:UpdateTexture()
    if self.state == nil then
      self:Clear()
    elseif self.state == true then
      self:Yellow()
    elseif self.state == false then
      self:Red()
    end
  end
  function button:SetValue(value)
    self.state = value
    self:UpdateTexture()
  end
  function button:LineGetPoint()
    if self.offset == nil then
      return "CENTER"
    elseif self.offset == "left" then
      return "RIGHT"
    elseif self.offset == "right" then
      return "LEFT"
    end
  end
  button:SetScript("OnClick", function(self)
    if self.state == true then
      self:SetValue(false)
    elseif self.state == false then
      self:SetValue(nil)
    else
      self:SetValue(true)
    end
    self.obj.obj:Fire("OnValueChanged", self.index, self.state)
  end)
  button:Clear()
  button:SetScript("OnEnter", Button_ShowToolTip)
  button:SetScript("OnLeave", Button_HideToolTip)
  button:SetMotionScriptsWhileDisabled(true)

  return button
end

local function resetLine(pool, line)
  line:Hide()
  line:ClearAllPoints()
end

local function TalentFrame_Update(self)
  local buttonShownCount = 0
  self.linePool:ReleaseAll()
  if self.list then
    for _, button in ipairs(self.buttons) do
      if self.open then
        local posX = button.posX
        local posY = - button.posY
        local point = "CENTER"
        if button.offset then
          if button.offset == "left" then
            point = "RIGHT"
          elseif button.offset == "right" then
            point = "LEFT"
          end
        else
          point = "CENTER"
        end
        button:ClearAllPoints()

        button:SetPoint(point, button.obj, "TOPLEFT", posX, posY)
        button:SetEnabled(true)
        button:SetMouseClickEnabled(true)
        button:SetSize((buttonSize/self.scale) * .5, (buttonSize/self.scale) * .5)
        button:SetScale(self.scale)
        button.cover:ClearAllPoints()
        button.cover:SetPoint("TOPLEFT", button, "TOPLEFT", -5, 5)
        button.cover:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", 5, -5)
        button:Show()
        for _, target in pairs(button.targets) do
          if self.talentIdToButton[target] == nil then
            -- print("Talent connect to unknown talent", button.talentId, target)
          elseif button.offset == "right" then
            -- don't trace line for right buttons
          else
            local line = self.linePool:Acquire()
            line:SetStartPoint(button:LineGetPoint(), button)
            local targetButton = self.talentIdToButton[target]
            line:SetEndPoint(targetButton:LineGetPoint(), targetButton)
            line:SetColorTexture(1,1,1,0.2)
            line:SetThickness(1)
            line:Show()
          end
        end
      else
        if button.state ~= nil then
          buttonShownCount = buttonShownCount + 1
          button:ClearAllPoints()
          button:SetPoint(
            "TOPLEFT",
            button.obj,
            "TOPLEFT",
            7 + ((buttonShownCount - 1) % 9) * (buttonSizePadded + 4),
            -7 + -1 * (ceil(buttonShownCount / 9) - 1) * (buttonSizePadded + 4)
          )
          button:SetEnabled(false)
          button:SetMouseClickEnabled(false)
          button:SetSize(buttonSize, buttonSize)
          button:SetScale(1)
          button.cover:ClearAllPoints()
          button.cover:SetPoint("TOPLEFT", button, "TOPLEFT", -10, 10)
          button.cover:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", 10, -10)
          button:Show()
        else
          button:Hide()
        end
      end
    end
  end
  if self.open then
    self.frame:SetHeight(self.saveSize.fullHeight)
    self.background:Show()
  else
    local rows = ceil(buttonShownCount / 11)
    if rows > 0 then
      self.frame:SetHeight(self.saveSize.collapsedRowHeight * rows)
    else
      self.frame:SetHeight(1)
    end
    self.background:Hide()
  end
end

local methods = {
  OnAcquire = function(self)
    self:SetDisabled(false)
    self.acquired = true
  end,

  OnRelease = function(self)
    self:SetDisabled(true)
    self:SetMultiselect(false)
    self.buttonPool:ReleaseAll()
    self.linePool:ReleaseAll()
    self.value = nil
    self.list = nil
    self.acquired = false
  end,

  SetList = function(self, list)
    self.list = list or {}
    self.buttonPool:ReleaseAll()
    self.linePool:ReleaseAll()
    self.buttons = {}
    self.talentIdToButton = {}
    local extraOffset = self.list[1000]
    for index, data in pairs(self.list) do
      if index < 999 then -- background index & extraOffset
        local button = self.buttonPool:Acquire()
        button.index = index
        button:SetParent(self.frame)
        button.obj = self.frame
        local talentId = data[1]
        button.talentId = talentId
        self.talentIdToButton[talentId] = button
        local spellId = data[2]
        button.spellId = spellId
        local icon = select(8, OptionsPrivate.Private.ExecEnv.GetSpellInfo(spellId))
        if icon then
          button:SetNormalTexture(icon)
        end
        local multiTalent, multiTalentTotal, subTreePosition = 0, 0, nil
        button.posX, button.posY, multiTalent, multiTalentTotal, subTreePosition = unpack(data[3])
        button.posX = button.posX / 10 - (extraOffset and extraOffset.offsetX or 0)
        button.posY = button.posY / 10 - (extraOffset and extraOffset.offsetY or 0)
        if multiTalentTotal > 1 then
          if multiTalent == 1 then
            button.offset = "left"
          else
            button.offset = "right"
          end
        else
          button.offset = nil
        end
        if subTreePosition then
          button.side = subTreePosition == 1 and "left" or "right"
        end
        button.targets = data[4]
        button:UpdateTexture()
        button:ClearAllPoints()
        tinsert(self.buttons, button)
      end
    end

    -- zoom both panel in their center
    local isSubTree = self.list[1001]
    local talentWidth
    local talentHeight
    local talentIconSize = 36
    local scale
    if not isSubTree then
      talentWidth = 1612
      talentHeight = 856
      local cutmid = 120
      local LeftPanelCenter = { x = (talentWidth / 2 - cutmid) / 2, y = talentHeight / 2 }
      local RightPanelCenter = { x = ((talentWidth / 2 + cutmid) + talentWidth) / 2 , y = talentHeight / 2 }
      scale = 1.3
      for _, b in pairs(self.buttons) do
        if b.posX < talentWidth / 2 then -- left panel
          b.posX = b.posX - LeftPanelCenter.x
          b.posX = b.posX * scale
          b.posX = b.posX + LeftPanelCenter.x - talentIconSize / 2
          b.posY = b.posY - LeftPanelCenter.y
          b.posY = b.posY * scale
          b.posY = b.posY + LeftPanelCenter.y * scale
        else                     -- right panel
          b.posX = b.posX - RightPanelCenter.x
          b.posX = b.posX * scale
          b.posX = b.posX + RightPanelCenter.x + talentIconSize / 2
          b.posY = b.posY - RightPanelCenter.y
          b.posY = b.posY * scale
          b.posY = b.posY + RightPanelCenter.y * scale
        end
      end
    else
      talentWidth = 200
      talentHeight = 300
      local midLeft, midRight = talentWidth / 4, (talentWidth / 4) * 3
      scale = 0.3
      for _, b in pairs(self.buttons) do
        b.posX = b.posX * scale
        b.posY = b.posY * scale
        b.posY = b.posY + 10
        if b.side == "left" then
          b.posX = b.posX + midLeft
        else
          b.posX = b.posX + midRight
        end
      end
    end
    self.scale = self.saveSize.fullWidth / talentWidth
    self.saveSize.fullHeight = talentHeight * self.scale * scale
    if self.list[999] then
      self.background:SetAtlas(self.list[999])
      self.background:SetBlendMode("ADD")
    end
    TalentFrame_Update(self)
  end,

  SetDisabled = function(self, disabled)
    if disabled then
      for _, button in pairs(self.buttons) do
        button:Hide()
      end
      self.background:Hide()
      self.open = nil
      self.toggle.frame:Hide()
      self.frame:Hide()
    else
      self.open = nil
      TalentFrame_Update(self)
      self.toggle.frame:Show()
      self.frame:Show()
    end
  end,

  SetItemValue = function(self, item, value)
    if self.buttons[item] then
      self.buttons[item]:SetValue(value)
      TalentFrame_Update(self)
    end
  end,

  SetValue = function(self, value) end,
  SetLabel = function(self, text) end,
  SetMultiselect = function(self, multi) end,

  ToggleView = function(self, force)
    if force ~= nil then
      self.open = force
    else
      if not self.open then
        self.open = true
      else
        self.open = nil
      end
    end
    TalentFrame_Update(self)
    self.parent:DoLayout()
  end,
}

local function Constructor()
  local name = widgetType .. AceGUI:GetNextWidgetNum(widgetType)

  local talentFrame = CreateFrame("Button", name, UIParent)
  talentFrame:SetFrameStrata("FULLSCREEN_DIALOG")

  local buttons = {}
  talentFrame:SetWidth(440)
  talentFrame:SetScript("OnClick", function(self)
    self.obj:ToggleView()
  end)
  local background = talentFrame:CreateTexture(nil, "BACKGROUND")
  background:SetAllPoints(talentFrame)

  local toggle = AceGUI:Create("WeakAurasToolbarButton")
  toggle:SetText(L["Select Talent"])
  toggle:SetTexture("interface/buttons/ui-microbutton-talents-up")
  toggle.icon:ClearAllPoints()
  toggle.icon:SetPoint("LEFT", toggle.frame, "LEFT", 0, 10)
  toggle.icon:SetSize(28, 58)
  toggle.icon:SetScale(0.6)
  toggle.frame:SetPoint("BOTTOMRIGHT", talentFrame, "TOPRIGHT", 0, 2)
  toggle.frame:SetParent(talentFrame)
  toggle.frame.obj.text:SetVertexColor(1, 1, 1, 1)
  toggle.frame:Show()

  toggle:SetCallback("OnClick", function(self)
    local parent = self.frame:GetParent()
    parent.obj:ToggleView()
  end)

  local widget = {
    frame = talentFrame,
    type = widgetType,
    buttons = buttons,
    toggle = toggle,
    background = background,
    saveSize = {
      fullWidth = 440,
      fullHeight = 0,
      collapsedRowHeight = (buttonSizePadded + 5),
    },
    linePool = CreateObjectPool(
      function(pool)
        return talentFrame:CreateLine()
      end,
      resetLine
    ),
    buttonPool = CreateObjectPool(CreateTalentButton)
  }

  for method, func in pairs(methods) do
    widget[method] = func
  end
  talentFrame.obj = widget

  local function OnBeforeReload()
    if widget.acquired then
      local user = widget:GetUserDataTable()
      if user and user.path then
        keepOpenForReload[user.path[#user.path]] = widget.open
      end
    end
  end

  local function OnAfterReload()
    if widget.acquired then
      local user = widget:GetUserDataTable()
      if user and user.path then
        if keepOpenForReload[user.path[#user.path]] then
          widget:ToggleView(true)
          keepOpenForReload[user.path[#user.path]] = nil
        end
      end
    end
  end

  OptionsPrivate.Private.callbacks:RegisterCallback("BeforeReload", OnBeforeReload)
  OptionsPrivate.Private.callbacks:RegisterCallback("AfterReload", OnAfterReload)

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_TWW.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_Wrath.lua ===
if not WeakAuras.IsLibsOK() then
  return
end

local widgetType, widgetVersion = "WeakAurasMiniTalent", 3
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(widgetType) or 0) >= widgetVersion then
  return
end
local L = WeakAuras.L

local buttonSize = 32
local buttonSizePadded = 45

local function CreateTalentButton(parent)
  local button = CreateFrame("Button", nil, parent)
  button.obj = parent
  button:SetSize(buttonSize, buttonSize)

  local cover = button:CreateTexture(nil, "OVERLAY")
  cover:SetTexture("interface/buttons/checkbuttonglow")
  cover:SetPoint("CENTER")
  cover:SetSize(buttonSize + 20, buttonSize + 20)
  cover:SetBlendMode("ADD")
  cover:Hide()
  button.cover = cover
  button:SetHighlightTexture("Interface/Buttons/ButtonHilight-Square", "ADD")
  function button:Yellow()
    self.cover:Show()
    self.cover:SetVertexColor(1, 1, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 1, 1, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:Red()
    self.cover:Show()
    self.cover:SetVertexColor(1, 0, 0, 1)
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(1, 0, 0, 1)
    end
    if not self.line1 then
      local line1 = button:CreateLine()
      line1:SetColorTexture(1, 0, 0, 1)
      line1:SetStartPoint("TOPLEFT", 3, -3)
      line1:SetEndPoint("BOTTOMRIGHT", -3, 3)
      line1:SetBlendMode("ADD")
      line1:SetThickness(2)
      local line2 = button:CreateLine()
      line2:SetColorTexture(1, 0, 0, 1)
      line2:SetStartPoint("TOPRIGHT", -3, -3)
      line2:SetEndPoint("BOTTOMLEFT", 3, 3)
      line2:SetBlendMode("ADD")
      line2:SetThickness(2)
      self.line1 = line1
      self.line2 = line2
    end
    self.line1:Show()
    self.line2:Show()
  end
  function button:Clear()
    self.cover:Hide()
    local normalTexture = self:GetNormalTexture()
    if normalTexture then
      normalTexture:SetVertexColor(0.3, 0.3, 0.3, 1)
    end
    if self.line1 then
      self.line1:Hide()
      self.line2:Hide()
    end
  end
  function button:UpdateTexture()
    if self.state == nil then
      self:Clear()
    elseif self.state == true then
      self:Yellow()
    elseif self.state == false then
      self:Red()
    end
  end
  function button:SetValue(value)
    self.state = value
    self:UpdateTexture()
  end
  button:SetScript("OnClick", function(self)
    if self.state == true then
      self:SetValue(false)
    elseif self.state == false then
      self:SetValue(nil)
    else
      self:SetValue(true)
    end
    self.obj.obj:Fire("OnValueChanged", self.index, self.state)
  end)
  button:SetScript("OnEnter", function(self)
    GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
    GameTooltip:SetTalent(self.tab, self.index - (self.tab - 1) * MAX_NUM_TALENTS, false, false, false, false)
  end)
  button:Clear()
  return button
end

local function Button_ShowToolTip(self)
  if self.spellId then
    GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
    GameTooltip:SetSpellByID(self.spellId)
  end
end
local function Button_HideToolTip(self)
  GameTooltip:Hide()
end

local function TalentFrame_Update(self)
  local buttonShownCount = 0
  if self.list then
    for _, button in ipairs(self.buttons) do
      local data = self.list[button.index]
      if not data then
        button:Hide()
      else
        local icon, tier, column, spellId = unpack(data)
        if spellId == nil then
          local talentId = button.index - (button.tab - 1) * MAX_NUM_TALENTS
          local name = GetTalentInfo(button.tab, talentId)
          print("Please report on WeakAuras Discord:\nspell missing", button.tab, tier, column, name)
        end
        button.tier = tier
        button.column = column
        button:SetNormalTexture(icon)
        button.spellId = spellId
        button:UpdateTexture()
        button:ClearAllPoints()
        button:SetScript("OnEnter", Button_ShowToolTip)
        button:SetScript("OnLeave", Button_HideToolTip)
        button:SetMotionScriptsWhileDisabled(true)
        if self.open then
          button:SetPoint("TOPLEFT", button.obj, "TOPLEFT", buttonSizePadded * (column - 1) + (button.tab - 1) * buttonSizePadded * 4 + 5, -buttonSizePadded * (tier - 1) - 5)
          button:SetEnabled(true)
          button:SetMouseClickEnabled(true)
          button:Show()
        else
          if button.state ~= nil then
            buttonShownCount = buttonShownCount + 1
            button:SetPoint(
              "TOPLEFT",
              button.obj,
              "TOPLEFT",
              7 + ((buttonShownCount - 1) % 11) * (buttonSizePadded + 4),
              -7 + -1 * (ceil(buttonShownCount / 11) - 1) * (buttonSizePadded + 4)
            )
            button:SetEnabled(false)
            button:SetMouseClickEnabled(false)
            button:Show()
          else
            button:Hide()
          end
        end
      end
    end
  end
  if self.open then
    self.frame:SetHeight(self.saveSize.fullHeight)
  else
    local rows = ceil(buttonShownCount / 11)
    if rows > 0 then
      self.frame:SetHeight(self.saveSize.collapsedRowHeight * rows)
    else
      self.frame:SetHeight(1)
    end
  end
  if self.list then
    local backgroundIndex = MAX_NUM_TALENTS * GetNumTalentTabs() + 1
    for tab = 1, GetNumTalentTabs() do
      local background = self.backgrounds[tab]
      local texture = self.list[backgroundIndex][tab]
      local base = "Interface\\TalentFrame\\" .. texture .. "-"
      background:SetTexture(base .. "TopLeft")
      if self.open then
        background:Show()
      else
        background:Hide()
      end
    end
  end
end

local methods = {
  OnAcquire = function(self)
    self:SetDisabled(false)
  end,

  OnRelease = function(self)
    self:SetDisabled(true)
    self:SetMultiselect(false)
    self.value = nil
    self.list = nil
  end,

  SetList = function(self, list)
    self.list = list or {}
    TalentFrame_Update(self)
  end,

  SetDisabled = function(self, disabled)
    if disabled then
      for _, button in pairs(self.buttons) do
        button:Hide()
      end
      for _, background in pairs(self.backgrounds) do
        background:Hide()
      end
      self.open = nil
      self.toggle.frame:Hide()
      self.frame:Hide()
    else
      self.open = nil
      TalentFrame_Update(self)
      self.toggle.frame:Show()
      self.frame:Show()
    end
  end,

  SetItemValue = function(self, item, value)
    if self.buttons[item] then
      self.buttons[item]:SetValue(value)
      TalentFrame_Update(self)
    end
  end,

  SetValue = function(self, value) end,
  SetLabel = function(self, text) end,
  SetMultiselect = function(self, multi) end,

  ToggleView = function(self)
    if not self.open then
      self.open = true
    else
      self.open = nil
    end
    TalentFrame_Update(self)
    self.parent:DoLayout()
  end,
}

local function Constructor()
  local name = widgetType .. AceGUI:GetNextWidgetNum(widgetType)

  local talentFrame = CreateFrame("Button", name, UIParent)
  talentFrame:SetFrameStrata("FULLSCREEN_DIALOG")

  local buttons = {}
  for i = 1, MAX_NUM_TALENTS * GetNumTalentTabs() do
    local button = CreateTalentButton(talentFrame)
    button.index = i
    button.tab = ceil(i / MAX_NUM_TALENTS)
    table.insert(buttons, button)
  end
  local backgrounds = {}
  for tab = 1, GetNumTalentTabs() do
    local background = talentFrame:CreateTexture(nil, "BACKGROUND")
    background:SetPoint("TOPLEFT", talentFrame, "TOPLEFT", (tab - 1) * buttonSizePadded * 4, 0)
    background:SetPoint("BOTTOMRIGHT", talentFrame, "BOTTOMLEFT", tab * buttonSizePadded * 4, 0)
    background:SetTexCoord(0, 1, 0, 1)
    background:Show()
    table.insert(backgrounds, background)
  end
  -- rescale buttons and resize frame to fit in weakauras options
  local width = buttonSizePadded * 4 * 3 + 10
  local height = buttonSizePadded * 11 + 10
  local finalWidth = 440
  local scale = (finalWidth / width)
  local finalHeight = height * scale
  for _, button in ipairs(buttons) do
    button:SetScale(scale)
  end
  for _, background in ipairs(backgrounds) do
    background:SetScale(scale)
  end
  talentFrame:SetSize(finalWidth, finalHeight)
  talentFrame:SetScript("OnClick", function(self)
    self.obj:ToggleView()
  end)

  local toggle = AceGUI:Create("WeakAurasToolbarButton")
  toggle:SetText(L["Select Talent"])
  toggle:SetTexture("interface/buttons/ui-microbutton-talents-up")
  toggle.icon:ClearAllPoints()
  toggle.icon:SetPoint("LEFT", toggle.frame, "LEFT", 0, 10)
  toggle.icon:SetSize(28, 58)
  toggle.icon:SetScale(0.6)
  toggle.frame:SetPoint("BOTTOMRIGHT", talentFrame, "TOPRIGHT", 0, 2)
  toggle.frame:SetParent(talentFrame)
  toggle.frame.obj.text:SetVertexColor(1, 1, 1, 1)
  toggle.frame:Show()

  toggle:SetCallback("OnClick", function(self)
    local parent = self.frame:GetParent()
    parent.obj:ToggleView()
  end)

  local widget = {
    frame = talentFrame,
    type = widgetType,
    buttons = buttons,
    toggle = toggle,
    backgrounds = backgrounds,
    saveSize = {
      fullWidth = finalWidth,
      fullHeight = finalHeight,
      collapsedRowHeight = (buttonSizePadded + 5) * scale,
    },
  }

  for method, func in pairs(methods) do
    widget[method] = func
  end
  talentFrame.obj = widget

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMiniTalent_Wrath.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMultiLineEditBox.lua ===
if not WeakAuras.IsLibsOK() then return end

---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local Type, Version = "WeakAurasMultiLineEditBox", 39
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local GetCursorInfo, ClearCursor = GetCursorInfo, ClearCursor
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = _G

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

if not AceGUIWeakAurasMultiLineEditBoxInsertLink then
  -- upgradeable hook
  hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIWeakAurasMultiLineEditBoxInsertLink(...) end)
end

function _G.AceGUIWeakAurasMultiLineEditBoxInsertLink(text)
  for i = 1, AceGUI:GetWidgetCount(Type) do
    local editbox = _G[("WeakAurasMultiLineEditBox%uEdit"):format(i)]
    if editbox and editbox:IsVisible() and editbox:HasFocus() then
      text = text:gsub("|", "||")
      editbox:Insert(text)
      return true
    end
  end
end


local function Layout(self)
  self:SetHeight(self.numlines * 14 + (self.disablebutton and 19 or 41) + self.labelHeight)

  if self.labelHeight == 0 then
    self.scrollBar:SetPoint("TOP", self.frame, "TOP", 0, -23)
  else
    self.scrollBar:SetPoint("TOP", self.label, "BOTTOM", 0, -19)
  end

  if self.disablebutton then
    self.scrollBar:SetPoint("BOTTOM", self.frame, "BOTTOM", 0, 21)
    self.scrollBG:SetPoint("BOTTOMLEFT", 0, 4)
  else
    self.scrollBar:SetPoint("BOTTOM", self.button, "TOP", 0, 18)
    self.scrollBG:SetPoint("BOTTOMLEFT", self.button, "TOPLEFT")
  end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function OnClick(self)                                                     -- Button
  self = self.obj
  self.editBox:ClearFocus()
  if not self:Fire("OnEnterPressed", IndentationLib.decode(self.editBox:GetText())) then
    self.button:Disable()
  end
end

local function OnCursorChanged(self, _, y, _, cursorHeight)                      -- EditBox
  self, y = self.obj.scrollFrame, -y
  local offset = self:GetVerticalScroll()
  if y < offset then
    self:SetVerticalScroll(y)
  else
    y = y + cursorHeight - self:GetHeight()
    if y > offset then
      self:SetVerticalScroll(y)
    end
  end
end

local function OnEditFocusLost(frame)                                             -- EditBox
  local self = frame.obj
  frame:HighlightText(0, 0)
  self:Fire("OnEditFocusLost")
  self.scrollFrame:EnableMouseWheel(false);

  local option = self.userdata.option
  if option and option.callbacks and option.callbacks.OnEditFocusLost then
    option.callbacks.OnEditFocusLost(self)
  end
end

local function OnEnter(self)                                                     -- EditBox / ScrollFrame
  self = self.obj
  if not self.entered then
    self.entered = true
    self:Fire("OnEnter")
  end
end

local function OnLeave(self)                                                     -- EditBox / ScrollFrame
  self = self.obj
  if self.entered then
    self.entered = nil
    self:Fire("OnLeave")
  end
end

local function OnMouseUp(self)                                                   -- ScrollFrame
  self = self.obj.editBox
  self:SetFocus()
  self:SetCursorPosition(self:GetNumLetters())
end

local function OnReceiveDrag(self)                                               -- EditBox / ScrollFrame
  local infoType, spellIndex, bookType, info = GetCursorInfo()
  if infoType == "spell" then
    info = OptionsPrivate.Private.ExecEnv.GetSpellName(info)
  elseif infoType ~= "item" then
    return
  end
  ClearCursor()
  self = self.obj
  local editBox = self.editBox
  if not editBox:HasFocus() then
    editBox:SetFocus()
    editBox:SetCursorPosition(editBox:GetNumLetters())
  end
  editBox:Insert(info)
  self.button:Enable()
end

local function OnSizeChanged(self, width, height)                                -- ScrollFrame
  self.obj.editBox:SetWidth(width)
end

local function OnTextChanged(self, userInput)                                    -- EditBox
  if userInput then
    self = self.obj
    self:Fire("OnTextChanged", IndentationLib.decode(self.editBox:GetText()))
    self.button:Enable()
end
end

local function OnTextSet(self)                                                   -- EditBox
  self:HighlightText(0, 0)
  self:SetCursorPosition(self:GetNumLetters())
  self:SetCursorPosition(0)
  self.obj.button:Disable()
end

local function OnVerticalScroll(self, offset)                                    -- ScrollFrame
  local editBox = self.obj.editBox
  editBox:SetHitRectInsets(0, 0, offset, editBox:GetHeight() - offset - self:GetHeight())
end

local function OnFrameShow(frame)
  if (frame.focusOnShow) then
    frame.obj.editBox:SetFocus()
    frame.focusOnShow = nil;
  end
  local self = frame.obj;
  local option = self.userdata.option;
  local numExtraButtons = 0;
  if (option and option.arg and option.arg.extraFunctions) then
    numExtraButtons = #option.arg.extraFunctions;
    for index, data in ipairs(option.arg.extraFunctions) do
      if (not self.extraButtons[index]) then
        local extraButton = CreateFrame("Button", ("%s%dExpandButton%d"):format(Type, self.widgetNum, index), frame, "UIPanelButtonTemplate")
        extraButton:SetPoint("LEFT", self.extraButtons[index - 1], "RIGHT");
        extraButton:SetHeight(22)
        extraButton:SetWidth(100);
        self.extraButtons[index] = extraButton;
      end
      local extraButton = self.extraButtons[index];
      extraButton:SetText(data.buttonLabel);
      extraButton:SetScript("OnClick", data.func);
      extraButton:Show();
    end
  end

  if option and option.callbacks and option.callbacks.OnShow then
    option.callbacks.OnShow(self)
  end

  for i = numExtraButtons + 1, #self.extraButtons do
    self.extraButtons[i]:Hide();
  end
end

local function OnEditFocusGained(frame)
  AceGUI:SetFocus(frame.obj)
  frame.obj:Fire("OnEditFocusGained")
  frame.obj.scrollFrame:EnableMouseWheel(true);

  local option = frame.obj.userdata.option
  if option and option.callbacks and option.callbacks.OnEditFocusGained then
    option.callbacks.OnEditFocusGained(frame.obj)
  end
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self.editBox:SetText("")
    self:SetDisabled(false)
    self:SetWidth(200)
    self:DisableButton(false)
    self:SetNumLines()
    self.entered = nil
    self:SetMaxLetters(0)
  end,

  ["OnRelease"] = function(self)
    self:ClearFocus()
  end,

  ["SetDisabled"] = function(self, disabled)
    local editBox = self.editBox
    if disabled then
      editBox:ClearFocus()
      editBox:EnableMouse(false)
      editBox:SetTextColor(0.5, 0.5, 0.5)
      self.label:SetTextColor(0.5, 0.5, 0.5)
      self.scrollFrame:EnableMouse(false)
      self.button:Disable()
    else
      editBox:EnableMouse(true)
      editBox:SetTextColor(1, 1, 1)
      self.label:SetTextColor(1, 0.82, 0)
      self.scrollFrame:EnableMouse(true)
    end
  end,

  ["SetLabel"] = function(self, text)
    if text and text ~= "" then
      self.label:SetText(text)
      if self.labelHeight ~= 10 then
        self.labelHeight = 10
        self.label:Show()
      end
    elseif self.labelHeight ~= 0 then
      self.labelHeight = 0
      self.label:Hide()
    end
    Layout(self)
  end,

  ["SetNumLines"] = function(self, value)
    if not value or value < 4 then
      value = 4
    end
    self.numlines = value
    Layout(self)
  end,

  ["SetText"] = function(self, text)
    self.editBox:SetText(IndentationLib.encode(text))
  end,

  ["GetText"] = function(self)
    return IndentationLib.decode(self.editBox:GetText())
  end,

  ["SetMaxLetters"] = function (self, num)
    self.editBox:SetMaxLetters(num or 0)
  end,

  ["DisableButton"] = function(self, disabled)
    self.disablebutton = disabled
    if disabled then
      self.button:Hide()
    else
      self.button:Show()
    end
    Layout(self)
  end,

  ["ClearFocus"] = function(self)
    self.editBox:ClearFocus()
    self.frame.focusOnShow = nil;
  end,

  ["SetFocus"] = function(self)
    self.editBox:SetFocus()
    if not self.frame:IsShown() then
      self.frame.focusOnShow = true;
    end
  end,

  ["HighlightText"] = function(self, from, to)
    self.editBox:HighlightText(from, to)
  end,

  ["GetCursorPosition"] = function(self)
    return self.editBox:GetCursorPosition()
  end,

  ["SetCursorPosition"] = function(self, ...)
    return self.editBox:SetCursorPosition(...)
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local backdrop = {
  bgFile = [[Interface\Tooltips\UI-Tooltip-Background]],
  edgeFile = [[Interface\Tooltips\UI-Tooltip-Border]], edgeSize = 16,
  insets = { left = 4, right = 3, top = 4, bottom = 3 }
}

local function Constructor()
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:Hide()

  frame:SetScript("OnShow", OnFrameShow);
  local widgetNum = AceGUI:GetNextWidgetNum(Type)

  local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
  label:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, -4)
  label:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, -4)
  label:SetJustifyH("LEFT")
  label:SetText(ACCEPT)
  label:SetHeight(10)

  local button = CreateFrame("Button", ("%s%dButton"):format(Type, widgetNum), frame, "UIPanelButtonTemplate")
  button:SetPoint("BOTTOMLEFT", 0, 4)
  button:SetHeight(22)
  button:SetWidth(100)
  button:SetText(ACCEPT)
  button:SetScript("OnClick", OnClick)
  button:Disable()

  local extraButtons = {};
  extraButtons[0] = button;

  local scrollBG = CreateFrame("Frame", nil, frame, "BackdropTemplate")
  scrollBG:SetBackdrop(backdrop)
  scrollBG:SetBackdropColor(0, 0, 0)
  scrollBG:SetBackdropBorderColor(0.4, 0.4, 0.4)

  local scrollFrame = CreateFrame("ScrollFrame", ("%s%dScrollFrame"):format(Type, widgetNum),
                                  frame, "UIPanelScrollFrameTemplate")
  scrollFrame:EnableMouseWheel(false);

  local scrollBar = _G[scrollFrame:GetName() .. "ScrollBar"]
  scrollBar:ClearAllPoints()
  scrollBar:SetPoint("TOP", label, "BOTTOM", 0, -19)
  scrollBar:SetPoint("BOTTOM", button, "TOP", 0, 18)
  scrollBar:SetPoint("RIGHT", frame, "RIGHT")

  scrollBG:SetPoint("TOPRIGHT", scrollBar, "TOPLEFT", 0, 19)
  scrollBG:SetPoint("BOTTOMLEFT", button, "TOPLEFT")

  scrollFrame:SetPoint("TOPLEFT", scrollBG, "TOPLEFT", 5, -6)
  scrollFrame:SetPoint("BOTTOMRIGHT", scrollBG, "BOTTOMRIGHT", -4, 4)
  scrollFrame:SetScript("OnEnter", OnEnter)
  scrollFrame:SetScript("OnLeave", OnLeave)
  scrollFrame:SetScript("OnMouseUp", OnMouseUp)
  scrollFrame:SetScript("OnReceiveDrag", OnReceiveDrag)
  scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
  scrollFrame:HookScript("OnVerticalScroll", OnVerticalScroll)

  local editBox = CreateFrame("EditBox", ("%s%dEdit"):format(Type, widgetNum), scrollFrame)
  editBox:SetAllPoints()
  editBox:SetFontObject(ChatFontNormal)
  editBox:SetMultiLine(true)
  editBox:EnableMouse(true)
  editBox:SetAutoFocus(false)
  editBox:SetCountInvisibleLetters(false)
  editBox:SetScript("OnCursorChanged", OnCursorChanged)
  editBox:SetScript("OnEditFocusLost", OnEditFocusLost)
  editBox:SetScript("OnEnter", OnEnter)
  editBox:SetScript("OnEscapePressed", editBox.ClearFocus)
  editBox:SetScript("OnLeave", OnLeave)
  editBox:SetScript("OnMouseDown", OnReceiveDrag)
  editBox:SetScript("OnReceiveDrag", OnReceiveDrag)
  editBox:SetScript("OnTextChanged", OnTextChanged)
  editBox:SetScript("OnTextSet", OnTextSet)
  editBox:SetScript("OnEditFocusGained", OnEditFocusGained)


  scrollFrame:SetScrollChild(editBox)

  local widget = {
    button      = button,
    extraButtons = extraButtons,
    editBox     = editBox,
    editbox     = editBox,
    frame       = frame,
    label       = label,
    labelHeight = 10,
    numlines    = 4,
    scrollBar   = scrollBar,
    scrollBG    = scrollBG,
    scrollFrame = scrollFrame,
    type        = Type,
    widgetNum   = widgetNum,
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end
  button.obj, editBox.obj, scrollFrame.obj = widget, widget, widget

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMultiLineEditBox.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMultiLineEditBoxWithEnter.lua ===
if not WeakAuras.IsLibsOK() then return end

---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- based on the AceGUI widget, overwrites the enter handling
local Type, Version = "WeakAuras-MultiLineEditBoxWithEnter", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
local LAAC = LibStub("LibAPIAutoComplete-1.0")

-- Lua APIs
local pairs = pairs

-- WoW APIs
local GetCursorInfo, ClearCursor = GetCursorInfo, ClearCursor
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = _G

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

if not AceGUIWeakAurasMultiLineEditBoxWithEnterInsertLink then
  -- upgradeable hook
  hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIWeakAurasMultiLineEditBoxWithEnterInsertLink(...) end)
end

function _G.AceGUIWeakAurasMultiLineEditBoxWithEnterInsertLink(text)
  for i = 1, AceGUI:GetWidgetCount(Type) do
    local editbox = _G[("MultiLineEditBox%uEdit"):format(i)]
    if editbox and editbox:IsVisible() and editbox:HasFocus() then
      text = text:gsub("|", "||")
      editbox:Insert(text)
      return true
    end
  end
end


local function Layout(self)
  self:SetHeight(self.numlines * 14 + (self.disablebutton and 19 or 41) + self.labelHeight)

  if self.labelHeight == 0 then
    self.scrollBar:SetPoint("TOP", self.frame, "TOP", 0, -23)
  else
    self.scrollBar:SetPoint("TOP", self.label, "BOTTOM", 0, -19)
  end

  if self.disablebutton then
    self.scrollBar:SetPoint("BOTTOM", self.frame, "BOTTOM", 0, 21)
    self.scrollBG:SetPoint("BOTTOMLEFT", 0, 4)
  else
    self.scrollBar:SetPoint("BOTTOM", self.button, "TOP", 0, 18)
    self.scrollBG:SetPoint("BOTTOMLEFT", self.button, "TOPLEFT")
  end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function OnEnterPressed(self)                                             -- EditBox
  self:HighlightText(0, 0)
  self.obj:Fire("OnEnterPressed", self:GetText())
end


local function OnClick(self)                                                     -- Button
  self = self.obj
  self.editBox:ClearFocus()
  if not self:Fire("OnEnterPressed", self.editBox:GetText()) then
    self.button:Disable()
  end
end

local function OnCursorChanged(self, _, y, _, cursorHeight)                      -- EditBox
  self, y = self.obj.scrollFrame, -y
  local offset = self:GetVerticalScroll()
  if y < offset then
    self:SetVerticalScroll(y)
  else
    y = y + cursorHeight - self:GetHeight()
    if y > offset then
      self:SetVerticalScroll(y)
    end
  end
end

local function OnEditFocusLost(self)                                             -- EditBox
  self:HighlightText(0, 0)
  self.obj:Fire("OnEditFocusLost")
  self.obj.scrollFrame:EnableMouseWheel(false);
  local option = self.obj.userdata.option
  if option and option.LAAC then
    LAAC:disable(self)
  end
end

local function OnEnter(self)                                                     -- EditBox / ScrollFrame
  self = self.obj
  if not self.entered then
    self.entered = true
    self:Fire("OnEnter")
  end
end

local function OnLeave(self)                                                     -- EditBox / ScrollFrame
  self = self.obj
  if self.entered then
    self.entered = nil
    self:Fire("OnLeave")
  end
end

local function OnMouseUp(self)                                                   -- ScrollFrame
  self = self.obj.editBox
  self:SetFocus()
  self:SetCursorPosition(self:GetNumLetters())
end

local function OnReceiveDrag(self)                                               -- EditBox / ScrollFrame
  local infoType, spellIndex, bookType, info = GetCursorInfo()
  if infoType == "spell" then
    info = OptionsPrivate.Private.ExecEnv.GetSpellName(info)
  elseif infoType ~= "item" then
    return
  end
  ClearCursor()
  self = self.obj
  local editBox = self.editBox
  if not editBox:HasFocus() then
    editBox:SetFocus()
    editBox:SetCursorPosition(editBox:GetNumLetters())
  end
  editBox:Insert(info)
  self.button:Enable()
end

local function OnSizeChanged(self, width, height)                                -- ScrollFrame
  self.obj.editBox:SetWidth(width)
end

local function OnTextChanged(self, userInput)                                    -- EditBox
  if userInput then
    self = self.obj
    self:Fire("OnTextChanged", self.editBox:GetText())
    self.button:Enable()
  end
end

local function OnTextSet(self)                                                   -- EditBox
  self:HighlightText(0, 0)
  self:SetCursorPosition(self:GetNumLetters())
  self:SetCursorPosition(0)
  self.obj.button:Disable()
end

local function OnVerticalScroll(self, offset)                                    -- ScrollFrame
  local editBox = self.obj.editBox
  editBox:SetHitRectInsets(0, 0, offset, editBox:GetHeight() - offset - self:GetHeight())
end

local function OnScrollRangeChanged(self, xrange, yrange)
  if yrange == 0 then
    self.obj.editBox:SetHitRectInsets(0, 0, 0, 0)
  else
    OnVerticalScroll(self, self:GetVerticalScroll())
  end
end

local function OnShowFocus(frame)
  frame.obj.editBox:SetFocus()
  frame:SetScript("OnShow", nil)
end

local function OnEditFocusGained(frame)
  AceGUI:SetFocus(frame.obj)
  frame.obj:Fire("OnEditFocusGained")
  frame.obj.scrollFrame:EnableMouseWheel(true);
  local option = frame.obj.userdata.option
  if option and option.LAAC then
    LAAC:enable(frame, option.LAAC)
  end
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self.editBox:SetText("")
    self:SetDisabled(false)
    self:SetWidth(200)
    self:DisableButton(false)
    self:SetNumLines()
    self.entered = nil
    self:SetMaxLetters(0)
  end,

  ["OnRelease"] = function(self)
    self:ClearFocus()
  end,

  ["SetDisabled"] = function(self, disabled)
    local editBox = self.editBox
    if disabled then
      editBox:ClearFocus()
      editBox:EnableMouse(false)
      editBox:SetTextColor(0.5, 0.5, 0.5)
      self.label:SetTextColor(0.5, 0.5, 0.5)
      self.scrollFrame:EnableMouse(false)
      self.button:Disable()
    else
      editBox:EnableMouse(true)
      editBox:SetTextColor(1, 1, 1)
      self.label:SetTextColor(1, 0.82, 0)
      self.scrollFrame:EnableMouse(true)
    end
  end,

  ["SetLabel"] = function(self, text)
    if text and text ~= "" then
      self.label:SetText(text)
      if self.labelHeight ~= 10 then
        self.labelHeight = 10
        self.label:Show()
      end
    elseif self.labelHeight ~= 0 then
      self.labelHeight = 0
      self.label:Hide()
    end
    Layout(self)
  end,

  ["SetNumLines"] = function(self, value)
    if not value or value < 4 then
      value = 4
    end
    self.numlines = value
    Layout(self)
  end,

  ["SetText"] = function(self, text)
    self.editBox:SetText(text)
  end,

  ["GetText"] = function(self)
    return self.editBox:GetText()
  end,

  ["SetMaxLetters"] = function (self, num)
    self.editBox:SetMaxLetters(num or 0)
  end,

  ["DisableButton"] = function(self, disabled)
    self.disablebutton = disabled
    if disabled then
      self.button:Hide()
    else
      self.button:Show()
    end
    Layout(self)
  end,

  ["ClearFocus"] = function(self)
    self.editBox:ClearFocus()
    self.frame:SetScript("OnShow", nil)
  end,

  ["SetFocus"] = function(self)
    self.editBox:SetFocus()
    if not self.frame:IsShown() then
      self.frame:SetScript("OnShow", OnShowFocus)
    end
  end,

  ["HighlightText"] = function(self, from, to)
    self.editBox:HighlightText(from, to)
  end,

  ["GetCursorPosition"] = function(self)
    return self.editBox:GetCursorPosition()
  end,

  ["SetCursorPosition"] = function(self, ...)
    return self.editBox:SetCursorPosition(...)
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local backdrop = {
  bgFile = [[Interface\Tooltips\UI-Tooltip-Background]],
  edgeFile = [[Interface\Tooltips\UI-Tooltip-Border]], edgeSize = 16,
  insets = { left = 4, right = 3, top = 4, bottom = 3 }
}

local function Constructor()
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:Hide()

  local widgetNum = AceGUI:GetNextWidgetNum(Type)

  local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
  label:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, -4)
  label:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, -4)
  label:SetJustifyH("LEFT")
  label:SetText(ACCEPT)
  label:SetHeight(10)

  local button = CreateFrame("Button", ("%s%dButton"):format(Type, widgetNum), frame, "UIPanelButtonTemplate")
  button:SetPoint("BOTTOMLEFT", 0, 4)
  button:SetHeight(22)
  button:SetWidth(label:GetStringWidth() + 24)
  button:SetText(ACCEPT)
  button:SetScript("OnClick", OnClick)
  button:Disable()

  local text = button:GetFontString()
  text:ClearAllPoints()
  text:SetPoint("TOPLEFT", button, "TOPLEFT", 5, -5)
  text:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -5, 1)
  text:SetJustifyV("MIDDLE")

  local scrollBG = CreateFrame("Frame", nil, frame, "BackdropTemplate")
  scrollBG:SetBackdrop(backdrop)
  scrollBG:SetBackdropColor(0, 0, 0)
  scrollBG:SetBackdropBorderColor(0.4, 0.4, 0.4)

  local scrollFrame = CreateFrame("ScrollFrame", ("%s%dScrollFrame"):format(Type, widgetNum), frame, "UIPanelScrollFrameTemplate")
  scrollFrame:EnableMouseWheel(false);

  local scrollBar = _G[scrollFrame:GetName() .. "ScrollBar"]
  scrollBar:ClearAllPoints()
  scrollBar:SetPoint("TOP", label, "BOTTOM", 0, -19)
  scrollBar:SetPoint("BOTTOM", button, "TOP", 0, 18)
  scrollBar:SetPoint("RIGHT", frame, "RIGHT")

  scrollBG:SetPoint("TOPRIGHT", scrollBar, "TOPLEFT", 0, 19)
  scrollBG:SetPoint("BOTTOMLEFT", button, "TOPLEFT")

  scrollFrame:SetPoint("TOPLEFT", scrollBG, "TOPLEFT", 5, -6)
  scrollFrame:SetPoint("BOTTOMRIGHT", scrollBG, "BOTTOMRIGHT", -4, 4)
  scrollFrame:SetScript("OnEnter", OnEnter)
  scrollFrame:SetScript("OnLeave", OnLeave)
  scrollFrame:SetScript("OnMouseUp", OnMouseUp)
  scrollFrame:SetScript("OnReceiveDrag", OnReceiveDrag)
  scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
  scrollFrame:HookScript("OnVerticalScroll", OnVerticalScroll)
  scrollFrame:HookScript("OnScrollRangeChanged", OnScrollRangeChanged)

  local editBox = CreateFrame("EditBox", ("%s%dEdit"):format(Type, widgetNum), scrollFrame)
  editBox:SetAllPoints()
  editBox:SetFontObject(ChatFontNormal)
  editBox:SetMultiLine(true)
  editBox:EnableMouse(true)
  editBox:SetAutoFocus(false)
  editBox:SetCountInvisibleLetters(false)
  editBox:SetScript("OnCursorChanged", OnCursorChanged)
  editBox:SetScript("OnEditFocusLost", OnEditFocusLost)
  editBox:SetScript("OnEnter", OnEnter)
  editBox:SetScript("OnEscapePressed", editBox.ClearFocus)
  editBox:SetScript("OnLeave", OnLeave)
  editBox:SetScript("OnMouseDown", OnReceiveDrag)
  editBox:SetScript("OnReceiveDrag", OnReceiveDrag)
  editBox:SetScript("OnTextChanged", OnTextChanged)
  editBox:SetScript("OnTextSet", OnTextSet)
  editBox:SetScript("OnEditFocusGained", OnEditFocusGained)
  editBox:SetScript("OnEnterPressed", OnEnterPressed)


  scrollFrame:SetScrollChild(editBox)

  local widget = {
    button      = button,
    editBox     = editBox,
    frame       = frame,
    label       = label,
    labelHeight = 10,
    numlines    = 4,
    scrollBar   = scrollBar,
    scrollBG    = scrollBG,
    scrollFrame = scrollFrame,
    type        = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end
  button.obj, editBox.obj, scrollFrame.obj = widget, widget, widget

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasMultiLineEditBoxWithEnter.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasNewButton.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local Type, Version = "WeakAurasNewButton", 27
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(570);
    self:SetHeight(40);
  end,
  ["SetTitle"] = function(self, title)
    self.title:SetText(title);
  end,
  ["GetTitle"] = function(self)
    return self.title:GetText();
  end,
  ["SetDescription"] = function(self, desc)
    self.frame.description = desc;
    self.description:SetText(desc);
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["SetIcon"] = function(self, icon)
    if(type(icon) == "string" or type(icon) == "number") then
      self.icon:SetTexture(icon);
      self.icon:Show();
      if(self.iconRegion and self.iconRegion.Hide) then
        self.iconRegion:Hide();
      end
      self.iconRegion = nil
    else
      self.iconRegion = icon;
      icon:SetAllPoints(self.icon);
      icon:SetParent(self.frame);
      icon:Show()
      self.icon:Hide();
    end
  end,
  ["SetThumbnail"] = function(self, regionType, data)
    local regionData = OptionsPrivate.Private.regionOptions[regionType]
    if regionData and regionData.acquireThumbnail then
      local thumbnail = regionData.acquireThumbnail(self.frame, data)
      self:SetIcon(thumbnail)
      self.thumbnail = thumbnail
      self.thumbnailType = regionType
    end
  end,
  ["ReleaseThumbnail"] = function(self)
    if self.thumbnail then
      local regionData = OptionsPrivate.Private.regionOptions[self.thumbnailType]
      if regionData and regionData.releaseThumbnail then
        regionData.releaseThumbnail(self.thumbnail)
      end
    end
    self.thumbnail = nil
    self.thumbnailType = nil
  end,
  ["OnRelease"] = function(self)
    self:ReleaseThumbnail()
    if(self.iconRegion and self.iconRegion.Hide) then
      self.iconRegion:Hide();
    end
    self.iconRegion = nil
    self.icon:Hide();
    self.frame:UnlockHighlight();
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = "WeakAurasDisplayButton"..AceGUI:GetNextWidgetNum(Type);
  local button = CreateFrame("Button", name, UIParent, "OptionsListButtonTemplate");
  button:SetHeight(40);
  button:SetWidth(380);
  button.dgroup = nil;

  local background = button:CreateTexture(nil, "BACKGROUND");
  button.background = background;
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
  background:SetBlendMode("ADD");
  background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
  background:SetAllPoints(button);

  local icon = button:CreateTexture(nil, "OVERLAY");
  button.icon = icon;
  icon:SetWidth(40);
  icon:SetHeight(40);
  icon:SetPoint("LEFT", button, "LEFT");

  local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge");
  button.title = title;
  title:SetHeight(14);
  title:SetJustifyH("LEFT");
  title:SetPoint("TOP", button, "TOP", 0, -5);
  title:SetPoint("LEFT", icon, "RIGHT", 2, 0);
  title:SetPoint("RIGHT", button, "RIGHT");

  local description = button:CreateFontString(nil, "OVERLAY", "GameFontHighlight");
  button.description = description;
  description:SetHeight(14);
  description:SetJustifyH("LEFT");
  description:SetPoint("BOTTOM", button, "BOTTOM", 0, 2);
  description:SetPoint("LEFT", icon, "RIGHT", 2, 0);
  description:SetPoint("RIGHT", button, "RIGHT");


  button.description = "";

  button:SetScript("OnEnter", function() Show_Tooltip(button, title:GetText(), button.description) end);
  button:SetScript("OnLeave", Hide_Tooltip);


  local widget = {
    frame = button,
    title = title,
    icon = icon,
    description = description,
    background = background,
    type = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasNewButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasNewHeaderButton.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasNewHeaderButton", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local L = WeakAuras.L;

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(1000);
    self:SetHeight(20);
  end,
  ["SetText"] = function(self, text)
    self.frame:SetText(" "..text);
  end,
  ["SetDescription"] = function(self, description)
    self.frame.description = description;
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["Disable"] = function(self)
    self.frame:Disable();
  end,
  ["Enable"] = function(self)
    self.frame:Enable();
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
  end,
  ["ClearPick"] = function(self)
    self.frame:UnlockHighlight();
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = Type..AceGUI:GetNextWidgetNum(Type)
  local button = CreateFrame("Button", name, UIParent, "OptionsListButtonTemplate");
  button:SetHeight(20);
  button:SetWidth(1000);
  button:SetDisabledFontObject("GameFontNormal");

  local background = button:CreateTexture(nil, "BACKGROUND");
  button.background = background;
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp");
  background:SetBlendMode("ADD");
  background:SetVertexColor(0.5, 0.5, 0.5, 0.25);
  background:SetAllPoints(button);

  button:SetScript("OnEnter", function() Show_Tooltip(button, button:GetText():sub(2), button.description or L["Add a new display"]) end);
  button:SetScript("OnLeave", Hide_Tooltip);

  local widget = {
    frame = button,
    type = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasNewHeaderButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasPendingInstallButton.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local pairs, next, type, unpack = pairs, next, type, unpack

local Type, Version = "WeakAurasPendingInstallButton", 3
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)

if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then
  return
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(1000)
    self:SetHeight(32)
    self.hasThumbnail = false
  end,
  ["Initialize"] = function(self, id, companionData)
    self.callbacks = {}
    self.id = id
    self.companionData = companionData

    function self.callbacks.OnUpdateClick()
      WeakAuras.Import(self.companionData.encoded)
    end

    self:SetTitle(self.companionData.name)
    self.update:SetScript("OnClick", self.callbacks.OnUpdateClick)
    local data = OptionsPrivate.Private.StringToTable(self.companionData.encoded, true)
    WeakAuras.PreAdd(data.d)
    self.data = data.d
    self.frame:EnableKeyboard(false)
    self:Enable()
    self.frame:Hide()
  end,
  ["SetLogo"] = function(self, path)
    self.frame.updateLogo.tex:SetTexture(path)
  end,
  ["SetRefreshLogo"] = function(self, path)
    self.frame.update:SetNormalTexture(path)
  end,
  ["Disable"] = function(self)
    self.background:Hide()
    self.frame:Disable()
  end,
  ["Enable"] = function(self)
    self.background:Show()
    self.frame:Enable()
    self.update:Show()
    self.update:Enable()
    self.updateLogo:Show()
    self:UpdateThumbnail()
  end,
  ["OnRelease"] = function(self)
    self:ReleaseThumbnail()
    self:Enable()
    self.title:Show()
    self.frame:SetScript("OnEnter", nil)
    self.frame:SetScript("OnLeave", nil)
    self.frame:SetScript("OnClick", nil)
    self.frame:ClearAllPoints()
    self.frame:Hide()
    self.frame = nil
    self.data = nil
  end,
  ["SetTitle"] = function(self, title)
    self.titletext = title
    self.title:SetText(title)
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func)
  end,
  ["UpdateThumbnail"] = function(self)
    if not self.hasThumbnail then
      return
    end

    if self.data.regionType ~= self.thumbnailType then
      self:ReleaseThumbnail()
      self:AcquireThumbnail()
    else
      local option = OptionsPrivate.Private.regionOptions[self.thumbnailType]
      if option and option.modifyThumbnail then
        option.modifyThumbnail(self.frame, self.thumbnail, self.data)
      end
    end
  end,
  ["ReleaseThumbnail"] = function(self)
    if not self.hasThumbnail then
      return
    end
    self.hasThumbnail = false

    if self.thumbnail then
      local regionType = self.thumbnailType
      local option = OptionsPrivate.Private.regionOptions[regionType]
      if self.thumbnail.icon then
        self.thumbnail.icon:SetDesaturated(false)
      end
      option.releaseThumbnail(self.thumbnail)
      self.thumbnail = nil
    end
  end,
  ["AcquireThumbnail"] = function(self)
    if self.hasThumbnail then
      return
    end

    if not self.data then
      return
    end

    self.hasThumbnail = true

    local button = self.frame
    local regionType = self.data.regionType
    self.thumbnailType = regionType

    local option = OptionsPrivate.Private.regionOptions[regionType]
    if option and option.acquireThumbnail then
      self.thumbnail = option.acquireThumbnail(button, self.data)
      if self.thumbnail.icon then
        self.thumbnail.icon:SetDesaturated(true)
      end
      self:SetIcon(self.thumbnail)
    else
      self:SetIcon("Interface\\Icons\\INV_Misc_QuestionMark")
    end
  end,
  ["SetIcon"] = function(self, icon)
    self.orgIcon = icon
    if (type(icon) == "string" or type(icon) == "number") then
      self.icon:SetTexture(icon)
      self.icon:Show()
      if (self.iconRegion and self.iconRegion.Hide) then
        self.iconRegion:Hide()
      end
    else
      self.iconRegion = icon
      icon:SetAllPoints(self.icon)
      icon:SetParent(self.frame)
      icon:Show()
      self.iconRegion:Show()
      self.icon:Hide()
    end
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = "WeakAurasPendingInstallButton" .. AceGUI:GetNextWidgetNum(Type)
  local button = CreateFrame("Button", name, UIParent)
  button:SetHeight(32)
  button:SetWidth(1000)
  button.data = {}

  local background = button:CreateTexture(nil, "BACKGROUND")
  button.background = background
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp")
  background:SetBlendMode("ADD")
  background:SetVertexColor(0.5, 1, 0.5, 0.3)
  background:SetPoint("TOP", button, "TOP")
  background:SetPoint("BOTTOM", button, "BOTTOM")
  background:SetPoint("LEFT", button, "LEFT")
  background:SetPoint("RIGHT", button, "RIGHT")

  local icon = button:CreateTexture(nil, "OVERLAY")
  button.icon = icon
  icon:SetWidth(32)
  icon:SetHeight(32)
  icon:SetPoint("LEFT", button, "LEFT")

  local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  button.title = title
  title:SetHeight(14)
  title:SetJustifyH("LEFT")
  title:SetPoint("TOPLEFT", icon, "TOPRIGHT", 2, 0)
  title:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT")
  title:SetVertexColor(0.6, 0.6, 0.6)

  button.description = {}

  local update = CreateFrame("Button", nil, button)
  button.update = update
  update.disabled = true
  update.func = function()
  end
  update:SetNormalTexture([[Interface\AddOns\WeakAuras\Media\Textures\wagoupdate_refresh.tga]])
  update:Disable()
  update:SetWidth(24)
  update:SetHeight(24)
  update:SetPoint("RIGHT", button, "RIGHT", -2, 0)

  -- Add logo
  local updateLogo = CreateFrame("Frame", nil, button)
  button.updateLogo = updateLogo
  local tex = updateLogo:CreateTexture()
  tex:SetTexture([[Interface\AddOns\WeakAuras\Media\Textures\wagoupdate_logo.tga]])
  tex:SetAllPoints()
  updateLogo.tex = tex
  updateLogo:SetSize(24, 24)
  updateLogo:SetPoint("CENTER", update)
  updateLogo:SetFrameStrata(update:GetFrameStrata())
  updateLogo:SetFrameLevel(update:GetFrameLevel()-1)

  -- Animation On Hover
  local animGroup = update:CreateAnimationGroup()
  update.animGroup = animGroup

  local animRotate = animGroup:CreateAnimation("rotation")
  animRotate:SetDegrees(-360)
  animRotate:SetDuration(1)
  animRotate:SetSmoothing("OUT")
  animGroup:SetScript("OnFinished", function()
    if (MouseIsOver(update)) then
      animGroup:Play()
    end
  end)
  update:SetScript("OnEnter", function()
    animGroup:Play()
  end)
  update:Hide()
  updateLogo:Hide()

  --- @type table<string, any>
  local widget = {
    frame = button,
    title = title,
    icon = icon,
    background = background,
    update = update,
    updateLogo = updateLogo,
    type = Type,
  }

  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasPendingInstallButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasPendingUpdateButton.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)
local L = WeakAuras.L

local pairs, next, type, unpack = pairs, next, type, unpack

local Type, Version = "WeakAurasPendingUpdateButton", 6
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
local LibDD = LibStub:GetLibrary("LibUIDropDownMenu-4.0")

if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then
  return
end

local function Hide_Tooltip()
  GameTooltip:Hide()
end

local function Show_Long_Tooltip(owner, description)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();
  local line = 1;
  for i,v in pairs(description) do
    if(type(v) == "string") then
      if(line > 1) then
        GameTooltip:AddLine(v, 1, 1, 1, 1);
      else
        GameTooltip:AddLine(v);
      end
    elseif(type(v) == "table") then
      if(i == 1) then
        GameTooltip:AddDoubleLine(v[1], v[2]..(v[3] and (" |T"..v[3]..":12:12:0:0:64:64:4:60:4:60|t") or ""));
      else
        GameTooltip:AddDoubleLine(v[1], v[2]..(v[3] and (" |T"..v[3]..":12:12:0:0:64:64:4:60:4:60|t") or ""), 1, 1, 1, 1, 1, 1, 1, 1);
      end
    end
    line = line + 1;
  end
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(1000)
    self:SetHeight(32)
    self.hasThumbnail = false
  end,
  ["Initialize"] = function(self, id, companionData)
    self.callbacks = {}
    self.id = id
    self.companionData = companionData
    self.linkedAuras = {}
    self.linkedChildren = {}

    function self.callbacks.OnUpdateClick()
      local linkedAuras = {}
      for auraId in pairs(self.linkedAuras) do
        if not self.linkedChildren[auraId] then
          tinsert(linkedAuras, auraId)
        end
      end

      WeakAuras.Import(self.companionData.encoded, nil, nil, linkedAuras)
    end

    function self.callbacks.OnFollowLinkClick()
      self.menu = {
        { text = L["Linked Auras"], isTitle = true }
      }
      for auraId in pairs(self.linkedAuras) do
        if not self.linkedChildren[auraId] then
          tinsert(
            self.menu,
            {
              text = auraId,
              notCheckable = true,
              func = function() WeakAuras.PickDisplay(auraId, "information") end
            }
          )
        end
      end
      LibDD:EasyMenu(self.menu, WeakAuras_DropDownMenu, self.followLink, 0, 0, "MENU", 5)
    end

    self:SetTitle(self.companionData.name)
    self.frame:SetScript("OnClick", self.callbacks.OnClickNormal)
    self.update:SetScript("OnClick", self.callbacks.OnUpdateClick)
    self.followLink:SetScript("OnClick", self.callbacks.OnFollowLinkClick)
    local data = OptionsPrivate.Private.StringToTable(self.companionData.encoded, true)
    WeakAuras.PreAdd(data.d)
    self.data = data.d
    self.frame:EnableKeyboard(false)
    self:Enable()
    self.frame:Hide()

    self.menu = {}

    self.frame:SetScript("OnEnter", function()
      self:SetNormalTooltip()
      Show_Long_Tooltip(self.frame, self.frame.description)
    end)
    self.frame:SetScript("OnLeave", Hide_Tooltip)
  end,
  ["SetLogo"] = function(self, path)
    self.frame.updateLogo.tex:SetTexture(path)
  end,
  ["SetRefreshLogo"] = function(self, path)
    self.frame.update:SetNormalTexture(path)
  end,
  ["Disable"] = function(self)
    self.background:Hide()
    self.frame:Disable()
  end,
  ["Enable"] = function(self)
    self.background:Show()
    self.frame:Enable()
    self.update:Show()
    self.update:Enable()
    self.updateLogo:Show()
    self:UpdateThumbnail()
  end,
  ["OnRelease"] = function(self)
    self:ReleaseThumbnail()
    self:Enable()
    self.title:Show()
    self.frame:SetScript("OnEnter", nil)
    self.frame:SetScript("OnLeave", nil)
    self.frame:SetScript("OnClick", nil)
    self.frame:ClearAllPoints()
    self.frame:Hide()
    self.frame = nil
    self.data = nil
  end,
  ["SetNormalTooltip"] = function(self)
    local data = self.data;
    local namestable = {};

    local hasDescription = data.desc and data.desc ~= "";
    local hasUrl = data.url and data.url ~= "";
    local hasVersion = (data.semver and data.semver ~= "") or (data.version and data.version ~= "");
    local hasVersionNote = self.companionData.versionNote and self.companionData.versionNote ~= ""

    if(hasDescription or hasUrl or hasVersion or hasVersionNote) then
      tinsert(namestable, " ")
    end

    if hasVersionNote then
      tinsert(namestable, "|cFFFFD100"..self.companionData.versionNote)
      tinsert(namestable, " ")
    end

    for auraId in pairs(self.linkedAuras) do
      if not self.linkedChildren[auraId] then
        tinsert(namestable, "|cFFFFD100" .. L["Linked aura: "]  .. auraId .. "|r")
      end
    end
    tinsert(namestable, " ")

    if(hasDescription) then
      tinsert(namestable, "|cFFFFD100"..data.desc)
    end

    if (hasUrl) then
      tinsert(namestable, "|cFFFFD100" .. data.url .. "|r")
    end

    if (hasVersion) then
      tinsert(namestable, "|cFFFFD100" .. L["Version: "]  .. (data.semver or data.version) .. "|r")
    end

    self:SetDescription({self.companionData.name or self.data.id, self.companionData.author or ""}, unpack(namestable))
  end,
  ["SetDescription"] = function(self, ...)
    self.frame.description = {...};
  end,
  ["SetTitle"] = function(self, title)
    self.titletext = title
    self.title:SetText(title)
  end,
  ["ResetLinkedAuras"] = function(self)
    wipe(self.linkedAuras)
    wipe(self.linkedChildren)
  end,
  ["MarkLinkedAura"] = function(self, auraId)
    self.linkedAuras[auraId] = true
  end,
  ["MarkLinkedChildren"] = function(self, auraId)
    self.linkedChildren[auraId] = true
  end,
  ["UpdateThumbnail"] = function(self)
    if not self.hasThumbnail then
      return
    end

    if self.data.regionType ~= self.thumbnailType then
      self:ReleaseThumbnail()
      self:AcquireThumbnail()
    else
      local option = OptionsPrivate.Private.regionOptions[self.thumbnailType]
      if option and option.modifyThumbnail then
        option.modifyThumbnail(self.frame, self.thumbnail, self.data)
      end
    end
  end,
  ["ReleaseThumbnail"] = function(self)
    if not self.hasThumbnail then
      return
    end
    self.hasThumbnail = false

    if self.thumbnail then
      local regionType = self.thumbnailType
      local option = OptionsPrivate.Private.regionOptions[regionType]
      if self.thumbnail.icon then
        self.thumbnail.icon:SetDesaturated(false)
      end
      option.releaseThumbnail(self.thumbnail)
      self.thumbnail = nil
    end
  end,
  ["AcquireThumbnail"] = function(self)
    if self.hasThumbnail then
      return
    end

    if not self.data then
      return
    end

    self.hasThumbnail = true

    local button = self.frame
    local regionType = self.data.regionType
    self.thumbnailType = regionType

    local option = OptionsPrivate.Private.regionOptions[regionType]
    if option and option.acquireThumbnail then
      self.thumbnail = option.acquireThumbnail(button, self.data)
      if self.thumbnail.icon then
        self.thumbnail.icon:SetDesaturated(true)
      end
      self:SetIcon(self.thumbnail)
    else
      self:SetIcon("Interface\\Icons\\INV_Misc_QuestionMark")
    end
  end,
  ["SetIcon"] = function(self, icon)
    self.orgIcon = icon
    if (type(icon) == "string" or type(icon) == "number") then
      self.icon:SetTexture(icon)
      self.icon:Show()
      if (self.iconRegion and self.iconRegion.Hide) then
        self.iconRegion:Hide()
      end
    else
      self.iconRegion = icon
      icon:SetAllPoints(self.icon)
      icon:SetParent(self.frame)
      icon:Show()
      self.iconRegion:Show()
      self.icon:Hide()
    end
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = "WeakAurasPendingUpdateButton" .. AceGUI:GetNextWidgetNum(Type)
  local button = CreateFrame("Button", name, UIParent)
  button:SetHeight(32)
  button:SetWidth(1000)
  button.data = {}

  local background = button:CreateTexture(nil, "BACKGROUND")
  button.background = background
  background:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp")
  background:SetBlendMode("ADD")
  background:SetVertexColor(0.88, 0.88, 0, 0.3)
  background:SetPoint("TOP", button, "TOP")
  background:SetPoint("BOTTOM", button, "BOTTOM")
  background:SetPoint("LEFT", button, "LEFT")
  background:SetPoint("RIGHT", button, "RIGHT")

  local icon = button:CreateTexture(nil, "OVERLAY")
  button.icon = icon
  icon:SetWidth(32)
  icon:SetHeight(32)
  icon:SetPoint("LEFT", button, "LEFT")

  -- follow link button
  local followLink = CreateFrame("Button", nil, button)
  button.followLink = followLink
  followLink:SetNormalAtlas("loottoast-arrow-green", true)
  followLink:GetNormalTexture():SetRotation(math.rad(-90))
  followLink:SetSize(24, 24)
  followLink:SetPoint("RIGHT", button, "RIGHT", -2, 0)
  followLink:SetScript("OnEnter", function()
    GameTooltip:SetOwner(followLink, "ANCHOR_NONE")
    GameTooltip:SetPoint("BOTTOMLEFT", followLink, "TOPRIGHT")
    GameTooltip:ClearLines()
    GameTooltip:AddLine(L["Linked Auras"])
    GameTooltip:Show()
  end)
  followLink:SetScript("OnLeave", Hide_Tooltip)

  local update = CreateFrame("Button", nil, button)
  button.update = update
  update.disabled = true
  update.func = function()
  end
  update:SetNormalTexture([[Interface\AddOns\WeakAuras\Media\Textures\wagoupdate_refresh.tga]])
  update:Disable()
  update:SetWidth(24)
  update:SetHeight(24)
  update:SetPoint("RIGHT", followLink, "LEFT", -2, 0)

  -- Add logo
  local updateLogo = CreateFrame("Frame", nil, button)
  button.updateLogo = updateLogo
  local tex = updateLogo:CreateTexture()
  tex:SetTexture([[Interface\AddOns\WeakAuras\Media\Textures\wagoupdate_logo.tga]])
  tex:SetAllPoints()
  updateLogo.tex = tex
  updateLogo:SetSize(24, 24)
  updateLogo:SetPoint("CENTER", update)
  updateLogo:SetFrameStrata(update:GetFrameStrata())
  updateLogo:SetFrameLevel(update:GetFrameLevel()-1)

  -- Animation On Hover
  local animGroup = update:CreateAnimationGroup()
  update.animGroup = animGroup

  local animRotate = animGroup:CreateAnimation("rotation")
  animRotate:SetDegrees(-360)
  animRotate:SetDuration(1)
  animRotate:SetSmoothing("OUT")
  animGroup:SetScript("OnFinished", function()
    if (MouseIsOver(update)) then
      animGroup:Play()
    end
  end)
  update:SetScript("OnEnter", function()
    animGroup:Play()
    GameTooltip:SetOwner(update, "ANCHOR_NONE")
    GameTooltip:SetPoint("BOTTOMLEFT", update, "TOPRIGHT")
    GameTooltip:ClearLines()
    GameTooltip:AddLine(L["Update"])
    GameTooltip:Show()
  end)
  update:SetScript("OnLeave", Hide_Tooltip)
  update:Hide()
  updateLogo:Hide()

  local title = button:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  button.title = title
  title:SetHeight(14)
  title:SetJustifyH("LEFT")
  title:SetPoint("TOPLEFT", icon, "TOPRIGHT", 2, 0)
  title:SetPoint("BOTTOMLEFT", icon, "BOTTOMRIGHT", 2, 0)
  title:SetPoint("RIGHT", updateLogo, "LEFT", -2, 0)
  title:SetVertexColor(0.6, 0.6, 0.6)

  button.description = {}
  --- @type table<string, any>
  local widget = {
    frame = button,
    title = title,
    icon = icon,
    background = background,
    update = update,
    updateLogo = updateLogo,
    followLink = followLink,
    type = Type,
  }

  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasPendingUpdateButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasScrollArea.lua ===
--[[-----------------------------------------------------------------------------
ScrollArea Widget
Plain widget that scrolls a content widget and doesn't grow in height.
Heavily based on AceGUIContainer-ScrollFrame
-------------------------------------------------------------------------------]]
local Type, Version = "WeakAurasScrollArea", 1
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs, assert, type = pairs, assert, type
local min, max, floor = math.min, math.max, math.floor

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function FixScrollOnUpdate(frame)
	frame:SetScript("OnUpdate", nil)
	frame.obj:FixScroll()
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function ScrollFrame_OnMouseWheel(frame, value)
	frame.obj:MoveScroll(value)
end

local function ScrollFrame_OnSizeChanged(frame)
	frame:SetScript("OnUpdate", FixScrollOnUpdate)
end

local function ScrollBar_OnScrollValueChanged(frame, value)
	frame.obj:SetScroll(value)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetScroll(0)
		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
	end,

	["OnRelease"] = function(self)
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
		self.scrollframe:SetPoint("BOTTOMRIGHT")
		self.scrollbar:Hide()
		self.scrollBarShown = nil
	end,

	["SetScroll"] = function(self, value)
		local status = self.localstatus
		local viewheight = self.scrollframe:GetHeight()
		local height = self.content:GetHeight()
		local offset

		if viewheight > height then
			offset = 0
		else
			offset = floor((height - viewheight) / 10000.0 * value)
		end
		self.content:ClearAllPoints()
		self.content:SetPoint("TOPLEFT", 0, offset)
		self.content:SetPoint("TOPRIGHT", 0, offset)
		status.offset = offset
		status.scrollvalue = value
		self:Fire("ContentScrolled")
	end,

	["GetContentOffset"] = function(self)
		local status = self.localstatus
		return status.offset or 0
	end,

	["GetViewportSize"] = function(self)
		return self.scrollframe:GetSize()
	end,

	["MoveScroll"] = function(self, value)
		local status = self.localstatus
		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()

		if self.scrollBarShown then
			local diff = height - viewheight
			local delta = 1
			if value < 0 then
				delta = -1
			end
			self.scrollbar:SetValue(min(max(status.scrollvalue + delta*(10000/(diff/45)),0), 10000))
		end
	end,

	["FixScroll"] = function(self)
		if self.updateLock then return end
		self.updateLock = true
		local status = self.localstatus
		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()
		local offset = status.offset or 0
		-- Give us a margin of error of 2 pixels to stop some conditions that i would blame on floating point inaccuracies
		-- No-one is going to miss 2 pixels at the bottom of the frame, anyhow!
		if viewheight < height + 2 then
			if self.scrollBarShown then
				self.scrollBarShown = nil
				self.scrollbar:Hide()
				self.scrollbar:SetValue(0)
				self.scrollframe:SetPoint("BOTTOMRIGHT")
				if self.content.original_width then
					self.content.width = self.content.original_width
				end
			end
		else
			if not self.scrollBarShown then
				self.scrollBarShown = true
				self.scrollbar:Show()
				self.scrollframe:SetPoint("BOTTOMRIGHT", -20, 0)
				if self.content.original_width then
					self.content.width = self.content.original_width - 20
				end
			end
			local value = (offset / (viewheight - height) * 10000)
			if value > 10000 then value = 10000 end
			self.scrollbar:SetValue(value)
			self:SetScroll(value)
			if value < 10000 then
				self.content:ClearAllPoints()
				self.content:SetPoint("TOPLEFT", 0, offset)
				self.content:SetPoint("TOPRIGHT", 0, offset)
				status.offset = offset
			end
		end
		self.updateLock = nil
	end,

	["SetContentHeight"] = function(self, height)
		self.content:SetHeight(height)
		-- update the scrollframe
		self:FixScroll()

		-- schedule another update when everything has "settled"
		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
	end,

	["OnWidthSet"] = function(self, width)
		self:Fire("ContentScrolled")
	end,

	["OnHeightSet"] = function(self, height)
		self:Fire("ContentScrolled")
	end
}
--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	local num = AceGUI:GetNextWidgetNum(Type)

	local scrollframe = CreateFrame("ScrollFrame", nil, frame)
	scrollframe:SetPoint("TOPLEFT")
	scrollframe:SetPoint("BOTTOMRIGHT")
	scrollframe:EnableMouseWheel(true)
	scrollframe:SetScript("OnMouseWheel", ScrollFrame_OnMouseWheel)
	scrollframe:SetScript("OnSizeChanged", ScrollFrame_OnSizeChanged)

	local scrollbar = CreateFrame("Slider", ("AceConfigDialogScrollFrame%dScrollBar"):format(num), scrollframe, "UIPanelScrollBarTemplate")
	scrollbar:SetPoint("TOPLEFT", scrollframe, "TOPRIGHT", 4, -16)
	scrollbar:SetPoint("BOTTOMLEFT", scrollframe, "BOTTOMRIGHT", 4, 16)
	scrollbar:SetMinMaxValues(0, 10000)
	scrollbar:SetValueStep(1)
	scrollbar:SetValue(0)
	scrollbar:SetWidth(16)
	scrollbar:Hide()
	-- set the script as the last step, so it doesn't fire yet
	scrollbar:SetScript("OnValueChanged", ScrollBar_OnScrollValueChanged)

	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
	scrollbg:SetAllPoints(scrollbar)
	scrollbg:SetColorTexture(0, 0, 0, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, scrollframe)
	content:SetPoint("TOPLEFT")
	content:SetPoint("TOPRIGHT")
	content:SetHeight(400)
	scrollframe:SetScrollChild(content)

	local widget = {
		localstatus = { scrollvalue = 0 },
		scrollframe = scrollframe,
		scrollbar   = scrollbar,
		content     = content,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	scrollframe.obj, scrollbar.obj = widget, widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasScrollArea.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasSnippetButton.lua ===
if not WeakAuras.IsLibsOK() then return end
--[[-----------------------------------------------------------------------------
SnippetButton Widget, based on AceGUI Button (and WA ToolbarButton)
Graphical Button.
-------------------------------------------------------------------------------]]
local Type, Version = "WeakAurasSnippetButton", 3
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then
  return
end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local _G = _G
local PlaySound, CreateFrame, UIParent = PlaySound, CreateFrame, UIParent

local L = WeakAuras.L

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Button_OnClick(frame, ...)
  if ... == "RightButton" and frame.editable then
    AceGUI:ClearFocus()
    PlaySound(852) -- SOUNDKIT.IG_MAINMENU_OPTION
    frame.title:Hide()
    frame.renameEditBox:Show()
    frame.renameEditBox:SetText(frame.title:GetText())
    frame.renameEditBox:HighlightText()
    frame.renameEditBox:SetFocus()
  elseif ... == "LeftButton" then
    AceGUI:ClearFocus()
    PlaySound(852) -- SOUNDKIT.IG_MAINMENU_OPTION
    frame.obj:Fire("OnClick", ...)
  end
end

local function Control_OnEnter(frame)
  local tooltip = GameTooltip
  tooltip:SetOwner(frame, "ANCHOR_RIGHT")
  tooltip:ClearLines()
  if frame.editable then
    tooltip:AddDoubleLine(frame.titleText, L["(Right click to rename)"], nil, nil, nil, 0.6, 0.6, 0.6)
  else
    tooltip:AddLine(frame.titleText)
  end
  tooltip:AddLine("   ")
  tooltip:AddLine(frame.descriptionText, 0.8, 0.8, 0.8)
  tooltip:Show()
  frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
  GameTooltip:Hide()
  frame.obj:Fire("OnLeave")
end

local function rename_complete(self, ...)
  self:Hide()
  self:GetParent().obj:Fire("OnEnterPressed", ...)
end
--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    -- restore default values
    self:SetDisabled(false)
    self:SetTitle()
    self:SetEditable(false)

    self.ntex:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp")
    self.ntex:SetVertexColor(0.8, 0.8, 0.8, 0.25)
    self.htex:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight2.blp")
    self.htex:SetVertexColor(0.3, 0.5, 1, 0.5)
    self.ptex:SetColorTexture(1, 1, 1, 0.2)
  end,
  -- ["OnRelease"] = nil,

  ["SetTitle"] = function(self, text)
    self.frame.titleText = text
    self.title:SetText(text)
  end,
  ["SetDescription"] = function(self, text)
    self.frame.descriptionText = text
  end,
  ["SetDisabled"] = function(self, disabled)
    self.disabled = disabled
    if disabled then
      self.frame:Disable()
    else
      self.frame:Enable()
    end
  end,
  ["LockHighlight"] = function(self)
    self.frame:LockHighlight()
  end,
  ["UnlockHighlight"] = function(self)
    self.frame:UnlockHighlight()
  end,
  ["SetEditable"] = function(self, editable)
    if editable then
      self.frame.editable = true
      self.deleteButton:Show()
      self.title:SetPoint("RIGHT", self.deleteButton, "LEFT")
    else
      self.frame.editable = false
      self.deleteButton:Hide()
      self.title:SetPoint("RIGHT", self.deleteButton, "RIGHT", 4, 0)
    end
  end,
  ["SetNew"] = function(self, new)
    if new then
      AceGUI:ClearFocus()
      self.title:Hide()
      self.renameEditBox:Show()
      self.renameEditBox:SetText(self.title:GetText())
      self.renameEditBox:HighlightText()
      self.renameEditBox:SetFocus()
    end
  end,
  ["SetDynamicTextStyle"] = function(self)
    self.ntex:SetTexture(nil)
    self.htex:SetAtlas("Options_List_Hover")
    self.htex:SetVertexColor(1, 1, 1, 1)
    self.ptex:SetAtlas("Options_List_Active")
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
  local name = "WeakAurasSnippetButton" .. AceGUI:GetNextWidgetNum(Type)
  local button = CreateFrame("Button", name, UIParent, "OptionsListButtonTemplate")
  button:Hide()

  button:EnableMouse(true)
  button:SetScript("OnClick", Button_OnClick)
  button:SetScript("OnEnter", Control_OnEnter)
  button:SetScript("OnLeave", Control_OnLeave)

  button:SetHeight(24)
  button:SetWidth(170)

  local deleteButton = CreateFrame("Button", nil, button)
  deleteButton:SetPoint("RIGHT", button, "RIGHT", -3, 0)
  deleteButton:SetSize(20, 20)
  local deleteTex = deleteButton:CreateTexture()
  deleteTex:SetAllPoints()
  deleteTex:SetTexture([[Interface\Buttons\CancelButton-Up]])
  deleteTex:SetTexCoord(0.1, 0.9, 0.1, 0.9)
  deleteButton:SetNormalTexture(deleteTex)
  deleteButton:Hide()
  button.deleteButton = deleteButton

  local title = button:CreateFontString(nil, "OVERLAY", "GameFontHighlightLarge")
  title:SetHeight(14)
  title:SetJustifyH("LEFT")
  title:SetPoint("LEFT", button, "LEFT", 3, 0)
  title:SetPoint("RIGHT", deleteButton, "LEFT")
  title:SetTextColor(1, 1, 1, 1)
  button.title = title

  local ntex = button:CreateTexture()
  ntex:SetPoint("TOPLEFT", 0, -1)
  ntex:SetPoint("BOTTOMRIGHT", 0, 1)
  button:SetNormalTexture(ntex)

  local htex = button:CreateTexture()
  htex:SetBlendMode("ADD")
  htex:SetAllPoints(ntex)
  button:SetHighlightTexture(htex)
  button.htex = htex

  local ptex = button:CreateTexture()
  ptex:SetAllPoints(ntex)
  button:SetPushedTexture(ptex)
  button.ptex = ptex

  local delHighlight = deleteButton:CreateTexture()
  delHighlight:SetTexture([[Interface\Buttons\CancelButton-Highlight]])
  delHighlight:SetTexCoord(0.1, 0.9, 0.1, 0.9)
  delHighlight:SetAllPoints()
  deleteButton:SetHighlightTexture(delHighlight)
  local delPushed = deleteButton:CreateTexture()
  delPushed:SetTexture([[Interface\Buttons\CancelButton-Down]])
  delPushed:SetTexCoord(0.1, 0.9, 0.1, 0.9)
  delPushed:SetAllPoints()
  deleteButton:SetPushedTexture(delPushed)
  button.deleteHighlight = delHighlight

  local renameEditBox = CreateFrame("EditBox", nil, button, "InputBoxTemplate")
  renameEditBox:SetHeight(14)
  renameEditBox:SetPoint("TOPLEFT", title, "TOPLEFT")
  renameEditBox:SetPoint("BOTTOMRIGHT", title, "BOTTOMRIGHT")
  renameEditBox:Hide()
  renameEditBox:SetScript(
    "OnEscapePressed",
    function(self)
      self:ClearFocus()
      AceGUI:ClearFocus()
      self:Hide()
      title:Show()
    end
  )
  renameEditBox:SetScript(
    "OnEditFocusLost",
    function(self)
      self:Hide()
      title:Show()
    end
  )
  renameEditBox:SetScript("OnEnterPressed", rename_complete)
  button.renameEditBox = renameEditBox

  local widget = {
    title = title,
    frame = button,
    type = Type,
    ntex = ntex,
    htex = htex,
    ptex = ptex,
    deleteButton = deleteButton,
    renameEditBox = renameEditBox
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasSnippetButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasSpacer.lua ===
if not WeakAuras.IsLibsOK() then return end
--[[-----------------------------------------------------------------------------
Spacer Widget
Just uses up a bit of horizontal space
-------------------------------------------------------------------------------]]
local Type, Version = "WeakAurasSpacer", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local methods = {
	["OnAcquire"] = function(self)
		self:SetFullWidth(true)
    self:SetHeight(4)
	end,
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local widget = {
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasSpacer.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasSpinBox.lua ===
--[[-----------------------------------------------------------------------------
Spin Box Widget
-------------------------------------------------------------------------------]]
local Type, Version = "WeakAurasSpinBox", 5
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then
  return
end

-- Lua APIs
local math_min, math_max, floor = math.min, math.max, math.floor
local tonumber, pairs = tonumber, pairs

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

local progressLeftOffset = WeakAuras.IsClassicOrCata() and -2 or -3
local progressExtraWidth = WeakAuras.IsClassicOrCata() and -2 or 0
local progressTopOffset = WeakAuras.IsClassicOrCata() and -3 or -2
local progressBottomOffset = WeakAuras.IsClassicOrCata() and 3 or 2

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function UpdateText(self)
  local value = self:GetValue() or 0
  if self.ispercent then
    self.editbox:SetText(("%s%%"):format(floor(value * 1000 + 0.5) / 10))
  else
    self.editbox:SetText(floor(value * 100 + 0.5) / 100)
  end
end

local function UpdateButtons(self)
  local value = self:GetValue() or 0
  self.leftbutton:SetEnabled(value > self.min)
  self.rightbutton:SetEnabled(value < self.max)
end

local function UpdateProgressBar(self)
  local value = self:GetValue() or 0
  local p = 0
  if self.min and self.max then
    if self.min < self.max then
      p = (value - self.min) / (self.max - self.min)
    end
  end
  p = Clamp(p, 0, 1)
  local w = p * (self.frame:GetWidth() - 45 + progressExtraWidth)
  self.progressBar:SetWidth(max(w, 1))
  self.progressBar:SetTexCoord(0, p , 0, 1)
end

local function UpdateHandleColor(self)
  if self.progressBarHandle.mouseDown then
    self.progressBarHandleTexture:SetColorTexture(0.6, 0.6, 0, 1)
  elseif MouseIsOver(self.progressBarHandle) then
    self.progressBarHandleTexture:SetColorTexture(0.8, 0.8, 0, 1)
  else
    self.progressBarHandleTexture:SetColorTexture(0.4, 0.4, 0, 1)
  end
end

local function UpdateHandleVisibility(self)
  if MouseIsOver(self.frame) then
    self.progressBarHandle:Show()
    UpdateHandleColor(self)
  else
    self.progressBarHandle:Hide()
  end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function SpinBox_OnValueDown(frame)
  local self = frame.obj
  --self.editbox:SetFocus()
  local value = self.value or 0
  local step = self.step or 1
  value = math_max(self.min, value - step)
  PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
  self:SetValue(value, true)
end

local function SpinBox_OnValueUp(frame)
  local self = frame.obj
  --self.editbox:SetFocus()
  local value = self.value or 0
  local step = self.step or 1
  value = math_min(self.max, value + step)
  PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
  self:SetValue(value, true)
end

local function EditBox_OnEscapePressed(frame)
  frame:ClearFocus()
end

local function EditBox_OnEnterPressed(frame)
  local self = frame.obj
  local value = frame:GetText()
  if self.ispercent then
    value = value:gsub("%%", "")
    value = tonumber(value) / 100
  else
    value = tonumber(value)
  end

  if value then
    PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
    self:SetValue(value, true)
  end
  frame:ClearFocus()
end

local function EditBox_OnEnter(frame)
  frame.onEntered = true
  if not frame.obj.progressBarHandle.mouseDown then
    frame.obj:Fire("OnEnter")
  end
end

local function EditBox_OnLeave(frame)
  if frame.onEntered then
    frame.obj:Fire("OnLeave")
  end
  frame.onEntered = false
end

local function Frame_OnEnter(frame)
  UpdateHandleVisibility(frame.obj)
end

local function ProgressBarHandle_OnUpdate(frame, elapsed)
  UpdateHandleColor(frame.obj)
  if not IsMouseButtonDown("LeftButton") then
    if frame.mouseDown then
      frame.obj:SetValue(frame.obj:GetValue(), true)
      frame.mouseDown = false
    end
  end
  if frame.mouseDown then
    frame.timeElapsed = frame.timeElapsed + elapsed
    if frame.timeElapsed > 0.1 then
      local currentX = GetCursorPosition()
      local deltaX = currentX - frame.startX
      deltaX = deltaX / frame.obj.editbox:GetEffectiveScale()

      local p = deltaX / (frame.obj.frame:GetWidth() - 45 + progressExtraWidth)
      local delta =  p * (frame.obj.max - frame.obj.min)
      local step = frame.obj.step
      local v = frame.originalValue + delta
      v = v - v % step
      v = Clamp(v, frame.obj.min, frame.obj.max)
      frame.obj:SetValue(v, false)
      frame.timeElapsed = 0
    end
  else
    UpdateHandleVisibility(frame.obj)
  end
end

local function ProgressBarHandle_OnMouseDown(frame, button)
  if button ~= "LeftButton" then
    return
  end
  frame.startX = GetCursorPosition()
  frame.originalValue = frame.obj:GetValue()
  frame.timeElapsed = 0
  frame.mouseDown = true
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(200)
    self:SetHeight(44)
    self:SetDisabled(false)
    self:SetIsPercent(nil)
    self:SetSpinBoxValues(0, 100, 1)
    self:SetValue(0)
    self.progressOpacity = 0
  end,

  ["OnRelease"] = function(self)
    self:ClearFocus()
  end,

  ["OnWidthSet"] = function(self, width)
    UpdateProgressBar(self)
  end,

  ["SetDisabled"] = function(self, disabled)
    self.disabled = disabled
    if disabled then
      self.label:SetTextColor(0.5, 0.5, 0.5)
      self.editbox:SetTextColor(0.5, 0.5, 0.5)
      self.editbox:EnableMouse(false)
      self.editbox:ClearFocus()
      self.leftbutton:SetEnabled(false)
      self.rightbutton:SetEnabled(false)
    else
      self.label:SetTextColor(1, 0.82, 0)
      self.editbox:SetTextColor(1, 1, 1)
      self.editbox:EnableMouse(true)
    end
  end,

  ["SetValue"] = function(self, value, reload)
    self.value = value
    UpdateText(self)
    UpdateButtons(self)
    UpdateProgressBar(self)
    -- In AceOptions the range is treated differently from other widget types
    -- Whereas for other widgets OnValueChanged leads to a reload, this is done only
    -- on OnMouseUp for ranges. (Probably to not reload the options while dragging)
    if reload then
      self:Fire("OnMouseUp", value)
    else
      self:Fire("OnValueChanged", value)
    end
  end,

  ["GetValue"] = function(self)
    return self.value
  end,

  ["SetLabel"] = function(self, text)
    self.label:SetText(text)
  end,

  ["SetSliderValues"] = function(self, ...)
    self:SetSpinBoxValues(...)
  end,

  ["SetSpinBoxValues"] = function(self, min, max, step)
    self.min = min or 0
    self.max = max or 100
    self.step = step or 1
    UpdateButtons(self)
    UpdateProgressBar(self)
  end,

  ["SetIsPercent"] = function(self, value)
    self.ispercent = value
    UpdateText(self)
  end,

  ["ClearFocus"] = function(self)
    self.editbox:ClearFocus()
  end,

  ["SetFocus"] = function(self)
    self.editbox:SetFocus()
    self.progressBarHandle:Hide()
  end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:SetScript("OnEnter", Frame_OnEnter)

  local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
  label:SetPoint("TOPLEFT")
  label:SetPoint("TOPRIGHT")
  label:SetJustifyH("LEFT")
  label:SetHeight(18)

  local leftbutton = CreateFrame("Button", nil, frame)
  leftbutton:SetSize(16, 16)
	leftbutton:SetNormalTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxleft")
  leftbutton:SetHighlightTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxlefth")
	leftbutton:SetPushedTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxleftp")
	leftbutton:SetDisabledTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxleftp")
  leftbutton:SetScript("OnClick", SpinBox_OnValueDown)

  local rightbutton = CreateFrame("Button", nil, frame)
  rightbutton:SetSize(16, 16)
	rightbutton:SetNormalTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxright")
  rightbutton:SetHighlightTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxrighth")
	rightbutton:SetPushedTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxrightp")
	rightbutton:SetDisabledTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxrightp")
  rightbutton:SetScript("OnClick", SpinBox_OnValueUp)

  local editbox = CreateFrame("EditBox", nil, frame, "InputBoxTemplate")
  editbox:SetAutoFocus(false)
  editbox:SetFontObject(ChatFontNormal)
  editbox:SetHeight(19)
  editbox:SetJustifyH("CENTER")
  editbox:EnableMouse(true)
  editbox:EnableMouseWheel(false)
  editbox:SetTextInsets(0, 0, 3, 3)
  editbox:SetScript("OnEnter", EditBox_OnEnter)
  editbox:SetScript("OnLeave", EditBox_OnLeave)
  editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
  editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
  editbox:SetScript("OnEditFocusGained", function(frame)
    AceGUI:SetFocus(frame.obj)
    UpdateHandleVisibility(frame.obj)
  end)
  editbox:SetScript("OnEditFocusLost", function(frame)
    UpdateHandleVisibility(frame.obj)
  end)

  leftbutton:SetPoint("TOPLEFT", 2, -18)
  rightbutton:SetPoint("TOPRIGHT", -2, -18)
  editbox:SetPoint("LEFT", leftbutton, "RIGHT", 8, 0)
  editbox:SetPoint("RIGHT", rightbutton, "LEFT", -2, 0)

  local progressBar = editbox:CreateTexture(nil, "ARTWORK", nil)
  progressBar:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\spinboxoverlay")
  progressBar:SetVertexColor(0.50, 0.50, 0.50, 1)
  progressBar:SetPoint("TOPLEFT", editbox, "TOPLEFT", progressLeftOffset, progressTopOffset)
  progressBar:SetPoint("BOTTOMLEFT", editbox, "BOTTOMLEFT", progressLeftOffset, progressBottomOffset)
  progressBar:SetWidth(0)

  local progressBarHandle = CreateFrame("Frame", nil, editbox)
  progressBarHandle:SetPoint("TOP", progressBar, "TOP", 0, 2)
  progressBarHandle:SetPoint("BOTTOM", progressBar, "BOTTOM", 0, -2)
  progressBarHandle:SetPoint("LEFT", progressBar, "RIGHT", -4, 0)
  progressBarHandle:SetPoint("RIGHT", progressBar, "RIGHT", 4, 0)
  progressBarHandle:EnableMouse(true)
  progressBarHandle:Hide()
  progressBarHandle:SetScript("OnMouseDown", ProgressBarHandle_OnMouseDown)
  progressBarHandle:SetScript("OnUpdate", ProgressBarHandle_OnUpdate)

  local progressBarHandleTexture = progressBarHandle:CreateTexture(nil, "ARTWORK")
  progressBarHandleTexture:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White")
  progressBarHandleTexture:SetColorTexture(0.8, 0.8, 0, 0.8)
  progressBarHandleTexture:SetPoint("TOPLEFT", progressBarHandle, "TOPLEFT", 2, -2)
  progressBarHandleTexture:SetPoint("BOTTOMRIGHT", progressBarHandle, "BOTTOMRIGHT", -2, 2)

  local widget = {
    label = label,
    editbox = editbox,
    leftbutton = leftbutton,
    rightbutton = rightbutton,
    progressBar = progressBar,
    progressBarHandle = progressBarHandle,
    progressBarHandleTexture = progressBarHandleTexture,
    frame = frame,
    type = Type,
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end
  editbox.obj, leftbutton.obj, rightbutton.obj, frame.obj, progressBarHandle.obj = widget, widget, widget, widget, widget

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasSpinBox.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasTextureButton.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local Type, Version = "WeakAurasTextureButton", 26
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end
local GetAtlasInfo = C_Texture and  C_Texture.GetAtlasInfo or GetAtlasInfo

local function Hide_Tooltip()
  GameTooltip:Hide();
end

local function Show_Tooltip(owner, line1, line2)
  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("BOTTOM", owner, "TOP");
  GameTooltip:ClearLines();
  GameTooltip:AddLine(line1);
  GameTooltip:AddLine(line2, 1, 1, 1, 1);
  GameTooltip:Show();
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
  ["OnAcquire"] = function(self)
    self:SetWidth(128);
    self:SetHeight(128);
  end,
  ["OnRelease"] = function(self)
    self:ClearPick();
    self:SetOnUpdate(nil)
    self.texture:SetTexture();
  end,
  ["SetTexture"] = function(self, texturePath, name, IsStopMotion)
    self.texture:SetTexCoord(0, 1, 0, 1)
    local atlasInfo = GetAtlasInfo(texturePath)
    if atlasInfo then
      self.texture:SetAtlas(texturePath, false);
      self.texture.IsAtlas = true
      local width = atlasInfo.width
      local height = atlasInfo.height
      if IsStopMotion then
        local flipbookInfo = OptionsPrivate.GetFlipbookTileSize(texturePath)
        if flipbookInfo then
          width = flipbookInfo.tileWidth
          height = flipbookInfo.tileHeight
        end
      end
      if width > height then
        self.texture:SetSize(120, 120 * (height / width))
      elseif height > width then
        self.texture:SetSize(120 * (width / height), 120)
      else
        self.texture:SetSize(120, 120)
      end
    else
      self.texture:SetSize(120, 120)
      self.texture:SetTexture(texturePath, "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE");
      self.texture.IsAtlas = nil
    end
    self.texture.path = texturePath;
    self.texture.name = name;
    self.texture.IsStopMotion = IsStopMotion
  end,
  ["ChangeTexture"] = function(self, r, g, b, a, texRotation, auraRotation, mirror, blendMode)
    if not self.texture.IsAtlas then
      local ulx,uly , llx,lly , urx,ury , lrx,lry;
      local angle = rad(135 - texRotation)
      local vx = math.cos(angle);
      local vy = math.sin(angle);
      ulx,uly , llx,lly , urx,ury , lrx,lry = 0.5+vx,0.5-vy , 0.5-vy,0.5-vx , 0.5+vy,0.5+vx , 0.5-vx,0.5+vy;
      if(mirror) then
        self.texture:SetTexCoord(urx,ury , lrx,lry , ulx,uly , llx,lly);
      else
        self.texture:SetTexCoord(ulx,uly , llx,lly , urx,ury , lrx,lry);
      end
    else
      self.texture:SetAtlas(self.texture.path)
    end
    self.texture:SetVertexColor(r, g, b, a);
    self.texture:SetBlendMode(blendMode);
    self.texture:SetRotation(auraRotation / 180 * math.pi)
  end,
  ["SetTexCoord"] = function(self, left, right, top, bottom)
    if self.texture.IsAtlas and not self.texture.IsStopMotion then
      self.texture:SetAtlas(self.texture.path)
    else
      self.texture:SetTexCoord(left, right, top, bottom);
    end
  end,
  ["SetOnUpdate"] = function(self, func)
    self.frame:SetScript("OnUpdate", func);
  end,
  ["GetTexturePath"] = function(self)
    return self.texture.path;
  end,
  ["SetClick"] = function(self, func)
    self.frame:SetScript("OnClick", func);
  end,
  ["Pick"] = function(self)
    self.frame:LockHighlight();
  end,
  ["ClearPick"] = function(self)
    self.frame:UnlockHighlight();
  end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local function Constructor()
  local name = "WeakAurasTextureButton"..AceGUI:GetNextWidgetNum(Type);
  local button = CreateFrame("Button", name, UIParent, "OptionsListButtonTemplate");
  if BackdropTemplateMixin then
    Mixin(button, BackdropTemplateMixin)
  end
  button:SetHeight(128);
  button:SetWidth(128);
  button:SetBackdrop({
    bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
    edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
    tile = true, tileSize = 16, edgeSize = 16,
    insets = { left = 4, right = 4, top = 4, bottom = 4 }
  });
  button:SetBackdropColor(0.1,0.1,0.1,0.2);
  button:SetBackdropBorderColor(0.4,0.4,0.4);

  local highlighttexture = button:CreateTexture(nil, "OVERLAY");
  highlighttexture:SetTexture("Interface\\BUTTONS\\ButtonHilight-SquareQuickslot.blp");
  highlighttexture:SetTexCoord(0.175, 0.875, 0.125, 0.825);
  highlighttexture:SetPoint("BOTTOMLEFT", button, 4, 4);
  highlighttexture:SetPoint("TOPRIGHT", button, -4, -4);
  button:SetHighlightTexture(highlighttexture);

  local texture = button:CreateTexture(nil, "OVERLAY");
  texture:SetPoint("CENTER")
  texture:SetSize(120, 120)

  button:SetScript("OnEnter", function() Show_Tooltip(button, texture.name, texture.path:gsub("\\", "\n")) end);
  button:SetScript("OnLeave", Hide_Tooltip);

  local widget = {
    frame = button,
    texture = texture,
    type = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end

  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasTextureButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasToolbarButton.lua ===
if not WeakAuras.IsLibsOK() then return end
--[[-----------------------------------------------------------------------------
ToolbarButton Widget, based on AceGUI Button
Graphical Button.
-------------------------------------------------------------------------------]]
local Type, Version = "WeakAurasToolbarButton", 7
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local _G = _G
local PlaySound, CreateFrame, UIParent = PlaySound, CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Button_OnClick(frame, ...)
	AceGUI:ClearFocus()
	PlaySound(852) -- SOUNDKIT.IG_MAINMENU_OPTION
	frame.obj:Fire("OnClick", ...)
end

local function Control_OnEnter(frame)
	if frame.tooltip then
		GameTooltip:ClearLines()
		GameTooltip:SetOwner(frame, "ANCHOR_NONE");
		GameTooltip:SetPoint("BOTTOM", frame, "TOP", 0, 5);
		GameTooltip:AddLine(frame.tooltip)
		GameTooltip:Show()
	end
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	GameTooltip:Hide()
	frame.obj:Fire("OnLeave")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		-- restore default values
		self:SetHeight(16)
		self:SetWidth(16)
		self:SetDisabled(false)
		self:SetText()
		self.hTex:SetVertexColor(1, 1, 1, 0.1)
		self:SetSmallFont(false)
		self.text:SetTextColor(GameFontNormal:GetTextColor())
	end,

	-- ["OnRelease"] = nil,

	["SetText"] = function(self, text)
		self.text:SetText(text)
		if text ~= "" then
			self:SetWidth(self.text:GetStringWidth() + 24)
		else
			self:SetWidth(16)
		end
	end,

	["SetTooltip"] = function(self, text)
		self.frame.tooltip = text
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
      self.text:SetTextColor(0.5, 0.5, 0.5)
		else
			self.frame:Enable()
			if self.smallFont then
				self.text:SetTextColor(GameFontNormalSmall:GetTextColor())
			else
				self.text:SetTextColor(GameFontNormal:GetTextColor())
			end
		end
	end,

	["SetTexture"] = function(self, path)
		self.icon:SetTexture(path)
	end,
	["LockHighlight"] = function(self)
		self.frame:LockHighlight()
	end,
	["UnlockHighlight"] = function(self)
		self.frame:UnlockHighlight()
	end,
	["SetStrongHighlight"] = function(self, enable)
		if enable then
			self.hTex:SetVertexColor(1, 1, 1, 0.3)
		else
			self.hTex:SetVertexColor(1, 1, 1, 0.1)
		end
	end,
	["SetSmallFont"] = function(self, small)
    self.smallFont = small
		if small then
			self.text:SetFontObject("GameFontNormalSmall")
		else
			self.text:SetFontObject("GameFontNormal")
		end
	end

}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local name = "AceGUI30Button" .. AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Button", name, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnClick", Button_OnClick)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)


	local icon = frame:CreateTexture()
	icon:SetTexture("aaa")
	icon:SetPoint("TOPLEFT", frame, "TOPLEFT")
	icon:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT")
	icon:SetWidth(16)

	local text = frame:CreateFontString()
	text:SetFontObject("GameFontNormal")
	text:ClearAllPoints()
	text:SetPoint("TOPLEFT", 20, -1)
	text:SetPoint("BOTTOMRIGHT", -4, 1)
	text:SetJustifyV("MIDDLE")

	--local nTex = frame:CreateTexture()
	--nTex:SetTexture("Interface/Buttons/UI-Panel-Button-Up")
	--nTex:SetTexCoord(0, 0.625, 0, 0.6875)
	--nTex:SetAllPoints()
	--frame:SetNormalTexture(nTex)

	local hTex = frame:CreateTexture()
	hTex:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite")
	hTex:SetVertexColor(1, 1, 1, 0.1)

	hTex:SetAllPoints()
	frame:SetHighlightTexture(hTex)

	local pTex = frame:CreateTexture()
	pTex:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite")
	pTex:SetVertexColor(1, 1, 1, 0.2)
	pTex:SetAllPoints()
	frame:SetPushedTexture(pTex)


  --- @type table<string, any>
	local widget = {
		text  = text,
		icon = icon,
		frame = frame,
		type  = Type,
		hTex = hTex
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasToolbarButton.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasTwoColumnDropDown.lua ===
if not WeakAuras.IsLibsOK() then return end

local Type, Version = "WeakAurasTwoColumnDropdown", 6
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local secondLevelMt = {} -- Tag for our tables
local function CreateSecondLevelTable()
  local t = {}
  setmetatable(t, secondLevelMt)
  return t
end

local function IsSecondLevelTable(t)
  return getmetatable(t) == secondLevelMt
end

local function CompareValues(a, b)
  if type(a) == "table" and type(b) == "table" then
    for ak, av in pairs(a) do
      if b[ak] ~= av then
        return false
      end
    end
    for bk, bv in pairs(b) do
      if a[bk] ~= bv then
        return false
      end
    end
    return true
  else
    return a == b
  end
end

local methods = {
  ["DoLayout"] = function(self, mode)
    self.mode = mode
    if mode == "one" then
      self.firstDropdown.frame:Show()
      self.secondDropDown.frame:Hide()
      self.firstDropdown.frame:ClearAllPoints()
      self.firstDropdown.frame:SetPoint("TOPLEFT", self.frame)
      self.firstDropdown.frame:SetPoint("TOPRIGHT", self.frame)
    else
      local halfWidth = self.frame:GetWidth() / 2
      self.firstDropdown.frame:Show()
      self.secondDropDown.frame:Show()
      self.firstDropdown.frame:ClearAllPoints()
      self.firstDropdown.frame:SetPoint("TOPLEFT", self.frame)
      self.firstDropdown.frame:SetPoint("TOPRIGHT", self.frame, "TOPLEFT", halfWidth, 0)
      self.secondDropDown.frame:SetPoint("TOPLEFT", self.frame, halfWidth, 0)
      self.secondDropDown.frame:SetPoint("TOPRIGHT", self.frame, "TOPRIGHT")
    end
  end,
  ["OnAcquire"] = function(widget)
    local firstDropdown = AceGUI:Create("Dropdown")
    local secondDropDown = AceGUI:Create("Dropdown")

    firstDropdown:SetParent(widget)
    secondDropDown:SetParent(widget)
    firstDropdown:SetPulloutWidth(200)

    secondDropDown:SetLabel(" ")
    secondDropDown:SetPulloutWidth(200)
    secondDropDown.userdata.defaultSelection = {}

    widget.firstDropdown = firstDropdown
    widget.secondDropDown = secondDropDown

    local OnFirstDropdownValueChanged = function(self, event, value)
      local displayName = widget.userdata.firstList[value]
      local treeValue = widget.userdata.tree[displayName]
      if IsSecondLevelTable(treeValue) then
        local oldValue
        if widget.userdata.secondList then
          local v = widget.secondDropDown:GetValue()
          if v then
            oldValue = widget.userdata.secondList[v]
          end
        end
        local secondList = {}
        for displayName, _ in pairs(treeValue) do
          tinsert(secondList, displayName)
        end
        table.sort(secondList)

        local oldValueIndex = tIndexOf(secondList, oldValue)
        widget.userdata.secondList = secondList
        widget.secondDropDown:SetList(secondList)
        widget:DoLayout("two")

        if (oldValueIndex) then
          widget.secondDropDown:SetValue(oldValueIndex)

          local v = widget:GetValue()
          if (v) then
            widget:Fire("OnValueChanged", v)
          end
        else
          local default = widget.secondDropDown.userdata.defaultSelection[displayName]
          if default then
            local index = tIndexOf(secondList, default)
            widget.secondDropDown:SetValue(index)
            local v = widget:GetValue()
            if (v) then
              widget:Fire("OnValueChanged", v)
            end
          else
            widget.secondDropDown:SetValue()
          end
        end
      else
        widget.userdata.secondList = nil
        widget:DoLayout("one")
        widget:Fire("OnValueChanged", treeValue)
      end
    end

    firstDropdown.OnFirstDropdownValueChanged = OnFirstDropdownValueChanged

    local OnSecondDropdownValueChanged = function(self, event, value)
      widget:Fire("OnValueChanged", widget:GetValue())
    end

    firstDropdown:SetCallback("OnValueChanged", OnFirstDropdownValueChanged)
    secondDropDown:SetCallback("OnValueChanged", OnSecondDropdownValueChanged)

    local function FireOnEnter(self, event)
      widget:Fire("OnEnter")
    end

    local function FireOnLeave(self, event)
      widget:Fire("OnLeave")
    end

    firstDropdown:SetCallback("OnEnter", FireOnEnter)
    firstDropdown:SetCallback("OnLeave", FireOnLeave)
    secondDropDown:SetCallback("OnEnter", FireOnEnter)
    secondDropDown:SetCallback("OnLeave", FireOnLeave)


    widget:DoLayout("two")
  end,
  ["OnRelease"] = function(self)
    self.firstDropdown:SetCallback("OnValueChanged", nil)
    self.secondDropDown:SetCallback("OnValueChanged", nil)
    self.firstDropdown:SetCallback("OnEnter", nil)
    self.firstDropdown:SetCallback("OnLeave", nil)
    self.secondDropDown:SetCallback("OnEnter", nil)
    self.secondDropDown:SetCallback("OnLeave", nil)

    AceGUI:Release(self.firstDropdown)
    AceGUI:Release(self.secondDropDown)

    self.firstDropdown = nil
    self.secondDropDown = nil
  end,
  ["SetLabel"] = function(self, v)
    if v == "" then
      v = " "
    end
    self.firstDropdown:SetLabel(v)
  end,
  ["SetValue"] = function(self, value)
    for displayName, treeValue in pairs(self.userdata.tree) do
      if CompareValues(treeValue, value) then
        self:DoLayout("one")
        self.firstDropdown:SetValue(tIndexOf(self.userdata.firstList, displayName))
        return
      elseif IsSecondLevelTable(treeValue) then
        for displayName2, key in pairs(treeValue) do
          if CompareValues(key, value) then
            self:DoLayout("two")
            local index = tIndexOf(self.userdata.firstList, displayName);
            self.firstDropdown:SetValue(index)
            self.firstDropdown:OnFirstDropdownValueChanged("", index)
            self.secondDropDown:SetValue(tIndexOf(self.userdata.secondList, displayName2))
            return
          end
        end
      end
    end
    self:DoLayout("one")
    self.firstDropdown:SetValue(nil)
  end,
  ["GetValue"] = function(self)
    local displayName1 = self.userdata.firstList[self.firstDropdown:GetValue()]

    local treeValue = self.userdata.tree[displayName1]
    if not treeValue then
      return nil
    end
    if not IsSecondLevelTable(treeValue) then
      return treeValue
    end

    local displayName2 = self.userdata.secondList[self.secondDropDown:GetValue()]
    treeValue = treeValue[displayName2]
    if not treeValue then
      return nil
    end
    return treeValue
  end,
  ["SetList"] = function(self, list, order, itemType)
    local tree = {}
    for key, displayName in pairs(list) do
      if type(displayName) == "table" then
        local base = displayName[1]
        local suffix = displayName[2]
        tree[base] = tree[base] or CreateSecondLevelTable()
        tree[base][suffix] = key
        if displayName[3] == true then
          self.secondDropDown.userdata.defaultSelection[base] = suffix
        end
      else
        tree[displayName] = key
      end
    end
    self.userdata.tree = tree

    local firstList = {}
    for displayName, _ in pairs(tree) do
      tinsert(firstList, displayName)
    end
    table.sort(firstList)
    self.userdata.firstList = firstList
    self.firstDropdown:SetList(firstList, order, itemType)
  end,
  ["OnWidthSet"] = function(self)
    self:DoLayout(self.mode)
  end
}

local function Constructor()
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:SetHeight(50)
  frame:SetWidth(50)

  local content = CreateFrame("Frame", nil, frame)
  content:SetPoint("TOPLEFT", 0, 0)
  content:SetPoint("BOTTOMRIGHT", 0, 0)

  local widget = {
    frame = frame,
    content = content,
    type = Type
  }
  for method, func in pairs(methods) do
    widget[method] = func
  end
  return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGUIWidget-WeakAurasTwoColumnDropDown.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGuiWidget-WeakAurasMediaSound.lua ===
--[[-----------------------------------------------------------------------------
WeakAurasMediaSound Widget

This code come from https://www.curseforge.com/wow/addons/libddi-1-0 by Funkeh under "Ace3 Style BSD" licence
-------------------------------------------------------------------------------]]
local Type, Version = "WeakAurasMediaSound", 1
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then
  return
end
local L = WeakAuras.L
local media = LibStub("LibSharedMedia-3.0")
local prototype = LibStub("AceGUI-3.0-DropDown-ItemBase"):GetItemBase()

local ignore = {
  [" " ..L["Custom"]] = true,
  [" " ..L["Sound by Kit ID"]] = true,
  [L["None"]] = true
}

local function updateToggle(self)
  if self.value then
    self.check:Show()
  else
    self.check:Hide()
  end
end

local function updateSndButton(self)
  local text = self.obj.text:GetText()
  if text == nil or ignore[text] then
    self.sndButton:Hide()
  else
    self.sndButton:Show()
  end
end

local function onRelease(self)
  prototype.OnRelease(self)
  self:SetValue(nil)
end

local function onClick(frame)
  local self = frame.obj
  if self.disabled then return end
  self.value = not self.value
  if self.value then
    PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
  else
    PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
  end
  updateToggle(self)
  self:Fire("OnValueChanged", self.value)
end

local function setValue(self, value)
  self.value = value
  updateToggle(self)
end

local function getValue(self)
  return self.value
end

local function soundOnClick(self)
  local snd = media:Fetch("sound", self.sound:GetText())
  if snd then PlaySoundFile(snd, "Master") end
end

local function constructor()
  local self = prototype.Create(Type)
  self.frame:SetScript("OnShow", updateSndButton)
  self.frame:SetScript("OnClick", onClick)
  self.SetValue = setValue
  self.GetValue = getValue
  self.OnRelease = onRelease
  local frame = self.frame

  local sndButton = CreateFrame("Button", nil, frame)
  sndButton:SetWidth(16)
  sndButton:SetHeight(16)
  sndButton:SetPoint("RIGHT", frame, "RIGHT", -3, -1)
  sndButton:SetScript("OnClick", soundOnClick)
  sndButton.sound = frame.obj.text
  frame.sndButton = sndButton

  local icon = sndButton:CreateTexture(nil, "BACKGROUND")
  icon:SetTexture(130979) --"Interface\\Common\\VoiceChat-Speaker"
  icon:SetAllPoints(sndButton)

  local highlight = sndButton:CreateTexture(nil, "HIGHLIGHT")
  highlight:SetTexture(130977) --"Interface\\Common\\VoiceChat-On"
  highlight:SetAllPoints(sndButton)

  AceGUI:RegisterAsWidget(self)
  return self
end
AceGUI:RegisterWidgetType(Type, constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGuiWidget-WeakAurasMediaSound.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/AceGuiWidget-WeakAurasProgressBar.lua ===
if not WeakAuras.IsLibsOK() then return end
--[[-----------------------------------------------------------------------------
Progress Bar Widget
A simple progress bar
-------------------------------------------------------------------------------]]
local Type, Version = "WeakAurasProgressBar", 2
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

local methods = {
	["OnAcquire"] = function(self)
		self:SetFullWidth(true)
    self:SetHeight(10)
    self.value = 0
    self.total = 1
	end,
  ["SetProgress"] = function(self, value, total)
    self.value = value
    self.total = total
    local p = value / total
    if p > 1 then
      p = 1
    end
    self.foreground:SetPoint("RIGHT", self.background, "LEFT", p * self.background:GetWidth(), 0)
  end,
  ["OnWidthSet"] = function(self)
    self:SetProgress(self.value, self.total)
  end
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
  local foreground = frame:CreateTexture(nil, "ARTWORK")
  local background = frame:CreateTexture(nil, "ARTWORK")
  foreground:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White")
  background:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White")
  background:SetVertexColor(0.5, 0.5, 0.5)
  foreground:SetDrawLayer("ARTWORK", 0);
  background:SetDrawLayer("ARTWORK", -1);

  background:SetAllPoints()
  foreground:SetPoint("TOPLEFT")
  foreground:SetPoint("BOTTOMLEFT")
  foreground:SetPoint("RIGHT", background, "LEFT", 0, 0)

	frame:Hide()

  --- @type table<string, any>
	local widget = {
		frame = frame,
    foreground = foreground,
    background = background,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/AceGuiWidget-WeakAurasProgressBar.lua ===


=== FILE: WeakAurasOptions/AceGUI-Widgets/WeakAurasStatusbarAtlasWidget.lua ===
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Original Widget created by Yssaril, modified by WeakAuras Team to handle Atlas

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

do
	local widgetType = "WA_LSM30_StatusbarAtlas"
	local widgetVersion = 1

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(this, button)
		local self = this.obj
		self:Fire("OnValueChanged", this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
      ---@class Button
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check
			local bar = frame:CreateTexture("ARTWORK")
				bar:SetHeight(16)
				bar:SetPoint("LEFT",check,"RIGHT",1,0)
				bar:SetPoint("RIGHT",frame,"RIGHT",-1,0)
			frame.bar = bar
			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")

				local font, size = text:GetFont()
				text:SetFont(font,size,"OUTLINE")

				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 3, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
    self.list = list or Media:HashTable("statusbar")
	end


	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local statusbar = self.list[text] ~= text and self.list[text] or Media:Fetch('statusbar', text)
		if type(statusbar) == "string" and C_Texture.GetAtlasInfo(statusbar) ~= nil then
			self.bar:SetAtlas(statusbar)
		else
			self.bar:SetTexture(statusbar)
		end
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	local sortedlist = {}
	local function ToggleDrop(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			for k, v in pairs(self.list) do
				sortedlist[#sortedlist+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				--print(k)
				if k == self.value then
					f.check:Show()
				end

				local statusbar = self.list[k] ~= k and self.list[k] or Media:Fetch('statusbar',k)
				if type(statusbar) == "string" and C_Texture.GetAtlasInfo(statusbar) ~= nil then
					f.bar:SetAtlas(statusbar)
				else
					f.bar:SetTexture(statusbar)
				end
				f.obj = self
				f.dropdown = self.dropdown
				self.dropdown:AddFrame(f)
			end
			wipe(sortedlist)
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter(this)
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave(this)
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrame()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		local bar = frame:CreateTexture(nil, "OVERLAY")
			bar:SetPoint("TOPLEFT", frame,"TOPLEFT",6,-25)
			bar:SetPoint("BOTTOMRIGHT", frame,"BOTTOMRIGHT", -21, 5)
			bar:SetAlpha(0.5)
		self.bar = bar

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

=== END OF FILE: WeakAurasOptions/AceGUI-Widgets/WeakAurasStatusbarAtlasWidget.lua ===


=== FILE: WeakAurasOptions/ActionOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local removeFuncs = OptionsPrivate.commonOptions.removeFuncs
local replaceNameDescFuncs = OptionsPrivate.commonOptions.replaceNameDescFuncs
local replaceImageFuncs = OptionsPrivate.commonOptions.replaceImageFuncs
local replaceValuesFuncs = OptionsPrivate.commonOptions.replaceValuesFuncs
local disabledAll = OptionsPrivate.commonOptions.CreateDisabledAll("action")
local hiddenAll = OptionsPrivate.commonOptions.CreateHiddenAll("action")
local getAll = OptionsPrivate.commonOptions.CreateGetAll("action")
local setAll = OptionsPrivate.commonOptions.CreateSetAll("action", getAll)
local dynamicTextInputs = {}

local RestrictedChannelCheck = function(data)
  return data.message_type == "SAY" or data.message_type == "YELL" or data.message_type == "SMARTRAID"
end

--- @type number? the time at which the last sound was played, so that we don't play
---  a sound from each setter
local lastPlayedSoundFromSet

function OptionsPrivate.GetActionOptions(data)
  local action = {
    type = "group",
    name = L["Actions"],
    order = 50,
    get = function(info)
      local split = info[#info]:find("_");
      if(split) then
        local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
        if(data.actions and data.actions[field]) then
          if (info.type == "color") then
            if type(data.actions[field][value]) == "table" then
              local c = data.actions[field][value]
              return c[1], c[2], c[3], c[4];
            else
              return 1, 1, 1, 1
            end
          else
            return data.actions[field][value];
          end
        else
          return nil;
        end
      end
    end,
    set = function(info, v, g, b, a)
      local split = info[#info]:find("_");
      local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
      data.actions = data.actions or {};
      data.actions[field] = data.actions[field] or {};
      if (info.type == "color") then
        if not data.actions[field][value] or type(data.actions[field][value]) ~= "table" then
          data.actions[field][value] = {}
        end
        local c = data.actions[field][value]
        c[1], c[2], c[3], c[4] = v, g, b, a;
      else
        data.actions[field][value] = v;
      end
      if(value == "sound" or value == "sound_path") then
        if lastPlayedSoundFromSet ~= GetTime() then
          pcall(PlaySoundFile, v, "Master")
          lastPlayedSoundFromSet = GetTime()
        end
      elseif(value == "sound_kit_id") then
        if lastPlayedSoundFromSet ~= GetTime() then
          pcall(PlaySound, v, "Master")
          lastPlayedSoundFromSet = GetTime()
        end
      end
      WeakAuras.Add(data);
      if(value == "message") then
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end,
    args = {
      init_header = {
        type = "header",
        name = L["Custom Functions"],
        order = 0.1
      },
      init_do_custom = {
        type = "toggle",
        name = L["Custom Init"],
        order = 0.2,
        width = WeakAuras.doubleWidth
      },
      init_do_custom_load = {
        type = "toggle",
        name = L["Custom Load"],
        order = 0.3,
        width = WeakAuras.doubleWidth
      },
      init_do_custom_unload = {
        type = "toggle",
        name = L["Custom Unload"],
        order = 0.4,
        width = WeakAuras.doubleWidth
      },
      -- texteditor added here by AddCodeOption
      start_header = {
        type = "header",
        name = L["On Show"],
        order = 0.5
      },
      start_do_message = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Chat Message"],
        order = 1
      },
      start_message_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Message Type"],
        order = 2,
        values = OptionsPrivate.Private.send_chat_message_types,
        sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.send_chat_message_types),
        disabled = function() return not data.actions.start.do_message end,
      },
      start_message_warning = {
        type = "description",
        width = WeakAuras.doubleWidth,
        name = L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."],
        order = 2.5,
        hidden = function() return not RestrictedChannelCheck(data.actions.start) end
      },
      start_message_space = {
        type = "execute",
        width = WeakAuras.normalWidth,
        name = "",
        order = 3,
        image = function() return "", 0, 0 end,
        hidden = function()
          return not(data.actions.start.message_type == "COMBAT"
                     or data.actions.start.message_type == "PRINT" or data.actions.start.message_type == "ERROR")
        end
      },
      start_message_color = {
        type = "color",
        width = WeakAuras.normalWidth,
        name = L["Color"],
        order = 3,
        hasAlpha = false,
        hidden = function()
          return not(data.actions.start.message_type == "COMBAT"
                     or data.actions.start.message_type == "PRINT"
                     or data.actions.start.message_type == "ERROR")
        end,
        get = function() return data.actions.start.r or 1, data.actions.start.g or 1, data.actions.start.b or 1 end,
        set = function(info, r, g, b)
          data.actions.start.r = r;
          data.actions.start.g = g;
          data.actions.start.b = b;
          WeakAuras.Add(data);
        end
      },
      start_message_dest = {
        type = "input",
        width = WeakAuras.normalWidth - 0.15,
        name = L["Send To"],
        order = 3.1,
        disabled = function() return not data.actions.start.do_message end,
        hidden = function() return data.actions.start.message_type ~= "WHISPER" end,
        control = "WeakAurasInput",
        callbacks = {
          OnEditFocusGained = function(self)
            local widget = dynamicTextInputs["start_message_dest"]
            OptionsPrivate.ToggleTextReplacements(data, widget, "OnEditFocusGained")
          end,
          OnEditFocusLost = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
          end,
          OnEnterPressed = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEnterPressed")
          end,
          OnShow = function(self)
            dynamicTextInputs["start_message_dest"] = self
          end,
        }
      },
      start_message_dest_text_replacements_button = {
        type = "execute",
        width = 0.15,
        name = L["Dynamic Text Replacements"],
        desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
        order = 3.11,
        disabled = function() return not data.actions.start.do_message end,
        hidden = function() return data.actions.start.message_type ~= "WHISPER" end,
        func = function()
          local widget = dynamicTextInputs["start_message_dest"]
          OptionsPrivate.ToggleTextReplacements(data, widget, "ToggleButton")
        end,
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
      },
      start_message_dest_isunit = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Is Unit"],
        order = 3.15,
        hidden = function()
          return data.actions.start.message_type ~= "WHISPER"
        end
      },
      start_message_tts_space = {
        type = "execute",
        width = WeakAuras.normalWidth,
        name = "",
        order = 3.19,
        image = function() return "", 0, 0 end,
        hidden = function() return data.actions.start.message_type ~= "TTS" end,
      },
      start_message_tts_settings = {
        type = "execute",
        width = WeakAuras.normalWidth,
        func = function()
          ShowUIPanel(ChatConfigFrame)
          ChatConfigFrameChatTabManager:UpdateSelection(VOICE_WINDOW_ID)
        end,
        name = L["Voice Settings"],
        order = 3.2,
        disabled = function() return not data.actions.start.do_message end,
        hidden = function() return data.actions.start.message_type ~= "TTS" end,
      },
      start_message = {
        type = "input",
        width = WeakAuras.doubleWidth - 0.15,
        name = L["Message"],
        order = 4,
        disabled = function() return not data.actions.start.do_message end,
        control = "WeakAurasInput",
        callbacks = {
          OnEditFocusGained = function(self)
            local widget = dynamicTextInputs["start_message"]
            OptionsPrivate.ToggleTextReplacements(data, widget, "OnEditFocusGained")
          end,
          OnEditFocusLost = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
          end,
          OnEnterPressed = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEnterPressed")
          end,
          OnShow = function(self)
            dynamicTextInputs["start_message"] = self
          end,
        }
      },
      start_message_text_replacements_button = {
        type = "execute",
        width = 0.15,
        name = L["Dynamic Text Replacements"],
        desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
        order = 4.1,
        disabled = function() return not data.actions.start.do_message end,
        func = function()
          local widget = dynamicTextInputs["start_message"]
          OptionsPrivate.ToggleTextReplacements(data, widget, "ToggleButton")
        end,
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
      },
      -- texteditor added later
      start_do_sound = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Play Sound"],
        order = 8
      },
      start_do_loop = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Loop"],
        order = 8.1,
        disabled = function() return not data.actions.start.do_sound end,
      },
      start_sound_repeat = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Repeat After"],
        order = 8.2,
        hidden = function() return not data.actions.start.do_loop end,
        disabled = function() return not data.actions.start.do_sound end,
        min = 0,
        softMax = 100,
      },
      start_sound_repeat_space = {
        type = "description",
        width = WeakAuras.normalWidth,
        order = 8.3,
        name = "",
        hidden = function() return not data.actions.start.do_loop end,
      },
      start_sound = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Sound"],
        order = 8.4,
        itemControl = "WeakAurasMediaSound",
        values = OptionsPrivate.Private.sound_types,
        sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.sound_types),
        disabled = function() return not data.actions.start.do_sound end,
      },
      start_sound_channel = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Sound Channel"],
        order = 8.5,
        values = OptionsPrivate.Private.sound_channel_types,
        disabled = function() return not data.actions.start.do_sound end,
        get = function() return data.actions.start.sound_channel or "Master" end
      },
      start_sound_path = {
        type = "input",
        width = WeakAuras.doubleWidth,
        name = L["Sound File Path"],
        order = 9,
        hidden = function() return data.actions.start.sound ~= " custom" end,
        disabled = function() return not data.actions.start.do_sound end
      },
      start_sound_kit_id = {
        type = "input",
        width = WeakAuras.doubleWidth,
        name = L["Sound Kit ID"],
        order = 9,
        hidden = function() return data.actions.start.sound ~= " KitID" end,
        disabled = function() return not data.actions.start.do_sound end
      },
      start_do_glow = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Glow External Element"],
        order = 10.1
      },
      start_glow_action = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Glow Action"],
        order = 10.2,
        values = OptionsPrivate.Private.glow_action_types,
        disabled = function() return not data.actions.start.do_glow end
      },
      start_glow_frame_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        desc = function()
          return (
            data.actions.start.glow_frame_type == "UNITFRAME"
            or data.actions.start.glow_frame_type == "NAMEPLATE"
          )
          and L["Require unit from trigger"] or nil
        end,
        name = L["Glow Frame Type"],
        order = 10.3,
        values = OptionsPrivate.Private.glow_frame_types,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action == nil
        end
      },
      start_glow_type_spacer = {
        type = "description",
        width = WeakAuras.normalWidth,
        name = "",
        order = 10.35,
        hidden = function()
          return not data.actions.start.do_glow
          or not (data.actions.start.glow_action == "hide" and data.actions.start.glow_frame_type == "FRAMESELECTOR")
        end,
      },
      start_glow_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Glow Type"],
        order = 10.4,
        values = OptionsPrivate.Private.glow_types,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_frame = {
        type = "input",
        width = WeakAuras.normalWidth,
        name = L["Frame"],
        order = 10.5,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_frame_type ~= "FRAMESELECTOR"
        end
      },
      start_choose_glow_frame = {
        type = "execute",
        width = WeakAuras.normalWidth,
        name = L["Choose"],
        order = 10.55,
        hidden = function() return not data.actions.start.do_glow or data.actions.start.glow_frame_type ~= "FRAMESELECTOR" end,
        func = function()
          if(data.controlledChildren and data.controlledChildren[1]) then
            WeakAuras.PickDisplay(data.controlledChildren[1]);
            OptionsPrivate.StartFrameChooser(WeakAuras.GetData(data.controlledChildren[1]), {"actions", "start", "glow_frame"});
          else
            OptionsPrivate.StartFrameChooser(data, {"actions", "start", "glow_frame"});
          end
        end
      },
      start_use_glow_color = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Glow Color"],
        order = 10.7,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_frame_type == nil
          or data.actions.start.glow_type == nil
        end,
      },
      start_glow_color = {
        type = "color",
        hasAlpha = true,
        width = WeakAuras.normalWidth,
        name = L["Glow Color"],
        order = 10.8,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_frame_type == nil
          or data.actions.start.glow_type == nil
        end,
        disabled = function() return not data.actions.start.use_glow_color end,
      },
      start_glow_startAnim = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Start Animation"],
        order = 10.801,
        get = function()
          return data.actions.start.glow_startAnim and true or false
        end,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_frame_type == nil
          or data.actions.start.glow_type ~= "Proc"
        end,
      },
      start_glow_duration = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Duration"],
        order = 10.802,
        softMin = 0.01,
        softMax = 3,
        step = 0.05,
        get = function()
          return data.actions.start.glow_duration or 1
        end,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_frame_type == nil
          or data.actions.start.glow_type ~= "Proc"
        end,
      },
      start_glow_lines = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Lines & Particles"],
        order = 10.81,
        min = 1,
        softMax = 30,
        step = 1,
        get = function()
          return data.actions.start.glow_lines or 8
        end,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or not data.actions.start.glow_type
          or data.actions.start.glow_type == "buttonOverlay"
          or data.actions.start.glow_type == "Proc"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_frequency = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Frequency"],
        order = 10.82,
        softMin = -2,
        softMax = 2,
        step = 0.05,
        get = function()
          return data.actions.start.glow_frequency or 0.25
        end,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or not data.actions.start.glow_type
          or data.actions.start.glow_type == "buttonOverlay"
          or data.actions.start.glow_type == "Proc"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_length = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Length"],
        order = 10.83,
        min = 0.05,
        softMax = 20,
        step = 0.05,
        get = function()
          return data.actions.start.glow_length or 10
        end,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_type ~= "Pixel"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_thickness = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Thickness"],
        order = 10.84,
        min = 0.05,
        softMax = 20,
        step = 0.05,
        get = function()
          return data.actions.start.glow_thickness or 1
        end,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_type ~= "Pixel"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_XOffset = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X-Offset"],
        order = 10.85,
        softMin = -100,
        softMax = 100,
        step = 0.5,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or not data.actions.start.glow_type
          or data.actions.start.glow_type == "buttonOverlay"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_YOffset = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y-Offset"],
        order = 10.86,
        softMin = -100,
        softMax = 100,
        step = 0.5,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or not data.actions.start.glow_type
          or data.actions.start.glow_type == "buttonOverlay"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_scale = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Scale"],
        order = 10.87,
        min = 0.05,
        softMax = 10,
        step = 0.05,
        isPercent = true,
        get = function()
          return data.actions.start.glow_scale or 1
        end,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_type ~= "ACShine"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_glow_border = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Border"],
        order = 10.88,
        hidden = function()
          return not data.actions.start.do_glow
          or data.actions.start.glow_action ~= "show"
          or data.actions.start.glow_type ~= "Pixel"
          or data.actions.start.glow_frame_type == nil
        end,
      },
      start_do_custom = {
        type = "toggle",
        width = WeakAuras.doubleWidth,
        name = L["Custom"],
        order = 11,
      },
      -- texteditor added laters
      finish_header = {
        type = "header",
        name = L["On Hide"],
        order = 20.5
      },
      finish_do_message = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Chat Message"],
        order = 21
      },
      finish_message_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Message Type"],
        order = 22,
        values = OptionsPrivate.Private.send_chat_message_types,
        sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.send_chat_message_types),
        disabled = function() return not data.actions.finish.do_message end,
      },
      finish_message_warning = {
        type = "description",
        width = WeakAuras.doubleWidth,
        name = L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."],
        order = 22.5,
        hidden = function() return not RestrictedChannelCheck(data.actions.finish) end
      },
      finish_message_space = {
        type = "execute",
        width = WeakAuras.normalWidth,
        name = "",
        order = 23,
        image = function() return "", 0, 0 end,
        hidden = function()
          return not(data.actions.finish.message_type == "COMBAT"
                     or data.actions.finish.message_type == "PRINT" or data.actions.finish.message_type == "ERROR")
        end
      },
      finish_message_color = {
        type = "color",
        width = WeakAuras.normalWidth - 0.15,
        name = L["Color"],
        order = 23,
        hasAlpha = false,
        hidden = function() return
          not(data.actions.finish.message_type == "COMBAT"
              or data.actions.finish.message_type == "PRINT"
              or data.actions.finish.message_type == "ERROR")
            end,
        get = function() return data.actions.finish.r or 1, data.actions.finish.g or 1, data.actions.finish.b or 1 end,
        set = function(info, r, g, b)
          data.actions.finish.r = r;
          data.actions.finish.g = g;
          data.actions.finish.b = b;
          WeakAuras.Add(data);
        end
      },
      finish_message_dest = {
        type = "input",
        width = WeakAuras.normalWidth - 0.15,
        name = L["Send To"],
        order = 23.1,
        disabled = function() return not data.actions.finish.do_message end,
        hidden = function() return data.actions.finish.message_type ~= "WHISPER" end,
        control = "WeakAurasInput",
        callbacks = {
          OnEditFocusGained = function(self)
            local widget = dynamicTextInputs["finish_message_dest"]
            OptionsPrivate.ToggleTextReplacements(data, widget, "OnEditFocusGained")
          end,
          OnEditFocusLost = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
          end,
          OnEnterPressed = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEnterPressed")
          end,
          OnShow = function(self)
            dynamicTextInputs["finish_message_dest"] = self
          end,
        }
      },
      finish_message_dest_text_replacements_button = {
        type = "execute",
        width = 0.15,
        name = L["Dynamic Text Replacements"],
        desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
        order = 23.11,
        disabled = function() return not data.actions.finish.do_message end,
        hidden = function() return data.actions.finish.message_type ~= "WHISPER" end,
        func = function()
          local widget = dynamicTextInputs["finish_message_dest"]
          OptionsPrivate.ToggleTextReplacements(data, widget, "ToggleButton")
        end,
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
      },
      finish_message_dest_isunit = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Is Unit"],
        order = 23.15,
        hidden = function()
          return data.actions.finish.message_type ~= "WHISPER"
        end
      },
      finish_message_tts_space = {
        type = "execute",
        width = WeakAuras.normalWidth,
        name = "",
        order = 23.19,
        image = function() return "", 0, 0 end,
        hidden = function() return data.actions.finish.message_type ~= "TTS" end,
      },
      finish_message_tts_settings = {
        type = "execute",
        width = WeakAuras.normalWidth,
        func = function()
          ShowUIPanel(ChatConfigFrame)
          ChatConfigFrameChatTabManager:UpdateSelection(VOICE_WINDOW_ID)
        end,
        name = L["Voice Settings"],
        order = 23.2,
        disabled = function() return not data.actions.finish.do_message end,
        hidden = function() return data.actions.finish.message_type ~= "TTS" end,
      },
      finish_message = {
        type = "input",
        width = WeakAuras.doubleWidth - 0.15,
        name = L["Message"],
        order = 24,
        disabled = function() return not data.actions.finish.do_message end,
        control = "WeakAurasInput",
        callbacks = {
          OnEditFocusGained = function(self)
            local widget = dynamicTextInputs["finish_message"]
            OptionsPrivate.ToggleTextReplacements(data, widget, "OnEditFocusGained")
          end,
          OnEditFocusLost = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
          end,
          OnEnterPressed = function(self)
            OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEnterPressed")
          end,
          OnShow = function(self)
            dynamicTextInputs["finish_message"] = self
          end,
        }
      },
      finish_message_text_replacements_button = {
        type = "execute",
        width = 0.15,
        name = L["Dynamic Text Replacements"],
        desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
        order = 24.1,
        disabled = function() return not data.actions.finish.do_message end,
        func = function()
          local widget = dynamicTextInputs["finish_message"]
          OptionsPrivate.ToggleTextReplacements(data, widget, "ToggleButton")
        end,
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
      },
      -- texteditor added below
      finish_do_sound = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Play Sound"],
        order = 28
      },
      finish_sound = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Sound"],
        order = 28.1,
        itemControl = "WeakAurasMediaSound",
        values = OptionsPrivate.Private.sound_types,
        sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.sound_types),
        disabled = function() return not data.actions.finish.do_sound end,
      },
      finish_sound_channel = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Sound Channel"],
        order = 28.5,
        values = OptionsPrivate.Private.sound_channel_types,
        disabled = function() return not data.actions.finish.do_sound end,
        get = function() return data.actions.finish.sound_channel or "Master" end
      },
      finish_sound_path = {
        type = "input",
        width = WeakAuras.doubleWidth,
        name = L["Sound File Path"],
        order = 29,
        hidden = function() return data.actions.finish.sound ~= " custom" end,
        disabled = function() return not data.actions.finish.do_sound end
      },
      finish_sound_kit_id = {
        type = "input",
        width = WeakAuras.doubleWidth,
        name = L["Sound Kit ID"],
        order = 29,
        hidden = function() return data.actions.finish.sound ~= " KitID" end,
        disabled = function() return not data.actions.finish.do_sound end
      },
      finish_stop_sound = {
        type = "toggle",
        width = WeakAuras.doubleWidth,
        name = L["Stop Sound"],
        order = 29.1,
      },
      finish_do_sound_fade = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Fadeout Sound"],
        order = 29.2,
        disabled = function() return not data.actions.finish.stop_sound end,
      },
      finish_stop_sound_fade = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Fadeout Time (seconds)"],
        order = 29.3,
        hidden = function() return not data.actions.finish.do_sound_fade end,
        disabled = function() return not data.actions.finish.stop_sound end,
        min = 0,
        softMax = 10,
        bigStep = 1,
      },
      finish_stop_sound_fade_space = {
        type = "description",
        width = WeakAuras.doubleWidth,
        order = 29.4,
        name = "",
      },
      finish_do_glow = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Glow External Element"],
        order = 30.1
      },
      finish_glow_action = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Glow Action"],
        order = 30.2,
        values = OptionsPrivate.Private.glow_action_types,
        disabled = function() return not data.actions.finish.do_glow end
      },
      finish_glow_frame_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        desc = function()
          return (
            data.actions.finish.glow_frame_type == "UNITFRAME"
            or data.actions.finish.glow_frame_type == "NAMEPLATE"
          )
          and L["Require unit from trigger"] or nil
        end,
        name = L["Glow Frame Type"],
        order = 30.3,
        values = OptionsPrivate.Private.glow_frame_types,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action == nil
        end
      },
      finish_glow_type_spacer = {
        type = "description",
        width = WeakAuras.normalWidth,
        name = "",
        order = 30.35,
        hidden = function()
          return not data.actions.finish.do_glow
          or not (data.actions.finish.glow_action == "hide" and data.actions.finish.glow_frame_type == "FRAMESELECTOR")
        end,
      },
      finish_glow_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Glow Type"],
        order = 30.4,
        values = OptionsPrivate.Private.glow_types,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_frame = {
        type = "input",
        width = WeakAuras.normalWidth,
        name = L["Frame"],
        order = 30.5,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_frame_type ~= "FRAMESELECTOR"
        end
      },
      finish_choose_glow_frame = {
        type = "execute",
        width = WeakAuras.normalWidth,
        name = L["Choose"],
        order = 30.55,
        hidden = function() return not data.actions.finish.do_glow or data.actions.finish.glow_frame_type ~= "FRAMESELECTOR" end,
        func = function()
          if(data.controlledChildren and data.controlledChildren[1]) then
            WeakAuras.PickDisplay(data.controlledChildren[1]);
            OptionsPrivate.StartFrameChooser(WeakAuras.GetData(data.controlledChildren[1]), {"actions", "finish", "glow_frame"});
          else
            OptionsPrivate.StartFrameChooser(data, {"actions", "finish", "glow_frame"});
          end
        end
      },
      finish_use_glow_color = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Glow Color"],
        order = 30.7,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_frame_type == nil
          or data.actions.finish.glow_type == nil
        end,
      },
      finish_glow_color = {
        type = "color",
        hasAlpha = true,
        width = WeakAuras.normalWidth,
        name = L["Glow Color"],
        order = 30.8,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_frame_type == nil
          or data.actions.finish.glow_type == nil
        end,
        disabled = function() return not data.actions.finish.use_glow_color end,
      },
      finish_glow_startAnim = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Start Animation"],
        order = 10.801,
        get = function()
          return data.actions.finish.glow_startAnim and true or false
        end,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_frame_type == nil
          or data.actions.finish.glow_type ~= "Proc"
        end,
      },
      finish_glow_duration = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Duration"],
        order = 10.802,
        softMin = 0.01,
        softMax = 3,
        step = 0.05,
        get = function()
          return data.actions.finish.glow_duration or 1
        end,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_frame_type == nil
          or data.actions.finish.glow_type ~= "Proc"
        end,
      },
      finish_glow_lines = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Lines & Particles"],
        order = 30.81,
        min = 1,
        softMax = 30,
        step = 1,
        get = function()
          return data.actions.finish.glow_lines or 8
        end,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or not data.actions.finish.glow_type
          or data.actions.finish.glow_type == "buttonOverlay"
          or data.actions.start.glow_type == "Proc"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_frequency = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Frequency"],
        order = 30.82,
        softMin = -2,
        softMax = 2,
        step = 0.05,
        get = function()
          return data.actions.finish.glow_frequency or 0.25
        end,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or not data.actions.finish.glow_type
          or data.actions.finish.glow_type == "buttonOverlay"
          or data.actions.start.glow_type == "Proc"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_length = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Length"],
        order = 30.83,
        min = 0.05,
        softMax = 20,
        step = 0.05,
        get = function()
          return data.actions.finish.glow_length or 10
        end,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_type ~= "Pixel"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_thickness = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Thickness"],
        order = 30.84,
        min = 0.05,
        softMax = 20,
        step = 0.05,
        get = function()
          return data.actions.finish.glow_thickness or 1
        end,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_type ~= "Pixel"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_XOffset = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X-Offset"],
        order = 30.85,
        softMin = -100,
        softMax = 100,
        step = 0.5,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or not data.actions.finish.glow_type
          or data.actions.finish.glow_type == "buttonOverlay"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_YOffset = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y-Offset"],
        order = 30.86,
        softMin = -100,
        softMax = 100,
        step = 0.5,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or not data.actions.finish.glow_type
          or data.actions.finish.glow_type == "buttonOverlay"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_scale = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Scale"],
        order = 30.87,
        min = 0.05,
        softMax = 10,
        step = 0.05,
        isPercent = true,
        get = function()
          return data.actions.finish.glow_scale or 1
        end,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_type ~= "ACShine"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_glow_border = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Border"],
        order = 30.88,
        hidden = function()
          return not data.actions.finish.do_glow
          or data.actions.finish.glow_action ~= "show"
          or data.actions.finish.glow_type ~= "Pixel"
          or data.actions.finish.glow_frame_type == nil
        end,
      },
      finish_hide_all_glows = {
        type = "toggle",
        width = WeakAuras.doubleWidth,
        name = L["Hide Glows applied by this aura"],
        order = 31,
      },
      finish_do_custom = {
        type = "toggle",
        width = WeakAuras.doubleWidth,
        name = L["Custom"],
        order = 32,
      },
    -- Text editor added below
    },
  }

  -- Text format option helpers

  OptionsPrivate.commonOptions.AddCodeOption(action.args, data, L["Custom Code"], "init", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#on-init",
                          0.21, function() return not data.actions.init.do_custom end, {"actions", "init", "custom"}, true)

  OptionsPrivate.commonOptions.AddCodeOption(action.args, data, L["Custom Code"], "customOnLoad", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#on-load",
                          0.31, function() return not data.actions.init.do_custom_load end, {"actions", "init", "customOnLoad"}, true)
  OptionsPrivate.commonOptions.AddCodeOption(action.args, data, L["Custom Code"], "customOnUnload", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#on-unload",
                          0.41, function() return not data.actions.init.do_custom_unload end, {"actions", "init", "customOnUnload"}, true)

  OptionsPrivate.commonOptions.AddCodeOption(action.args, data, L["Custom Code"], "start_message", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#chat-message---custom-code",
                          5, function() return not (data.actions.start.do_message and (OptionsPrivate.Private.ContainsCustomPlaceHolder(data.actions.start.message) or (data.actions.start.message_type == "WHISPER" and OptionsPrivate.Private.ContainsCustomPlaceHolder(data.actions.start.message_dest)))) end, {"actions", "start", "message_custom"}, false);

  local startHidden = function()
    return OptionsPrivate.IsCollapsed("format_option", "actions", "start_message", true)
  end

  local startSetHidden = function(hidden)
    OptionsPrivate.SetCollapsed("format_option", "actions", "start_message", hidden)
  end

  local startGet = function(key)
    return data.actions.start["message_format_" .. key]
  end

  local order = 6
  local usedKeys = {}
  local function startAddOption(key, option)
    if usedKeys[key] then
      return
    end
    usedKeys[key] = true
    option.order = order
    order = order + 0.01
    local reload = option.reloadOptions
    option.reloadOptions = nil
    option.set = function(info, v)
      data.actions.start["message_format_" .. key] = v
      WeakAuras.Add(data)
      if reload then
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end

    if option.hidden then
      local hidden = option.hidden
      option.hidden = function() return not data.actions.start.do_message or hidden() end
    else
      option.hidden = function() return not data.actions.start.do_message end
    end

    action.args["start_message_format_" .. key] = option
  end

  if data.controlledChildren then
    local list = {}
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      tinsert(list, child)
    end

    for index, child in ipairs(list) do
      local startGet = function(key)
        return child.actions.start["message_format_" .. key]
      end
      OptionsPrivate.AddTextFormatOption(child.actions and child.actions.start.message, true, startGet, startAddOption, startHidden, startSetHidden, true, index, #list)
    end
  else
    OptionsPrivate.AddTextFormatOption(data.actions and data.actions.start.message, true, startGet, startAddOption, startHidden, startSetHidden, true)
  end


  OptionsPrivate.commonOptions.AddCodeOption(action.args, data, L["Custom Code"], "start", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#on-show",
                          13, function() return not data.actions.start.do_custom end, {"actions", "start", "custom"}, true);

  OptionsPrivate.commonOptions.AddCodeOption(action.args, data, L["Custom Code"], "finish_message", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#chat-message---custom-code",
                          25, function() return not (data.actions.finish.do_message and (OptionsPrivate.Private.ContainsCustomPlaceHolder(data.actions.finish.message) or (data.actions.finish.message_type == "WHISPER" and OptionsPrivate.Private.ContainsCustomPlaceHolder(data.actions.finish.message_dest)))) end, {"actions", "finish", "message_custom"}, false);

  local finishHidden = function()
    return OptionsPrivate.IsCollapsed("format_option", "actions", "finish_message", true)
  end

  local finishSetHidden = function(hidden)
    OptionsPrivate.SetCollapsed("format_option", "actions", "finish_message", hidden)
  end

  local finishGet = function(key)
    return data.actions.finish["message_format_" .. key]
  end

  order = 26
  usedKeys = {}
  local function finishAddOption(key, option)
    if usedKeys[key] then
      return
    end
    option.order = order
    order = order + 0.01
    local reload = option.reloadOptions
    option.reloadOptions = nil
    option.set = function(info, v)
      data.actions.finish["message_format_" .. key] = v
      WeakAuras.Add(data)
      if reload then
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end

    if option.hidden then
      local hidden = option.hidden
      option.hidden = function() return not data.actions.finish.do_message or hidden() end
    else
      option.hidden = function() return not data.actions.finish.do_message end
    end

    action.args["finish_message_format_" .. key] = option
  end

  if data.controlledChildren then
    local list = {}
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      tinsert(list, child)
    end
    for index, child in ipairs(list) do
      local finishGet = function(key)
        return child.actions.finish["message_format_" .. key]
      end
      OptionsPrivate.AddTextFormatOption(child.actions and child.actions.finish.message, true, finishGet, finishAddOption, finishHidden, finishSetHidden, true, index, #list)
    end
  else
    OptionsPrivate.AddTextFormatOption(data.actions and data.actions.finish.message, true, finishGet, finishAddOption, finishHidden, finishSetHidden, true)
  end

  OptionsPrivate.commonOptions.AddCodeOption(action.args, data, L["Custom Code"], "finish", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#on-hide",
                          32, function() return not data.actions.finish.do_custom end, {"actions", "finish", "custom"}, true);

  if data.controlledChildren then
    removeFuncs(action)
    replaceNameDescFuncs(action, data, "action")
    replaceImageFuncs(action, data, "action")
    replaceValuesFuncs(action, data, "action")

    action.get = function(info, ...) return getAll(data, info, ...); end;
    action.set = function(info, ...)
      setAll(data, info, ...);
      if(type(data.id) == "string") then
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
      end
    end
    action.hidden = function(info, ...) return hiddenAll(data, info, ...); end;
    action.disabled = function(info, ...) return disabledAll(data, info, ...); end;
  end

  return action;
end

=== END OF FILE: WeakAurasOptions/ActionOptions.lua ===


=== FILE: WeakAurasOptions/AnimationOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local removeFuncs = OptionsPrivate.commonOptions.removeFuncs
local replaceNameDescFuncs = OptionsPrivate.commonOptions.replaceNameDescFuncs
local replaceImageFuncs = OptionsPrivate.commonOptions.replaceImageFuncs
local replaceValuesFuncs = OptionsPrivate.commonOptions.replaceValuesFuncs
local disabledAll = OptionsPrivate.commonOptions.CreateDisabledAll("animation")
local hiddenAll = OptionsPrivate.commonOptions.CreateHiddenAll("animation")
local getAll = OptionsPrivate.commonOptions.CreateGetAll("animation")
local setAll = OptionsPrivate.commonOptions.CreateSetAll("animation", getAll)



local function filterAnimPresetTypes(intable, id)
  local ret = {};
  OptionsPrivate.Private.EnsureRegion(id)
  local region = OptionsPrivate.Private.regions[id] and OptionsPrivate.Private.regions[id].region
  local regionType = OptionsPrivate.Private.regions[id] and OptionsPrivate.Private.regions[id].regionType
  local data = WeakAuras.GetData(id);

  if data.controlledChildren then
    return ret
  end

  if(region and regionType and data) then
    for key, value in pairs(intable) do
      local preset = OptionsPrivate.Private.anim_presets[key];
      if(preset) then
        if not((preset.use_scale and not region.Scale) or (preset.use_rotate and not region.SetAnimRotation)) then
          ret[key] = value;
        end
      end
    end
  end
  return ret;
end

function OptionsPrivate.GetAnimationOptions(data)
  local anim_types = OptionsPrivate.Private.anim_types
  local anim_translate_types = OptionsPrivate.Private.anim_translate_types;
  local anim_scale_types = OptionsPrivate.Private.anim_scale_types;
  local anim_alpha_types = OptionsPrivate.Private.anim_alpha_types;
  local anim_rotate_types = OptionsPrivate.Private.anim_rotate_types;
  local anim_color_types = OptionsPrivate.Private.anim_color_types;
  local anim_start_preset_types = OptionsPrivate.Private.anim_start_preset_types;
  local anim_main_preset_types = OptionsPrivate.Private.anim_main_preset_types;
  local anim_finish_preset_types = OptionsPrivate.Private.anim_finish_preset_types;
  local duration_types = OptionsPrivate.Private.duration_types;
  local duration_types_no_choice = OptionsPrivate.Private.duration_types_no_choice;
  local anim_ease_types = OptionsPrivate.Private.anim_ease_types;

  local id = data.id
  local animation = {
    type = "group",
    name = L["Animations"],
    order = 60,
    get = function(info)
      local split = info[#info]:find("_");
      if(split) then
        local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);

        if(data.animation and data.animation[field]) then
          return data.animation[field][value];
        else
          if(value == "scalex" or value == "scaley") then
            return 1;
          else
            return nil;
          end
        end
      end
    end,
    set = function(info, v)
      local split = info[#info]:find("_");
      local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
      data.animation = data.animation or {};
      data.animation[field] = data.animation[field] or {};
      data.animation[field][value] = v;
      if(field == "main") then
        local region = OptionsPrivate.Private.EnsureRegion(id)
        OptionsPrivate.Private.Animate("display", data.uid, "main", data.animation.main, region, false, nil, true);
        if(OptionsPrivate.Private.clones[id]) then
          for cloneId, cloneRegion in pairs(OptionsPrivate.Private.clones[id]) do
            OptionsPrivate.Private.Animate("display", data.uid, "main", data.animation.main,
                                           cloneRegion, false, nil, true, cloneId);
          end
        end
      end
      WeakAuras.Add(data);
    end,
    disabled = function(info, v)
      local split = info[#info]:find("_");
      local valueToType = {
        alphaType = "use_alpha",
        alpha = "use_alpha",
        translateType = "use_translate",
        x = "use_translate",
        y = "use_translate",
        scaleType = "use_scale",
        scalex = "use_scale",
        scaley = "use_scale",
        rotateType = "use_rotate",
        rotate = "use_rotate",
        colorType = "use_color",
        color = "use_color"
      }
      if(split) then
        local field, value = info[#info]:sub(1, split-1), info[#info]:sub(split+1);
        if(data.animation and data.animation[field]) then
          if(valueToType[value]) then
            return not data.animation[field][valueToType[value]];
          else
            return false;
          end
        else
          return true;
        end
      else
        return false;
      end
    end,
    args = {
      start_header = {
        type = "header",
        name = L["Start"],
        order = 30
      },
      start_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 32,
        values = anim_types,
        disabled = false
      },
      start_preset = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Preset"],
        order = 33,
        values = function() return filterAnimPresetTypes(anim_start_preset_types, id) end,
        hidden = function() return data.animation.start.type ~= "preset" end
      },
      start_duration_type = {
        type = "select",
        width = WeakAuras.halfWidth,
        name = L["Time in"],
        order = 33,
        values = duration_types,
        hidden = function()
          return data.animation.start.type ~= "custom"
        end
      },
      start_duration = {
        type = "input",
        width = WeakAuras.halfWidth,
        name = function()
          if(data.animation.start.duration_type == "relative") then
            return L["% of Progress"];
          else
            return L["Duration (s)"];
          end
        end,
        desc = function()
          if(data.animation.start.duration_type == "relative") then
            return L["Animation relative duration description"];
          else
            return L["The duration of the animation in seconds."];
          end
        end,
        order = 33.5,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      start_easeType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Ease type"],
        values = anim_ease_types,
        order = 33.7,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      start_easeStrength = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Ease Strength"],
        order = 33.8,
        min = 1,
        max = 5,
        bigStep = 1,
        hidden = function() return data.animation.start.type ~= "custom" end,
        disabled = function() return data.animation.start.easeType == "none" end
      },
      start_use_alpha = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Fade In"],
        order = 34,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      start_alphaType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 35,
        values = anim_alpha_types,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      -- text editor added below
      start_alpha = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.doubleWidth,
        name = L["Alpha"],
        order = 36,
        min = 0,
        max = 1,
        bigStep = 0.01,
        isPercent = true,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      start_use_translate = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Slide In"],
        order = 38,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      start_translateType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 39,
        values = anim_translate_types,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      -- texteditor added below
      start_x = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X Offset"],
        order = 40,
        softMin = -200,
        softMax = 200,
        step = 1,
        bigStep = 5,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      start_y = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y Offset"],
        order = 41,
        softMin = -200,
        softMax = 200,
        step = 1,
        bigStep = 5,
        hidden = function() return data.animation.start.type ~= "custom" end
      },
      start_use_scale = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Zoom In"],
        order = 42,
        hidden = function()
          return (
            data.animation.start.type ~= "custom"
            or not OptionsPrivate.Private.EnsureRegion(id).Scale
            ) end
      },
      start_scaleType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 43,
        values = anim_scale_types,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      -- texteditor added below
      start_scalex = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X Scale"],
        order = 44,
        softMin = 0,
        softMax = 5,
        step = 0.01,
        bigStep = 0.1,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      start_scaley = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y Scale"],
        order = 45,
        softMin = 0,
        softMax = 5,
        step = 0.01,
        bigStep = 0.1,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      start_use_rotate = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Rotate In"],
        order = 46,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      start_rotateType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 47,
        values = anim_rotate_types,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      -- texteditor added below
      start_rotate = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.doubleWidth,
        name = L["Angle"],
        order = 48,
        softMin = 0,
        softMax = 360,
        bigStep = 3,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      start_use_color = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Color"],
        order = 48.2,
        hidden = function()
           return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end
      },
      start_colorType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 48.5,
        values = anim_color_types,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end
      },
      -- texteditor added below
      start_color = {
        type = "color",
        width = WeakAuras.doubleWidth,
        name = L["Color"],
        order = 49.5,
        hidden = function()
          return (data.animation.start.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end,
        get = function()
          return data.animation.start.colorR or 1,
            data.animation.start.colorG or 1,
            data.animation.start.colorB or 1,
            data.animation.start.colorA or 1;
        end,
        set = function(info, r, g, b, a)
          data.animation.start.colorR = r;
          data.animation.start.colorG = g;
          data.animation.start.colorB = b;
          data.animation.start.colorA = a;
        end
      },
      main_header = {
        type = "header",
        name = L["Main"],
        order = 50
      },
      main_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 52,
        values = anim_types,
        disabled = false
      },
      main_preset = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Preset"],
        order = 53,
        values = function() return filterAnimPresetTypes(anim_main_preset_types, id) end,
        hidden = function() return data.animation.main.type ~= "preset" end
      },
      main_duration_type = {
        type = "select",
        width = WeakAuras.halfWidth,
        name = L["Time in"],
        order = 53,
        values = duration_types,
        hidden = function()
          return data.animation.main.type ~= "custom"
        end
      },
      main_duration = {
        type = "input",
        width = WeakAuras.halfWidth,
        name = function()
          if(data.animation.main.duration_type == "relative") then
            return L["% of Progress"];
          else
            return L["Duration (s)"];
          end
        end,
        desc = function()
          if(data.animation.main.duration_type == "relative") then
            return L["Animation relative duration description"];
          else
            local ret = "";
            ret = ret..L["The duration of the animation in seconds."].."\n";
            ret = ret..L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."]
            return ret;
          end
        end,
        order = 53.5,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      main_easeType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Ease type"],
        values = anim_ease_types,
        order = 53.7,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      main_easeStrength = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Ease Strength"],
        order = 53.8,
        min = 1,
        max = 5,
        bigStep = 1,
        hidden = function() return data.animation.main.type ~= "custom" end,
        disabled = function() return data.animation.main.easeType == "none" end
      },
      main_use_alpha = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Fade"],
        order = 54,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      main_alphaType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 55,
        values = anim_alpha_types,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      -- texteditor added below
      main_alpha = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.doubleWidth,
        name = L["Alpha"],
        order = 56,
        min = 0,
        max = 1,
        bigStep = 0.01,
        isPercent = true,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      main_use_translate = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Slide"],
        order = 58,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      main_translateType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 59,
        values = anim_translate_types,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      -- texteditor added below
      main_x = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X Offset"],
        order = 60,
        softMin = -200,
        softMax = 200,
        step = 1,
        bigStep = 5,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      main_y = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y Offset"],
        order = 61,
        softMin = -200,
        softMax = 200,
        step = 1,
        bigStep = 5,
        hidden = function() return data.animation.main.type ~= "custom" end
      },
      main_use_scale = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Zoom"],
        order = 62,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      main_scaleType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 63,
        values = anim_scale_types,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      -- texteditor added below
      main_scalex = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X Scale"],
        order = 64,
        softMin = 0,
        softMax = 5,
        step = 0.01,
        bigStep = 0.1,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      main_scaley = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y Scale"],
        order = 65,
        softMin = 0,
        softMax = 5,
        step = 0.01,
        bigStep = 0.1,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      main_use_rotate = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Rotate"],
        order = 66,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      main_rotateType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 67,
        values = anim_rotate_types,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      -- text editor added below
      main_rotate = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.doubleWidth,
        name = L["Angle"],
        order = 68,
        softMin = 0,
        softMax = 360,
        bigStep = 3,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      main_use_color = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Color"],
        order = 68.2,
        hidden = function()
           return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
          end
      },
      main_colorType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 68.5,
        values = anim_color_types,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end
      },
      -- texteditor added below
      main_color = {
        type = "color",
        width = WeakAuras.doubleWidth,
        name = L["Color"],
        order = 69.5,
        hidden = function()
          return (data.animation.main.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end,
        get = function()
          return data.animation.main.colorR or 1,
            data.animation.main.colorG or 1,
            data.animation.main.colorB or 1,
            data.animation.main.colorA or 1;
        end,
        set = function(info, r, g, b, a)
          data.animation.main.colorR = r;
          data.animation.main.colorG = g;
          data.animation.main.colorB = b;
          data.animation.main.colorA = a;
        end
      },
      finish_header = {
        type = "header",
        name = L["Finish"],
        order = 70
      },
      finish_type = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 72,
        values = anim_types,
        disabled = false
      },
      finish_preset = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Preset"],
        order = 73,
        values = function() return filterAnimPresetTypes(anim_finish_preset_types, id) end,
        hidden = function() return data.animation.finish.type ~= "preset" end
      },
      finish_duration_type_no_choice = {
        type = "select",
        width = WeakAuras.halfWidth,
        name = L["Time in"],
        order = 73,
        values = duration_types_no_choice,
        disabled = true,
        hidden = function() return data.animation.finish.type ~= "custom" end,
        get = function() return "seconds" end
      },
      finish_duration = {
        type = "input",
        width = WeakAuras.halfWidth,
        name = L["Duration (s)"],
        desc = L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."],
        order = 73.5,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      finish_easeType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Ease type"],
        values = anim_ease_types,
        order = 73.7,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      finish_easeStrength = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Ease Strength"],
        order = 73.8,
        min = 1,
        max = 5,
        bigStep = 1,
        hidden = function() return data.animation.finish.type ~= "custom" end,
        disabled = function() return data.animation.finish.easeType == "none" end
      },
      finish_use_alpha = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Fade Out"],
        order = 74,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      finish_alphaType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 75,
        values = anim_alpha_types,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      -- texteditor added below
      finish_alpha = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.doubleWidth,
        name = L["Alpha"],
        order = 76,
        min = 0,
        max = 1,
        bigStep = 0.01,
        isPercent = true,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      finish_use_translate = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Slide Out"],
        order = 78,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      finish_translateType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 79,
        values = anim_translate_types,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      -- texteditor added below
      finish_x = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X Offset"],
        order = 80,
        softMin = -200,
        softMax = 200,
        step = 1,
        bigStep = 5,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      finish_y = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y Offset"],
        order = 81,
        softMin = -200,
        softMax = 200,
        step = 1,
        bigStep = 5,
        hidden = function() return data.animation.finish.type ~= "custom" end
      },
      finish_use_scale = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Zoom Out"],
        order = 82,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      finish_scaleType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 83,
        values = anim_scale_types,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      -- texteditor added below
      finish_scalex = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["X Scale"],
        order = 84,
        softMin = 0,
        softMax = 5,
        step = 0.01,
        bigStep = 0.1,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      finish_scaley = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Y Scale"],
        order = 85,
        softMin = 0,
        softMax = 5,
        step = 0.01,
        bigStep = 0.1,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Scale)
        end
      },
      finish_use_rotate = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Rotate Out"],
        order = 86,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      finish_rotateType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 87,
        values = anim_rotate_types,
        hidden = function()
           return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
          end
      },
      -- texteditor added below
      finish_rotate = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.doubleWidth,
        name = L["Angle"],
        order = 88,
        softMin = 0,
        softMax = 360,
        bigStep = 3,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
        end
      },
      finish_use_color = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Color"],
        order = 88.2,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end
      },
      finish_colorType = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Type"],
        order = 88.5,
        values = anim_color_types,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end
      },
      -- texteditor added below
      finish_color = {
        type = "color",
        width = WeakAuras.doubleWidth,
        name = L["Color"],
        order = 89.5,
        hidden = function()
          return (data.animation.finish.type ~= "custom" or not OptionsPrivate.Private.EnsureRegion(id).Color)
        end,
        get = function()
          return data.animation.finish.colorR or 1,
            data.animation.finish.colorG or 1,
            data.animation.finish.colorB or 1,
            data.animation.finish.colorA or 1;
        end,
        set = function(info, r, g, b, a)
          data.animation.finish.colorR = r;
          data.animation.finish.colorG = g;
          data.animation.finish.colorB = b;
          data.animation.finish.colorA = a;
        end
      }
    }
  }

  local function extraSetFunction()
    OptionsPrivate.Private.Animate("display", data.uid, "main", data.animation.main,
                                   OptionsPrivate.Private.EnsureRegion(id), false, nil, true)
    if(OptionsPrivate.Private.clones[id]) then
      for cloneId, cloneRegion in pairs(OptionsPrivate.Private.clones[id]) do
        OptionsPrivate.Private.Animate("display", data.uid, "main", data.animation.main,
                                       cloneRegion, false, nil, true, cloneId)
      end
    end
  end

  -- Text Editors for "start"
  local function hideStartAlphaFunc()
    return data.animation.start.type ~= "custom"
           or data.animation.start.alphaType ~= "custom"
           or not data.animation.start.use_alpha
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "start_alphaFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#alpha-opacity",
                          35.3, hideStartAlphaFunc, {"animation", "start", "alphaFunc"}, false);

  local function hideStartTranslate()
    return data.animation.start.type ~= "custom"
           or data.animation.start.translateType ~= "custom"
           or not data.animation.start.use_translate
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "start_translateFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#translate-position",
                          39.3, hideStartTranslate, {"animation", "start", "translateFunc"}, false);

  local function hideStartScale()
    return data.animation.start.type ~= "custom"
           or data.animation.start.scaleType ~= "custom"
           or not (data.animation.start.use_scale and OptionsPrivate.Private.EnsureRegion(id).Scale)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "start_scaleFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#scale-size",
                          43.3, hideStartScale, {"animation", "start", "scaleFunc"}, false);

  local function hideStartRotateFunc()
    return data.animation.start.type ~= "custom"
           or data.animation.start.rotateType ~= "custom"
           or not (data.animation.start.use_rotate and OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "start_rotateFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#rotate",
                          47.3, hideStartRotateFunc, {"animation", "start", "rotateFunc"}, false);

  local function hideStartColorFunc()
    return data.animation.start.type ~= "custom"
           or data.animation.start.colorType ~= "custom"
           or not (data.animation.start.use_color and OptionsPrivate.Private.EnsureRegion(id).Color)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "start_colorFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#color",
                          48.7, hideStartColorFunc, {"animation", "start", "colorFunc"}, false);

  -- Text Editors for "main"
  local function hideMainAlphaFunc()
    return data.animation.main.type ~= "custom"
           or data.animation.main.alphaType ~= "custom"
           or not data.animation.main.use_alpha
  end
  local mainCodeOptions = { extraSetFunction = extraSetFunction }
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "main_alphaFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#alpha-opacity",
                          55.3, hideMainAlphaFunc, {"animation", "main", "alphaFunc"}, false, mainCodeOptions);

  local function hideMainTranslate()
    return data.animation.main.type ~= "custom"
           or data.animation.main.translateType ~= "custom"
           or not data.animation.main.use_translate
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "main_translateFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#translate-position",
                          59.3, hideMainTranslate, {"animation", "main", "translateFunc"}, false, mainCodeOptions);

  local function hideMainScale()
    return data.animation.main.type ~= "custom"
           or data.animation.main.scaleType ~= "custom"
           or not (data.animation.main.use_scale and OptionsPrivate.Private.EnsureRegion(id).Scale)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "main_scaleFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#scale-sizes",
                          63.3, hideMainScale, {"animation", "main", "scaleFunc"}, false, mainCodeOptions);

  local function hideMainRotateFunc()
    return data.animation.main.type ~= "custom"
           or data.animation.main.rotateType ~= "custom"
           or not (data.animation.main.use_rotate and OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "main_rotateFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#rotate",
                          67.3, hideMainRotateFunc, {"animation", "main", "rotateFunc"}, false, mainCodeOptions);

  local function hideMainColorFunc()
    return data.animation.main.type ~= "custom"
           or data.animation.main.colorType ~= "custom"
           or not (data.animation.main.use_color and OptionsPrivate.Private.EnsureRegion(id).Color)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "main_colorFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#color",
                          68.7, hideMainColorFunc, {"animation", "main", "colorFunc"}, false, mainCodeOptions);

  -- Text Editors for "finish"
  local function hideFinishAlphaFunc()
    return data.animation.finish.type ~= "custom"
           or data.animation.finish.alphaType ~= "custom"
           or not data.animation.finish.use_alpha
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "finish_alphaFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#alpha-opacity",
                          75.3, hideFinishAlphaFunc, {"animation", "finish", "alphaFunc"}, false);

  local function hideFinishTranslate()
    return data.animation.finish.type ~= "custom"
           or data.animation.finish.translateType ~= "custom"
           or not data.animation.finish.use_translate
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "finish_translateFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#translate-position",
                          79.3, hideFinishTranslate, {"animation", "finish", "translateFunc"}, false);

  local function hideFinishScale()
    return data.animation.finish.type ~= "custom"
           or data.animation.finish.scaleType ~= "custom"
           or not (data.animation.finish.use_scale and OptionsPrivate.Private.EnsureRegion(id).Scale)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "finish_scaleFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#scale-size",
                          83.3, hideFinishScale, {"animation", "finish", "scaleFunc"}, false);

  local function hideFinishRotateFunc()
    return data.animation.finish.type ~= "custom"
           or data.animation.finish.rotateType ~= "custom"
           or not (data.animation.finish.use_rotate and OptionsPrivate.Private.EnsureRegion(id).SetAnimRotation)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "finish_rotateFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#rotate",
                          87.3, hideFinishRotateFunc, {"animation", "finish", "rotateFunc"}, false);

  local function hideFinishColorFunc()
    return data.animation.finish.type ~= "custom"
           or data.animation.finish.colorType ~= "custom"
           or not (data.animation.finish.use_color and OptionsPrivate.Private.EnsureRegion(id).Color)
  end
  OptionsPrivate.commonOptions.AddCodeOption(animation.args, data, L["Custom Function"], "finish_colorFunc",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#color",
                          88.7, hideFinishColorFunc, {"animation", "finish", "colorFunc"}, false);

  if(data.controlledChildren) then
    removeFuncs(animation);
    replaceNameDescFuncs(animation, data, "animation");
    replaceImageFuncs(animation, data, "animation");
    replaceValuesFuncs(animation, data, "animation");

    animation.get = function(info, ...) return getAll(data, info, ...); end;
    animation.set = function(info, ...)
      setAll(data, info, ...);
      if(type(data.id) == "string") then
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
      end
    end
    animation.hidden = function(info, ...) return hiddenAll(data, info, ...); end;
    animation.disabled = function(info, ...) return disabledAll(data, info, ...); end;
  end

  return animation;
end

=== END OF FILE: WeakAurasOptions/AnimationOptions.lua ===


=== FILE: WeakAurasOptions/AuthorOptions.lua ===
--[[
  writes to options field of aura data, which is then read to construct the user config panel

  Values in aura data:
  authorOptions -> array of options.
  config -> key/value hash table.
    key, and format of value are defined by author, and the precise value is defined by the user.
    This table gets copied into the aura's script environment via aura_env.config.
  authorMode -> bool, used to determine if author or user mode is displayed in Custom Options tab.

  option -> table with fields:
    type (required) -> string such as "toggle", "slider", "string", "number", "color", etc.
    key (required) -> string which custom scripts can use to read the selected option
    default (required) -> default value of the option
    name (required) -> displayed name in the user config panel
    width (required) -> number between 0.1 and 2 (softMin of 0.5). Determines the width of the option.
    useDesc (optional) -> bool. If false, then the tooltip will not be used.
    desc (optional) -> string to be displayed in the option tooltip
  When options are merged together (i.e. when the user multiselects and then opens the custom options tab), there is one additional field:
    references -> childID <=> optionID map, used to dereference to the proper option table in setters
  Supported option types, and additional fields that each type supports/requires:
    group -> represents a group of options.
      useCollapse (optional) -> if true, then group will have a collapsible header in user mode.
      collapse (optional) -> whether or not the collapsible header begins collapsed when the user begins a session.
      subOptions (required) -> array of options
      groupType (required) -> type of group:
        simple -> group is for organizational purposes only.
                  config value is a sub config
        array -> group represents an array of entries from the user, with similar information between them:
                 config value is arranged as an array of sub configs, one for each entry in the array.
          limitType (required) -> Specifies if user can add or remove entries from the array freely
          size (optional) -> required if the limitType is not "none".
    description -> dummy option which can be used to display some text. Not interactive, and so key/default/name are not set or required.
      text (required) -> text displayed on the panel
      fontSize (optional) -> fontSize. Default is medium.
    space -> dummy option which acts as a spacer. Not interactive, and so key/default/name are not set or required.
      useWidth (required) -> bool. If false, then the space is given full width in AceConfig. Else, option.width is used.
      useHeight (required) -> bool. If false, then the space covers only the line it renders on. Else, it covers the number of lines specified.
      height (optional) -> number. Height of space, in lines.
    separator -> AceConfig header widget.
      useName (required) -> bool. If true, then option.text is used as the name.
      test (optional) -> string. Text to be shown on the header widget.
    input -> text field which the user can input a string.
      length (optional) -> allowed length of the string. If set, then input longer than the allowed length will be trimmed
    number -> text field which the user can type in a number. Input is converted to a number value.
      max (optional) -> maximum allowed value. If set, then input greater than the maximum will be clamped
      min (optional) -> minimum allowed value. If set, then input lesser than the minimum will be clamped
      step (optional) -> stepsize
    select -> dropdown menu with author-specified strings to select.
      values (required) -> array of strings to select. config value will be the index corresponding to the string.
    toggle -> checkbutton which can be in a state of true or false, corresponding to checked and unchecked
    color -> color selector. Color is delivered as an {r, g, b, a} array.
    range -> slider element which allows the user to select a number value.
      max (optional) -> maximum allowed value. If set, then input greater than the maximum will be clamped
      min (optional) -> minimum allowed value. If set, then input lesser than the minimum will be clamped
      softmax (optional) -> Like max, but the manual entry will accept values up to the softmax.
      softmin (optional) -> Like min, but the manual entry will accept values down to the softmin.
      bigStep (optional) -> step size of the slider. Defaults to 0.05
      step (optional) -> like bigStep, but applies to number input as well
]]
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local tinsert, tremove, tconcat = table.insert, table.remove, table.concat
local conflictBlue = "|cFF4080FF"
local conflict = {} -- magic value

local function atLeastOneSet(references, key)
  for _, optionData in pairs(references) do
    local childOption = optionData.options[optionData.index]
    if childOption[key] ~= nil then
      return true
    end
  end
end

local function neq(a, b)
  if type(a) == "table" and type(b) == "table" then
    for k, v in pairs(a) do
      if neq(v, b[k]) then
        return true
      end
    end
    for k, v in pairs(b) do
      if neq(v, a[k]) then
        return true
      end
    end
  else
    return a ~= b
  end
end

-- blues the name if there are conflicts between the references for this value
local function name(option, key, name, phrase)
  local header = name or phrase
  if option[key] ~= nil or not atLeastOneSet(option.references, key) then
    return header
  else
    return conflictBlue .. header
  end
end

-- blue if at least one member of the group does not have an option in the references
local function nameHead(data, option, phrase)
  if not data.controlledChildren then
    return phrase
  else
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      if not option.references[child.id] then
        return conflictBlue .. phrase
      end
    end
  end
  return phrase
end

local function nameUser(option)
  local firstValue
  for id, optionData in pairs(option.references) do
    local childConfig = optionData.config
    if not childConfig then
      return option.name
    elseif firstValue == nil then
      firstValue = childConfig[option.key]
    elseif neq(firstValue, childConfig[option.key]) then
      return conflictBlue .. option.name
    end
  end
  return option.name
end

local function nameUserDesc(option)
  if option.text then
    return option.text
  else
    local text = {}
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      if childOption.text and childOption.text ~= nil then
        tinsert(text, childOption.text)
      end
    end
    return conflictBlue .. tconcat(text, "\n")
  end
end

local function nameArray(option, array, index, phrase)
  local value
  for id, optionData in pairs(option.references) do
    local childOption = optionData.options[optionData.index]
    if not childOption[array] then
      return conflictBlue .. phrase
    elseif childOption[array][index] == nil then
      return conflictBlue .. phrase
    elseif value == nil then
      value = childOption[array][index]
    elseif value ~= childOption[array][index] then
      return conflictBlue .. phrase
    end
  end
  return phrase
end

-- provides a tooltip showing all the conflicting values if there are any
local function desc(option, key, phrase)
  if option[key] or not atLeastOneSet(option.references, key) then
    return phrase
  else
    local desc = {}
    if phrase then
      desc[1] = phrase
    end
    tinsert(desc, L["Values:"])
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      local childData = optionData.data
      if childOption[key] ~= nil then
        tinsert(
          desc,
          ("%s #%i: %s"):format(childData.id, optionData.path[#optionData.path], tostring(childOption[key]))
        )
      end
    end
    return tconcat(desc, "\n")
  end
end

local function descType(option)
  local desc = {
    L["This setting controls what widget is generated in user mode."],
    L["Used in Auras:"]
  }
  for id, optionData in pairs(option.references) do
    tinsert(desc, ("%s - Option %i"):format(id, optionData.path[#optionData.path]))
  end
  return tconcat(desc, "\n")
end

local function descSelect(option, key)
  if option.values then
    return ""
  else
    local desc = {L["Values:"]}
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      if childOption.values[key] ~= nil then
        tinsert(
          desc,
          ("%s %i: - %s"):format(id, optionData.path[#optionData.path], tostring(childOption.values[key]))
        )
      end
    end
    return tconcat(desc, "\n")
  end
end

local function descColor(option, key)
  if option[key] or not atLeastOneSet(option.references, key) then
    return L["Values are in normalized rgba format."]
  else
    local desc = {
      L["Values are in normalized rgba format."],
      L["Values:"]
    }
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      if childOption[key] ~= nil then
        tinsert(
          desc,
          ("%s #%i: %.2f %.2f %.2f %.2f"):format(
            id,
            childOption.path[#childOption.path],
            unpack(childOption[key])
          )
        )
      end
    end
    return tconcat(desc, "\n")
  end
end

local function descUser(option)
  if option.useDesc ~= nil and option.desc ~= nil then
    return option.useDesc and option.desc or nil
  else
    local desc = {}
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      if childOption.useDesc and childOption.desc and childOption.desc ~= "" then
        tinsert(desc, ("%s - %s"):format(id, childOption.desc))
      end
    end
    return tconcat(desc, "\n")
  end
end

local function descArray(option, array, index, phrase)
  local desc, values, isConflict = {phrase}, {}, false
  local initialValue = nil
  for id, optionData in pairs(option.references) do
    local childOption = optionData.options[optionData.index]
    values[id] = tostring(childOption[array][index])
    if initialValue == nil then
      initialValue = values[id]
    elseif values[id] ~= initialValue then
      isConflict = true
    end
  end
  if isConflict then
    for id, value in pairs(values) do
      tinsert(desc, ("%s - %s"):format(id,  value))
    end
  end
  return tconcat(desc, "\n")
end

-- getters for AceConfig
local function get(option, key)
  return function()
    return option[key]
  end
end

local function getUser(option)
  return function()
    local value
    for _, optionData in pairs(option.references) do
      if not optionData.config then
        return
      elseif value == nil then
        value = optionData.config[option.key]
      elseif neq(value, optionData.config[option.key]) then
        return
      end
    end
    return value
  end
end

local function getStr(option, key)
  return function()
    local str = option[key] or ""
    return str:gsub("|", "||")
  end
end

local function getNumAsString(option, key)
  return function()
    if option[key] ~= nil then
      return tostring(option[key])
    end
  end
end

local function getUserNumAsString(option)
  return function()
    local value
    for id, optionData in pairs(option.references) do
      if value == nil then
        value = optionData.config[option.key]
      elseif neq(value, optionData.config[option.key]) then
        return ""
      end
    end
    if value ~= nil then
      return tostring(value)
    end
  end
end

local function getValues(option)
  local values = {}
  local firstChild = true
  for _, optionData in pairs(option.references) do
    local childOption = optionData.options[optionData.index]
    local childValues = childOption.values
    local i = 1
    while i <= #values or i <= #childValues do
      if firstChild then
        values[i] = childValues[i]
      elseif values[i] ~= childValues[i] then
        values[i] = conflict
      end
      i = i + 1
    end
    firstChild = false
  end
  return values
end

local function getUserValues(option)
  local values = getValues(option)
  for i, v in ipairs(values) do
    if v == conflict then
      values[i] = conflictBlue .. L["Value %i"]:format(i)
    end
  end
  return values
end

local function getColor(option, key)
  return function()
    if option[key] then
      return unpack(option[key])
    end
  end
end

local function getUserColor(option)
  return function()
    local firstValue
    for id, optionData in pairs(option.references) do
      local childConfig = optionData.config
      if firstValue == nil then
        firstValue = childConfig[option.key]
      elseif neq(firstValue, childConfig[option.key]) then
        return
      end
      if firstValue then
        return unpack(firstValue)
      end
    end
  end
end

local function getArrayStr(option, array, index)
  return function()
    if option[array][index] then
      return option[array][index]:gsub("|","||")
    else
      return ""
    end
  end
end

-- setters for AceConfig
local function set(data, option, key)
  return function(_, value)
    for _, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      local childData = optionData.data
      childOption[key] = value
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function setUser(data, option)
  return function(_, value)
    for _, optionData in pairs(option.references) do
      local childData = optionData.data
      local childConfig = optionData.config
      childConfig[option.key] = value
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function setStr(data, option, key)
  return function(_, value)
    value = value:gsub("||", "|")
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      local childData = optionData.data
      childOption[key] = value
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function setNum(data, option, key, required)
  return function(_, value)
    if value ~= "" then
      local num = tonumber(value)
      if not num or math.abs(num) == math.huge or tostring(num) == "nan" then
        return
      end
      for id, optionData in pairs(option.references) do
        local childOption = optionData.options[optionData.index]
        local childData = optionData.data
        childOption[key] = num
        WeakAuras.Add(childData)
      end
    elseif not required then
      for id, optionData in pairs(option.references) do
        local childOption = optionData.options[optionData.index]
        local childData = optionData.data
        childOption[key] = nil
        WeakAuras.Add(childData)
      end
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function setUserNum(data, option)
  return function(_, value)
    if value ~= "" then
      local num = tonumber(value)
      if not num or math.abs(num) == math.huge or tostring(num) == "nan" then return end
      for _, optionData in pairs(option.references) do
        local childData = optionData.data
        local childConfig = optionData.config
        childConfig[option.key] = num
        WeakAuras.Add(childData)
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end
  end
end

local function setColor(data, option, key)
  return function(_, r, g, b, a)
    local color = {r, g, b, a}
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      local childData = optionData.data
      childOption[key] = color
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function setUserColor(data, option)
  return function(_, r, g, b, a)
    local color = {r, g, b, a}
    for id, optionData in pairs(option.references) do
      local childData = optionData.data
      local childConfig = optionData.config
      childConfig[option.key] = color
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function setSelectDefault(data, option, key)
  return function(_, value)
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      local childData = optionData.data
      childOption.default = min(value, #childOption.values)
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function setArrayStr(data, option, array, index)
  return function(_, value)
    value = value:gsub("||","|")
    for id, optionData in pairs(option.references) do
      local childOption = optionData.options[optionData.index]
      local childData = optionData.data
      childOption[array][index] = value
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function ensureUniqueKey(candidate, suffix, options, index)
  index = index or 1
  local goodKey = true
  local key = candidate
  local existingKeys = {}
  for _, option in ipairs(options) do
    if option.key then
      if option.key == key then
        goodKey = false
      end
      existingKeys[option.key] = true
    end
  end
  if not goodKey then
    local prefix = candidate .. suffix
    while not goodKey do
      key = prefix .. index
      goodKey = not existingKeys[key]
      index = index + 1
    end
  end
  return key
end

local function generateKey(prefix, options, index)
  return ensureUniqueKey(prefix, "", options, index)
end

local typeControlAdders, addAuthorModeOption
typeControlAdders = {
  toggle = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "default"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = name(option, "default", L["Default"]),
      desc = desc(option, "default"),
      order = order(),
      values = OptionsPrivate.Private.bool_types,
      get = function()
        if option.default == nil then
          return
        end
        return option.default and 1 or 0
      end,
      set = function(_, value)
        local val = value == 1
        for id, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.default = val
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
  end,
  input = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "default"] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = name(option, "default", L["Default"]),
      desc = desc(option, "default"),
      order = order(),
      get = get(option, "default"),
      set = set(data, option, "default")
    }
    args[prefix .. "useLength"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = name(option, "useLength", L["Max Length"]),
      desc = desc(option, "useLength"),
      order = order(),
      get = get(option, "useLength"),
      set = set(data, option, "useLength")
    }
    args[prefix .. "length"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = name(option, "length", L["Length"]),
      desc = desc(option, "length"),
      order = order(),
      min = 1,
      step = 1,
      softMax = 20,
      get = get(option, "length"),
      set = set(data, option, "length"),
      disabled = function()
        return not option.useLength
      end
    }
    args[prefix .. "multiline"] = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = name(option, "multiline", L["Large Input"]),
      desc = desc(option, "multiline", L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."]),
      order = order(),
      get = get(option, "multiline"),
      set = set(data, option, "multiline"),
    }
  end,
  number = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "default"] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = name(option, "default", L["Default"]),
      desc = desc(option, "default"),
      order = order(),
      get = getNumAsString(option, "default"),
      set = setNum(data, option, "default", true)
    }
    args[prefix .. "min"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "min", L["Min"]),
      desc = desc(option, "min"),
      order = order(),
      get = getNumAsString(option, "min"),
      set = setNum(data, option, "min")
    }
    args[prefix .. "max"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "max", L["Max"]),
      desc = desc(option, "min"),
      order = order(),
      get = getNumAsString(option, "max"),
      set = setNum(data, option, "max")
    }
    args[prefix .. "step"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "step", L["Step Size"]),
      desc = desc(option, "step"),
      order = order(),
      get = getNumAsString(option, "step"),
      set = setNum(data, option, "step")
    }
  end,
  range = function(options, args, data, order, prefix, i)
    local option = options[i]
    local min, max, softMin, softMax, step, bigStep
    softMax = option.softMax
    softMin = option.softMin
    bigStep = option.bigStep
    min = option.min
    max = option.max
    local effectiveMin = softMin or min or 0
    local effectiveMax = softMax or max or 100
    if (effectiveMin > effectiveMax) then
      -- This will cause a error inside the slider
      -- Fix up either softMax or max, depending on which one is the effective one
      if softMax then
        softMax = effectiveMin
      elseif max then
        max = effectiveMin
      else
        softMax = effectiveMin
      end
    end
    step = option.step
    args[prefix .. "default"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = name(option, "default", L["Default"]),
      desc = desc(option, "default"),
      order = order(),
      get = get(option, "default"),
      set = set(data, option, "default"),
      min = min,
      max = max,
      step = step,
      softMin = softMin,
      softMax = softMax,
      bigStep = bigStep,
    }

    args[prefix .. "min"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "min", L["Min"]),
      desc = desc(option, "min"),
      order = order(),
      get = getNumAsString(option, "min"),
      set = setNum(data, option, "min")
    }

    args[prefix .. "max"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "max", L["Max"]),
      desc = desc(option, "max"),
      order = order(),
      get = getNumAsString(option, "max"),
      set = setNum(data, option, "max")
    }

    args[prefix .. "step"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "step", L["Step Size"]),
      desc = desc(option, "step"),
      order = order(),
      get = getNumAsString(option, "step"),
      set = setNum(data, option, "step")
    }

    args[prefix .. "softmin"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "softMin", L["Soft Min"]),
      desc = desc(option, "softMin"),
      order = order(),
      get = getNumAsString(option, "softMin"),
      set = setNum(data, option, "softMin")
    }

    args[prefix .. "softmax"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "softMax", L["Soft Max"]),
      desc = desc(option, "softMax"),
      order = order(),
      get = getNumAsString(option, "softMax"),
      set = setNum(data, option, "softMax")
    }

    args[prefix .. "bigstep"] = {
      type = "input",
      width = WeakAuras.normalWidth * 2 / 3,
      name = name(option, "bigStep", L["Slider Step Size"]),
      desc = desc(option, "bigStep"),
      order = order(),
      get = getNumAsString(option, "bigStep"),
      set = setNum(data, option, "bigStep")
    }
  end,
  description = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "key"] = nil
    args[prefix .. "name"] = nil
    args[prefix .. "fontsize"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = name(option, "fontSize", L["Font Size"]),
      desc = desc(option, "fontSize"),
      order = order(),
      values = OptionsPrivate.Private.font_sizes,
      get = get(option, "fontSize"),
      set = set(data, option, "fontSize")
    }
    args[prefix .. "descinput"] = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = name(option, "text", L["Description Text"]),
      desc = desc(option, "text"),
      order = order(),
      multiline = true,
      get = getStr(option, "text"),
      set = setStr(data, option, "text")
    }
  end,
  color = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "default"] = {
      type = "color",
      width = WeakAuras.normalWidth,
      hasAlpha = true,
      name = name(option, "default", L["Default"]),
      desc = descColor(option, "default"),
      order = order(),
      get = getColor(option, "default"),
      set = setColor(data, option, "default")
    }
  end,
  select = function(options, args, data, order, prefix, i)
    local option = options[i]
    local values = getValues(option)
    local defaultValues = {}
    for i, v in ipairs(values) do
      if v == conflict then
        defaultValues[i] = conflictBlue .. L["Value %i"]:format(i)
      else
        defaultValues[i] = v
      end
    end
    args[prefix .. "default"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = name(option, "default", L["Default"]),
      desc = desc(option, "default"),
      order = order(),
      values = defaultValues,
      get = get(option, "default"),
      set = setSelectDefault(data, option)
    }
    for j, value in ipairs(values) do
      args[prefix .. "space" .. j] = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Value %i"]:format(j),
        order = order(),
        disabled = function()
          return true
        end,
        get = function()
          return true
        end,
        set = function()
        end
      }
      args[prefix .. "value" .. j] = {
        type = "input",
        width = WeakAuras.normalWidth - 0.15,
        name = (value == conflict and conflictBlue or "") .. L["Value %i"]:format(j),
        desc = descSelect(option, j),
        order = order(),
        get = function()
          if value ~= conflict then
            return value:gsub("|", "||")
          end
        end,
        set = function(_, value)
          value = value:gsub("||", "|")
          for id, optionData in pairs(option.references) do
            local childOption = optionData.options[optionData.index]
            local childData = optionData.data
            local insertPoint = math.min(j, #childOption.values + 1)
            if value == "" then
              tremove(childOption.values, insertPoint)
            else
              childOption.values[insertPoint] = value
            end
            WeakAuras.Add(childData)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end
      }
      args[prefix .. "valdelete" .. j] = {
        type = "execute",
        width = 0.15,
        name = L["Delete"],
        order = order(),
        func = function()
          for id, optionData in pairs(option.references) do
            local childOption = optionData.options[optionData.index]
            local childData = optionData.data
            tremove(childOption.values, j)
            WeakAuras.Add(childData)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\delete",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon"
      }
    end
    args[prefix .. "newvaluespace"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["New Value"],
      order = order(),
      disabled = function()
        return true
      end,
      get = function()
        return true
      end,
      set = function()
      end
    }
    args[prefix .. "newvalue"] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["New Value"],
      order = order(),
      get = function()
        return ""
      end,
      set = function(_, value)
        value = value:gsub("||", "|")
        for id, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.values[#childOption.values + 1] = value
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
  end,
  space = function(options, args, data, order, prefix, i)
    local option = options[i]
    -- this option should be just useWidth but no need to do a migration in the data just for that.
    args[prefix .. "variableWidth"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      order = order(),
      name = name(option, "variableWidth", L["Width"]),
      desc = desc(
        option,
        "variableWidth",
        L["If unchecked, then this space will fill the entire line it is on in User Mode."]
      ),
      get = get(option, "variableWidth"),
      set = set(data, option, "variableWidth")
    }
    args[prefix .. "widthSpace"] = nil

    local widthOption = args[prefix .. "width"]
    widthOption.name = name(option, "width", L["Width"])
    widthOption.disabled = function()
      return not option.variableWidth
    end
    widthOption.order = order()

    args[prefix .. "useHeight"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      order = order(),
      name = name(option, "useHeight", L["Height"]),
      desc = desc(option, "useHeight", L["If checked, then this space will span across multiple lines."]),
      get = get(option, "useHeight"),
      set = set(data, option, "useHeight")
    }

    args[prefix .. "height"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = order(),
      name = name(option, "height", L["Height"]),
      desc = desc(option, "height"),
      get = get(option, "height"),
      set = set(data, option, "height"),
      disabled = function()
        return not option.useHeight
      end,
      min = 1,
      softMax = 10,
      step = 1
    }
  end,
  media = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "mediaType"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = name(option, "mediaType", L["Media Type"]),
      desc = desc(option, "mediaType"),
      values = OptionsPrivate.Private.shared_media_types,
      order = order(),
      get = get(option, "mediaType"),
      set = function(_, value)
        for _, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.mediaType = value
          childOption.default = OptionsPrivate.Private.author_option_media_defaults[value]
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
    args[prefix .. "default"] = {
      type = "select",
      width = WeakAuras.doubleWidth,
      name = name(option, "default", L["Default"]),
      desc = desc(option, "default"),
      values = function()
        if option.mediaType == "sound" then
          return OptionsPrivate.Private.sound_file_types
        else
          return AceGUIWidgetLSMlists[option.mediaType]
        end
      end,
      sorting = function()
        if option.mediaType == "sound" then
          return OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.sound_file_types)
        else
          return nil
        end
      end,
      dialogControl = OptionsPrivate.Private.author_option_media_controls[option.mediaType],
      itemControl = OptionsPrivate.Private.author_option_media_itemControls[option.mediaType],
      order = order(),
      get = get(option, "default"),
      set = function(_, value)
        if option.mediaType == "sound" then
          -- do this outside the deref loop, so we don't play the sound a million times
          PlaySoundFile(value, "Master")
        end
        for _, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.default = value
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
  end,
  multiselect = function(options, args, data, order, prefix, i)
    local option = options[i]
    local values = getValues(option)
    local defaultValues = {}
    for i, v in ipairs(values) do
      if v == conflict then
        defaultValues[i] = conflictBlue .. L["Value %i"]:format(i)
      else
        defaultValues[i] = v
      end
    end
    args[prefix .. "default"] = {
      type = "multiselect",
      width = WeakAuras.normalWidth * 0.9,
      name = L["Default"],
      order = order(),
      values = defaultValues,
      get = function(_, k)
        return option.default and option.default[k]
      end,
      set = function(_, k, v)
        for id, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.default[k] = v
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
    for j, value in ipairs(values) do
      args[prefix .. "space" .. j] = {
        type = "toggle",
        width = WeakAuras.normalWidth,
        name = L["Value %i"]:format(j),
        order = order(),
        disabled = function()
          return true
        end,
        get = function()
          return true
        end,
        set = function()
        end
      }
      args[prefix .. "value" .. j] = {
        type = "input",
        width = WeakAuras.normalWidth - 0.15,
        name = (value == conflict and conflictBlue or "") .. L["Value %i"]:format(j),
        desc = descSelect(option, j),
        order = order(),
        get = function()
          if value ~= conflict then
            return value:gsub("|", "||")
          end
        end,
        set = function(_, value)
          value = value:gsub("||", "|")
          for id, optionData in pairs(option.references) do
            local childOption = optionData.options[optionData.index]
            local childData = optionData.data
            local insertPoint = math.min(j, #childOption.values + 1)
            if value == "" then
              tremove(childOption.values, insertPoint)
              tremove(childOption.default, insertPoint)
            else
              childOption.values[insertPoint] = value
            end
            WeakAuras.Add(childData)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end
      }
      args[prefix .. "valdelete" .. j] = {
        type = "execute",
        width = 0.15,
        name = "",
        order = order(),
        func = function()
          for id, optionData in pairs(option.references) do
            local childOption = optionData.options[optionData.index]
            local childData = optionData.data
            tremove(childOption.values, j)
            tremove(childOption.default, j)
            WeakAuras.Add(childData)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\delete",
        imageWidth = 24,
        imageHeight = 24
      }
    end
    args[prefix .. "newvaluespace"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["New Value"],
      order = order(),
      disabled = function()
        return true
      end,
      get = function()
        return true
      end,
      set = function()
      end
    }
    args[prefix .. "newvalue"] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["New Value"],
      order = order(),
      get = function()
        return ""
      end,
      set = function(_, value)
        value = value:gsub("||", "|")
        for id, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.values[#childOption.values + 1] = value
          childOption.default[#childOption.default + 1] = false
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
  end,
  header = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "width"] = nil
    args[prefix .. "useName"] = {
      type = "toggle",
      name = name(option, "useName", L["Separator text"]),
      desc = desc(
        option,
        "useName",
        L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."]
      ),
      order = order(),
      width = WeakAuras.normalWidth,
      get = get(option, "useName"),
      set = set(data, option, "useName")
    }
    args[prefix .. "text"] = {
      type = "input",
      name = name(option, "text", L["Separator Text"]),
      desc = desc(option, "text"),
      order = order(),
      width = WeakAuras.normalWidth,
      get = getStr(option, "text"),
      set = setStr(data, option, "text"),
      disabled = function()
        return not option.useName
      end
    }
  end,
  group = function(options, args, data, order, prefix, i)
    local option = options[i]
    args[prefix .. "width"] = nil
    args[prefix .. "groupType"] = {
      type = "select",
      name = name(option, "groupType", L["Group Type"]),
      order = order(),
      width = WeakAuras.doubleWidth,
      values = OptionsPrivate.Private.group_option_types,
      get = get(option, "groupType"),
      set = function(_, value)
        for id, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.groupType = value
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
    args[prefix .. "useCollapse"] = {
      type = "toggle",
      name = name(option, "useCollapse", L["Collapsible Group"]),
      desc = desc(option, "useCollapse", L["If checked, then this option group can be temporarily collapsed by the user."]),
      order = order(),
      width = WeakAuras.normalWidth,
      get = get(option, "useCollapse"),
      set = set(data, option, "useCollapse"),
    }
    args[prefix .. "collapseDefault"] = {
      type = "toggle",
      name = name(option, "collapse", L["Start Collapsed"]),
      desc = desc(option, "collapse", L["If checked, then this option group will start collapsed."]),
      order = order(),
      width = WeakAuras.normalWidth,
      get = get(option, "collapse"),
      set = function(_, value)
        for id, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          childOption.collapse = value
          OptionsPrivate.SetCollapsed(id, "config", optionData.path, value)
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end,
      disabled = function() return not option.useCollapse end
    }
    args[prefix .. "noMerge"] = {
      type = "toggle",
      name = WeakAuras.newFeatureString .. name(option, "noMerge", L["Prevent Merging"]),
      desc = desc(option, "noMerge", L["If checked, then this group will not merge with other group when selecting multiple auras."]),
      order = order(),
      width = option.groupType =="simple" and WeakAuras.doubleWidth or WeakAuras.normalWidth,
      get = get(option, "noMerge"),
      set = set(data, option, "noMerge"),
    }
    if option.groupType ~="simple" then
      args[prefix .. "sortAlphabetically"] = {
        type = "toggle",
        name = WeakAuras.newFeatureString .. name(option, "sortAlphabetically", L["Sort"]),
        desc = desc(option, "sortAlphabetically", L["If checked, then the combo box in the User settings will be sorted."]),
        order = order(),
        width = WeakAuras.normalWidth,
        get = get(option, "sortAlphabetically"),
        set = set(data, option, "sortAlphabetically"),
      }
    end
    if option.groupType ~="simple" then
      args[prefix .. "limitType"] = {
        type = "select",
        name = name(option, "limitType", L["Number of Entries"]),
        desc = desc(option, "limitType", L["Determines how many entries can be in the table."]),
        order = order(),
        width = WeakAuras.normalWidth,
        values = OptionsPrivate.Private.group_limit_types,
        get = get(option, "limitType"),
        set = function(_, value)
          for id, optionData in pairs(option.references) do
            local childOption = optionData.options[optionData.index]
            local childData = optionData.data
            if childOption.limitType == "fixed" and childOption.nameSource == -1 and value ~= "fixed" then
              childOption.entryNames = nil
              childOption.nameSource = 0
            end
            childOption.limitType = value
            WeakAuras.Add(childData)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end,
      }
      args[prefix .. "size"] = {
        type = "range",
        control = "WeakAurasSpinBox",
        name = name(option, "limitType", option.limitType == "max" and L["Entry limit"] or L["Number of Entries"]),
        desc = desc(option, "limitType"),
        order = order(),
        width = WeakAuras.normalWidth,
        min = 1, -- no point in a table with no entries
        softMax = 20, -- 20 people in a mythic raid group
        step = 1,
        get = get(option, "size"),
        set = function(_, value)
          for id, optionData in pairs(option.references) do
            local childOption = optionData.options[optionData.index]
            local childData = optionData.data
            if childOption.nameSource == -1 then
              if value < childOption.size then
                for i = value + 1, childOption.size do
                  childOption.entryNames[i] = nil
                end
              else
                for i = childOption.size + 1, value do
                  childOption.entryNames[i] = L["Entry %i"]:format(i)
                end
              end
            end
            childOption.size = value
            WeakAuras.Add(childData)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end,
        disabled = function() return option.limitType == "none" end,
      }
      args[prefix .. "hideReorder"] = {
        type = "toggle",
        name = name(option, "hideReorder", L["Disallow Entry Reordering"]),
        desc = desc(option, "hideReorder"),
        order = order(),
        width = WeakAuras.normalWidth,
        get = function()
          return option.hideReorder or option.nameSource == -1
        end,
        set = set(data, option, "hideReorder"),
        disabled = function()
          return option.nameSource == -1
        end,
      }
      local nameSources = CopyTable(OptionsPrivate.Private.array_entry_name_types)
      local validNameSourceTypes = OptionsPrivate.Private.name_source_option_types
      if option.limitType ~= "fixed" then
        nameSources[-1] = nil
      end
      for subIndex, subOption in ipairs(option.subOptions) do
        if validNameSourceTypes[subOption.type] then
          local allShareThisOption = true
          for id in pairs(option.references) do
            if not subOption.references[id] then
              allShareThisOption = false
              break
            end
          end
          if allShareThisOption then
            nameSources[subIndex] = subOption.key
          end
        end
      end
      args[prefix .. "nameSource"] = {
        type = "select",
        name = name(option, "nameSource", L["Entry Name Source"]),
        desc = desc(option, "nameSource"),
        order = order(),
        values = nameSources,
        width = WeakAuras.doubleWidth,
        get = function()
          return option.nameSource or 0
        end,
        set = function(_, value)
          for id, optionData in pairs(option.references) do
            local childOption = optionData.options[optionData.index]
            local childData = optionData.data
            if (value == -1) ~= (childOption.nameSource == -1) then
              if value == -1 then
                local entryNames = {}
                for i = 1, childOption.size do
                  entryNames[i] = L["Entry %i"]:format(i)
                end
                childOption.entryNames = entryNames
              else
                childOption.entryNames = nil
              end
            end
            if value > 0 then
              childOption.nameSource = option.subOptions[value].references[id].index
            else
              childOption.nameSource = value
            end
            WeakAuras.Add(childData)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end,
      }
      if option.nameSource == -1 then
        for i = 1, option.size do
          args[prefix .. "entry" .. i .. "name"] = {
            type = "input",
            name = nameArray(option, "entryNames", i, L["Entry %i"]:format(i)),
            desc = descArray(option, "entryNames", i),
            order = order(),
            width = WeakAuras.doubleWidth,
            get = getArrayStr(option, "entryNames", i),
            set = setArrayStr(data, option, "entryNames", i),
          }
        end
      end
    end
    args[prefix .. "groupStart"] = {
      type = "header",
      name = L["Start of %s"]:format(option.name),
      order = order()
    }
    local subPrefix = prefix .. "option"
    for subIndex, subOption in ipairs(option.subOptions) do
      local addControlsForType = typeControlAdders[subOption.type]
      if addControlsForType then
        addAuthorModeOption(option.subOptions, args, data, order, subPrefix .. subIndex, subIndex)
      end
    end
    args[prefix .. "addSubOption"] = {
      type = "execute",
      name = L["Add Sub Option"],
      order = order(),
      width = WeakAuras.normalWidth,
      func = function()
        for id, optionData in pairs(option.references) do
          local childOption = optionData.options[optionData.index]
          local childData = optionData.data
          local path = optionData.path
          local j = #childOption.subOptions + 1
          path[#path + 1] = j
          childOption.subOptions[j] = {
            type = "toggle",
            key = generateKey("subOption", childOption.subOptions, j),
            name = L["Sub Option %i"]:format(j),
            default = false,
            width = 1,
            useDesc = false,
          }
          OptionsPrivate.SetCollapsed(id, "author", path, false)
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
    args[prefix .. "groupEnd"] = {
      type = "header",
      name = L["End of %s"]:format(option.name),
      order = order()
    }
  end
}

local function up(data, options, index)
  local option = options[index]
  return function()
    for id, optionData in pairs(option.references) do
      if optionData.path[#optionData.path] <= 1 then
        return true
      end
    end
  end, function()
    for id, optionData in pairs(option.references) do
      -- move the option up in the subOptions
      local path = optionData.path
      local optionID = optionData.index
      local childData = optionData.data
      local childOptions = optionData.options
      local parent = optionData.parent
      if parent and parent.groupType == "array" then
        local dereferencedParent = parent.references[id].options[parent.references[id].index]
        if dereferencedParent.nameSource == optionID then
          dereferencedParent.nameSource = optionID - 1
        elseif dereferencedParent.nameSource == optionID - 1 then
          dereferencedParent.nameSource = optionID
        end
      end
      OptionsPrivate.MoveCollapseDataUp(id, "author", path)
      childOptions[optionID], childOptions[optionID - 1] = childOptions[optionID - 1], childOptions[optionID]
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function down(data, options, index)
  local option = options[index]
  return function()
    for id, optionData in pairs(option.references) do
      if optionData.path[#optionData.path] >= #optionData.options then
        return true
      end
    end
  end, function()
    for id, optionData in pairs(option.references) do
      -- move the option down in the subOptions
      local path = optionData.path
      local optionID = optionData.index
      local childData = optionData.data
      local parent = optionData.parent
      if parent and parent.groupType == "array" then
        local dereferencedParent = parent.references[id].options[parent.references[id].index]
        if dereferencedParent.nameSource == optionID then
          dereferencedParent.nameSource = optionID + 1
        elseif dereferencedParent.nameSource == optionID + 1 then
          dereferencedParent.nameSource = optionID
        end
      end
      local childOptions = optionData.options
      OptionsPrivate.MoveCollapseDataDown(id, "author", path)
      childOptions[optionID], childOptions[optionID + 1] = childOptions[optionID + 1], childOptions[optionID]
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function duplicate(data, options, index)
  local option = options[index]
  return function()
    for id, optionData in pairs(option.references) do
      local optionID = optionData.index
      local childOptions = optionData.options
      local childData = optionData.data
      local path = optionData.path
      path[#path] = path[#path] + 1 -- this data is being regenerated very soon
      OptionsPrivate.InsertCollapsed(id, "author", optionData.path, false)
      local newOption = CopyTable(childOptions[optionID])
      if newOption.key then
        local existingKeys = {}
        for _, option in ipairs(childOptions) do
          if option.key then
            existingKeys[option.key] = true
          end
        end
        while existingKeys[newOption.key] do
          newOption.key = generateKey(newOption.key .. "copy", childOptions, 1)
        end
      end
      if newOption.name then
        newOption.name = newOption.name .. " - " .. L["Copy"]
      end
      tinsert(childOptions, optionID + 1, newOption)
      WeakAuras.Add(childData)
    end
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end

local function validateNonDuplicateKey(option)
  -- note: this has some unintuitive behavior
  -- e.g. if aura A has option keys "foo", "bar"
  -- and aura B has option keys "foo", "baz",
  -- then you still cannot change the merged option with key "foo" to "bar"
  -- unless you unselect aura A, even though aura B would be fine with that.
  return function(_, newKey)
    for id, optionData in pairs(option.references) do
      for index, otherOption in ipairs(optionData.options) do
        if index ~= optionData.index and otherOption.key == newKey then
          return L["%s - Option #%i has the key %s. Please choose a different option key."]:format(id, index, newKey)
        end
      end
    end
    return true
  end
end

function addAuthorModeOption(options, args, data, order, prefix, i)
  -- add header controls
  local option = options[i]

  local collapsed = false
  for id, optionData in pairs(option.references) do
    if OptionsPrivate.IsCollapsed(id, "author", optionData.path, true) then
      collapsed = true
      break
    end
  end

  local _, optionData = next(option.references)
  local isInGroup = optionData.parent ~= nil
  local buttonWidth = 0.6
  if isInGroup then
    buttonWidth = buttonWidth + 0.3
  end

  local optionBelow = options[i + 1]
  local isAboveGroup = optionBelow and OptionsPrivate.Private.author_option_classes[optionBelow.type] == "group"
  if isAboveGroup then
    buttonWidth = buttonWidth + 0.15
  end

  local optionAbove = options[i - 1]
  local isBelowGroup = optionAbove and OptionsPrivate.Private.author_option_classes[optionAbove.type] == "group"
  if isBelowGroup then
    buttonWidth = buttonWidth + 0.15
  end
  local optionClass = OptionsPrivate.Private.author_option_classes[option.type]
  local optionName = optionClass == "noninteractive" and OptionsPrivate.Private.author_option_types[option.type]
                     or option.name

  args[prefix .. "collapse"] = {
    type = "execute",
    name = nameHead(data, option, optionName),
    order = order(),
    width = WeakAuras.doubleWidth - buttonWidth,
    func = function()
      for id, optionData in pairs(option.references) do
        OptionsPrivate.SetCollapsed(id, "author", optionData.path, not collapsed)
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end,
    image = collapsed and "Interface\\AddOns\\WeakAuras\\Media\\Textures\\expand" or
      "Interface\\AddOns\\WeakAuras\\Media\\Textures\\collapse",
    imageWidth = 18,
    imageHeight = 18,
    control = "WeakAurasExpand"
  }

  args[prefix .. "upAndIn"] = {
    type = "execute",
    width = 0.15,
    name = L["Move Into Above Group"],
    order = order(),
    hidden = function() return not isBelowGroup end,
    func = function()
      for id, optionData in pairs(option.references) do
        local groupData = optionAbove.references[id]
        if groupData then
          local childGroup = groupData.options[groupData.index]
          local childCollapsed = OptionsPrivate.IsCollapsed(id, "author", optionData.path, true)
          OptionsPrivate.RemoveCollapsed(id, "author", optionData.path)
          local newPath = groupData.path
          tinsert(newPath, #childGroup.subOptions + 1)
          OptionsPrivate.InsertCollapsed(id, "author", newPath, childCollapsed)
          local childOption = tremove(optionData.options, optionData.index)
          childOption.key = ensureUniqueKey(childOption.key, "In", childGroup.subOptions)
          local childData = optionData.data
          tinsert(childGroup.subOptions, childOption)
          WeakAuras.Add(childData)
        end
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\upright",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }
  args[prefix .. "downAndIn"] = {
    type = "execute",
    width = 0.15,
    name = L["Move Into Below Group"],
    order = order(),
    hidden = function() return not isAboveGroup end,
    func = function()
      for id, optionData in pairs(option.references) do
        local groupData = optionBelow.references[id]
        if groupData then
          local childGroup = groupData.options[groupData.index]
          local childCollapsed = OptionsPrivate.IsCollapsed(id, "author", optionData.path, true)
          OptionsPrivate.RemoveCollapsed(id, "author", optionData.path)
          local newPath = groupData.path
          tinsert(newPath, 1)
          OptionsPrivate.InsertCollapsed(id, "author", newPath, childCollapsed)
          local childOption = tremove(optionData.options, optionData.index)
          childOption.key = ensureUniqueKey(childOption.key, "In", childGroup.subOptions)
          local childData = optionData.data
          tinsert(childGroup.subOptions, 1, childOption)
          WeakAuras.Add(childData)
        end
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\downright",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }

  args[prefix .. "upAndOut"] = {
    type = "execute",
    width = 0.15,
    name = L["Move Above Group"],
    order = order(),
    hidden = function() return not isInGroup end,
    func = function()
      for id, optionData in pairs(option.references) do
        local path = optionData.path
        local parent = optionData.parent
        local parentOptions = parent and parent.references[id].options or optionData.data.authorOptions
        local childOption = tremove(optionData.options, optionData.index)
        if parent and parent.groupType == "array" then
          local dereferencedParent = parent.references[id].options[parent.references[id].index]
          if dereferencedParent.nameSource == optionData.index then
            dereferencedParent.nameSource = 0
          elseif dereferencedParent.nameSource > optionData.index then
            dereferencedParent.nameSource = dereferencedParent.nameSource - 1
          end
        end
        OptionsPrivate.RemoveCollapsed(id, "author", optionData.path)
        childOption.key = ensureUniqueKey(childOption.key, "Out", parentOptions)
        tinsert(parentOptions, path[#path - 1], childOption)
        path[#path] = nil
        OptionsPrivate.InsertCollapsed(id, "author", path)
        WeakAuras.Add(optionData.data)
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\upleft",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }
  args[prefix .. "downAndOut"] = {
    type = "execute",
    width = 0.15,
    name = L["Move Below Group"],
    order = order(),
    hidden = function() return not isInGroup end,
    func = function()
      for id, optionData in pairs(option.references) do
        local path = optionData.path
        local parent = optionData.parent
        local parentOptions = parent and parent.references[id].options or optionData.data.authorOptions
        local childOption = tremove(optionData.options, optionData.index)
        if parent and parent.groupType == "array" then
          local dereferencedParent = parent.references[id].options[parent.references[id].index]
          if dereferencedParent.nameSource == optionData.index then
            dereferencedParent.nameSource = 0
          elseif dereferencedParent.nameSource > optionData.index then
            dereferencedParent.nameSource = dereferencedParent.nameSource - 1
          end
        end
        OptionsPrivate.RemoveCollapsed(id, "author", optionData.path)
        childOption.key = ensureUniqueKey(childOption.key, "Out", parentOptions)
        tinsert(parentOptions, path[#path - 1] + 1, childOption)
        path[#path] = nil
        path[#path] = path[#path] + 1
        OptionsPrivate.InsertCollapsed(id, "author", path)
        WeakAuras.Add(optionData.data)
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\downleft",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }
  local upDisable, upFunc = up(data, options, i)
  args[prefix .. "up"] = {
    type = "execute",
    width = 0.15,
    name = L["Move Up"],
    order = order(),
    disabled = upDisable,
    func = upFunc,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\moveup",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }

  local downDisable, downFunc = down(data, options, i)
  args[prefix .. "down"] = {
    type = "execute",
    width = 0.15,
    name = L["Move Down"],
    order = order(),
    disabled = downDisable,
    func = downFunc,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\movedown",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }

  args[prefix .. "duplicate"] = {
    type = "execute",
    width = 0.15,
    name = L["Duplicate"],
    order = order(),
    func = duplicate(data, options, i),
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\duplicate",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }

  args[prefix .. "delete"] = {
    type = "execute",
    width = 0.15,
    name = L["Delete"],
    order = order(),
    func = function()
      for id, optionData in pairs(option.references) do
        local childOptions = optionData.options
        local optionIndex = optionData.index
        local childData = optionData.data
        local parent = optionData.parent
        OptionsPrivate.RemoveCollapsed(id, "author", optionData.path)
        tremove(childOptions, optionIndex)
        if parent and parent.groupType == "array" then
          local dereferencedParent = parent.references[id].options[parent.references[id].index]
          if dereferencedParent.nameSource == optionData.index then
            dereferencedParent.nameSource = 0
          elseif dereferencedParent.nameSource > optionData.index then
            dereferencedParent.nameSource = dereferencedParent.nameSource - 1
          end
        end
        WeakAuras.Add(childData)
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\delete",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  }

  if collapsed then return end

  args[prefix .. "type"] = {
    type = "select",
    width = WeakAuras.doubleWidth,
    name = L["Option Type"],
    desc = descType(option),
    order = order(),
    values = OptionsPrivate.Private.author_option_types,
    get = get(option, "type"),
    set = function(_, value)
      if value == option.type then
        return
      end
      local author_option_fields = OptionsPrivate.Private.author_option_fields
      local commonFields, newFields = author_option_fields.common, author_option_fields[value]
      local newClass = OptionsPrivate.Private.author_option_classes[value]
      for id, optionData in pairs(option.references) do
        local childOption = optionData.options[optionData.index]
        local childData = optionData.data
        local parentOption = optionData.parent
        for k in pairs(childOption) do
          if not commonFields[k] then
            childOption[k] = nil
          end
        end
        for k, v in pairs(newFields) do
          if type(v) == "table" then
            childOption[k] = CopyTable(v)
          else
            childOption[k] = v
          end
        end
        childOption.type = value
        if newClass == "noninteractive" then
          childOption.name = nil
          childOption.desc = nil
          childOption.key = nil
          childOption.useDesc = nil
          childOption.default = nil
        else
          -- don't use the option index here if switching from a noninteractive type
          -- mostly because it would have a very non-intuitive effect
          -- the names and keys would likely not match anymore, and so
          -- the merged display would basically explode into a bunch of separate options
          childOption.name = childOption.name or (L["Option %i"]):format(i)
          if not childOption.key then
            local newKey = "option" .. i
            local existingKeys = {}
            for index, option in pairs(optionData.options) do
              if index ~= optionData.index and option.key then
                existingKeys[option.key] = true
              end
            end
            while existingKeys[newKey] do
              newKey = newKey .. "copy"
            end
            childOption.key = newKey
          end
        end
        if parentOption and parentOption.groupType == "array" and not OptionsPrivate.Private.array_entry_name_types[value] then
          local dereferencedParent = parentOption.references[id]
          if dereferencedParent.nameSource == optionData.index then
            dereferencedParent.nameSource = 0
          end
        end
        WeakAuras.Add(childData)
      end
      WeakAuras.ClearAndUpdateOptions(data.id, true)
    end
  }

  if optionClass ~= "noninteractive" then
    args[prefix .. "name"] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = name(option, "name", L["Display Name"]),
      desc = desc(option, "name"),
      order = order(),
      get = getStr(option, "name"),
      set = setStr(data, option, "name")
    }

    args[prefix .. "key"] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = name(option, "key", optionClass == "group" and L["Group key"] or L["Option key"]),
      order = order(),
      validate = validateNonDuplicateKey(option),
      get = get(option, "key"),
      set = set(data, option, "key")
    }
  end

  if optionClass == "simple" then
    args[prefix .. "tooltipSpace"] = {
      type = "description",
      width = WeakAuras.doubleWidth,
      name = "",
      order = order
    }
    args[prefix .. "usetooltip"] = {
      type = "toggle",
      name = name(option, "useDesc", L["Tooltip"]),
      order = order(),
      width = WeakAuras.halfWidth,
      get = get(option, "useDesc"),
      set = set(data, option, "useDesc")
    }
    args[prefix .. "tooltip"] = {
      type = "input",
      name = name(option, "desc", L["Tooltip Text"]),
      desc = desc(option, "desc"),
      order = order(),
      width = WeakAuras.normalWidth * 1.5,
      get = getStr(option, "desc"),
      set = setStr(data, option, "desc"),
      disabled = function()
        return not option.useDesc
      end
    }
  end

  args[prefix .. "width"] = {
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    name = name(option, "width", L["Width"]),
    desc = desc(option, "width"),
    order = order(),
    min = 0.1,
    max = 2,
    step = 0.05,
    get = get(option, "width"),
    set = set(data, option, "width")
  }

  local addControlsForType = typeControlAdders[option.type]
  if addControlsForType then
    addControlsForType(options, args, data, order, prefix, i)
  end
end

local groupPages = {}

local function getPage(id, path, max)
  max = max or math.huge
  groupPages[id] = groupPages[id] or {}
  local base = groupPages[id]
  for _, index in ipairs(path) do
    if not base[index] then
      base[index] = {}
    end
    base = base[index]
  end
  if not base.page or (max and base.page > max) then
    base.page = 1
  end
  return base.page
end

local function setPage(id, path, page)
  groupPages[id] = groupPages[id] or {}
  local base = groupPages[id]
  for _, index in ipairs(path) do
    if not base[index] then
      base[index] = {}
    end
    base = base[index]
  end
  base.page = page
end

local function addUserModeOption(options, args, data, order, prefix, i)
  local option = options[i]
  local optionType = option.type
  local optionClass = OptionsPrivate.Private.author_option_classes[optionType]
  local userOption

  if optionClass == "simple" then
    userOption = {
      type = optionType,
      name = nameUser(option),
      desc = descUser(option),
      width = (option.width or 1) * WeakAuras.normalWidth,
      order = order(),
      get = getUser(option),
      set = setUser(data, option)
    }
  elseif optionClass == "noninteractive" then
    userOption = {
      type = "description",
      order = order(),
      name = "",
      width = (option.width or 1) * WeakAuras.normalWidth
    }
  elseif optionClass == "group" then
    local collapsed = false
    if option.useCollapse then
      local defaultCollapsed = true
      if option.collapse ~= nil then
        defaultCollapsed = option.collapse
      end
      for id, optionData in pairs(option.references) do
        if OptionsPrivate.IsCollapsed(id, "config", optionData.path, defaultCollapsed) then
          collapsed = true
          break
        end
      end
      args[prefix .. "collapse"] = {
        type = "execute",
        name = option.name,
        order = order(),
        width = WeakAuras.doubleWidth,
        func = function()
          for id, optionData in pairs(option.references) do
            OptionsPrivate.SetCollapsed(id, "config", optionData.path, not collapsed)
          end
          WeakAuras.ClearAndUpdateOptions(data.id, true)
        end,
        image = collapsed and "Interface\\AddOns\\WeakAuras\\Media\\Textures\\expand" or
          "Interface\\AddOns\\WeakAuras\\Media\\Textures\\collapse",
        imageWidth = 18,
        imageHeight = 18,
        control = "WeakAurasExpand"
      }
    end
    if not collapsed then
      local skipSubOptions = false
      if option.groupType == "array" then
        local values, firstChild = {}, true
        local nameSource = option.nameSource or 0
        if nameSource > 0 then
          nameSource = option.subOptions[option.nameSource].key
        end
        if nameSource == -1 then
          for id, optionData in pairs(option.references) do
            local i = 1
            local childOption = optionData.options[optionData.index]
            local entryNames = childOption.entryNames
            while i <= #values or i <= childOption.size do
              if firstChild then
                values[i] = entryNames[i]
              elseif values[i] ~= entryNames[i] then
                values[i] = conflictBlue .. L["Entry %i"]:format(i)
              end
              i = i + 1
            end
            firstChild = false
          end
        elseif nameSource == 0 then
          for id, optionData in pairs(option.references) do
            local i = 1
            local childOption = optionData.options[optionData.index]
            local childValues = optionData.config[childOption.key]
            while i <= #values or i <= #childValues do
              if firstChild then
                values[i] = L["Entry %i"]:format(i)
              elseif values[i] == nil or childValues[i] == nil then
                values[i] = conflictBlue .. L["Entry %i"]:format(i)
              end
              i = i + 1
            end
            firstChild = false
          end
        else
          for id, optionData in pairs(option.references) do
            local i = 1
            local childOption = optionData.options[optionData.index]
            local childValues = optionData.config[option.key]
            while i <= #values or i <= #childValues do
              if firstChild then
                values[i] = childValues[i][nameSource] or conflictBlue .. L["Entry %i"]:format(i)
              elseif not childValues[i] or childValues[i][nameSource] ~= values[i] then
                values[i] = conflictBlue .. L["Entry %i"]:format(i)
              end
              i = i + 1
            end
            firstChild = false
          end
        end
        skipSubOptions = #values == 0
        local buttonWidth = 0.75
        if option.limitType == "fixed" then
          buttonWidth = buttonWidth - 0.30
        end
        if option.hideReorder or option.nameSource == -1 then
          buttonWidth = buttonWidth - 0.30
        end
        args[prefix .. "entryChoice"] = {
          type = "select",
          name = nameUser(option),
          order = order(),
          width = WeakAuras.doubleWidth - buttonWidth,
          values = values,
          get = function()
            if skipSubOptions then
              return 1 -- show the "create" prompt, which is at index 1
            end
            local value
            for id, optionData in pairs(option.references) do
              local childOption = optionData.options[optionData.index]
              local childConfigList = optionData.config[childOption.key]
              if value == nil then
                value = getPage(id, optionData.path, #childConfigList)
              elseif value ~= getPage(id, optionData.path, #childConfigList) then
                return ""
              end
            end
            return value
          end,
          set = function(_, value)
            for id, optionData in pairs(option.references) do
              setPage(id, optionData.path, value) -- XXX: mergeOptions will reset this to the maximum value if it's too big
            end
            WeakAuras.ClearAndUpdateOptions(data.id, true)
          end,
          sorting = option.sortAlphabetically and OptionsPrivate.Private.SortOrderForValues(values) or nil
        }
        args[prefix .. "resetEntry"] = {
          type = "execute",
          name = L["Reset Entry"],
          order = order(),
          func = function()
            for id, optionData in pairs(option.references) do
              local childOption = optionData.options[optionData.index]
              local childData = optionData.data
              local childPage = getPage(id, optionData.path)
              local childConfigList = optionData.config[childOption.key]
              childConfigList[childPage] = {}
              WeakAuras.Add(childData)
            end
            WeakAuras.ClearAndUpdateOptions(data.id, true)
          end,
          width = 0.15,
          image = "Interface\\Addons\\WeakAuras\\Media\\Textures\\reset",
          imageWidth = 18,
          imageHeight = 18,
          control = "WeakAurasIcon"
        }
        if option.limitType ~= "fixed" then
          args[prefix .. "createEntry"] = {
            type = "execute",
            name = L["Add Entry"],
            order = order(),
            func = function()
              for id, optionData in pairs(option.references) do
                local childOption = optionData.options[optionData.index]
                local childConfigList = optionData.config[childOption.key]
                local childData = optionData.data
                if childOption.limitType == "none" or #childConfigList < childOption.size then
                  tinsert(childConfigList, {})
                  setPage(id, optionData.path, #childConfigList)
                  -- we do need to Add here, so that the new entry can get its default values
                  WeakAuras.Add(childData)
                end
              end
              WeakAuras.ClearAndUpdateOptions(data.id, true)
            end,
            disabled = function()
              if option.limitType == "none" then
                return false
              else
                for id, optionData in pairs(option.references) do
                  local childOption = optionData.options[optionData.index]
                  local childConfigList = optionData.config[childOption.key]
                  if #childConfigList >= childOption.size then
                    return true
                  end
                end
              end
            end,
            width = 0.15,
            image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\add",
            imageWidth = 18,
            imageHeight = 18,
            control = "WeakAurasIcon"
          }
          args[prefix .. "deleteEntry"] = {
            type = "execute",
            name = L["Delete Entry"],
            order = order(),
            confirm = true,
            func = function()
              for id, optionData in pairs(option.references) do
                local childOption = optionData.options[optionData.index]
                local childConfigList = optionData.config[childOption.key]
                local childData = optionData.data
                local page = getPage(id, optionData.path)
                if #childConfigList ~= 0 then
                  tremove(childConfigList, page)
                  setPage(id, optionData.path, min(#childConfigList, page))
                  WeakAuras.Add(childData)
                end
              end
              WeakAuras.ClearAndUpdateOptions(data.id, true)
            end,
            disabled = function()
              return skipSubOptions
            end,
            width = 0.15,
            image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\delete",
            imageWidth = 18,
            imageHeight = 18,
            control = "WeakAurasIcon"
          }
        end
        if option.nameSource ~= -1 and not option.hideReorder then
          args[prefix .. "moveEntryUp"] = {
            type = "execute",
            name = L["Move Entry Up"],
            order = order(),
            func = function()
              for id, optionData in pairs(option.references) do
                local childOption = optionData.options[optionData.index]
                local childConfigList = optionData.config[childOption.key]
                local childData = optionData.data
                local childPage = getPage(id, optionData.path, #childConfigList)
                if childConfigList[childPage] then
                  childConfigList[childPage], childConfigList[childPage - 1] = childConfigList[childPage - 1], childConfigList[childPage]
                  setPage(id, optionData.path, childPage - 1)
                  WeakAuras.Add(childData)
                end
              end
              WeakAuras.ClearAndUpdateOptions(data.id, true)
            end,
            disabled = function()
              for id, optionData in pairs(option.references) do
                if getPage(id, optionData.path) <= 1 then
                  return true
                end
              end
            end,
            width = 0.15,
            image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\moveup",
            imageWidth = 18,
            imageHeight = 18,
            control = "WeakAurasIcon"
          }
          args[prefix .. "moveEntryDown"] = {
            type = "execute",
            name = L["Move Entry Down"],
            order = order(),
            func = function()
              for id, optionData in pairs(option.references) do
                local childOption = optionData.options[optionData.index]
                local childConfigList = optionData.config[childOption.key]
                local childData = optionData.data
                local childPage = getPage(id, optionData.path, #childConfigList)
                if childConfigList[childPage] then
                  childConfigList[childPage], childConfigList[childPage + 1] = childConfigList[childPage + 1], childConfigList[childPage]
                  setPage(id, optionData.path, childPage + 1)
                  WeakAuras.Add(childData)
                end
              end
              WeakAuras.ClearAndUpdateOptions(data.id, true)
            end,
            disabled = function()
              for id, optionData in pairs(option.references) do
                local childPage = getPage(id, optionData.path)
                local childOption = optionData.options[optionData.index]
                local childConfigList = optionData.config[childOption.key]
                if childPage >= #childConfigList then
                  return true
                end
              end
            end,
            width = 0.15,
            image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\movedown",
            imageWidth = 18,
            imageHeight = 18,
            control = "WeakAurasIcon"
          }
        end
      end

      if not skipSubOptions then
        local subPrefix = prefix .. "subOption"
        for j = 1, #option.subOptions do
          addUserModeOption(option.subOptions, args, data, order, subPrefix .. j, j)
        end
      end
    end
  end
  args[prefix] = userOption

  -- convert from weakauras option type to ace option type
  if optionClass == "simple" then
    -- toggle and input don't need any extra love
    if optionType == "input" then
      userOption.multiline = option.multiline
    elseif optionType == "number" then
      userOption.type = "input"
      userOption.get = getUserNumAsString(option)
      userOption.set = setUserNum(data, option)
    elseif optionType == "range" then
      userOption.softMax = option.softMax
      userOption.softMin = option.softMin
      userOption.bigStep = option.bigStep
      userOption.min = option.min
      userOption.max = option.max
      local effectiveMin = userOption.softMin or userOption.min or 0
      local effectiveMax = userOption.softMax or userOption.max or 100
      if (effectiveMin > effectiveMax) then
        -- This will cause a error inside the slider
        -- Fix up either softMax or max, depending on which one is the effective one
        if userOption.softMax then
          userOption.softMax = effectiveMin
        elseif userOption.max then
          userOption.max = effectiveMin
        else
          userOption.softMax = effectiveMin
        end
      end
      userOption.step = option.step
    elseif optionType == "color" then
      userOption.hasAlpha = true
      userOption.get = getUserColor(option)
      userOption.set = setUserColor(data, option)
    elseif optionType == "select" then
      userOption.values = getUserValues(option)
    elseif optionType == "multiselect" then
      userOption.values = getUserValues(option)
      userOption.get = function(_, k)
        local value
        for id, optionData in pairs(option.references) do
          if value == nil then
            value = optionData.config[option.key][k]
          elseif value ~= optionData.config[option.key][k] then
            return
          end
        end
        return value
      end
      userOption.set = function(_, k, v)
        for _, optionData in pairs(option.references) do
          optionData.config[option.key][k] = v
          WeakAuras.Add(optionData.data)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    elseif optionType == "media" then
      userOption.type = "select"
      userOption.dialogControl = OptionsPrivate.Private.author_option_media_controls[option.mediaType]
      userOption.itemControl = OptionsPrivate.Private.author_option_media_itemControls[option.mediaType]
      userOption.values = function()
        if option.mediaType == "sound" then
          return OptionsPrivate.Private.sound_file_types
        else
          return AceGUIWidgetLSMlists[option.mediaType]
        end
      end

      userOption.sorting = function()
        if option.mediaType == "sound" then
          return OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.sound_file_types)
        else
          return nil
        end
      end

      userOption.set = function(_, value)
        if option.mediaType == "sound" then
          PlaySoundFile(value, "Master")
        end
        for _, optionData in pairs(option.references) do
          local childData = optionData.data
          local childConfig = optionData.config
          childConfig[option.key] = value
          WeakAuras.Add(childData)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    end
  elseif optionClass == "noninteractive" then
    if optionType == "header" then
      userOption.type = "header"
      local name = {}
      local firstName = nil
      local conflict = false
      for _, optionData in pairs(option.references) do
        local childOption = optionData.options[optionData.index]
        if childOption.useName and #childOption.text > 0 then
          if firstName == nil then
            firstName = childOption.text
            tinsert(name, (childOption.text:gsub("||", "|")))
          elseif childOption.text ~= firstName then
            conflict = true
            tinsert(name, (childOption.text:gsub("||", "|")))
          end
        end
      end
      userOption.name = (conflict and conflictBlue or "") .. tconcat(name, " / ")
    elseif optionType == "description" then
      userOption.name = nameUserDesc(option)
      userOption.fontSize = option.fontSize
    elseif optionType == "space" then
      if not option.variableWidth then
        userOption.width = "full"
      end
      if option.useHeight and (option.height or 1) > 1 then
        userOption.name = string.rep("\n", option.height - 1)
      else
        userOption.name = " "
      end
    end
  end
end

local function initReferences(mergedOption, data, options, index, config, path, parent)
  mergedOption.references = {
    [data.id] = {
      data = data,
      options = options,
      index = index,
      config = config,
      path = path,
      parent = parent,
    }
  }
  if mergedOption.subOptions then
    local subConfig
    if config then
      if mergedOption.groupType == "simple" then
        subConfig = config[mergedOption.key]
      else
        local configList = config[mergedOption.key]
        local page = getPage(data.id, path, #configList)
        subConfig = configList[page]
      end
    end
    local subOptions = options[index].subOptions
    local subPath
    local subParent = mergedOption
    for i, submergedOption in ipairs(mergedOption.subOptions) do -- ha, submerged
      subPath = CopyTable(path)
      subPath[#subPath + 1] = i
      initReferences(submergedOption, data, subOptions, i, subConfig, subPath, subParent)
    end
  end
end

-- all of these fields must be identical for an option to be merged
-- sometimes this just means that they are both nil, e.g. descriptions have no key
local significantFieldsForMerge = {
  type = true,
  name = true,
  key = true,
  groupType = true,
  limitType = true,
  size = true,
  mediaType = true,
}

-- these fields are special cases, generally reserved for when the UI displays something based on the merged options
-- e.g. array name source displays options in merged order, so the dereferenced source is not useful at that level.
local specialCasesForMerge = {
  nameSource = true
}

local function mergeOptions(mergedOptions, data, options, config, prepath, parent)
  local nextInsert = 1
  for i = 1, #options do
    local path = CopyTable(prepath)
    path[#path + 1] = i
    -- find the best place to start inserting the next option to merge
    local nextToMerge = options[i]
    local shouldMerge = false
    if not nextToMerge.noMerge then
      for j = nextInsert, #mergedOptions + 1 do
        local mergedOption = mergedOptions[j]
        if not mergedOption then
          break
        end -- no more options to check, so must insert
        local validMerge = not mergedOption.noMerge
        if validMerge then
          for field in pairs(significantFieldsForMerge) do
            if nextToMerge[field] ~= mergedOption[field] then
              validMerge = false
              break
            end
          end
        end
        if validMerge then
          shouldMerge = true
          nextInsert = j
          break
        end
      end
    end
    -- now we know at what point to add nextToMerge
    if shouldMerge then
      local mergedOption = mergedOptions[nextInsert]
      -- nil out all fields which aren't the same
      mergedOption.references[data.id] = {
        data = data,
        options = options,
        index = i,
        config = config,
        path = path,
        parent = parent,
      }
      for k, v in pairs(nextToMerge) do
        if k == "subOptions" then
          local subConfig
          if config then
            if mergedOption.groupType == "simple" then
              subConfig = config[mergedOption.key]
            else
              local configList = config[mergedOption.key]
              local page = getPage(data.id, path, #configList)
              subConfig = configList[page]
            end
          end
          local subParent = mergedOption
          mergeOptions(mergedOption.subOptions, data, v, subConfig, path, subParent)
          if mergedOption.groupType == "array" and mergedOption.nameSource ~= nil then
            -- special case merge of nameSource
            -- nameSource can be an optionID of the array's subOptions.
            -- Since the optionIDs are normally hidden away in references and options with different optionIDs can be merged together,
            -- we can't simply use nilmerge like we do with most other fields.
            -- Obviously, if the nameSource has already been set to nil then we do not need to do any more checks,
            -- as newly merged options can never resolve conflicts. Otherwise, we need to examine the semantic value of the nameSource.
            if nextToMerge.nameSource < 1 or mergedOption.nameSource < 1 then -- either the names are fixed, or they are auto-generated as "Entry #"
              -- in this case, nilmerge is the appropriate strategy
              if mergedOption.nameSource ~= nextToMerge.nameSource then
                mergedOption.nameSource = nil
              end
            else -- entry names are sourced from config of a particular subOption
              -- check if nextToMerge.nameSource was merged in the same spot as mergedOption.nameSource
              local subMergedOption = mergedOption.subOptions[mergedOption.nameSource]
              local optionData = subMergedOption.references[data.id]
              if not optionData or optionData.index ~= nextToMerge.nameSource then
                -- either an option was not merged at the name source's index, or the wrong option was.
                -- in both cases, the name source is conflicted. Fallback to "Entry #" as entry names
                mergedOption.nameSource = nil
              end
            end
          end
        elseif not specialCasesForMerge[k] and neq(mergedOption[k], v) then
          mergedOption[k] = nil
        end
      end
    else
      nextInsert = #mergedOptions + 1
      -- can't merge, should insert instead
      local newOption = CopyTable(nextToMerge)
      initReferences(newOption, data, options, i, config, path, parent)
      tinsert(mergedOptions, nextInsert, newOption)
    end
    -- never merge 2 options from the same child
    nextInsert = nextInsert + 1
  end
end

local function valuesAreEqual(t1, t2)
  if t1 == t2 then
    return true
  end
  local ty1 = type(t1)
  local ty2 = type(t2)
  if ty1 ~= ty2 then
    return false
  end
  if ty1 == "number" then
    return abs(t1 - t2) < 1e-9
  end
  if ty1 ~= "table" then
    return false
  end
  for k1, v1 in pairs(t1) do
    local v2 = t2[k1]
    if v2 == nil or not valuesAreEqual(v1, v2) then
      return false
    end
  end

  for k2, v2 in pairs(t2) do
    local v1 = t1[k2]
    if v1 == nil or not valuesAreEqual(v1, v2) then
      return false
    end
  end
  return true
end

local function allChoicesAreDefault(option, config, id, path)
  local optionClass = OptionsPrivate.Private.author_option_classes[option.type]
  if optionClass == "simple" then
    return valuesAreEqual(option.default, config[option.key])
  elseif optionClass == "group" then
    if option.groupType == "simple" then
      local subConfig = config[option.key]
      path[#path + 1] = 0
      for i, subOption in ipairs(option.subOptions) do
        path[#path] = i
        if not allChoicesAreDefault(subOption, subConfig, id, path) then
          return false
        end
      end
      path[#path] = nil
    elseif option.groupType == "array" then
      path[#path + 1] = 0
      for _, subConfig in ipairs(config[option.key]) do
        for i, subOption in ipairs(option.subOptions) do
          path[#path] = i
          if not allChoicesAreDefault(subOption, subConfig, id, path) then
            return false
          end
        end
      end
      path[#path] = nil
    end
    if option.useCollapse then
      local isCollapsed = OptionsPrivate.IsCollapsed(id, "config", path, option.collapse)
      if isCollapsed ~= option.collapse then
        return false
      end
    end
  end
  return true
end

local function createorder(startorder)
  local order = startorder or 1
  return function()
    order = order + 1
    return order
  end
end

function OptionsPrivate.GetAuthorOptions(data)
  -- initialize the process
  local authorOptions = {
    type = "group",
    name = L["Custom Options"],
    order = 100,
    args = {}
  }
  local args = authorOptions.args
  local isAuthorMode = true
  local options = {}
  local order = createorder(1)

  for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
    mergeOptions(options, child, child.authorOptions, child.config, {})
    isAuthorMode = isAuthorMode and child.authorMode
  end

  if isAuthorMode then
    args["enterUserMode"] = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = L["Enter User Mode"],
      desc = L["Enter user mode."],
      order = order(),
      func = function()
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          child.authorMode = nil
          -- no need to add, author mode is picked up by ClearAndUpdateOptions
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
    args["enterUserModeSpacer"] = {
      type = "description",
      name = "",
      order = order()
    }
    for i = 1, #options do
      addAuthorModeOption(options, args, data, order, "option" .. i, i)
    end
    args["addOption"] = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = L["Add Option"],
      order = order(),
      func = function()
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          local i = #child.authorOptions + 1
          child.authorOptions[i] = {
            type = "toggle",
            key = generateKey("option", child.authorOptions, i),
            name = L["Option %i"]:format(i),
            default = false,
            width = 1,
            useDesc = false,
          }
          OptionsPrivate.SetCollapsed(child.id, "author", i, false)
          WeakAuras.Add(child)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
  else
    for i = 1, #options do
      addUserModeOption(options, args, data, order, "userOption" .. i, i)
    end
    args["userConfigFooter"] = {
      type = "header",
      name = "",
      order = order()
    }
    args["resetToDefault"] = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = L["Reset to Defaults"],
      desc = L["Reset all options to their default values."],
      order = order(),
      func = function()
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          child.config = {} -- config validation in Add() will set all the needed keys to their defaults
          OptionsPrivate.ResetCollapsed(child.id, "config")
          WeakAuras.Add(child)
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end,
      disabled = function()
        local path = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          local config = child.config
            for i, option in ipairs(child.authorOptions) do
              path[1] = i
              local result = allChoicesAreDefault(option, config, child.id, path)
              if result == false then
                return false
              end
            end
        end
        return true
      end
    }
    args["enterAuthorMode"] = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = L["Enter Author Mode"],
      desc = L["Configure what options appear on this panel."],
      order = order(),
      func = function()
        for configData in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          -- no need to add, author mode is picked up by ClearAndUpdateOptions
          configData.authorMode = true
        end
        WeakAuras.ClearAndUpdateOptions(data.id, true)
      end
    }
  end
  return authorOptions
end

=== END OF FILE: WeakAurasOptions/AuthorOptions.lua ===


=== FILE: WeakAurasOptions/BuffTrigger2.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local function getAuraMatchesLabel(name)
  local ids = WeakAuras.spellCache.GetSpellsMatching(name)
  if ids then
    local numMatches = 0
    for _ in pairs(ids) do
      numMatches = numMatches + 1
    end
    return L["Matches %s spells"]:format(tostring(numMatches))
  else
    return ""
  end
end

local function getAuraMatchesList(name, showSpellIdRecommendation)
  local ids = WeakAuras.spellCache.GetSpellsMatching(name)
  if ids then
    local numMatches = 0
    local descText = ""

    local playerSpells = {}
    local otherSpells = {}

    for id, _ in pairs(ids) do
      numMatches = numMatches + 1

      if WeakAuras.IsPlayerSpellOrOverridesAndBaseIsPlayerSpell(id) then
        tinsert(playerSpells, id)
      else
        tinsert(otherSpells, id)
      end
    end

    local function addSpellToDesc(id)
      local icon = OptionsPrivate.Private.ExecEnv.GetSpellIcon(id)
      if icon then
        if descText == "" then
          descText = "|T"..icon..":0|t: "..id
        else
          descText = descText.."\n|T"..icon..":0|t: "..id
        end
      end
    end

    table.sort(playerSpells)
    table.sort(otherSpells)

    if #playerSpells > 0 then
      descText = descText .. L["Player Spells found:"]
      for _, id in ipairs(playerSpells) do
        addSpellToDesc(id)
      end
    end

    if #otherSpells > 0 then
      if descText ~= "" then
        descText = descText .. "\n\n"
      end
      descText = descText .. L["Spells found:"]

      for _, id in ipairs(otherSpells) do
        addSpellToDesc(id)
      end
    end

    local bestSuggestion
    if #playerSpells == 1 then
      bestSuggestion = playerSpells[1]
    elseif #playerSpells == 0 and #otherSpells == 1 then
      bestSuggestion = otherSpells[1]
    end

    if showSpellIdRecommendation then
      local tip = L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."]
      if bestSuggestion then
        tip = tip .. "\n" .. "|cffffd200" .. L["Click to replace the name with %s."]:format(bestSuggestion) .. "|r"
      end
      descText = descText .. "\n\n" .. tip
    end

    return descText, bestSuggestion
  else
    return ""
  end
end

local function shiftTable(tbl, pos)
  local size = #tbl
  for i = pos, size, 1 do
    tbl[i] = tbl[i + 1]
  end
end

-- Counts the Names or SpellIds in a aura, recursively.
local function CountNames(data, triggernum, name)
  local result = 0
  local trigger = data.triggers[triggernum].trigger
  if trigger[name] then
    result = #trigger[name]
  end
  return result
end

local function IsGroupTrigger(trigger)
  return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
         or trigger.unit == "boss" or trigger.unit == "nameplate" or trigger.unit == "arena" or trigger.unit == "multi"
end

local function IsSingleMissing(trigger)
  return not IsGroupTrigger(trigger) and trigger.matchesShowOn == "showOnMissing"
end

local function CanHaveMatchCheck(trigger)
  if IsGroupTrigger(trigger) then
    return true
  end
  if trigger.matchesShowOn == "showOnMissing" then
    return false
  end
  if trigger.matchesShowOn == "showOnActive" or trigger.matchesShowOn == "showOnMatches" or not trigger.matchesShowOn then
    return true
  end
  -- Always: If clones are shown
  return trigger.showClones
end

local function CreateNameOptions(aura_options, data, triggernum, size, isExactSpellId, isIgnoreList, prefix, baseOrder, useKey, optionKey, name, desc, inverse)
  local trigger = data.triggers[triggernum].trigger

  local spellCache = WeakAuras.spellCache

  for i = 1, size do
    local hiddenFunction
    if isIgnoreList then
      hiddenFunction = function()
        return not (trigger.type == "aura2" and trigger[useKey] and (i == 1 or trigger[optionKey] and trigger[optionKey][i - 1]) and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger))
      end
    else
      hiddenFunction = function()
        return not (trigger.type == "aura2" and trigger[useKey] and (i == 1 or trigger[optionKey] and trigger[optionKey][i - 1]))
      end
    end

    if i ~= 1 then
      aura_options[prefix .. "space" .. i] = {
        type = "execute",
        name = inverse and L["and"] or L["or"],
        width = WeakAuras.normalWidth - 0.2,
        image = function() return "", 0, 0 end,
        order = baseOrder + i / 100 + 0.0001,
        hidden = hiddenFunction
      }
    end

    local iconOption = prefix .. "icon" .. i
    aura_options[iconOption] = {
      type = "execute",
      width = 0.2,
      order = baseOrder + i / 100 + 0.0002,
      hidden = hiddenFunction,
      control = "WeakAurasIcon"
    }

    if isExactSpellId then
      aura_options[iconOption].name = function()
        return OptionsPrivate.Private.ExecEnv.GetSpellName(WeakAuras.SafeToNumber(trigger[optionKey] and trigger[optionKey][i]) or "")
      end
      aura_options[iconOption].image = function()
        local icon = OptionsPrivate.Private.ExecEnv.GetSpellIcon(trigger[optionKey] and trigger[optionKey][i] or "")
        return icon and tostring(icon) or "", 18, 18
      end
      aura_options[iconOption].disabled = function()
        return not trigger[optionKey] or not trigger[optionKey][i] or not OptionsPrivate.Private.ExecEnv.GetSpellIcon(trigger[optionKey] and trigger[optionKey][i])
      end
    else
      aura_options[iconOption].name = function()
        local spellId = trigger[optionKey] and trigger[optionKey][i] and WeakAuras.SafeToNumber(trigger[optionKey][i])
        if spellId then
          return getAuraMatchesLabel(OptionsPrivate.Private.ExecEnv.GetSpellName(spellId))
        else
          return getAuraMatchesLabel(trigger[optionKey] and trigger[optionKey][i])
        end
      end

      aura_options[iconOption].desc = function()
        local input = trigger[optionKey] and trigger[optionKey][i]
        local spellId = input and WeakAuras.SafeToNumber(input)
        if spellId then
          local name = OptionsPrivate.Private.ExecEnv.GetSpellName(spellId)
          if name then
            local auraDesc = getAuraMatchesList(name)
            if auraDesc then
              auraDesc = name .. "\n" .. auraDesc
            end
            return auraDesc
          end
        else
          if input and input ~= "" then
            return getAuraMatchesList(input, true)
          end
        end
      end
      aura_options[iconOption].image = function()
        local icon
        local input = trigger[optionKey] and trigger[optionKey][i]
        local spellId = input and WeakAuras.SafeToNumber(input)
        if spellId then
          icon = OptionsPrivate.Private.ExecEnv.GetSpellIcon(spellId)
        elseif input and input ~= "" then
          icon = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\info"
        end
        return icon and tostring(icon) or "", 18, 18
      end

      aura_options[iconOption].func = function()
        local input = trigger[optionKey] and trigger[optionKey][i]
        local spellId = input and WeakAuras.SafeToNumber(trigger[optionKey][i])
        if spellId then
          -- Do nothing
        elseif input and input ~= "" then
          local _, bestSuggestion = getAuraMatchesList(input)
          if bestSuggestion then
            trigger[optionKey][i] = bestSuggestion
            WeakAuras.Add(data)
            WeakAuras.ClearAndUpdateOptions(data.id)
          end
        end
      end
    end

    aura_options[prefix .. i] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = name,
      desc = desc,
      order = baseOrder + i / 100 + 0.0003,
      hidden = hiddenFunction,
      get = function(info)
        local rawString = trigger[optionKey] and trigger[optionKey][i]
        if not rawString then return "" end
        local spellName, _, _, _, _, _, spellID = OptionsPrivate.Private.ExecEnv.GetSpellInfo(WeakAuras.SafeToNumber(rawString))
        if spellName and spellID then
          return ("%s (%s)"):format(spellID, spellName) .. "\0" .. rawString
        elseif WeakAuras.SafeToNumber(rawString) then
          return ("%s (%s)"):format(rawString, L["Unknown Spell"]) .. "\0" .. rawString
        else
          return rawString .. "\0" .. rawString
        end
      end,
      set = function(info, v)
        trigger[optionKey] = trigger[optionKey] or {}
        if v == "" then
          shiftTable(trigger[optionKey], i)
        else
          if isExactSpellId then
            trigger[optionKey][i] = v
          else
            local _, spellId = WeakAuras.spellCache.CorrectAuraName(v)
            if spellId then
              trigger[optionKey][i] = tostring(spellId)
            else
              trigger[optionKey][i] = spellCache.BestKeyMatch(v)
            end
          end
        end

        WeakAuras.Add(data)
        WeakAuras.UpdateThumbnail(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end,
      validate = isExactSpellId and WeakAuras.ValidateNumeric or nil,
      control = "WeakAurasInputFocus",
    }
  end
  -- VALIDATE ?
end

local function GetBuffTriggerOptions(data, triggernum)
  local trigger = data.triggers[triggernum].trigger

  local function HasMatchCount(trigger)
    if IsGroupTrigger(trigger) then
      return trigger.useMatch_count
    else
      return trigger.matchesShowOn == "showOnMatches"
    end
  end

  local function HasMatchPerUnitCount(trigger)
    if trigger.type == "aura2" and IsGroupTrigger(trigger)
      and trigger.showClones and trigger.combinePerUnit and trigger.perUnitMode ~= "unaffected"
    then
      return trigger.useMatchPerUnit_count
    end
  end

  local ValidateNumeric = WeakAuras.ValidateNumeric
  local aura_options = {
    useUnit = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Unit"],
      order = 10,
      disabled = true,
      get = function() return true end
    },
    unit = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Unit"],
      order = 10.1,
      values = function()
        return OptionsPrivate.Private.unit_types_bufftrigger_2
      end,
      desc = L[" |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.\n |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.\n|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.\n |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.\n |cffffff00Smart Group|r adjusts to your current group type, matching just the \"player\" when solo, \"party\" units (including \"player\") in a party or \"raid\" units in a raid.\n |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.\n|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.\n\n|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting."],
    },
    useSpecificUnit = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Specific Unit"],
      order = 10.2,
      disabled = true,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit == "member") end,
      get = function() return true end
    },
    specificUnit = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["Specific Unit"],
      order = 10.3,
      desc = L["A Unit ID (e.g., party1)."],
      hidden = function() return not (trigger.type == "aura2" and trigger.unit == "member") end
    },
    warnSpecifcUnit = {
      type = "description",
      width = WeakAuras.doubleWidth,
      name = function()
        return L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."]:format(trigger.specificUnit or "")
      end,
      order = 10.4,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit == "member" and WeakAuras.UntrackableUnit(trigger.specificUnit)) end
    },
    warnSoftTarget = {
      type = "description",
      width = WeakAuras.doubleWidth,
      name = function()
        return L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."]:format(trigger.unit or "")
      end,
      order = 10.4,
      hidden = function() return not WeakAuras.IsUntrackableSoftTarget(trigger.unit) end
    },
    useDebuffType = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Aura Type"],
      order = 11,
      disabled = true,
      get = function() return true end
    },
    debuffType = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Aura Type"],
      order = 11.1,
      values = OptionsPrivate.Private.debuff_types,
    },
    spell_filters_header = {
      type = "header",
      name = L["Spell Selection Filters"],
      order = 11.15,
    },
    use_debuffClass = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Debuff Type"],
      order = 11.2,
      desc = L["Filter to only dispellable de/buffs of the given type(s)\nBleed classification via LibDispel"],
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end
    },
    debuffClass = {
      type = "multiselect",
      width = WeakAuras.normalWidth,
      name = L["Debuff Type"],
      order = 11.3,
      hidden = function()
        return not (trigger.type == "aura2" and trigger.unit ~= "multi"
          and CanHaveMatchCheck(trigger)
          and trigger.use_debuffClass)
      end,
      values = OptionsPrivate.Private.debuff_class_types,
    },
    debuffClassSpace = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = 11.4,
      hidden = function()
        return not (trigger.type == "aura2" and trigger.unit ~= "multi"
          and CanHaveMatchCheck(trigger)
          and not trigger.use_debuffClass)
      end
    },
    useName = {
      type = "toggle",
      name = L["Name(s)"],
      order = 12,
      width = WeakAuras.normalWidth - 0.2,
    },
    useNameSpace = {
      type = "description",
      name = "",
      order = 12.1,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and not trigger.useName) end
    },
    useExactSpellId = {
      type = "toggle",
      name = L["Exact Spell ID(s)"],
      width = WeakAuras.normalWidth - 0.2,
      order = 22,
    },
    useExactSpellIdSpace = {
      type = "description",
      name = "",
      order = 22.1,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and not trigger.useExactSpellId) end
    },
    useIgnoreName = {
      type = "toggle",
      name = L["Ignored Name(s)"],
      order = 32,
      width = WeakAuras.normalWidth - 0.2,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end
    },
    useIgnoreNameSpace = {
      type = "description",
      name = "",
      order = 32.1,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and not trigger.useIgnoreName and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end
    },
    useIgnoreExactSpellId = {
      type = "toggle",
      name = L["Ignored Exact Spell ID(s)"],
      width = WeakAuras.normalWidth - 0.2,
      order = 42,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end
    },
    useIgnoreExactSpellIddSpace = {
      type = "description",
      name = "",
      order = 42.1,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and not trigger.useIgnoreExactSpellId and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end
    },

    useNamePattern = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Name Pattern Match"],
      desc = L["Filter based on the spell Name string."],
      order = 55,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi") end
    },
    useNamePatternSpace = {
      type = "description",
      name = "",
      order = 55.2,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and not trigger.useNamePattern) end
    },
    namePattern_operator = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Operator"],
      order = 55.1,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and trigger.useNamePattern) end,
      values = OptionsPrivate.Private.string_operator_types
    },
    namePattern_name = {
      type = "input",
      name = L["Aura Name Pattern"],
      width = WeakAuras.doubleWidth,
      order = 55.2,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and trigger.useNamePattern) end
    },
    aura_filters_header = {
      type = "header",
      name = L["Active Aura Filters and Info"],
      order = 59.9,
    },
    useStacks = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Stack Count"],
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end,
      order = 60
    },
    stacksOperator = {
      type = "select",
      name = L["Operator"],
      order = 60.1,
      width = WeakAuras.halfWidth,
      values = OptionsPrivate.Private.operator_types,
      disabled = function() return not trigger.useStacks end,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useStacks) end,
      get = function() return trigger.useStacks and trigger.stacksOperator or nil end
    },
    stacks = {
      type = "input",
      name = L["Stack Count"],
      validate = ValidateNumeric,
      order = 60.2,
      width = WeakAuras.halfWidth,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useStacks) end,
      get = function() return trigger.useStacks and trigger.stacks or nil end
    },
    useStacksSpace = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = 60.3,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and not trigger.useStacks) end
    },
    useRem = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Remaining Time"],
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end,
      order = 61
    },
    remOperator = {
      type = "select",
      name = L["Operator"],
      order = 61.1,
      width = WeakAuras.halfWidth,
      values = OptionsPrivate.Private.operator_types,
      disabled = function() return not trigger.useRem end,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useRem) end,
      get = function() return trigger.useRem and trigger.remOperator or nil end
    },
    rem = {
      type = "input",
      name = L["Remaining Time"],
      validate = ValidateNumeric,
      order = 61.2,
      width = WeakAuras.halfWidth,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useRem) end,
      get = function() return trigger.useRem and trigger.rem or nil end
    },
    useRemSpace = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = 61.3,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and not trigger.useRem) end
    },
    useTotal = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Total Time"],
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end,
      order = 61.4
    },
    totalOperator = {
      type = "select",
      name = L["Operator"],
      order = 61.5,
      width = WeakAuras.halfWidth,
      values = OptionsPrivate.Private.operator_types,
      disabled = function() return not trigger.useTotal end,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useTotal) end,
      get = function() return trigger.useTotal and trigger.totalOperator or nil end
    },
    total = {
      type = "input",
      name = L["Total Time"],
      validate = ValidateNumeric,
      order = 61.6,
      width = WeakAuras.halfWidth,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useTotal) end,
      get = function() return trigger.useTotal and trigger.total or nil end
    },
    useTotalSpace = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = 61.7,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and not trigger.useTotal) end
    },
    use_stealable = {
      type = "toggle",
      name = function(input)
        local value = trigger.use_stealable
        if value == nil then return L["Is Stealable"]
        elseif value == false then return "|cFFFF0000 " .. L["Negator"] .. " " .. L["Is Stealable"] .. "|r"
        else return "|cFF00FF00" .. L["Is Stealable"] .. "|r" end
      end,
      width = WeakAuras.doubleWidth,
      order = 64,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end,
      get = function()
        local value = trigger.use_stealable
        if value == nil then return false
        elseif value == false then return "false"
        else return "true" end
      end,
      set = function(info, v)
        if v then
          trigger.use_stealable = true
        else
          local value = trigger.use_stealable
          if value == false then trigger.use_stealable = nil
          else trigger.use_stealable = false end
        end
        WeakAuras.Add(data)
      end
    },
    use_isBossDebuff = {
      type = "toggle",
      name = function(input)
        local value = trigger.use_isBossDebuff
        if value == nil then return L["Is Boss Debuff"]
        elseif value == false then return "|cFFFF0000 " .. L["Negator"] .. " " .. L["Is Boss Debuff"] .. "|r"
        else return "|cFF00FF00" .. L["Is Boss Debuff"] .. "|r" end
      end,
      width = WeakAuras.doubleWidth,
      order = 64.1,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end,
      get = function()
        local value = trigger.use_isBossDebuff
        if value == nil then return false
        elseif value == false then return "false"
        else return "true" end
      end,
      set = function(info, v)
        if v then
          trigger.use_isBossDebuff = true
        else
          local value = trigger.use_isBossDebuff
          if value == false then trigger.use_isBossDebuff = nil
          else trigger.use_isBossDebuff = false end
        end
        WeakAuras.Add(data)
      end
    },
    use_castByPlayer = {
      type = "toggle",
      name = function()
        local value = trigger.use_castByPlayer
        if value == nil then return L["Cast by a Player Character"]
        elseif value == false then return "|cFFFF0000 "..L["Negator"].." "..L["Cast by a Player Character"]
        else return "|cFF00FF00"..L["Cast by a Player Character"] end
      end,
      desc = L["Only Match auras cast by a player (not an npc)"],
      width = WeakAuras.doubleWidth,
      order = 64.2,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger)) end,
      get = function()
        local value = trigger.use_castByPlayer
        if value == nil then return false
        elseif value == false then return "false"
        else return "true" end
      end,
      set = function(info, v)
        if v then
          trigger.use_castByPlayer = true
        else
          local value = trigger.use_castByPlayer
          if value == false then trigger.use_castByPlayer = nil
          else trigger.use_castByPlayer = false end
        end
        WeakAuras.Add(data)
      end
    },
    ownOnly = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = function()
        local value = trigger.ownOnly
        if value == nil then return L["Own Only"]
        elseif value == false then return "|cFFFF0000 " .. L["Negator"] .. " " .. L["Own Only"] .. "|r"
        else return "|cFF00FF00" .. L["Own Only"] .. "|r" end
      end,
      desc = function()
        local value = trigger.ownOnly
        if value == nil then return L["Only match auras cast by the player or their pet"]
        elseif value == false then return L["Only match auras cast by people other than the player or their pet"]
        else return L["Only match auras cast by the player or their pet"] end
      end,
      get = function()
        local value = trigger.ownOnly
        if value == nil then return false
        elseif value == false then return "false"
        else return "true" end
      end,
      set = function(info, v)
        if v then
          trigger.ownOnly = true
        else
          local value = trigger.ownOnly
          if value == false then trigger.ownOnly = nil
          else trigger.ownOnly = false end
        end
        WeakAuras.Add(data)
      end,
      order = 64.3,
      hidden = function() return not trigger.type == "aura2" end
    },

    fetchTooltip = {
      type = "toggle",
      name = L["Fetch Tooltip Information"],
      desc = L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."],
      order = 64.5,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and not IsSingleMissing(trigger)) end
    },
    use_tooltip = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Tooltip Pattern Match"],
      order = 64.51,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.fetchTooltip) end
    },
    use_tooltipSpace = {
      type = "description",
      name = "",
      order = 64.52,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and not trigger.use_tooltip and trigger.fetchTooltip) end
    },
    tooltip_operator = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Operator"],
      order = 64.53,
      disabled = function() return not trigger.use_tooltip end,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.use_tooltip and trigger.fetchTooltip) end,
      values = OptionsPrivate.Private.string_operator_types
    },
    tooltip = {
      type = "input",
      name = L["Tooltip Content"],
      width = WeakAuras.doubleWidth,
      order = 64.54,
      disabled = function() return not trigger.use_tooltip end,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.use_tooltip and trigger.fetchTooltip) end
    },
    use_tooltipValue = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Tooltip Value"],
      order = 64.55,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.fetchTooltip) end
    },
    tooltipValueNumber = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Tooltip Value #"],
      order = 64.56,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.use_tooltipValue and trigger.fetchTooltip) end,
      values = OptionsPrivate.Private.tooltip_count
    },
    use_tooltipValueSpace = {
      type = "description",
      name = "",
      order = 64.57,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and not trigger.use_tooltipValue and trigger.fetchTooltip) end
    },
    tooltipValue_operator = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Operator"],
      order = 64.58,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.use_tooltipValue and trigger.fetchTooltip) end,
      values = OptionsPrivate.Private.operator_types
    },
    tooltipValue = {
      type = "input",
      name = L["Tooltip"],
      width = WeakAuras.normalWidth,
      validate = ValidateNumeric,
      order = 64.59,
      hidden = function() return not (trigger.type == "aura2" and trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.use_tooltipValue and trigger.fetchTooltip) end
    },
    unit_filters_header = {
      type = "header",
      name = L["Affected Unit Filters and Info"],
      order = 65,
      hidden = function() return trigger.unit == "multi" end,
    },
    useAffected = {
      type = "toggle",
      name = L["Fetch Affected/Unaffected Names and Units"],
      width = WeakAuras.doubleWidth,
      order = 65.1,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")) end
    },
    fetchRole = {
      type = "toggle",
      name = L["Fetch Role Information"],
      desc = L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."],
      order = 65.2,
      width = WeakAuras.doubleWidth,
      hidden = function()
        return not (trigger.type == "aura2" and trigger.unit ~= "multi")
               or WeakAuras.IsClassicEra()
      end
    },
    fetchRaidMark = {
      type = "toggle",
      name = L["Fetch Raid Mark Information"],
      desc = L["This adds %raidMark as text replacements."],
      order = 65.3,
      width = WeakAuras.doubleWidth,
      hidden = function()
        return not (trigger.type == "aura2" and trigger.unit ~= "multi")
      end
    },
    use_includePets = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Include Pets"],
      order = 66.1,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"))
      end
    },
    includePets = {
      type = "select",
      values = OptionsPrivate.Private.include_pets_types,
      width = WeakAuras.normalWidth,
      name = L["Include Pets"],
      order = 66.15,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and trigger.use_includePets) end,
    },
    includePetsSpace = {
      type = "description",
      name = "",
      order = 66.16,
      width = WeakAuras.normalWidth,
      hidden = function()
        return not (trigger.type == "aura2"
                    and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and not trigger.use_includePets)
      end
    },

    useActualSpec = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Specialization"],
      desc = L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"],
      order = 66.3,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        and WeakAuras.IsCataOrMistsOrRetail())
      end,
    },
    actualSpec = {
      type = "multiselect",
      width = WeakAuras.normalWidth,
      name = L["Actual Spec"],
      desc = L["Requires syncing the specialization via LibSpecialization."],
      values = OptionsPrivate.Private.spec_types_all,
      hidden = function()
        return not (trigger.type == "aura2"
                    and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
                    and trigger.useActualSpec
                    and WeakAuras.IsCataOrMistsOrRetail())
      end,
      order = 66.4
    },
    actualSpecSpace = {
      type = "description",
      name = "",
      order = 66.5,
      width = WeakAuras.normalWidth,
      hidden = function()
        return not (trigger.type == "aura2"
                    and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
                    and not trigger.useActualSpec
                    and WeakAuras.IsCataOrMistsOrRetail())
      end
    },

    useGroupRole = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Group Role"],
      order = 67.1,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"))
        or WeakAuras.IsClassicEra()
      end
    },
    group_role = {
      type = "multiselect",
      width = WeakAuras.normalWidth,
      name = L["Group Role"],
      values = OptionsPrivate.Private.role_types,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and trigger.useGroupRole)
        or WeakAuras.IsClassicEra()
      end,
      order = 67.2
    },
    group_roleSpace = {
      type = "description",
      name = "",
      order = 67.3,
      width = WeakAuras.normalWidth,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and not trigger.useGroupRole)
        or WeakAuras.IsClassicEra()
      end
    },
    useRaidRole = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Raid Role"],
      order = 67.4,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"))
        or WeakAuras.IsRetail()
      end
    },
    raid_role = {
      type = "multiselect",
      width = WeakAuras.normalWidth,
      name = L["Raid Role"],
      values = OptionsPrivate.Private.raid_role_types,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and trigger.useRaidRole)
        or WeakAuras.IsRetail()
      end,
      order = 67.5
    },
    raid_roleSpace = {
      type = "description",
      name = "",
      order = 67.6,
      width = WeakAuras.normalWidth,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and not trigger.useRaidRole)
        or WeakAuras.IsRetail()
      end
    },
    useArenaSpec = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Arena Spec"],
      order = 67.8,
      hidden = function() return
        not (WeakAuras.IsRetail() and trigger.type == "aura2" and trigger.unit == "arena")
      end
    },
    arena_spec = {
      type = "multiselect",
      width = WeakAuras.normalWidth,
      name = L["Specialization"],
      values = OptionsPrivate.Private.spec_types_all,
      hidden = function()
        return not (WeakAuras.IsRetail() and trigger.type == "aura2" and trigger.unit == "arena" and trigger.useArenaSpec)
      end,
      order = 67.9
    },
    arena_specSpace = {
      type = "description",
      name = "",
      order = 67.91,
      width = WeakAuras.normalWidth,
      hidden = function()
        return not (WeakAuras.IsRetail() and trigger.type == "aura2" and trigger.unit == "arena" and not trigger.useArenaSpec)
      end,
    },

    useClass = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Class"],
      order = 68.1,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"))
      end
    },
    class = {
      type = "multiselect",
      width = WeakAuras.normalWidth,
      name = L["Class"],
      values = WeakAuras.class_types,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and trigger.useClass) end,
      order = 68.2
    },
    classSpace = {
      type = "description",
      name = "",
      order = 68.3,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and not trigger.useClass) end
    },

    useUnitName = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Unit Name"],
      order = 68.4,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"))
      end
    },
    unitName = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["Filter by Unit Name"],
      desc = L["Filter formats: 'Name', 'Name-Realm', '-Realm'.\n\nSupports multiple entries, separated by commas\nCan use \\ to escape -."],
      order = 68.5,
      hidden = function()
        return not (trigger.type == "aura2"
                    and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and trigger.useUnitName)
      end
    },
    unitNameSpace = {
      type = "description",
      name = "",
      order = 68.5,
      width = WeakAuras.normalWidth,
      hidden = function()
        return not (trigger.type == "aura2"
                    and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and not trigger.useUnitName)
      end
    },

    useHostility = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Hostility"],
      order = 69.1,
      hidden = function()
        return not (trigger.type == "aura2"
                    and (trigger.unit == "group"
                         or trigger.unit == "raid"
                         or trigger.unit == "party"
                         or trigger.unit == "nameplate"))
      end
    },
    hostility = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Hostility"],
      values = OptionsPrivate.Private.hostility_types,
      hidden = function()
        return not (trigger.type == "aura2"
                    and trigger.useHostility
                    and (trigger.unit == "group"
                         or trigger.unit == "raid"
                         or trigger.unit == "party"
                         or trigger.unit == "nameplate"))
      end,
      order = 69.2
    },
    hostilitySpace = {
      type = "description",
      name = "",
      order = 69.3,
      width = WeakAuras.normalWidth,
      hidden = function()
        return not (trigger.type == "aura2"
                    and not trigger.useHostility
                    and (trigger.unit == "group"
                         or trigger.unit == "raid"
                         or trigger.unit == "party"
                         or trigger.unit == "nameplate"))
      end
    },

    useNpcId = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Filter by Npc ID"],
      order = 69.31,
      hidden = function() return
        not (trigger.type == "aura2" and (trigger.unit == "nameplate" or trigger.unit == "boss"))
      end
    },
    npcId = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["Npc ID"],
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "nameplate" or trigger.unit == "boss") and trigger.useNpcId) end,
      order = 69.32,
      desc = L["Supports multiple entries, separated by commas"]
    },
    npcIdSpace = {
      type = "description",
      name = "",
      order = 69.33,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "nameplate" or trigger.unit == "boss") and not trigger.useNpcId) end
    },

    ignoreSelf = {
      type = "toggle",
      name = L["Ignore Self"],
      order = 69.35,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party" or trigger.unit == "nameplate")) end
    },

    ignoreDead = {
      type = "toggle",
      name = L["Ignore Dead"],
      order = 69.4,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")) end
    },

    ignoreDisconnected = {
      type = "toggle",
      name = L["Ignore Disconnected"],
      order = 69.8,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")) end
    },
    inRange = {
      type = "toggle",
      name = L["Ignore out of casting range"],
      desc = L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."],
      order = 69.81,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and WeakAuras.IsRetail()) end
    },
    ignoreInvisible = {
      type = "toggle",
      name = L["Ignore out of checking range"],
      desc = L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."],
      order = 69.9,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "aura2" and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")) end
    },

    show_settings_header = {
      type = "header",
      name = L["Show and Clone Settings"],
      order = 69.91,
    },
    multi_unit_hint = {
      type = "description",
      order = 69.92,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "aura2" and IsGroupTrigger(trigger)) end,
      name = L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"],
    },
    useGroup_count = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Unit Count"],
      hidden = function() return not (trigger.type == "aura2" and IsGroupTrigger(trigger)) end,
      order = 70
    },
    useGroup_countSpace = {
      type = "description",
      name = "",
      order = 70.1,
      width = WeakAuras.normalWidth,
      hidden = function() return not (trigger.type == "aura2" and IsGroupTrigger(trigger) and not trigger.useGroup_count) end
    },
    group_countOperator = {
      type = "select",
      name = L["Operator"],
      desc = function()
        if (trigger.unit == "multi") then
          return L["Compare against the number of units affected."]
        else
          local groupType = OptionsPrivate.Private.unit_types_bufftrigger_2[trigger.unit or "group"] or "|cFFFF0000Error|r"
          return L["Group aura count description"]:format(groupType, groupType, groupType, groupType, groupType, groupType, groupType)
        end
      end,
      order = 70.2,
      width = WeakAuras.halfWidth,
      values = OptionsPrivate.Private.operator_types,
      hidden = function() return not (trigger.type == "aura2" and IsGroupTrigger(trigger) and trigger.useGroup_count) end,
      get = function() return trigger.group_countOperator end
    },
    group_count = {
      type = "input",
      name = L["Count"],
      desc = function()
        if (trigger.unit == "multi") then
          return L["Compare against the number of units affected."]
        else
          local groupType = OptionsPrivate.Private.unit_types_bufftrigger_2[trigger.unit or "group"] or "|cFFFF0000Error|r"
          return L["Group aura count description"]:format(groupType, groupType, groupType, groupType, groupType, groupType, groupType)
        end
      end,
      order = 70.3,
      width = WeakAuras.halfWidth,
      hidden = function() return not (trigger.type == "aura2" and IsGroupTrigger(trigger) and trigger.useGroup_count) end,
    },

    use_matchesShowOn = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show On"],
      order = 71,
      hidden = function() return not (trigger.type == "aura2" and not IsGroupTrigger(trigger)) end,
      get = function() return true end,
      disabled = true
    },
    matchesShowOn = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Show On"],
      values = OptionsPrivate.Private.bufftrigger_2_progress_behavior_types,
      order = 71.1,
      hidden = function() return not (trigger.type == "aura2" and not IsGroupTrigger(trigger)) end,
      get = function()
        return trigger.matchesShowOn or "showOnActive"
      end
    },
    useMatch_count = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Match Count"],
      hidden = function() return not (trigger.type == "aura2" and IsGroupTrigger(trigger)) end,
      order = 71.2
    },
    useMatch_countSpace = {
      type = "description",
      name = "",
      order = 71.3,
      width = WeakAuras.normalWidth,
      hidden = function()
        if trigger.type ~= "aura2" then
          return true
        end
        if IsGroupTrigger(trigger) then
          return trigger.useMatch_count
        else
          return trigger.matchesShowOn ~= "showOnMatches"
        end
      end
    },
    match_countOperator = {
      type = "select",
      name = L["Operator"],
      order = 71.4,
      width = WeakAuras.halfWidth,
      values = OptionsPrivate.Private.operator_types,
      hidden = function() return not (trigger.type == "aura2" and HasMatchCount(trigger)) end,
      desc = L["Counts the number of matches over all units."]
    },
    match_count = {
      type = "input",
      name = L["Count"],
      order = 71.5,
      width = WeakAuras.halfWidth,
      hidden = function() return not (trigger.type == "aura2" and HasMatchCount(trigger)) end,
      validate = ValidateNumeric,
      desc = L["Counts the number of matches over all units."]
    },
    useMatchPerUnit_count = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Match Count per Unit"],
      hidden = function() return not (trigger.type == "aura2" and IsGroupTrigger(trigger)
        and trigger.showClones and trigger.combinePerUnit and trigger.perUnitMode ~= "unaffected") end,
      order = 71.6
    },
    useMatchPerUnit_countSpace = {
      type = "description",
      name = "",
      order = 71.7,
      width = WeakAuras.normalWidth,
      hidden = function()
        if trigger.type == "aura2" and IsGroupTrigger(trigger)
          and trigger.showClones and trigger.combinePerUnit and trigger.perUnitMode ~= "unaffected" then
            return trigger.useMatchPerUnit_count
        end
        return true
      end
    },
    matchPerUnit_countOperator = {
      type = "select",
      name = L["Operator"],
      order = 71.8,
      width = WeakAuras.halfWidth,
      values = OptionsPrivate.Private.operator_types,
      hidden = function() return not (HasMatchPerUnitCount(trigger)) end,
      desc = L["Counts the number of matches per unit."]
    },
    matchPerUnit_count = {
      type = "input",
      name = L["Count"],
      order = 71.9,
      width = WeakAuras.halfWidth,
      hidden = function() return not (HasMatchPerUnitCount(trigger)) end,
      validate = ValidateNumeric,
      desc = L["Counts the number of matches per unit."]
    },
    showClones = {
      type = "toggle",
      name = L["Auto-Clone (Show All Matches)"],
      order = 72,
      hidden = function() return not (trigger.type == "aura2" and not IsSingleMissing(trigger)) end,
      width = WeakAuras.doubleWidth,
      set = function(info, v)
        trigger.showClones = v
        WeakAuras.Add(data)
      end
    },
    combinePerUnit = {
      type = "toggle",
      name = L["Combine Matches Per Unit"],
      width = WeakAuras.doubleWidth,
      order = 72.2,
      hidden = function()
        return not (trigger.type == "aura2" and IsGroupTrigger(trigger) and trigger.showClones)
      end
    },
    use_perUnitMode = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show Matches for Units"],
      order = 72.3,
      hidden = function()
        return not (trigger.type == "aura2" and IsGroupTrigger(trigger) and trigger.showClones and trigger.unit ~= "multi" and trigger.combinePerUnit)
      end,
      get = function() return true end,
      disabled = true
    },
    perUnitMode = {
      type = "select",
      name = L["Show Matches for"],
      values = OptionsPrivate.Private.bufftrigger_2_per_unit_mode,
      order = 72.4,
      width = WeakAuras.normalWidth,
      hidden = function()
        return not (trigger.type == "aura2" and IsGroupTrigger(trigger) and trigger.showClones and trigger.unit ~= "multi" and trigger.combinePerUnit)
      end,
      get = function()
        return trigger.perUnitMode or "affected"
      end
    },
    use_combineMode = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Preferred Match"],
      order = 72.5,
      hidden = function()
        if (trigger.type == "aura2") then
          if (IsGroupTrigger(trigger)) then
            if trigger.showClones then
              return not (trigger.combinePerUnit and trigger.perUnitMode ~= "unaffected")
            else
              return false
            end
          else
            return not (not IsSingleMissing(trigger) and not trigger.showClones)
          end
        end
        return true
      end,
      get = function() return true end,
      disabled = true
    },
    combineMode = {
      type = "select",
      name = L["Preferred Match"],
      values = OptionsPrivate.Private.bufftrigger_2_preferred_match_types,
      order = 72.6,
      width = WeakAuras.normalWidth,
      hidden = function()
        if (trigger.type == "aura2") then
          if (IsGroupTrigger(trigger)) then
            if trigger.showClones then
              return not (trigger.combinePerUnit and trigger.perUnitMode ~= "unaffected")
            else
              return false
            end
          else
            return not (not IsSingleMissing(trigger) and not trigger.showClones)
          end
        end
        return true
      end,
      get = function()
        return trigger.combineMode or "showLowest"
      end
    },
    unitExists = {
      type = "toggle",
      name = L["Show If Unit Does Not Exist"],
      width = WeakAuras.doubleWidth,
      order = 73,
      hidden = function()
        return not (trigger.type == "aura2" and trigger.unit ~= "player" and not IsGroupTrigger(trigger))
      end,
    },
  }

  -- Names
  local nameOptionSize = CountNames(data, triggernum, "auranames") + 1
  local spellOptionsSize = CountNames(data, triggernum, "auraspellids") + 1
  local ignoreNameOptionSize = CountNames(data, triggernum, "ignoreAuraNames") + 1
  local ignoreSpellOptionsSize = CountNames(data, triggernum, "ignoreAuraSpellids") + 1

  CreateNameOptions(aura_options, data, triggernum, nameOptionSize,
                    false, false, "name", 12, "useName", "auranames",
                    L["Aura Name"],
                    L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."],
                    IsSingleMissing(trigger))


  CreateNameOptions(aura_options, data, triggernum, spellOptionsSize,
                    true, false, "spellid", 22, "useExactSpellId", "auraspellids",
                    L["Spell ID"], L["Enter a Spell ID. You can use the addon idTip to determine spell ids."],
                    IsSingleMissing(trigger))

  CreateNameOptions(aura_options, data, triggernum, ignoreNameOptionSize,
                    false, true, "ignorename", 32, "useIgnoreName", "ignoreAuraNames",
                    L["Ignored Aura Name"],
                    L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."],
                    IsSingleMissing(trigger))

  CreateNameOptions(aura_options, data, triggernum, ignoreSpellOptionsSize,
                    true, true, "ignorespellid", 42, "useIgnoreExactSpellId", "ignoreAuraSpellids",
                    L["Ignored Spell ID"], L["Enter a Spell ID. You can use the addon idTip to determine spell ids."],
                    IsSingleMissing(trigger))

  OptionsPrivate.commonOptions.AddCommonTriggerOptions(aura_options, data, triggernum, true)
  OptionsPrivate.commonOptions.AddTriggerGetterSetter(aura_options, data, triggernum)
  OptionsPrivate.AddTriggerMetaFunctions(aura_options, data, triggernum)


  return {
    ["trigger." .. triggernum .. ".aura_options"] = aura_options
  }
end

WeakAuras.RegisterTriggerSystemOptions({"aura2"}, GetBuffTriggerOptions)

=== END OF FILE: WeakAurasOptions/BuffTrigger2.lua ===


=== FILE: WeakAurasOptions/Cache.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local pairs, error, coroutine = pairs, error, coroutine

-- WoW APIs
local IsSpellKnown = IsSpellKnown

---@class WeakAuras
local WeakAuras = WeakAuras

local spellCache = {}
WeakAuras.spellCache = spellCache

local cache
local metaData
local bestIcon = {}

-- Builds a cache of name/icon pairs from existing spell data
-- This is a rather slow operation, so it's only done once, and the result is subsequently saved
function spellCache.Build()
  if not cache  then
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end

  if not metaData.needsRebuild then
    return
  end

  local holes
  if WeakAuras.IsClassicEra() then
    holes = {}
    holes[63707] = 81743
    holes[81748] = 219002
    holes[219004] = 285223
    holes[285224] = 301088
    holes[301101] = 324269
    holes[474742] = 1213143
  elseif WeakAuras.IsCataClassic() then
    holes = {}
    holes[121820] = 158262
    holes[158263] = 186402
    holes[186403] = 219002
    holes[219004] = 243805
    holes[243806] = 261127
    holes[262591] = 281624
    holes[301101] = 324269
  elseif WeakAuras.IsMists() then
    holes = {}
    holes[171557] = 186402
    holes[186403] = 219002
    holes[219004] = 243805
    holes[243819] = 261127
    holes[262591] = 281624
    holes[301101] = 324269
    holes[473745] = 1214175
  elseif WeakAuras.IsRetail() then
    holes = {}
    holes[474771] = 556604
    holes[556606] = 936050
    holes[936051] = 1049295
    holes[1049296] = 1213133
  end
  wipe(cache)
  local co = coroutine.create(function()
    metaData.rebuilding = true
    local id = 0
    local misses = 0
    while misses < 80000 do
      id = id + 1
      local name = OptionsPrivate.Private.ExecEnv.GetSpellName(id)
      local icon = OptionsPrivate.Private.ExecEnv.GetSpellIcon(id)

      if(icon == 136243) then -- 136243 is the a gear icon, we can ignore those spells
        misses = 0;
      elseif name and name ~= "" and icon then
        cache[name] = cache[name] or {}

        if not cache[name].spells or cache[name].spells == "" then
          cache[name].spells = id .. "=" .. icon
        else
          cache[name].spells = cache[name].spells .. "," .. id .. "=" .. icon
        end
        misses = 0
      else
        misses = misses + 1
      end
      if holes and holes[id] then
        id = holes[id]
      end
      coroutine.yield(0.01, "spells")
    end

    if WeakAuras.IsCataOrMistsOrRetail() then
      for _, category in pairs(GetCategoryList()) do
        local total = GetCategoryNumAchievements(category, true)
        for i = 1, total do
          local id,name,_,_,_,_,_,_,_,iconID = GetAchievementInfo(category, i)
          if name and iconID then
            cache[name] = cache[name] or {}
            if not cache[name].achievements or cache[name].achievements == "" then
              cache[name].achievements = id .. "=" .. iconID
            else
              cache[name].achievements = cache[name].achievements .. "," .. id .. "=" .. iconID
            end
          end
          coroutine.yield(0.1, "achievements")
        end
        coroutine.yield(0.1, "categories")
      end
    end

    metaData.needsRebuild = false
    metaData.rebuilding = false
  end)
  OptionsPrivate.Private.Threads:Add("spellCache", co, 'background')
end

--[[ function to help find big holes in spellIds to help speedup Build()

local id = 0
local misses = 0
local lastId
print("####")
while misses < 4000000 do
   id = id + 1
   local spellInfo = C_Spell.GetSpellInfo(id)
   local name = spellInfo and spellInfo.name
   local icon = C_Spell.GetSpellTexture(id)
   if icon == 136243 then -- 136243 is the a gear icon, we can ignore those spells
      misses = 0
   elseif name and name ~= "" and icon then
      if misses > 10000 then
         print(("holes[%s] = %s"):format(lastId, id - 1))
      end
      lastId = id
      misses = 0
   else
      misses = misses + 1
   end
end
print("lastId", lastId)
]]

function spellCache.GetIcon(name)
  if (name == nil) then
    return nil;
  end
  if cache then
    if (bestIcon[name]) then
      return bestIcon[name]
    end

    local icons = cache[name]
    local bestMatch = nil
    if (icons) then
      if (icons.spells) then
        for spell, icon in icons.spells:gmatch("(%d+)=(%d+)") do
          local spellId = tonumber(spell)

          if not bestMatch or (spellId and spellId ~= 0 and IsSpellKnown(spellId)) then
            bestMatch = tonumber(icon)
          end
        end
      end
    elseif metaData.rebuilding then
      OptionsPrivate.Private.Threads:SetPriority('spellCache', 'normal')
    end

    bestIcon[name] = bestMatch
    return bestIcon[name]
  else
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end
end

function spellCache.GetSpellsMatching(name)
  if cache[name] then
    if cache[name].spells then
      local result = {}
      for spell, icon in cache[name].spells:gmatch("(%d+)=(%d+)") do
        local spellId = tonumber(spell)
        local iconId = tonumber(icon)
        result[spellId] = icon
      end
      return result
    end
  elseif metaData.rebuilding then
    OptionsPrivate.Private.Threads:SetPriority('spellCache', 'normal')
  end
end

function spellCache.AddIcon(name, id, icon)
  if not cache then
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
    return
  end

  if name and id and icon then
    cache[name] = cache[name] or {}
    if not cache[name].spells or cache[name].spells == "" then
      cache[name].spells = id .. "=" .. icon
    else
      cache[name].spells = cache[name].spells .. "," .. id .. "=" .. icon
    end
  end
end

function spellCache.Get()
  if cache then
    return cache
  else
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end
end

function spellCache.Load(data)
  metaData = data
  cache = metaData.spellCache

  local _, build = GetBuildInfo();
  local locale = GetLocale();
  local version = WeakAuras.versionString

  local num = 0;
  for i,v in pairs(cache) do
    num = num + 1;
  end

  if(num < 39000 or metaData.locale ~= locale or metaData.build ~= build
     or metaData.version ~= version or not metaData.spellCacheStrings)
  then
    metaData.build = build;
    metaData.locale = locale;
    metaData.version = version;
    metaData.spellCacheAchievements = true
    metaData.spellCacheStrings = true
    metaData.needsRebuild = true
    wipe(cache)
  end
end

-- This function computes the Levenshtein distance between two strings
-- It is used in this program to match spell icon textures with "good" spell names; i.e.,
-- spell names that are very similar to the name of the texture
local function Lev(str1, str2)
  local matrix = {};
  for i=0, str1:len() do
    matrix[i] = {[0] = i};
  end
  for j=0, str2:len() do
    matrix[0][j] = j;
  end
  for j=1, str2:len() do
    for i =1, str1:len() do
      if(str1:sub(i, i) == str2:sub(j, j)) then
        matrix[i][j] = matrix[i-1][j-1];
      else
        matrix[i][j] = math.min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1;
      end
    end
  end

  return matrix[str1:len()][str2:len()];
end

function spellCache.BestKeyMatch(nearkey)
  local bestKey = "";
  local bestDistance = math.huge;
  local partialMatches = {};
  if cache[nearkey] then
    return nearkey
  end
  for key, value in pairs(cache) do
    if key:lower() == nearkey:lower() then
      return key
    end
    if(key:lower():find(nearkey:lower(), 1, true)) then
      partialMatches[key] = value;
    end
  end
  for key, value in pairs(partialMatches) do
    local distance = Lev(nearkey, key);
    if(distance < bestDistance) then
      bestKey = key;
      bestDistance = distance;
    end
  end

  return bestKey;
end

---@param input string | number
---@return string name, number? id
function spellCache.CorrectAuraName(input)
  if (not cache) then
    error("spellCache has not been loaded. Call WeakAuras.spellCache.Load(...) first.")
  end

  local spellId = WeakAuras.SafeToNumber(input)
  if type(input) == "string" and input:find("|", nil, true) then
    spellId = WeakAuras.SafeToNumber(input:match("|Hspell:(%d+)"))
  end
  if(spellId) then
    local name, _, icon = OptionsPrivate.Private.ExecEnv.GetSpellInfo(spellId);
    if(name) then
      spellCache.AddIcon(name, spellId, icon)
      return name, spellId;
    else
      return "Invalid Spell ID", spellId;
    end
  else
    local ret = spellCache.BestKeyMatch(input);
    if(ret == "") then
      return "No Match Found", nil;
    else
      return ret, nil;
    end
  end
end

=== END OF FILE: WeakAurasOptions/Cache.lua ===


=== FILE: WeakAurasOptions/Changelog.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)
OptionsPrivate.changelog = {
  versionString = '5.20.5',
  dateString = '2025-10-09',
  fullChangeLogUrl = 'https://github.com/WeakAuras/WeakAuras2/compare/5.20.4...5.20.5',
  highlightText = [==[
]==],  commitText = [==[InfusOnWoW (13):

- Update Discord List
- BT2: Make the spell id tooltip in the options clickable
- Conditions: Tweak handling of custom function
- Totem trigger: Add spellId check and use slot information from event
- Boss Mod Count Conditions: Use same cron syntax as for the trigger
- Conditions: Properly escape string checks to support [].
- Update Atlas File List from wago.tools
- Update Discord List
- CLEU: Replace combobox with one entry with a disabled checkbox
- Fix inserting links into the display text boxes
- Fix regression for textured Ticks
- Revert "Revert "Fix KR/TW/CN large number formatting for >= 100.000.000""
- Update Discord List

Stanzilla (5):

- chore: update retail toc for 11.2.5
- Update WeakAurasModelPaths from wago.tools
- Update WeakAurasModelPaths from wago.tools
- Update WeakAurasModelPaths from wago.tools
- Update WeakAurasModelPaths from wago.tools

Veldt (1):

- Add Bleak Arrows to reset_ranged_swing_spells

dependabot[bot] (1):

- Bump leafo/gh-actions-lua from 11 to 12

mrbuds (2):

- Function for checking if we are on a Hardcore server doesn't exists on Retail
- Scary warning on import on Hardcore server

]==]
}
=== END OF FILE: WeakAurasOptions/Changelog.lua ===


=== FILE: WeakAurasOptions/CommonOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local commonOptionsCache = {}
OptionsPrivate.commonOptionsCache = commonOptionsCache
commonOptionsCache.data = {}

commonOptionsCache.GetOrCreateData = function(self, info)
  local base = self.data
  for i, key in ipairs(info) do
    base[key] = base[key] or {}
    base = base[key]
  end
  return base
end

commonOptionsCache.GetData = function(self, info)
  local base = self.data
  for i, key in ipairs(info) do
    if base[key] and type(base[key]) == "table" then
      base = base[key]
    else
      return nil
    end
  end
  return base
end

commonOptionsCache.SetSameAll = function(self, info, value)
  local base = self:GetOrCreateData(info)
  base.sameAll = value
end

commonOptionsCache.GetSameAll = function(self, info)
  local base = self:GetData(info)
  if base then
    return base.sameAll
  end
end

commonOptionsCache.SetNameAll = function(self, info, value)
  local base = self:GetOrCreateData(info)
  base.nameAll = value
end

commonOptionsCache.GetNameAll = function(self, info)
  local base = self:GetData(info)
  if base then
    return base.nameAll
  end
end

commonOptionsCache.Clear = function(self)
  self.data = {}
end


local parsePrefix = function(input, data, create)
  local subRegionIndex, property = string.match(input, "^sub%.(%d+)%..-%.(.+)")
  subRegionIndex = tonumber(subRegionIndex)
  if subRegionIndex then
    if create then
      data.subRegions = data.subRegions or {}
      data.subRegions[subRegionIndex] = data.subRegions[subRegionIndex] or {}
    else
      if not data.subRegions or not data.subRegions[subRegionIndex] then
        return nil
      end
    end
    return data.subRegions[subRegionIndex], property
  end
  local index = string.find(input, ".", 1, true);
  if (index) then
    return data, string.sub(input, index + 1);
  end
  return data, input
end

local function setFuncs(option, input)
  if type(input) == "function" then
    option.func = input
  else
    option.func = input.func
    option.disabled = input.disabled
  end
end

local function addCollapsibleHeader(options, key, input, order, isGroupTab)
  if input.__noHeader then
    return
  end
  local title = input.__title
  local hasAdd = input.__add
  local hasDelete = input.__delete
  local hasUp = input.__up
  local hasDown = input.__down
  local hasDuplicate = input.__duplicate
  local hasApplyTemplate = input.__applyTemplate
  local hasDynamicTextCodes = input.__dynamicTextCodes
  local defaultCollapsed = input.__collapsed
  local hiddenFunc = input.__hidden
  local notcollapsable = input.__notcollapsable
  local marginTop = input.__topLine
  local withoutheader = input.__withoutheader
  local isCollapsed = input.__isCollapsed
  local setCollapsed = input.__setCollapsed

  if not isCollapsed then
    isCollapsed = function()
      return OptionsPrivate.IsCollapsed("collapse", "region", key, defaultCollapsed)
    end
  end

  if not setCollapsed then
    setCollapsed = function(info, button, secondCall)
      if not notcollapsable and not secondCall then
        local isCollapsed = OptionsPrivate.IsCollapsed("collapse", "region", key, defaultCollapsed)
        OptionsPrivate.SetCollapsed("collapse", "region", key, not isCollapsed)
      end
    end
  end

  local titleWidth = WeakAuras.doubleWidth - (hasAdd and 0.15 or 0) - (hasDelete and 0.15 or 0)  - (hasUp and 0.15 or 0)
                     - (hasDown and 0.15 or 0) - (hasDuplicate and 0.15 or 0) - (hasApplyTemplate and 0.15 or 0) - (hasDynamicTextCodes and 0.15 or 0)

  options[key .. "collapseSpacer"] = {
    type = marginTop and "header" or "description",
    name = "",
    order = order,
    width = "full",
    hidden = hiddenFunc,
  }

  if not withoutheader then
    options[key .. "collapseButton"] = {
      type = "execute",
      name = title,
      order = order + 0.1,
      width = titleWidth,
      func = setCollapsed,
      image = function()
        if notcollapsable then
          return "Interface\\AddOns\\WeakAuras\\Media\\Textures\\bullet1", 18, 18
        else
          return isCollapsed() and "Interface\\AddOns\\WeakAuras\\Media\\Textures\\expand"
                                    or "Interface\\AddOns\\WeakAuras\\Media\\Textures\\collapse",
                                    18, 18
        end
      end,
      control = "WeakAurasExpand",
      hidden = hiddenFunc
    }

    if hasAdd then
      options[key .. "addButton"] = {
        type = "execute",
        name = L["Add"],
        order = order + 0.2,
        width = 0.15,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\add",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        hidden = hiddenFunc
      }
      setFuncs(options[key .. "addButton"], input.__add)
    end

    if hasUp then
      options[key .. "upButton"] = {
        type = "execute",
        name = L["Move Up"],
        order = order + 0.3,
        width = 0.15,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\moveup",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        hidden = hiddenFunc
      }
      setFuncs(options[key .. "upButton"], input.__up)
    end

    if hasDown then
      options[key .. "downButton"] = {
        type = "execute",
        name = L["Move Down"],
        order = order + 0.4,
        width = 0.15,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\movedown",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        hidden = hiddenFunc
      }
      setFuncs(options[key .. "downButton"], input.__down)
    end

    if hasDuplicate then
      options[key .. "duplicateButton"] = {
        type = "execute",
        name = L["Duplicate"],
        order = order + 0.5,
        width = 0.15,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\duplicate",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        hidden = hiddenFunc
      }
      setFuncs(options[key .. "duplicateButton"], input.__duplicate)
    end

    if hasDelete then
      options[key .. "deleteButton"] = {
        type = "execute",
        name = L["Delete"],
        order = order + 0.6,
        width = 0.15,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\delete",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        hidden = hiddenFunc
      }
      setFuncs(options[key .. "deleteButton"], input.__delete)
    end

    if hasApplyTemplate then
      options[key .. "applyTemplate"] = {
        type = "execute",
        name = L["Apply Template"],
        order = order + 0.7,
        width = 0.15,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\template",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        hidden = hiddenFunc
      }
      setFuncs(options[key .. "applyTemplate"], input.__applyTemplate)
    end

    if hasDynamicTextCodes then
      options[key .. "dynamicTextCodesButton"] = {
        type = "execute",
        name = L["Dynamic Text Replacements"],
        desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
        order = order + 0.8,
        width = 0.15,
        hidden = hiddenFunc,
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
      }
      setFuncs(options[key .. "dynamicTextCodesButton"], input.__dynamicTextCodes)
    end
  end

  if hiddenFunc then
    return function()
      return hiddenFunc() or isCollapsed()
    end
  else
    return isCollapsed
  end
end

local function copyOptionTable(input, orderAdjustment, collapsedFunc)
  local resultOption = CopyTable(input);
  resultOption.order = orderAdjustment + resultOption.order;
  if collapsedFunc then
    local oldHidden = resultOption.hidden;
    if oldHidden ~= nil then
      local oldFunc
      if type(oldHidden) ~= "function" then
        oldFunc = function(...) return oldHidden end
      else
        oldFunc = oldHidden
      end
      resultOption.hidden = function(...)
        if collapsedFunc() then
          return true
        else
          return oldFunc(...)
        end
      end
    else
      resultOption.hidden = collapsedFunc;
    end
  end
  return resultOption;
end

local flattenRegionOptions = function(allOptions, isGroupTab)
  local result = {};
  local base = 1000;

  for optionGroup, options in pairs(allOptions) do
    local groupBase = base * options.__order

    local collapsedFunc = addCollapsibleHeader(result, optionGroup, options, groupBase, isGroupTab)

    for optionName, option in pairs(options) do
      if not optionName:find("^__") then
        result[optionGroup .. "." .. optionName] = copyOptionTable(option, groupBase, collapsedFunc);
      end
    end
  end

  return result;
end

local function fixMetaOrders(allOptions)
  -- assumes that the results from create methods are contiguous in __order fields
  -- shifts __order fields such that each optionGroup is ordered correctly relative
  -- to its peers, but has a unique __order number in the combined option table.
  local groupOrders = {}
  local maxGroupOrder = 0
  for optionGroup, options in pairs(allOptions) do
    local metaOrder = options.__order
    groupOrders[metaOrder] = groupOrders[metaOrder] or {}
    maxGroupOrder = max(maxGroupOrder, metaOrder)
    tinsert(groupOrders[metaOrder], optionGroup)
  end

  local index = 0
  local newOrder = 1
  while index <= maxGroupOrder do
    index = index + 1
    if groupOrders[index] then
      table.sort(groupOrders[index])
      for _, optionGroup in ipairs(groupOrders[index]) do
        allOptions[optionGroup].__order = newOrder
        newOrder = newOrder + 1
      end
    end
  end
end

local function removeFuncs(intable, removeFunc)
  for i,v in pairs(intable) do
    if(i == "get" or i == "set" or i == "hidden" or i == "disabled") then
      intable[i] = nil;
    elseif (i == "func" and removeFunc) then
      intable[i] = nil
    elseif(type(v) == "table" and i ~= "values" and i ~= "extraFunctions") then
      removeFuncs(v, removeFunc)
    end
  end
end

local function getChildOption(options, info)
  for i=1,#info do
    options = options.args[info[i]];
    if not(options) then
      return nil;
    end

    if (options.hidden) then
      local type = type(options.hidden);
      if (type == "bool") then
        if (options.hidden) then
          return nil;
        end
      elseif (type == "function") then
        if (options.hidden(info)) then
          return nil;
        end
      end
    end
  end
  return options
end

local function hiddenChild(childOptionTable, info)
  for i=#childOptionTable,0,-1 do
    if(childOptionTable[i].hidden ~= nil) then
      if(type(childOptionTable[i].hidden) == "boolean") then
        return childOptionTable[i].hidden;
      elseif(type(childOptionTable[i].hidden) == "function") then
        return childOptionTable[i].hidden(info);
      end
    end
  end
  return false;
end

local function CreateHiddenAll(subOption)
  return function(data, info)
    local mainOptions = OptionsPrivate.EnsureOptions(data, subOption)
    for i=1,#info do
      mainOptions = mainOptions.args[info[i]];
    end

    if(#data.controlledChildren == 0) then
      if mainOptions.hiddenAllIfAnyHidden then
        return false
      else
        return true
      end
    end

    for child in  OptionsPrivate.Private.TraverseLeafs(data) do
      local childOptions = OptionsPrivate.EnsureOptions(child, subOption)
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end
      if (childOption) then
        local childHidden = hiddenChild(childOptionTable, info)
        if mainOptions.hiddenAllIfAnyHidden then
          if childHidden then
            return true
          end
        else
          if not childHidden then
            return false
          end
        end
      end
    end

    if mainOptions.hiddenAllIfAnyHidden then
      return false
    else
      return true
    end
  end
end

local function disabledChild(childOptionTable, info)
  for i=#childOptionTable,0,-1 do
    if(childOptionTable[i].disabled ~= nil) then
      if(type(childOptionTable[i].disabled) == "boolean") then
        return childOptionTable[i].disabled;
      elseif(type(childOptionTable[i].disabled) == "function") then
        return childOptionTable[i].disabled(info);
      end
    end
  end
  return false;
end

local function CreateDisabledAll(subOption)
  return function(data, info)
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local childOptions = OptionsPrivate.EnsureOptions(child, subOption);
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end
      if (childOption) then
        if (not disabledChild(childOptionTable, info)) then
          return false;
        end
      end
    end

    return true;
  end
end

local function disabledOrHiddenChild(childOptionTable, info)
  return hiddenChild(childOptionTable, info) or disabledChild(childOptionTable, info);
end


local function replaceNameDescFuncs(intable, data, subOption)
  local function compareTables(tableA, tableB)
    if(#tableA == #tableB) then
      for j=1,#tableA do
        if(type(tableA[j]) == "number" and type(tableB[j]) == "number") then
          if((math.floor(tableA[j] * 100) / 100) ~= (math.floor(tableB[j] * 100) / 100)) then
            return false;
          end
        else
          if(tableA[j] ~= tableB[j]) then
            return false;
          end
        end
      end
    else
      return false;
    end
    return true;
  end

  local function getValueFor(options, info, key)
    local childOptionTable = {[0] = options};
    for i=1,#info do
      options = options.args[info[i]];
      if (not options) then
        return nil;
      end
      childOptionTable[i] = options;
    end

    if (disabledOrHiddenChild(childOptionTable, info)) then
      return nil;
    end

    for i=#childOptionTable,0,-1 do
      if(childOptionTable[i][key]) then
        return childOptionTable[i][key];
      end
    end
    return nil;
  end

  local function combineKeys(info)
    local combinedKeys = nil;
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local values = getValueFor(OptionsPrivate.EnsureOptions(child, subOption), info, "values");
      if (values) then
        if (type(values) == "function") then
          values = values(info);
        end
        if (type(values) == "table") then
          combinedKeys = combinedKeys or {};
          for k, v in pairs(values) do
            combinedKeys[k] = v;
          end
        end
      end
    end
    return combinedKeys;
  end

  local function regionPrefix(input)
    local index = string.find(input, ".", 1, true);
    if (index) then
      local regionType = string.sub(input, 1, index - 1);
      return OptionsPrivate.Private.regionOptions[regionType] and regionType;
    end
    return nil;
  end

  local function sameAll(info)
    local cached = commonOptionsCache:GetSameAll(info)
    if (cached ~= nil) then
      return cached
    end

    local combinedValues = {};
    local first = true;
    local combinedKeys = combineKeys(info);

    local isToggle = nil

    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      if isToggle == nil then
        local childOption = getChildOption(OptionsPrivate.EnsureOptions(child, subOption), info)
        isToggle = childOption and childOption.type == "toggle"
      end

      local regionType = regionPrefix(info[#info]);
      if(child and (not regionType or child.regionType == regionType or regionType == "sub")) then
        local childOptions = OptionsPrivate.EnsureOptions(child, subOption)
        local get = getValueFor(childOptions, info, "get");
        if (combinedKeys) then
          for key, _ in pairs(combinedKeys) do
            local values = {};
            if (get) then
              values = { get(info, key) };
            end
            if (combinedValues[key] == nil) then
              combinedValues[key] = values;
            else
              if (not compareTables(combinedValues[key], values)) then
                commonOptionsCache:SetSameAll(info, false)
                return nil;
              end
            end
          end
        else
          local values = {};
          if (get) then
            values = { get(info) };
            if isToggle and values[1] == nil then
              values[1] = false
            end
          end
          if(first) then
            combinedValues = values;
            first = false;
          else
            if (not compareTables(combinedValues, values)) then
              commonOptionsCache:SetSameAll(info, false)
              return nil;
            end
          end
        end
      end
    end

    commonOptionsCache:SetSameAll(info, true)
    return true;
  end

  local function nameAll(info)
    local cached = commonOptionsCache:GetNameAll(info)
    if (cached ~= nil) then
      return cached
    end

    local combinedName;
    local first = true;
    local foundNames = {};
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local childOption = getChildOption(OptionsPrivate.EnsureOptions(child, subOption), info);
      if (childOption) then
        local name;
        if(type(childOption.name) == "function") then
          name = childOption.name(info);
        else
          name = childOption.name;
          commonOptionsCache:SetNameAll(info, name)
          return name
        end
        if (not name) then
        -- Do nothing
        elseif(first) then
          if (name ~= "") then
            combinedName = name;
            first = false;
          end
          foundNames[name] = true;
        elseif not(foundNames[name]) then
          if (name ~= "") then
            if (childOption.type == "description") then
              combinedName = combinedName .. "\n\n" .. name;
            else
              combinedName = combinedName .. " / " .. name;
            end
          end
          foundNames[name] = true;
        end
      end
    end
    if combinedName then
      commonOptionsCache:SetNameAll(info, combinedName)
    end

    return combinedName or ""
  end

  local function descAll(info)
    local combinedDesc;
    local first = true;
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local childOption = getChildOption(OptionsPrivate.EnsureOptions(child, subOption), info);
      if (childOption) then
        local desc;
        if(type(childOption.desc) == "function") then
          desc = childOption.desc(info);
        else
          desc = childOption.desc;
        end
        if(first) then
          combinedDesc = desc;
          first = false;
        elseif not(combinedDesc == desc) then
          return L["Not all children have the same value for this option"];
        end
      end
    end
    return combinedDesc;
  end

  local function recurse(intable)
    for i,v in pairs(intable) do
      if(i == "name" and type(v) ~= "table") then
        intable.name = function(info)
          local name = nameAll(info);
          if(sameAll(info)) then
            return name;
          else
            if(name == "") then
              return name;
            else
              return "|cFF4080FF"..(name or "error").."|r";
            end
          end
        end
        intable.desc = function(info)
          if(sameAll(info)) then
            return descAll(info);
          else
            local combinedKeys = nil;
            if (intable.type == "multiselect") then
              combinedKeys = combineKeys(info)
            end

            local values = {};
            for child in OptionsPrivate.Private.TraverseLeafs(data) do
              local childOptions = OptionsPrivate.EnsureOptions(child, subOption)
              local childOption = childOptions;
              local childOptionTable = {[0] = childOption};
              for i=1,#info do
                childOption = childOption.args[info[i]];
                childOptionTable[i] = childOption;
              end
              if (childOption and not hiddenChild(childOptionTable, info)) then
                for i=#childOptionTable,0,-1 do
                  if(childOptionTable[i].get) then
                    if(intable.type == "toggle") then
                      local name, tri;
                      if(type(childOption.name) == "function") then
                        name = childOption.name(info);
                        tri = true;
                      else
                        name = childOption.name;
                      end
                      if(tri and childOptionTable[i].get(info)) then
                        tinsert(values, "|cFFE0E000"..child.id..": |r"..name);
                      elseif(tri) then
                        tinsert(values, "|cFFE0E000"..child.id..": |r"..L["Ignored"]);
                      elseif(childOptionTable[i].get(info)) then
                        tinsert(values, "|cFFE0E000"..child.id..": |r|cFF00FF00"..L["Enabled"].."|r");
                      else
                        tinsert(values, "|cFFE0E000"..child.id..": |r|cFFFF0000"..L["Disabled"].."|r");
                      end
                    elseif(intable.type == "color") then
                      local r, g, b = childOptionTable[i].get(info);
                      r, g, b = r or 1, g or 1, b or 1;
                      tinsert(values, ("|cFF%2x%2x%2x%s|r"):format(r * 220 + 35, g * 220 + 35, b * 220 + 35, child.id));
                    elseif(intable.type == "select") then
                      local selectValues = type(intable.values) == "table" and intable.values or intable.values(info);
                      local key = childOptionTable[i].get(info);
                      local display = key and selectValues[key] or L["None"];
                      if intable.dialogControl == "LSM30_Font" then
                        tinsert(values, "|cFFE0E000"..child.id..": |r" .. key);
                      else
                        if type(display) == "string" then
                          tinsert(values, "|cFFE0E000"..child.id..": |r"..display);
                        elseif type(display) == "table" then
                          tinsert(values, "|cFFE0E000"..child.id..": |r"..display[1].."/"..display[2] );
                        end
                      end
                    elseif(intable.type == "multiselect") then
                      local selectedValues = {};
                      for k, v in pairs(combinedKeys) do
                        if (childOptionTable[i].get(info, k)) then
                          tinsert(selectedValues, tostring(v))
                        end
                      end
                      tinsert(values, "|cFFE0E000"..child.id..": |r"..table.concat(selectedValues, ","));
                    else
                      local display = childOptionTable[i].get(info) or L["None"];
                      if(type(display) == "number") then
                        display = math.floor(display * 100) / 100;
                      else
                        local nullBytePos = display:find("\0", nil, true)
                        if nullBytePos then
                          display = display:sub(1, nullBytePos - 1)
                        end

                        if #display > 50 then
                          display = display:sub(1, 50) .. "..."
                        end
                      end
                      tinsert(values, "|cFFE0E000"..child.id..": |r"..display);
                    end
                    break;
                  end
                end
              end
            end
            return table.concat(values, "\n");
          end
        end
      elseif(type(v) == "table" and i ~= "values") then
        recurse(v);
      end
    end
  end
  recurse(intable);
end

local function replaceImageFuncs(intable, data, subOption)
  local function imageAll(info)
    local combinedImage = {};
    local first = true;
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local childOption = OptionsPrivate.EnsureOptions(child, subOption)
      if not(childOption) then
        return "error"
      end
      childOption = getChildOption(childOption, info);
      if childOption and childOption.image then
        local image = {childOption.image(info)};
        if(first) then
          combinedImage = image;
          first = false;
        else
          if not(combinedImage[1] == image[1]) then
            return "", 0, 0;
          end
        end
      end
    end

    return unpack(combinedImage);
  end

  local function recurse(intable)
    for i,v in pairs(intable) do
      if(i == "image" and type(v) == "function") then
        intable[i] = imageAll;
      elseif(type(v) == "table" and i ~= "values") then
        recurse(v);
      end
    end
  end
  recurse(intable);
end

local concatenableTypes = {
  string = true,
  number = true
}
local function isConcatenableValue(value)
  return value and concatenableTypes[type(value)]
end
local function replaceValuesFuncs(intable, data, subOption)
  local function valuesAll(info)
    local combinedValues = {};
    local handledValues = {};
    local first = true;
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local childOption = OptionsPrivate.EnsureOptions(child, subOption)
      if not(childOption) then
        return "error"
      end

      childOption = getChildOption(childOption, info);
      if (childOption) then
        local values = childOption.values;
        if (type(values) == "function") then
          values = values(info);
        end
        if(first) then
          for k, v in pairs(values) do
            handledValues[k] = handledValues[k] or {};
            handledValues[k][v] = true;
            combinedValues[k] = v;
          end
          first = false;
        else
          for k, v in pairs(values) do
            if (handledValues[k] and handledValues[k][v]) then
            -- Already known key/value pair
            else
              if (combinedValues[k]) then
                if isConcatenableValue(k) and isConcatenableValue(v) then
                  combinedValues[k] = combinedValues[k] .. "/" .. v;
                end
              else
                combinedValues[k] = v;
              end
              handledValues[k] = handledValues[k] or {};
              handledValues[k][v] = true;
            end
          end
        end
      end
    end

    return combinedValues;
  end

  local function recurse(intable)
    for i,v in pairs(intable) do
      if(i == "values" and type(v) == "function") then
        intable[i] = valuesAll;
      elseif(type(v) == "table" and i ~= "values") then
        recurse(v);
      end
    end
  end
  recurse(intable);
end

local getHelper = {
  first = true,
  combinedValues = {},
  same = true,
  Set = function(self, values)
    if self.same == false then
      return false
    end
    if(self.first) then
      self.combinedValues = values;
      self.first = false;
      return true
    else
      if(#self.combinedValues == #values) then
        for j=1,#self.combinedValues do
          if(type(self.combinedValues[j]) == "number" and type(values[j]) == "number") then
            if((math.floor(self.combinedValues[j] * 100) / 100) ~= (math.floor(values[j] * 100) / 100)) then
              self.same = false;
              break;
            end
          else
            if(self.combinedValues[j] ~= values[j]) then
              self.same = false;
              break;
            end
          end
        end
      else
        self.same = false;
      end
      return self.same
    end
  end,
  Get = function(self)
    return self.combinedValues
  end,
  GetSame = function(self)
    return self.same
  end,
  HasValue = function(self)
    return not self.first
  end
}


local function CreateGetAll(subOption)
  return function(data, info, ...)
    local isToggle = nil
    local isColor = nil

    local allChildren = CopyTable(getHelper)
    local enabledChildren = CopyTable(getHelper)
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      if isToggle == nil or isColor == nil then
        local childOptions = getChildOption(OptionsPrivate.EnsureOptions(child, subOption), info)
        isToggle = childOptions and childOptions.type == "toggle"
        isColor = childOptions and childOptions.type == "color"
      end


      local childOptions = OptionsPrivate.EnsureOptions(child, subOption)
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end
      if (childOption) then
        for i=#childOptionTable,0,-1 do
          if(childOptionTable[i].get) then
            local values = {childOptionTable[i].get(info, ...)};
            if isToggle and values[1] == nil then
              values[1] = false
            end

            allChildren:Set(values)
            if not disabledOrHiddenChild(childOptionTable, info) then
                enabledChildren:Set(values)
            end

            if not allChildren:GetSame() and not enabledChildren:GetSame() then
              if isColor then
                return 0, 0, 0, 1
              end
              return nil;
            end
            break;
          end
        end
      end
    end

    if enabledChildren:HasValue() then
      return unpack(enabledChildren:Get())
    else
      -- This can happen if all children are disabled
      return unpack(allChildren:Get())
    end
  end
end

local function CreateSetAll(subOption, getAll)
  return function(data, info, ...)
    OptionsPrivate.Private.pauseOptionsProcessing(true);
    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
    local before = getAll(data, info, ...)
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local childOptions = OptionsPrivate.EnsureOptions(child, subOption)
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end

      if (childOption and not disabledOrHiddenChild(childOptionTable, info)) then
        for i=#childOptionTable,0,-1 do
          local optionTable = childOptionTable[i]
          if(optionTable.set) then
            if (optionTable.type == "multiselect") then
              local newValue
              if optionTable.multiTristate then
                if before == true then
                  newValue = false
                elseif before == false then
                  newValue = nil
                elseif before == nil then
                  newValue = true
                end
              else
                newValue = not before
              end
              optionTable.set(info, ..., newValue)
            else
              optionTable.set(info, ...);
            end
            break;
          end
        end
      end
    end

    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
    OptionsPrivate.Private.pauseOptionsProcessing(false);
    OptionsPrivate.Private.ScanForLoads();
    OptionsPrivate.SortDisplayButtons(nil, true);
    OptionsPrivate.UpdateOptions()
  end
end

local function CreateExecuteAll(subOption)
  return function(data, info, button)
    local secondCall = nil
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      local childOptions = OptionsPrivate.EnsureOptions(child, subOption)
      local childOption = childOptions;
      local childOptionTable = {[0] = childOption};
      for i=1,#info do
        childOption = childOption.args[info[i]];
        childOptionTable[i] = childOption;
      end

      if (childOption and not disabledOrHiddenChild(childOptionTable, info)) then
        -- Some functions, that is the expand/collapse functions need to be
        -- effectively called only once. Passing in the secondCall parameter allows
        -- them to distinguish between the first and every other call
        childOption.func(info, button, secondCall)
        secondCall = true
      end
    end
    WeakAuras.ClearAndUpdateOptions(data.id)
  end
end

local function ProgressOptions(data)
  local order = 1
  local options = {
    __title = L["Progress Settings"],
    __order = 98,
    __collapsed = true
  }

  options.progressSource = {
    type = "select",
    width = WeakAuras.doubleWidth,
    name = L["Progress Source"],
    order = order,
    control = "WeakAurasTwoColumnDropdown",
    values = OptionsPrivate.Private.GetProgressSourcesForUi(data),
    get = function(info)
      return OptionsPrivate.Private.GetProgressValueConstant(data.progressSource)
    end,
    set = function(info, value)
      if value then
        data.progressSource = data.progressSource or {}
        -- Copy only trigger + property
        data.progressSource[1] = value[1]
        data.progressSource[2] = value[2]
      else
        data.progressSource = nil
      end
      WeakAuras.Add(data)
    end
  }

  options.progressSourceWarning = {
    type = "description",
    width = WeakAuras.doubleWidth,
    name = L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""],
    order = order + 0.5,
    hidden = function()
      local progressSource = OptionsPrivate.Private.AddProgressSourceMetaData(data, data.progressSource)
      -- Auto progress, Manual Progress or the progress source has a total property
      if not progressSource or progressSource[2] == "auto" or progressSource[1] == 0 or progressSource[4] ~= nil then
        return true
      end
      return false
    end
  }

  local function hiddenManual()
    if data.progressSource and data.progressSource[1] == 0 then
      return false
    end
    return true
  end

  options.progressSourceManualValue = {
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    name = L["Value"],
    order = order + 0.7,
    min = 0,
    softMax = 100,
    bigStep = 1,
    hidden = hiddenManual,
    get = function(info)
      return data.progressSource and data.progressSource[3] or 0
    end,
    set = function(info, value)
      data.progressSource = data.progressSource or {}
      data.progressSource[3] = value
      WeakAuras.Add(data)
    end
  }

  options.progressSourceManualTotal = {
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    name = L["Total"],
    order = order + 0.8,
    min = 0,
    softMax = 100,
    bigStep = 1,
    hidden = hiddenManual,
    get = function(info)
      return data.progressSource and data.progressSource[4] or 100
    end,
    set = function(info, value)
      data.progressSource = data.progressSource or {}
      data.progressSource[4] = value
      WeakAuras.Add(data)
    end
  }

  options.useAdjustededMin = {
    type = "toggle",
    width = WeakAuras.normalWidth,
    name = L["Set Minimum Progress"],
    desc = L["Values/Remaining Time below this value are displayed as zero progress."],
    order = order + 1,
    set = function(info, value)
      data.useAdjustededMin = value
      if not value then
        data.adjustedMin = ""
      end
      WeakAuras.Add(data)
    end
  };

  options.adjustedMin = {
    type = "input",
    validate = WeakAuras.ValidateNumericOrPercent,
    width = WeakAuras.normalWidth,
    order = order + 2,
    name = L["Minimum"],
    hidden = function() return not data.useAdjustededMin end,
    desc = L["Enter static or relative values with %"]
  };

  options.useAdjustedMinSpacer = {
    type = "description",
    width = WeakAuras.normalWidth,
    name = "",
    order = order + 3,
    hidden = function() return not (not data.useAdjustededMin and data.useAdjustededMax) end,
  }

  options.useAdjustededMax = {
    type = "toggle",
    width = WeakAuras.normalWidth,
    name = L["Set Maximum Progress"],
    desc = L["Values/Remaining Time above this value are displayed as full progress."],
    order = order + 4,
    set = function(info, value)
      data.useAdjustededMax = value
      if not value then
        data.adjustedMax = ""
      end
      WeakAuras.Add(data)
    end
  }

  options.adjustedMax = {
    type = "input",
    width = WeakAuras.normalWidth,
    validate = WeakAuras.ValidateNumericOrPercent,
    order = order + 5,
    name = L["Maximum"],
    hidden = function() return not data.useAdjustededMax end,
    desc = L["Enter static or relative values with %"]
  }

  options.useAdjustedMaxSpacer = {
    type = "description",
    width = WeakAuras.normalWidth,
    name = "",
    order = order + 6,
    hidden = function() return not (data.useAdjustededMin and not data.useAdjustededMax) end,
  }

  return options
end

local function PositionOptions(id, data, _, hideWidthHeight, disableSelfPoint, group)
  local metaOrder = 99
  local function IsParentDynamicGroup()
    if data.parent then
      local parentData = WeakAuras.GetData(data.parent)
      return parentData and parentData.regionType == "dynamicgroup"
    end
  end

  local function IsGroupByFrame()
    return data.regionType == "dynamicgroup" and data.useAnchorPerUnit
  end

  local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;
  local positionOptions = {
    __title = L["Position and Size Settings"],
    __order = metaOrder,
    __collapsed = true,
    width = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Width"],
      order = 60,
      min = 1,
      softMax = screenWidth,
      max = 4 * screenWidth,
      bigStep = 1,
      hidden = hideWidthHeight,
    },
    height = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Height"],
      order = 61,
      min = 1,
      softMax = screenHeight,
      max = 4 * screenHeight,
      bigStep = 1,
      hidden = hideWidthHeight,
    },
    anchorFrameType = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Anchored To"],
      order = 70,
      hidden = function()
        return IsParentDynamicGroup() or IsGroupByFrame()
      end,
      values = (data.regionType == "group" or data.regionType == "dynamicgroup")
                and OptionsPrivate.Private.anchor_frame_types_group
                or OptionsPrivate.Private.anchor_frame_types,
      sorting = OptionsPrivate.Private.SortOrderForValues(
                (data.regionType == "group" or data.regionType == "dynamicgroup")
                and OptionsPrivate.Private.anchor_frame_types_group
                or OptionsPrivate.Private.anchor_frame_types),
    },
    anchorFrameParent = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Set Parent to Anchor"],
      desc = L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."],
      order = 71,
      get = function()
        return data.anchorFrameParent or data.anchorFrameParent == nil;
      end,
      hidden = function()
        return not IsGroupByFrame() and (data.anchorFrameType == "SCREEN" or data.anchorFrameType == "UIPARENT" or data.anchorFrameType == "MOUSE" or IsParentDynamicGroup());
      end,
    },
    anchorFrameSpaceOne = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = "",
      order = 72,
      image = function() return "", 0, 0 end,
      hidden = function()
        return IsParentDynamicGroup() or not (data.anchorFrameType == "SCREEN" or data.anchorFrameType == "UIPARENT" or data.anchorFrameType == "MOUSE" or IsGroupByFrame())
      end,
    },
    -- Input field to select frame to anchor on
    anchorFrameFrame = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["Frame"],
      order = 73,
      hidden = function()
        if (IsParentDynamicGroup() or IsGroupByFrame()) then
          return true;
        end
        return not (data.anchorFrameType == "SELECTFRAME")
      end
    },
    -- Button to select frame to anchor on
    chooseAnchorFrameFrame = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = L["Choose"],
      order = 74,
      hidden = function()
        if (IsParentDynamicGroup() or IsGroupByFrame()) then
          return true;
        end
        return not (data.anchorFrameType == "SELECTFRAME")
      end,
      func = function()
        OptionsPrivate.StartFrameChooser(data, {"anchorFrameFrame"});
      end
    },
    selfPoint = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Anchor"],
      order = 75,
      hidden = IsParentDynamicGroup,
      values = OptionsPrivate.Private.point_types,
      disabled = disableSelfPoint,
      control = "WeakAurasAnchorButtons",
    },
    anchorPoint = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = function()
        if (data.anchorFrameType == "SCREEN" or data.anchorFrameType == "UIPARENT") then
          return L["To Screen's"]
        elseif (data.anchorFrameType == "PRD") then
          return L["To Personal Ressource Display's"];
        else
          return L["To Frame's"];
        end
      end,
      order = 76,
      hidden = function()
        if (data.parent) then
          if IsGroupByFrame() then
            return false
          end
          if IsParentDynamicGroup() then
            return true
          end
          return data.anchorFrameType == "SCREEN" or data.anchorFrameType == "MOUSE";
        else
          return data.anchorFrameType == "MOUSE";
        end
      end,
      values = OptionsPrivate.Private.point_types,
      control = "WeakAurasAnchorButtons",
    },
    anchorPointGroup = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["To Group's"],
      order = 77,
      hidden = function()
        if IsGroupByFrame() then
          return true
        end
        if (data.anchorFrameType ~= "SCREEN") then
          return true;
        end
        if (data.parent) then
          return IsParentDynamicGroup();
        end
        return true;
      end,
      disabled = true,
      values = {["CENTER"] = L["Anchor Point"]},
      get = function() return "CENTER"; end,
      control = "WeakAurasAnchorButtons",
    },
    anchorFramePoints = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = "",
      order = 78,
      image = function() return "", 0, 0 end,
      hidden = function()
        return not (data.anchorFrameType == "MOUSE") or IsParentDynamicGroup();
      end
    },
    xOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      name = L["X Offset"],
      order = 79,
      width = WeakAuras.normalWidth,
      softMin = (-1 * screenWidth),
      min = (-4 * screenWidth),
      softMax = screenWidth,
      max = 4 * screenWidth,
      bigStep = 10,
      get = function() return data.xOffset end,
      set = function(info, v)
        data.xOffset = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
        OptionsPrivate.Private.AddParents(data)
      end
    },
    yOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      name = L["Y Offset"],
      order = 80,
      width = WeakAuras.normalWidth,
      softMin = (-1 * screenHeight),
      min = (-4 * screenHeight),
      softMax = screenHeight,
      max = 4 * screenHeight,
      bigStep = 10,
      get = function() return data.yOffset end,
      set = function(info, v)
        data.yOffset = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
        OptionsPrivate.Private.AddParents(data)
      end
    },
    frameStrata = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Frame Strata"],
      order = 81,
      values = OptionsPrivate.Private.frame_strata_types
    },
    anchorFrameSpace = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = "",
      order = 82,
      image = function() return "", 0, 0 end,
      hidden = function()
        return not (data.anchorFrameType ~= "SCREEN" or data.anchorFrameType ~= "UIPARENT" or IsParentDynamicGroup());
      end
    },
  };

  OptionsPrivate.commonOptions.AddCodeOption(positionOptions, data, L["Custom Anchor"], "custom_anchor",
                      "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-anchor-function",
                      71.5, function() return not(data.anchorFrameType == "CUSTOM" and not IsParentDynamicGroup() and not IsGroupByFrame()) end,
                      {"customAnchor"}, false, { setOnParent = group })
  return positionOptions;
end

--- @type fun(data: auraData, options: table, startOrder: number, areaAnchors: table, pointAnchors: table)
local function PositionOptionsForSubElement(data, options, startOrder, areaAnchors, pointAnchors)
  options.anchor_mode = {
    name = L["Anchor Mode"],
    type = "select",
    width = WeakAuras.normalWidth,
    order = startOrder,
    values = OptionsPrivate.Private.anchor_mode,
  }

  options.anchor_area = {
    name = L["Area"],
    type = "select",
    width = WeakAuras.normalWidth,
    control = "WeakAurasTwoColumnDropdown",
    order = startOrder + 0.1,
    values = areaAnchors,
    hidden = function()
      return data.anchor_mode == "point"
    end
  }

  options.anchor_space = {
    name = "",
    type = "description",
    order = startOrder + 0.2,
    hidden = function()
      return data.anchor_mode == "area"
    end
  }

  options.self_point = {
    name = L["Anchor"],
    type = "select",
    width = WeakAuras.normalWidth,
    control = "WeakAurasTwoColumnDropdown",
    order = startOrder + 0.3,
    values = OptionsPrivate.Private.point_types,
    hidden = function()
      return data.anchor_mode == "area"
    end
  }

  options.anchor_point = {
    name = L["To Region's"],
    type = "select",
    width = WeakAuras.normalWidth,
    control = "WeakAurasTwoColumnDropdown",
    order = startOrder + 0.4,
    values = pointAnchors,
    hidden = function()
      return data.anchor_mode == "area"
    end
  }

  options.width = {
    name = L["Width"],
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    min = 0,
    softMax = 200,
    step = 1,
    order = startOrder + 0.5,
    hidden = function()
      return data.anchor_mode == "area"
    end
  }

  options.height = {
    name = L["Height"],
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    min = 0,
    softMax = 200,
    step = 1,
    order = startOrder + 0.6,
    hidden = function()
      return data.anchor_mode == "area"
    end
  }

  options.xOffset = {
    type = "range",
    control = "WeakAurasSpinBox",
    name = function()
      if data.anchor_mode == "area" then
        return L["Extra Width"]
      else
        return L["X Offset"]
      end
    end,
    order = startOrder + 0.7,
    width = WeakAuras.normalWidth,
    softMin = -200,
    softMax = 200,
    step = 1,
  }

  options.yOffset = {
    type = "range",
    control = "WeakAurasSpinBox",
    name = function()
      if data.anchor_mode == "area" then
        return L["Extra Height"]
      else
        return L["Y Offset"]
      end
    end,
    order = startOrder + 0.8,
    width = WeakAuras.normalWidth,
    softMin = -200,
    softMax = 200,
    step = 1,
  }
end

--- @type fun(parentData: auraData, data: table, options: table, startOrder: number)
local function ProgressOptionsForSubElement(parentData, data, options, startOrder, progressSourceHidden)
  options.progress_source = {
    type = "select",
    width = WeakAuras.doubleWidth,
    name = L["Progress Source"],
    order = startOrder,
    control = "WeakAurasTwoColumnDropdown",
    values = OptionsPrivate.Private.GetProgressSourcesForUi(parentData, true),
    get = function(info)
      return OptionsPrivate.Private.GetProgressValueConstant(data.progressSource or {-2, ""})
    end,
    set = function(info, value)
      if value then
        data.progressSource = data.progressSource or {}
        -- Copy only trigger + property
        data.progressSource[1] = value[1]
        data.progressSource[2] = value[2]
      else
        data.progressSource = nil
      end
      WeakAuras.Add(parentData)
    end,
    hidden = progressSourceHidden
  }

  options.progressSourceWarning = {
    type = "description",
    width = WeakAuras.doubleWidth,
    name = L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""],
    order = startOrder + 0.1,
    hidden = function()
      if type(progressSourceHidden) == "function" and progressSourceHidden() then
        return true
      end
      local progressSource = OptionsPrivate.Private.AddProgressSourceMetaData(parentData, data.progressSource)
      -- Auto progress, Manual Progress or the progress source has a total property
      if not progressSource or progressSource[2] == "auto" or progressSource[1] == 0 or progressSource[4] ~= nil then
        return true
      end
      return false
    end,
  }

  local function hiddenManual()
    if type(progressSourceHidden) == "function" and progressSourceHidden() then
      return true
    end
    if data.progressSource and data.progressSource[1] == 0 then
      return false
    end
    return true
  end

  options.progressSourceManualValue = {
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    name = L["Value"],
    order = startOrder + 0.2,
    min = 0,
    softMax = 100,
    bigStep = 1,
    hidden = hiddenManual,
    get = function(info)
      return data.progressSource and data.progressSource[3] or 0
    end,
    set = function(info, value)
      data.progressSource = data.progressSource or {}
      data.progressSource[3] = value
      WeakAuras.Add(parentData)
    end
  }

  options.progressSourceManualTotal = {
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    name = L["Total"],
    order = startOrder + 0.3,
    min = 0,
    softMax = 100,
    bigStep = 1,
    hidden = hiddenManual,
    get = function(info)
      return data.progressSource and data.progressSource[4] or 100
    end,
    set = function(info, value)
      data.progressSource = data.progressSource or {}
      data.progressSource[4] = value
      WeakAuras.Add(parentData)
    end
  }

  options.useAdjustededMin = {
    type = "toggle",
    width = WeakAuras.normalWidth,
    name = L["Set Minimum Progress"],
    desc = L["Values/Remaining Time below this value are displayed as zero progress."],
    order = startOrder + 0.4,
    set = function(info, value)
      data.useAdjustededMin = value
      if not value then
        data.adjustedMin = ""
      end
      WeakAuras.Add(parentData)
    end,
    hidden = progressSourceHidden
  };

  options.adjustedMin = {
    type = "input",
    validate = WeakAuras.ValidateNumericOrPercent,
    width = WeakAuras.normalWidth,
    order = startOrder + 0.5,
    name = L["Minimum"],
    hidden = function()
      if type(progressSourceHidden) == "function" and progressSourceHidden() then
        return true
      end
      return not data.useAdjustededMin
    end,
    desc = L["Enter static or relative values with %"]
  };

  options.useAdjustedMinSpacer = {
    type = "description",
    width = WeakAuras.normalWidth,
    name = "",
    order = startOrder + 0.6,
    hidden = function()
      if type(progressSourceHidden) == "function" and progressSourceHidden() then
        return true
      end
      return not (not data.useAdjustededMin and data.useAdjustededMax)
    end,
  }

  options.useAdjustededMax = {
    type = "toggle",
    width = WeakAuras.normalWidth,
    name = L["Set Maximum Progress"],
    desc = L["Values/Remaining Time above this value are displayed as full progress."],
    order = startOrder + 0.7,
    set = function(info, value)
      data.useAdjustededMax = value
      if not value then
        data.adjustedMax = ""
      end
      WeakAuras.Add(parentData)
    end,
    hidden = progressSourceHidden
  }

  options.adjustedMax = {
    type = "input",
    width = WeakAuras.normalWidth,
    validate = WeakAuras.ValidateNumericOrPercent,
    order = startOrder + 0.8,
    name = L["Maximum"],
    hidden = function()
      if type(progressSourceHidden) == "function" and progressSourceHidden() then
        return true
      end
      return not data.useAdjustededMax
    end,
    desc = L["Enter static or relative values with %"]
  }

  options.useAdjustedMaxSpacer = {
    type = "description",
    width = WeakAuras.normalWidth,
    name = "",
    order = startOrder + 0.9,
    hidden = function()
      if type(progressSourceHidden) == "function" and progressSourceHidden() then
        return true
      end
      return not (data.useAdjustededMin and not data.useAdjustededMax)
    end,
  }
end


local function BorderOptions(id, data, showBackDropOptions, hiddenFunc, order)
  local borderOptions = {
    borderHeader = {
      type = "header",
      order = order,
      name = L["Border Settings"],
      hidden = hiddenFunc,
    },
    border = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Show Border"],
      order = order + 0.1,
      hidden = hiddenFunc,
    },
    borderEdge = {
      type = "select",
      width = WeakAuras.normalWidth,
      dialogControl = "LSM30_Border",
      name = L["Border Style"],
      order = order + 0.2,
      values = AceGUIWidgetLSMlists.border,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
    },
    borderBackdrop = {
      type = "select",
      width = WeakAuras.normalWidth,
      dialogControl = "LSM30_Background",
      name = L["Backdrop Style"],
      order = order + 0.3,
      values = AceGUIWidgetLSMlists.background,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
    },
    borderOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Border Offset"],
      order = order + 0.3,
      softMin = 0,
      softMax = 32,
      bigStep = 1,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
    },
    borderSize = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Border Size"],
      order = order + 0.4,
      min = 1,
      softMax = 64,
      bigStep = 1,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
    },
    borderInset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Border Inset"],
      order = order + 0.5,
      softMin = 1,
      softMax = 32,
      bigStep = 1,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
    },
    border_spacer = {
      type = "description",
      name = "",
      width = WeakAuras.normalWidth,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
      order = order + 0.6
    },
    borderColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Border Color"],
      hasAlpha = true,
      order = order + 0.7,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
    },
    borderInFront  = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Border in Front"],
      order = order + 0.8,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border or not showBackDropOptions end,
    },
    backdropColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Backdrop Color"],
      hasAlpha = true,
      order = order + 0.9,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border end,
    },
    backdropInFront  = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Backdrop in Front"],
      order = order + 1,
      hidden = function() return hiddenFunc and hiddenFunc() or not data.border or not showBackDropOptions end,
    },
  }

  return borderOptions;
end

local function noop()
end

local function GetCustomCode(data, path)
  for _, key in ipairs(path) do
    if (not data or not data[key]) then
      return nil;
    end
    data = data[key];
  end
  return data;
end

local function AddCodeOption(args, data, name, prefix, url, order, hiddenFunc, path, encloseInFunction, options)
  options = options and CopyTable(options) or {}
  options.extraFunctions = options.extraFunctions or {};
  tinsert(options.extraFunctions, 1, {
    buttonLabel = L["Expand"],
    func = function()
      OptionsPrivate.OpenTextEditor(OptionsPrivate.GetPickedDisplay(), path, encloseInFunction, options.multipath,
                                    options.reloadOptions, options.setOnParent, url, options.validator)
    end
  });

  args[prefix .. "_custom"] = {
    type = "input",
    width = WeakAuras.doubleWidth,
    name = name,
    order = order,
    multiline = true,
    hidden = hiddenFunc,
    control = "WeakAurasMultiLineEditBox",
    arg = {
      extraFunctions = options.extraFunctions,
    },
    set = function(info, v)
      local subdata = data;
      for i = 1, #path -1 do
        local key = path[i];
        subdata[key] = subdata[key] or {};
        subdata = subdata[key];
      end

      subdata[path[#path]] = v;
      WeakAuras.Add(data);
      if (options.extraSetFunction) then
        options.extraSetFunction();
      end
      if (options.reloadOptions) then
        OptionsPrivate.ClearOptions(data.id)
      end
    end,
    get = function(info)
      return GetCustomCode(data, path);
    end
  };

  args[prefix .. "_customError"] = {
    type = "description",
    name = function()
      if hiddenFunc() then
        return "";
      end

      local code = GetCustomCode(data, path);

      if (not code or code:trim() == "") then
        return ""
      end

      if (encloseInFunction) then
        code = "function() "..code.."\n end";
      end

      code = "return " .. code;

      local loadedFunction, errorString = OptionsPrivate.Private.LoadFunction(code, data.id, true);

      if not errorString then
        if options.validator then
          errorString = options.validator(loadedFunction)
        end
      end
      return errorString and "|cFFFF0000"..errorString or "";
    end,
    width = WeakAuras.doubleWidth,
    order = order + 0.002,
    hidden = function()
      if (hiddenFunc()) then
        return true;
      end

      local code = GetCustomCode(data, path);
      if (not code or code:trim() == "") then
        return true;
      end

      if (encloseInFunction) then
        code = "function() "..code.."\n end";
      end

      code = "return " .. code;

      local loadedFunction, errorString = loadstring(code);
      if(errorString and not loadedFunction) then
        return false;
      else
        if options.validator then
          local ok, validate = xpcall(loadedFunction, noop)
          if ok then
            return options.validator(validate)
          end
          return false
        end
        return true;
      end
    end
  };
end

local function AddCommonTriggerOptions(options, data, triggernum, doubleWidth)
  local trigger = data.triggers[triggernum].trigger

  local trigger_types = {};
  for type, triggerSystem in pairs(OptionsPrivate.Private.triggerTypes) do
    trigger_types[type] = triggerSystem.GetName(type);
  end

  options.type = {
    type = "select",
    width = doubleWidth and WeakAuras.doubleWidth or WeakAuras.normalWidth,
    name = L["Type"],
    desc = L["The type of trigger"],
    order = 1.1,
    values = trigger_types,
    sorting = OptionsPrivate.Private.SortOrderForValues(trigger_types),
    get = function()
      return trigger.type
    end,
    set = function(info, v)
      trigger.type = v;
      local prototype = trigger.event and OptionsPrivate.Private.event_prototypes[trigger.event];
      if OptionsPrivate.Private.event_categories[v] and OptionsPrivate.Private.event_categories[v].default then
        if not prototype or prototype.type ~= v then
          trigger.event = OptionsPrivate.Private.event_categories[v].default
        end
      end
      WeakAuras.Add(data);
      WeakAuras.UpdateThumbnail(data);
      WeakAuras.ClearAndUpdateOptions(data.id);
    end,
  }
end

-- Adds setters/getters to trigger options
-- This is used by both aura triggers
local function AddTriggerGetterSetter(options, data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  for key, option in pairs(options) do
    if type(option) == "table" and not option.get then
      if option.type == "multiselect" then
        option.get = function(info, index)
          return trigger[key] and trigger[key][index]
        end
      else
        option.get = function(info)
          return trigger[key]
        end
      end
    end
    if type(option) == "table" and not option.set then
      if option.type == "multiselect" then
        option.set = function(info, index, value)
          if type(trigger[key]) ~= "table" then
            trigger[key] = {}
          end
          if value ~= nil then
            if value then
              trigger[key][index] = true
            else
              trigger[key][index] = nil
            end
          else
            if trigger[key][index] then
              trigger[key][index] = nil
            else
              trigger[key][index] = true
            end
          end
          if next(trigger[key]) == nil then
            trigger[key] = nil
          end

          WeakAuras.Add(data)
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
      else
        option.set = function(info, v)
          trigger[key] = v
          WeakAuras.Add(data)
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
      end
    end
  end
end


OptionsPrivate.commonOptions = {}
OptionsPrivate.commonOptions.parsePrefix = parsePrefix
OptionsPrivate.commonOptions.flattenRegionOptions = flattenRegionOptions
OptionsPrivate.commonOptions.fixMetaOrders = fixMetaOrders
OptionsPrivate.commonOptions.removeFuncs = removeFuncs
OptionsPrivate.commonOptions.CreateHiddenAll = CreateHiddenAll
OptionsPrivate.commonOptions.CreateDisabledAll = CreateDisabledAll
OptionsPrivate.commonOptions.replaceNameDescFuncs = replaceNameDescFuncs
OptionsPrivate.commonOptions.replaceImageFuncs = replaceImageFuncs
OptionsPrivate.commonOptions.replaceValuesFuncs = replaceValuesFuncs
OptionsPrivate.commonOptions.CreateGetAll = CreateGetAll
OptionsPrivate.commonOptions.CreateSetAll = CreateSetAll
OptionsPrivate.commonOptions.CreateExecuteAll = CreateExecuteAll

OptionsPrivate.commonOptions.PositionOptions = PositionOptions
OptionsPrivate.commonOptions.PositionOptionsForSubElement = PositionOptionsForSubElement
OptionsPrivate.commonOptions.ProgressOptions = ProgressOptions
OptionsPrivate.commonOptions.ProgressOptionsForSubElement = ProgressOptionsForSubElement
OptionsPrivate.commonOptions.BorderOptions = BorderOptions
OptionsPrivate.commonOptions.AddCodeOption = AddCodeOption

OptionsPrivate.commonOptions.AddCommonTriggerOptions = AddCommonTriggerOptions
OptionsPrivate.commonOptions.AddTriggerGetterSetter = AddTriggerGetterSetter


=== END OF FILE: WeakAurasOptions/CommonOptions.lua ===


=== FILE: WeakAurasOptions/ConditionOptions.lua ===

-- A bit of terminology
-- Templates:
--   The potential conditions that are offered by the triggers
-- The data structure returned by GetTriggerConditions(data) is
-- [] Trigger number
--   [] Condition name
--      - display: Display Name
--      - type: Type, e.g. "select", "number", "timer", "unit"
--      - values: (only for "select" and "unit")
--      - test: a test function template

-- Conditions + Changes: Actually active settings on a aura
-- Datastructure:
-- [] Index
--    - check
--      - trigger: Trigger number. Negative values indicate a special check:
--          -1: Global conditions
--          -2: Combinator
--      - variable: Variable inside the trigger state to check
--      - op: Operator to use for check
--      - value: Value to check
--      - checks: Sub Checks for Combinations, each containing trigger, variable, op, value or checks
--      - (for merged) references
--          - id => conditionIndex
--               => op
--               => value
--      - (for merged) referenceCount
--      - (for merged) samevalue
--      - (for merged) sameop
--    - changes
--      [] Index
--         - property: Property that is changed
--         - value: New value
--         - (for merged) references
--              => id => changeIndex
--                    => value
--         - (for merged) referenceCount
--         - (for merged) samevalue
--  Properties: The parts of the region than can be changed via
--             the condition system
-- [] Property Name
--   - display: A display Name
--   - setter: The setter function, called both on activating and deactivating a property change
---  - action: The action function, called on activating a condition
--   - type: The type
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local SharedMedia = LibStub("LibSharedMedia-3.0");

local function addSpace(args, order)
  args["space" .. order] = {
    type = "description",
    name = "",
    image = function() return "", 0, 0 end,
    order = order,
    width = WeakAuras.normalWidth
  }
  order = order + 1;
  return order;
end

local function compareValues(a, b, propertytype)
  if (propertytype == "color") then
    if (type(a) ~= "table" or type(b) ~= "table") then
      return a == b;
    end
    return a[1] == b[1]
      and a[2] == b[2]
      and a[3] == b[3]
      and a[4] == b[4];
  elseif propertytype == "progressSource" then
    if type(a) == "table" and type(b) == "table" then
      local triggerA, propertyA, triggerB, propertyB = a[1], a[2], b[1], b[2]
      if triggerA ~= triggerB or propertyA ~= propertyB then
        return false
      end
      if triggerA == 0 then
        return a[3] == b[3] and a[4] == b[4]
      end
      return true
    end
  end
  return a == b;
end

local function valueToString(a, propertytype)
  if (propertytype == "color") then
    if (type(a) == "table") then
      local r, g, b, alpha = floor((a[1] or 0) * 255), floor((a[2] or 0) * 255), floor((a[3] or 0) * 255), floor((a[4] or 0) * 255)
      return string.format("|c%02X%02X%02X%02X", alpha, r, g, b) .. L["color"];
    else
      return "";
    end
  elseif (propertytype == "chat" or propertytype == "sound" or propertytype == "customcode"
          or propertytype == "glowexternal" or propertytype == "customcheck") then
    return tostring(a);
  elseif (propertytype == "alwaystrue") then
    return ""
  elseif (propertytype == "bool") then
    return (a == 1 or a == true) and L["True"] or L["False"];
  end
  return tostring(a);
end

local function isSubset(data, reference, totalAuraCount)
  if (data.controlledChildren) then
    if (totalAuraCount > reference.referenceCount) then
      return true;
    end
  end
  return false;
end

local function blueIfSubset(data, reference, totalAuraCount)
  if (isSubset(data, reference, totalAuraCount)) then
    return "|cFF4080FF";
  end
  return "";
end

local function blueIfNoValue(data, object, variable, blueString, normalString)
  if (data.controlledChildren) then
    if (object["same" .. variable] == false) then
      return "|cFF4080FF" .. blueString;
    end
  end
  return normalString or "";
end

local function blueIfNoValue2(data, object, variable, subvariable, blueString, normalString)
  if (data.controlledChildren) then
    if (not object["same" .. variable] or not object["same" .. variable][subvariable]) then
      return "|cFF4080FF" .. blueString;
    end
  end
  return normalString or "";
end

local function descIfSubset(data, reference, totalAuraCount)
  if (isSubset(data, reference, totalAuraCount)) then
    local desc = L["Used in auras:"];
    for id in pairs(reference.references) do
      desc = desc .. "\n" .. id;
    end
    return desc;
  end
  return "";
end

local function descIfNoValue(data, object, variable, propertyType, values)
  if (data.controlledChildren) then
    if (object["same" .. variable] == false) then
      local desc = "";
      for id, reference in pairs(object.references) do
        if propertyType == "list" and values then
          desc = desc .."|cFFE0E000".. id .. ": |r" .. (values[reference[variable]] or "") .. "\n";
        elseif propertyType == "progressSource" then
          desc = desc .."|cFFE0E000".. id .. ": |r"
          local progressSource = reference[variable]
          if type(progressSource) == "table" then
            local trigger = progressSource[1]
            if trigger == 0 then
              desc = desc .. L["Manual with %i/%i"]:format(progressSource[3] or 0, progressSource[4] or 100)
            else
              local p = OptionsPrivate.Private.GetProgressValueConstant(progressSource)
              local description = values[p] or ""
              if type(description) == "string" then
                desc = desc .. description
              elseif type(description) == "table"
                      and type(description[1]) == "string"
                      and type(description[2])  == "string"
              then
                desc = desc .. description[1] .. " " .. description[2]
              end
            end
          end
          desc = desc .."\n"
        else
          desc = desc .."|cFFE0E000".. id .. ": |r" .. (valueToString(reference[variable], propertyType) or "") .. "\n";
        end
      end
      return desc;
    end
  end
  return nil;
end

local function descIfNoValue2(data, object, variable, subvariable, type, values)
  if (data.controlledChildren) then
    if (object["same" .. variable] and object["same" .. variable][subvariable] == false) then
      local desc = "";
      for id, reference in pairs(object.references) do
        if (values) then
          desc = desc .."|cFFE0E000".. id .. ": |r" .. (values[reference[variable][subvariable]] or "") .. "\n";
        else
          desc = desc .."|cFFE0E000".. id .. ": |r" .. valueToString(reference[variable][subvariable], type or "") .. "\n";
        end
      end
      return desc;
    end
  end
  return nil;
end

local function filterUsedProperties(indexToProperty, allDisplays, usedProperties, ownProperty)
  local filtered = {};
  for index, value in pairs(allDisplays) do
    local property = indexToProperty[index];
    local isUsed = property and usedProperties[property];
    local isOwn = ownProperty and property == ownProperty;
    if ( not isUsed or isOwn) then
      filtered[index] = value;
    end
  end

  return filtered;
end

--- @type number? the time at which the last sound was played, so that we don't play
---  a sound from each setter
local lastPlayedSoundFromSet
local function wrapWithPlaySound(func, kit)
  return function(info, v)
    func(info, v);
    if (tonumber(v)) then
      if lastPlayedSoundFromSet ~= GetTime() then
        pcall(PlaySound, tonumber(v), "Master")
        lastPlayedSoundFromSet = GetTime()
      end
    else
      if lastPlayedSoundFromSet ~= GetTime() then
        pcall(PlaySoundFile, v, "Master")
        lastPlayedSoundFromSet = GetTime()
      end
    end
  end
end

local dynamicTextInputs = {}

local function addControlsForChange(args, order, data, conditionVariable, totalAuraCount, conditions, i, j, allProperties, usedProperties)
  local thenText = (j == 1) and L["Then "] or L["And "];
  local display = isSubset(data, conditions[i].changes[j], totalAuraCount) and allProperties.displayWithCopy or allProperties.display;
  local valuesForProperty = filterUsedProperties(allProperties.indexToProperty, display, usedProperties, conditions[i].changes[j].property);
  args["condition" .. i .. "property" .. j] = {
    type = "select",
    width = WeakAuras.normalWidth,
    name = blueIfSubset(data, conditions[i].changes[j], totalAuraCount) .. thenText,
    desc = descIfSubset(data, conditions[i].changes[j], totalAuraCount),
    order = order,
    values = valuesForProperty,
    control = "WeakAurasTwoColumnDropdown",
    get = function()
      local property = conditions[i].changes[j].property;
      return property and allProperties.propertyToIndex[property];
    end,
    set = function(info, index)
      local property = allProperties.indexToProperty[index];
      if (property == "COPY") then
        for child in OptionsPrivate.Private.TraverseLeafs(data) do
          if (conditions[i].changes[j].references[child.id]) then
          -- Already exist
          else
            local insertPoint = 1;
            for index = j, 1, -1 do
              if (conditions[i].changes[index].references[child.id]) then
                insertPoint = index + 1;
                break;
              end
            end

            local change = {};
            change.property = conditions[i].changes[j].property;
            if (type(conditions[i].changes[j].value) == "table") then
              change.value = CopyTable(conditions[i].changes[j].value)
            else
              change.value = conditions[i].changes[j].value;
            end

            local reference = conditions[i].check.references[child.id]
            if reference then
              local conditionIndex = reference.conditionIndex;
              tinsert(child[conditionVariable][conditionIndex].changes, insertPoint, change);
              WeakAuras.Add(child);
              OptionsPrivate.ClearOptions(child.id)
            end
          end
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
        return;
      elseif (property == "DELETE") then
        if (data.controlledChildren) then
          for id, reference in pairs(conditions[i].changes[j].references) do
            local auraData = WeakAuras.GetData(id);
            local conditionIndex = conditions[i].check.references[id].conditionIndex;
            tremove(auraData[conditionVariable][conditionIndex].changes, reference.changeIndex);
            WeakAuras.Add(auraData);
            OptionsPrivate.ClearOptions(auraData.id)
          end
          WeakAuras.ClearAndUpdateOptions(data.id)
        else
          tremove(conditions[i].changes, j);
          WeakAuras.Add(data);
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
        return;
      end

      local default = allProperties.propertyMap[property].default;
      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].changes[j].references) do
          local auraData = WeakAuras.GetData(id);
          local conditionIndex = conditions[i].check.references[id].conditionIndex;
          auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].property = property;
          auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value = default;
          WeakAuras.Add(auraData);
          OptionsPrivate.ClearOptions(auraData.id)
        end
        conditions[i].changes[j].property = property;
        WeakAuras.ClearAndUpdateOptions(data.id)
      else
        conditions[i].changes[j].property = property;
        conditions[i].changes[j].value = default;
        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end
  }
  order = order + 1;

  local setValue;
  local setValueTable
  local setValueColor;
  local setValueComplex;
  local setValueColorComplex;
  if (data.controlledChildren) then
    setValue = function(info, v)
      for id, reference in pairs(conditions[i].changes[j].references) do
        local auraData = WeakAuras.GetData(id);
        local conditionIndex = conditions[i].check.references[id].conditionIndex;
        auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value = v;
        WeakAuras.Add(auraData);
        OptionsPrivate.ClearOptions(auraData.id)
      end
      conditions[i].changes[j].value = v;
      WeakAuras.ClearAndUpdateOptions(data.id)
    end
    setValueTable = function(info, v)
      for id, reference in pairs(conditions[i].changes[j].references) do
        local auraData = WeakAuras.GetData(id)
        local conditionIndex = conditions[i].check.references[id].conditionIndex
        auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value = CopyTable(v)
        WeakAuras.Add(auraData)
        OptionsPrivate.ClearOptions(auraData.id)
      end
      conditions[i].changes[j].value = CopyTable(v)
      WeakAuras.ClearAndUpdateOptions(data.id)
    end
    setValueColor = function(info, r, g, b, a)
      for id, reference in pairs(conditions[i].changes[j].references) do
        local auraData = WeakAuras.GetData(id);
        local conditionIndex = conditions[i].check.references[id].conditionIndex;
        auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value = auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value or {};
        auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[1] = r;
        auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[2] = g;
        auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[3] = b;
        auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[4] = a;
        WeakAuras.Add(auraData);
        OptionsPrivate.ClearOptions(auraData.id)
      end
      conditions[i].changes[j].value = conditions[i].changes[j].value or {};
      conditions[i].changes[j].value[1] = r;
      conditions[i].changes[j].value[2] = g;
      conditions[i].changes[j].value[3] = b;
      conditions[i].changes[j].value[4] = a;
      WeakAuras.ClearAndUpdateOptions(data.id)
    end

    setValueComplex = function(property)
      return function(info, v)
        for id, reference in pairs(conditions[i].changes[j].references) do
          local auraData = WeakAuras.GetData(id);
          local conditionIndex = conditions[i].check.references[id].conditionIndex;
          if (type(auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value) ~= "table") then
            auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value = {};
          end
          auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[property] = v;
          WeakAuras.Add(auraData);
          OptionsPrivate.ClearOptions(auraData.id)
        end
        if (type(conditions[i].changes[j].value) ~= "table") then
          conditions[i].changes[j].value = {};
        end
        conditions[i].changes[j].value[property] = v;
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end

    setValueColorComplex = function(property)
      return function(info, r, g, b, a)
        for id, reference in pairs(conditions[i].changes[j].references) do
          local auraData = WeakAuras.GetData(id);
          local conditionIndex = conditions[i].check.references[id].conditionIndex;
          if (type(auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value) ~= "table") then
            auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value = {};
          end
          if (type(auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[property]) ~= "table") then
            auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[property] = {};
          end
          auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[property][1] = r;
          auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[property][2] = g;
          auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[property][3] = b;
          auraData[conditionVariable][conditionIndex].changes[reference.changeIndex].value[property][4] = a;
          WeakAuras.Add(auraData);
          OptionsPrivate.ClearOptions(auraData.id)
        end
        if (type(conditions[i].changes[j].value) ~= "table") then
          conditions[i].changes[j].value = {};
        end
        if (type(conditions[i].changes[j].value[property]) ~= "table") then
          conditions[i].changes[j].value[property] = {};
        end
        conditions[i].changes[j].value[property][1] = r;
        conditions[i].changes[j].value[property][2] = g;
        conditions[i].changes[j].value[property][3] = b;
        conditions[i].changes[j].value[property][4] = a;
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end
  else
    setValue = function(info, v)
      conditions[i].changes[j].value = v;
      WeakAuras.Add(data);
      WeakAuras.ClearAndUpdateOptions(data.id)
    end
    setValueTable = function(info, v)
      conditions[i].changes[j].value = CopyTable(v)
      WeakAuras.Add(data)
      WeakAuras.ClearAndUpdateOptions(data.id)
    end
    setValueColor = function(info, r, g, b, a)
      conditions[i].changes[j].value = conditions[i].changes[j].value or {};
      conditions[i].changes[j].value[1] = r;
      conditions[i].changes[j].value[2] = g;
      conditions[i].changes[j].value[3] = b;
      conditions[i].changes[j].value[4] = a;
      WeakAuras.Add(data);
      WeakAuras.ClearAndUpdateOptions(data.id)
    end

    setValueComplex = function(property)
      return function(info, v)
        if (type (conditions[i].changes[j].value) ~= "table") then
          conditions[i].changes[j].value = {};
        end
        conditions[i].changes[j].value[property] = v;
        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end

    setValueColorComplex = function(property)
      return function(info, r, g, b, a)
        if (type (conditions[i].changes[j].value) ~= "table") then
          conditions[i].changes[j].value = {};
        end
        if (type (conditions[i].changes[j].value[property]) ~= "table") then
          conditions[i].changes[j].value[property] = {};
        end
        conditions[i].changes[j].value[property][1] = r;
        conditions[i].changes[j].value[property][2] = g;
        conditions[i].changes[j].value[property][3] = b;
        conditions[i].changes[j].value[property][4] = a;
        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end
  end

  local propertyType;
  local property = conditions[i].changes[j].property;
  if (property) then
    propertyType = allProperties.propertyMap[property] and allProperties.propertyMap[property].type;
  end
  if (propertyType == "bool" or propertyType == "number") then
    args["condition" .. i .. "value" .. j] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      desc = descIfNoValue(data, conditions[i].changes[j], "value", propertyType),
      order = order,
      get = function()
        return conditions[i].changes[j].value;
      end,
      set = setValue
    }
    order = order + 1;
    if (propertyType == "number") then
      args["condition" .. i .. "value" .. j].name = blueIfNoValue(data, conditions[i].changes[j], "value", L["Differences"])
      local properties = allProperties.propertyMap[property];
      if (properties.min or properties.softMin) and (properties.max or properties.softMax) then
        args["condition" .. i .. "value" .. j].type = "range";
        args["condition" .. i .. "value" .. j].control = "WeakAurasSpinBox"
        args["condition" .. i .. "value" .. j].min = properties.min;
        args["condition" .. i .. "value" .. j].softMin = properties.softMin;
        args["condition" .. i .. "value" .. j].max = properties.max;
        args["condition" .. i .. "value" .. j].softMax = properties.softMax;
        args["condition" .. i .. "value" .. j].step = properties.step;
        args["condition" .. i .. "value" .. j].bigStep = properties.bigStep;
        args["condition" .. i .. "value" .. j].isPercent = properties.isPercent;
      else
        args["condition" .. i .. "value" .. j].type = "input";
        args["condition" .. i .. "value" .. j].validate = WeakAuras.ValidateNumeric;
      end
    else
      args["condition" .. i .. "value" .. j].name = function()
        local value = conditions[i].changes[j].value
        return blueIfNoValue(data, conditions[i].changes[j], "value", L["Differences"], value and L["ON"] or L["OFF"])
      end
    end
  elseif (propertyType == "string" or propertyType == "texture") then
    args["condition" .. i .. "value" .. j] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue(data, conditions[i].changes[j], "value", L["Text"]),
      desc = descIfNoValue(data, conditions[i].changes[j], "value", propertyType),
      order = order,
      get = function()
        return conditions[i].changes[j].value;
      end,
      set = setValue,
      control = allProperties.propertyMap[property].control
    }
    order = order + 1;
    if propertyType == "texture" then
      args["condition" .. i .. "value" .. j].width =  WeakAuras.normalWidth - 0.15
      args["condition" .. i .. "value_browse" .. j] = {
        type = "execute",
        name = L["Choose"],
        width = 0.15,
        order = order,
        func = function()
          if data.controlledChildren then
            local paths = {}
            for id, reference in pairs(conditions[i].changes[j].references) do
              paths[id] = {"conditions", conditions[i].check.references[id].conditionIndex, "changes", reference.changeIndex}
            end
            OptionsPrivate.OpenTexturePicker(data, paths,
                                             {texture = "value"},
                                             OptionsPrivate.Private.texture_types)
          else
            OptionsPrivate.OpenTexturePicker(data, {[data.id] = { "conditions", i, "changes", j } },
                                             {texture = "value"},
                                             OptionsPrivate.Private.texture_types)
          end
        end,
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
      }
      order = order + 1;
    end
  elseif (propertyType == "icon") then
    args["condition" .. i .. "value" .. j] = {
      type = "input",
      width = WeakAuras.normalWidth - 0.15,
      name = blueIfNoValue(data, conditions[i].changes[j], "value", L["Differences"]),
      desc = descIfNoValue(data, conditions[i].changes[j], "value", propertyType),
      order = order,
      get = function()
        local v = conditions[i].changes[j].value
        return v and tostring(v)
      end,
      set = setValue
    }
    order = order + 1
    args["condition" .. i .. "value_browse" .. j] = {
      type = "execute",
      width = 0.15,
      name = "",
      order = order,
      func = function()
        if data.controlledChildren then
          local paths = {}
          for id, reference in pairs(conditions[i].changes[j].references) do
            paths[id] = {"conditions", conditions[i].check.references[id].conditionIndex, "changes", reference.changeIndex, "value"}
          end
          OptionsPrivate.OpenIconPicker(data, paths)
        else
          OptionsPrivate.OpenIconPicker(data, {[data.id] = { "conditions", i, "changes", j, "value" } })
        end
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    }
  elseif (propertyType == "color") then
    args["condition" .. i .. "value" .. j] = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue(data, conditions[i].changes[j], "value", L["Differences"]),
      desc = descIfNoValue(data, conditions[i].changes[j], "value", propertyType),
      order = order,
      hasAlpha = true,
      get = function()
        if (conditions[i].changes[j].value and type(conditions[i].changes[j].value) == "table") then
          return conditions[i].changes[j].value[1], conditions[i].changes[j].value[2], conditions[i].changes[j].value[3], conditions[i].changes[j].value[4];
        end
        return 1, 1, 1, 1;
      end,
      set = setValueColor
    }
    order = order + 1;
  elseif (propertyType == "list" or propertyType == "progressSource" or propertyType == "textureLSM") then
    local values = property and allProperties.propertyMap[property] and allProperties.propertyMap[property].values;
    local dialogControl

    if propertyType == "textureLSM" then
      dialogControl = "WA_LSM30_StatusbarAtlas"
      local statusbarList = {}
      Mixin(statusbarList, SharedMedia:HashTable("statusbar"))
      Mixin(statusbarList, SharedMedia:HashTable("statusbar_atlas"))
      values = statusbarList
    end

    args["condition" .. i .. "value" .. j] = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = values,
      dialogControl = dialogControl,
      name =  blueIfNoValue(data, conditions[i].changes[j], "value", L["Differences"], ""),
      desc =  descIfNoValue(data, conditions[i].changes[j], "value", propertyType, values),
      order = order,
      get = function()
        return conditions[i].changes[j].value;
      end,
      set = setValue,
    }
    order = order + 1

    if propertyType == "progressSource" then
      args["condition" .. i .. "value" .. j].control = "WeakAurasTwoColumnDropdown"
      args["condition" .. i .. "value" .. j].set = setValueTable
      args["condition" .. i .. "value" .. j].get = function()
        local v = conditions[i].changes[j].value
        return OptionsPrivate.Private.GetProgressValueConstant(v)
      end

      args["condition" .. i .. "progressSourceWarning" .. j] = {
        type = "description",
        width = WeakAuras.doubleWidth,
        name = L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""],
        order = order,
        hidden = function()
          local v = conditions[i].changes[j].value
          local progressSource = OptionsPrivate.Private.AddProgressSourceMetaData(data, v)
          -- Auto progress, Manual Progress or the progress source has a total property
          if progressSource and (progressSource[2] == "auto" or progressSource[1] == 0 or progressSource[4] ~= nil) then
            return true
          end
          return false
        end
      }
      order = order + 1

      local function hiddenManual()
        local v = conditions[i].changes[j].value
        local progressSource = OptionsPrivate.Private.AddProgressSourceMetaData(data, v)
        if progressSource and progressSource[1] == 0 then
          return false
        end
        return true
      end

      args["condition" .. i .. "progressSourceManualValue" .. j] = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Value"],
        order = order,
        min = 0,
        softMax = 100,
        bigStep = 1,
        hidden = hiddenManual,
        get = function()
          local v = conditions[i].changes[j].value
          return v and type(v[3]) == "number" and v[3] or 0
        end,
        set = setValueComplex(3)
      }
      order = order + 1

      args["condition" .. i .. "progressSourceManualTotal" .. j] = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Total"],
        order = order,
        min = 0,
        softMax = 100,
        bigStep = 1,
        hidden = hiddenManual,
        get = function()
          local v = conditions[i].changes[j].value
          return v and type(v[4]) == "number" and v[4] or 100
        end,
        set = setValueComplex(4)
      }
      order = order + 1
    end
  elseif (propertyType == "sound") then
    args["condition" .. i .. "value" .. j .. "sound_type"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = OptionsPrivate.Private.sound_condition_types,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "sound_type", L["Differences"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "sound_type", propertyType, OptionsPrivate.Private.sound_condition_types),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound_type;
      end,
      set = setValueComplex("sound_type"),
    }
    order = order + 1;

    local function anySoundType(needle)
      local sound_type = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound_type;
      if (sound_type) then
        return sound_type == needle;
      end
      if (conditions[i].changes[j].references) then
        for id, reference in pairs(conditions[i].changes[j].references) do
          if (type(reference.value) == "table" and reference.value.sound_type == needle) then
            return true;
          end
        end
      end
      return false;
    end

    args["condition" .. i .. "value" .. j .. "sound"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = OptionsPrivate.Private.sound_types,
      sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.sound_types),
      itemControl = "WeakAurasMediaSound",
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "sound", L["Differences"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "sound", propertyType, OptionsPrivate.Private.sound_types),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound;
      end,
      set = wrapWithPlaySound(setValueComplex("sound")),
      hidden = function() return not (anySoundType("Play") or anySoundType("Loop")) end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "sound_channel"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = OptionsPrivate.Private.sound_channel_types,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "sound_channel", L["Sound Channel"], L["Sound Channel"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "sound_channel", propertyType, OptionsPrivate.Private.sound_channel_types),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound_channel;
      end,
      set = setValueComplex("sound_channel"),
      hidden = function() return not (anySoundType("Loop") or anySoundType("Play")) end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "sound_repeat"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      min = 0,
      softMax = 60,
      bigStep = 1,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "sound_repeat", L["Repeat every"], L["Repeat every"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "sound_repeat", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound_repeat;
      end,
      set = setValueComplex("sound_repeat"),
      disabled = function() return not anySoundType("Loop") end,
      hidden = function() return not (anySoundType("Loop")) end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "sound_repeat_space"] = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = order,
      hidden = function() return not (anySoundType("Loop")) end
    }
    order = order + 1;

    local function anySoundValue(needle)
      local sound_type = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound;
      if (sound_type) then
        return sound_type == needle;
      end
      if (conditions[i].changes[j].references) then
        for id, reference in pairs(conditions[i].changes[j].references) do
          if (type(reference.value) == "table" and reference.value.sound == needle) then
            return true;
          end
        end
      end
      return false;
    end

    args["condition" .. i .. "value" .. j .. "sound_path"] = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "sound_path", L["Sound File Path"], L["Sound File Path"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "sound_path", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound_path;
      end,
      set = wrapWithPlaySound(setValueComplex("sound_path")),
      hidden = function() return not (anySoundValue(" custom") and (anySoundType("Loop") or anySoundType("Play"))) end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "sound_kit_id"] = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "sound_kit_id", L["Sound Kit ID"], L["Sound Kit ID"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "sound_kit_id", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound_kit_id;
      end,
      set = wrapWithPlaySound(setValueComplex("sound_kit_id")),
      hidden = function() return not (anySoundValue(" KitID")  and (anySoundType("Loop") or anySoundType("Play"))) end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "sound_fade"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      min = 0,
      softMax = 10,
      bigStep = 1,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "sound_fade", L["Fadeout Time (seconds)"], L["Fadeout Time (seconds)"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "sound_fade", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.sound_fade;
      end,
      set = setValueComplex("sound_fade"),
      disabled = function() return not anySoundType("Stop") end,
      hidden = function() return not (anySoundType("Stop")) end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "sound_fade_space"] = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = order,
      hidden = function() return not (anySoundType("Stop")) end
    }
    order = order + 1;


  elseif (propertyType == "chat") then
    args["condition" .. i .. "value" .. j .. "message type"] = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = OptionsPrivate.Private.send_chat_message_types,
      sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.send_chat_message_types),
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "message_type", L["Differences"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "message_type", propertyType, OptionsPrivate.Private.send_chat_message_types),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message_type;
      end,
      set = setValueComplex("message_type"),
    }
    order = order + 1;

    local function anyMessageType(needle)
      local message_type = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message_type;
      if (message_type) then
        return message_type == needle;
      end
      if (conditions[i].changes[j].references) then
        for id, reference in pairs(conditions[i].changes[j].references) do
          if (type(reference.value) == "table" and reference.value.message_type == needle) then
            return true;
          end
        end
      end
      return false;
    end

    if WeakAuras.IsRetail() then
      args["condition" .. i .. "value" .. j .. "message type warning"] = {
        type = "description",
        width = WeakAuras.doubleWidth,
        name = L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."],
        order = order,
        hidden = function()
          return not (anyMessageType("SAY") or anyMessageType("YELL") or anyMessageType("SMARTRAID"));
        end
      }
      order = order + 1;
    end

    args["condition" .. i .. "value" .. j .. "_indent"] = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = order,
      hidden = function()
        return anyMessageType("WHISPER");
      end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "message color"] = {
      type = "color",
      width = WeakAuras.normalWidth,
      hasAlpha = false,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "message_color", L["Color"], L["Color"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "message_color", propertyType),
      order = order,
      get = function()
        if (conditions[i].changes[j].value and type(conditions[i].changes[j].value) == "table") and type(conditions[i].changes[j].value.message_color) == "table" then
          return conditions[i].changes[j].value.message_color[1], conditions[i].changes[j].value.message_color[2], conditions[i].changes[j].value.message_color[3];
        end
        return 1, 1, 1, 1;
      end,
      set = setValueColorComplex("message_color"),
      hidden = function()
        return not (anyMessageType("COMBAT") or anyMessageType("PRINT") or anyMessageType("ERROR"));
      end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "message dest"] = {
      type = "input",
      width = WeakAuras.normalWidth - 0.15,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "message_dest", L["Send To"], L["Send To"]),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message_dest;
      end,
      set = setValueComplex("message_dest"),
      hidden = function()
        return not anyMessageType("WHISPER");
      end,
      control = "WeakAurasInput",
      callbacks = {
        OnEditFocusGained = function(self)
          local widget = dynamicTextInputs["condition" .. i .. "value" .. j .. "message dest"]
          OptionsPrivate.ToggleTextReplacements(data, widget, "OnEditFocusGained")
        end,
        OnEditFocusLost = function(self)
          OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
        end,
        OnEnterPressed = function(self)
          OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEnterPressed")
        end,
        OnShow = function(self)
          dynamicTextInputs["condition" .. i .. "value" .. j .. "message dest"] = self
        end,
      }
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "message dest_text_replacements_button"] = {
      type = "execute",
      width = 0.15,
      name = L["Dynamic Text Replacements"],
      desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
      order = order,
      hidden = function()
        return not anyMessageType("WHISPER");
      end,
      func = function()
        local widget = dynamicTextInputs["condition" .. i .. "value" .. j .. "message dest"]
        OptionsPrivate.ToggleTextReplacements(data, widget, "ToggleButton")
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue(data, conditions[i].changes[j], "value", "message_dest_isunit", L["Is Unit"]),
      desc = descIfNoValue(data, conditions[i].changes[j], "value", "message_dest_isunit", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message_dest_isunit;
      end,
      set = setValueComplex("message_dest_isunit"),
      hidden = function()
        return not anyMessageType("WHISPER");
      end
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "message voice"] = {
      type = "execute",
      name = L["Voice Settings"],
      order = order,
      width = WeakAuras.normalWidth,
      func = function()
        ShowUIPanel(ChatConfigFrame)
        ChatConfigFrameChatTabManager:UpdateSelection(VOICE_WINDOW_ID)
        end,
      hidden = function()
        return not anyMessageType("TTS");
      end,
    }
    order = order + 1;

    local message_getter = function()
      return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message;
    end

    args["condition" .. i .. "value" .. j .. "message"] = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "message", L["Message"], L["Message"]),
      order = order,
      get = message_getter,
      set = setValueComplex("message"),
      control = "WeakAurasInput",
      callbacks = {
        OnEditFocusGained = function(self)
          local widget = dynamicTextInputs["condition" .. i .. "value" .. j .. "message"]
          OptionsPrivate.ToggleTextReplacements(data, widget, "OnEditFocusGained")
        end,
        OnEditFocusLost = function(self)
          OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
        end,
        OnEnterPressed = function(self)
          OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEnterPressed")
        end,
        OnShow = function(self)
          dynamicTextInputs["condition" .. i .. "value" .. j .. "message"] = self
        end,
      }
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "message_text_replacements_button"] = {
      type = "execute",
      width = 0.15,
      name = L["Dynamic Text Replacements"],
      desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
      order = order,
      func = function()
        local widget = dynamicTextInputs["condition" .. i .. "value" .. j .. "message"]
        OptionsPrivate.ToggleTextReplacements(data, widget, "ToggleButton")
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
    }
    order = order + 1;


    local formatGet = function(key)
      return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value["message_format_" .. key]
    end

    local usedKeys = {}
    local function addOption(key, option)
      if usedKeys[key] then
        return
      end
      usedKeys[key] = true
      option.order = order
      order = order + 0.01
      local fullKey = "condition" .. i .. "value" .. j .. "message_format_" .. key
      option.get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value["message_format_" .. key];
      end
      local originalName = option.name
      if option.type ~= "header" then
        option.name = blueIfNoValue2(data, conditions[i].changes[j], "value", "message_format_" .. key, originalName, originalName)
        option.desc = descIfNoValue2(data, conditions[i].changes[j], "value", "message_format_" .. key, nil, option.values)
      end

      option.set = setValueComplex("message_format_" .. key)

      args[fullKey] = option
    end

    local hasTextFormatOption

    local hidden = function()
      return OptionsPrivate.IsCollapsed("format_option", "conditions", i .. "#" .. j , true)
    end

    local setHidden = function(hidden)
      OptionsPrivate.SetCollapsed("format_option", "conditions", i .. "#" .. j, hidden)
    end

    if data.controlledChildren then
      local ordered = {}
      for _, reference in pairs(conditions[i].changes[j].references) do
        tinsert(ordered, reference)
      end
      for index, reference in ipairs(ordered) do
        local input = reference.value and reference.value.message
        hasTextFormatOption = OptionsPrivate.AddTextFormatOption(input, true, formatGet, addOption, hidden, setHidden, true, index, #ordered)
      end
    else
      local input = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value["message"]
      hasTextFormatOption = OptionsPrivate.AddTextFormatOption(input, true, formatGet, addOption, hidden, setHidden, true)
    end

    if hasTextFormatOption then
      local footerOption = {
        type = "header",
        name = "",
        width = WeakAuras.doubleWidth
      }
      addOption("footer", footerOption)
    end

    local function customHidden()
      local message = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message;
      local message_dest = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message_type == "WHISPER" and conditions[i].changes[j].value.message_dest
      if (not message and not message_dest) then return true; end
      return not OptionsPrivate.Private.ContainsCustomPlaceHolder(message) and not OptionsPrivate.Private.ContainsCustomPlaceHolder(message_dest);
    end

    args["condition" .. i .. "value" .. j .. "custom"] = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "custom", L["Custom Code"], L["Custom Code"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "custom", propertyType),
      order = order,
      multiline = true,
      hidden = customHidden,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.custom;
      end,
      control = "WeakAurasMultiLineEditBox",
      set = setValueComplex("custom"),
      arg = {
        extraFunctions = {
          {
            buttonLabel = L["Expand"],
            func = function()
              if (data.controlledChildren) then
                -- Collect multi paths
                local multipath = {};
                for id, reference in pairs(conditions[i].changes[j].references) do
                  local conditionIndex = conditions[i].check.references[id].conditionIndex;
                  local changeIndex = reference.changeIndex;
                  multipath[id] = {"conditions", conditionIndex, "changes", changeIndex, "value", "custom"};
                end
                OptionsPrivate.OpenTextEditor(data, multipath, nil, true, nil, nil, "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#chat-message---custom-code-1");
              else
                OptionsPrivate.OpenTextEditor(data, {"conditions", i, "changes", j, "value", "custom"}, nil, nil, nil, nil, "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#chat-message---custom-code-1");
              end
            end
          }
        }
      }
    }

    order = order + 1;

    args["condition" .. i .. "value" .. j .. "custom_error"] = {
      type = "description",
      name = function()
        local custom = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.custom;
        if not custom then
          return "";
        end
        local _, errorString = loadstring("return  " .. custom);
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = WeakAuras.doubleWidth,
      order = order,
      hidden = function()
        local message = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.message;
        if (not message) then
          return true;
        end
        if (not OptionsPrivate.Private.ContainsCustomPlaceHolder(message)) then
          return true;
        end

        local custom = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.custom;

        if (not custom) then
          return true;
        end

        local loadedFunction, errorString = loadstring("return " .. custom);
        if(errorString and not loadedFunction) then
          return false;
        else
          return true;
        end
      end
    }
    order = order + 1;

  elseif(propertyType == "customcode") then
    order = addSpace(args, order);

    args["condition" .. i .. "value" .. j .. "custom"] = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "message_custom", L["Custom Code"], L["Custom Code"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "message_custom", propertyType),
      order = order,
      multiline = true,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.custom;
      end,
      control = "WeakAurasMultiLineEditBox",
      set = setValueComplex("custom"),
      arg = {
        extraFunctions = {
          {
            buttonLabel = L["Expand"],
            func = function()
              if (data.controlledChildren) then
                -- Collect multi paths
                local multipath = {};
                for id, reference in pairs(conditions[i].changes[j].references) do
                  local conditionIndex = conditions[i].check.references[id].conditionIndex;
                  local changeIndex = reference.changeIndex;
                  local childData = WeakAuras.GetData(id);
                  childData.conditions[conditionIndex].changes[changeIndex].value = childData.conditions[conditionIndex].changes[changeIndex].value or {};
                  multipath[id] = {"conditions", conditionIndex, "changes", changeIndex, "value", "custom"};
                end
                OptionsPrivate.OpenTextEditor(data, multipath, true, true, nil, nil, "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#run-custom-code");
              else
                data.conditions[i].changes[j].value = data.conditions[i].changes[j].value or {};
                OptionsPrivate.OpenTextEditor(data, {"conditions", i, "changes", j, "value", "custom"}, true, nil, nil, nil, "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#run-custom-code");
              end
            end
          }
        }
      }
    }
    order = order + 1;

    args["condition" .. i .. "value" .. j .. "custom_error"] = {
      type = "description",
      name = function()
        local custom = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.custom;
        if not custom then
          return "";
        end
        local _, errorString = loadstring("return function() " .. custom .. "\n end");
        return errorString and "|cFFFF0000"..errorString or "";
      end,
      width = WeakAuras.doubleWidth,
      order = order,
      hidden = function()
        local custom = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.custom;

        if (not custom) then
          return true;
        end
        local loadedFunction, errorString = loadstring("return function() " .. custom .. "\n end");
        if(errorString and not loadedFunction) then
          return false;
        else
          return true;
        end
      end
    }
    order = order + 1;
  elseif (propertyType == "glowexternal") then
    local function anyGlowExternal(property, needle)
      local ref = type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value[property]
      if ref then
        if type(needle) == "table" then
          return needle[ref]
        else
          return ref == needle
        end
      end
      if conditions[i].changes[j].references then
        for id, reference in pairs(conditions[i].changes[j].references) do
          if type(reference.value) == "table" then
            if type(needle) == "table" then
              if needle[reference.value[property]] then
                return true
              end
            else
              if reference.value[property] == needle then
                return true
              end
            end
          end
        end
      end
      return false
    end

    local glowTypesExcepButtonOverlay = CopyTable(OptionsPrivate.Private.glow_types)
    glowTypesExcepButtonOverlay["buttonOverlay"] = nil
    local glowTypesExcepButtonOverlayAndProc = CopyTable(OptionsPrivate.Private.glow_types)
    glowTypesExcepButtonOverlayAndProc["buttonOverlay"] = nil
    glowTypesExcepButtonOverlayAndProc["Proc"] = nil

    args["condition" .. i .. "value" .. j .. "glow_action"] = {
      type = "select",
      values = OptionsPrivate.Private.glow_action_types,
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_action", L["Glow Action"], L["Glow Action"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_action", propertyType, OptionsPrivate.Private.glow_action_types),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_action;
      end,
      set = setValueComplex("glow_action")
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_frame_type"] = {
      type = "select",
      values = OptionsPrivate.Private.glow_frame_types,
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_frame_type", L["Glow Frame Type"], L["Glow Frame Type"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_frame_type", propertyType, OptionsPrivate.Private.glow_frame_types),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_frame_type;
      end,
      hidden = function() return not anyGlowExternal("glow_action", OptionsPrivate.Private.glow_action_types) end,
      set = setValueComplex("glow_frame_type")
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_type"] = {
      type = "select",
      values = OptionsPrivate.Private.glow_types,
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_type", L["Glow Type"], L["Glow Type"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_type", propertyType, OptionsPrivate.Private.glow_types),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_type;
      end,
      set = setValueComplex("glow_type"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_frame_type", OptionsPrivate.Private.glow_frame_types))
      end
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_frame"] = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_frame", L["Frame"], L["Frame"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_frame", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_frame;
      end,
      set = setValueComplex("glow_frame"),
      hidden = function()
        return not anyGlowExternal("glow_frame_type", "FRAMESELECTOR")
      end
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "choose_glow_frame"] = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_frame", L["Choose"], L["Choose"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_frame", propertyType),
      order = order,
      func = function()
        OptionsPrivate.StartFrameChooser(data, {"conditions", i, "changes", j, "value", "glow_frame"});
      end,
      hidden = function()
        return not anyGlowExternal("glow_frame_type", "FRAMESELECTOR")
      end
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "use_glow_color"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "use_glow_color", L["Glow Color"], L["Glow Color"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "use_glow_color", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.use_glow_color;
      end,
      set = setValueComplex("use_glow_color"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", OptionsPrivate.Private.glow_types))
      end
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_color"] = {
      type = "color",
      hasAlpha = true,
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_color", L["Glow Color"], L["Glow Color"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_color", "color"),
      order = order,
      get = function()
        if (conditions[i].changes[j].value and type(conditions[i].changes[j].value) == "table") and type(conditions[i].changes[j].value.glow_color) == "table" then
          return conditions[i].changes[j].value.glow_color[1], conditions[i].changes[j].value.glow_color[2], conditions[i].changes[j].value.glow_color[3], conditions[i].changes[j].value.glow_color[4];
        end
        return 1, 1, 1, 1;
      end,
      set = setValueColorComplex("glow_color"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show")
                    and anyGlowExternal("glow_frame_type", OptionsPrivate.Private.glow_frame_types)
                    and anyGlowExternal("glow_type", OptionsPrivate.Private.glow_types))
      end,
      disabled = function() return not anyGlowExternal("use_glow_color", true) end
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_startAnim"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_startAnim", L["Start Animation"], L["Start Animation"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_startAnim", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_startAnim;
      end,
      set = setValueComplex("glow_startAnim"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", "Proc"))
      end
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_duration"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_duration", L["Duration"], L["Duration"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_duration", propertyType),
      order = order,
      softMin = 0.01,
      softMax = 3,
      step = 0.05,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_duration or 1;
      end,
      set = setValueComplex("glow_duration"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", "Proc"))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_lines"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_lines", L["Lines & Particles"], L["Lines & Particles"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_lines", propertyType),
      order = order,
      min = 1,
      softMax = 30,
      step = 1,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_lines or 8;
      end,
      set = setValueComplex("glow_lines"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", glowTypesExcepButtonOverlayAndProc))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_frequency"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_frequency", L["Frequency"], L["Frequency"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_frequency", propertyType),
      order = order,
      softMin = -2,
      softMax = 2,
      step = 0.05,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_frequency or 0.25;
      end,
      set = setValueComplex("glow_frequency"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", glowTypesExcepButtonOverlayAndProc))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_length"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_length", L["Length"], L["Length"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_length", propertyType),
      order = order,
      min = 0.05,
      softMax = 20,
      step = 0.05,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_length or 10;
      end,
      set = setValueComplex("glow_length"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", "Pixel"))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_thickness"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_thickness", L["Thickness"], L["Thickness"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_thickness", propertyType),
      order = order,
      min = 0.05,
      softMax = 20,
      step = 0.05,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_thickness or 1;
      end,
      set = setValueComplex("glow_thickness"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", "Pixel"))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_XOffset"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_XOffset", L["X-Offset"], L["X-Offset"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_XOffset", propertyType),
      order = order,
      softMin = -100,
      softMax = 100,
      step = 0.5,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_XOffset or 0;
      end,
      set = setValueComplex("glow_XOffset"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", glowTypesExcepButtonOverlay))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_YOffset"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_YOffset", L["Y-Offset"], L["Y-Offset"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_YOffset", propertyType),
      order = order,
      softMin = -100,
      softMax = 100,
      step = 0.5,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_YOffset or 0;
      end,
      set = setValueComplex("glow_YOffset"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", glowTypesExcepButtonOverlay))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_scale"] = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_scale", L["Scale"], L["Scale"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_scale", propertyType),
      order = order,
      min = 0.05,
      softMax = 10,
      step = 0.05,
      isPercent = true,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_scale or 1;
      end,
      set = setValueComplex("glow_scale"),
      hidden = function()
        return not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", "ACShine"))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_border"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = blueIfNoValue2(data, conditions[i].changes[j], "value", "glow_border", L["Border"], L["Border"]),
      desc = descIfNoValue2(data, conditions[i].changes[j], "value", "glow_border", propertyType),
      order = order,
      get = function()
        return type(conditions[i].changes[j].value) == "table" and conditions[i].changes[j].value.glow_border;
      end,
      set = setValueComplex("glow_border"),
      hidden = function() return
        not (anyGlowExternal("glow_action", "show") and anyGlowExternal("glow_type", "Pixel"))
      end,
    }
    order = order + 1
    args["condition" .. i .. "value" .. j .. "glow_spacer"] = {
      type = "description",
      width = WeakAuras.doubleWidth,
      name = "",
      order = order,
      hidden = false,
    }
    order = order + 1
  else -- Unknown property type
    order = addSpace(args, order);
  end
  return order;
end


local function checkSameValue(samevalue, propertyType)
  if (propertyType == "chat") then
    return samevalue.message_type and samevalue.message;
  elseif (propertyType == "sound") then
    return samevalue.sound and samevalue.sound_type;
  elseif (propertyType == "customcode") then
    return samevalue.custom;
  else
    return samevalue;
  end
end

local function getOrCreateSubCheck(base, path)
  for _, i in ipairs(path) do
    base.checks = base.checks or {};
    base.checks[i] = base.checks[i] or {};
    base = base.checks[i];
  end
  return base;
end


local function getSubCheck(base, path)
  for _, i in ipairs(path) do
    if (not base.checks or not base.checks[i]) then
      return nil;
    end
    base = base.checks[i];
  end
  return base;
end

local function removeSubCheck(base, path)
  -- Ensures that the parents exists
  getOrCreateSubCheck(base, path);

  local choppedPath = CopyTable(path);
  tremove(choppedPath, #path);

  local parent = getSubCheck(base, choppedPath);
  tremove(parent.checks, path[#path]);
end

local function addControlsForIfLine(args, order, data, conditionVariable, totalAuraCount, conditions, i, path, conditionTemplates, conditionTemplateWithoutCombinations, allProperties, parentType)
  local check = getSubCheck(conditions[i].check, path);

  local indentDepth = min(#path, 3); -- Be reasonable
  local indentWidth = (indentDepth > 0 and 0.02 or 0) + indentDepth * 0.03;
  local normalWidth = WeakAuras.normalWidth - indentWidth;

  local conditionTemplatesToUse = indentDepth < 3 and conditionTemplates or conditionTemplateWithoutCombinations;

  local optionsName = blueIfSubset(data, conditions[i].check, totalAuraCount);
  local needsTriggerName = check and check.trigger and check.trigger ~= -1 and check.trigger ~= -2;
  if (parentType) then
    local isFirst = path[#path] == 1;
    if (isFirst) then
      if (needsTriggerName) then
        optionsName = optionsName .. OptionsPrivate.GetTriggerTitle(data, check.trigger)
      end
    else
      if (needsTriggerName) then
        if (parentType == "AND") then
          optionsName = optionsName .. string.format(L["and %s"], OptionsPrivate.GetTriggerTitle(data, check.trigger));
        else
          optionsName = optionsName .. string.format(L["or %s"], OptionsPrivate.GetTriggerTitle(data, check.trigger));
        end
      end
    end
  else
    local isLinked = conditions[i].linked and i > 1
    if (needsTriggerName) then
      if isLinked then
        optionsName = optionsName .. string.format(L["Else If %s"], OptionsPrivate.GetTriggerTitle(data, check.trigger));
      else
        optionsName = optionsName .. string.format(L["If %s"], OptionsPrivate.GetTriggerTitle(data, check.trigger));
      end
    else
        optionsName = optionsName .. (isLinked and L["Else If"] or L["If"])
    end
  end

  if (indentWidth > 0) then
    -- Our container frame is not exactly at width = 2, due to some legacy
    -- Typically that works fine because the next widget doesn't fit into
    -- previous line. But the bullets are so small that we need to ensure
    -- that the previous line is full
    args["space" .. order] = {
      type = "description",
      name = "",
      image = function() return "", 0, 0 end,
      order = order,
      width = WeakAuras.doubleWidth * 1.5,
    }
    order = order + 1;

    if (indentWidth > 0.05) then
      args["condition" .. i .. tostring(path) .. "indent"] = {
        type = "description",
        width = indentWidth - 0.05,
        name = "",
        order = order
      }
      order = order + 1;
    end

    args["condition" .. i .. tostring(path) .. "bullet"] = {
      type = "description",
      width = 0.05,
      name = "",
      order = order,
      image = "Interface\\Addons\\WeakAuras\\Media\\Textures\\bullet" .. indentDepth,
      imageWidth = 10,
      imageHeight = 10,
    }
    order = order + 1;
  end

  local valuesForIf;
  if (indentDepth > 0) then
    valuesForIf = conditionTemplatesToUse.displayWithRemove;
  else
    valuesForIf = isSubset(data, conditions[i].check, totalAuraCount) and conditionTemplatesToUse.displayWithCopy or conditionTemplatesToUse.display;
  end

  args["condition" .. i .. tostring(path) .. "if"] = {
    type = "select",
    name = optionsName,
    desc = descIfSubset(data, conditions[i].check, totalAuraCount),
    order = order,
    values = valuesForIf,
    width = normalWidth;
    set = function(info, v)
      if (conditionTemplatesToUse.indexToTrigger[v] == "COPY") then
        for child in OptionsPrivate.Private.TraverseLeafs(data) do
          if (conditions[i].check.references[child.id]) then
          -- Already exists
          else
            -- find a good insertion point, if any other condition has a reference to this
            -- insert directly after that
            local insertPoint = 1;
            for index = i, 1, -1 do
              if (conditions[index].check.references[child.id]) then
                insertPoint = index + 1;
                break;
              end
            end

            local condition = {};
            condition.check = {};
            condition.check.trigger = conditions[i].check.trigger;
            condition.check.variable = conditions[i].check.variable;
            condition.check.op = conditions[i].check.op;
            condition.check.value = conditions[i].check.value;
            if (conditions[i].check.checks) then
              condition.check.checks = CopyTable(conditions[i].check.checks);
            end

            condition.changes = {};
            for changeIndex, change in ipairs(conditions[i].changes) do
              local propertyType = change.property and allProperties.propertyMap[change.property] and allProperties.propertyMap[change.property].type
              if (checkSameValue(change.samevalue, propertyType)) then
                local copy = {};
                copy.property = change.property;
                if (type(change.value) == "table") then
                  copy.value = CopyTable(change.value);
                else
                  copy.value = change.value;
                end
                tinsert(condition.changes, copy);
              end
            end

            tinsert(child[conditionVariable], insertPoint, condition);
            WeakAuras.Add(child);
            OptionsPrivate.ClearOptions(child.id)
          end
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
        return;
      end

      if (conditionTemplatesToUse.indexToTrigger[v] == "REMOVE") then
        if (data.controlledChildren) then
          for id, reference in pairs(conditions[i].check.references) do
            local auraData = WeakAuras.GetData(id);
            removeSubCheck(auraData[conditionVariable][reference.conditionIndex].check, path);
            WeakAuras.Add(auraData)
            WeakAuras.ClearAndUpdateOptions(auraData.id)
          end
        else
          removeSubCheck(conditions[i].check, path);
          WeakAuras.Add(data)
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
        return;
      end

      local trigger = conditionTemplatesToUse.indexToTrigger[v];
      local variable = conditionTemplatesToUse.indexToVariable[v];
      if (not trigger or not variable) then
        return;
      end

      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].check.references) do
          local auraData = WeakAuras.GetData(id);
          local childCheck = getOrCreateSubCheck(auraData[conditionVariable][reference.conditionIndex].check, path);
          childCheck.variable = variable;
          childCheck.trigger = trigger;
          childCheck.value = nil;
          WeakAuras.Add(auraData);
          OptionsPrivate.ClearOptions(auraData.id)
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
      else
        local oldType;
        check = getOrCreateSubCheck(conditions[i].check, path);
        if (check.trigger and check.variable) then
          local templatesForTrigger = conditionTemplatesToUse.all[check.trigger];
          local templatesForTriggerAndCondition = templatesForTrigger and templatesForTrigger[check.variable];
          oldType = templatesForTriggerAndCondition and templatesForTriggerAndCondition.type;
        end
        check.variable = variable;
        check.trigger = trigger;
        local newType = conditionTemplatesToUse.all[trigger][variable].type;
        if (newType ~= oldType) then
          check.value = nil;
        end
        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end,
    get = function()
      local trigger = check and check.trigger;
      local variable = check and check.variable;
      if ( trigger and variable ) then
        return conditionTemplatesToUse.conditionToIndex[trigger .. "-" .. variable];
      end
      return "";
    end
  };

  order = order + 1;

  if (check and (check.variable == "AND" or check.variable == "OR")) then
    order = addSpace(args, order);

    local subCheckCount = check.checks and #check.checks or 0;
    -- We always want one more control than there are existing checks
    subCheckCount = subCheckCount + 1;

    for subCheck = 1, subCheckCount do
      local subPath = CopyTable(path);
      tinsert(subPath, subCheck);
      order = addControlsForIfLine(args, order, data, conditionVariable, totalAuraCount, conditions, i, subPath, conditionTemplates, conditionTemplateWithoutCombinations, allProperties, check.variable);
    end
  end

  local currentConditionTemplate = nil;
  local trigger = check and check.trigger;
  local variable = check and check.variable;
  if (trigger and variable) then
    if (conditionTemplatesToUse.all[trigger]) then
      currentConditionTemplate = conditionTemplatesToUse.all[trigger][variable];
    end
  end

  if (currentConditionTemplate and currentConditionTemplate.type and type(currentConditionTemplate.type) == "string") then
    local function makeSetter(field)
      if (data.controlledChildren) then
        return function(info, v)
          check = getOrCreateSubCheck(conditions[i].check, path);
          for id, reference in pairs(conditions[i].check.references) do
            local auraData = WeakAuras.GetData(id);
            local childCheck = getOrCreateSubCheck(auraData[conditionVariable][reference.conditionIndex].check, path);
            childCheck[field] = v;
            WeakAuras.Add(auraData);
            OptionsPrivate.ClearOptions(auraData.id)
          end
          check[field] = v;
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
      else
        return function(info, v)
          check = getOrCreateSubCheck(conditions[i].check, path);
          check[field] = v;
          WeakAuras.Add(data);
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
      end
    end

    local setOp = makeSetter("op")
    local setValue = makeSetter("value")

    if (currentConditionTemplate.type == "number" or currentConditionTemplate.type == "timer" or currentConditionTemplate.type == "elapsedTimer") then
      local opTypes = OptionsPrivate.Private.operator_types
      if currentConditionTemplate.operator_types == "without_equal" then
        opTypes = OptionsPrivate.Private.operator_types_without_equal
      elseif currentConditionTemplate.operator_types == "only_equal" then
        opTypes = OptionsPrivate.Private.equality_operator_types
      end

      args["condition" .. i .. tostring(path) .. "_op"] = {
        name = blueIfNoValue(data, conditions[i].check, "op", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "op", currentConditionTemplate.type),
        type = "select",
        order = order,
        values = opTypes,
        width = WeakAuras.halfWidth,
        get = function()
          return check.op;
        end,
        set = setOp,
      }
      order = order + 1;

      args["condition" .. i .. tostring(path) .. "_value"] = {
        type = "input",
        name = blueIfNoValue(data, conditions[i].check, "value", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type),
        width = WeakAuras.halfWidth,
        order = order,
        validate = WeakAuras.ValidateNumeric,
        get = function()
          return check.value;
        end,
        set = setValue
      }
      order = order + 1;
    elseif (currentConditionTemplate.type == "select") or (currentConditionTemplate.type == "unit") then
      if (type(currentConditionTemplate.values) == "table") then
        args["condition" .. i .. tostring(path) .. "_op"] = {
          name = blueIfNoValue(data, conditions[i].check, "op", L["Differences"]),
          desc = descIfNoValue(data, conditions[i].check, "op", currentConditionTemplate.type),
          type = "select",
          width = WeakAuras.normalWidth,
          order = order,
          values = OptionsPrivate.Private.equality_operator_types,
          get = function()
            return check.op;
          end,
          set = setOp,
        }
        order = order + 1;

        order = addSpace(args, order);

        if (currentConditionTemplate.type == "unit") then
          args["condition" .. i .. tostring(path) .. "_value"] = {
            type = "select",
            width = WeakAuras.normalWidth,
            name = blueIfNoValue(data, conditions[i].check, "value", L["Differences"]),
            desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type),
            order = order,
            values = currentConditionTemplate.values,
            get = function()
              return currentConditionTemplate.values[check.value] and check.value or (check.value and "member")
            end,
            set = setValue
          }
          order = order + 1;

          args["condition" .. i .. tostring(path) .. "_member"] = {
            type = "input",
            width = WeakAuras.doubleWidth,
            name = blueIfNoValue(data, conditions[i].check, "value", L["Differences"]),
            desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type),
            order = order,
            get = function()
              return check and check.value
            end,
            set = setValue,
            hidden = function()
              return not conditions[i].check.value or currentConditionTemplate.values[conditions[i].check.value] and conditions[i].check.value ~= "member"
            end
          }
          order = order + 1;
        else
          args["condition" .. i .. tostring(path) .. "_value"] = {
            type = "select",
            width = WeakAuras.normalWidth,
            name = blueIfNoValue(data, conditions[i].check, "value", L["Differences"]),
            desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type),
            order = order,
            values = currentConditionTemplate.values,
            get = function()
              return check.value
            end,
            set = setValue
          }
          order = order + 1;
        end
      end
    elseif (currentConditionTemplate.type == "bool") then
      args["condition" .. i .. tostring(path) .. "_value"] = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = blueIfNoValue(data, conditions[i].check, "value", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type),
        order = order,
        values = OptionsPrivate.Private.bool_types,
        get = function()
          return check and check.value;
        end,
        set = setValue
      }
      order = order + 1;
    elseif (currentConditionTemplate.type == "string") then
      if currentConditionTemplate.operator_types ~= "none" then
        args["condition" .. i .. tostring(path) .. "_op"] = {
          name = blueIfNoValue(data, conditions[i].check, "op", L["Differences"]),
          desc = descIfNoValue(data, conditions[i].check, "op", currentConditionTemplate.type),
          type = "select",
          width = WeakAuras.normalWidth,
          order = order,
          values = OptionsPrivate.Private.string_operator_types,
          get = function()
            return check and check.op;
          end,
          set = setOp
        }
        order = order + 1;
        order = addSpace(args, order);
      end

      args["condition" .. i .. tostring(path) .. "_value"] = {
        type = "input",
        width = WeakAuras.normalWidth,
        name = blueIfNoValue(data, conditions[i].check, "value", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type),
        order = order,
        get = function()
          return check and check.value;
        end,
        set = setValue
      }
      order = order + 1;
    elseif currentConditionTemplate.type == "alwaystrue" then
      order = addSpace(args, order)
    elseif (currentConditionTemplate.type == "range") then
      args["condition" .. i .. tostring(path) .. "_op_range"] = {
        name = blueIfNoValue(data, conditions[i].check, "op_range", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "op_range", currentConditionTemplate.type),
        type = "select",
        order = order,
        values = OptionsPrivate.Private.operator_types_without_equal,
        width = WeakAuras.halfWidth,
        get = function()
          return check.op_range;
        end,
        set = makeSetter("op_range"),
      }
      order = order + 1;

      args["condition" .. i .. tostring(path) .. "_range"] = {
        type = "input",
        name = L["Range in yards"],
        desc = descIfNoValue(data, conditions[i].check, "range", currentConditionTemplate.type),
        width = WeakAuras.halfWidth,
        order = order,
        validate = WeakAuras.ValidateNumeric,
        get = function()
          return check.range;
        end,
        set = makeSetter("range")
      }
      order = order + 1;

      if (indentWidth > 0) then
        args["condition" .. i .. tostring(path) .. "_space"] = {
          type = "description",
          name = "",
          order = order,
          width = WeakAuras.doubleWidth * 1.5,
        }
        order = order + 1;
        args["condition" .. i .. tostring(path) .. "_indent"] = {
          type = "description",
          width = indentWidth,
          name = "",
          order = order
        }
        order = order + 1;
      end

      args["condition" .. i .. tostring(path) .. "_type"] = {
        type = "select",
        width = normalWidth,
        name = blueIfNoValue(data, conditions[i].check, "type", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "type", currentConditionTemplate.type),
        order = order,
        values = {
          group = L["Group player(s) found"],
          enemies = L["Enemy nameplate(s) found"]
        },
        get = function()
          return check.type
        end,
        set = makeSetter("type"),
      }
      order = order + 1;

      args["condition" .. i .. tostring(path) .. "_op"] = {
        name = blueIfNoValue(data, conditions[i].check, "op", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "op", currentConditionTemplate.type),
        type = "select",
        order = order,
        values = OptionsPrivate.Private.operator_types,
        width = WeakAuras.halfWidth,
        get = function()
          return check.op;
        end,
        set = setOp,
      }
      order = order + 1;

      args["condition" .. i .. tostring(path) .. "_value"] = {
        type = "input",
        name = blueIfNoValue(data, conditions[i].check, "value", L["Differences"]),
        desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type),
        width = WeakAuras.halfWidth,
        order = order,
        validate = WeakAuras.ValidateNumeric,
        get = function()
          return check.value;
        end,
        set = setValue
      }
      order = order + 1;
    elseif currentConditionTemplate.type == "customcheck" then
      args["condition" .. i .. tostring(path) .. "_op"] = {
        name = blueIfNoValue(data, conditions[i].check, "op", L["Additional Events"], L["Additional Events"]),
        desc = descIfNoValue(data, conditions[i].check, "op", currentConditionTemplate.type) or "",
        type = "input",
        width = WeakAuras.doubleWidth,
        order = order,
        get = function()
          return check and check.op;
        end,
        set = setOp
      }
      order = order + 1;

      args["condition" .. i .. tostring(path) .. "_value"] = {
        type = "input",
        width = WeakAuras.doubleWidth,
        name = blueIfNoValue(data, conditions[i].check, "value", L["Custom Check"], L["Custom Check"]),
        desc = descIfNoValue(data, conditions[i].check, "value", currentConditionTemplate.type) or "",
        order = order,
        get = function()
          return check and check.value;
        end,
        set = setValue,
        multiline = true,
        control = "WeakAurasMultiLineEditBox",
        arg = {
          extraFunctions = {
            {
              buttonLabel = L["Expand"],
              func = function()
                if (data.controlledChildren) then
                  -- Collect multi paths
                  local multipath = {};
                  for id in pairs(conditions[i].check.references) do
                    local conditionIndex = conditions[i].check.references[id].conditionIndex;
                    multipath[id] ={ "conditions", conditionIndex, "check" }
                    for _, v in ipairs(path) do
                      tinsert(multipath[id], "checks")
                      tinsert(multipath[id], v)
                    end
                    tinsert(multipath[id], "value")
                  end
                  OptionsPrivate.OpenTextEditor(data, multipath, nil, true, nil, nil, "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-check");
                else
                  local fullPath = { "conditions", i, "check" }
                  for _, v in ipairs(path) do
                    tinsert(fullPath, "checks")
                    tinsert(fullPath, v)
                  end
                  tinsert(fullPath, "value")

                  OptionsPrivate.OpenTextEditor(data, fullPath, nil, nil, nil, nil, "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-check");
                end
              end
            }
          }
        }
      }
      order = order + 1

      args["condition" .. i .. tostring(path) .. "_value_error"] = {
        type = "description",
        name = function()
          if (not check.value) then
            return ""
          end
          local _, errorString = loadstring("return " .. check.value);
          return errorString and "|cFFFF0000"..errorString or "";
        end,
        width = WeakAuras.doubleWidth,
        order = order,
        hidden = function()
          if (not check.value) then
            return true;
          end

          local loadedFunction, errorString = loadstring("return " .. check.value);
          if(errorString and not loadedFunction) then
            return false;
          else
            return true;
          end
        end
      }
      order = order + 1
    elseif (currentConditionTemplate.type == "combination") then
      -- Do nothing
    else
      order = addSpace(args, order);
    end
  else
    order = addSpace(args, order);
  end
  return order;
end

local function fixUpLinkedInFirstCondition(conditions)
  if conditions[1] and conditions[1].linked then
    conditions[1].linked = false
  end
end

local function formatConditionTitle(text, propertyType, value)
  if propertyType == "color" and type(value) == "table" then
    local r, g, b = unpack(value)
    r, g, b = r or 1, g or 1, b or 1
    return ("|cFF%2x%2x%2x%s|r"):format(r * 220 + 35, g * 220 + 35, b * 220 + 35, text)
  elseif propertyType == "bool" then
    return ("%s: %s"):format(text, value and L["ON"] or L["OFF"])
  elseif propertyType == "sound" and type(value) == "table" and type(value.sound) == "string" and value.sound ~= "" then
    if OptionsPrivate.Private.sound_types[value.sound] then
      return ("%s: %s"):format(text, OptionsPrivate.Private.sound_types[value.sound])
    end
  elseif value ~= nil and type(value) ~= "table" then
    return ("%s: %s"):format(text, value)
  end
  return text
end

local function GetConditionTitle(changes, conditionnum, allProperties)
  if type(changes) == "table" and #changes > 0 then
    local outs = {}
    for i, change in ipairs(changes) do
      local property = change.property
      if property and allProperties.propertyMap[property] then
        local display = allProperties.propertyMap[property].display
        local propertyType = allProperties.propertyMap[property].type
        local title
        if type(display) == "string" then
          title = display
        elseif type(display) == "table" then
          title = ("%s %s"):format(display[1], display[2])
        end
        if title then
          tinsert(outs, formatConditionTitle(title, propertyType, change.value))
        end
      end
    end
    if #outs > 0 then
      return L["%i. %s"]:format(conditionnum, table.concat(outs, ", "))
    end
  end
  return L["%i."]:format(conditionnum)
end

local function addControlsForCondition(args, order, data, conditionVariable, totalAuraCount, conditions, i, conditionTemplates, conditionTemplateWithoutCombinations, allProperties)
  if (not conditions[i].check) then
    return order;
  end

  local defaultCollapsed = #conditions > 2
  local collapsed = false;
  if data.controlledChildren then
    for id, reference in pairs(conditions[i].check.references) do
      local index = reference.conditionIndex;
      if OptionsPrivate.IsCollapsed(id, "condition", index, defaultCollapsed) then
        collapsed = true;
        break;
      end
    end
  else
    collapsed = OptionsPrivate.IsCollapsed(data.id, "condition", i, defaultCollapsed);
  end

  args["condition" .. i .. "header"] = {
    type = "execute",
    name = GetConditionTitle(conditions[i].changes, i, allProperties),
    order = order,
    width = WeakAuras.doubleWidth - 0.6,
    func = function()
      if data.controlledChildren then
        for id, reference in pairs(conditions[i].check.references) do
          local index = reference.conditionIndex
          OptionsPrivate.SetCollapsed(id, "condition", index, not collapsed);
          OptionsPrivate.ClearOptions(id)
        end
      else
        OptionsPrivate.SetCollapsed(data.id, "condition", i, not collapsed);
      end
      WeakAuras.ClearAndUpdateOptions(data.id)
    end,
    image = collapsed and "Interface\\AddOns\\WeakAuras\\Media\\Textures\\expand" or "Interface\\AddOns\\WeakAuras\\Media\\Textures\\collapse" ,
    imageWidth = 18,
    imageHeight = 18,
    control = "WeakAurasExpand",
    fontObject = GameFontHighlight
  };
  order = order + 1;

  args["condition" .. i .. "up"] = {
    type = "execute",
    name = L["Move Up"],
    order = order,
    disabled = function()
      if (data.controlledChildren) then
        for _, reference in pairs(conditions[i].check.references) do
          local index = reference.conditionIndex;
          if (index > 1) then
            return false;
          end
        end
        return true;
      else
        return i == 1;
      end
    end,
    func = function()
      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].check.references) do
          local auraData = WeakAuras.GetData(id);
          local index = reference.conditionIndex;
          if (index > 1) then
            local tmp = auraData[conditionVariable][reference.conditionIndex];
            tremove(auraData[conditionVariable], reference.conditionIndex);
            tinsert(auraData[conditionVariable], reference.conditionIndex - 1, tmp);
            fixUpLinkedInFirstCondition(auraData[conditionVariable])
            WeakAuras.Add(auraData);
            OptionsPrivate.MoveCollapseDataUp(auraData.id, "condition", {reference.conditionIndex})
            OptionsPrivate.ClearOptions(auraData.id)
          end
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
      else
        if (i > 1) then
          local tmp = conditions[i];
          tremove(conditions, i);
          tinsert(conditions, i - 1, tmp);
          fixUpLinkedInFirstCondition(conditions)
          WeakAuras.Add(data);
          OptionsPrivate.MoveCollapseDataUp(data.id, "condition", {i})
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
      end
    end,
    width = 0.15,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\moveup",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  };
  order = order + 1;

  args["condition" .. i .. "down"] = {
    type = "execute",
    name = L["Move Down"],
    order = order,
    disabled = function()
      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].check.references) do
          local index = reference.conditionIndex;
          local auraData = WeakAuras.GetData(id);
          if (index < #auraData[conditionVariable]) then
            return false;
          end
        end
        return true;
      else
        return i == #conditions;
      end
    end,
    func = function()
      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].check.references) do
          local auraData = WeakAuras.GetData(id);
          local index = reference.conditionIndex;
          if (index < #auraData[conditionVariable]) then
            local tmp = auraData[conditionVariable][reference.conditionIndex];
            tremove(auraData[conditionVariable], reference.conditionIndex);
            tinsert(auraData[conditionVariable], reference.conditionIndex + 1, tmp);
            fixUpLinkedInFirstCondition(auraData[conditionVariable])
            WeakAuras.Add(auraData);
            OptionsPrivate.MoveCollapseDataDown(auraData.id, "condition", {reference.conditionIndex})
            OptionsPrivate.ClearOptions(auraData.id)
          end
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
        return;
      else
        if (i < #conditions) then
          local tmp = conditions[i];
          tremove(conditions, i);
          tinsert(conditions, i + 1, tmp);
          fixUpLinkedInFirstCondition(conditions)
          WeakAuras.Add(data);
          OptionsPrivate.MoveCollapseDataDown(data.id, "condition", {i})
          WeakAuras.ClearAndUpdateOptions(data.id)
          return;
        end
      end
    end,
    width = 0.15,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\movedown",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  };
  order = order + 1;

  args["condition" .. i .. "duplicate"] = {
    type = "execute",
    name = L["Duplicate"],
    order = order,
    func = function()
      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].check.references) do
          local auraData = WeakAuras.GetData(id);
          local clone = CopyTable(auraData[conditionVariable][reference.conditionIndex])
          tinsert(auraData[conditionVariable], reference.conditionIndex + 1, clone);
          WeakAuras.Add(auraData);
          OptionsPrivate.DuplicateCollapseData(auraData.id, "condition", {reference.conditionIndex})
          OptionsPrivate.ClearOptions(auraData.id)
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
        return;
      else
        local clone = CopyTable(conditions[i])
        tinsert(conditions, i + 1, clone);
        WeakAuras.Add(data);
        OptionsPrivate.DuplicateCollapseData(data.id, "condition", {i})
        WeakAuras.ClearAndUpdateOptions(data.id)
        return;
      end
    end,
    width = 0.15,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\duplicate",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  };
  order = order + 1;

  args["condition" .. i .. "delete"] = {
    type = "execute",
    name = L["Delete"],
    order = order,
    func = function()
      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].check.references) do
          local auraData = WeakAuras.GetData(id);
          tremove(auraData[conditionVariable], reference.conditionIndex);
          fixUpLinkedInFirstCondition(auraData[conditionVariable])
          WeakAuras.Add(auraData);
          OptionsPrivate.RemoveCollapsed(auraData.id, "condition", {reference.conditionIndex})
          OptionsPrivate.ClearOptions(auraData.id)
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
        return;
      else
        tremove(conditions, i);
        fixUpLinkedInFirstCondition(conditions)
        WeakAuras.Add(data);
        OptionsPrivate.RemoveCollapsed(data.id, "condition", {i})
        WeakAuras.ClearAndUpdateOptions(data.id)
        return;
      end
    end,
    width = 0.15,
    image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\delete",
    imageWidth = 24,
    imageHeight = 24,
    control = "WeakAurasIcon"
  };
  order = order + 1;

  if collapsed then
    return order;
  end

  order = addControlsForIfLine(args, order, data, conditionVariable, totalAuraCount, conditions, i, {}, conditionTemplates, conditionTemplateWithoutCombinations, allProperties);

  -- Add Property changes

  local usedProperties = {};
  for j = 1, conditions[i].changes and #conditions[i].changes or 0 do
    local property = conditions[i].changes[j].property;
    if (property) then
      usedProperties[property] = true;
    end
  end

  for j = 1, conditions[i].changes and #conditions[i].changes or 0 do
    order = addControlsForChange(args, order, data, conditionVariable, totalAuraCount, conditions, i, j, allProperties, usedProperties);
  end

  args["condition" .. i .. "_addChange"] = {
    type = "execute",
    width = WeakAuras.normalWidth,
    name = L["Add Property Change"],
    order = order,
    func = function()
      if (data.controlledChildren) then
        for id, reference in pairs(conditions[i].check.references) do
          local auradata = WeakAuras.GetData(id);
          auradata[conditionVariable][reference.conditionIndex].changes = auradata[conditionVariable][reference.conditionIndex].changes or {}
          tinsert(auradata[conditionVariable][reference.conditionIndex].changes, {})
          WeakAuras.Add(auradata);
          OptionsPrivate.ClearOptions(auradata.id)
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
      else
        conditions[i].changes = conditions[i].changes or {};
        conditions[i].changes[#conditions[i].changes + 1] = {};
        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end
  }
  order = order + 1;

  local showElseIf = false
  local isLinked = false

  if (data.controlledChildren) then
    for id, reference in pairs(conditions[i].check.references) do
      if reference.conditionIndex > 1 then
        local auradata = WeakAuras.GetData(id);
        isLinked = auradata[conditionVariable][reference.conditionIndex].linked
        showElseIf = true
        break;
      end
    end
  else
    if i > 1 then
      showElseIf = true
      isLinked = conditions[i].linked
    end
  end

  if showElseIf then
    args["condition" .. i .. "_else"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Else If"],
      order = order,
      get = function()
        return isLinked
      end,
      set = function()
        if (data.controlledChildren) then
          for id, reference in pairs(conditions[i].check.references) do
            local auradata = WeakAuras.GetData(id);
            if reference.conditionIndex > 1 then
              auradata[conditionVariable][reference.conditionIndex].linked = not isLinked
              WeakAuras.Add(auradata);
              OptionsPrivate.ClearOptions(auradata.id)
            end
          end
          WeakAuras.ClearAndUpdateOptions(data.id)
        else
          conditions[i].linked = not isLinked
          WeakAuras.Add(data);
          WeakAuras.ClearAndUpdateOptions(data.id)
        end
      end
    }
    order = order + 1;
  else
    order = addSpace(args, order)
  end

  return order;
end

local function mergeConditionTemplates(allConditionTemplates, auraConditionsTemplate, numTriggers)
  for triggernum = 1, numTriggers do
    local auraTemplatesForTrigger = auraConditionsTemplate[triggernum];
    if (auraTemplatesForTrigger) then
      allConditionTemplates[triggernum] = allConditionTemplates[triggernum] or {};
      for conditionName in pairs(auraTemplatesForTrigger) do
        if not allConditionTemplates[triggernum][conditionName] then
          allConditionTemplates[triggernum][conditionName] = CopyTable(auraTemplatesForTrigger[conditionName]);
        else
          if (allConditionTemplates[triggernum][conditionName].type ~= auraTemplatesForTrigger[conditionName].type) then
            -- Two different trigger types have a condition of the same name, with incompatible types
            -- Setting the type to incompatible prevents the interface from showing options for it
            -- This can't currently happen
            allConditionTemplates[triggernum][conditionName].type = "incompatible";
          end
        end
      end
    end
  end
end

local function createConditionTemplatesValueList(allConditionTemplates, numTriggers, excludeCombinations, data)
  local conditionTemplates = {};
  conditionTemplates.all = allConditionTemplates;
  conditionTemplates.indexToTrigger = {};
  conditionTemplates.indexToVariable = {};
  conditionTemplates.conditionToIndex = {};
  conditionTemplates.display = {};

  local index = 1;
  local startTriggernum = excludeCombinations and -1 or -2;
  for triggernum = startTriggernum, numTriggers do
    local templatesForTrigger = allConditionTemplates[triggernum];
    if triggernum ~= 0 then
      -- Sort Conditions for one trigger
      local sorted = {};
      if (templatesForTrigger) then
        for conditionName in pairs(templatesForTrigger) do
          tinsert(sorted, conditionName);
        end
        table.sort(sorted, function(a, b)
          return templatesForTrigger[a].display < templatesForTrigger[b].display;
        end);

        if (#sorted > 0) then
          if (triggernum == -2) then
            -- Do Nothing
            conditionTemplates.display[index]  = string.format(L["Combinations"]);
          elseif (triggernum == -1) then
            conditionTemplates.display[index]  = string.format(L["Global Conditions"]);
          else
            conditionTemplates.display[index]  = OptionsPrivate.GetTriggerTitle(data, triggernum)
          end
          index = index + 1;

          for _, conditionName in ipairs(sorted) do
            conditionTemplates.display[index] = "    " .. templatesForTrigger[conditionName].display;
            conditionTemplates.indexToTrigger[index] = triggernum;
            conditionTemplates.indexToVariable[index] = conditionName;
            conditionTemplates.conditionToIndex[triggernum .. "-" .. conditionName] = index;
            index = index + 1;
          end
        end
      end
    end
  end

  conditionTemplates.displayWithRemove = CopyTable(conditionTemplates.display);
  conditionTemplates.displayWithRemove[9997] = "" .. L["Remove"] .. "";
  conditionTemplates.indexToTrigger[9997] = "REMOVE";
  conditionTemplates.indexToVariable[9997] = "REMOVE";

  return conditionTemplates;
end

local function createConditionTemplates(data)
  -- The allConditionTemplates contains a table per trigger.
  -- Each table contains a entry per condition variable
  -- For the DropDown we need a flat and sorted list that maps
  -- from a index to a display name
  -- And two auxillary data structures which map to the index from triggernum/conditionvalue
  -- And from the index to triggernum/conditionvalue

  local allConditionTemplates;
  local numTriggers = 0;
  if (data.controlledChildren) then
    allConditionTemplates = {};
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      numTriggers = max(numTriggers, #child.triggers);

      local auraConditionsTemplate = OptionsPrivate.Private.GetTriggerConditions(child);
      mergeConditionTemplates(allConditionTemplates, auraConditionsTemplate, numTriggers)
    end
  else
    allConditionTemplates = OptionsPrivate.Private.GetTriggerConditions(data);
    numTriggers = #data.triggers;
  end

  allConditionTemplates[-2] = {
    ["AND"] = {
      display = L["All of"],
      type = "combination"
    },
    ["OR"] = {
      display = L["Any of"],
      type = "combination"
    }
  }
  allConditionTemplates[-1] = OptionsPrivate.Private.GetGlobalConditions();

  local conditionTemplates = createConditionTemplatesValueList(allConditionTemplates, numTriggers, nil, data);

  if (data.controlledChildren) then
    conditionTemplates.displayWithCopy = CopyTable(conditionTemplates.display);

    conditionTemplates.displayWithCopy[9998] = "" .. L["Copy to all auras"] .. "";
    conditionTemplates.indexToTrigger[9998] = "COPY";
    conditionTemplates.indexToVariable[9998] = "COPY";
  end

  local conditionTemplateWithoutCombinations = createConditionTemplatesValueList(allConditionTemplates, numTriggers, true, data);

  return conditionTemplates, conditionTemplateWithoutCombinations;
end

local function buildAllPotentialProperties(data, category)
  local allProperties = {};
  allProperties.propertyMap = {};
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
    local regionProperties = OptionsPrivate.Private.GetProperties(child);

    if (regionProperties) then
      for k, v in pairs(regionProperties) do
        if (v.category == category) then
          if (allProperties.propertyMap[k]) then
            if (allProperties.propertyMap[k].type ~= v.type) then
              allProperties.propertyMap[k].type = "incompatible";
            end

            if (allProperties.propertyMap[k].type == "list" or allProperties.propertyMap[k].type == "progressSource" ) then
              -- Merge value lists
              for key, value in pairs(v.values) do
                if (allProperties.propertyMap[k].values[key] == nil) then
                  allProperties.propertyMap[k].values[key] = value;
                end
              end
            end
          else
            allProperties.propertyMap[k] = CopyTable(v)
          end
        end
      end
    end
  end

  allProperties.indexToProperty = {};
  for k in pairs(allProperties.propertyMap) do
    tinsert(allProperties.indexToProperty, k);
  end
  table.sort(allProperties.indexToProperty, function(a, b)
    local av = allProperties.propertyMap[a].display
    av = type(av) == "table" and av[1] or av

    local bv = allProperties.propertyMap[b].display
    bv = type(bv) == "table" and bv[1] or bv
    return av < bv
  end);

  allProperties.propertyToIndex = {};
  for index, property in ipairs(allProperties.indexToProperty) do
    allProperties.propertyToIndex[property] = index;
  end

  allProperties.display = {};
  for index, property in ipairs(allProperties.indexToProperty) do
    allProperties.display[index] = allProperties.propertyMap[property].display;
  end

  allProperties.display[9999] = "" .. L["Remove this property"] .. "";
  allProperties.indexToProperty[9999] = "DELETE";

  if (data.controlledChildren) then
    allProperties.displayWithCopy = CopyTable(allProperties.display);

    allProperties.displayWithCopy[9998] = "" .. L["Copy to all auras"] .. "";
    allProperties.indexToProperty[9998] = "COPY";
  end

  return allProperties;
end

local function compareSubChecks(a, b, allConditionTemplates)
  if (a == nil and b == nil) then
    return true;
  end
  if (a == nil or b == nil) then
    return false;
  end

  if (#a ~= #b) then
    return false;
  end

  local count = #a;

  for i = 1, count do
    if (a[i].trigger ~= b[i].trigger or a[i].variable ~= b[i].variable) then
      return false;
    end

    if (a[i].trigger == -2) then
      if (not compareSubChecks(a[i].checks, b[i].checks, allConditionTemplates)) then
        return false;
      end
    else
      local currentConditionTemplate = allConditionTemplates[a[i].trigger] and allConditionTemplates[a[i].trigger][a[i].variable];
      if (not currentConditionTemplate) then
        return true;
      end

      local type = currentConditionTemplate.type;
      if (type == "number" or type == "timer" or type == "elapsedTimer" or type == "select" or type == "string" or type == "customcheck") then
        if (a[i].op ~= b[i].op or a[i].value ~= b[i].value) then
          return false;
        end
      elseif (type == "bool") then
        if (a[i].value ~= b[i].value) then
          return false;
        end
      elseif (type == "alwaystrue") then
        return true
      end
    end
  end
  return true;
end

local function findMatchingCondition(all, needle, start, allConditionTemplates)
  while (true) do
    local condition = all[start];
    if (not condition) then
      return nil;
    end

    if (condition.check.trigger == needle.check.trigger and condition.check.variable == needle.check.variable
        and condition.linked == needle.linked) then
      if condition.check.variable == "customcheck" then
        -- Be a bit more strict for custom checks, there's little benefit in merging them
        if condition.check.op == needle.check.op and condition.check.value == needle.check.value then
          return start
        end
      elseif (condition.check.trigger == -2) then
        if (compareSubChecks(condition.check.checks, needle.check.checks, allConditionTemplates)) then
          return start;
        end
      else
        return start;
      end
    end
    start = start + 1;
  end
end

local function findMatchingProperty(all, change, id)
  for index, allChange in ipairs(all) do
    if (allChange.property == change.property) then
      local alreadyReferenced = allChange.references and allChange.references[id];
      if (not alreadyReferenced) then
        return index;
      end
    end
  end
  return nil;
end

local function SubPropertiesForChange(change)
  if change.property == "sound" then
    return { "sound", "sound_channel", "sound_path", "sound_kit_id", "sound_repeat", "sound_type", "sound_fade"}
  elseif change.property == "customcode" then
    return { "custom" }
  elseif change.property == "glowexternal" then
    return {
      "glow_action", "glow_frame_type", "glow_type",
      "glow_frame", "choose_glow_frame",
      "use_glow_color", "glow_color",
      "glow_startAnim", "glow_duration", "glow_lines", "glow_frequency", "glow_length", "glow_thickness", "glow_XOffset", "glow_YOffset",
      "glow_scale", "glow_border"
    }
  elseif change.property == "chat" then
    local result = { "message_type", "message_dest", "message_channel", "message_color", "message", "custom", "message_voice" }
    local input = change.value and change.value.message
    if input then
      local getter = function(key)
        return change.value["message_format_" .. key]
      end
      OptionsPrivate.AddTextFormatOption(input, false, getter, function(key)
        tinsert(result, "message_format_" .. key)
      end, nil, nil, true)
    end
    return result
  end
end

local subPropertyToType = {
  glow_color = "color",
  message_color = "color"
}

local function mergeConditionChange(all, change, id, changeIndex, allProperties)
  local propertyType = all.property and allProperties.propertyMap[all.property] and allProperties.propertyMap[all.property].type
  if (propertyType == "chat" or propertyType == "sound" or propertyType == "customcode" or propertyType == "glowexternal") then
    if (type(all.value) ~= type(change.value)) then
      all.value = nil;
      all.samevalue = nil;
    else
      if (type(change.value) ~= "table") then
        if not compareValues(all.value, change.value, propertyType) then
          all.value = nil;
          all.samevalue = false;
        end
      else
        for _, propertyName in ipairs(SubPropertiesForChange(change)) do
          if all.samevalue[propertyName] == nil then
            -- NEW not yet seen property
            all.value[propertyName] = change.value[propertyName]
            all.samevalue[propertyName] = true
          elseif not compareValues(all.value[propertyName], change.value[propertyName], subPropertyToType[propertyName]) then
            all.value[propertyName] = nil;
            if all.samevalue then
              all.samevalue[propertyName] = false;
            end
          end
        end
      end
    end
  else
    if not compareValues(all.value, change.value, propertyType) then
      all.value = nil;
      all.samevalue = false;
    end
  end

  all.references = all.references or {};
  all.references[id] = {
    ["changeIndex"] = changeIndex,
    ["value"] = change.value
  };
  all.referenceCount = (all.referenceCount or 0) + 1;

end

local function mergeCondition(all, aura, id, conditionIndex, allProperties)
  if (all.check.op ~= aura.check.op) then
    all.check.op = nil;
    all.check.sameop = false;
  end

  if (all.check.value ~= aura.check.value) then
    all.check.value = nil;
    all.check.samevalue = false;
  end


  all.check.references = all.check.references or {};
  all.check.references[id] = {
    ["conditionIndex"] = conditionIndex,
    ["op"] = aura.check.op,
    ["value"] = aura.check.value
  };
  all.check.referenceCount = (all.check.referenceCount or 0) + 1;

  -- Merge properties
  local currentInsertPoint = 1;
  for changeIndex, change in ipairs(aura.changes) do
    local matchIndex = findMatchingProperty(all.changes, change, id);
    if (not matchIndex) then
      local copy = CopyTable(change);

      local propertyType = change.property and allProperties.propertyMap[change.property] and allProperties.propertyMap[change.property].type;
      if (propertyType == "chat" or propertyType == "sound" or propertyType == "customcode" or propertyType == "glowexternal") then
        copy.samevalue = {};
        for _, propertyName in ipairs(SubPropertiesForChange(change)) do
          copy.samevalue[propertyName] = true;
        end
      else
        copy.samevalue = true;
      end
      copy.references = {};
      copy.references[id] = {
        ["changeIndex"] = changeIndex,
        ["value"] = copy.value
      }

      copy.referenceCount = 1;
      tinsert(all.changes, currentInsertPoint, copy);
      currentInsertPoint = currentInsertPoint + 1;
    else
      mergeConditionChange(all.changes[matchIndex], change, id, changeIndex, allProperties);
      currentInsertPoint = matchIndex + 1;
    end
  end
end

local function mergeConditions(all, aura, id, allConditionTemplates, propertyTypes)
  if (not aura) then
    return;
  end

  local currentInsertPoint = 1;
  for conditionIndex, condition in ipairs(aura) do
    local match = findMatchingCondition(all, condition, currentInsertPoint, allConditionTemplates);
    if (not match) then
      local copy = CopyTable(condition);
      copy.check.samevalue = true;
      copy.check.sameop = true;
      copy.check.references = {};
      copy.check.references[id] = {
        ["conditionIndex"] = conditionIndex,
        ["op"] = condition.check.op,
        ["value"] = condition.check.value
      };
      copy.check.referenceCount = 1;

      if (copy.changes) then
        for changeIndex, change in pairs(copy.changes) do
          local propertyType = change.property and propertyTypes.propertyMap[change.property] and propertyTypes.propertyMap[change.property].type;
          if (propertyType == "chat" or propertyType == "sound" or propertyType == "customcode" or propertyType == "glowexternal") then
            change.samevalue = {};
            for _, propertyName in ipairs(SubPropertiesForChange(change)) do
              change.samevalue[propertyName] = true;
            end
          else
            change.samevalue = true;
          end
          change.references = {};
          change.references[id] = {
            ["changeIndex"] = changeIndex,
            ["value"] = condition.changes[changeIndex].value
          };
          change.referenceCount = 1;
        end
      end

      tinsert(all, currentInsertPoint, copy);
      currentInsertPoint = currentInsertPoint + 1;
    else
      mergeCondition(all[match], condition, id, conditionIndex, propertyTypes);
      currentInsertPoint = match + 1;
    end
  end
end

local fixupConditions = function(conditions)
  for _, condition in ipairs(conditions) do
    condition.check = condition.check or {}
    condition.changes = condition.changes or {}
  end
end

function OptionsPrivate.GetConditionOptions(data)
  local  options = {
    type = "group",
    name = L["Conditions"],
    order = 25,
    args = {}
  }

  local args = options.args

  local conditionVariable = "conditions"
  local startorder = 0
  local category = nil
  -- Build potential Conditions Templates structure
  local conditionTemplates, conditionTemplateWithoutCombinations = createConditionTemplates(data);

  -- Build potential properties structure
  local allProperties = buildAllPotentialProperties(data, category);

  -- Build currently selected conditions
  local conditions;
  local totalAuraCount

  if (data.controlledChildren) then
    local allChildren = {}
    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      tinsert(allChildren, child)
    end
    totalAuraCount = #allChildren

    conditions = {};
    for index = totalAuraCount, 1, -1 do
      local child = allChildren[index]
      fixupConditions(child[conditionVariable])
      mergeConditions(conditions, child[conditionVariable], child.id, conditionTemplates.all, allProperties);
    end
  else
    totalAuraCount = 1
    data[conditionVariable] = data[conditionVariable] or {};
    conditions = data[conditionVariable];
    fixupConditions(data[conditionVariable])
  end

  local order = startorder;
  for i = 1, #conditions do
    order = addControlsForCondition(args, order, data, conditionVariable, totalAuraCount, conditions, i, conditionTemplates, conditionTemplateWithoutCombinations, allProperties);
  end

  args["addConditionHeader"] = {
    type = "header",
    width = WeakAuras.doubleWidth,
    name = "",
    order = order
  }
  order = order + 1

  args["addCondition"] = {
    type = "execute",
    width = WeakAuras.normalWidth,
    name = L["Add Condition"],
    order = order,
    func = function()
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
        child[conditionVariable][#child[conditionVariable] + 1] = {};
        child[conditionVariable][#child[conditionVariable]].check = {};
        child[conditionVariable][#child[conditionVariable]].changes = {};
        child[conditionVariable][#child[conditionVariable]].changes[1] = {}
        child[conditionVariable][#child[conditionVariable]].category = category;
        OptionsPrivate.SetCollapsed(child.id, "condition", #child[conditionVariable], false);
        WeakAuras.Add(child);
        OptionsPrivate.ClearOptions(child.id)
      end
      WeakAuras.ClearAndUpdateOptions(data.id)
    end
  }
  order = order + 1;

  return options;
end

=== END OF FILE: WeakAurasOptions/ConditionOptions.lua ===


=== FILE: WeakAurasOptions/DisplayOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)
local L = WeakAuras.L

local flattenRegionOptions = OptionsPrivate.commonOptions.flattenRegionOptions
local fixMetaOrders = OptionsPrivate.commonOptions.fixMetaOrders
local parsePrefix = OptionsPrivate.commonOptions.parsePrefix
local removeFuncs = OptionsPrivate.commonOptions.removeFuncs
local replaceNameDescFuncs = OptionsPrivate.commonOptions.replaceNameDescFuncs
local replaceImageFuncs = OptionsPrivate.commonOptions.replaceImageFuncs
local replaceValuesFuncs = OptionsPrivate.commonOptions.replaceValuesFuncs
local disabledAll = OptionsPrivate.commonOptions.CreateDisabledAll("region")
local hiddenAll = OptionsPrivate.commonOptions.CreateHiddenAll("region")
local getAll = OptionsPrivate.commonOptions.CreateGetAll("region")
local setAll = OptionsPrivate.commonOptions.CreateSetAll("region", getAll)

local function AddSubRegion(data, subRegionName)
  for data in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
    data.subRegions = data.subRegions or {}
    if OptionsPrivate.Private.subRegionTypes[subRegionName] and OptionsPrivate.Private.subRegionTypes[subRegionName] then
      if OptionsPrivate.Private.subRegionTypes[subRegionName].supports(data.regionType) then
        local default = OptionsPrivate.Private.subRegionTypes[subRegionName].default
        local subRegionData = type(default) == "function" and default(data.regionType) or CopyTable(default)
        subRegionData.type = subRegionName
        tinsert(data.subRegions, subRegionData)
        WeakAuras.Add(data)
        OptionsPrivate.ClearOptions(data.id)
      end
    end
  end
  WeakAuras.ClearAndUpdateOptions(data.id)
end

local function AddOptionsForSupportedSubRegion(regionOption, data, supported)
  if not next(supported) then
    return
  end
  local hasSubRegions = false

  local result = {}
  local order = 1
  result.__order = 300
  result.__title = L["Add Extra Elements"]
  result.__topLine = true
  result.__withoutheader = true
  result["subregiontypespace"] = {
    type = "description",
    width = WeakAuras.doubleWidth,
    name = "",
    order = order,
  }
  order = order + 1
  for subRegionType in pairs(supported) do
    if OptionsPrivate.Private.subRegionTypes[subRegionType].supportsAdd then
      hasSubRegions = true
      result[subRegionType] = {
        type = "execute",
        width = WeakAuras.normalWidth,
        name = string.format(L["Add %s"], OptionsPrivate.Private.subRegionTypes[subRegionType].displayName),
        order = order,
        func = function()
          AddSubRegion(data, subRegionType)
        end,
      }
      order = order + 1
    end
  end
  regionOption["sub"] = result;
  return hasSubRegions
end

local function union(table1, table2)
  local meta = {};
  for i,v in pairs(table1) do
    meta[i] = v;
  end
  for i,v in pairs(table2) do
    meta[i] = v;
  end
  return meta;
end

function OptionsPrivate.GetDisplayOptions(data)
  local id = data.id

  if not data.controlledChildren then
    local regionOption;
    local commonOption = {};

    local hasSubElements = false

    if(OptionsPrivate.Private.regionOptions[data.regionType]) then
      regionOption = OptionsPrivate.Private.regionOptions[data.regionType].create(id, data);

      if data.subRegions then
        local subIndex = {}
        for index, subRegionData in ipairs(data.subRegions) do
          local subRegionType = subRegionData.type
          if OptionsPrivate.Private.subRegionOptions[subRegionType] then
            hasSubElements = true
            subIndex[subRegionType] = subIndex[subRegionType] and subIndex[subRegionType] + 1 or 1
            local options, common = OptionsPrivate.Private.subRegionOptions[subRegionType].create(data, subRegionData, index, subIndex[subRegionType])
            options.__order = 200 + index
            options.__collapsed = true
            regionOption["sub." .. index .. "." .. subRegionType] = options
            commonOption[subRegionType] = common
          end
        end
      end

      local commonOptionIndex = 0
      for option, optionData in pairs(commonOption) do
        commonOptionIndex = commonOptionIndex + 1
        optionData.__order = 100 + commonOptionIndex
        regionOption[option] = optionData
      end

      local supported = {}
      for subRegionName, subRegionType in pairs(OptionsPrivate.Private.subRegionTypes) do
        if subRegionType.supports(data.regionType) then
          supported[subRegionName] = true
        end
      end
      hasSubElements = AddOptionsForSupportedSubRegion(regionOption, data, supported) or hasSubElements
    else
      regionOption = {
        [data.regionType] = {
          __title = "|cFFFFFF00" .. data.regionType,
          __order = 1,
          unsupported = {
            type = "description",
            name = L["This region of type \"%s\" is not supported."]:format(data.regionType),
            order = 2,
          }
        }
      };
    end

    if hasSubElements then
      regionOption["SubElementsHeader"] = {
        __order = 100,
        __noHeader = true,
        header = {
          type = "header",
          name = L["Sub Elements"],
          order = 1
        }
      }
    end

    local options = flattenRegionOptions(regionOption, true)

    for _, option in pairs(options) do
      if option.type == "range" then
        option.control = "WeakAurasSpinBox"
      end
    end

    local region = {
      type = "group",
      name = L["Display"],
      order = 10,
      get = function(info)
        local base, property = parsePrefix(info[#info], data);
        if not base then
          return nil
        end
        if(info.type == "color") then
          base[property] = base[property] or {};
          local c = base[property];
          return c[1], c[2], c[3], c[4];
        else
          return base[property];
        end
      end,
      set = function(info, v, g, b, a)
        local base, property = parsePrefix(info[#info], data, true);
        if(info.type == "color") then
          base[property] = base[property] or {};
          local c = base[property];
          c[1], c[2], c[3], c[4] = v, g, b, a;
        elseif(info.type == "toggle") then
          base[property] = v;
        else
          base[property] = (v ~= "" and v) or nil;
        end
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.Private.AddParents(data)
        OptionsPrivate.ResetMoverSizer();
      end,
      args = options
    };
    return region
  else
    -- Multiple Auras
    -- We call the create functions of the relevant region types with
    -- the parentData once per region type
    -- For sub regions, the relevant create function is called with the parentData
    -- once per index/sub region type
    local handledRegionTypes = {}
    local handledSubRegionTypes = {}

    local allOptions = {};
    local commonOption = {};
    local unsupportedCount = 0
    local supportedSubRegions = {}
    local hasSubElements = false

    for child in OptionsPrivate.Private.TraverseLeafs(data) do
      if child and not handledRegionTypes[child.regionType] then
        handledRegionTypes[child.regionType] = true;
        if OptionsPrivate.Private.regionOptions[child.regionType] then
          allOptions = union(allOptions, OptionsPrivate.Private.regionOptions[child.regionType].create(id, data));
        else
          unsupportedCount = unsupportedCount + 1
          allOptions["__unsupported" .. unsupportedCount] =  {
            __title = "|cFFFFFF00" .. child.regionType,
            __order = 1,
            warning = {
              type = "description",
              name = L["Regions of type \"%s\" are not supported."]:format(child.regionType),
              order = 1
            },
          }
        end
        for subRegionName, subRegionType in pairs(OptionsPrivate.Private.subRegionTypes) do
          if subRegionType.supports(child.regionType) then
            supportedSubRegions[subRegionName] = true
          end
        end
      end
      if child.subRegions then
        local subIndex = {}
        for index, subRegionData in ipairs(child.subRegions) do
          local subRegionType = subRegionData.type
          local alreadyHandled = handledSubRegionTypes[index] and handledSubRegionTypes[index][subRegionType]
          if OptionsPrivate.Private.subRegionOptions[subRegionType] and not alreadyHandled then
            handledSubRegionTypes[index] = handledSubRegionTypes[index] or {}
            handledSubRegionTypes[index][subRegionType] = true
            hasSubElements = true
            subIndex[subRegionType] = subIndex[subRegionType] and subIndex[subRegionType] + 1 or 1

            local options, common = OptionsPrivate.Private.subRegionOptions[subRegionType].create(data, nil, index, subIndex[subRegionType])
            options.__order = 200 + index

            allOptions["sub." .. index .. "." .. subRegionType] = options
            commonOption[subRegionType] = common
          end
        end
      end
    end

    local commonOptionIndex = 0
    for option, optionData in pairs(commonOption) do
      commonOptionIndex = commonOptionIndex + 1
      optionData.__order = 100 + commonOptionIndex
      allOptions[option] = optionData
    end

    hasSubElements = AddOptionsForSupportedSubRegion(allOptions, data, supportedSubRegions) or hasSubElements

    if hasSubElements then
      allOptions["SubElementsHeader"] = {
        __order = 100,
        __noHeader = true,
        header = {
          order = 1,
          type = "header",
          name = L["Sub Elements"],
        }
      }
    end

    fixMetaOrders(allOptions);

    local region = {
      type = "group",
      name = L["Display"],
      order = 10,
      args = flattenRegionOptions(allOptions, false);
    };

    removeFuncs(region);
    replaceNameDescFuncs(region, data, "region");
    replaceImageFuncs(region, data, "region");
    replaceValuesFuncs(region, data, "region");

    region.get = function(info, ...) return getAll(data, info, ...); end;
    region.set = function(info, ...)
      setAll(data, info, ...);
      if(type(data.id) == "string") then
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
      end
    end
    region.hidden = function(info, ...) return hiddenAll(data, info, ...); end;
    region.disabled = function(info, ...) return disabledAll(data, info, ...); end;
    return region
  end

end

=== END OF FILE: WeakAurasOptions/DisplayOptions.lua ===


=== FILE: WeakAurasOptions/ForAllIndentsAndPurposes.lua ===
if not WeakAuras.IsLibsOK() then return end

-- For All Indents And Purposes
local revision = 23
-- Maintainer: kristofer.karlsson@gmail.com

-- For All Indents And Purposes -
-- a indentation + syntax highlighting library
-- All valid lua code should be processed correctly.

-- Usage (for developers)
--------
-- Variant 1: - non embedded
-- 1) Add ForAllIndentsAndPurposes to your dependencies (or optional dependencies)

-- Variant 2: - embedded
-- 1.a) Copy indent.lua to your addon directory
-- 1.b) Put indent.lua first in your list of files in the TOC

-- For both variants:
-- 2) hook the editboxes that you want to have indentation like this:
-- IndentationLib.enable(editbox [, colorTable [, tabWidth] ])
-- if you don't select a color table, it will use the default.
-- Read through this code for further usage help.
-- (The documentation IS the code)

-- luacheck: globals IndentationLib

if not IndentationLib then
    IndentationLib = {}
end

if not IndentationLib.revision or revision > IndentationLib.revision then
    local lib = IndentationLib
    lib.revision = revision

    local stringlen = string.len
    local stringformat = string.format
    local stringfind = string.find
    local stringsub = string.sub
    local stringbyte = string.byte
    local stringchar = string.char
    local stringrep = string.rep
    local stringgsub = string.gsub

    local defaultTabWidth = 2
    local defaultColorTable

    local workingTable = {}
    local workingTable2 = {}
    local function tableclear(t)
        for k in next,t do
            t[k] = nil
        end
    end

    local function stringinsert(s, pos, insertStr)
        return stringsub(s, 1, pos) .. insertStr .. stringsub(s, pos + 1)
    end
    lib.stringinsert = stringinsert

    local function stringdelete(s, pos1, pos2)
        return stringsub(s, 1, pos1 - 1) .. stringsub(s, pos2 + 1)
    end
    lib.stringdelete = stringdelete

    -- token types
    local tokens = {}
    lib.tokens = tokens
    tokens.TOKEN_UNKNOWN = 0
    tokens.TOKEN_NUMBER = 1
    tokens.TOKEN_LINEBREAK = 2
    tokens.TOKEN_WHITESPACE = 3
    tokens.TOKEN_IDENTIFIER = 4
    tokens.TOKEN_ASSIGNMENT = 5
    tokens.TOKEN_EQUALITY = 6
    tokens.TOKEN_MINUS = 7
    tokens.TOKEN_COMMENT_SHORT = 8
    tokens.TOKEN_COMMENT_LONG = 9
    tokens.TOKEN_STRING = 10
    tokens.TOKEN_LEFTBRACKET = 11
    tokens.TOKEN_PERIOD = 12
    tokens.TOKEN_DOUBLEPERIOD = 13
    tokens.TOKEN_TRIPLEPERIOD = 14
    tokens.TOKEN_LTE = 15
    tokens.TOKEN_LT = 16
    tokens.TOKEN_GTE = 17
    tokens.TOKEN_GT = 18
    tokens.TOKEN_NOTEQUAL = 19
    tokens.TOKEN_COMMA = 20
    tokens.TOKEN_SEMICOLON = 21
    tokens.TOKEN_COLON = 22
    tokens.TOKEN_LEFTPAREN = 23
    tokens.TOKEN_RIGHTPAREN = 24
    tokens.TOKEN_PLUS = 25
    tokens.TOKEN_SLASH = 27
    tokens.TOKEN_LEFTWING = 28
    tokens.TOKEN_RIGHTWING = 29
    tokens.TOKEN_CIRCUMFLEX = 30
    tokens.TOKEN_ASTERISK = 31
    tokens.TOKEN_RIGHTBRACKET = 32
    tokens.TOKEN_KEYWORD = 33
    tokens.TOKEN_SPECIAL = 34
    tokens.TOKEN_VERTICAL = 35
    tokens.TOKEN_TILDE = 36
    -- WoW specific tokens
    tokens.TOKEN_COLORCODE_START = 37
    tokens.TOKEN_COLORCODE_STOP = 38
    -- new as of lua 5.1
    tokens.TOKEN_HASH = 39
    tokens.TOKEN_PERCENT = 40


    -- ascii codes
    local bytes = {}
    lib.bytes = bytes
    bytes.BYTE_LINEBREAK_UNIX = stringbyte("\n")
    bytes.BYTE_LINEBREAK_MAC = stringbyte("\r")
    bytes.BYTE_SINGLE_QUOTE = stringbyte("'")
    bytes.BYTE_DOUBLE_QUOTE = stringbyte('"')
    bytes.BYTE_0 = stringbyte("0")
    bytes.BYTE_9 = stringbyte("9")
    bytes.BYTE_PERIOD = stringbyte(".")
    bytes.BYTE_SPACE = stringbyte(" ")
    bytes.BYTE_TAB = stringbyte("\t")
    bytes.BYTE_E = stringbyte("E")
    bytes.BYTE_e = stringbyte("e")
    bytes.BYTE_MINUS = stringbyte("-")
    bytes.BYTE_EQUALS = stringbyte("=")
    bytes.BYTE_LEFTBRACKET = stringbyte("[")
    bytes.BYTE_RIGHTBRACKET = stringbyte("]")
    bytes.BYTE_BACKSLASH = stringbyte("\\")
    bytes.BYTE_COMMA = stringbyte(",")
    bytes.BYTE_SEMICOLON = stringbyte(";")
    bytes.BYTE_COLON = stringbyte(":")
    bytes.BYTE_LEFTPAREN = stringbyte("(")
    bytes.BYTE_RIGHTPAREN = stringbyte(")")
    bytes.BYTE_TILDE = stringbyte("~")
    bytes.BYTE_PLUS = stringbyte("+")
    bytes.BYTE_SLASH = stringbyte("/")
    bytes.BYTE_LEFTWING = stringbyte("{")
    bytes.BYTE_RIGHTWING = stringbyte("}")
    bytes.BYTE_CIRCUMFLEX = stringbyte("^")
    bytes.BYTE_ASTERISK = stringbyte("*")
    bytes.BYTE_LESSTHAN = stringbyte("<")
    bytes.BYTE_GREATERTHAN = stringbyte(">")
    -- WoW specific chars
    bytes.BYTE_VERTICAL = stringbyte("|")
    bytes.BYTE_r = stringbyte("r")
    bytes.BYTE_c = stringbyte("c")
    -- new as of lua 5.1
    bytes.BYTE_HASH = stringbyte("#")
    bytes.BYTE_PERCENT = stringbyte("%")


    local linebreakCharacters = {}
    lib.linebreakCharacters = linebreakCharacters
    linebreakCharacters[bytes.BYTE_LINEBREAK_UNIX] = 1
    linebreakCharacters[bytes.BYTE_LINEBREAK_MAC] = 1

    local whitespaceCharacters = {}
    lib.whitespaceCharacters = whitespaceCharacters
    whitespaceCharacters[bytes.BYTE_SPACE] = 1
    whitespaceCharacters[bytes.BYTE_TAB] = 1

    local specialCharacters = {}
    lib.specialCharacters = specialCharacters
    specialCharacters[bytes.BYTE_PERIOD] = -1
    specialCharacters[bytes.BYTE_LESSTHAN] = -1
    specialCharacters[bytes.BYTE_GREATERTHAN] = -1
    specialCharacters[bytes.BYTE_LEFTBRACKET] = -1
    specialCharacters[bytes.BYTE_EQUALS] = -1
    specialCharacters[bytes.BYTE_MINUS] = -1
    specialCharacters[bytes.BYTE_SINGLE_QUOTE] = -1
    specialCharacters[bytes.BYTE_DOUBLE_QUOTE] = -1
    specialCharacters[bytes.BYTE_TILDE] = -1
    specialCharacters[bytes.BYTE_RIGHTBRACKET] = tokens.TOKEN_RIGHTBRACKET
    specialCharacters[bytes.BYTE_COMMA] = tokens.TOKEN_COMMA
    specialCharacters[bytes.BYTE_COLON] = tokens.TOKEN_COLON
    specialCharacters[bytes.BYTE_SEMICOLON] = tokens.TOKEN_SEMICOLON
    specialCharacters[bytes.BYTE_LEFTPAREN] = tokens.TOKEN_LEFTPAREN
    specialCharacters[bytes.BYTE_RIGHTPAREN] = tokens.TOKEN_RIGHTPAREN
    specialCharacters[bytes.BYTE_PLUS] = tokens.TOKEN_PLUS
    specialCharacters[bytes.BYTE_SLASH] = tokens.TOKEN_SLASH
    specialCharacters[bytes.BYTE_LEFTWING] = tokens.TOKEN_LEFTWING
    specialCharacters[bytes.BYTE_RIGHTWING] = tokens.TOKEN_RIGHTWING
    specialCharacters[bytes.BYTE_CIRCUMFLEX] = tokens.TOKEN_CIRCUMFLEX
    specialCharacters[bytes.BYTE_ASTERISK] = tokens.TOKEN_ASTERISK
    -- WoW specific
    specialCharacters[bytes.BYTE_VERTICAL] = -1
    -- new as of lua 5.1
    specialCharacters[bytes.BYTE_HASH] = tokens.TOKEN_HASH
    specialCharacters[bytes.BYTE_PERCENT] = tokens.TOKEN_PERCENT

    local function nextNumberExponentPartInt(text, pos)
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_NUMBER, pos
            end

            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                pos = pos + 1
            else
                return tokens.TOKEN_NUMBER, pos
            end
        end
    end

    local function nextNumberExponentPart(text, pos)
        local byte = stringbyte(text, pos)
        if not byte then
            return tokens.TOKEN_NUMBER, pos
        end

        if byte == bytes.BYTE_MINUS then
            -- handle this case: a = 1.2e-- some comment
            -- i decide to let 1.2e be parsed as a a number
            byte = stringbyte(text, pos + 1)
            if byte == bytes.BYTE_MINUS then
                return tokens.TOKEN_NUMBER, pos
            end
            return nextNumberExponentPartInt(text, pos + 1)
        end

        return nextNumberExponentPartInt(text, pos)
    end

    local function nextNumberFractionPart(text, pos)
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_NUMBER, pos
            end

            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                pos = pos + 1
            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then
                return nextNumberExponentPart(text, pos + 1)
            else
                return tokens.TOKEN_NUMBER, pos
            end
        end
    end

    local function nextNumberIntPart(text, pos)
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_NUMBER, pos
            end

            if byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                pos = pos + 1
            elseif byte == bytes.BYTE_PERIOD then
                return nextNumberFractionPart(text, pos + 1)
            elseif byte == bytes.BYTE_E or byte == bytes.BYTE_e then
                return nextNumberExponentPart(text, pos + 1)
            else
                return tokens.TOKEN_NUMBER, pos
            end
        end
    end

    local function nextIdentifier(text, pos)
        while true do
            local byte = stringbyte(text, pos)

            if not byte or
            linebreakCharacters[byte] or
            whitespaceCharacters[byte] or
            specialCharacters[byte] then
                return tokens.TOKEN_IDENTIFIER, pos
            end
            pos = pos + 1
        end
    end

    -- returns false or: true, nextPos, equalsCount
    local function isBracketStringNext(text, pos)
        local byte = stringbyte(text, pos)
        if byte == bytes.BYTE_LEFTBRACKET then
            local pos2 = pos + 1
            byte = stringbyte(text, pos2)
            while byte == bytes.BYTE_EQUALS do
                pos2 = pos2 + 1
                byte = stringbyte(text, pos2)
            end
            if byte == bytes.BYTE_LEFTBRACKET then
                return true, pos2 + 1, (pos2 - 1) - pos
            else
                return false
            end
        else
            return false
        end
    end

    -- Already parsed the [==[ part when get here
    local function nextBracketString(text, pos, equalsCount)
        local state = 0
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_STRING, pos
            end

            if byte == bytes.BYTE_RIGHTBRACKET then
                if state == 0 then
                    state = 1
                elseif state == equalsCount + 1 then
                    return tokens.TOKEN_STRING, pos + 1
                else
                    state = 0
                end
            elseif byte == bytes.BYTE_EQUALS then
                if state > 0 then
                    state = state + 1
                end
            else
                state = 0
            end
            pos = pos + 1
        end
    end

    local function nextComment(text, pos)
        -- When we get here we have already parsed the "--"
        -- Check for long comment
        local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)
        if isBracketString then
            local tokenType, nextPos2 = nextBracketString(text, nextPos, equalsCount)
            return tokens.TOKEN_COMMENT_LONG, nextPos2
        end

        local byte = stringbyte(text, pos)

        -- Short comment, find the first linebreak
        while true do
            byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_COMMENT_SHORT, pos
            end
            if linebreakCharacters[byte] then
                return tokens.TOKEN_COMMENT_SHORT, pos
            end
            pos = pos + 1
        end
    end

    local function nextString(text, pos, character)
        local even = true
        while true do
            local byte = stringbyte(text, pos)
            if not byte then
                return tokens.TOKEN_STRING, pos
            end

            if byte == character then
                if even then
                    return tokens.TOKEN_STRING, pos + 1
                end
            end
            if byte == bytes.BYTE_BACKSLASH then
                even = not even
            else
                even = true
            end

            pos = pos + 1
        end
    end

    -- INPUT
    -- 1: text: text to search in
    -- 2: tokenPos:  where to start searching
    -- OUTPUT
    -- 1: token type
    -- 2: position after the last character of the token
    local function nextToken(text, pos)
        local byte = stringbyte(text, pos)
        if not byte then
            return nil
        end

        if linebreakCharacters[byte] then
            return tokens.TOKEN_LINEBREAK, pos + 1
        end

        if whitespaceCharacters[byte] then
            while true do
                pos = pos + 1
                byte = stringbyte(text, pos)
                if not byte or not whitespaceCharacters[byte] then
                    return tokens.TOKEN_WHITESPACE, pos
                end
            end
        end

        local token = specialCharacters[byte]
        if token then
            if token ~= -1 then
                return token, pos + 1
            end

            -- WoW specific (for color codes)
            if byte == bytes.BYTE_VERTICAL then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_VERTICAL then
                    return tokens.TOKEN_VERTICAL, pos + 2
                end
                if byte == bytes.BYTE_c then
                    return tokens.TOKEN_COLORCODE_START, pos + 10
                end
                if byte == bytes.BYTE_r then
                    return tokens.TOKEN_COLORCODE_STOP, pos + 2
                end
                return tokens.TOKEN_UNKNOWN, pos + 1
            end

            if byte == bytes.BYTE_MINUS then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_MINUS then
                    return nextComment(text, pos + 2)
                end
                return tokens.TOKEN_MINUS, pos + 1
            end

            if byte == bytes.BYTE_SINGLE_QUOTE then
                return nextString(text, pos + 1, bytes.BYTE_SINGLE_QUOTE)
            end

            if byte == bytes.BYTE_DOUBLE_QUOTE then
                return nextString(text, pos + 1, bytes.BYTE_DOUBLE_QUOTE)
            end

            if byte == bytes.BYTE_LEFTBRACKET then
                local isBracketString, nextPos, equalsCount = isBracketStringNext(text, pos)
                if isBracketString then
                    return nextBracketString(text, nextPos, equalsCount)
                else
                    return tokens.TOKEN_LEFTBRACKET, pos + 1
                end
            end

            if byte == bytes.BYTE_EQUALS then
                byte = stringbyte(text, pos + 1)
                if not byte then
                    return tokens.TOKEN_ASSIGNMENT, pos + 1
                end
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_EQUALITY, pos + 2
                end
                return tokens.TOKEN_ASSIGNMENT, pos + 1
            end

            if byte == bytes.BYTE_PERIOD then
                byte = stringbyte(text, pos + 1)
                if not byte then
                    return tokens.TOKEN_PERIOD, pos + 1
                end
                if byte == bytes.BYTE_PERIOD then
                    byte = stringbyte(text, pos + 2)
                    if byte == bytes.BYTE_PERIOD then
                        return tokens.TOKEN_TRIPLEPERIOD, pos + 3
                    end
                    return tokens.TOKEN_DOUBLEPERIOD, pos + 2
                elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
                    return nextNumberFractionPart(text, pos + 2)
                end
                return tokens.TOKEN_PERIOD, pos + 1
            end

            if byte == bytes.BYTE_LESSTHAN then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_LTE, pos + 2
                end
                return tokens.TOKEN_LT, pos + 1
            end

            if byte == bytes.BYTE_GREATERTHAN then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_GTE, pos + 2
                end
                return tokens.TOKEN_GT, pos + 1
            end

            if byte == bytes.BYTE_TILDE then
                byte = stringbyte(text, pos + 1)
                if byte == bytes.BYTE_EQUALS then
                    return tokens.TOKEN_NOTEQUAL, pos + 2
                end
                return tokens.TOKEN_TILDE, pos + 1
            end

            return tokens.TOKEN_UNKNOWN, pos + 1
        elseif byte >= bytes.BYTE_0 and byte <= bytes.BYTE_9 then
            return nextNumberIntPart(text, pos + 1)
        else
            return nextIdentifier(text, pos + 1)
        end
    end

    -- Cool stuff begins here! (indentation and highlighting)

    local noIndentEffect = {0, 0}
    local indentLeft = {-1, 0}
    local indentRight = {0, 1}
    local indentBoth = {-1, 1}

    local keywords = {}
    lib.keywords = keywords
    keywords["and"] = noIndentEffect
    keywords["break"] = noIndentEffect
    keywords["false"] = noIndentEffect
    keywords["for"] = noIndentEffect
    keywords["if"] = noIndentEffect
    keywords["in"] = noIndentEffect
    keywords["local"] = noIndentEffect
    keywords["nil"] = noIndentEffect
    keywords["not"] = noIndentEffect
    keywords["or"] = noIndentEffect
    keywords["return"] = noIndentEffect
    keywords["true"] = noIndentEffect
    keywords["while"] = noIndentEffect

    keywords["until"] = indentLeft
    keywords["elseif"] = indentLeft
    keywords["end"] = indentLeft

    keywords["do"] = indentRight
    keywords["then"] = indentRight
    keywords["repeat"] = indentRight
    keywords["function"] = indentRight

    keywords["else"] = indentBoth

    local tokenIndentation = {}
    lib.tokenIndentation = tokenIndentation
    tokenIndentation[tokens.TOKEN_LEFTPAREN] = indentRight
    tokenIndentation[tokens.TOKEN_LEFTBRACKET] = indentRight
    tokenIndentation[tokens.TOKEN_LEFTWING] = indentRight

    tokenIndentation[tokens.TOKEN_RIGHTPAREN] = indentLeft
    tokenIndentation[tokens.TOKEN_RIGHTBRACKET] = indentLeft
    tokenIndentation[tokens.TOKEN_RIGHTWING] = indentLeft

    local function fillWithTabs(n)
        return stringrep("\t", n)
    end

    local function fillWithSpaces(a, b)
        return stringrep(" ", a*b)
    end

    function lib.colorCodeCode(code, colorTable, caretPosition)
        local stopColor = colorTable and colorTable[0]
        if not stopColor then
            return code, caretPosition
        end

        local stopColorLen = stringlen(stopColor)

        tableclear(workingTable)
        local tsize = 0
        local totalLen = 0

        local numLines = 0
        local newCaretPosition
        local prevTokenWasColored = false
        local prevTokenWidth = 0

        local pos = 1
        local level = 0

        while true do
            if caretPosition and not newCaretPosition and pos >= caretPosition then
                if pos == caretPosition then
                    newCaretPosition = totalLen
                else
                    newCaretPosition = totalLen
                    local diff = pos - caretPosition
                    if diff > prevTokenWidth then
                        diff = prevTokenWidth
                    end
                    if prevTokenWasColored then
                        diff = diff + stopColorLen
                    end
                    newCaretPosition = newCaretPosition - diff
                end
            end

            prevTokenWasColored = false
            prevTokenWidth = 0

            local tokenType, nextPos = nextToken(code, pos)

            if not tokenType then
                break
            end

            if tokenType == tokens.TOKEN_COLORCODE_START or tokenType == tokens.TOKEN_COLORCODE_STOP or tokenType == tokens.TOKEN_UNKNOWN then
                -- ignore color codes
            elseif tokenType == tokens.TOKEN_LINEBREAK or tokenType == tokens.TOKEN_WHITESPACE then
                if tokenType == tokens.TOKEN_LINEBREAK then
                    numLines = numLines + 1
                end
                local str = stringsub(code, pos, nextPos - 1)
                prevTokenWidth = nextPos - pos

                tsize = tsize + 1
                workingTable[tsize] = str
                totalLen = totalLen + stringlen(str)
            else
                local str = stringsub(code, pos, nextPos - 1)

                prevTokenWidth = nextPos - pos

                -- Add coloring
                if keywords[str] then
                    tokenType = tokens.TOKEN_KEYWORD
                end

                local color
                if stopColor then
                    color = colorTable[str]
                    if not color then
                        color = colorTable[tokenType]
                        if not color then
                            if tokenType == tokens.TOKEN_IDENTIFIER then
                                color = colorTable[tokens.TOKEN_IDENTIFIER]
                            else
                                color = colorTable[tokens.TOKEN_SPECIAL]
                            end
                        end
                    end
                end

                if color then
                    tsize = tsize + 1
                    workingTable[tsize] = color
                    tsize = tsize + 1
                    workingTable[tsize] = str
                    tsize = tsize + 1
                    workingTable[tsize] = stopColor

                    totalLen = totalLen + stringlen(color) + (nextPos - pos) + stopColorLen
                    prevTokenWasColored = true
                else
                    tsize = tsize + 1
                    workingTable[tsize] = str

                    totalLen = totalLen + stringlen(str)
                end
            end

            pos = nextPos
        end
        return table.concat(workingTable), newCaretPosition, numLines
    end

    function lib.indentCode(code, tabWidth, colorTable, caretPosition)
        local fillFunction
        if tabWidth == nil then
            tabWidth = defaultTabWidth
        end
        if tabWidth then
            fillFunction = fillWithSpaces
        else
            fillFunction = fillWithTabs
        end

        tableclear(workingTable)
        local tsize = 0
        local totalLen = 0

        tableclear(workingTable2)
        local tsize2 = 0
        local totalLen2 = 0

        local stopColor = colorTable and colorTable[0]
        local stopColorLen = not stopColor or stringlen(stopColor)

        local newCaretPosition
        local newCaretPositionFinalized = false
        local prevTokenWasColored = false
        local prevTokenWidth = 0

        local pos = 1
        local level = 0

        local hitNonWhitespace = false
        local hitIndentRight = false
        local preIndent = 0
        local postIndent = 0
        while true do
            if caretPosition and not newCaretPosition and pos >= caretPosition then
                if pos == caretPosition then
                    newCaretPosition = totalLen + totalLen2
                else
                    newCaretPosition = totalLen + totalLen2
                    local diff = pos - caretPosition
                    if diff > prevTokenWidth then
                        diff = prevTokenWidth
                    end
                    if prevTokenWasColored then
                        diff = diff + stopColorLen
                    end
                    newCaretPosition = newCaretPosition - diff
                end
            end

            prevTokenWasColored = false
            prevTokenWidth = 0

            local tokenType, nextPos = nextToken(code, pos)

            if not tokenType or tokenType == tokens.TOKEN_LINEBREAK then
                level = level + preIndent
                if level < 0 then level = 0 end

                local s = fillFunction(level, tabWidth)

                tsize = tsize + 1
                workingTable[tsize] = s
                totalLen = totalLen + stringlen(s)

                if newCaretPosition and not newCaretPositionFinalized then
                    newCaretPosition = newCaretPosition + stringlen(s)
                    newCaretPositionFinalized = true
                end

                for k, v in next,workingTable2 do
                    tsize = tsize + 1
                    workingTable[tsize] = v
                    totalLen = totalLen + stringlen(v)
                end

                if not tokenType then
                    break
                end

                tsize = tsize + 1
                workingTable[tsize] = stringsub(code, pos, nextPos - 1)
                totalLen = totalLen + nextPos - pos

                level = level + postIndent
                if level < 0 then level = 0 end

                tableclear(workingTable2)
                tsize2 = 0
                totalLen2 = 0

                hitNonWhitespace = false
                hitIndentRight = false
                preIndent = 0
                postIndent = 0
            elseif tokenType == tokens.TOKEN_WHITESPACE then
                if hitNonWhitespace then
                    prevTokenWidth = nextPos - pos
                    tsize2 = tsize2 + 1
                    local s = stringsub(code, pos, nextPos - 1)
                    workingTable2[tsize2] = s
                    totalLen2 = totalLen2 + stringlen(s)
                end
            elseif tokenType == tokens.TOKEN_COLORCODE_START or tokenType == tokens.TOKEN_COLORCODE_STOP or tokenType == tokens.TOKEN_UNKNOWN then
                -- skip these, though they shouldn't be encountered here anyway
            else
                hitNonWhitespace = true
                local str = stringsub(code, pos, nextPos - 1)
                prevTokenWidth = nextPos - pos

                -- See if this is an indent-modifier
                local indentTable
                if tokenType == tokens.TOKEN_IDENTIFIER then
                    indentTable = keywords[str]
                else
                    indentTable = lib.tokenIndentation[tokenType]
                end

                if indentTable then
                    if hitIndentRight then
                        postIndent = postIndent + indentTable[1] + indentTable[2]
                    else
                        local pre = indentTable[1]
                        local post = indentTable[2]
                        if post > 0 then
                            hitIndentRight = true
                        end
                        preIndent = preIndent + pre
                        postIndent = postIndent + post
                    end
                end

                -- Add coloring
                if keywords[str] then
                    tokenType = tokens.TOKEN_KEYWORD
                end

                local color
                if stopColor then
                    color = colorTable[str]
                    if not color then
                        color = colorTable[tokenType]
                        if not color then
                            if tokenType == tokens.TOKEN_IDENTIFIER then
                                color = colorTable[tokens.TOKEN_IDENTIFIER]
                            else
                                color = colorTable[tokens.TOKEN_SPECIAL]
                            end
                        end
                    end
                end

                if color then
                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = color
                    totalLen2 = totalLen2 + stringlen(color)

                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = str
                    totalLen2 = totalLen2 + nextPos - pos

                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = stopColor
                    totalLen2 = totalLen2 + stopColorLen

                    prevTokenWasColored = true
                else
                    tsize2 = tsize2 + 1
                    workingTable2[tsize2] = str
                    totalLen2 = totalLen2 + nextPos - pos

                end
            end
            pos = nextPos
        end
        return table.concat(workingTable), newCaretPosition
    end

    -- WoW specific code:
    local GetTime = GetTime

    local editboxSetText
    local editboxGetText

    -- Caret code (thanks Tem!)
    local function critical_enter(editbox)
        local script = editbox:GetScript("OnTextSet")
        if script then
            editbox:SetScript("OnTextSet", nil)
        end
        return script
    end

    local function critical_leave(editbox, script)
        if script then
            editbox:SetScript("OnTextSet", script)
        end
    end

    local function setCaretPos_main(editbox, pos)
        local text = editboxGetText(editbox)

        if stringlen(text) > 0 then
            editboxSetText(editbox, stringinsert(text, pos, "a"))
            editbox:HighlightText(pos, pos + 1)
            editbox:Insert("\0")
        end
    end

    local function getCaretPos(editbox)
        local script = critical_enter(editbox)

        local text = editboxGetText(editbox)
        editbox:Insert("")
        local pos = stringfind(editboxGetText(editbox), "", 1, 1)
        editboxSetText(editbox, text)

        if pos then
            setCaretPos_main(editbox, pos - 1)
        end
        critical_leave(editbox, script)

        return (pos or 0) - 1
    end

    local function setCaretPos(editbox, pos)
        local script, script2 = critical_enter(editbox)
        setCaretPos_main(editbox, pos)
        critical_leave(editbox, script, script2)
    end
    -- end of caret code

    function lib.stripWowColors(code)

        -- HACK!
        -- This is a fix for a bug, where an unfinished string causes a lot of newlines to be created.
        -- The reason for the bug, is that a |r\n\n gets converted to \n\n|r after the next indent-run
        -- The fix is to remove those last two linebreaks when stripping
        code = stringgsub(code, "|r\n\n$", "|r")

        tableclear(workingTable)
        local tsize = 0

        local pos = 1

        local prevVertical = false
        local even = true
        local selectionStart = 1

        while true do
            local byte = stringbyte(code, pos)
            if not byte then
                break
            end
            if byte == bytes.BYTE_VERTICAL then
                even = not even
                prevVertical = true
            else
                if prevVertical and not even then
                    if byte == bytes.BYTE_c then

                        if pos - 2 >= selectionStart then
                            tsize = tsize + 1
                            workingTable[tsize] = stringsub(code, selectionStart, pos - 2)
                        end

                        pos = pos + 8
                        selectionStart = pos + 1
                    elseif byte == bytes.BYTE_r then

                        if pos - 2 >= selectionStart then
                            tsize = tsize + 1
                            workingTable[tsize] = stringsub(code, selectionStart, pos - 2)
                        end
                        selectionStart = pos + 1
                    end
                end
                prevVertical = false
                even = true
            end
            pos = pos + 1
        end
        if pos >= selectionStart then
            tsize = tsize + 1
            workingTable[tsize] = stringsub(code, selectionStart, pos - 1)
        end
        return table.concat(workingTable)
    end

    function lib.decode(code)
        if code then
            code = lib.stripWowColors(code)
            code = stringgsub(code, "||", "|")
        end
        return code or ""
    end

    function lib.encode(code)
        if code then
            code = stringgsub(code, "|", "||")
        end
        return code or ""
    end

    function lib.stripWowColorsWithPos(code, pos)
        code = stringinsert(code, pos, "\2")
        code = lib.stripWowColors(code)
        pos = stringfind(code, "\2", 1, 1)
        code = stringdelete(code, pos, pos)
        return code, pos
    end

    -- returns the padded code, and true if modified, false if unmodified
    local linebreak = stringbyte("\n")
    function lib.padWithLinebreaks(code)
        local len = stringlen(code)
        local linebreakcount = 0
        while len > 0 and linebreakcount < 2 do
            local b = stringbyte(code, len)
            if b == linebreak then
                linebreakcount = linebreakcount + 1
            elseif whitespaceCharacters[b] then
                -- Ignore whitespace characters
            else
                break
            end
            len = len - 1
        end

        if linebreakcount == 0 then
            return code .. "\n\n", true
        elseif linebreakcount == 1 then
            return code .. "\n", true
        else
            return code, false
        end
    end

    -- Data tables
    -- No weak table magic, since editboxes can never be removed in WoW
    local enabled = {}
    local dirty = {}

    local editboxIndentCache = {}
    local decodeCache = {}
    local editboxStringCache = {}
    local editboxNumLinesCache = {}

    function lib.colorCodeEditbox(editbox)
        dirty[editbox] = nil

        local colorTable = editbox.faiap_colorTable or defaultColorTable
        local tabWidth = editbox.faiap_tabWidth

        local orgCode = editboxGetText(editbox)
        local prevCode = editboxStringCache[editbox]
        if prevCode == orgCode then
            return
        end

        local pos = getCaretPos(editbox)

        local code
        code, pos = lib.stripWowColorsWithPos(orgCode, pos)

        colorTable[0] = "|r"

        local newCode, newPos, numLines = lib.colorCodeCode(code, colorTable, pos)
        newCode = lib.padWithLinebreaks(newCode)

        editboxStringCache[editbox] = newCode
        if orgCode ~= newCode then
            local script, script2 = critical_enter(editbox)
            decodeCache[editbox] = nil
            local stringlenNewCode = stringlen(newCode)

            editboxSetText(editbox, newCode)
            if newPos then
                if newPos < 0 then newPos = 0 end
                if newPos > stringlenNewCode then newPos = stringlenNewCode end

                setCaretPos(editbox, newPos)
            end
            critical_leave(editbox, script, script2)
        end

        if editboxNumLinesCache[editbox] ~= numLines then
            lib.indentEditbox(editbox)
        end
        editboxNumLinesCache[editbox] = numLines
    end

    function lib.indentEditbox(editbox)
        dirty[editbox] = nil

        local colorTable = editbox.faiap_colorTable or defaultColorTable
        local tabWidth = editbox.faiap_tabWidth

        local orgCode = editboxGetText(editbox)
        local prevCode = editboxIndentCache[editbox]
        if prevCode == orgCode then
            return
        end

        local pos = getCaretPos(editbox)

        local code
        code, pos = lib.stripWowColorsWithPos(orgCode, pos)

        colorTable[0] = "|r"
        local newCode, newPos = lib.indentCode(code, tabWidth, colorTable, pos)
        newCode = lib.padWithLinebreaks(newCode)
        editboxIndentCache[editbox] = newCode
        if code ~= newCode then
            local script, script2 = critical_enter(editbox)
            decodeCache[editbox] = nil

            local stringlenNewCode = stringlen(newCode)

            editboxSetText(editbox, newCode)

            if newPos then
                if newPos < 0 then newPos = 0 end
                if newPos > stringlenNewCode then newPos = stringlenNewCode end

                setCaretPos(editbox, newPos)
            end
            critical_leave(editbox, script, script2)
        end
    end

    local function hookHandler(editbox, handler, newFun)
        local oldFun = editbox:GetScript(handler)
        if oldFun == newFun then
            -- already hooked, ignore it
            return
        end
        editbox["faiap_old_" .. handler] = oldFun
        editbox:SetScript(handler, newFun)
    end

    local function textChangedHook(editbox, ...)
        local oldFun = editbox["faiap_old_OnTextChanged"]
        if oldFun then
            oldFun(editbox, ...)
        end
        if enabled[editbox] and not editbox:IsInIMECompositionMode() then
            dirty[editbox] = GetTime()
        end
    end

    local function tabPressedHook(editbox, ...)
        local oldFun = editbox["faiap_old_OnTabPressed"]
        if oldFun then
            oldFun(editbox, ...)
        end
        if enabled[editbox] then
            return lib.indentEditbox(editbox)
        end
    end

    local function onUpdateHook(editbox, ...)
        local oldFun = editbox["faiap_old_OnUpdate"]
        if oldFun then
            oldFun(editbox, ...)
        end
        if enabled[editbox] and not editbox:IsInIMECompositionMode() then
            local now = GetTime()
            local lastUpdate = dirty[editbox] or now
            if now - lastUpdate > 0.2 then
                decodeCache[editbox] = nil
                return lib.colorCodeEditbox(editbox)
            end
        end
    end

    local function newGetText(editbox)
        local decoded = decodeCache[editbox]
        if not decoded then
            decoded = lib.decode(editboxGetText(editbox))
            decodeCache[editbox] = decoded
        end
        return decoded or ""
    end

    local function newSetText(editbox, text)
        decodeCache[editbox] = nil
        if text then
            local encoded = lib.encode(text)

            return editboxSetText(editbox, encoded)
        end
    end

    function lib.enable(editbox, colorTable, tabWidth)
        if not editboxSetText then
            editboxSetText = editbox.SetText
            editboxGetText = editbox.GetText
        end

        local modified
        if editbox.faiap_colorTable ~= colorTable then
            editbox.faiap_colorTable = colorTable
            modified = true
        end
        if editbox.faiap_tabWidth ~= tabWidth then
            editbox.faiap_tabWidth = tabWidth
            modified = true
        end

        if enabled[editbox] then
            if modified then
                lib.indentEditbox(editbox)
            end
            return
        end

        -- Editbox is possibly hooked, but disabled
        enabled[editbox] = true

        editbox.oldMaxBytes = editbox:GetMaxBytes()
        editbox.oldMaxLetters = editbox:GetMaxLetters()
        editbox:SetMaxBytes(0)
        editbox:SetMaxLetters(0)

        editbox.GetText = newGetText
        editbox.SetText = newSetText

        hookHandler(editbox, "OnTextChanged", textChangedHook)
        hookHandler(editbox, "OnTabPressed", tabPressedHook)
        hookHandler(editbox, "OnUpdate", onUpdateHook)

        lib.indentEditbox(editbox)
    end

    -- Deprecated function
    lib.addSmartCode = lib.enable

    function lib.disable(editbox)
        if not enabled[editbox] then
            return
        end
        enabled[editbox] = nil

        -- revert settings for max bytes / letters
        editbox:SetMaxBytes(editbox.oldMaxBytes)
        editbox:SetMaxLetters(editbox.oldMaxLetters)

        -- try a real unhooking, if possible
        if editbox:GetScript("OnTextChanged") == textChangedHook then
            editbox:SetScript("OnTextChanged", editbox.faiap_old_OnTextChanged)
            editbox.faiap_old_OnTextChanged = nil
        end

        if editbox:GetScript("OnTabPressed") == tabPressedHook then
            editbox:SetScript("OnTabPressed", editbox.faiap_old_OnTabPressed)
            editbox.faiap_old_OnTabPressed = nil
        end

        if editbox:GetScript("OnUpdate") == onUpdateHook then
            editbox:SetScript("OnUpdate", editbox.faiap_old_OnUpdate)
            editbox.faiap_old_OnUpdate = nil
        end

        editbox.GetText = nil
        editbox.SetText = nil

        -- change the text back to unformatted
        editbox:SetText(newGetText(editbox))

        -- clear caches
        editboxIndentCache[editbox] = nil
        decodeCache[editbox] = nil
        editboxStringCache[editbox] = nil
        editboxNumLinesCache[editbox] = nil
    end

    defaultColorTable = {}
    lib.defaultColorTable = defaultColorTable
    defaultColorTable[tokens.TOKEN_SPECIAL] = "|c00ff99ff"
    defaultColorTable[tokens.TOKEN_KEYWORD] = "|c006666ff"
    defaultColorTable[tokens.TOKEN_COMMENT_SHORT] = "|c00999999"
    defaultColorTable[tokens.TOKEN_COMMENT_LONG] = "|c00999999"

    local stringColor = "|c00ffff77"
    defaultColorTable[tokens.TOKEN_STRING] = stringColor
    defaultColorTable[".."] = stringColor

    local tableColor = "|c00ff9900"
    defaultColorTable["..."] = tableColor
    defaultColorTable["{"] = tableColor
    defaultColorTable["}"] = tableColor
    defaultColorTable["["] = tableColor
    defaultColorTable["]"] = tableColor

    local arithmeticColor = "|c0033ff55"
    defaultColorTable[tokens.TOKEN_NUMBER] = arithmeticColor
    defaultColorTable["+"] = arithmeticColor
    defaultColorTable["-"] = arithmeticColor
    defaultColorTable["/"] = arithmeticColor
    defaultColorTable["*"] = arithmeticColor

    local logicColor1 = "|c0055ff88"
    defaultColorTable["=="] = logicColor1
    defaultColorTable["<"] = logicColor1
    defaultColorTable["<="] = logicColor1
    defaultColorTable[">"] = logicColor1
    defaultColorTable[">="] = logicColor1
    defaultColorTable["~="] = logicColor1

    local logicColor2 = "|c0088ffbb"
    defaultColorTable["and"] = logicColor2
    defaultColorTable["or"] = logicColor2
    defaultColorTable["not"] = logicColor2

    defaultColorTable[0] = "|r"

end

-- just for testing
--[[
function testTokenizer()
  local str = ""
  for line in io.lines("indent.lua") do
   str = str .. line .. "\n"
  end

  local pos = 1

  while true do
   local tokenType, nextPos = nextToken(str, pos)

   if not tokenType then
  break
   end

   if true or tokenType ~= tokens.TOKEN_WHITESPACE and tokenType ~= tokens.TOKEN_LINEBREAK then
  print(stringformat("Found token %d (%d-%d): (%s)", tokenType, pos, nextPos - 1, stringsub(str, pos, nextPos - 1)))
   end

   if tokenType == tokens.TOKEN_UNKNOWN then
  print("unknown token!")
  break
   end

   pos = nextPos
  end
end


function testIndenter(i)
  local lib = IndentationLib
  local str = ""
  for line in io.lines("test.lua") do
   str = str .. line .. "\n"
  end

  local colorTable = lib.defaultColorTable
  print(lib.indentCode(str, 4, colorTable, i))
end


testIndenter()

--]]

=== END OF FILE: WeakAurasOptions/ForAllIndentsAndPurposes.lua ===


=== FILE: WeakAurasOptions/GenericTrigger.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function GetCustomTriggerOptions(data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  local function appendToTriggerPath(...)
    local ret = {...};
    tinsert(ret, 1, "trigger");
    tinsert(ret, 1, triggernum);
    tinsert(ret, 1, "triggers");
    return ret;
  end

  local function appendToUntriggerPath(...)
    local ret = {...};
    tinsert(ret, 1, "untrigger");
    tinsert(ret, 1, triggernum);
    tinsert(ret, 1, "triggers");
    return ret;
  end

  local customOptions =
  {
    custom_type = {
      type = "select",
      name = L["Event Type"],
      order = 7,
      width = WeakAuras.doubleWidth,
      values = OptionsPrivate.Private.custom_trigger_types,
      hidden = function() return not (trigger.type == "custom") end,
      get = function()
        return trigger.custom_type
      end,
      set = function(info, v)
        trigger.custom_type = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        WeakAuras.ClearAndUpdateOptions(data.id);
      end
    },
    check = {
      type = "select",
      name = L["Check On..."],
      width = WeakAuras.doubleWidth,
      order = 8,
      values = OptionsPrivate.Private.check_types,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate")
        and trigger.check ~= "update")
      end,
      get = function() return trigger.check end,
      set = function(info, v)
        trigger.check = v;
        WeakAuras.Add(data);
      end
    },
    check2 = {
      type = "select",
      name = L["Check On..."],
      order = 9,
      width = WeakAuras.doubleWidth,
      values = OptionsPrivate.Private.check_types,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate")
        and trigger.check == "update")
      end,
      get = function() return trigger.check end,
      set = function(info, v)
        trigger.check = v;
        WeakAuras.Add(data);
      end
    },
    onUpdateThrottle = {
      type = "range",
      control = "WeakAurasSpinBox",
      softMin = 0,
      softMax = 5,
      bigStep = 0.1,
      min = 0,
      width = WeakAuras.doubleWidth,
      name = L["Custom trigger Update Throttle"],
      order = 9.01,
      get = function() return trigger.onUpdateThrottle or 0 end,
      set = function(info, v)
        v = tonumber(v) or 0
        if v < 0 then
          v = 0
        end
        trigger.onUpdateThrottle = v
        WeakAuras.Add(data)
      end,
      hidden = function() return not (
        trigger.type == "custom"
        and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate")
        and (
          (trigger.check == "update")
          or (trigger.check == "event" and type(trigger.events) == "string" and trigger.events:find("FRAME_UPDATE", 1, true))
        )
      )
      end,
    },
    events = {
      type = "input",
      multiline = true,
      control = "WeakAuras-MultiLineEditBoxWithEnter",
      LAAC = { disableFunctions = true, disableSystems = true },
      width = WeakAuras.doubleWidth,
      name = L["Event(s)"],
      desc = L["Custom trigger status tooltip"],
      order = 8.1,
      hidden = function() return not (trigger.type == "custom"
        and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate")
        and trigger.check ~= "update") end,
      get = function() return trigger.events end,
      set = function(info, v)
        trigger.events = v;
        WeakAuras.Add(data);
      end
    },
    events2 = {
      type = "input",
      multiline = true,
      control = "WeakAuras-MultiLineEditBoxWithEnter",
      LAAC = { disableFunctions = true, disableSystems = true },
      name = L["Event(s)"],
      desc = L["Custom trigger event tooltip"],
      width = WeakAuras.doubleWidth,
      order = 9.1,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event") end,
      get = function() return trigger.events end,
      set = function(info, v)
        trigger.events = v;
        WeakAuras.Add(data);
      end
    },
    event_customError = {
      type = "description",
      name = function()
        local events = trigger.custom_type == "event" and trigger.events2 or trigger.events
        -- Check for errors
        for _, event in pairs(WeakAuras.split(events)) do
          local trueEvent
          for i in event:gmatch("[^:]+") do
            if not trueEvent then
              trueEvent = string.upper(i)
            elseif trueEvent == "CLEU" or trueEvent == "COMBAT_LOG_EVENT_UNFILTERED" then
              local subevent = string.upper(i)
              if not OptionsPrivate.Private.IsCLEUSubevent(subevent) then
                return "|cFFFF0000"..L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"]:format(subevent)
              end
            elseif trueEvent:match("^UNIT_") then
              local unit = string.lower(i)
              if not OptionsPrivate.Private.baseUnitId[unit] and not OptionsPrivate.Private.multiUnitId[unit] then
                return "|cFFFF0000"..L["Unit %s is not a valid unit for RegisterUnitEvent"]:format(unit)
              end
            elseif trueEvent == "TRIGGER" then
              local requestedTriggernum = tonumber(i)
              if requestedTriggernum then
                if OptionsPrivate.Private.watched_trigger_events[data.id]
                and OptionsPrivate.Private.watched_trigger_events[data.id][triggernum]
                and OptionsPrivate.Private.watched_trigger_events[data.id][triggernum][requestedTriggernum] then
                  return "|cFFFF0000"..L["Reciprocal TRIGGER:# requests will be ignored!"]
                end
              end
            end
          end
        end

        -- Check for warnings
        for _, event in pairs(WeakAuras.split(events)) do
          if event == "CLEU" or event == "COMBAT_LOG_EVENT_UNFILTERED" then
            return "|cFFFF0000"..L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."]
          end
        end
        return ""
      end,
      width = WeakAuras.doubleWidth,
      order = 9.201,
      hidden = function()
        if not (
          trigger.type == "custom"
          and (trigger.custom_type == "status" or trigger.custom_type == "stateupdate" or trigger.custom_type == "event")
          and trigger.check ~= "update"
        )
        then
          return true
        end
        local events = trigger.custom_type == "event" and trigger.events2 or trigger.events
        -- Check for errors
        for _, event in pairs(WeakAuras.split(events)) do
          local trueEvent
          for i in event:gmatch("[^:]+") do
            if not trueEvent then
              trueEvent = string.upper(i)
            elseif trueEvent == "CLEU" or trueEvent == "COMBAT_LOG_EVENT_UNFILTERED" then
              if not OptionsPrivate.Private.IsCLEUSubevent(string.upper(i)) then
                return false
              end
            elseif trueEvent:match("^UNIT_") then
              local unit = string.lower(i)
              if not OptionsPrivate.Private.baseUnitId[unit] then
                return false
              end
            elseif trueEvent == "TRIGGER" then
              local requestedTriggernum = tonumber(i)
              if requestedTriggernum then
                if OptionsPrivate.Private.watched_trigger_events[data.id]
                and OptionsPrivate.Private.watched_trigger_events[data.id][triggernum]
                and OptionsPrivate.Private.watched_trigger_events[data.id][triggernum][requestedTriggernum] then
                  return false
                end
              end
            end
          end
        end
        -- Check for warnings
        for _, event in pairs(WeakAuras.split(events)) do
          if event == "CLEU" or event == "COMBAT_LOG_EVENT_UNFILTERED" then
            return false
          end
        end
        return true
      end
    },
    -- texteditor below
    custom_hide = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Hide"],
      order = 12,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.custom_hide ~= "custom") end,
      values = OptionsPrivate.Private.eventend_types,
      get = function() trigger.custom_hide = trigger.custom_hide or "timed"; return trigger.custom_hide end,
      set = function(info, v)
        trigger.custom_hide = v;
        WeakAuras.Add(data);
      end
    },
    custom_hide2 = {
      type = "select",
      name = L["Hide"],
      order = 12,
      width = WeakAuras.doubleWidth,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.custom_hide == "custom") end,
      values = OptionsPrivate.Private.eventend_types,
      get = function() return trigger.custom_hide end,
      set = function(info, v)
        trigger.custom_hide = v;
        WeakAuras.Add(data);
      end
    },
    dynamicDuration = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Dynamic Duration"],
      order = 12.5,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.custom_hide ~= "custom") end,
      get = function()
        return trigger.dynamicDuration
      end,
      set = function(info, v)
        trigger.dynamicDuration = v;
        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id);
      end
    },
    duration = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["Duration (s)"],
      order = 13,
      hidden = function() return not (trigger.type == "custom" and trigger.custom_type == "event" and trigger.custom_hide ~= "custom" and not trigger.dynamicDuration) end,
      get = function()
        return trigger.duration
      end,
      set = function(info, v)
        trigger.duration = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    },
    addOverlayFunction = {
      type = "execute",
      name = L["Add Overlay"],
      order = 17.9,
      width = WeakAuras.doubleWidth,
      hidden = function()
        if (trigger.type ~= "custom") then
          return true;
        end
        if (trigger.custom_type == "stateupdate") then
          return true;
        end

        for i = 1, 7 do
          if (trigger["customOverlay" .. i] == nil) then
            return false;
          end
        end
        return true;
      end,
      func = function()
        for i = 1, 7 do
          if (trigger["customOverlay" .. i] == nil) then
            trigger["customOverlay" .. i] = "";
            break;
          end
        end
        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    }
  };

  local function extraSetFunction()
    WeakAuras.UpdateThumbnail(data);
  end

  local function extraSetFunctionReload()
    extraSetFunction();
    WeakAuras.ClearAndUpdateOptions(data.id);
  end

  local function hideCustomTrigger()
    return not (trigger.type == "custom")
  end
  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Custom Trigger"], "custom_trigger", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-trigger",
                          10, hideCustomTrigger, appendToTriggerPath("custom"), false, {multipath = false, extraSetFunction = extraSetFunction, reloadOptions = true});

  local function hideCustomVariables()
    return not (trigger.type == "custom" and trigger.custom_type == "stateupdate");
  end

  local validTypes = {
    bool = true,
    number = true,
    timer = true,
    elapsedTimer = true,
    select = true,
    string = true,
  }

  local validProperties = {
    display = "string",
    type = "string",
    test = "function",
    events = "table",
    values = "table",
    total = "string",
    inverse = "string",
    paused = "string",
    remaining = "string",
    modRate = "string",
    useModRate = "boolean",
    formatter = "string"
  }

  local function validateCustomVariables(variables)
    if (type(variables) ~= "table") then
      return L["Not a table"]
    end

    OptionsPrivate.Private.ExpandCustomVariables(variables)

    for k, v in pairs(variables) do
      if k == "additionalProgress" then
        -- Skip over additionalProgress
      elseif type(v) ~= "table" then
        return string.format(L["Could not parse '%s'. Expected a table."], k)
      elseif not validTypes[v.type] then
        return string.format(L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."], k)
      elseif v.type == "select" and not v.values then
        return string.format(L["Type 'select' for '%s' requires a values member'"], k)
      else
        for property, propertyValue in pairs(v) do
          if not validProperties[property] then
            return string.format(L["Unknown property '%s' found in '%s'"], property, k)
          end
          if type(propertyValue) ~= validProperties[property] then
            return string.format(L["Invalid type for property '%s' in '%s'. Expected '%s'"], property, k, validProperties[property])
          end
        end
      end
    end
  end

  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Custom Variables"], "custom_variables", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-variables",
                          11, hideCustomVariables, appendToTriggerPath("customVariables"), false,
                          {multipath = false, extraSetFunction = extraSetFunctionReload, reloadOptions = true, validator = validateCustomVariables });

  local function hideCustomUntrigger()
    return not (trigger.type == "custom"
      and (trigger.custom_type == "status" or (trigger.custom_type == "event" and trigger.custom_hide == "custom")))
  end
  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Custom Untrigger"], "custom_untrigger", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-untrigger",
                          14, hideCustomUntrigger, appendToUntriggerPath("custom"), false, {multipath = false, extraSetFunction = extraSetFunction});

  local function hideCustomDuration()
    return not (trigger.type == "custom"
      and (trigger.custom_type == "status"
           or (trigger.custom_type == "event" and (trigger.custom_hide ~= "timed" or trigger.dynamicDuration))))
  end
  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Duration Info"], "custom_duration", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#duration-info",
                          16, hideCustomDuration, appendToTriggerPath("customDuration"), false, { multipath = false, extraSetFunction = extraSetFunctionReload });

  local function hideIfTriggerStateUpdate()
    return not (trigger.type == "custom" and trigger.custom_type ~= "stateupdate")
  end

  for i = 1, 7 do
    local function hideOverlay()
      if (trigger["customOverlay" .. i] == nil) then
        return true;
      end
      return hideIfTriggerStateUpdate();
    end

    local function removeOverlay()
      for j = i, 7 do
        trigger["customOverlay" .. j] = trigger["customOverlay" .. (j +1)];
      end
      WeakAuras.Add(data);
      WeakAuras.ClearAndUpdateOptions(data.id)
      WeakAuras.FillOptions()
    end

    local extraFunctions = {
      {
        buttonLabel = L["Remove"],
        func = removeOverlay
      }
    }

    OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, string.format(L["Overlay %s Info"], i), "custom_overlay" .. i, "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#overlay-info",
                            17 + i / 10, hideOverlay, appendToTriggerPath("customOverlay" .. i), false, { multipath = false, extraSetFunction = extraSetFunctionReload, extraFunctions = extraFunctions});
  end

  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Name Info"], "custom_name",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#name-info",
                          18, hideIfTriggerStateUpdate, appendToTriggerPath("customName"), false,
                          { multipath = false, extraSetFunction = extraSetFunctionReload});
  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Icon Info"], "custom_icon",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#icon-info",
                          20, hideIfTriggerStateUpdate, appendToTriggerPath("customIcon"), false,
                          { multipath = false, extraSetFunction = extraSetFunction});
  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Texture Info"], "custom_texture",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#texture-info",
                          22, hideIfTriggerStateUpdate, appendToTriggerPath("customTexture"), false,
                          { multipath = false, extraSetFunction = extraSetFunction});
  OptionsPrivate.commonOptions.AddCodeOption(customOptions, data, L["Stack Info"], "custom_stacks",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#stack-info",
                          23, hideIfTriggerStateUpdate, appendToTriggerPath("customStacks"), false,
                          { multipath = false, extraSetFunction = extraSetFunctionReload});

  return customOptions;
end

local function GetGenericTriggerOptions(data, triggernum)
  local id = data.id;

  local trigger = data.triggers[triggernum].trigger;
  local triggerType = trigger.type;

  local subtypes = OptionsPrivate.Private.category_event_prototype[trigger.type]

  local needsTypeSelection = subtypes and next(subtypes, next(subtypes))

  local options = {}

  if needsTypeSelection then
    options.event = {
      type = "select",
      name = "",
      order = 7.1,
      width = WeakAuras.normalWidth,
      values = subtypes,
      sorting = OptionsPrivate.Private.SortOrderForValues(subtypes),
      get = function(info)
        return trigger.event
      end,
      set = function(info, v)
        trigger.event = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end,
    }
  end

  OptionsPrivate.commonOptions.AddCommonTriggerOptions(options, data, triggernum, not needsTypeSelection)
  OptionsPrivate.AddTriggerMetaFunctions(options, data, triggernum)

  local combatLogCategory = WeakAuras.GetTriggerCategoryFor("Combat Log")
  local combatLogOptions =
  {
    subeventPrefix = {
      type = "select",
      name = L["Subevent"],
      width = WeakAuras.normalWidth,
      order = 8,
      values = OptionsPrivate.Private.subevent_prefix_types,
      sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.subevent_prefix_types),
      hidden = function() return not (trigger.type == combatLogCategory and trigger.event == "Combat Log"); end,
      get = function(info)
        return trigger.subeventPrefix
      end,
      set = function(info, v)
        trigger.subeventPrefix = v
        WeakAuras.Add(data)
      end
    },
    subeventSuffix = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Subevent Suffix"],
      order = 9,
      values = OptionsPrivate.Private.subevent_suffix_types,
      sorting = OptionsPrivate.Private.SortOrderForValues(OptionsPrivate.Private.subevent_suffix_types),
      hidden = function() return not (trigger.type == combatLogCategory and trigger.event == "Combat Log" and OptionsPrivate.Private.subevent_actual_prefix_types[trigger.subeventPrefix]); end,
      get = function(info)
        return trigger.subeventSuffix
      end,
      set = function(info, v)
        trigger.subeventSuffix = v
        WeakAuras.Add(data)
      end
    },
    spacer_suffix = {
      type = "description",
      name = "",
      order = 9.1,
      hidden = function() return not (trigger.type == combatLogCategory and trigger.event == "Combat Log"); end
    },
  }

  if (triggerType == "custom") then
    Mixin(options, GetCustomTriggerOptions(data, triggernum));
  elseif (OptionsPrivate.Private.category_event_prototype[triggerType]) then
    local prototypeOptions;
    local trigger = data.triggers[triggernum].trigger
    if(OptionsPrivate.Private.event_prototypes[trigger.event]) then
      prototypeOptions = OptionsPrivate.ConstructOptions(OptionsPrivate.Private.event_prototypes[trigger.event], data, 10, triggernum);
      if (trigger.event == "Combat Log") then
        Mixin(prototypeOptions, combatLogOptions);
      end
    else
      print("|cFF8800FFWeakAuras|r: No prototype for", trigger.event);
    end
    if (prototypeOptions) then
      Mixin(options, prototypeOptions);
    end
  end


  return {
    ["trigger." .. triggernum .. "." .. (trigger.event or "unknown")] = options
  }
end

WeakAuras.RegisterTriggerSystemOptions(WeakAuras.genericTriggerTypes, GetGenericTriggerOptions);

=== END OF FILE: WeakAurasOptions/GenericTrigger.lua ===


=== FILE: WeakAurasOptions/GroupOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L
local parsePrefix = OptionsPrivate.commonOptions.parsePrefix
local flattenRegionOptions = OptionsPrivate.commonOptions.flattenRegionOptions

function OptionsPrivate.GetGroupOptions(data)
  local regionOption;
  local id = data.id
  if (OptionsPrivate.Private.regionOptions[data.regionType]) then
    regionOption = OptionsPrivate.Private.regionOptions[data.regionType].create(id, data);
  else
    regionOption = {
      [data.regionType] = {
        __title = "|cFFFFFF00" .. data.regionType,
        __order = 1,
        unsupported = {
          type = "description",
          name = L["This region of type \"%s\" is not supported."]:format(data.regionType)
        }
      };
    };
  end

  local  groupOptions = {
    type = "group",
    name = L["Group Options"],
    order = 0,
    get = function(info)
      local base, property = parsePrefix(info[#info], data);
      if not base then
        return nil
      end
      if(info.type == "color") then
        base[property] = base[property] or {};
        local c = base[property];
        return c[1], c[2], c[3], c[4];
      else
        return base[property];
      end
    end,
    set = function(info, v, g, b, a)
      local base, property = parsePrefix(info[#info], data, true);
      if(info.type == "color") then
        base[property] = base[property] or {};
        local c = base[property];
        c[1], c[2], c[3], c[4] = v, g, b, a;
      elseif(info.type == "toggle") then
        base[property] = v;
      else
        base[property] = (v ~= "" and v) or nil;
      end
      WeakAuras.Add(data);
      WeakAuras.UpdateThumbnail(data);
      OptionsPrivate.ResetMoverSizer();
    end,
    hidden = function() return false end,
    disabled = function() return false end,
    args = flattenRegionOptions(regionOption, true);
  }

  return groupOptions
end

=== END OF FILE: WeakAurasOptions/GroupOptions.lua ===


=== FILE: WeakAurasOptions/InformationOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

--- Creates the options for one aura
---@param data auraData
---@return table
function OptionsPrivate.GetInformationOptions(data)
  --- @type boolean
  local isGroup = data.controlledChildren and true or false
  --- @type boolean
  local isTmpGroup = type(data.id) == "table"

  local options = {
    type = "group",
    name = L["Information"],
    order = 1,
    args = {

    }
  }

  --- @type number
  local order = 1
  local args = options.args

  -- NAME
  -- One Aura or Group: Allows editing of aura/group name
  -- Multi-selection: Don't allow any editing
  if not isTmpGroup then
    args.name = {
      type = "input",
      name = L["Name:"],
      width = WeakAuras.doubleWidth,
      order = order,
      get = function()
        return data.id
      end,
      set = function(info, newid)
        if data.id ~= newid and not WeakAuras.GetData(newid) then
          local oldid = data.id
          WeakAuras.Rename(data, newid);
        end
      end
    }
    order = order + 1
  end

  -- URL
  -- One Aura: Edit URL of the aura
  -- Group/Multi-selection: Edit URLs of both parent and children
  --- @type boolean
  local sameURL = true
  --- @type string|nil
  local commonURL
  --- @type string
  local desc = ""

  local traverseForUrl = isTmpGroup and OptionsPrivate.Private.TraverseAllChildren or OptionsPrivate.Private.TraverseAll
  for child in traverseForUrl(data) do
    if child.url then
      desc = desc .. "|cFFE0E000"..child.id..": |r"..child.url .. "\n"
    end
    if not commonURL then
      commonURL = child.url or ""
    elseif child.url ~= commonURL then
      sameURL = false
    end
  end

  args.url = {
    type = "input",
    name = sameURL and L["URL"] or "|cFF4080FF" .. L["URL"],
    width = WeakAuras.doubleWidth,
    get = function()
      return sameURL and commonURL or ""
    end,
    set = function(info, v)
      OptionsPrivate.Private.TimeMachine:StartTransaction()
      for child in traverseForUrl(data) do
        OptionsPrivate.Private.TimeMachine:Append({
          uid = child.uid,
          actionType = "set",
          path = {"url"},
          payload = v
        })
      end
      OptionsPrivate.Private.TimeMachine:Commit()
    end,
    desc = sameURL and "" or desc,
    order = order
  }
  order = order + 1

  if isGroup then
    args.url_note = {
      type = "description",
      name = isTmpGroup and L["|cFFE0E000Note:|r This sets the URL on all selected auras"]
                         or L["|cFFE0E000Note:|r This sets the URL on this group and all its members."],
      width = WeakAuras.doubleWidth,
      order = order
    }
    order = order + 1
  end
  if OptionsPrivate.HasWagoUrl(data.id) then
    args.ignoreWagoUpdate = {
      type = "toggle",
      name = L["Ignore Wago updates"],
      desc = OptionsPrivate.IsWagoUpdateIgnored(data.id) and L["Do you want to enable updates for this aura"] or L["Do you want to ignore updates for this aura"],
      width = WeakAuras.doubleWidth,
      get = function() return OptionsPrivate.IsWagoUpdateIgnored(data.id) end,
      set = function(info, v)
          local auraData = WeakAuras.GetData(data.id)
          if auraData then
            local ignoreUpdate
            if OptionsPrivate.IsWagoUpdateIgnored(data.id) then
              ignoreUpdate = nil
            else
              ignoreUpdate = true
            end
            for child in OptionsPrivate.Private.TraverseAll(auraData) do
              child.ignoreWagoUpdate = ignoreUpdate
              OptionsPrivate.ClearOptions(child.id)
            end
            WeakAuras.ClearAndUpdateOptions(data.id)
          end
          OptionsPrivate.SortDisplayButtons(nil, true)

      end,
      order = order
    }
    order = order + 1
  end


  -- Description
  -- One Aura/Group: Edit description of the aura or group
  -- Multi-selection: No editing
  if not isTmpGroup then
    args.description = {
      type = "input",
      name = isGroup and L["Group Description"] or L["Description"],
      width = WeakAuras.doubleWidth,
      multiline = true,
      order = order,
      get = function()
        return data.desc
      end,
      set = function(info, v)
        data.desc = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    }
    order = order + 1

    if isGroup then
      args.description_note = {
        type = "description",
        name = string.format(L["|cFFE0E000Note:|r This sets the description only on '%s'"], data.id),
        width = WeakAuras.doubleWidth,
        order = order,
      }
      order = order + 1
    end
  end

  -- Show warnings only for single selection for now
  if not isGroup then
    local _, title, message = OptionsPrivate.Private.AuraWarnings.FormatWarnings(data.uid)
    if title and message then
      args.warningTitle = {
        type = "header",
        name = title,
        width = WeakAuras.doubleWidth,
        order = order,
      }
      order = order + 1

      args.warnings = {
        type = "description",
        name = message,
        width = WeakAuras.doubleWidth,
        order = order,
        fontSize = "medium"
      }
      order = order + 1
    end
  end

    -- compatibility Options
  args.compabilityTitle = {
    type = "header",
    name = L["Compatibility Options"],
    width = WeakAuras.doubleWidth,
    order = order,
  }
  order = order + 1

  local properties = {
    ignoreOptionsEventErrors = {
      name = L["Custom Trigger: Ignore Lua Errors on OPTIONS event"],
    },
    forceEvents = {
      name = L["Custom Trigger: Send fake events instead of STATUS event"]
    },
    groupOffset = {
      name = L["Offset by 1px"],
      onParent = true,
      regionType = "group"
    }
  }

  --- @type table<string, boolean>
  local same = {
    ignoreOptionsEventErrors = true,
    forceEvents = true,
    groupOffset = true
  }

  --- @type table<string, boolean>
  local common = {

  }

  --- @type table<string, string>
  local mergedDesc = {

  }

  for property, propertyData in pairs(properties) do
    if propertyData.onParent then
      if not isTmpGroup and (not propertyData.regionType or propertyData.regionType == data.regionType) then
        if data.information[property] ~= nil then
          common[property] = data.information[property]
        else
          common[property] = false
        end
      end
    else
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
        if not propertyData.regionType or propertyData.regionType == child.regionType then
          local effectiveProperty = child.information[property]
          if effectiveProperty == nil then
            effectiveProperty = false
          end

          mergedDesc[property] = (mergedDesc[property] or "") .. "|cFFE0E000" .. child.id .. ": |r"
          .. (effectiveProperty and "true" or "false") .. "\n"

          if common[property] == nil then
            common[property] = effectiveProperty
          elseif effectiveProperty ~= common[property] then
            same[property] = false
          end
        end
      end
    end

    if common[property] ~= nil then
      args["compatibility_" .. property] = {
        type = "toggle",
        name = same[property] and propertyData.name or "|cFF4080FF" .. propertyData.name,
        width = WeakAuras.doubleWidth,
        get = function()
          if propertyData.onParent then
            return data.information[property]
          else
            return same[property] and common[property] or false
          end
        end,
        set = function(info, v)
          if propertyData.onParent then
            data.information[property] = v
            WeakAuras.Add(data)
            OptionsPrivate.ClearOptions(data.id)
          else
            for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
              if not propertyData.regionType or propertyData.regionType == child.regionType then
                child.information[property] = v
                WeakAuras.Add(child)
                OptionsPrivate.ClearOptions(child.id)
              end
            end
          end
          WeakAuras.ClearAndUpdateOptions(data.id)
        end,
        desc = same[property] and "" or mergedDesc[property],
        order = order
      }
      order = order + 1
    end
  end

  -- Saved Data
  --- @type number
  local savedDataCount = 0
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
    OptionsPrivate.Private.SaveAuraEnvironment(data.id)
    if child.information.saved then
      savedDataCount = savedDataCount + 1
    end
  end
  if savedDataCount > 0 then
    args.savedDataTitle = {
      type = "header",
      name = L["Saved Data"],
      width = WeakAuras.doubleWidth,
      order = order,
    }
    order = order + 1

    for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
      if child.information.saved then
        args["savedData." .. child.uid] = {
          type = "description",
          name = L["%s stores around %s KB of data"]:format(child.id, ceil((#child.information.saved) / 1024)),
          width = savedDataCount > 1 and WeakAuras.doubleWidth or WeakAuras.normalWidth,
          order = order,
        }
        order = order + 1
      end
    end

    args.savedDataClear = {
      type = "execute",
      name = L["Clear Saved Data"],
      width = savedDataCount > 1 and WeakAuras.doubleWidth or WeakAuras.normalWidth,
      order = order,
      func = function()
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          OptionsPrivate.Private.ClearAuraEnvironmentSavedData(child.id)
          WeakAuras.Add(child)
          OptionsPrivate.ClearOptions(child.id)
        end
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    }
    order = order + 1
  end

  -- Debug Log
  args.debugLogTitle = {
    type = "header",
    name = L["Enable Debug Log"],
    width = WeakAuras.doubleWidth,
    order = order,
  }
  order = order + 1

  args.debugLogDesc = {
    type = "description",
    name = L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."],
    width = WeakAuras.doubleWidth,
    order = order,
  }
  order = order + 1

  --- @type boolean
  local sameDebugLog = true
  --- @type boolean|nil
  local commonDebugLog
  --- @type string
  local debugLogDesc = ""

  if isGroup and not isTmpGroup then
    sameDebugLog = true
    commonDebugLog = data.information.debugLog and true or false
  else
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
      --- @type boolean
      local effectiveDebugLog = child.information.debugLog and true or false
      debugLogDesc = debugLogDesc .. "|cFFE0E000"..child.id..": |r".. (effectiveDebugLog and "true" or "false") .. "\n"
      if commonDebugLog == nil then
        commonDebugLog = effectiveDebugLog
      elseif effectiveDebugLog ~= commonDebugLog then
        sameDebugLog = false
      end
    end
  end

  args.debugLogToggle = {
    type = "toggle",
    name = sameDebugLog and L["Enable Debug Logging"] or "|cFF4080FF" .. L["Enable Debug Logging"],
    desc = not sameDebugLog and debugLogDesc or nil,
    width = WeakAuras.doubleWidth,
    order = order,
    get = function()
      return sameDebugLog and commonDebugLog
    end,
    set = function(info, v)
      if isGroup and not isTmpGroup then
        data.information.debugLog = v
        WeakAuras.Add(data)
      else
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          child.information.debugLog = v
          WeakAuras.Add(child)
          OptionsPrivate.ClearOptions(child.id)
        end
      end

      WeakAuras.ClearAndUpdateOptions(data.id)
    end
  }
  order = order + 1

  if not sameDebugLog or commonDebugLog then
    args.debugLogShow = {
      type = "execute",
      name = L["Show Debug Logs"],
      width = WeakAuras.normalWidth,
      order = order,
      func = function()
        --- @type string
        local fullMessage = L["WeakAuras %s on WoW %s"]:format(WeakAuras.versionString, WeakAuras.BuildInfo) .. "\n\n"
        --- @type boolean
        local haveLogs = false
        if isGroup and not isTmpGroup then
          local auraLog = OptionsPrivate.Private.DebugLog.GetLogs(data.uid)
          if auraLog then
            haveLogs = true
            fullMessage = fullMessage .. L["Aura: '%s'"]:format(data.id)
            --- @type string|nil
            local version = data.semver or data.version
            if (version) then
              fullMessage = fullMessage .. "\n" .. L["Version: %s"]:format(version)
            end
            fullMessage = fullMessage .. "\n" .. L["Debug Log:"] .. "\n" .. auraLog .. "\n\n"
          end
        else
          for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
            --- @type string
            local auraLog = OptionsPrivate.Private.DebugLog.GetLogs(child.uid)
            if auraLog then
              haveLogs = true
              fullMessage = fullMessage .. L["Aura: '%s'"]:format(child.id)
              --- @type string|nil
              local version = child.semver or child.version
              if (version) then
                fullMessage = fullMessage .. "\n" .. L["Version: %s"]:format(version)
              end
              fullMessage = fullMessage .. "\n" .. L["Debug Log:"] .. "\n" .. auraLog .. "\n\n"
            end
          end
        end

        if haveLogs then
          OptionsPrivate.OpenDebugLog(fullMessage)
        else
          OptionsPrivate.OpenDebugLog(L["No Logs saved."])
        end
      end
    }
    order = order + 1

    args.debugLogClear = {
      type = "execute",
      name = L["Clear Debug Logs"],
      width = WeakAuras.normalWidth,
      order = order,
      func = function()
        if isGroup and not isTmpGroup then
          OptionsPrivate.Private.DebugLog.Clear(data.uid)
        else
          for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
            OptionsPrivate.Private.DebugLog.Clear(child.uid)
          end
        end
      end
    }
    order = order + 1
  end

  return options
end

=== END OF FILE: WeakAurasOptions/InformationOptions.lua ===


=== FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfig-3.0.lua ===
--- AceConfig-3.0 wrapper library.
-- Provides an API to register an options table with the config registry,
-- as well as associate it with a slash command.
-- @class file
-- @name AceConfig-3.0
-- @release $Id: AceConfig-3.0.lua 1335 2024-05-05 19:35:16Z nevcairiel $

--[[
AceConfig-3.0

Very light wrapper library that combines all the AceConfig subcomponents into one more easily used whole.

]]

local cfgreg = LibStub("AceConfigRegistry-3.0")
local cfgcmd = LibStub("AceConfigCmd-3.0")

local MAJOR, MINOR = "AceConfig-3.0", 3
local AceConfig = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfig then return end

--TODO: local cfgdlg = LibStub("AceConfigDialog-3.0", true)
--TODO: local cfgdrp = LibStub("AceConfigDropdown-3.0", true)

-- Lua APIs
local pcall, error, type, pairs = pcall, error, type, pairs

-- -------------------------------------------------------------------
-- :RegisterOptionsTable(appName, options, slashcmd)
--
-- - appName - (string) application name
-- - options - table or function ref, see AceConfigRegistry
-- - slashcmd - slash command (string) or table with commands, or nil to NOT create a slash command

--- Register a option table with the AceConfig registry.
-- You can supply a slash command (or a table of slash commands) to register with AceConfigCmd directly.
-- @paramsig appName, options [, slashcmd]
-- @param appName The application name for the config table.
-- @param options The option table (or a function to generate one on demand).  http://www.wowace.com/addons/ace3/pages/ace-config-3-0-options-tables/
-- @param slashcmd A slash command to register for the option table, or a table of slash commands.
-- @usage
-- local AceConfig = LibStub("AceConfig-3.0")
-- AceConfig:RegisterOptionsTable("MyAddon", myOptions, {"/myslash", "/my"})
function AceConfig:RegisterOptionsTable(appName, options, slashcmd)
	local ok,msg = pcall(cfgreg.RegisterOptionsTable, self, appName, options)
	if not ok then error(msg, 2) end

	if slashcmd then
		if type(slashcmd) == "table" then
			for _,cmd in pairs(slashcmd) do
				cfgcmd:CreateChatCommand(cmd, appName)
			end
		else
			cfgcmd:CreateChatCommand(slashcmd, appName)
		end
	end
end

=== END OF FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfig-3.0.lua ===


=== FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua ===
--- AceConfigCmd-3.0 handles access to an options table through the "command line" interface via the ChatFrames.
-- @class file
-- @name AceConfigCmd-3.0
-- @release $Id: AceConfigCmd-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $

--[[
AceConfigCmd-3.0

Handles commandline optionstable access

REQUIRES: AceConsole-3.0 for command registration (loaded on demand)

]]

-- TODO: plugin args

local cfgreg = LibStub("AceConfigRegistry-3.0")

local MAJOR, MINOR = "AceConfigCmd-3.0", 14
local AceConfigCmd = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfigCmd then return end

AceConfigCmd.commands = AceConfigCmd.commands or {}
local commands = AceConfigCmd.commands

local AceConsole -- LoD
local AceConsoleName = "AceConsole-3.0"

-- Lua APIs
local strsub, strsplit, strlower, strmatch, strtrim = string.sub, string.split, string.lower, string.match, string.trim
local format, tonumber, tostring = string.format, tonumber, tostring
local tsort, tinsert = table.sort, table.insert
local select, pairs, next, type = select, pairs, next, type
local error, assert = error, assert

-- WoW APIs
local _G = _G

local L = setmetatable({}, {	-- TODO: replace with proper locale
	__index = function(self,k) return k end
})

local function print(msg)
	(SELECTED_CHAT_FRAME or DEFAULT_CHAT_FRAME):AddMessage(msg)
end

-- constants used by getparam() calls below

local handlertypes = {["table"]=true}
local handlermsg = "expected a table"

local functypes = {["function"]=true, ["string"]=true}
local funcmsg = "expected function or member name"


-- pickfirstset() - picks the first non-nil value and returns it

local function pickfirstset(...)
	for i=1,select("#",...) do
		if select(i,...)~=nil then
			return select(i,...)
		end
	end
end


-- err() - produce real error() regarding malformed options tables etc

local function err(info,inputpos,msg )
	local cmdstr=" "..strsub(info.input, 1, inputpos-1)
	error(MAJOR..": /" ..info[0] ..cmdstr ..": "..(msg or "malformed options table"), 2)
end


-- usererr() - produce chatframe message regarding bad slash syntax etc

local function usererr(info,inputpos,msg )
	local cmdstr=strsub(info.input, 1, inputpos-1);
	print("/" ..info[0] .. " "..cmdstr ..": "..(msg or "malformed options table"))
end


-- callmethod() - call a given named method (e.g. "get", "set") with given arguments

local function callmethod(info, inputpos, tab, methodtype, ...)
	local method = info[methodtype]
	if not method then
		err(info, inputpos, "'"..methodtype.."': not set")
	end

	info.arg = tab.arg
	info.option = tab
	info.type = tab.type

	if type(method)=="function" then
		return method(info, ...)
	elseif type(method)=="string" then
		if type(info.handler[method])~="function" then
			err(info, inputpos, "'"..methodtype.."': '"..method.."' is not a member function of "..tostring(info.handler))
		end
		return info.handler[method](info.handler, info, ...)
	else
		assert(false)	-- type should have already been checked on read
	end
end

-- callfunction() - call a given named function (e.g. "name", "desc") with given arguments

local function callfunction(info, tab, methodtype, ...)
	local method = tab[methodtype]

	info.arg = tab.arg
	info.option = tab
	info.type = tab.type

	if type(method)=="function" then
		return method(info, ...)
	else
		assert(false) -- type should have already been checked on read
	end
end

-- do_final() - do the final step (set/execute) along with validation and confirmation

local function do_final(info, inputpos, tab, methodtype, ...)
	if info.validate then
		local res = callmethod(info,inputpos,tab,"validate",...)
		if type(res)=="string" then
			usererr(info, inputpos, "'"..strsub(info.input, inputpos).."' - "..res)
			return
		end
	end
	-- console ignores .confirm

	callmethod(info,inputpos,tab,methodtype, ...)
end


-- getparam() - used by handle() to retreive and store "handler", "get", "set", etc

local function getparam(info, inputpos, tab, depth, paramname, types, errormsg)
	local old,oldat = info[paramname], info[paramname.."_at"]
	local val=tab[paramname]
	if val~=nil then
		if val==false then
			val=nil
		elseif not types[type(val)] then
			err(info, inputpos, "'" .. paramname.. "' - "..errormsg)
		end
		info[paramname] = val
		info[paramname.."_at"] = depth
	end
	return old,oldat
end


-- iterateargs(tab) - custom iterator that iterates both t.args and t.plugins.*
local dummytable={}

local function iterateargs(tab)
	if not tab.plugins then
		return pairs(tab.args)
	end

	local argtabkey,argtab=next(tab.plugins)
	local v

	return function(_, k)
		while argtab do
			k,v = next(argtab, k)
			if k then return k,v end
			if argtab==tab.args then
				argtab=nil
			else
				argtabkey,argtab = next(tab.plugins, argtabkey)
				if not argtabkey then
					argtab=tab.args
				end
			end
		end
	end
end

local function checkhidden(info, inputpos, tab)
	if tab.cmdHidden~=nil then
		return tab.cmdHidden
	end
	local hidden = tab.hidden
	if type(hidden) == "function" or type(hidden) == "string" then
		info.hidden = hidden
		hidden = callmethod(info, inputpos, tab, 'hidden')
		info.hidden = nil
	end
	return hidden
end

local function showhelp(info, inputpos, tab, depth, noHead)
	if not noHead then
		print("|cff33ff99"..info.appName.."|r: Arguments to |cffffff78/"..info[0].."|r "..strsub(info.input,1,inputpos-1)..":")
	end

	local sortTbl = {}	-- [1..n]=name
	local refTbl = {}   -- [name]=tableref

	for k,v in iterateargs(tab) do
		if not refTbl[k] then	-- a plugin overriding something in .args
			tinsert(sortTbl, k)
			refTbl[k] = v
		end
	end

	tsort(sortTbl, function(one, two)
		local o1 = refTbl[one].order or 100
		local o2 = refTbl[two].order or 100
		if type(o1) == "function" or type(o1) == "string" then
			info.order = o1
			info[#info+1] = one
			o1 = callmethod(info, inputpos, refTbl[one], "order")
			info[#info] = nil
			info.order = nil
		end
		if type(o2) == "function" or type(o1) == "string" then
			info.order = o2
			info[#info+1] = two
			o2 = callmethod(info, inputpos, refTbl[two], "order")
			info[#info] = nil
			info.order = nil
		end
		if o1<0 and o2<0 then return o1<o2 end
		if o2<0 then return true end
		if o1<0 then return false end
		if o1==o2 then return tostring(one)<tostring(two) end   -- compare names
		return o1<o2
	end)

	for i = 1, #sortTbl do
		local k = sortTbl[i]
		local v = refTbl[k]
		if not checkhidden(info, inputpos, v) then
			if v.type ~= "description" and v.type ~= "header" then
				-- recursively show all inline groups
				local name, desc = v.name, v.desc
				if type(name) == "function" then
					name = callfunction(info, v, 'name')
				end
				if type(desc) == "function" then
					desc = callfunction(info, v, 'desc')
				end
				if v.type == "group" and pickfirstset(v.cmdInline, v.inline, false) then
					print("  "..(desc or name)..":")
					local oldhandler,oldhandler_at = getparam(info, inputpos, v, depth, "handler", handlertypes, handlermsg)
					showhelp(info, inputpos, v, depth, true)
					info.handler,info.handler_at = oldhandler,oldhandler_at
				else
					local key = k:gsub(" ", "_")
					print("  |cffffff78"..key.."|r - "..(desc or name or ""))
				end
			end
		end
	end
end


local function keybindingValidateFunc(text)
	if text == nil or text == "NONE" then
		return nil
	end
	text = text:upper()
	local shift, ctrl, alt
	local modifier
	while true do
		if text == "-" then
			break
		end
		modifier, text = strsplit('-', text, 2)
		if text then
			if modifier ~= "SHIFT" and modifier ~= "CTRL" and modifier ~= "ALT" then
				return false
			end
			if modifier == "SHIFT" then
				if shift then
					return false
				end
				shift = true
			end
			if modifier == "CTRL" then
				if ctrl then
					return false
				end
				ctrl = true
			end
			if modifier == "ALT" then
				if alt then
					return false
				end
				alt = true
			end
		else
			text = modifier
			break
		end
	end
	if text == "" then
		return false
	end
	if not text:find("^F%d+$") and text ~= "CAPSLOCK" and text:len() ~= 1 and (text:byte() < 128 or text:len() > 4) and not _G["KEY_" .. text] then
		return false
	end
	local s = text
	if shift then
		s = "SHIFT-" .. s
	end
	if ctrl then
		s = "CTRL-" .. s
	end
	if alt then
		s = "ALT-" .. s
	end
	return s
end

-- handle() - selfrecursing function that processes input->optiontable
-- - depth - starts at 0
-- - retfalse - return false rather than produce error if a match is not found (used by inlined groups)

local function handle(info, inputpos, tab, depth, retfalse)

	if not(type(tab)=="table" and type(tab.type)=="string") then err(info,inputpos) end

	-------------------------------------------------------------------
	-- Grab hold of handler,set,get,func,etc if set (and remember old ones)
	-- Note that we do NOT validate if method names are correct at this stage,
	-- the handler may change before they're actually used!

	local oldhandler,oldhandler_at = getparam(info,inputpos,tab,depth,"handler",handlertypes,handlermsg)
	local oldset,oldset_at = getparam(info,inputpos,tab,depth,"set",functypes,funcmsg)
	local oldget,oldget_at = getparam(info,inputpos,tab,depth,"get",functypes,funcmsg)
	local oldfunc,oldfunc_at = getparam(info,inputpos,tab,depth,"func",functypes,funcmsg)
	local oldvalidate,oldvalidate_at = getparam(info,inputpos,tab,depth,"validate",functypes,funcmsg)
	--local oldconfirm,oldconfirm_at = getparam(info,inputpos,tab,depth,"confirm",functypes,funcmsg)

	-------------------------------------------------------------------
	-- Act according to .type of this table

	if tab.type=="group" then
		------------ group --------------------------------------------

		if type(tab.args)~="table" then err(info, inputpos) end
		if tab.plugins and type(tab.plugins)~="table" then err(info,inputpos) end

		-- grab next arg from input
		local _,nextpos,arg = (info.input):find(" *([^ ]+) *", inputpos)
		if not arg then
			showhelp(info, inputpos, tab, depth)
			return
		end
		nextpos=nextpos+1

		-- loop .args and try to find a key with a matching name
		for k,v in iterateargs(tab) do
			if not(type(k)=="string" and type(v)=="table" and type(v.type)=="string") then err(info,inputpos, "options table child '"..tostring(k).."' is malformed") end

			-- is this child an inline group? if so, traverse into it
			if v.type=="group" and pickfirstset(v.cmdInline, v.inline, false) then
				info[depth+1] = k
				if handle(info, inputpos, v, depth+1, true)==false then
					info[depth+1] = nil
					-- wasn't found in there, but that's ok, we just keep looking down here
				else
					return	-- done, name was found in inline group
				end
			-- matching name and not a inline group
			elseif strlower(arg)==strlower(k:gsub(" ", "_")) then
				info[depth+1] = k
				return handle(info,nextpos,v,depth+1)
			end
		end

		-- no match
		if retfalse then
			-- restore old infotable members and return false to indicate failure
			info.handler,info.handler_at = oldhandler,oldhandler_at
			info.set,info.set_at = oldset,oldset_at
			info.get,info.get_at = oldget,oldget_at
			info.func,info.func_at = oldfunc,oldfunc_at
			info.validate,info.validate_at = oldvalidate,oldvalidate_at
			--info.confirm,info.confirm_at = oldconfirm,oldconfirm_at
			return false
		end

		-- couldn't find the command, display error
		usererr(info, inputpos, "'"..arg.."' - " .. L["unknown argument"])
		return
	end

	local strInput = strsub(info.input,inputpos);

	if tab.type=="execute" then
		------------ execute --------------------------------------------
		do_final(info, inputpos, tab, "func")



	elseif tab.type=="input" then
		------------ input --------------------------------------------

		local res = true
		if tab.pattern then
			if type(tab.pattern)~="string" then err(info, inputpos, "'pattern' - expected a string") end
			if not strmatch(strInput, tab.pattern) then
				usererr(info, inputpos, "'"..strInput.."' - " .. L["invalid input"])
				return
			end
		end

		do_final(info, inputpos, tab, "set", strInput)



	elseif tab.type=="toggle" then
		------------ toggle --------------------------------------------
		local b
		local str = strtrim(strlower(strInput))
		if str=="" then
			b = callmethod(info, inputpos, tab, "get")

			if tab.tristate then
				--cycle in true, nil, false order
				if b then
					b = nil
				elseif b == nil then
					b = false
				else
					b = true
				end
			else
				b = not b
			end

		elseif str==L["on"] then
			b = true
		elseif str==L["off"] then
			b = false
		elseif tab.tristate and str==L["default"] then
			b = nil
		else
			if tab.tristate then
				usererr(info, inputpos, format(L["'%s' - expected 'on', 'off' or 'default', or no argument to toggle."], str))
			else
				usererr(info, inputpos, format(L["'%s' - expected 'on' or 'off', or no argument to toggle."], str))
			end
			return
		end

		do_final(info, inputpos, tab, "set", b)


	elseif tab.type=="range" then
		------------ range --------------------------------------------
		local val = tonumber(strInput)
		if not val then
			usererr(info, inputpos, "'"..strInput.."' - "..L["expected number"])
			return
		end
		if type(info.step)=="number" then
			val = val- (val % info.step)
		end
		if type(info.min)=="number" and val<info.min then
			usererr(info, inputpos, val.." - "..format(L["must be equal to or higher than %s"], tostring(info.min)) )
			return
		end
		if type(info.max)=="number" and val>info.max then
			usererr(info, inputpos, val.." - "..format(L["must be equal to or lower than %s"], tostring(info.max)) )
			return
		end

		do_final(info, inputpos, tab, "set", val)


	elseif tab.type=="select" then
		------------ select ------------------------------------
		local str = strtrim(strlower(strInput))

		local values = tab.values
		if type(values) == "function" or type(values) == "string" then
			info.values = values
			values = callmethod(info, inputpos, tab, "values")
			info.values = nil
		end

		if str == "" then
			local b = callmethod(info, inputpos, tab, "get")
			local fmt = "|cffffff78- [%s]|r %s"
			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
			print(L["Options for |cffffff78"..info[#info].."|r:"])
			for k, v in pairs(values) do
				if b == k then
					print(fmt_sel:format(k, v))
				else
					print(fmt:format(k, v))
				end
			end
			return
		end

		local ok
		for k,v in pairs(values) do
			if strlower(k)==str then
				str = k	-- overwrite with key (in case of case mismatches)
				ok = true
				break
			end
		end
		if not ok then
			usererr(info, inputpos, "'"..str.."' - "..L["unknown selection"])
			return
		end

		do_final(info, inputpos, tab, "set", str)

	elseif tab.type=="multiselect" then
		------------ multiselect -------------------------------------------
		local str = strtrim(strlower(strInput))

		local values = tab.values
		if type(values) == "function" or type(values) == "string" then
			info.values = values
			values = callmethod(info, inputpos, tab, "values")
			info.values = nil
		end

		if str == "" then
			local fmt = "|cffffff78- [%s]|r %s"
			local fmt_sel = "|cffffff78- [%s]|r %s |cffff0000*|r"
			print(L["Options for |cffffff78"..info[#info].."|r (multiple possible):"])
			for k, v in pairs(values) do
				if callmethod(info, inputpos, tab, "get", k) then
					print(fmt_sel:format(k, v))
				else
					print(fmt:format(k, v))
				end
			end
			return
		end

		--build a table of the selections, checking that they exist
		--parse for =on =off =default in the process
		--table will be key = true for options that should toggle, key = [on|off|default] for options to be set
		local sels = {}
		for v in str:gmatch("[^ ]+") do
			--parse option=on etc
			local opt, val = v:match('(.+)=(.+)')
			--get option if toggling
			if not opt then
				opt = v
			end

			--check that the opt is valid
			local ok
			for k in pairs(values) do
				if strlower(k)==opt then
					opt = k	-- overwrite with key (in case of case mismatches)
					ok = true
					break
				end
			end

			if not ok then
				usererr(info, inputpos, "'"..opt.."' - "..L["unknown selection"])
				return
			end

			--check that if val was supplied it is valid
			if val then
				if val == L["on"] or val == L["off"] or (tab.tristate and val == L["default"]) then
					--val is valid insert it
					sels[opt] = val
				else
					if tab.tristate then
						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on', 'off' or 'default', or no argument to toggle."], v, val))
					else
						usererr(info, inputpos, format(L["'%s' '%s' - expected 'on' or 'off', or no argument to toggle."], v, val))
					end
					return
				end
			else
				-- no val supplied, toggle
				sels[opt] = true
			end
		end

		for opt, val in pairs(sels) do
			local newval

			if (val == true) then
				--toggle the option
				local b = callmethod(info, inputpos, tab, "get", opt)

				if tab.tristate then
					--cycle in true, nil, false order
					if b then
						b = nil
					elseif b == nil then
						b = false
					else
						b = true
					end
				else
					b = not b
				end
				newval = b
			else
				--set the option as specified
				if val==L["on"] then
					newval = true
				elseif val==L["off"] then
					newval = false
				elseif val==L["default"] then
					newval = nil
				end
			end

			do_final(info, inputpos, tab, "set", opt, newval)
		end


	elseif tab.type=="color" then
		------------ color --------------------------------------------
		local str = strtrim(strlower(strInput))
		if str == "" then
			--TODO: Show current value
			return
		end

		local r, g, b, a

		local hasAlpha = tab.hasAlpha
		if type(hasAlpha) == "function" or type(hasAlpha) == "string" then
			info.hasAlpha = hasAlpha
			hasAlpha = callmethod(info, inputpos, tab, 'hasAlpha')
			info.hasAlpha = nil
		end

		if hasAlpha then
			if str:len() == 8 and str:find("^%x*$")  then
				--parse a hex string
				r,g,b,a = tonumber(str:sub(1, 2), 16) / 255, tonumber(str:sub(3, 4), 16) / 255, tonumber(str:sub(5, 6), 16) / 255, tonumber(str:sub(7, 8), 16) / 255
			else
				--parse seperate values
				r,g,b,a = str:match("^([%d%.]+) ([%d%.]+) ([%d%.]+) ([%d%.]+)$")
				r,g,b,a = tonumber(r), tonumber(g), tonumber(b), tonumber(a)
			end
			if not (r and g and b and a) then
				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBBAA' or 'r g b a'."], str))
				return
			end

			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 and a >= 0.0 and a <= 1.0 then
				--values are valid
			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 and a >= 0 and a <= 255 then
				--values are valid 0..255, convert to 0..1
				r = r / 255
				g = g / 255
				b = b / 255
				a = a / 255
			else
				--values are invalid
				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0..1 or 0..255."], str))
			end
		else
			a = 1.0
			if str:len() == 6 and str:find("^%x*$") then
				--parse a hex string
				r,g,b = tonumber(str:sub(1, 2), 16) / 255, tonumber(str:sub(3, 4), 16) / 255, tonumber(str:sub(5, 6), 16) / 255
			else
				--parse seperate values
				r,g,b = str:match("^([%d%.]+) ([%d%.]+) ([%d%.]+)$")
				r,g,b = tonumber(r), tonumber(g), tonumber(b)
			end
			if not (r and g and b) then
				usererr(info, inputpos, format(L["'%s' - expected 'RRGGBB' or 'r g b'."], str))
				return
			end
			if r >= 0.0 and r <= 1.0 and g >= 0.0 and g <= 1.0 and b >= 0.0 and b <= 1.0 then
				--values are valid
			elseif r >= 0 and r <= 255 and g >= 0 and g <= 255 and b >= 0 and b <= 255 then
				--values are valid 0..255, convert to 0..1
				r = r / 255
				g = g / 255
				b = b / 255
			else
				--values are invalid
				usererr(info, inputpos, format(L["'%s' - values must all be either in the range 0-1 or 0-255."], str))
			end
		end

		do_final(info, inputpos, tab, "set", r,g,b,a)

	elseif tab.type=="keybinding" then
		------------ keybinding --------------------------------------------
		local str = strtrim(strlower(strInput))
		if str == "" then
			--TODO: Show current value
			return
		end
		local value = keybindingValidateFunc(str:upper())
		if value == false then
			usererr(info, inputpos, format(L["'%s' - Invalid Keybinding."], str))
			return
		end

		do_final(info, inputpos, tab, "set", value)

	elseif tab.type=="description" then
		------------ description --------------------
		-- ignore description, GUI config only
	else
		err(info, inputpos, "unknown options table item type '"..tostring(tab.type).."'")
	end
end

--- Handle the chat command.
-- This is usually called from a chat command handler to parse the command input as operations on an aceoptions table.\\
-- AceConfigCmd uses this function internally when a slash command is registered with `:CreateChatCommand`
-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param input The commandline input (as given by the WoW handler, i.e. without the command itself)
-- @usage
-- MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceConsole-3.0")
-- -- Use AceConsole-3.0 to register a Chat Command
-- MyAddon:RegisterChatCommand("mychat", "ChatCommand")
--
-- -- Show the GUI if no input is supplied, otherwise handle the chat input.
-- function MyAddon:ChatCommand(input)
--   -- Assuming "MyOptions" is the appName of a valid options table
--   if not input or input:trim() == "" then
--     LibStub("AceConfigDialog-3.0"):Open("MyOptions")
--   else
--     LibStub("AceConfigCmd-3.0").HandleCommand(MyAddon, "mychat", "MyOptions", input)
--   end
-- end
function AceConfigCmd:HandleCommand(slashcmd, appName, input)

	local optgetter = cfgreg:GetOptionsTable(appName)
	if not optgetter then
		error([[Usage: HandleCommand("slashcmd", "appName", "input"): 'appName' - no options table "]]..tostring(appName)..[[" has been registered]], 2)
	end
	local options = assert( optgetter("cmd", MAJOR) )

	local info = {   -- Don't try to recycle this, it gets handed off to callbacks and whatnot
		[0] = slashcmd,
		appName = appName,
		options = options,
		input = input,
		self = self,
		handler = self,
		uiType = "cmd",
		uiName = MAJOR,
	}

	handle(info, 1, options, 0)  -- (info, inputpos, table, depth)
end

--- Utility function to create a slash command handler.
-- Also registers tab completion with AceTab
-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
-- @param appName The application name as given to `:RegisterOptionsTable()`
function AceConfigCmd:CreateChatCommand(slashcmd, appName)
	if not AceConsole then
		AceConsole = LibStub(AceConsoleName)
	end
	if AceConsole.RegisterChatCommand(self, slashcmd, function(input)
				AceConfigCmd.HandleCommand(self, slashcmd, appName, input)	-- upgradable
		end,
	true) then -- succesfully registered so lets get the command -> app table in
		commands[slashcmd] = appName
	end
end

--- Utility function that returns the options table that belongs to a slashcommand.
-- Designed to be used for the AceTab interface.
-- @param slashcmd The slash command WITHOUT leading slash (only used for error output)
-- @return The options table associated with the slash command (or nil if the slash command was not registered)
function AceConfigCmd:GetChatCommandOptions(slashcmd)
	return commands[slashcmd]
end

=== END OF FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfigCmd-3.0/AceConfigCmd-3.0.lua ===


=== FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua ===
--- AceConfigDialog-3.0 generates AceGUI-3.0 based windows based on option tables.
-- @class file
-- @name AceConfigDialog-3.0
-- @release $Id: AceConfigDialog-3.0.lua 1372 2025-10-05 05:38:34Z nevcairiel $

local LibStub = LibStub
local gui = LibStub("AceGUI-3.0")
local reg = LibStub("AceConfigRegistry-3.0")

local MAJOR, MINOR = "AceConfigDialog-3.0", 89
local AceConfigDialog, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfigDialog then return end

AceConfigDialog.OpenFrames = AceConfigDialog.OpenFrames or {}
AceConfigDialog.Status = AceConfigDialog.Status or {}
AceConfigDialog.frame = AceConfigDialog.frame or CreateFrame("Frame")
AceConfigDialog.tooltip = AceConfigDialog.tooltip or CreateFrame("GameTooltip", "AceConfigDialogTooltip", UIParent, "GameTooltipTemplate")

AceConfigDialog.frame.apps = AceConfigDialog.frame.apps or {}
AceConfigDialog.frame.closing = AceConfigDialog.frame.closing or {}
AceConfigDialog.frame.closeAllOverride = AceConfigDialog.frame.closeAllOverride or {}

-- Lua APIs
local tinsert, tsort, tremove, wipe = table.insert, table.sort, table.remove, table.wipe
local strmatch, format = string.match, string.format
local error = error
local pairs, next, select, type, unpack, ipairs = pairs, next, select, type, unpack, ipairs
local tostring, tonumber = tostring, tonumber
local math_min, math_max, math_floor = math.min, math.max, math.floor

local emptyTbl = {}

--[[
	 xpcall safecall implementation
]]
local xpcall = xpcall

local function errorhandler(err)
	return geterrorhandler()(err)
end

local function safecall(func, ...)
	if func then
		return xpcall(func, errorhandler, ...)
	end
end

local width_multiplier = 170

--[[
Group Types
  Tree 	- All Descendant Groups will all become nodes on the tree, direct child options will appear above the tree
        - Descendant Groups with inline=true and thier children will not become nodes

  Tab	- Direct Child Groups will become tabs, direct child options will appear above the tab control
        - Grandchild groups will default to inline unless specified otherwise

  Select- Same as Tab but with entries in a dropdown rather than tabs


  Inline Groups
    - Will not become nodes of a select group, they will be effectivly part of thier parent group seperated by a border
    - If declared on a direct child of a root node of a select group, they will appear above the group container control
    - When a group is displayed inline, all descendants will also be inline members of the group

]]

-- Recycling functions
local new, del, copy
--newcount, delcount,createdcount,cached = 0,0,0
do
	local pool = setmetatable({},{__mode="k"})
	function new()
		--newcount = newcount + 1
		local t = next(pool)
		if t then
			pool[t] = nil
			return t
		else
			--createdcount = createdcount + 1
			return {}
		end
	end
	function copy(t)
		local c = new()
		for k, v in pairs(t) do
			c[k] = v
		end
		return c
	end
	function del(t)
		--delcount = delcount + 1
		wipe(t)
		pool[t] = true
	end
--	function cached()
--		local n = 0
--		for k in pairs(pool) do
--			n = n + 1
--		end
--		return n
--	end
end

-- picks the first non-nil value and returns it
local function pickfirstset(...)
  for i=1,select("#",...) do
    if select(i,...)~=nil then
      return select(i,...)
    end
  end
end

--gets an option from a given group, checking plugins
local function GetSubOption(group, key)
	if group.plugins then
		for plugin, t in pairs(group.plugins) do
			if t[key] then
				return t[key]
			end
		end
	end

	return group.args[key]
end

--Option member type definitions, used to decide how to access it

--Is the member Inherited from parent options
local isInherited = {
	set = true,
	get = true,
	func = true,
	confirm = true,
	validate = true,
	disabled = true,
	hidden = true
}

--Does a string type mean a literal value, instead of the default of a method of the handler
local stringIsLiteral = {
	name = true,
	desc = true,
	icon = true,
	usage = true,
	width = true,
	image = true,
	fontSize = true,
	tooltipHyperlink = true
}

--Is Never a function or method
local allIsLiteral = {
	type = true,
	descStyle = true,
	imageWidth = true,
	imageHeight = true,
}

--gets the value for a member that could be a function
--function refs are called with an info arg
--every other type is returned
local function GetOptionsMemberValue(membername, option, options, path, appName, ...)
	--get definition for the member
	local inherits = isInherited[membername]


	--get the member of the option, traversing the tree if it can be inherited
	local member

	if inherits then
		local group = options
		if group[membername] ~= nil then
			member = group[membername]
		end
		for i = 1, #path do
			group = GetSubOption(group, path[i])
			if group[membername] ~= nil then
				member = group[membername]
			end
		end
	else
		member = option[membername]
	end

	--check if we need to call a functon, or if we have a literal value
	if ( not allIsLiteral[membername] ) and ( type(member) == "function" or ((not stringIsLiteral[membername]) and type(member) == "string") ) then
		--We have a function to call
		local info = new()
		--traverse the options table, picking up the handler and filling the info with the path
		local group = options
		local handler = group.handler

		for i = 1, #path do
			group = GetSubOption(group, path[i])
			info[i] = path[i]
			handler = group.handler or handler
		end

		info.options = options
		info.appName = appName
		info[0] = appName
		info.arg = option.arg
		info.handler = handler
		info.option = option
		info.type = option.type
		info.uiType = "dialog"
		info.uiName = MAJOR

		local a, b, c ,d
		--using 4 returns for the get of a color type, increase if a type needs more
		if type(member) == "function" then
			--Call the function
			a,b,c,d = member(info, ...)
		else
			--Call the method
			if handler and handler[member] then
				a,b,c,d = handler[member](handler, info, ...)
			else
				error(format("Method %s doesn't exist in handler for type %s", member, membername))
			end
		end
		del(info)
		return a,b,c,d
	else
		--The value isnt a function to call, return it
		return member
	end
end

--[[calls an options function that could be inherited, method name or function ref
local function CallOptionsFunction(funcname ,option, options, path, appName, ...)
	local info = new()

	local func
	local group = options
	local handler

	--build the info table containing the path
	-- pick up functions while traversing the tree
	if group[funcname] ~= nil then
		func = group[funcname]
	end
	handler = group.handler or handler

	for i, v in ipairs(path) do
		group = GetSubOption(group, v)
		info[i] = v
		if group[funcname] ~= nil then
			func =  group[funcname]
		end
		handler = group.handler or handler
	end

	info.options = options
	info[0] = appName
	info.arg = option.arg

	local a, b, c ,d
	if type(func) == "string" then
		if handler and handler[func] then
			a,b,c,d = handler[func](handler, info, ...)
		else
			error(string.format("Method %s doesn't exist in handler for type func", func))
		end
	elseif type(func) == "function" then
		a,b,c,d = func(info, ...)
	end
	del(info)
	return a,b,c,d
end
--]]

--tables to hold orders and names for options being sorted, will be created with new()
--prevents needing to call functions repeatedly while sorting
local tempOrders
local tempNames

local function compareOptions(a,b)
	if not a then
		return true
	end
	if not b then
		return false
	end
	local OrderA, OrderB = tempOrders[a] or 100, tempOrders[b] or 100
	if OrderA == OrderB then
		local NameA = (type(tempNames[a]) == "string") and tempNames[a] or ""
		local NameB = (type(tempNames[b]) == "string") and tempNames[b] or ""
		return NameA:upper() < NameB:upper()
	end
	if OrderA < 0 then
		if OrderB >= 0 then
			return false
		end
	else
		if OrderB < 0 then
			return true
		end
	end
	return OrderA < OrderB
end



--builds 2 tables out of an options group
-- keySort, sorted keys
-- opts, combined options from .plugins and args
local function BuildSortedOptionsTable(group, keySort, opts, options, path, appName)
	tempOrders = new()
	tempNames = new()

	if group.plugins then
		for plugin, t in pairs(group.plugins) do
			for k, v in pairs(t) do
				if not opts[k] then
					tinsert(keySort, k)
					opts[k] = v

					path[#path+1] = k
					tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
					tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
					path[#path] = nil
				end
			end
		end
	end

	for k, v in pairs(group.args) do
		if not opts[k] then
			tinsert(keySort, k)
			opts[k] = v

			path[#path+1] = k
			tempOrders[k] = GetOptionsMemberValue("order", v, options, path, appName)
			tempNames[k] = GetOptionsMemberValue("name", v, options, path, appName)
			path[#path] = nil
		end
	end

	tsort(keySort, compareOptions)

	del(tempOrders)
	del(tempNames)
end

local function DelTree(tree)
	if tree.children then
		local childs = tree.children
		for i = 1, #childs do
			DelTree(childs[i])
			del(childs[i])
		end
		del(childs)
	end
end

local function CleanUserData(widget, event)

	local user = widget:GetUserDataTable()

	if user.path then
		del(user.path)
	end

	if widget.type == "TreeGroup" then
		local tree = user.tree
		widget:SetTree(nil)
		if tree then
			for i = 1, #tree do
				DelTree(tree[i])
				del(tree[i])
			end
			del(tree)
		end
	end

	if widget.type == "TabGroup" then
		widget:SetTabs(nil)
		if user.tablist then
			del(user.tablist)
		end
	end

	if widget.type == "DropdownGroup" then
		widget:SetGroupList(nil)
		if user.grouplist then
			del(user.grouplist)
		end
		if user.orderlist then
			del(user.orderlist)
		end
	end
end

-- - Gets a status table for the given appname and options path.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param path The path to the options (a table with all group keys)
-- @return
function AceConfigDialog:GetStatusTable(appName, path)
	local status = self.Status

	if not status[appName] then
		status[appName] = {}
		status[appName].status = {}
		status[appName].children = {}
	end

	status = status[appName]

	if path then
		for i = 1, #path do
			local v = path[i]
			if not status.children[v] then
				status.children[v] = {}
				status.children[v].status = {}
				status.children[v].children = {}
			end
			status = status.children[v]
		end
	end

	return status.status
end

--- Selects the specified path in the options window.
-- The path specified has to match the keys of the groups in the table.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param ... The path to the key that should be selected
function AceConfigDialog:SelectGroup(appName, ...)
	local path = new()


	local app = reg:GetOptionsTable(appName)
	if not app then
		error(("%s isn't registed with AceConfigRegistry, unable to open config"):format(appName), 2)
	end
	local options = app("dialog", MAJOR)
	local group = options
	local status = self:GetStatusTable(appName, path)
	if not status.groups then
		status.groups = {}
	end
	status = status.groups
	local treevalue
	local treestatus

	for n = 1, select("#",...) do
		local key = select(n, ...)

		if group.childGroups == "tab" or group.childGroups == "select" then
			--if this is a tab or select group, select the group
			status.selected = key
			--children of this group are no longer extra levels of a tree
			treevalue = nil
		else
			--tree group by default
			if treevalue then
				--this is an extra level of a tree group, build a uniquevalue for it
				treevalue = treevalue.."\001"..key
			else
				--this is the top level of a tree group, the uniquevalue is the same as the key
				treevalue = key
				if not status.groups then
					status.groups = {}
				end
				--save this trees status table for any extra levels or groups
				treestatus = status
			end
			--make sure that the tree entry is open, and select it.
			--the selected group will be overwritten if a child is the final target but still needs to be open
			treestatus.selected = treevalue
			treestatus.groups[treevalue] = true

		end

		--move to the next group in the path
		group = GetSubOption(group, key)
		if not group then
			break
		end
		tinsert(path, key)
		status = self:GetStatusTable(appName, path)
		if not status.groups then
			status.groups = {}
		end
		status = status.groups
	end

	del(path)
	reg:NotifyChange(appName)
end

local function OptionOnMouseOver(widget, event)
	--show a tooltip/set the status bar to the desc text
	local user = widget:GetUserDataTable()
	local opt = user.option
	local options = user.options
	local path = user.path
	local appName = user.appName
	local tooltip = AceConfigDialog.tooltip

	tooltip:SetOwner(widget.frame, "ANCHOR_TOPRIGHT")

	local tooltipHyperlink = GetOptionsMemberValue("tooltipHyperlink", opt, options, path, appName)
	if tooltipHyperlink then
		tooltip:SetHyperlink(tooltipHyperlink)
		tooltip:Show()
		return
	end

	local name = GetOptionsMemberValue("name", opt, options, path, appName)
	local desc = GetOptionsMemberValue("desc", opt, options, path, appName)
	local usage = GetOptionsMemberValue("usage", opt, options, path, appName)
	local descStyle = opt.descStyle

	if descStyle and descStyle ~= "tooltip" then return end

	tooltip:SetText(name, 1, .82, 0, 1, true)

	if opt.type == "multiselect" then
		tooltip:AddLine(user.text, 0.5, 0.5, 0.8, true)
	end
	if type(desc) == "string" then
		tooltip:AddLine(desc, 1, 1, 1, true)
	end
	if type(usage) == "string" then
		tooltip:AddLine(usage, NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b, true)
	end

	tooltip:Show()
end

local function OptionOnMouseLeave(widget, event)
	AceConfigDialog.tooltip:Hide()
end

local function GetFuncName(option)
	if option.type == "execute" then
		return "func"
	else
		return "set"
	end
end
do
	local InCombatLockdown = InCombatLockdown
	local frame = AceConfigDialog.popup
	if not frame or oldminor < 81 then
		frame = CreateFrame("Frame", nil, UIParent)
		AceConfigDialog.popup = frame
		frame:Hide()
		frame:SetPoint("CENTER", UIParent, "CENTER")
		frame:SetSize(320, 72)
		frame:EnableMouse(true) -- Do not allow click-through on the frame
		frame:SetFrameStrata("TOOLTIP")
		frame:SetFrameLevel(100) -- Lots of room to draw under it
		frame:SetScript("OnKeyDown", function(self, key)
			if key == "ESCAPE" then
				if not InCombatLockdown() then
					self:SetPropagateKeyboardInput(false)
				end
				if self.cancel:IsShown() then
					self.cancel:Click()
				else -- Showing a validation error
					self:Hide()
				end
			elseif not InCombatLockdown() then
				self:SetPropagateKeyboardInput(true)
			end
		end)

		local border = CreateFrame("Frame", nil, frame, "DialogBorderOpaqueTemplate")
		border:SetAllPoints(frame)
		frame:SetFixedFrameStrata(true)
		frame:SetFixedFrameLevel(true)

		local text = frame:CreateFontString(nil, "ARTWORK", "GameFontHighlight")
		text:SetSize(290, 0)
		text:SetPoint("TOP", 0, -16)
		frame.text = text

		local function newButton(newText)
			local button = CreateFrame("Button", nil, frame)
			button:SetSize(128, 21)
			button:SetNormalFontObject(GameFontNormal)
			button:SetHighlightFontObject(GameFontHighlight)
			button:SetNormalTexture(130763) -- "Interface\\Buttons\\UI-DialogBox-Button-Up"
			button:GetNormalTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
			button:SetPushedTexture(130761) -- "Interface\\Buttons\\UI-DialogBox-Button-Down"
			button:GetPushedTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
			button:SetHighlightTexture(130762) -- "Interface\\Buttons\\UI-DialogBox-Button-Highlight"
			button:GetHighlightTexture():SetTexCoord(0.0, 1.0, 0.0, 0.71875)
			button:SetText(newText)
			return button
		end

		local accept = newButton(ACCEPT)
		accept:SetPoint("BOTTOMRIGHT", frame, "BOTTOM", -6, 16)
		frame.accept = accept

		local cancel = newButton(CANCEL)
		cancel:SetPoint("LEFT", accept, "RIGHT", 13, 0)
		frame.cancel = cancel
	end
end
local function confirmPopup(appName, rootframe, basepath, info, message, func, ...)
	local frame = AceConfigDialog.popup
	frame:Show()
	frame.text:SetText(message)
	-- From StaticPopup.lua
	-- local height = 32 + text:GetHeight() + 2;
	-- height = height + 6 + accept:GetHeight()
	-- We add 32 + 2 + 6 + 21 (button height) == 61
	local height = 61 + frame.text:GetHeight()
	frame:SetHeight(height)

	frame.accept:ClearAllPoints()
	frame.accept:SetPoint("BOTTOMRIGHT", frame, "BOTTOM", -6, 16)
	frame.cancel:Show()

	local t = {...}
	local tCount = select("#", ...)
	frame.accept:SetScript("OnClick", function(self)
		safecall(func, unpack(t, 1, tCount)) -- Manually set count as unpack() stops on nil (bug with #table)
		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
		frame:Hide()
		self:SetScript("OnClick", nil)
		frame.cancel:SetScript("OnClick", nil)
		del(info)
	end)
	frame.cancel:SetScript("OnClick", function(self)
		AceConfigDialog:Open(appName, rootframe, unpack(basepath or emptyTbl))
		frame:Hide()
		self:SetScript("OnClick", nil)
		frame.accept:SetScript("OnClick", nil)
		del(info)
	end)
end

local function validationErrorPopup(message)
	local frame = AceConfigDialog.popup
	frame:Show()
	frame.text:SetText(message)
	-- From StaticPopup.lua
	-- local height = 32 + text:GetHeight() + 2;
	-- height = height + 6 + accept:GetHeight()
	-- We add 32 + 2 + 6 + 21 (button height) == 61
	local height = 61 + frame.text:GetHeight()
	frame:SetHeight(height)

	frame.accept:ClearAllPoints()
	frame.accept:SetPoint("BOTTOM", frame, "BOTTOM", 0, 16)
	frame.cancel:Hide()

	frame.accept:SetScript("OnClick", function()
		frame:Hide()
	end)
end

local function ActivateControl(widget, event, ...)
	--This function will call the set / execute handler for the widget
	--widget:GetUserDataTable() contains the needed info
	local user = widget:GetUserDataTable()
	local option = user.option
	local options = user.options
	local path = user.path
	local info = new()

	local func
	local group = options
	local funcname = GetFuncName(option)
	local handler
	local confirm
	local validate
	--build the info table containing the path
	-- pick up functions while traversing the tree
	if group[funcname] ~= nil then
		func =  group[funcname]
	end
	handler = group.handler
	confirm = group.confirm
	validate = group.validate
	for i = 1, #path do
		local v = path[i]
		group = GetSubOption(group, v)
		info[i] = v
		if group[funcname] ~= nil then
			func =  group[funcname]
		end
		handler = group.handler or handler
		if group.confirm ~= nil then
			confirm = group.confirm
		end
		if group.validate ~= nil then
			validate = group.validate
		end
	end

	info.options = options
	info.appName = user.appName
	info.arg = option.arg
	info.handler = handler
	info.option = option
	info.type = option.type
	info.uiType = "dialog"
	info.uiName = MAJOR

	local name
	if type(option.name) == "function" then
		name = option.name(info)
	elseif type(option.name) == "string" then
		name = option.name
	else
		name = ""
	end
	local usage = option.usage
	local pattern = option.pattern

	local validated = true

	if option.type == "input" then
		if type(pattern)=="string" then
			if not strmatch(..., pattern) then
				validated = false
			end
		end
	end

	local success
	if validated and option.type ~= "execute" then
		if type(validate) == "string" then
			if handler and handler[validate] then
				success, validated = safecall(handler[validate], handler, info, ...)
				if not success then validated = false end
			else
				error(format("Method %s doesn't exist in handler for type execute", validate))
			end
		elseif type(validate) == "function" then
			success, validated = safecall(validate, info, ...)
			if not success then validated = false end
		end
	end

	if not validated or type(validated) == "string" then
		if not validated then
			if usage then
				validated = name..": "..usage
			else
				if pattern then
					validated = name..": Expected "..pattern
				else
					validated = name..": Invalid Value"
				end
			end
		end

		-- show validate message
		if user.rootframe.SetStatusText then
			user.rootframe:SetStatusText(validated)
		else
			validationErrorPopup(validated)
		end
		PlaySound(882) -- SOUNDKIT.IG_PLAYER_INVITE_DECLINE || _DECLINE is actually missing from the table
		del(info)
		return true
	else

		local confirmText = option.confirmText
		--call confirm func/method
		if type(confirm) == "string" then
			if handler and handler[confirm] then
				success, confirm = safecall(handler[confirm], handler, info, ...)
				if success and type(confirm) == "string" then
					confirmText = confirm
					confirm = true
				elseif not success then
					confirm = false
				end
			else
				error(format("Method %s doesn't exist in handler for type confirm", confirm))
			end
		elseif type(confirm) == "function" then
			success, confirm = safecall(confirm, info, ...)
			if success and type(confirm) == "string" then
				confirmText = confirm
				confirm = true
			elseif not success then
				confirm = false
			end
		end

		--confirm if needed
		if type(confirm) == "boolean" then
			if confirm then
				if not confirmText then
					local option_name, desc = option.name, option.desc
					if type(option_name) == "function" then
						option_name = option_name(info)
					end
					if type(desc) == "function" then
						desc = desc(info)
					end
					confirmText = option_name
					if desc then
						confirmText = confirmText.." - "..desc
					end
				end

				local iscustom = user.rootframe:GetUserData("iscustom")
				local rootframe

				if iscustom then
					rootframe = user.rootframe
				end
				local basepath = user.rootframe:GetUserData("basepath")
				if type(func) == "string" then
					if handler and handler[func] then
						confirmPopup(user.appName, rootframe, basepath, info, confirmText, handler[func], handler, info, ...)
					else
						error(format("Method %s doesn't exist in handler for type func", func))
					end
				elseif type(func) == "function" then
					confirmPopup(user.appName, rootframe, basepath, info, confirmText, func, info, ...)
				end
				--func will be called and info deleted when the confirm dialog is responded to
				return
			end
		end

		--call the function
		if type(func) == "string" then
			if handler and handler[func] then
				safecall(handler[func],handler, info, ...)
			else
				error(format("Method %s doesn't exist in handler for type func", func))
			end
		elseif type(func) == "function" then
			safecall(func,info, ...)
		end



		local iscustom = user.rootframe:GetUserData("iscustom")
		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
		--full refresh of the frame, some controls dont cause this on all events
		if option.type == "color" then
			if event == "OnValueConfirmed" then

				if iscustom then
					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
				else
					AceConfigDialog:Open(user.appName, unpack(basepath))
				end
			end
		elseif option.type == "range" then
			if event == "OnMouseUp" then
				if iscustom then
					AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
				else
					AceConfigDialog:Open(user.appName, unpack(basepath))
				end
			end
		--multiselects don't cause a refresh on 'OnValueChanged' only 'OnClosed'
		elseif option.type == "multiselect" then
			user.valuechanged = true
		else
			if iscustom then
				AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
			else
				AceConfigDialog:Open(user.appName, unpack(basepath))
			end
		end

	end
	del(info)
end

local function ActivateSlider(widget, event, value)
	local option = widget:GetUserData("option")
	local min, max, step = option.min or (not option.softMin and 0 or nil), option.max or (not option.softMax and 100 or nil), option.step
	if min then
		if step then
			value = math_floor((value - min) / step + 0.5) * step + min
		end
		value = math_max(value, min)
	end
	if max then
		value = math_min(value, max)
	end
	ActivateControl(widget,event,value)
end

--called from a checkbox that is part of an internally created multiselect group
--this type is safe to refresh on activation of one control
local function ActivateMultiControl(widget, event, ...)
	ActivateControl(widget, event, widget:GetUserData("value"), ...)
	local user = widget:GetUserDataTable()
	local iscustom = user.rootframe:GetUserData("iscustom")
	local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
	if iscustom then
		AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
	else
		AceConfigDialog:Open(user.appName, unpack(basepath))
	end
end

local function MultiControlOnClosed(widget, event, ...)
	local user = widget:GetUserDataTable()
	if user.valuechanged and not widget:IsReleasing() then
		local iscustom = user.rootframe:GetUserData("iscustom")
		local basepath = user.rootframe:GetUserData("basepath") or emptyTbl
		if iscustom then
			AceConfigDialog:Open(user.appName, user.rootframe, unpack(basepath))
		else
			AceConfigDialog:Open(user.appName, unpack(basepath))
		end
	end
end

local function FrameOnClose(widget, event)
	local appName = widget:GetUserData("appName")
	AceConfigDialog.OpenFrames[appName] = nil
	gui:Release(widget)
end

local function CheckOptionHidden(option, options, path, appName)
	--check for a specific boolean option
	local hidden = pickfirstset(option.dialogHidden,option.guiHidden)
	if hidden ~= nil then
		return hidden
	end

	return GetOptionsMemberValue("hidden", option, options, path, appName)
end

local function CheckOptionDisabled(option, options, path, appName)
	--check for a specific boolean option
	local disabled = pickfirstset(option.dialogDisabled,option.guiDisabled)
	if disabled ~= nil then
		return disabled
	end

	return GetOptionsMemberValue("disabled", option, options, path, appName)
end
--[[
local function BuildTabs(group, options, path, appName)
	local tabs = new()
	local text = new()
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, #keySort do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			path[#path+1] = k
			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				tinsert(tabs, k)
				text[k] = GetOptionsMemberValue("name", v, options, path, appName)
			end
			path[#path] = nil
		end
	end

	del(keySort)
	del(opts)

	return tabs, text
end
]]
local function BuildSelect(group, options, path, appName)
	local groups = new()
	local order = new()
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, #keySort do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			path[#path+1] = k
			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				groups[k] = GetOptionsMemberValue("name", v, options, path, appName)
				tinsert(order, k)
			end
			path[#path] = nil
		end
	end

	del(opts)
	del(keySort)

	return groups, order
end

local function BuildSubGroups(group, tree, options, path, appName)
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, #keySort do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			path[#path+1] = k
			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				local entry = new()
				entry.value = k
				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
				entry.iconCoords = GetOptionsMemberValue("iconCoords", v, options, path, appName)
				entry.disabled = CheckOptionDisabled(v, options, path, appName)
				if not tree.children then tree.children = new() end
				tinsert(tree.children,entry)
				if (v.childGroups or "tree") == "tree" then
					BuildSubGroups(v,entry, options, path, appName)
				end
			end
			path[#path] = nil
		end
	end

	del(keySort)
	del(opts)
end

local function BuildGroups(group, options, path, appName, recurse)
	local tree = new()
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, #keySort do
		local k = keySort[i]
		local v = opts[k]
		if v.type == "group" then
			path[#path+1] = k
			local inline = pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
			local hidden = CheckOptionHidden(v, options, path, appName)
			if not inline and not hidden then
				local entry = new()
				entry.value = k
				entry.text = GetOptionsMemberValue("name", v, options, path, appName)
				entry.icon = GetOptionsMemberValue("icon", v, options, path, appName)
				entry.iconCoords = GetOptionsMemberValue("iconCoords", v, options, path, appName)
				entry.disabled = CheckOptionDisabled(v, options, path, appName)
				tinsert(tree,entry)
				if recurse and (v.childGroups or "tree") == "tree" then
					BuildSubGroups(v,entry, options, path, appName)
				end
			end
			path[#path] = nil
		end
	end
	del(keySort)
	del(opts)
	return tree
end

local function InjectInfo(control, options, option, path, rootframe, appName)
	local user = control:GetUserDataTable()
	for i = 1, #path do
		user[i] = path[i]
	end
	user.rootframe = rootframe
	user.option = option
	user.options = options
	user.path = copy(path)
	user.appName = appName
	control:SetCallback("OnRelease", CleanUserData)
	control:SetCallback("OnLeave", OptionOnMouseLeave)
	control:SetCallback("OnEnter", OptionOnMouseOver)
end

local function CreateControl(userControlType, fallbackControlType)
	local control
	if userControlType then
		control = gui:Create(userControlType)
		if not control then
			geterrorhandler()(("Invalid Custom Control Type - %s"):format(tostring(userControlType)))
		end
	end
	if not control then
		control = gui:Create(fallbackControlType)
	end
	return control
end

local function sortTblAsStrings(x,y)
	return tostring(x) < tostring(y) -- Support numbers as keys
end

--[[
	options - root of the options table being fed
	container - widget that controls will be placed in
	rootframe - Frame object the options are in
	path - table with the keys to get to the group being fed
--]]

local function FeedOptions(appName, options,container,rootframe,path,group,inline)
	local keySort = new()
	local opts = new()

	BuildSortedOptionsTable(group, keySort, opts, options, path, appName)

	for i = 1, #keySort do
		local k = keySort[i]
		local v = opts[k]
		tinsert(path, k)
		local hidden = CheckOptionHidden(v, options, path, appName)
		local name = GetOptionsMemberValue("name", v, options, path, appName)
		if not hidden then
			if v.type == "group" then
				if inline or pickfirstset(v.dialogInline,v.guiInline,v.inline, false) then
					--Inline group
					local GroupContainer
					if name and name ~= "" then
						GroupContainer = gui:Create("InlineGroup")
						GroupContainer:SetTitle(name or "")
					else
						GroupContainer = gui:Create("SimpleGroup")
					end

					GroupContainer.width = "fill"
					GroupContainer:SetLayout("flow")
					container:AddChild(GroupContainer)
					FeedOptions(appName,options,GroupContainer,rootframe,path,v,true)
				end
			else
				--Control to feed
				local control

				if v.type == "execute" then

					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)

					local iconControl = type(image) == "string" or type(image) == "number"
					control = CreateControl(v.dialogControl or v.control, iconControl and "Icon" or "Button")
					if iconControl then
						if not width then
							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
						end
						if not height then
							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
						end
						if type(imageCoords) == "table" then
							control:SetImage(image, unpack(imageCoords))
						else
							control:SetImage(image)
						end
						if type(width) ~= "number" then
							width = 32
						end
						if type(height) ~= "number" then
							height = 32
						end
						control:SetImageSize(width, height)
						control:SetLabel(name)
					else
						control:SetText(name)
					end
					control:SetCallback("OnClick",ActivateControl)

				elseif v.type == "input" then
					control = CreateControl(v.dialogControl or v.control, v.multiline and "MultiLineEditBox" or "EditBox")

					if v.multiline and control.SetNumLines then
						control:SetNumLines(tonumber(v.multiline) or 4)
					end
					control:SetLabel(name)
					control:SetCallback("OnEnterPressed",ActivateControl)
					local text = GetOptionsMemberValue("get",v, options, path, appName)
					if type(text) ~= "string" then
						text = ""
					end
					control:SetText(text)

				elseif v.type == "toggle" then
					control = CreateControl(v.dialogControl or v.control, "CheckBox")
					control:SetLabel(name)
					control:SetTriState(v.tristate)
					local value = GetOptionsMemberValue("get",v, options, path, appName)
					control:SetValue(value)
					control:SetCallback("OnValueChanged",ActivateControl)

					if v.descStyle == "inline" then
						local desc = GetOptionsMemberValue("desc", v, options, path, appName)
						control:SetDescription(desc)
					end

					local image = GetOptionsMemberValue("image", v, options, path, appName)
					local imageCoords = GetOptionsMemberValue("imageCoords", v, options, path, appName)

					if type(image) == "string" or type(image) == "number" then
						if type(imageCoords) == "table" then
							control:SetImage(image, unpack(imageCoords))
						else
							control:SetImage(image)
						end
					end
				elseif v.type == "range" then
					control = CreateControl(v.dialogControl or v.control, "Slider")
					control:SetLabel(name)
					control:SetSliderValues(v.softMin or v.min or 0, v.softMax or v.max or 100, v.bigStep or v.step or 0)
					control:SetIsPercent(v.isPercent)
					local value = GetOptionsMemberValue("get",v, options, path, appName)
					if type(value) ~= "number" then
						value = 0
					end
					control:SetValue(value)
					control:SetCallback("OnValueChanged",ActivateSlider)
					control:SetCallback("OnMouseUp",ActivateSlider)

				elseif v.type == "select" then
					local values = GetOptionsMemberValue("values", v, options, path, appName)
					local sorting = GetOptionsMemberValue("sorting", v, options, path, appName)
					if v.style == "radio" then
						local disabled = CheckOptionDisabled(v, options, path, appName)
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						control = gui:Create("InlineGroup")
						control:SetLayout("Flow")
						control:SetTitle(name)
						control.width = "fill"

						control:PauseLayout()
						local optionValue = GetOptionsMemberValue("get",v, options, path, appName)
						if not sorting then
							sorting = {}
							for value, text in pairs(values) do
								sorting[#sorting+1]=value
							end
							tsort(sorting, sortTblAsStrings)
						end
						for _, value in ipairs(sorting) do
							local text = values[value]
							local radio = gui:Create("CheckBox")
							radio:SetLabel(text)
							radio:SetUserData("value", value)
							radio:SetUserData("text", text)
							radio:SetDisabled(disabled)
							radio:SetType("radio")
							radio:SetValue(optionValue == value)
							radio:SetCallback("OnValueChanged", ActivateMultiControl)
							InjectInfo(radio, options, v, path, rootframe, appName)
							control:AddChild(radio)
							if width == "double" then
								radio:SetWidth(width_multiplier * 2)
							elseif width == "half" then
								radio:SetWidth(width_multiplier / 2)
							elseif (type(width) == "number") then
								radio:SetWidth(width_multiplier * width)
							elseif width == "full" then
								radio.width = "fill"
							else
								radio:SetWidth(width_multiplier)
							end
						end
						control:ResumeLayout()
						control:DoLayout()
					else
						control = CreateControl(v.dialogControl or v.control, "Dropdown")
						local itemType = v.itemControl
						if itemType and not gui:GetWidgetVersion(itemType) then
							geterrorhandler()(("Invalid Custom Item Type - %s"):format(tostring(itemType)))
							itemType = nil
						end
						control:SetLabel(name)
						control:SetList(values, sorting, itemType)
						local value = GetOptionsMemberValue("get",v, options, path, appName)
						if not values[value] then
							value = nil
						end
						control:SetValue(value)
						control:SetCallback("OnValueChanged", ActivateControl)
					end

				elseif v.type == "multiselect" then
					local values = GetOptionsMemberValue("values", v, options, path, appName)
					local disabled = CheckOptionDisabled(v, options, path, appName)

					local valuesort = new()
					if values then
						for value, text in pairs(values) do
							tinsert(valuesort, value)
						end
					end
					tsort(valuesort)

					local controlType = v.dialogControl or v.control
					if controlType then
						control = gui:Create(controlType)
						if not control then
							geterrorhandler()(("Invalid Custom Control Type - %s"):format(tostring(controlType)))
						end
					end
					if control then
						control:SetMultiselect(true)
						control:SetLabel(name)
						control:SetList(values)
						control:SetDisabled(disabled)
						control:SetCallback("OnValueChanged",ActivateControl)
						control:SetCallback("OnClosed", MultiControlOnClosed)
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						if width == "double" then
							control:SetWidth(width_multiplier * 2)
						elseif width == "half" then
							control:SetWidth(width_multiplier / 2)
						elseif (type(width) == "number") then
							control:SetWidth(width_multiplier * width)
						elseif width == "full" then
							control.width = "fill"
						else
							control:SetWidth(width_multiplier)
						end
						--check:SetTriState(v.tristate)
						for s = 1, #valuesort do
							local key = valuesort[s]
							local value = GetOptionsMemberValue("get",v, options, path, appName, key)
							control:SetItemValue(key,value)
						end
					else
						control = gui:Create("InlineGroup")
						control:SetLayout("Flow")
						control:SetTitle(name)
						control.width = "fill"

						control:PauseLayout()
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						for s = 1, #valuesort do
							local value = valuesort[s]
							local text = values[value]
							local check = gui:Create("CheckBox")
							check:SetLabel(text)
							check:SetUserData("value", value)
							check:SetUserData("text", text)
							check:SetDisabled(disabled)
							check:SetTriState(v.tristate)
							check:SetValue(GetOptionsMemberValue("get",v, options, path, appName, value))
							check:SetCallback("OnValueChanged",ActivateMultiControl)
							InjectInfo(check, options, v, path, rootframe, appName)
							control:AddChild(check)
							if width == "double" then
								check:SetWidth(width_multiplier * 2)
							elseif width == "half" then
								check:SetWidth(width_multiplier / 2)
							elseif (type(width) == "number") then
								check:SetWidth(width_multiplier * width)
							elseif width == "full" then
								check.width = "fill"
							else
								check:SetWidth(width_multiplier)
							end
						end
						control:ResumeLayout()
						control:DoLayout()


					end

					del(valuesort)

				elseif v.type == "color" then
					control = CreateControl(v.dialogControl or v.control, "ColorPicker")
					control:SetLabel(name)
					control:SetHasAlpha(GetOptionsMemberValue("hasAlpha",v, options, path, appName))
					control:SetColor(GetOptionsMemberValue("get",v, options, path, appName))
					control:SetCallback("OnValueChanged",ActivateControl)
					control:SetCallback("OnValueConfirmed",ActivateControl)

				elseif v.type == "keybinding" then
					control = CreateControl(v.dialogControl or v.control, "Keybinding")
					control:SetLabel(name)
					control:SetKey(GetOptionsMemberValue("get",v, options, path, appName))
					control:SetCallback("OnKeyChanged",ActivateControl)

				elseif v.type == "header" then
					control = CreateControl(v.dialogControl or v.control, "Heading")
					control:SetText(name)
					control.width = "fill"

				elseif v.type == "description" then
					control = CreateControl(v.dialogControl or v.control, "Label")
					control:SetText(name)

					local fontSize = GetOptionsMemberValue("fontSize",v, options, path, appName)
					if fontSize == "medium" then
						control:SetFontObject(GameFontHighlight)
					elseif fontSize == "large" then
						control:SetFontObject(GameFontHighlightLarge)
					else -- small or invalid
						control:SetFontObject(GameFontHighlightSmall)
					end

					local imageCoords = GetOptionsMemberValue("imageCoords",v, options, path, appName)
					local image, width, height = GetOptionsMemberValue("image",v, options, path, appName)

					if type(image) == "string" or type(image) == "number" then
						if not width then
							width = GetOptionsMemberValue("imageWidth",v, options, path, appName)
						end
						if not height then
							height = GetOptionsMemberValue("imageHeight",v, options, path, appName)
						end
						if type(imageCoords) == "table" then
							control:SetImage(image, unpack(imageCoords))
						else
							control:SetImage(image)
						end
						if type(width) ~= "number" then
							width = 32
						end
						if type(height) ~= "number" then
							height = 32
						end
						control:SetImageSize(width, height)
					end
					local controlWidth = GetOptionsMemberValue("width",v,options,path,appName)
					control.width = not controlWidth and "fill"
				end

				--Common Init
				if control then
					if control.width ~= "fill" then
						local width = GetOptionsMemberValue("width",v,options,path,appName)
						if width == "double" then
							control:SetWidth(width_multiplier * 2)
						elseif width == "half" then
							control:SetWidth(width_multiplier / 2)
						elseif (type(width) == "number") then
							control:SetWidth(width_multiplier * width)
						elseif width == "full" then
							control.width = "fill"
						else
							control:SetWidth(width_multiplier)
						end
					end
					if control.SetDisabled then
						local disabled = CheckOptionDisabled(v, options, path, appName)
						control:SetDisabled(disabled)
					end

					InjectInfo(control, options, v, path, rootframe, appName)
					container:AddChild(control)
				end

			end
		end
		tremove(path)
	end
	container:ResumeLayout()
	container:DoLayout()
	del(keySort)
	del(opts)
end

local function BuildPath(path, ...)
	for i = 1, select("#",...)  do
		tinsert(path, (select(i,...)))
	end
end


local function TreeOnButtonEnter(widget, event, uniquevalue, button)
	local user = widget:GetUserDataTable()
	if not user then return end
	local options = user.options
	local option = user.option
	local path = user.path
	local appName = user.appName
	local tooltip = AceConfigDialog.tooltip

	local feedpath = new()
	for i = 1, #path do
		feedpath[i] = path[i]
	end

	BuildPath(feedpath, ("\001"):split(uniquevalue))
	local group = options
	for i = 1, #feedpath do
		if not group then return end
		group = GetSubOption(group, feedpath[i])
	end

	local name = GetOptionsMemberValue("name", group, options, feedpath, appName)
	local desc = GetOptionsMemberValue("desc", group, options, feedpath, appName)

	tooltip:SetOwner(button, "ANCHOR_NONE")
	tooltip:ClearAllPoints()
	if widget.type == "TabGroup" then
		tooltip:SetPoint("BOTTOM",button,"TOP")
	else
		tooltip:SetPoint("LEFT",button,"RIGHT")
	end

	tooltip:SetText(name, 1, .82, 0, 1, true)

	if type(desc) == "string" then
		tooltip:AddLine(desc, 1, 1, 1, true)
	end

	tooltip:Show()
end

local function TreeOnButtonLeave(widget, event, value, button)
	AceConfigDialog.tooltip:Hide()
end


local function GroupExists(appName, options, path, uniquevalue)
	if not uniquevalue then return false end

	local feedpath = new()
	local temppath = new()
	for i = 1, #path do
		feedpath[i] = path[i]
	end

	BuildPath(feedpath, ("\001"):split(uniquevalue))

	local group = options
	for i = 1, #feedpath do
		local v = feedpath[i]
		temppath[i] = v
		group = GetSubOption(group, v)

		if not group or group.type ~= "group" or CheckOptionHidden(group, options, temppath, appName) then
			del(feedpath)
			del(temppath)
			return false
		end
	end
	del(feedpath)
	del(temppath)
	return true
end

local function GroupSelected(widget, event, uniquevalue)

	local user = widget:GetUserDataTable()

	local options = user.options
	local option = user.option
	local path = user.path
	local rootframe = user.rootframe

	local feedpath = new()
	for i = 1, #path do
		feedpath[i] = path[i]
	end

	BuildPath(feedpath, ("\001"):split(uniquevalue))
	widget:ReleaseChildren()
	AceConfigDialog:FeedGroup(user.appName,options,widget,rootframe,feedpath)

	del(feedpath)
end



--[[
-- INTERNAL --
This function will feed one group, and any inline child groups into the given container
Select Groups will only have the selection control (tree, tabs, dropdown) fed in
and have a group selected, this event will trigger the feeding of child groups

Rules:
	If the group is Inline, FeedOptions
	If the group has no child groups, FeedOptions

	If the group is a tab or select group, FeedOptions then add the Group Control
	If the group is a tree group FeedOptions then
		its parent isnt a tree group:  then add the tree control containing this and all child tree groups
		if its parent is a tree group, its already a node on a tree
--]]

function AceConfigDialog:FeedGroup(appName,options,container,rootframe,path, isRoot)
	local group = options
	--follow the path to get to the curent group
	local inline
	local grouptype, parenttype = options.childGroups, "none"


	for i = 1, #path do
		local v = path[i]
		group = GetSubOption(group, v)
		inline = inline or pickfirstset(v.dialogInline,v.guiInline,v.inline, false)
		parenttype = grouptype
		grouptype = group.childGroups
	end

	if not parenttype then
		parenttype = "tree"
	end

	--check if the group has child groups
	local hasChildGroups
	for k, v in pairs(group.args) do
		if v.type == "group" and not pickfirstset(v.dialogInline,v.guiInline,v.inline, false) and not CheckOptionHidden(v, options, path, appName) then
			hasChildGroups = true
		end
	end
	if group.plugins then
		for plugin, t in pairs(group.plugins) do
			for k, v in pairs(t) do
				if v.type == "group" and not pickfirstset(v.dialogInline,v.guiInline,v.inline, false) and not CheckOptionHidden(v, options, path, appName) then
					hasChildGroups = true
				end
			end
		end
	end

	container:SetLayout("flow")
	local scroll

	--Add a scrollframe if we are not going to add a group control, this is the inverse of the conditions for that later on
	if (not (hasChildGroups and not inline)) or (grouptype ~= "tab" and grouptype ~= "select" and (parenttype == "tree" and not isRoot)) then
		if container.type ~= "InlineGroup" and container.type ~= "SimpleGroup" then
			scroll = gui:Create("ScrollFrame")
			scroll:SetLayout("flow")
			scroll.width = "fill"
			scroll.height = "fill"
			container:SetLayout("fill")
			container:AddChild(scroll)
			container = scroll
		end
	end

	FeedOptions(appName,options,container,rootframe,path,group,nil)

	if scroll then
		container:PerformLayout()
		local status = self:GetStatusTable(appName, path)
		if not status.scroll then
			status.scroll = {}
		end
		scroll:SetStatusTable(status.scroll)
	end

	if hasChildGroups and not inline then
		local name = GetOptionsMemberValue("name", group, options, path, appName)
		if grouptype == "tab" then

			local tab = gui:Create("TabGroup")
			InjectInfo(tab, options, group, path, rootframe, appName)
			tab:SetCallback("OnGroupSelected", GroupSelected)
			tab:SetCallback("OnTabEnter", TreeOnButtonEnter)
			tab:SetCallback("OnTabLeave", TreeOnButtonLeave)

			local status = AceConfigDialog:GetStatusTable(appName, path)
			if not status.groups then
				status.groups = {}
			end
			tab:SetStatusTable(status.groups)
			tab.width = "fill"
			tab.height = "fill"

			local tabs = BuildGroups(group, options, path, appName)
			tab:SetTabs(tabs)
			tab:SetUserData("tablist", tabs)

			for i = 1, #tabs do
				local entry = tabs[i]
				if not entry.disabled then
					tab:SelectTab((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
					break
				end
			end

			container:AddChild(tab)

		elseif grouptype == "select" then

			local selectGroup = gui:Create("DropdownGroup")
			selectGroup:SetTitle(name)
			InjectInfo(selectGroup, options, group, path, rootframe, appName)
			selectGroup:SetCallback("OnGroupSelected", GroupSelected)
			local status = AceConfigDialog:GetStatusTable(appName, path)
			if not status.groups then
				status.groups = {}
			end
			selectGroup:SetStatusTable(status.groups)
			local grouplist, orderlist = BuildSelect(group, options, path, appName)
			selectGroup:SetGroupList(grouplist, orderlist)
			selectGroup:SetUserData("grouplist", grouplist)
			selectGroup:SetUserData("orderlist", orderlist)

			local firstgroup = orderlist[1]
			if firstgroup then
				selectGroup:SetGroup((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or firstgroup)
			end

			selectGroup.width = "fill"
			selectGroup.height = "fill"

			container:AddChild(selectGroup)

		--assume tree group by default
		--if parenttype is tree then this group is already a node on that tree
		elseif (parenttype ~= "tree") or isRoot then
			local tree = gui:Create("TreeGroup")
			InjectInfo(tree, options, group, path, rootframe, appName)
			tree:EnableButtonTooltips(false)

			tree.width = "fill"
			tree.height = "fill"

			tree:SetCallback("OnGroupSelected", GroupSelected)
			tree:SetCallback("OnButtonEnter", TreeOnButtonEnter)
			tree:SetCallback("OnButtonLeave", TreeOnButtonLeave)

			local status = AceConfigDialog:GetStatusTable(appName, path)
			if not status.groups then
				status.groups = {}
			end
			local treedefinition = BuildGroups(group, options, path, appName, true)
			tree:SetStatusTable(status.groups)

			tree:SetTree(treedefinition)
			tree:SetUserData("tree",treedefinition)

			for i = 1, #treedefinition do
				local entry = treedefinition[i]
				if not entry.disabled then
					tree:SelectByValue((GroupExists(appName, options, path,status.groups.selected) and status.groups.selected) or entry.value)
					break
				end
			end

			container:AddChild(tree)
		end
	end
end

local old_CloseSpecialWindows


local function RefreshOnUpdate(this)
	for appName in pairs(this.closing) do
		if AceConfigDialog.OpenFrames[appName] then
			AceConfigDialog.OpenFrames[appName]:Hide()
		end
		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
				if not widget:IsVisible() then
					widget:ReleaseChildren()
				end
			end
		end
		this.closing[appName] = nil
	end

	if this.closeAll then
		for k, v in pairs(AceConfigDialog.OpenFrames) do
			if not this.closeAllOverride[k] then
				v:Hide()
			end
		end
		this.closeAll = nil
		wipe(this.closeAllOverride)
	end

	for appName in pairs(this.apps) do
		if AceConfigDialog.OpenFrames[appName] then
			local user = AceConfigDialog.OpenFrames[appName]:GetUserDataTable()
			AceConfigDialog:Open(appName, unpack(user.basepath or emptyTbl))
		end
		if AceConfigDialog.BlizOptions and AceConfigDialog.BlizOptions[appName] then
			for key, widget in pairs(AceConfigDialog.BlizOptions[appName]) do
				local user = widget:GetUserDataTable()
				if widget:IsVisible() then
					AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(user.basepath or emptyTbl))
				end
			end
		end
		this.apps[appName] = nil
	end
	this:SetScript("OnUpdate", nil)
end

-- Upgrade the OnUpdate script as well, if needed.
if AceConfigDialog.frame:GetScript("OnUpdate") then
	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
end

--- Close all open options windows
function AceConfigDialog:CloseAll()
	AceConfigDialog.frame.closeAll = true
	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
	if next(self.OpenFrames) then
		return true
	end
end

--- Close a specific options window.
-- @param appName The application name as given to `:RegisterOptionsTable()`
function AceConfigDialog:Close(appName)
	if self.OpenFrames[appName] then
		AceConfigDialog.frame.closing[appName] = true
		AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
		return true
	end
end

-- Internal -- Called by AceConfigRegistry
function AceConfigDialog:ConfigTableChanged(event, appName)
	AceConfigDialog.frame.apps[appName] = true
	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
end

reg.RegisterCallback(AceConfigDialog, "ConfigTableChange", "ConfigTableChanged")

--- Sets the default size of the options window for a specific application.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param width The default width
-- @param height The default height
function AceConfigDialog:SetDefaultSize(appName, width, height)
	local status = AceConfigDialog:GetStatusTable(appName)
	if type(width) == "number" and type(height) == "number" then
		status.width = width
		status.height = height
	end
end

--- Open an option window at the specified path (if any).
-- This function can optionally feed the group into a pre-created container
-- instead of creating a new container frame.
-- @paramsig appName [, container][, ...]
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param container An optional container frame to feed the options into
-- @param ... The path to open after creating the options window (see `:SelectGroup` for details)
function AceConfigDialog:Open(appName, container, ...)
	if not old_CloseSpecialWindows then
		old_CloseSpecialWindows = CloseSpecialWindows
		CloseSpecialWindows = function()
			local found = old_CloseSpecialWindows()
			return self:CloseAll() or found
		end
	end
	local app = reg:GetOptionsTable(appName)
	if not app then
		error(("%s isn't registed with AceConfigRegistry, unable to open config"):format(appName), 2)
	end
	local options = app("dialog", MAJOR)

	local f

	local path = new()
	local name = GetOptionsMemberValue("name", options, options, path, appName)

	--If an optional path is specified add it to the path table before feeding the options
	--as container is optional as well it may contain the first element of the path
	if type(container) == "string" then
		tinsert(path, container)
		container = nil
	end
	for n = 1, select("#",...) do
		tinsert(path, (select(n, ...)))
	end

	local option = options
	if type(container) == "table" and container.type == "BlizOptionsGroup" and #path > 0 then
		for i = 1, #path do
			option = options.args[path[i]]
		end
		name = format("%s - %s", name, GetOptionsMemberValue("name", option, options, path, appName))
	end

	--if a container is given feed into that
	if container then
		f = container
		f:ReleaseChildren()
		f:SetUserData("appName", appName)
		f:SetUserData("iscustom", true)
		if #path > 0 then
			f:SetUserData("basepath", copy(path))
		end
		local status = AceConfigDialog:GetStatusTable(appName)
		if not status.width then
			status.width =  700
		end
		if not status.height then
			status.height = 500
		end
		if f.SetStatusTable then
			f:SetStatusTable(status)
		end
		if f.SetTitle then
			f:SetTitle(name or "")
		end
	else
		if not self.OpenFrames[appName] then
			f = gui:Create("Frame")
			self.OpenFrames[appName] = f
		else
			f = self.OpenFrames[appName]
		end
		f:ReleaseChildren()
		f:SetCallback("OnClose", FrameOnClose)
		f:SetUserData("appName", appName)
		if #path > 0 then
			f:SetUserData("basepath", copy(path))
		end
		f:SetTitle(name or "")
		local status = AceConfigDialog:GetStatusTable(appName)
		f:SetStatusTable(status)
	end

	self:FeedGroup(appName,options,f,f,path,true)
	if f.Show then
		f:Show()
	end
	del(path)

	if AceConfigDialog.frame.closeAll then
		-- close all is set, but thats not good, since we're just opening here, so force it
		AceConfigDialog.frame.closeAllOverride[appName] = true
	end
end

-- convert pre-39 BlizOptions structure to the new format
if oldminor and oldminor < 39 and AceConfigDialog.BlizOptions then
	local old = AceConfigDialog.BlizOptions
	local newOpt = {}
	for key, widget in pairs(old) do
		local appName = widget:GetUserData("appName")
		if not newOpt[appName] then newOpt[appName] = {} end
		newOpt[appName][key] = widget
	end
	AceConfigDialog.BlizOptions = newOpt
else
	AceConfigDialog.BlizOptions = AceConfigDialog.BlizOptions or {}
end

local function FeedToBlizPanel(widget, event)
	local path = widget:GetUserData("path")
	AceConfigDialog:Open(widget:GetUserData("appName"), widget, unpack(path or emptyTbl))
end

local function ClearBlizPanel(widget, event)
	local appName = widget:GetUserData("appName")
	AceConfigDialog.frame.closing[appName] = true
	AceConfigDialog.frame:SetScript("OnUpdate", RefreshOnUpdate)
end

--- Add an option table into the Blizzard Interface Options panel.
-- You can optionally supply a descriptive name to use and a parent frame to use,
-- as well as a path in the options table.\\
-- If no name is specified, the appName will be used instead.
--
-- If you specify a proper `parent` (by name), the interface options will generate a
-- tree layout. Note that only one level of children is supported, so the parent always
-- has to be a head-level note.
--
-- This function returns a reference to the container frame registered with the Interface
-- Options. You can use this reference to open the options with the API function
-- `InterfaceOptionsFrame_OpenToCategory`.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param name A descriptive name to display in the options tree (defaults to appName)
-- @param parent The parent to use in the interface options tree.
-- @param ... The path in the options table to feed into the interface options panel.
-- @return The reference to the frame registered into the Interface Options.
-- @return The category ID to pass to Settings.OpenToCategory (or InterfaceOptionsFrame_OpenToCategory)
function AceConfigDialog:AddToBlizOptions(appName, name, parent, ...)
	local BlizOptions = AceConfigDialog.BlizOptions

	local key = appName
	for n = 1, select("#", ...) do
		key = key.."\001"..select(n, ...)
	end

	if not BlizOptions[appName] then
		BlizOptions[appName] = {}
	end

	if not BlizOptions[appName][key] then
		local group = gui:Create("BlizOptionsGroup")
		BlizOptions[appName][key] = group

		group:SetTitle(name or appName)
		group:SetUserData("appName", appName)
		if select("#", ...) > 0 then
			local path = {}
			for n = 1, select("#",...) do
				tinsert(path, (select(n, ...)))
			end
			group:SetUserData("path", path)
		end
		group:SetCallback("OnShow", FeedToBlizPanel)
		group:SetCallback("OnHide", ClearBlizPanel)
		if Settings and Settings.RegisterCanvasLayoutCategory then
			local categoryName = name or appName
			if parent then
				local category = Settings.GetCategory(parent)
				if not category then
					error(("The parent category '%s' was not found"):format(parent), 2)
				end
				local subcategory = Settings.RegisterCanvasLayoutSubcategory(category, group.frame, categoryName)

				-- force the generated ID to be used for subcategories, as these can have very simple names like "Profiles"
				group:SetName(subcategory.ID, parent)
			else
				local category = Settings.RegisterCanvasLayoutCategory(group.frame, categoryName)
				-- using appName here would be cleaner, but would not be 100% compatible
				-- but for top-level categories it should be fine, as these are typically addon names
				category.ID = categoryName
				group:SetName(categoryName, parent)
				Settings.RegisterAddOnCategory(category)
			end
		else
			group:SetName(name or appName, parent)
			InterfaceOptions_AddCategory(group.frame)
		end
		return group.frame, group.frame.name
	else
		error(("%s has already been added to the Blizzard Options Window with the given path"):format(appName), 2)
	end
end

=== END OF FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfigDialog-3.0/AceConfigDialog-3.0.lua ===


=== FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua ===
--- AceConfigRegistry-3.0 handles central registration of options tables in use by addons and modules.\\
-- Options tables can be registered as raw tables, OR as function refs that return a table.\\
-- Such functions receive three arguments: "uiType", "uiName", "appName". \\
-- * Valid **uiTypes**: "cmd", "dropdown", "dialog". This is verified by the library at call time. \\
-- * The **uiName** field is expected to contain the full name of the calling addon, including version, e.g. "FooBar-1.0". This is verified by the library at call time.\\
-- * The **appName** field is the options table name as given at registration time \\
--
-- :IterateOptionsTables() (and :GetOptionsTable() if only given one argument) return a function reference that the requesting config handling addon must call with valid "uiType", "uiName".
-- @class file
-- @name AceConfigRegistry-3.0
-- @release $Id: AceConfigRegistry-3.0.lua 1296 2022-11-04 18:50:10Z nevcairiel $
local CallbackHandler = LibStub("CallbackHandler-1.0")

local MAJOR, MINOR = "AceConfigRegistry-3.0", 21
local AceConfigRegistry = LibStub:NewLibrary(MAJOR, MINOR)

if not AceConfigRegistry then return end

AceConfigRegistry.tables = AceConfigRegistry.tables or {}

if not AceConfigRegistry.callbacks then
	AceConfigRegistry.callbacks = CallbackHandler:New(AceConfigRegistry)
end

-- Lua APIs
local tinsert, tconcat = table.insert, table.concat
local strfind, strmatch = string.find, string.match
local type, tostring, select, pairs = type, tostring, select, pairs
local error, assert = error, assert

-----------------------------------------------------------------------
-- Validating options table consistency:


AceConfigRegistry.validated = {
	-- list of options table names ran through :ValidateOptionsTable automatically.
	-- CLEARED ON PURPOSE, since newer versions may have newer validators
	cmd = {},
	dropdown = {},
	dialog = {},
}



local function err(msg, errlvl, ...)
	local t = {}
	for i=select("#",...),1,-1 do
		tinsert(t, (select(i, ...)))
	end
	error(MAJOR..":ValidateOptionsTable(): "..tconcat(t,".")..msg, errlvl+2)
end


local isstring={["string"]=true, _="string"}
local isstringfunc={["string"]=true,["function"]=true, _="string or funcref"}
local istable={["table"]=true,   _="table"}
local ismethodtable={["table"]=true,["string"]=true,["function"]=true,   _="methodname, funcref or table"}
local optstring={["nil"]=true,["string"]=true, _="string"}
local optstringfunc={["nil"]=true,["string"]=true,["function"]=true, _="string or funcref"}
local optstringnumberfunc={["nil"]=true,["string"]=true,["number"]=true,["function"]=true, _="string, number or funcref"}
local optnumber={["nil"]=true,["number"]=true, _="number"}
local optmethodfalse={["nil"]=true,["string"]=true,["function"]=true,["boolean"]={[false]=true},  _="methodname, funcref or false"}
local optmethodnumber={["nil"]=true,["string"]=true,["function"]=true,["number"]=true,  _="methodname, funcref or number"}
local optmethodtable={["nil"]=true,["string"]=true,["function"]=true,["table"]=true,  _="methodname, funcref or table"}
local optmethodbool={["nil"]=true,["string"]=true,["function"]=true,["boolean"]=true,  _="methodname, funcref or boolean"}
local opttable={["nil"]=true,["table"]=true,  _="table"}
local optbool={["nil"]=true,["boolean"]=true,  _="boolean"}
local optboolnumber={["nil"]=true,["boolean"]=true,["number"]=true,  _="boolean or number"}
local optstringnumber={["nil"]=true,["string"]=true,["number"]=true, _="string or number"}

local basekeys={
	type=isstring,
	name=isstringfunc,
	desc=optstringfunc,
	descStyle=optstring,
	order=optmethodnumber,
	validate=optmethodfalse,
	confirm=optmethodbool,
	confirmText=optstring,
	disabled=optmethodbool,
	hidden=optmethodbool,
		guiHidden=optmethodbool,
		dialogHidden=optmethodbool,
		dropdownHidden=optmethodbool,
	cmdHidden=optmethodbool,
	tooltipHyperlink=optstringfunc,
	icon=optstringnumberfunc,
	iconCoords=optmethodtable,
	handler=opttable,
	get=optmethodfalse,
	set=optmethodfalse,
	func=optmethodfalse,
	arg={["*"]=true},
	width=optstringnumber,
}

local typedkeys={
	header={
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	description={
		image=optstringnumberfunc,
		imageCoords=optmethodtable,
		imageHeight=optnumber,
		imageWidth=optnumber,
		fontSize=optstringfunc,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	group={
		args=istable,
		plugins=opttable,
		inline=optbool,
			cmdInline=optbool,
			guiInline=optbool,
			dropdownInline=optbool,
			dialogInline=optbool,
		childGroups=optstring,
	},
	execute={
		image=optstringnumberfunc,
		imageCoords=optmethodtable,
		imageHeight=optnumber,
		imageWidth=optnumber,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	input={
		pattern=optstring,
		usage=optstring,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
		multiline=optboolnumber,
	},
	toggle={
		tristate=optbool,
		image=optstringnumberfunc,
		imageCoords=optmethodtable,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	tristate={
	},
	range={
		min=optnumber,
		softMin=optnumber,
		max=optnumber,
		softMax=optnumber,
		step=optnumber,
		bigStep=optnumber,
		isPercent=optbool,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	select={
		values=ismethodtable,
		sorting=optmethodtable,
		style={
			["nil"]=true,
			["string"]={dropdown=true,radio=true},
			_="string: 'dropdown' or 'radio'"
		},
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
		itemControl=optstring,
	},
	multiselect={
		values=ismethodtable,
		style=optstring,
		tristate=optbool,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	color={
		hasAlpha=optmethodbool,
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
	keybinding={
		control=optstring,
		dialogControl=optstring,
		dropdownControl=optstring,
	},
}

local function validateKey(k,errlvl,...)
	errlvl=(errlvl or 0)+1
	if type(k)~="string" then
		err("["..tostring(k).."] - key is not a string", errlvl,...)
	end
	if strfind(k, "[%c\127]") then
		err("["..tostring(k).."] - key name contained control characters", errlvl,...)
	end
end

local function validateVal(v, oktypes, errlvl,...)
	errlvl=(errlvl or 0)+1
	local isok=oktypes[type(v)] or oktypes["*"]

	if not isok then
		err(": expected a "..oktypes._..", got '"..tostring(v).."'", errlvl,...)
	end
	if type(isok)=="table" then		-- isok was a table containing specific values to be tested for!
		if not isok[v] then
			err(": did not expect "..type(v).." value '"..tostring(v).."'", errlvl,...)
		end
	end
end

local function validate(options,errlvl,...)
	errlvl=(errlvl or 0)+1
	-- basic consistency
	if type(options)~="table" then
		err(": expected a table, got a "..type(options), errlvl,...)
	end
	if type(options.type)~="string" then
		err(".type: expected a string, got a "..type(options.type), errlvl,...)
	end

	-- get type and 'typedkeys' member
	local tk = typedkeys[options.type]
	if not tk then
		err(".type: unknown type '"..options.type.."'", errlvl,...)
	end

	-- make sure that all options[] are known parameters
	for k,v in pairs(options) do
		if not (tk[k] or basekeys[k]) then
			err(": unknown parameter", errlvl,tostring(k),...)
		end
	end

	-- verify that required params are there, and that everything is the right type
	for k,oktypes in pairs(basekeys) do
		validateVal(options[k], oktypes, errlvl,k,...)
	end
	for k,oktypes in pairs(tk) do
		validateVal(options[k], oktypes, errlvl,k,...)
	end

	-- extra logic for groups
	if options.type=="group" then
		for k,v in pairs(options.args) do
			validateKey(k,errlvl,"args",...)
			validate(v, errlvl,k,"args",...)
		end
		if options.plugins then
			for plugname,plugin in pairs(options.plugins) do
				if type(plugin)~="table" then
					err(": expected a table, got '"..tostring(plugin).."'", errlvl,tostring(plugname),"plugins",...)
				end
				for k,v in pairs(plugin) do
					validateKey(k,errlvl,tostring(plugname),"plugins",...)
					validate(v, errlvl,k,tostring(plugname),"plugins",...)
				end
			end
		end
	end
end


--- Validates basic structure and integrity of an options table \\
-- Does NOT verify that get/set etc actually exist, since they can be defined at any depth
-- @param options The table to be validated
-- @param name The name of the table to be validated (shown in any error message)
-- @param errlvl (optional number) error level offset, default 0 (=errors point to the function calling :ValidateOptionsTable)
function AceConfigRegistry:ValidateOptionsTable(options,name,errlvl)
	errlvl=(errlvl or 0)+1
	name = name or "Optionstable"
	if not options.name then
		options.name=name	-- bit of a hack, the root level doesn't really need a .name :-/
	end
	validate(options,errlvl,name)
end

--- Fires a "ConfigTableChange" callback for those listening in on it, allowing config GUIs to refresh.
-- You should call this function if your options table changed from any outside event, like a game event
-- or a timer.
-- @param appName The application name as given to `:RegisterOptionsTable()`
function AceConfigRegistry:NotifyChange(appName)
	if not AceConfigRegistry.tables[appName] then return end
	AceConfigRegistry.callbacks:Fire("ConfigTableChange", appName)
end

-- -------------------------------------------------------------------
-- Registering and retreiving options tables:


-- validateGetterArgs: helper function for :GetOptionsTable (or, rather, the getter functions returned by it)

local function validateGetterArgs(uiType, uiName, errlvl)
	errlvl=(errlvl or 0)+2
	if uiType~="cmd" and uiType~="dropdown" and uiType~="dialog" then
		error(MAJOR..": Requesting options table: 'uiType' - invalid configuration UI type, expected 'cmd', 'dropdown' or 'dialog'", errlvl)
	end
	if not strmatch(uiName, "[A-Za-z]%-[0-9]") then	-- Expecting e.g. "MyLib-1.2"
		error(MAJOR..": Requesting options table: 'uiName' - badly formatted or missing version number. Expected e.g. 'MyLib-1.2'", errlvl)
	end
end

--- Register an options table with the config registry.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param options The options table, OR a function reference that generates it on demand. \\
-- See the top of the page for info on arguments passed to such functions.
-- @param skipValidation Skip options table validation (primarily useful for extremely huge options, with a noticeable slowdown)
function AceConfigRegistry:RegisterOptionsTable(appName, options, skipValidation)
	if type(options)=="table" then
		if options.type~="group" then	-- quick sanity checker
			error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - missing type='group' member in root group", 2)
		end
		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
			errlvl=(errlvl or 0)+1
			validateGetterArgs(uiType, uiName, errlvl)
			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
				AceConfigRegistry:ValidateOptionsTable(options, appName, errlvl)	-- upgradable
				AceConfigRegistry.validated[uiType][appName] = true
			end
			return options
		end
	elseif type(options)=="function" then
		AceConfigRegistry.tables[appName] = function(uiType, uiName, errlvl)
			errlvl=(errlvl or 0)+1
			validateGetterArgs(uiType, uiName, errlvl)
			local tab = assert(options(uiType, uiName, appName))
			if not AceConfigRegistry.validated[uiType][appName] and not skipValidation then
				AceConfigRegistry:ValidateOptionsTable(tab, appName, errlvl)	-- upgradable
				AceConfigRegistry.validated[uiType][appName] = true
			end
			return tab
		end
	else
		error(MAJOR..": RegisterOptionsTable(appName, options): 'options' - expected table or function reference", 2)
	end
end

--- Returns an iterator of ["appName"]=funcref pairs
function AceConfigRegistry:IterateOptionsTables()
	return pairs(AceConfigRegistry.tables)
end




--- Query the registry for a specific options table.
-- If only appName is given, a function is returned which you
-- can call with (uiType,uiName) to get the table.\\
-- If uiType&uiName are given, the table is returned.
-- @param appName The application name as given to `:RegisterOptionsTable()`
-- @param uiType The type of UI to get the table for, one of "cmd", "dropdown", "dialog"
-- @param uiName The name of the library/addon querying for the table, e.g. "MyLib-1.0"
function AceConfigRegistry:GetOptionsTable(appName, uiType, uiName)
	local f = AceConfigRegistry.tables[appName]
	if not f then
		return nil
	end

	if uiType then
		return f(uiType,uiName,1)	-- get the table for us
	else
		return f	-- return the function
	end
end

=== END OF FILE: WeakAurasOptions/Libs/AceConfig-3.0/AceConfigRegistry-3.0/AceConfigRegistry-3.0.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/BackgroundWidget.lua ===
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

do
	local widgetType = "LSM30_Background"
	local widgetVersion = 13

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(this, button)
		local self = this.obj
		self:Fire("OnValueChanged", this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function ContentOnEnter(this, button)
		local self = this.obj
		local text = this.text:GetText()
		local background = self.list[text] ~= text and self.list[text] or Media:Fetch('background',text)
		self.dropdown.bgTex:SetTexture(background)
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent, BackdropTemplateMixin and "BackdropTemplate")
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
				frame:SetScript("OnEnter", ContentOnEnter)

			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check

			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")
				local font, size = text:GetFont()
				text:SetFont(font,size,"OUTLINE")

				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text

			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("background")
	end


	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local background = self.list[text] ~= text and self.list[text] or Media:Fetch('background',text)

		self.frame.displayButton:SetBackdrop({bgFile = background,
			edgeFile = "Interface/Tooltips/UI-Tooltip-Border",
			edgeSize = 16,
			insets = { left = 4, right = 4, top = 4, bottom = 4 }})
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.frame.displayButton:SetBackdropColor(.2,.2,.2,1)
		else
			self.frame:Enable()
			self.frame.displayButton:SetBackdropColor(1,1,1,1)
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	local sortedlist = {}
	local function ToggleDrop(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			for k, v in pairs(self.list) do
				sortedlist[#sortedlist+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				--print(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				f.dropdown = self.dropdown
				self.dropdown:AddFrame(f)
			end
			wipe(sortedlist)
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter(this)
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave(this)
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrameWithWindow()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/BackgroundWidget.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/BorderWidget.lua ===
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

do
	local widgetType = "LSM30_Border"
	local widgetVersion = 13

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(this, button)
		local self = this.obj
		self:Fire("OnValueChanged", this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function ContentOnEnter(this, button)
		local self = this.obj
		local text = this.text:GetText()
		local border = self.list[text] ~= text and self.list[text] or Media:Fetch('border',text)
		this.dropdown:SetBackdrop({edgeFile = border,
			bgFile=[[Interface\DialogFrame\UI-DialogBox-Background-Dark]],
			tile = true, tileSize = 16, edgeSize = 16,
			insets = { left = 4, right = 4, top = 4, bottom = 4 }})
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
				frame:SetScript("OnEnter", ContentOnEnter)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check
			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")
				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("border")
	end


	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local border = self.list[text] ~= text and self.list[text] or Media:Fetch('border',text)

		self.frame.displayButton:SetBackdrop({edgeFile = border,
			bgFile=[[Interface\DialogFrame\UI-DialogBox-Background-Dark]],
			tile = true, tileSize = 16, edgeSize = 16,
			insets = { left = 4, right = 4, top = 4, bottom = 4 }})
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	local sortedlist = {}
	local function ToggleDrop(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			for k, v in pairs(self.list) do
				sortedlist[#sortedlist+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				--print(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				f.dropdown = self.dropdown
				self.dropdown:AddFrame(f)
			end
			wipe(sortedlist)
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter(this)
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave(this)
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrameWithWindow()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/BorderWidget.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/FontWidget.lua ===
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

do
	local widgetType = "LSM30_Font"
	local widgetVersion = 13

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(this, button)
		local self = this.obj
		self:Fire("OnValueChanged", this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check
			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")
				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("font")
	end

	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local font = self.list[text] ~= text and self.list[text] or Media:Fetch('font',text)
		local _, size, outline= self.frame.text:GetFont()
		self.frame.text:SetFont(font,size,outline)
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	local sortedlist = {}
	local function ToggleDrop(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			for k, v in pairs(self.list) do
				sortedlist[#sortedlist+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				local _, size, outline= f.text:GetFont()
				local font = self.list[k] ~= k and self.list[k] or Media:Fetch('font',k)
				f.text:SetFont(font,size,outline)
				f.text:SetText(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				self.dropdown:AddFrame(f)
			end
			wipe(sortedlist)
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter(this)
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave(this)
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrame()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/FontWidget.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/SoundWidget.lua ===
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

do
	local widgetType = "LSM30_Sound"
	local widgetVersion = 13

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(this, button)
		local self = this.obj
		self:Fire("OnValueChanged", this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function ContentSpeakerOnClick(this, button)
		local self = this.frame.obj
		local sound = this.frame.text:GetText()
		PlaySoundFile(self.list[sound] ~= sound and self.list[sound] or Media:Fetch('sound',sound), "Master")
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check

			local soundbutton = CreateFrame("Button", nil, frame)
				soundbutton:SetWidth(16)
				soundbutton:SetHeight(16)
				soundbutton:SetPoint("RIGHT",frame,"RIGHT",-1,0)
				soundbutton.frame = frame
				soundbutton:SetScript("OnClick", ContentSpeakerOnClick)
			frame.soundbutton = soundbutton

			local speaker = soundbutton:CreateTexture(nil, "BACKGROUND")
				speaker:SetTexture("Interface\\Common\\VoiceChat-Speaker")
				speaker:SetAllPoints(soundbutton)
			frame.speaker = speaker
			local speakeron = soundbutton:CreateTexture(nil, "HIGHLIGHT")
				speakeron:SetTexture("Interface\\Common\\VoiceChat-On")
				speakeron:SetAllPoints(soundbutton)
			frame.speakeron = speakeron

			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")
				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 1, 0)
				text:SetPoint("BOTTOMRIGHT", soundbutton, "BOTTOMLEFT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("sound")
	end

	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.speaker:SetDesaturated(true)
			self.speakeron:SetDesaturated(true)
		else
			self.frame:Enable()
			self.speaker:SetDesaturated(false)
			self.speakeron:SetDesaturated(false)
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	local sortedlist = {}
	local function ToggleDrop(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			for k, v in pairs(self.list) do
				sortedlist[#sortedlist+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				if k == self.value then
					f.check:Show()
				end
				f.obj = self
				self.dropdown:AddFrame(f)
			end
			wipe(sortedlist)
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter(this)
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave(this)
		this.obj:Fire("OnLeave")
	end

	local function WidgetPlaySound(this)
		local self = this.obj
		local sound = self.frame.text:GetText()
		PlaySoundFile(self.list[sound] ~= sound and self.list[sound] or Media:Fetch('sound',sound), "Master")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrame()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)


		local soundbutton = CreateFrame("Button", nil, frame)
			soundbutton:SetWidth(16)
			soundbutton:SetHeight(16)
			soundbutton:SetPoint("LEFT",frame.DLeft,"LEFT",26,1)
			soundbutton:SetScript("OnClick", WidgetPlaySound)
			soundbutton.obj = self
		self.soundbutton = soundbutton
		frame.text:SetPoint("LEFT",soundbutton,"RIGHT",2,0)


		local speaker = soundbutton:CreateTexture(nil, "BACKGROUND")
			speaker:SetTexture("Interface\\Common\\VoiceChat-Speaker")
			speaker:SetAllPoints(soundbutton)
		self.speaker = speaker
		local speakeron = soundbutton:CreateTexture(nil, "HIGHLIGHT")
			speakeron:SetTexture("Interface\\Common\\VoiceChat-On")
			speakeron:SetAllPoints(soundbutton)
		self.speakeron = speakeron

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/SoundWidget.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/StatusbarWidget.lua ===
-- Widget is based on the AceGUIWidget-DropDown.lua supplied with AceGUI-3.0
-- Widget created by Yssaril

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

local AGSMW = LibStub("AceGUISharedMediaWidgets-1.0")

do
	local widgetType = "LSM30_Statusbar"
	local widgetVersion = 13

	local contentFrameCache = {}
	local function ReturnSelf(self)
		self:ClearAllPoints()
		self:Hide()
		self.check:Hide()
		table.insert(contentFrameCache, self)
	end

	local function ContentOnClick(this, button)
		local self = this.obj
		self:Fire("OnValueChanged", this.text:GetText())
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function GetContentLine()
		local frame
		if next(contentFrameCache) then
			frame = table.remove(contentFrameCache)
		else
			frame = CreateFrame("Button", nil, UIParent)
				--frame:SetWidth(200)
				frame:SetHeight(18)
				frame:SetHighlightTexture([[Interface\QuestFrame\UI-QuestTitleHighlight]], "ADD")
				frame:SetScript("OnClick", ContentOnClick)
			local check = frame:CreateTexture("OVERLAY")
				check:SetWidth(16)
				check:SetHeight(16)
				check:SetPoint("LEFT",frame,"LEFT",1,-1)
				check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
				check:Hide()
			frame.check = check
			local bar = frame:CreateTexture("ARTWORK")
				bar:SetHeight(16)
				bar:SetPoint("LEFT",check,"RIGHT",1,0)
				bar:SetPoint("RIGHT",frame,"RIGHT",-1,0)
			frame.bar = bar
			local text = frame:CreateFontString(nil,"OVERLAY","GameFontWhite")

				local font, size = text:GetFont()
				text:SetFont(font,size,"OUTLINE")

				text:SetPoint("TOPLEFT", check, "TOPRIGHT", 3, 0)
				text:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -2, 0)
				text:SetJustifyH("LEFT")
				text:SetText("Test Test Test Test Test Test Test")
			frame.text = text
			frame.ReturnSelf = ReturnSelf
		end
		frame:Show()
		return frame
	end

	local function OnAcquire(self)
		self:SetHeight(44)
		self:SetWidth(200)
	end

	local function OnRelease(self)
		self:SetText("")
		self:SetLabel("")
		self:SetDisabled(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	local function SetValue(self, value) -- Set the value to an item in the List.
		if self.list then
			self:SetText(value or "")
		end
		self.value = value
	end

	local function GetValue(self)
		return self.value
	end

	local function SetList(self, list) -- Set the list of values for the dropdown (key => value pairs)
		self.list = list or Media:HashTable("statusbar")
	end


	local function SetText(self, text) -- Set the text displayed in the box.
		self.frame.text:SetText(text or "")
		local statusbar = self.list[text] ~= text and self.list[text] or Media:Fetch('statusbar',text)
		self.bar:SetTexture(statusbar)
	end

	local function SetLabel(self, text) -- Set the text for the label.
		self.frame.label:SetText(text or "")
	end

	local function AddItem(self, key, value) -- Add an item to the list.
		self.list = self.list or {}
		self.list[key] = value
	end
	local SetItemValue = AddItem -- Set the value of a item in the list. <<same as adding a new item>>

	local function SetMultiselect(self, flag) end -- Toggle multi-selecting. <<Dummy function to stay inline with the dropdown API>>
	local function GetMultiselect() return false end-- Query the multi-select flag. <<Dummy function to stay inline with the dropdown API>>
	local function SetItemDisabled(self, key) end-- Disable one item in the list. <<Dummy function to stay inline with the dropdown API>>

	local function SetDisabled(self, disabled) -- Disable the widget.
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end

	local function textSort(a,b)
		return string.upper(a) < string.upper(b)
	end

	local sortedlist = {}
	local function ToggleDrop(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
			AceGUI:ClearFocus()
		else
			AceGUI:SetFocus(self)
			self.dropdown = AGSMW:GetDropDownFrame()
			local width = self.frame:GetWidth()
			self.dropdown:SetPoint("TOPLEFT", self.frame, "BOTTOMLEFT")
			self.dropdown:SetPoint("TOPRIGHT", self.frame, "BOTTOMRIGHT", width < 160 and (160 - width) or 0, 0)
			for k, v in pairs(self.list) do
				sortedlist[#sortedlist+1] = k
			end
			table.sort(sortedlist, textSort)
			for i, k in ipairs(sortedlist) do
				local f = GetContentLine()
				f.text:SetText(k)
				--print(k)
				if k == self.value then
					f.check:Show()
				end

				local statusbar = self.list[k] ~= k and self.list[k] or Media:Fetch('statusbar',k)
				f.bar:SetTexture(statusbar)
				f.obj = self
				f.dropdown = self.dropdown
				self.dropdown:AddFrame(f)
			end
			wipe(sortedlist)
		end
	end

	local function ClearFocus(self)
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function OnHide(this)
		local self = this.obj
		if self.dropdown then
			self.dropdown = AGSMW:ReturnDropDownFrame(self.dropdown)
		end
	end

	local function Drop_OnEnter(this)
		this.obj:Fire("OnEnter")
	end

	local function Drop_OnLeave(this)
		this.obj:Fire("OnLeave")
	end

	local function Constructor()
		local frame = AGSMW:GetBaseFrame()
		local self = {}

		self.type = widgetType
		self.frame = frame
		frame.obj = self
		frame.dropButton.obj = self
		frame.dropButton:SetScript("OnEnter", Drop_OnEnter)
		frame.dropButton:SetScript("OnLeave", Drop_OnLeave)
		frame.dropButton:SetScript("OnClick",ToggleDrop)
		frame:SetScript("OnHide", OnHide)

		local bar = frame:CreateTexture(nil, "OVERLAY")
			bar:SetPoint("TOPLEFT", frame,"TOPLEFT",6,-25)
			bar:SetPoint("BOTTOMRIGHT", frame,"BOTTOMRIGHT", -21, 5)
			bar:SetAlpha(0.5)
		self.bar = bar

		self.alignoffset = 31

		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.ClearFocus = ClearFocus
		self.SetText = SetText
		self.SetValue = SetValue
		self.GetValue = GetValue
		self.SetList = SetList
		self.SetLabel = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.ToggleDrop = ToggleDrop

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)

end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/StatusbarWidget.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/prototypes.lua ===
-- Widget created by Yssaril
local DataVersion = 9004
local AGSMW = LibStub:NewLibrary("AceGUISharedMediaWidgets-1.0", DataVersion)

if not AGSMW then
  return	-- already loaded and no upgrade necessary
end

local AceGUI = LibStub("AceGUI-3.0")
local Media = LibStub("LibSharedMedia-3.0")

AGSMW = AGSMW or {}

AceGUIWidgetLSMlists = {
	['font'] = Media:HashTable("font"),
	['sound'] = Media:HashTable("sound"),
	['statusbar'] = Media:HashTable("statusbar"),
	['border'] = Media:HashTable("border"),
	['background'] = Media:HashTable("background"),
}

do
	local function disable(frame)
		frame.label:SetTextColor(.5,.5,.5)
		frame.text:SetTextColor(.5,.5,.5)
		frame.dropButton:Disable()
		if frame.displayButtonFont then
			frame.displayButtonFont:SetTextColor(.5,.5,.5)
			frame.displayButton:Disable()
		end
	end

	local function enable(frame)
		frame.label:SetTextColor(1,.82,0)
		frame.text:SetTextColor(1,1,1)
		frame.dropButton:Enable()
		if frame.displayButtonFont then
			frame.displayButtonFont:SetTextColor(1,1,1)
			frame.displayButton:Enable()
		end
	end

	local displayButtonBackdrop = {
		edgeFile = "Interface/Tooltips/UI-Tooltip-Border",
		tile = true, tileSize = 16, edgeSize = 16,
		insets = { left = 4, right = 4, top = 4, bottom = 4 },
	}

	-- create or retrieve BaseFrame
	function AGSMW:GetBaseFrame()
		local frame = CreateFrame("Frame", nil, UIParent)
		frame:SetHeight(44)
		frame:SetWidth(200)

		local label = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
			label:SetPoint("TOPLEFT",frame,"TOPLEFT",0,0)
			label:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
			label:SetJustifyH("LEFT")
			label:SetHeight(18)
			label:SetText("")
		frame.label = label

		local DLeft = frame:CreateTexture(nil, "ARTWORK")
			DLeft:SetWidth(25)
			DLeft:SetHeight(64)
			DLeft:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT", -17, -21)
			DLeft:SetTexture([[Interface\Glues\CharacterCreate\CharacterCreate-LabelFrame]])
			DLeft:SetTexCoord(0, 0.1953125, 0, 1)
		frame.DLeft = DLeft

		local DRight = frame:CreateTexture(nil, "ARTWORK")
			DRight:SetWidth(25)
			DRight:SetHeight(64)
			DRight:SetPoint("TOP", DLeft, "TOP")
			DRight:SetPoint("RIGHT", frame, "RIGHT", 17, 0)
			DRight:SetTexture([[Interface\Glues\CharacterCreate\CharacterCreate-LabelFrame]])
			DRight:SetTexCoord(0.8046875, 1, 0, 1)
		frame.DRight = DRight

		local DMiddle = frame:CreateTexture(nil, "ARTWORK")
			DMiddle:SetHeight(64)
			DMiddle:SetPoint("TOP", DLeft, "TOP")
			DMiddle:SetPoint("LEFT", DLeft, "RIGHT")
			DMiddle:SetPoint("RIGHT", DRight, "LEFT")
			DMiddle:SetTexture([[Interface\Glues\CharacterCreate\CharacterCreate-LabelFrame]])
			DMiddle:SetTexCoord(0.1953125, 0.8046875, 0, 1)
		frame.DMiddle = DMiddle

		local text = frame:CreateFontString(nil,"OVERLAY","GameFontHighlightSmall")
			text:SetPoint("RIGHT",DRight,"RIGHT",-43,1)
			text:SetPoint("LEFT",DLeft,"LEFT",26,1)
			text:SetJustifyH("RIGHT")
			text:SetHeight(18)
			text:SetText("")
		frame.text = text

		local dropButton = CreateFrame("Button", nil, frame)
			dropButton:SetWidth(24)
			dropButton:SetHeight(24)
			dropButton:SetPoint("TOPRIGHT", DRight, "TOPRIGHT", -16, -18)
			dropButton:SetNormalTexture([[Interface\ChatFrame\UI-ChatIcon-ScrollDown-Up]])
			dropButton:SetPushedTexture([[Interface\ChatFrame\UI-ChatIcon-ScrollDown-Down]])
			dropButton:SetDisabledTexture([[Interface\ChatFrame\UI-ChatIcon-ScrollDown-Disabled]])
			dropButton:SetHighlightTexture([[Interface\Buttons\UI-Common-MouseHilight]], "ADD")
		frame.dropButton = dropButton

		frame.Disable = disable
		frame.Enable = enable
		return frame
	end

	function AGSMW:GetBaseFrameWithWindow()
		local frame = self:GetBaseFrame()

		local displayButton = CreateFrame("Button", nil, frame, BackdropTemplateMixin and "BackdropTemplate")
			displayButton:SetHeight(42)
			displayButton:SetWidth(42)
			displayButton:SetPoint("TOPLEFT", frame, "TOPLEFT", 1, -2)
			displayButton:SetBackdrop(displayButtonBackdrop)
			displayButton:SetBackdropBorderColor(.5, .5, .5)
		frame.displayButton = displayButton

		frame.label:SetPoint("TOPLEFT",displayButton,"TOPRIGHT",1,2)

		frame.DLeft:SetPoint("BOTTOMLEFT", displayButton, "BOTTOMRIGHT", -17, -20)

		return frame
	end

end

do

	local sliderBackdrop = {
		["bgFile"] = [[Interface\Buttons\UI-SliderBar-Background]],
		["edgeFile"] = [[Interface\Buttons\UI-SliderBar-Border]],
		["tile"] = true,
		["edgeSize"] = 8,
		["tileSize"] = 8,
		["insets"] = {
			["left"] = 3,
			["right"] = 3,
			["top"] = 3,
			["bottom"] = 3,
		},
	}
	local frameBackdrop = {
		bgFile=[[Interface\DialogFrame\UI-DialogBox-Background-Dark]],
		edgeFile = [[Interface\DialogFrame\UI-DialogBox-Border]],
		tile = true, tileSize = 32, edgeSize = 32,
		insets = { left = 11, right = 12, top = 12, bottom = 9 },
	}

	local function OnMouseWheel(self, dir)
		self.slider:SetValue(self.slider:GetValue()+(15*dir*-1))
	end

	local function AddFrame(self, frame)
		frame:SetParent(self.contentframe)
		frame:SetFrameStrata(self:GetFrameStrata())
		frame:SetFrameLevel(self:GetFrameLevel() + 100)

		if next(self.contentRepo) then
			frame:SetPoint("TOPLEFT", self.contentRepo[#self.contentRepo], "BOTTOMLEFT", 0, 0)
			frame:SetPoint("RIGHT", self.contentframe, "RIGHT", 0, 0)
			self.contentframe:SetHeight(self.contentframe:GetHeight() + frame:GetHeight())
			self.contentRepo[#self.contentRepo+1] = frame
		else
			self.contentframe:SetHeight(frame:GetHeight())
			frame:SetPoint("TOPLEFT", self.contentframe, "TOPLEFT", 0, 0)
			frame:SetPoint("RIGHT", self.contentframe, "RIGHT", 0, 0)
			self.contentRepo[1] = frame
		end

		if self.contentframe:GetHeight() > UIParent:GetHeight()*2/5 - 20 then
			self.scrollframe:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -28, 12)
			self:SetHeight(UIParent:GetHeight()*2/5)
			self.slider:Show()
			self:SetScript("OnMouseWheel", OnMouseWheel)
			self.slider:SetMinMaxValues(0, self.contentframe:GetHeight()-self.scrollframe:GetHeight())
		else
			self.scrollframe:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -14, 12)
			self:SetHeight(self.contentframe:GetHeight()+25)
			self.slider:Hide()
			self:SetScript("OnMouseWheel", nil)
			self.slider:SetMinMaxValues(0, 0)
		end
		self.contentframe:SetWidth(self.scrollframe:GetWidth())
	end

	local function ClearFrames(self)
		for i, frame in ipairs(self.contentRepo) do
			frame:ReturnSelf()
			self.contentRepo[i] = nil
		end
	end

	local function slider_OnValueChanged(self, value)
		self.frame.scrollframe:SetVerticalScroll(value)
	end

	local DropDownCache = {}
	function AGSMW:GetDropDownFrame()
		local frame
		if next(DropDownCache) then
			frame = table.remove(DropDownCache)
		else
			frame = CreateFrame("Frame", nil, UIParent, BackdropTemplateMixin and "BackdropTemplate")
				frame:SetClampedToScreen(true)
				frame:SetWidth(188)
				frame:SetBackdrop(frameBackdrop)
				frame:SetFrameStrata("TOOLTIP")
				frame:EnableMouseWheel(true)

			local contentframe = CreateFrame("Frame", nil, frame)
				contentframe:SetWidth(160)
				contentframe:SetHeight(0)
			frame.contentframe = contentframe

			local scrollframe = CreateFrame("ScrollFrame", nil, frame)
				scrollframe:SetWidth(160)
				scrollframe:SetPoint("TOPLEFT", frame, "TOPLEFT", 14, -13)
				scrollframe:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -14, 12)
				scrollframe:SetScrollChild(contentframe)
			frame.scrollframe = scrollframe

			contentframe:SetPoint("TOPLEFT", scrollframe)
			contentframe:SetPoint("TOPRIGHT", scrollframe)

			local bgTex = frame:CreateTexture(nil, "ARTWORK")
				bgTex:SetAllPoints(scrollframe)
			frame.bgTex = bgTex

			frame.AddFrame = AddFrame
			frame.ClearFrames = ClearFrames
			frame.contentRepo = {} -- store all our frames in here so we can get rid of them later

			local slider = CreateFrame("Slider", nil, scrollframe, BackdropTemplateMixin and "BackdropTemplate")
				slider:SetOrientation("VERTICAL")
				slider:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -14, -10)
				slider:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -14, 10)
				slider:SetBackdrop(sliderBackdrop)
				slider:SetThumbTexture([[Interface\Buttons\UI-SliderBar-Button-Vertical]])
				slider:SetMinMaxValues(0, 1)
				--slider:SetValueStep(1)
				slider:SetWidth(12)
				slider.frame = frame
				slider:SetScript("OnValueChanged", slider_OnValueChanged)
			frame.slider = slider
		end
		frame:SetHeight(UIParent:GetHeight()*2/5)
		frame.slider:SetValue(0)
		frame:Show()
		return frame
	end

	function AGSMW:ReturnDropDownFrame(frame)
		ClearFrames(frame)
		frame:ClearAllPoints()
		frame:Hide()
		frame:SetBackdrop(frameBackdrop)
		frame.bgTex:SetTexture(nil)
		table.insert(DropDownCache, frame)
		return nil
	end
end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0-SharedMediaWidgets/prototypes.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/AceGUI-3.0.lua ===
--- **AceGUI-3.0** provides access to numerous widgets which can be used to create GUIs.
-- AceGUI is used by AceConfigDialog to create the option GUIs, but you can use it by itself
-- to create any custom GUI. There are more extensive examples in the test suite in the Ace3
-- stand-alone distribution.
--
-- **Note**: When using AceGUI-3.0 directly, please do not modify the frames of the widgets directly,
-- as any "unknown" change to the widgets will cause addons that get your widget out of the widget pool
-- to misbehave. If you think some part of a widget should be modifiable, please open a ticket, and we"ll
-- implement a proper API to modify it.
-- @usage
-- local AceGUI = LibStub("AceGUI-3.0")
-- -- Create a container frame
-- local f = AceGUI:Create("Frame")
-- f:SetCallback("OnClose",function(widget) AceGUI:Release(widget) end)
-- f:SetTitle("AceGUI-3.0 Example")
-- f:SetStatusText("Status Bar")
-- f:SetLayout("Flow")
-- -- Create a button
-- local btn = AceGUI:Create("Button")
-- btn:SetWidth(170)
-- btn:SetText("Button !")
-- btn:SetCallback("OnClick", function() print("Click!") end)
-- -- Add the button to the container
-- f:AddChild(btn)
-- @class file
-- @name AceGUI-3.0
-- @release $Id: AceGUI-3.0.lua 1288 2022-09-25 14:19:00Z funkehdude $
local ACEGUI_MAJOR, ACEGUI_MINOR = "AceGUI-3.0", 41
local AceGUI, oldminor = LibStub:NewLibrary(ACEGUI_MAJOR, ACEGUI_MINOR)

if not AceGUI then return end -- No upgrade needed

-- Lua APIs
local tinsert, wipe = table.insert, table.wipe
local select, pairs, next, type = select, pairs, next, type
local error, assert = error, assert
local setmetatable, rawget = setmetatable, rawget
local math_max, math_min, math_ceil = math.max, math.min, math.ceil

-- WoW APIs
local UIParent = UIParent

AceGUI.WidgetRegistry = AceGUI.WidgetRegistry or {}
AceGUI.LayoutRegistry = AceGUI.LayoutRegistry or {}
AceGUI.WidgetBase = AceGUI.WidgetBase or {}
AceGUI.WidgetContainerBase = AceGUI.WidgetContainerBase or {}
AceGUI.WidgetVersions = AceGUI.WidgetVersions or {}
AceGUI.tooltip = AceGUI.tooltip or CreateFrame("GameTooltip", "AceGUITooltip", UIParent, "GameTooltipTemplate")

-- local upvalues
local WidgetRegistry = AceGUI.WidgetRegistry
local LayoutRegistry = AceGUI.LayoutRegistry
local WidgetVersions = AceGUI.WidgetVersions

--[[
	 xpcall safecall implementation
]]
local xpcall = xpcall

local function errorhandler(err)
	return geterrorhandler()(err)
end

local function safecall(func, ...)
	if func then
		return xpcall(func, errorhandler, ...)
	end
end

-- Recycling functions
local newWidget, delWidget
do
	-- Version Upgrade in Minor 29
	-- Internal Storage of the objects changed, from an array table
	-- to a hash table, and additionally we introduced versioning on
	-- the widgets which would discard all widgets from a pre-29 version
	-- anyway, so we just clear the storage now, and don't try to
	-- convert the storage tables to the new format.
	-- This should generally not cause *many* widgets to end up in trash,
	-- since once dialogs are opened, all addons should be loaded already
	-- and AceGUI should be on the latest version available on the users
	-- setup.
	-- -- nevcairiel - Nov 2nd, 2009
	if oldminor and oldminor < 29 and AceGUI.objPools then
		AceGUI.objPools = nil
	end

	AceGUI.objPools = AceGUI.objPools or {}
	local objPools = AceGUI.objPools
	--Returns a new instance, if none are available either returns a new table or calls the given contructor
	function newWidget(widgetType)
		if not WidgetRegistry[widgetType] then
			error("Attempt to instantiate unknown widget type", 2)
		end

		if not objPools[widgetType] then
			objPools[widgetType] = {}
		end

		local newObj = next(objPools[widgetType])
		if not newObj then
			newObj = WidgetRegistry[widgetType]()
			newObj.AceGUIWidgetVersion = WidgetVersions[widgetType]
		else
			objPools[widgetType][newObj] = nil
			-- if the widget is older then the latest, don't even try to reuse it
			-- just forget about it, and grab a new one.
			if not newObj.AceGUIWidgetVersion or newObj.AceGUIWidgetVersion < WidgetVersions[widgetType] then
				return newWidget(widgetType)
			end
		end
		return newObj
	end
	-- Releases an instance to the Pool
	function delWidget(obj,widgetType)
		if not objPools[widgetType] then
			objPools[widgetType] = {}
		end
		if objPools[widgetType][obj] then
			error("Attempt to Release Widget that is already released", 2)
		end
		objPools[widgetType][obj] = true
	end
end


-------------------
-- API Functions --
-------------------

-- Gets a widget Object

--- Create a new Widget of the given type.
-- This function will instantiate a new widget (or use one from the widget pool), and call the
-- OnAcquire function on it, before returning.
-- @param type The type of the widget.
-- @return The newly created widget.
function AceGUI:Create(widgetType)
	if WidgetRegistry[widgetType] then
		local widget = newWidget(widgetType)

		if rawget(widget, "Acquire") then
			widget.OnAcquire = widget.Acquire
			widget.Acquire = nil
		elseif rawget(widget, "Aquire") then
			widget.OnAcquire = widget.Aquire
			widget.Aquire = nil
		end

		if rawget(widget, "Release") then
			widget.OnRelease = rawget(widget, "Release")
			widget.Release = nil
		end

		if widget.OnAcquire then
			widget:OnAcquire()
		else
			error(("Widget type %s doesn't supply an OnAcquire Function"):format(widgetType))
		end
		-- Set the default Layout ("List")
		safecall(widget.SetLayout, widget, "List")
		safecall(widget.ResumeLayout, widget)
		return widget
	end
end

--- Releases a widget Object.
-- This function calls OnRelease on the widget and places it back in the widget pool.
-- Any data on the widget is being erased, and the widget will be hidden.\\
-- If this widget is a Container-Widget, all of its Child-Widgets will be releases as well.
-- @param widget The widget to release
function AceGUI:Release(widget)
	if widget.isQueuedForRelease then return end
	widget.isQueuedForRelease = true
	safecall(widget.PauseLayout, widget)
	widget.frame:Hide()
	widget:Fire("OnRelease")
	safecall(widget.ReleaseChildren, widget)

	if widget.OnRelease then
		widget:OnRelease()
--	else
--		error(("Widget type %s doesn't supply an OnRelease Function"):format(widget.type))
	end
	for k in pairs(widget.userdata) do
		widget.userdata[k] = nil
	end
	for k in pairs(widget.events) do
		widget.events[k] = nil
	end
	widget.width = nil
	widget.relWidth = nil
	widget.height = nil
	widget.relHeight = nil
	widget.noAutoHeight = nil
	widget.frame:ClearAllPoints()
	widget.frame:Hide()
	widget.frame:SetParent(UIParent)
	widget.frame.width = nil
	widget.frame.height = nil
	if widget.content then
		widget.content.width = nil
		widget.content.height = nil
	end
	widget.isQueuedForRelease = nil
	delWidget(widget, widget.type)
end

--- Check if a widget is currently in the process of being released
-- This function check if this widget, or any of its parents (in which case it'll be released shortly as well)
-- are currently being released. This allows addon to handle any callbacks accordingly.
-- @param widget The widget to check
function AceGUI:IsReleasing(widget)
	if widget.isQueuedForRelease then
		return true
	end

	if widget.parent and widget.parent.AceGUIWidgetVersion then
		return AceGUI:IsReleasing(widget.parent)
	end

	return false
end

-----------
-- Focus --
-----------


--- Called when a widget has taken focus.
-- e.g. Dropdowns opening, Editboxes gaining kb focus
-- @param widget The widget that should be focused
function AceGUI:SetFocus(widget)
	if self.FocusedWidget and self.FocusedWidget ~= widget then
		safecall(self.FocusedWidget.ClearFocus, self.FocusedWidget)
	end
	self.FocusedWidget = widget
end


--- Called when something has happened that could cause widgets with focus to drop it
-- e.g. titlebar of a frame being clicked
function AceGUI:ClearFocus()
	if self.FocusedWidget then
		safecall(self.FocusedWidget.ClearFocus, self.FocusedWidget)
		self.FocusedWidget = nil
	end
end

-------------
-- Widgets --
-------------
--[[
	Widgets must provide the following functions
		OnAcquire() - Called when the object is acquired, should set everything to a default hidden state

	And the following members
		frame - the frame or derivitive object that will be treated as the widget for size and anchoring purposes
		type - the type of the object, same as the name given to :RegisterWidget()

	Widgets contain a table called userdata, this is a safe place to store data associated with the wigdet
	It will be cleared automatically when a widget is released
	Placing values directly into a widget object should be avoided

	If the Widget can act as a container for other Widgets the following
		content - frame or derivitive that children will be anchored to

	The Widget can supply the following Optional Members
		:OnRelease() - Called when the object is Released, should remove any additional anchors and clear any data
		:OnWidthSet(width) - Called when the width of the widget is changed
		:OnHeightSet(height) - Called when the height of the widget is changed
			Widgets should not use the OnSizeChanged events of thier frame or content members, use these methods instead
			AceGUI already sets a handler to the event
		:LayoutFinished(width, height) - called after a layout has finished, the width and height will be the width and height of the
			area used for controls. These can be nil if the layout used the existing size to layout the controls.

]]

--------------------------
-- Widget Base Template --
--------------------------
do
	local WidgetBase = AceGUI.WidgetBase

	WidgetBase.SetParent = function(self, parent)
		local frame = self.frame
		frame:SetParent(nil)
		frame:SetParent(parent.content)
		self.parent = parent
	end

	WidgetBase.SetCallback = function(self, name, func)
		if type(func) == "function" then
			self.events[name] = func
		end
	end

	WidgetBase.Fire = function(self, name, ...)
		if self.events[name] then
			local success, ret = safecall(self.events[name], self, name, ...)
			if success then
				return ret
			end
		end
	end

	WidgetBase.SetWidth = function(self, width)
		self.frame:SetWidth(width)
		self.frame.width = width
		if self.OnWidthSet then
			self:OnWidthSet(width)
		end
	end

	WidgetBase.SetRelativeWidth = function(self, width)
		if width <= 0 or width > 1 then
			error(":SetRelativeWidth(width): Invalid relative width.", 2)
		end
		self.relWidth = width
		self.width = "relative"
	end

	WidgetBase.SetHeight = function(self, height)
		self.frame:SetHeight(height)
		self.frame.height = height
		if self.OnHeightSet then
			self:OnHeightSet(height)
		end
	end

	--[[ WidgetBase.SetRelativeHeight = function(self, height)
		if height <= 0 or height > 1 then
			error(":SetRelativeHeight(height): Invalid relative height.", 2)
		end
		self.relHeight = height
		self.height = "relative"
	end ]]

	WidgetBase.IsVisible = function(self)
		return self.frame:IsVisible()
	end

	WidgetBase.IsShown= function(self)
		return self.frame:IsShown()
	end

	WidgetBase.Release = function(self)
		AceGUI:Release(self)
	end

	WidgetBase.IsReleasing = function(self)
		return AceGUI:IsReleasing(self)
	end

	WidgetBase.SetPoint = function(self, ...)
		return self.frame:SetPoint(...)
	end

	WidgetBase.ClearAllPoints = function(self)
		return self.frame:ClearAllPoints()
	end

	WidgetBase.GetNumPoints = function(self)
		return self.frame:GetNumPoints()
	end

	WidgetBase.GetPoint = function(self, ...)
		return self.frame:GetPoint(...)
	end

	WidgetBase.GetUserDataTable = function(self)
		return self.userdata
	end

	WidgetBase.SetUserData = function(self, key, value)
		self.userdata[key] = value
	end

	WidgetBase.GetUserData = function(self, key)
		return self.userdata[key]
	end

	WidgetBase.IsFullHeight = function(self)
		return self.height == "fill"
	end

	WidgetBase.SetFullHeight = function(self, isFull)
		if isFull then
			self.height = "fill"
		else
			self.height = nil
		end
	end

	WidgetBase.IsFullWidth = function(self)
		return self.width == "fill"
	end

	WidgetBase.SetFullWidth = function(self, isFull)
		if isFull then
			self.width = "fill"
		else
			self.width = nil
		end
	end

--	local function LayoutOnUpdate(this)
--		this:SetScript("OnUpdate",nil)
--		this.obj:PerformLayout()
--	end

	local WidgetContainerBase = AceGUI.WidgetContainerBase

	WidgetContainerBase.PauseLayout = function(self)
		self.LayoutPaused = true
	end

	WidgetContainerBase.ResumeLayout = function(self)
		self.LayoutPaused = nil
	end

	WidgetContainerBase.PerformLayout = function(self)
		if self.LayoutPaused then
			return
		end
		safecall(self.LayoutFunc, self.content, self.children)
	end

	--call this function to layout, makes sure layed out objects get a frame to get sizes etc
	WidgetContainerBase.DoLayout = function(self)
		self:PerformLayout()
--		if not self.parent then
--			self.frame:SetScript("OnUpdate", LayoutOnUpdate)
--		end
	end

	WidgetContainerBase.AddChild = function(self, child, beforeWidget)
		if beforeWidget then
			local siblingIndex = 1
			for _, widget in pairs(self.children) do
				if widget == beforeWidget then
					break
				end
				siblingIndex = siblingIndex + 1
			end
			tinsert(self.children, siblingIndex, child)
		else
			tinsert(self.children, child)
		end
		child:SetParent(self)
		child.frame:Show()
		self:DoLayout()
	end

	WidgetContainerBase.AddChildren = function(self, ...)
		for i = 1, select("#", ...) do
			local child = select(i, ...)
			tinsert(self.children, child)
			child:SetParent(self)
			child.frame:Show()
		end
		self:DoLayout()
	end

	WidgetContainerBase.ReleaseChildren = function(self)
		local children = self.children
		for i = 1,#children do
			AceGUI:Release(children[i])
			children[i] = nil
		end
	end

	WidgetContainerBase.SetLayout = function(self, Layout)
		self.LayoutFunc = AceGUI:GetLayout(Layout)
	end

	WidgetContainerBase.SetAutoAdjustHeight = function(self, adjust)
		if adjust then
			self.noAutoHeight = nil
		else
			self.noAutoHeight = true
		end
	end

	local function FrameResize(this)
		local self = this.obj
		if this:GetWidth() and this:GetHeight() then
			if self.OnWidthSet then
				self:OnWidthSet(this:GetWidth())
			end
			if self.OnHeightSet then
				self:OnHeightSet(this:GetHeight())
			end
		end
	end

	local function ContentResize(this)
		if this:GetWidth() and this:GetHeight() then
			this.width = this:GetWidth()
			this.height = this:GetHeight()
			this.obj:DoLayout()
		end
	end

	setmetatable(WidgetContainerBase, {__index=WidgetBase})

	--One of these function should be called on each Widget Instance as part of its creation process

	--- Register a widget-class as a container for newly created widgets.
	-- @param widget The widget class
	function AceGUI:RegisterAsContainer(widget)
		widget.children = {}
		widget.userdata = {}
		widget.events = {}
		widget.base = WidgetContainerBase
		widget.content.obj = widget
		widget.frame.obj = widget
		widget.content:SetScript("OnSizeChanged", ContentResize)
		widget.frame:SetScript("OnSizeChanged", FrameResize)
		setmetatable(widget, {__index = WidgetContainerBase})
		widget:SetLayout("List")
		return widget
	end

	--- Register a widget-class as a widget.
	-- @param widget The widget class
	function AceGUI:RegisterAsWidget(widget)
		widget.userdata = {}
		widget.events = {}
		widget.base = WidgetBase
		widget.frame.obj = widget
		widget.frame:SetScript("OnSizeChanged", FrameResize)
		setmetatable(widget, {__index = WidgetBase})
		return widget
	end
end




------------------
-- Widget API   --
------------------

--- Registers a widget Constructor, this function returns a new instance of the Widget
-- @param Name The name of the widget
-- @param Constructor The widget constructor function
-- @param Version The version of the widget
function AceGUI:RegisterWidgetType(Name, Constructor, Version)
	assert(type(Constructor) == "function")
	assert(type(Version) == "number")

	local oldVersion = WidgetVersions[Name]
	if oldVersion and oldVersion >= Version then return end

	WidgetVersions[Name] = Version
	WidgetRegistry[Name] = Constructor
end

--- Registers a Layout Function
-- @param Name The name of the layout
-- @param LayoutFunc Reference to the layout function
function AceGUI:RegisterLayout(Name, LayoutFunc)
	assert(type(LayoutFunc) == "function")
	if type(Name) == "string" then
		Name = Name:upper()
	end
	LayoutRegistry[Name] = LayoutFunc
end

--- Get a Layout Function from the registry
-- @param Name The name of the layout
function AceGUI:GetLayout(Name)
	if type(Name) == "string" then
		Name = Name:upper()
	end
	return LayoutRegistry[Name]
end

AceGUI.counts = AceGUI.counts or {}

--- A type-based counter to count the number of widgets created.
-- This is used by widgets that require a named frame, e.g. when a Blizzard
-- Template requires it.
-- @param type The widget type
function AceGUI:GetNextWidgetNum(widgetType)
	if not self.counts[widgetType] then
		self.counts[widgetType] = 0
	end
	self.counts[widgetType] = self.counts[widgetType] + 1
	return self.counts[widgetType]
end

--- Return the number of created widgets for this type.
-- In contrast to GetNextWidgetNum, the number is not incremented.
-- @param widgetType The widget type
function AceGUI:GetWidgetCount(widgetType)
	return self.counts[widgetType] or 0
end

--- Return the version of the currently registered widget type.
-- @param widgetType The widget type
function AceGUI:GetWidgetVersion(widgetType)
	return WidgetVersions[widgetType]
end

-------------
-- Layouts --
-------------

--[[
	A Layout is a func that takes 2 parameters
		content - the frame that widgets will be placed inside
		children - a table containing the widgets to layout
]]

-- Very simple Layout, Children are stacked on top of each other down the left side
AceGUI:RegisterLayout("List",
	function(content, children)
		local height = 0
		local width = content.width or content:GetWidth() or 0
		for i = 1, #children do
			local child = children[i]

			local frame = child.frame
			frame:ClearAllPoints()
			frame:Show()
			if i == 1 then
				frame:SetPoint("TOPLEFT", content)
			else
				frame:SetPoint("TOPLEFT", children[i-1].frame, "BOTTOMLEFT")
			end

			if child.width == "fill" then
				child:SetWidth(width)
				frame:SetPoint("RIGHT", content)

				if child.DoLayout then
					child:DoLayout()
				end
			elseif child.width == "relative" then
				child:SetWidth(width * child.relWidth)

				if child.DoLayout then
					child:DoLayout()
				end
			end

			height = height + (frame.height or frame:GetHeight() or 0)
		end
		safecall(content.obj.LayoutFinished, content.obj, nil, height)
	end)

-- A single control fills the whole content area
AceGUI:RegisterLayout("Fill",
	function(content, children)
		if children[1] then
			children[1]:SetWidth(content:GetWidth() or 0)
			children[1]:SetHeight(content:GetHeight() or 0)
			children[1].frame:ClearAllPoints()
			children[1].frame:SetAllPoints(content)
			children[1].frame:Show()
			safecall(content.obj.LayoutFinished, content.obj, nil, children[1].frame:GetHeight())
		end
	end)

local layoutrecursionblock = nil
local function safelayoutcall(object, func, ...)
	layoutrecursionblock = true
	object[func](object, ...)
	layoutrecursionblock = nil
end

AceGUI:RegisterLayout("Flow",
	function(content, children)
		if layoutrecursionblock then return end
		--used height so far
		local height = 0
		--width used in the current row
		local usedwidth = 0
		--height of the current row
		local rowheight = 0
		local rowoffset = 0

		local width = content.width or content:GetWidth() or 0

		--control at the start of the row
		local rowstart
		local rowstartoffset
		local isfullheight

		local frameoffset
		local lastframeoffset
		local oversize
		for i = 1, #children do
			local child = children[i]
			oversize = nil
			local frame = child.frame
			local frameheight = frame.height or frame:GetHeight() or 0
			local framewidth = frame.width or frame:GetWidth() or 0
			lastframeoffset = frameoffset
			-- HACK: Why did we set a frameoffset of (frameheight / 2) ?
			-- That was moving all widgets half the widgets size down, is that intended?
			-- Actually, it seems to be neccessary for many cases, we'll leave it in for now.
			-- If widgets seem to anchor weirdly with this, provide a valid alignoffset for them.
			-- TODO: Investigate moar!
			frameoffset = child.alignoffset or (frameheight / 2)

			if child.width == "relative" then
				framewidth = width * child.relWidth
			end

			frame:Show()
			frame:ClearAllPoints()
			if i == 1 then
				-- anchor the first control to the top left
				frame:SetPoint("TOPLEFT", content)
				rowheight = frameheight
				rowoffset = frameoffset
				rowstart = frame
				rowstartoffset = frameoffset
				usedwidth = framewidth
				if usedwidth > width then
					oversize = true
				end
			else
				-- if there isn't available width for the control start a new row
				-- if a control is "fill" it will be on a row of its own full width
				if usedwidth == 0 or ((framewidth) + usedwidth > width) or child.width == "fill" then
					if isfullheight then
						-- a previous row has already filled the entire height, there's nothing we can usefully do anymore
						-- (maybe error/warn about this?)
						break
					end
					--anchor the previous row, we will now know its height and offset
					rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
					height = height + rowheight + 3
					--save this as the rowstart so we can anchor it after the row is complete and we have the max height and offset of controls in it
					rowstart = frame
					rowstartoffset = frameoffset
					rowheight = frameheight
					rowoffset = frameoffset
					usedwidth = framewidth
					if usedwidth > width then
						oversize = true
					end
				-- put the control on the current row, adding it to the width and checking if the height needs to be increased
				else
					--handles cases where the new height is higher than either control because of the offsets
					--math.max(rowheight-rowoffset+frameoffset, frameheight-frameoffset+rowoffset)

					--offset is always the larger of the two offsets
					rowoffset = math_max(rowoffset, frameoffset)
					rowheight = math_max(rowheight, rowoffset + (frameheight / 2))

					frame:SetPoint("TOPLEFT", children[i-1].frame, "TOPRIGHT", 0, frameoffset - lastframeoffset)
					usedwidth = framewidth + usedwidth
				end
			end

			if child.width == "fill" then
				safelayoutcall(child, "SetWidth", width)
				frame:SetPoint("RIGHT", content)

				usedwidth = 0
				rowstart = frame

				if child.DoLayout then
					child:DoLayout()
				end
				rowheight = frame.height or frame:GetHeight() or 0
				rowoffset = child.alignoffset or (rowheight / 2)
				rowstartoffset = rowoffset
			elseif child.width == "relative" then
				safelayoutcall(child, "SetWidth", width * child.relWidth)

				if child.DoLayout then
					child:DoLayout()
				end
			elseif oversize then
				if width > 1 then
					frame:SetPoint("RIGHT", content)
				end
			end

			if child.height == "fill" then
				frame:SetPoint("BOTTOM", content)
				isfullheight = true
			end
		end

		--anchor the last row, if its full height needs a special case since  its height has just been changed by the anchor
		if isfullheight then
			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -height)
		elseif rowstart then
			rowstart:SetPoint("TOPLEFT", content, "TOPLEFT", 0, -(height + (rowoffset - rowstartoffset) + 3))
		end

		height = height + rowheight + 3
		safecall(content.obj.LayoutFinished, content.obj, nil, height)
	end)

-- Get alignment method and value. Possible alignment methods are a callback, a number, "start", "middle", "end", "fill" or "TOPLEFT", "BOTTOMRIGHT" etc.
local GetCellAlign = function (dir, tableObj, colObj, cellObj, cell, child)
	local fn = cellObj and (cellObj["align" .. dir] or cellObj.align)
			or colObj and (colObj["align" .. dir] or colObj.align)
			or tableObj["align" .. dir] or tableObj.align
			or "CENTERLEFT"
	local val
	child, cell = child or 0, cell or 0

	if type(fn) == "string" then
		fn = fn:lower()
		fn = dir == "V" and (fn:sub(1, 3) == "top" and "start" or fn:sub(1, 6) == "bottom" and "end" or fn:sub(1, 6) == "center" and "middle")
		  or dir == "H" and (fn:sub(-4) == "left" and "start" or fn:sub(-5) == "right" and "end" or fn:sub(-6) == "center" and "middle")
		  or fn
		val = (fn == "start" or fn == "fill") and 0 or fn == "end" and cell - child or (cell - child) / 2
	elseif type(fn) == "function" then
		val = fn(child or 0, cell, dir)
	else
		val = fn
	end

	return fn, math_max(0, math_min(val, cell))
end

-- Get width or height for multiple cells combined
local GetCellDimension = function (dir, laneDim, from, to, space)
	local dim = 0
	for cell=from,to do
		dim = dim + (laneDim[cell] or 0)
	end
	return dim + math_max(0, to - from) * (space or 0)
end

--[[ Options
============
Container:
 - columns ({col, col, ...}): Column settings. "col" can be a number (<= 0: content width, <1: rel. width, <10: weight, >=10: abs. width) or a table with column setting.
 - space, spaceH, spaceV: Overall, horizontal and vertical spacing between cells.
 - align, alignH, alignV: Overall, horizontal and vertical cell alignment. See GetCellAlign() for possible values.
Columns:
 - width: Fixed column width (nil or <=0: content width, <1: rel. width, >=1: abs. width).
 - min or 1: Min width for content based width
 - max or 2: Max width for content based width
 - weight: Flexible column width. The leftover width after accounting for fixed-width columns is distributed to weighted columns according to their weights.
 - align, alignH, alignV: Overwrites the container setting for alignment.
Cell:
 - colspan: Makes a cell span multiple columns.
 - rowspan: Makes a cell span multiple rows.
 - align, alignH, alignV: Overwrites the container and column setting for alignment.
]]
AceGUI:RegisterLayout("Table",
	function (content, children)
		local obj = content.obj
		obj:PauseLayout()

		local tableObj = obj:GetUserData("table")
		local cols = tableObj.columns
		local spaceH = tableObj.spaceH or tableObj.space or 0
		local spaceV = tableObj.spaceV or tableObj.space or 0
		local totalH = (content:GetWidth() or content.width or 0) - spaceH * (#cols - 1)

		-- We need to reuse these because layout events can come in very frequently
		local layoutCache = obj:GetUserData("layoutCache")
		if not layoutCache then
			layoutCache = {{}, {}, {}, {}, {}, {}}
			obj:SetUserData("layoutCache", layoutCache)
		end
		local t, laneH, laneV, rowspans, rowStart, colStart = unpack(layoutCache)

		-- Create the grid
		local n, slotFound = 0
		for i,child in ipairs(children) do
			if child:IsShown() then
				repeat
					n = n + 1
					local col = (n - 1) % #cols + 1
					local row = math_ceil(n / #cols)
					local rowspan = rowspans[col]
					local cell = rowspan and rowspan.child or child
					local cellObj = cell:GetUserData("cell")
					slotFound = not rowspan

					-- Rowspan
					if not rowspan and cellObj and cellObj.rowspan then
						rowspan = {child = child, from = row, to = row + cellObj.rowspan - 1}
						rowspans[col] = rowspan
					end
					if rowspan and i == #children then
						rowspan.to = row
					end

					-- Colspan
					local colspan = math_max(0, math_min((cellObj and cellObj.colspan or 1) - 1, #cols - col))
					n = n + colspan

					-- Place the cell
					if not rowspan or rowspan.to == row then
						t[n] = cell
						rowStart[cell] = rowspan and rowspan.from or row
						colStart[cell] = col

						if rowspan then
							rowspans[col] = nil
						end
					end
				until slotFound
			end
		end

		local rows = math_ceil(n / #cols)

		-- Determine fixed size cols and collect weights
		local extantH, totalWeight = totalH, 0
		for col,colObj in ipairs(cols) do
			laneH[col] = 0

			if type(colObj) == "number" then
				colObj = {[colObj >= 1 and colObj < 10 and "weight" or "width"] = colObj}
				cols[col] = colObj
			end

			if colObj.weight then
				-- Weight
				totalWeight = totalWeight + (colObj.weight or 1)
			else
				if not colObj.width or colObj.width <= 0 then
					-- Content width
					for row=1,rows do
						local child = t[(row - 1) * #cols + col]
						if child then
							local f = child.frame
							f:ClearAllPoints()
							local childH = f:GetWidth() or 0

							laneH[col] = math_max(laneH[col], childH - GetCellDimension("H", laneH, colStart[child], col - 1, spaceH))
						end
					end

					laneH[col] = math_max(colObj.min or colObj[1] or 0, math_min(laneH[col], colObj.max or colObj[2] or laneH[col]))
				else
					-- Rel./Abs. width
					laneH[col] = colObj.width < 1 and colObj.width * totalH or colObj.width
				end
				extantH = math_max(0, extantH - laneH[col])
			end
		end

		-- Determine sizes based on weight
		local scale = totalWeight > 0 and extantH / totalWeight or 0
		for col,colObj in pairs(cols) do
			if colObj.weight then
				laneH[col] = scale * colObj.weight
			end
		end

		-- Arrange children
		for row=1,rows do
			local rowV = 0

			-- Horizontal placement and sizing
			for col=1,#cols do
				local child = t[(row - 1) * #cols + col]
				if child then
					local colObj = cols[colStart[child]]
					local cellObj = child:GetUserData("cell")
					local offsetH = GetCellDimension("H", laneH, 1, colStart[child] - 1, spaceH) + (colStart[child] == 1 and 0 or spaceH)
					local cellH = GetCellDimension("H", laneH, colStart[child], col, spaceH)

					local f = child.frame
					f:ClearAllPoints()
					local childH = f:GetWidth() or 0

					local alignFn, align = GetCellAlign("H", tableObj, colObj, cellObj, cellH, childH)
					f:SetPoint("LEFT", content, offsetH + align, 0)
					if child:IsFullWidth() or alignFn == "fill" or childH > cellH then
						f:SetPoint("RIGHT", content, "LEFT", offsetH + align + cellH, 0)
					end

					if child.DoLayout then
						child:DoLayout()
					end

					rowV = math_max(rowV, (f:GetHeight() or 0) - GetCellDimension("V", laneV, rowStart[child], row - 1, spaceV))
				end
			end

			laneV[row] = rowV

			-- Vertical placement and sizing
			for col=1,#cols do
				local child = t[(row - 1) * #cols + col]
				if child then
					local colObj = cols[colStart[child]]
					local cellObj = child:GetUserData("cell")
					local offsetV = GetCellDimension("V", laneV, 1, rowStart[child] - 1, spaceV) + (rowStart[child] == 1 and 0 or spaceV)
					local cellV = GetCellDimension("V", laneV, rowStart[child], row, spaceV)

					local f = child.frame
					local childV = f:GetHeight() or 0

					local alignFn, align = GetCellAlign("V", tableObj, colObj, cellObj, cellV, childV)
					if child:IsFullHeight() or alignFn == "fill" then
						f:SetHeight(cellV)
					end
					f:SetPoint("TOP", content, 0, -(offsetV + align))
				end
			end
		end

		-- Calculate total height
		local totalV = GetCellDimension("V", laneV, 1, #laneV, spaceV)

		-- Cleanup
		for _,v in pairs(layoutCache) do wipe(v) end

		safecall(obj.LayoutFinished, obj, nil, totalV)
		obj:ResumeLayout()
	end)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/AceGUI-3.0.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua ===
--[[-----------------------------------------------------------------------------
BlizOptionsGroup Container
Simple container widget for the integration of AceGUI into the Blizzard Interface Options
-------------------------------------------------------------------------------]]
local Type, Version = "BlizOptionsGroup", 26
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame = CreateFrame

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]

local function OnShow(frame)
	frame.obj:Fire("OnShow")
end

local function OnHide(frame)
	frame.obj:Fire("OnHide")
end

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

local function okay(frame)
	frame.obj:Fire("okay")
end

local function cancel(frame)
	frame.obj:Fire("cancel")
end

local function default(frame)
	frame.obj:Fire("default")
end

local function refresh(frame)
	frame.obj:Fire("refresh")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]

local methods = {
	["OnAcquire"] = function(self)
		self:SetName()
		self:SetTitle()
	end,

	-- ["OnRelease"] = nil,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 63
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 26
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["SetName"] = function(self, name, parent)
		self.frame.name = name
		self.frame.parent = parent
	end,

	["SetTitle"] = function(self, title)
		local content = self.content
		content:ClearAllPoints()
		if not title or title == "" then
			content:SetPoint("TOPLEFT", 10, -10)
			self.label:SetText("")
		else
			content:SetPoint("TOPLEFT", 10, -40)
			self.label:SetText(title)
		end
		content:SetPoint("BOTTOMRIGHT", -10, 10)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, InterfaceOptionsFramePanelContainer)
	frame:Hide()

	-- support functions for the Blizzard Interface Options
	frame.okay = okay
	frame.cancel = cancel
	frame.default = default
	frame.refresh = refresh

	-- 10.0 support function aliases (cancel has been removed)
	frame.OnCommit = okay
	frame.OnDefault = default
	frame.OnRefresh = refresh

	frame:SetScript("OnHide", OnHide)
	frame:SetScript("OnShow", OnShow)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalLarge")
	label:SetPoint("TOPLEFT", 10, -15)
	label:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", 10, -45)
	label:SetJustifyH("LEFT")
	label:SetJustifyV("TOP")

	--Container Support
	local content = CreateFrame("Frame", nil, frame)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		label   = label,
		frame   = frame,
		content = content,
		type    = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-BlizOptionsGroup.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua ===
--[[-----------------------------------------------------------------------------
DropdownGroup Container
Container controlled by a dropdown on the top.
-------------------------------------------------------------------------------]]
local Type, Version = "DropdownGroup", 22
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local assert, pairs, type = assert, pairs, type

-- WoW APIs
local CreateFrame = CreateFrame

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function SelectedGroup(self, event, value)
	local group = self.parentgroup
	local status = group.status or group.localstatus
	status.selected = value
	self.parentgroup:Fire("OnGroupSelected", value)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self.dropdown:SetText("")
		self:SetDropdownWidth(200)
		self:SetTitle("")
	end,

	["OnRelease"] = function(self)
		self.dropdown.list = nil
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
	end,

	["SetTitle"] = function(self, title)
		self.titletext:SetText(title)
		self.dropdown.frame:ClearAllPoints()
		if title and title ~= "" then
			self.dropdown.frame:SetPoint("TOPRIGHT", -2, 0)
		else
			self.dropdown.frame:SetPoint("TOPLEFT", -1, 0)
		end
	end,

	["SetGroupList"] = function(self,list,order)
		self.dropdown:SetList(list,order)
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
	end,

	["SetGroup"] = function(self,group)
		self.dropdown:SetValue(group)
		local status = self.status or self.localstatus
		status.selected = group
		self:Fire("OnGroupSelected", group)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 26
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 63
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["LayoutFinished"] = function(self, width, height)
		self:SetHeight((height or 0) + 63)
	end,

	["SetDropdownWidth"] = function(self, width)
		self.dropdown:SetWidth(width)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame")
	frame:SetHeight(100)
	frame:SetWidth(100)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	titletext:SetPoint("TOPLEFT", 4, -5)
	titletext:SetPoint("TOPRIGHT", -4, -5)
	titletext:SetJustifyH("LEFT")
	titletext:SetHeight(18)

	local dropdown = AceGUI:Create("Dropdown")
	dropdown.frame:SetParent(frame)
	dropdown.frame:SetFrameLevel(dropdown.frame:GetFrameLevel() + 2)
	dropdown:SetCallback("OnValueChanged", SelectedGroup)
	dropdown.frame:SetPoint("TOPLEFT", -1, 0)
	dropdown.frame:Show()
	dropdown:SetLabel("")

	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
	border:SetPoint("TOPLEFT", 0, -26)
	border:SetPoint("BOTTOMRIGHT", 0, 3)
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1,0.1,0.1,0.5)
	border:SetBackdropBorderColor(0.4,0.4,0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		frame       = frame,
		localstatus = {},
		titletext   = titletext,
		dropdown    = dropdown,
		border      = border,
		content     = content,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	dropdown.parentgroup = widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-DropDownGroup.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua ===
--[[-----------------------------------------------------------------------------
Frame Container
-------------------------------------------------------------------------------]]
local Type, Version = "Frame", 30
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs, assert, type = pairs, assert, type
local wipe = table.wipe

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Button_OnClick(frame)
	PlaySound(799) -- SOUNDKIT.GS_TITLE_OPTION_EXIT
	frame.obj:Hide()
end

local function Frame_OnShow(frame)
	frame.obj:Fire("OnShow")
end

local function Frame_OnClose(frame)
	frame.obj:Fire("OnClose")
end

local function Frame_OnMouseDown(frame)
	AceGUI:ClearFocus()
end

local function Title_OnMouseDown(frame)
	frame:GetParent():StartMoving()
	AceGUI:ClearFocus()
end

local function MoverSizer_OnMouseUp(mover)
	local frame = mover:GetParent()
	frame:StopMovingOrSizing()
	local self = frame.obj
	local status = self.status or self.localstatus
	status.width = frame:GetWidth()
	status.height = frame:GetHeight()
	status.top = frame:GetTop()
	status.left = frame:GetLeft()
end

local function SizerSE_OnMouseDown(frame)
	frame:GetParent():StartSizing("BOTTOMRIGHT")
	AceGUI:ClearFocus()
end

local function SizerS_OnMouseDown(frame)
	frame:GetParent():StartSizing("BOTTOM")
	AceGUI:ClearFocus()
end

local function SizerE_OnMouseDown(frame)
	frame:GetParent():StartSizing("RIGHT")
	AceGUI:ClearFocus()
end

local function StatusBar_OnEnter(frame)
	frame.obj:Fire("OnEnterStatusBar")
end

local function StatusBar_OnLeave(frame)
	frame.obj:Fire("OnLeaveStatusBar")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self.frame:SetParent(UIParent)
		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
		self.frame:SetFrameLevel(100) -- Lots of room to draw under it
		self:SetTitle()
		self:SetStatusText()
		self:ApplyStatus()
		self:Show()
        self:EnableResize(true)
	end,

	["OnRelease"] = function(self)
		self.status = nil
		wipe(self.localstatus)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 34
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 57
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["SetTitle"] = function(self, title)
		self.titletext:SetText(title)
		self.titlebg:SetWidth((self.titletext:GetWidth() or 0) + 10)
	end,

	["SetStatusText"] = function(self, text)
		self.statustext:SetText(text)
	end,

	["Hide"] = function(self)
		self.frame:Hide()
	end,

	["Show"] = function(self)
		self.frame:Show()
	end,

	["EnableResize"] = function(self, state)
		local func = state and "Show" or "Hide"
		self.sizer_se[func](self.sizer_se)
		self.sizer_s[func](self.sizer_s)
		self.sizer_e[func](self.sizer_e)
	end,

	-- called to set an external table to store status in
	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
		self:ApplyStatus()
	end,

	["ApplyStatus"] = function(self)
		local status = self.status or self.localstatus
		local frame = self.frame
		self:SetWidth(status.width or 700)
		self:SetHeight(status.height or 500)
		frame:ClearAllPoints()
		if status.top and status.left then
			frame:SetPoint("TOP", UIParent, "BOTTOM", 0, status.top)
			frame:SetPoint("LEFT", UIParent, "LEFT", status.left, 0)
		else
			frame:SetPoint("CENTER")
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local FrameBackdrop = {
	bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background",
	edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
	tile = true, tileSize = 32, edgeSize = 32,
	insets = { left = 8, right = 8, top = 8, bottom = 8 }
}

local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent, "BackdropTemplate")
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetMovable(true)
	frame:SetResizable(true)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")
	frame:SetFrameLevel(100) -- Lots of room to draw under it
	frame:SetBackdrop(FrameBackdrop)
	frame:SetBackdropColor(0, 0, 0, 1)
	if frame.SetResizeBounds then -- WoW 10.0
		frame:SetResizeBounds(400, 200)
	else
		frame:SetMinResize(400, 200)
	end
	frame:SetToplevel(true)
	frame:SetScript("OnShow", Frame_OnShow)
	frame:SetScript("OnHide", Frame_OnClose)
	frame:SetScript("OnMouseDown", Frame_OnMouseDown)

	local closebutton = CreateFrame("Button", nil, frame, "UIPanelButtonTemplate")
	closebutton:SetScript("OnClick", Button_OnClick)
	closebutton:SetPoint("BOTTOMRIGHT", -27, 17)
	closebutton:SetHeight(20)
	closebutton:SetWidth(100)
	closebutton:SetText(CLOSE)

	local statusbg = CreateFrame("Button", nil, frame, "BackdropTemplate")
	statusbg:SetPoint("BOTTOMLEFT", 15, 15)
	statusbg:SetPoint("BOTTOMRIGHT", -132, 15)
	statusbg:SetHeight(24)
	statusbg:SetBackdrop(PaneBackdrop)
	statusbg:SetBackdropColor(0.1,0.1,0.1)
	statusbg:SetBackdropBorderColor(0.4,0.4,0.4)
	statusbg:SetScript("OnEnter", StatusBar_OnEnter)
	statusbg:SetScript("OnLeave", StatusBar_OnLeave)

	local statustext = statusbg:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	statustext:SetPoint("TOPLEFT", 7, -2)
	statustext:SetPoint("BOTTOMRIGHT", -7, 2)
	statustext:SetHeight(20)
	statustext:SetJustifyH("LEFT")
	statustext:SetText("")

	local titlebg = frame:CreateTexture(nil, "OVERLAY")
	titlebg:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
	titlebg:SetTexCoord(0.31, 0.67, 0, 0.63)
	titlebg:SetPoint("TOP", 0, 12)
	titlebg:SetWidth(100)
	titlebg:SetHeight(40)

	local title = CreateFrame("Frame", nil, frame)
	title:EnableMouse(true)
	title:SetScript("OnMouseDown", Title_OnMouseDown)
	title:SetScript("OnMouseUp", MoverSizer_OnMouseUp)
	title:SetAllPoints(titlebg)

	local titletext = title:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	titletext:SetPoint("TOP", titlebg, "TOP", 0, -14)

	local titlebg_l = frame:CreateTexture(nil, "OVERLAY")
	titlebg_l:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
	titlebg_l:SetTexCoord(0.21, 0.31, 0, 0.63)
	titlebg_l:SetPoint("RIGHT", titlebg, "LEFT")
	titlebg_l:SetWidth(30)
	titlebg_l:SetHeight(40)

	local titlebg_r = frame:CreateTexture(nil, "OVERLAY")
	titlebg_r:SetTexture(131080) -- Interface\\DialogFrame\\UI-DialogBox-Header
	titlebg_r:SetTexCoord(0.67, 0.77, 0, 0.63)
	titlebg_r:SetPoint("LEFT", titlebg, "RIGHT")
	titlebg_r:SetWidth(30)
	titlebg_r:SetHeight(40)

	local sizer_se = CreateFrame("Frame", nil, frame)
	sizer_se:SetPoint("BOTTOMRIGHT")
	sizer_se:SetWidth(25)
	sizer_se:SetHeight(25)
	sizer_se:EnableMouse()
	sizer_se:SetScript("OnMouseDown",SizerSE_OnMouseDown)
	sizer_se:SetScript("OnMouseUp", MoverSizer_OnMouseUp)

	local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
	line1:SetWidth(14)
	line1:SetHeight(14)
	line1:SetPoint("BOTTOMRIGHT", -8, 8)
	line1:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
	local x = 0.1 * 14/17
	line1:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)

	local line2 = sizer_se:CreateTexture(nil, "BACKGROUND")
	line2:SetWidth(8)
	line2:SetHeight(8)
	line2:SetPoint("BOTTOMRIGHT", -8, 8)
	line2:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
	x = 0.1 * 8/17
	line2:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)

	local sizer_s = CreateFrame("Frame", nil, frame)
	sizer_s:SetPoint("BOTTOMRIGHT", -25, 0)
	sizer_s:SetPoint("BOTTOMLEFT")
	sizer_s:SetHeight(25)
	sizer_s:EnableMouse(true)
	sizer_s:SetScript("OnMouseDown", SizerS_OnMouseDown)
	sizer_s:SetScript("OnMouseUp", MoverSizer_OnMouseUp)

	local sizer_e = CreateFrame("Frame", nil, frame)
	sizer_e:SetPoint("BOTTOMRIGHT", 0, 25)
	sizer_e:SetPoint("TOPRIGHT")
	sizer_e:SetWidth(25)
	sizer_e:EnableMouse(true)
	sizer_e:SetScript("OnMouseDown", SizerE_OnMouseDown)
	sizer_e:SetScript("OnMouseUp", MoverSizer_OnMouseUp)

	--Container Support
	local content = CreateFrame("Frame", nil, frame)
	content:SetPoint("TOPLEFT", 17, -27)
	content:SetPoint("BOTTOMRIGHT", -17, 40)

	local widget = {
		localstatus = {},
		titletext   = titletext,
		statustext  = statustext,
		titlebg     = titlebg,
		sizer_se    = sizer_se,
		sizer_s     = sizer_s,
		sizer_e     = sizer_e,
		content     = content,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	closebutton.obj, statusbg.obj = widget, widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-Frame.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua ===
--[[-----------------------------------------------------------------------------
InlineGroup Container
Simple container widget that creates a visible "box" with an optional title.
-------------------------------------------------------------------------------]]
local Type, Version = "InlineGroup", 22
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(300)
		self:SetHeight(100)
		self:SetTitle("")
	end,

	-- ["OnRelease"] = nil,

	["SetTitle"] = function(self,title)
		self.titletext:SetText(title)
	end,


	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight((height or 0) + 40)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 20
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 20
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local titletext = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	titletext:SetPoint("TOPLEFT", 14, 0)
	titletext:SetPoint("TOPRIGHT", -14, 0)
	titletext:SetJustifyH("LEFT")
	titletext:SetHeight(18)

	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
	border:SetPoint("TOPLEFT", 0, -17)
	border:SetPoint("BOTTOMRIGHT", -1, 3)
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	border:SetBackdropBorderColor(0.4, 0.4, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		frame     = frame,
		content   = content,
		titletext = titletext,
		type      = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-InlineGroup.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua ===
--[[-----------------------------------------------------------------------------
ScrollFrame Container
Plain container that scrolls its content and doesn't grow in height.
-------------------------------------------------------------------------------]]
local Type, Version = "ScrollFrame", 26
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs, assert, type = pairs, assert, type
local min, max, floor = math.min, math.max, math.floor

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function FixScrollOnUpdate(frame)
	frame:SetScript("OnUpdate", nil)
	frame.obj:FixScroll()
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function ScrollFrame_OnMouseWheel(frame, value)
	frame.obj:MoveScroll(value)
end

local function ScrollFrame_OnSizeChanged(frame)
	frame:SetScript("OnUpdate", FixScrollOnUpdate)
end

local function ScrollBar_OnScrollValueChanged(frame, value)
	frame.obj:SetScroll(value)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetScroll(0)
		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
	end,

	["OnRelease"] = function(self)
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
		self.scrollframe:SetPoint("BOTTOMRIGHT")
		self.scrollbar:Hide()
		self.scrollBarShown = nil
		self.content.height, self.content.width, self.content.original_width = nil, nil, nil
	end,

	["SetScroll"] = function(self, value)
		local status = self.status or self.localstatus
		local viewheight = self.scrollframe:GetHeight()
		local height = self.content:GetHeight()
		local offset

		if viewheight > height then
			offset = 0
		else
			offset = floor((height - viewheight) / 1000.0 * value)
		end
		self.content:ClearAllPoints()
		self.content:SetPoint("TOPLEFT", 0, offset)
		self.content:SetPoint("TOPRIGHT", 0, offset)
		status.offset = offset
		status.scrollvalue = value
	end,

	["MoveScroll"] = function(self, value)
		local status = self.status or self.localstatus
		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()

		if self.scrollBarShown then
			local diff = height - viewheight
			local delta = 1
			if value < 0 then
				delta = -1
			end
			self.scrollbar:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
		end
	end,

	["FixScroll"] = function(self)
		if self.updateLock then return end
		self.updateLock = true
		local status = self.status or self.localstatus
		local height, viewheight = self.scrollframe:GetHeight(), self.content:GetHeight()
		local offset = status.offset or 0
		-- Give us a margin of error of 2 pixels to stop some conditions that i would blame on floating point inaccuracys
		-- No-one is going to miss 2 pixels at the bottom of the frame, anyhow!
		if viewheight < height + 2 then
			if self.scrollBarShown then
				self.scrollBarShown = nil
				self.scrollbar:Hide()
				self.scrollbar:SetValue(0)
				self.scrollframe:SetPoint("BOTTOMRIGHT")
				if self.content.original_width then
					self.content.width = self.content.original_width
				end
				self:DoLayout()
			end
		else
			if not self.scrollBarShown then
				self.scrollBarShown = true
				self.scrollbar:Show()
				self.scrollframe:SetPoint("BOTTOMRIGHT", -20, 0)
				if self.content.original_width then
					self.content.width = self.content.original_width - 20
				end
				self:DoLayout()
			end
			local value = (offset / (viewheight - height) * 1000)
			if value > 1000 then value = 1000 end
			self.scrollbar:SetValue(value)
			self:SetScroll(value)
			if value < 1000 then
				self.content:ClearAllPoints()
				self.content:SetPoint("TOPLEFT", 0, offset)
				self.content:SetPoint("TOPRIGHT", 0, offset)
				status.offset = offset
			end
		end
		self.updateLock = nil
	end,

	["LayoutFinished"] = function(self, width, height)
		self.content:SetHeight(height or 0 + 20)

		-- update the scrollframe
		self:FixScroll()

		-- schedule another update when everything has "settled"
		self.scrollframe:SetScript("OnUpdate", FixScrollOnUpdate)
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
		if not status.scrollvalue then
			status.scrollvalue = 0
		end
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		content.width = width - (self.scrollBarShown and 20 or 0)
		content.original_width = width
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		content.height = height
	end
}
--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	local num = AceGUI:GetNextWidgetNum(Type)

	local scrollframe = CreateFrame("ScrollFrame", nil, frame)
	scrollframe:SetPoint("TOPLEFT")
	scrollframe:SetPoint("BOTTOMRIGHT")
	scrollframe:EnableMouseWheel(true)
	scrollframe:SetScript("OnMouseWheel", ScrollFrame_OnMouseWheel)
	scrollframe:SetScript("OnSizeChanged", ScrollFrame_OnSizeChanged)

	local scrollbar = CreateFrame("Slider", ("AceConfigDialogScrollFrame%dScrollBar"):format(num), scrollframe, "UIPanelScrollBarTemplate")
	scrollbar:SetPoint("TOPLEFT", scrollframe, "TOPRIGHT", 4, -16)
	scrollbar:SetPoint("BOTTOMLEFT", scrollframe, "BOTTOMRIGHT", 4, 16)
	scrollbar:SetMinMaxValues(0, 1000)
	scrollbar:SetValueStep(1)
	scrollbar:SetValue(0)
	scrollbar:SetWidth(16)
	scrollbar:Hide()
	-- set the script as the last step, so it doesn't fire yet
	scrollbar:SetScript("OnValueChanged", ScrollBar_OnScrollValueChanged)

	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
	scrollbg:SetAllPoints(scrollbar)
	scrollbg:SetColorTexture(0, 0, 0, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, scrollframe)
	content:SetPoint("TOPLEFT")
	content:SetPoint("TOPRIGHT")
	content:SetHeight(400)
	scrollframe:SetScrollChild(content)

	local widget = {
		localstatus = { scrollvalue = 0 },
		scrollframe = scrollframe,
		scrollbar   = scrollbar,
		content     = content,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	scrollframe.obj, scrollbar.obj = widget, widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-ScrollFrame.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua ===
--[[-----------------------------------------------------------------------------
SimpleGroup Container
Simple container widget that just groups widgets.
-------------------------------------------------------------------------------]]
local Type, Version = "SimpleGroup", 20
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent


--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(300)
		self:SetHeight(100)
	end,

	-- ["OnRelease"] = nil,

	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight(height or 0)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		content:SetWidth(width)
		content.width = width
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		content:SetHeight(height)
		content.height = height
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	--Container Support
	local content = CreateFrame("Frame", nil, frame)
	content:SetPoint("TOPLEFT")
	content:SetPoint("BOTTOMRIGHT")

	local widget = {
		frame     = frame,
		content   = content,
		type      = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-SimpleGroup.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua ===
--[[-----------------------------------------------------------------------------
TabGroup Container
Container that uses tabs on top to switch between groups.
-------------------------------------------------------------------------------]]
local Type, Version = "TabGroup", 38
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs, ipairs, assert, type, wipe = pairs, ipairs, assert, type, table.wipe

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = _G

-- local upvalue storage used by BuildTabs
local widths = {}
local rowwidths = {}
local rowends = {}

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

local function PanelTemplates_TabResize(tab, padding, absoluteSize, minWidth, maxWidth, absoluteTextSize)
	local tabName = tab:GetName();

	local buttonMiddle = tab.Middle or tab.middleTexture or _G[tabName.."Middle"];
	local buttonMiddleDisabled = tab.MiddleDisabled or (tabName and _G[tabName.."MiddleDisabled"]);
	local left = tab.Left or tab.leftTexture or _G[tabName.."Left"];
	local sideWidths = 2 * left:GetWidth();
	local tabText = tab.Text or _G[tab:GetName().."Text"];
	local highlightTexture = tab.HighlightTexture or (tabName and _G[tabName.."HighlightTexture"]);

	local width, tabWidth;
	local textWidth;
	if ( absoluteTextSize ) then
		textWidth = absoluteTextSize;
	else
		tabText:SetWidth(0);
		textWidth = tabText:GetWidth();
	end
	-- If there's an absolute size specified then use it
	if ( absoluteSize ) then
		if ( absoluteSize < sideWidths) then
			width = 1;
			tabWidth = sideWidths
		else
			width = absoluteSize - sideWidths;
			tabWidth = absoluteSize
		end
		tabText:SetWidth(width);
	else
		-- Otherwise try to use padding
		if ( padding ) then
			width = textWidth + padding;
		else
			width = textWidth + 24;
		end
		-- If greater than the maxWidth then cap it
		if ( maxWidth and width > maxWidth ) then
			if ( padding ) then
				width = maxWidth + padding;
			else
				width = maxWidth + 24;
			end
			tabText:SetWidth(width);
		else
			tabText:SetWidth(0);
		end
		if (minWidth and width < minWidth) then
			width = minWidth;
		end
		tabWidth = width + sideWidths;
	end

	if ( buttonMiddle ) then
		buttonMiddle:SetWidth(width);
	end
	if ( buttonMiddleDisabled ) then
		buttonMiddleDisabled:SetWidth(width);
	end

	tab:SetWidth(tabWidth);

	if ( highlightTexture ) then
		highlightTexture:SetWidth(tabWidth);
	end
end

local function PanelTemplates_DeselectTab(tab)
	local name = tab:GetName();

	local left = tab.Left or _G[name.."Left"];
	local middle = tab.Middle or _G[name.."Middle"];
	local right = tab.Right or _G[name.."Right"];
	left:Show();
	middle:Show();
	right:Show();
	--tab:UnlockHighlight();
	tab:Enable();
	local text = tab.Text or _G[name.."Text"];
	text:SetPoint("CENTER", tab, "CENTER", (tab.deselectedTextX or 0), (tab.deselectedTextY or 2));

	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
	leftDisabled:Hide();
	middleDisabled:Hide();
	rightDisabled:Hide();
end

local function PanelTemplates_SelectTab(tab)
	local name = tab:GetName();

	local left = tab.Left or _G[name.."Left"];
	local middle = tab.Middle or _G[name.."Middle"];
	local right = tab.Right or _G[name.."Right"];
	left:Hide();
	middle:Hide();
	right:Hide();
	--tab:LockHighlight();
	tab:Disable();
	tab:SetDisabledFontObject(GameFontHighlightSmall);
	local text = tab.Text or _G[name.."Text"];
	text:SetPoint("CENTER", tab, "CENTER", (tab.selectedTextX or 0), (tab.selectedTextY or -3));

	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
	leftDisabled:Show();
	middleDisabled:Show();
	rightDisabled:Show();

	if GameTooltip:IsOwned(tab) then
		GameTooltip:Hide();
	end
end

local function PanelTemplates_SetDisabledTabState(tab)
	local name = tab:GetName();
	local left = tab.Left or _G[name.."Left"];
	local middle = tab.Middle or _G[name.."Middle"];
	local right = tab.Right or _G[name.."Right"];
	left:Show();
	middle:Show();
	right:Show();
	--tab:UnlockHighlight();
	tab:Disable();
	tab.text = tab:GetText();
	-- Gray out text
	tab:SetDisabledFontObject(GameFontDisableSmall);
	local leftDisabled = tab.LeftDisabled or _G[name.."LeftDisabled"];
	local middleDisabled = tab.MiddleDisabled or _G[name.."MiddleDisabled"];
	local rightDisabled = tab.RightDisabled or _G[name.."RightDisabled"];
	leftDisabled:Hide();
	middleDisabled:Hide();
	rightDisabled:Hide();
end

local function UpdateTabLook(frame)
	if frame.disabled then
		PanelTemplates_SetDisabledTabState(frame)
	elseif frame.selected then
		PanelTemplates_SelectTab(frame)
	else
		PanelTemplates_DeselectTab(frame)
	end
end

local function Tab_SetText(frame, text)
	frame:_SetText(text)
	local width = frame.obj.frame.width or frame.obj.frame:GetWidth() or 0
	PanelTemplates_TabResize(frame, 0, nil, nil, width, frame:GetFontString():GetStringWidth())
end

local function Tab_SetSelected(frame, selected)
	frame.selected = selected
	UpdateTabLook(frame)
end

local function Tab_SetDisabled(frame, disabled)
	frame.disabled = disabled
	UpdateTabLook(frame)
end

local function BuildTabsOnUpdate(frame)
	local self = frame.obj
	self:BuildTabs()
	frame:SetScript("OnUpdate", nil)
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Tab_OnClick(frame)
	if not (frame.selected or frame.disabled) then
		PlaySound(841) -- SOUNDKIT.IG_CHARACTER_INFO_TAB
		frame.obj:SelectTab(frame.value)
	end
end

local function Tab_OnEnter(frame)
	local self = frame.obj
	self:Fire("OnTabEnter", self.tabs[frame.id].value, frame)
end

local function Tab_OnLeave(frame)
	local self = frame.obj
	self:Fire("OnTabLeave", self.tabs[frame.id].value, frame)
end

local function Tab_OnShow(frame)
	_G[frame:GetName().."HighlightTexture"]:SetWidth(frame:GetTextWidth() + 30)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetTitle()
	end,

	["OnRelease"] = function(self)
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
		self.tablist = nil
		for _, tab in pairs(self.tabs) do
			tab:Hide()
		end
	end,

	["CreateTab"] = function(self, id)
		local tabname = ("AceGUITabGroup%dTab%d"):format(self.num, id)
		local tab = CreateFrame("Button", tabname, self.border)
		tab:SetSize(115, 24)
		tab.deselectedTextY = -3
		tab.selectedTextY = -2

		tab.LeftDisabled = tab:CreateTexture(tabname .. "LeftDisabled", "BORDER")
		tab.LeftDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
		tab.LeftDisabled:SetSize(20, 24)
		tab.LeftDisabled:SetPoint("BOTTOMLEFT", 0, -3)
		tab.LeftDisabled:SetTexCoord(0, 0.15625, 0, 1.0)

		tab.MiddleDisabled = tab:CreateTexture(tabname .. "MiddleDisabled", "BORDER")
		tab.MiddleDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
		tab.MiddleDisabled:SetSize(88, 24)
		tab.MiddleDisabled:SetPoint("LEFT", tab.LeftDisabled, "RIGHT")
		tab.MiddleDisabled:SetTexCoord(0.15625, 0.84375, 0, 1.0)

		tab.RightDisabled = tab:CreateTexture(tabname .. "RightDisabled", "BORDER")
		tab.RightDisabled:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-ActiveTab")
		tab.RightDisabled:SetSize(20, 24)
		tab.RightDisabled:SetPoint("LEFT", tab.MiddleDisabled, "RIGHT")
		tab.RightDisabled:SetTexCoord(0.84375, 1.0, 0, 1.0)

		tab.Left = tab:CreateTexture(tabname .. "Left", "BORDER")
		tab.Left:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
		tab.Left:SetSize(20, 24)
		tab.Left:SetPoint("TOPLEFT")
		tab.Left:SetTexCoord(0, 0.15625, 0, 1.0)

		tab.Middle = tab:CreateTexture(tabname .. "Middle", "BORDER")
		tab.Middle:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
		tab.Middle:SetSize(88, 24)
		tab.Middle:SetPoint("LEFT", tab.Left, "RIGHT")
		tab.Middle:SetTexCoord(0.15625, 0.84375, 0, 1.0)

		tab.Right = tab:CreateTexture(tabname .. "Right", "BORDER")
		tab.Right:SetTexture("Interface\\OptionsFrame\\UI-OptionsFrame-InActiveTab")
		tab.Right:SetSize(20, 24)
		tab.Right:SetPoint("LEFT", tab.Middle, "RIGHT")
		tab.Right:SetTexCoord(0.84375, 1.0, 0, 1.0)

		tab.Text = tab:CreateFontString(tabname .. "Text")
		tab:SetFontString(tab.Text)

		tab:SetNormalFontObject(GameFontNormalSmall)
		tab:SetHighlightFontObject(GameFontHighlightSmall)
		tab:SetDisabledFontObject(GameFontHighlightSmall)
		tab:SetHighlightTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight", "ADD")
		tab.HighlightTexture = tab:GetHighlightTexture()
		tab.HighlightTexture:ClearAllPoints()
		tab.HighlightTexture:SetPoint("LEFT", tab, "LEFT", 10, -4)
		tab.HighlightTexture:SetPoint("RIGHT", tab, "RIGHT", -10, -4)
		_G[tabname .. "HighlightTexture"] = tab.HighlightTexture

		tab.obj = self
		tab.id = id

		tab.text = tab.Text -- compat
		tab.text:ClearAllPoints()
		tab.text:SetPoint("LEFT", 14, -3)
		tab.text:SetPoint("RIGHT", -12, -3)

		tab:SetScript("OnClick", Tab_OnClick)
		tab:SetScript("OnEnter", Tab_OnEnter)
		tab:SetScript("OnLeave", Tab_OnLeave)
		tab:SetScript("OnShow", Tab_OnShow)

		tab._SetText = tab.SetText
		tab.SetText = Tab_SetText
		tab.SetSelected = Tab_SetSelected
		tab.SetDisabled = Tab_SetDisabled

		return tab
	end,

	["SetTitle"] = function(self, text)
		self.titletext:SetText(text or "")
		if text and text ~= "" then
			self.alignoffset = 25
		else
			self.alignoffset = 18
		end
		self:BuildTabs()
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
	end,

	["SelectTab"] = function(self, value)
		local status = self.status or self.localstatus
		local found
		for i, v in ipairs(self.tabs) do
			if v.value == value then
				v:SetSelected(true)
				found = true
			else
				v:SetSelected(false)
			end
		end
		status.selected = value
		if found then
			self:Fire("OnGroupSelected",value)
		end
	end,

	["SetTabs"] = function(self, tabs)
		self.tablist = tabs
		self:BuildTabs()
	end,


	["BuildTabs"] = function(self)
		local hastitle = (self.titletext:GetText() and self.titletext:GetText() ~= "")
		local tablist = self.tablist
		local tabs = self.tabs

		if not tablist then return end

		local width = self.frame.width or self.frame:GetWidth() or 0

		wipe(widths)
		wipe(rowwidths)
		wipe(rowends)

		--Place Text into tabs and get thier initial width
		for i, v in ipairs(tablist) do
			local tab = tabs[i]
			if not tab then
				tab = self:CreateTab(i)
				tabs[i] = tab
			end

			tab:Show()
			tab:SetText(v.text)
			tab:SetDisabled(v.disabled)
			tab.value = v.value

			widths[i] = tab:GetWidth() - 6 --tabs are anchored 10 pixels from the right side of the previous one to reduce spacing, but add a fixed 4px padding for the text
		end

		for i = (#tablist)+1, #tabs, 1 do
			tabs[i]:Hide()
		end

		--First pass, find the minimum number of rows needed to hold all tabs and the initial tab layout
		local numtabs = #tablist
		local numrows = 1
		local usedwidth = 0

		for i = 1, #tablist do
			--If this is not the first tab of a row and there isn't room for it
			if usedwidth ~= 0 and (width - usedwidth - widths[i]) < 0 then
				rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
				rowends[numrows] = i - 1
				numrows = numrows + 1
				usedwidth = 0
			end
			usedwidth = usedwidth + widths[i]
		end
		rowwidths[numrows] = usedwidth + 10 --first tab in each row takes up an extra 10px
		rowends[numrows] = #tablist

		--Fix for single tabs being left on the last row, move a tab from the row above if applicable
		if numrows > 1 then
			--if the last row has only one tab
			if rowends[numrows-1] == numtabs-1 then
				--if there are more than 2 tabs in the 2nd last row
				if (numrows == 2 and rowends[numrows-1] > 2) or (rowends[numrows] - rowends[numrows-1] > 2) then
					--move 1 tab from the second last row to the last, if there is enough space
					if (rowwidths[numrows] + widths[numtabs-1]) <= width then
						rowends[numrows-1] = rowends[numrows-1] - 1
						rowwidths[numrows] = rowwidths[numrows] + widths[numtabs-1]
						rowwidths[numrows-1] = rowwidths[numrows-1] - widths[numtabs-1]
					end
				end
			end
		end

		--anchor the rows as defined and resize tabs to fill thier row
		local starttab = 1
		for row, endtab in ipairs(rowends) do
			local first = true
			for tabno = starttab, endtab do
				local tab = tabs[tabno]
				tab:ClearAllPoints()
				if first then
					tab:SetPoint("TOPLEFT", self.frame, "TOPLEFT", 0, -(hastitle and 14 or 7)-(row-1)*20 )
					first = false
				else
					tab:SetPoint("LEFT", tabs[tabno-1], "RIGHT", -10, 0)
				end
			end

			-- equal padding for each tab to fill the available width,
			-- if the used space is above 75% already
			-- the 18 pixel is the typical width of a scrollbar, so we can have a tab group inside a scrolling frame,
			-- and not have the tabs jump around funny when switching between tabs that need scrolling and those that don't
			local padding = 0
			if not (numrows == 1 and rowwidths[1] < width*0.75 - 18) then
				padding = (width - rowwidths[row]) / (endtab - starttab+1)
			end

			for i = starttab, endtab do
				PanelTemplates_TabResize(tabs[i], padding + 4, nil, nil, width, tabs[i]:GetFontString():GetStringWidth())
			end
			starttab = endtab + 1
		end

		self.borderoffset = (hastitle and 17 or 10)+((numrows)*20)
		self.border:SetPoint("TOPLEFT", 1, -self.borderoffset)
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local contentwidth = width - 60
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
		self:BuildTabs(self)
		self.frame:SetScript("OnUpdate", BuildTabsOnUpdate)
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - (self.borderoffset + 23)
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight((height or 0) + (self.borderoffset + 23))
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local function Constructor()
	local num = AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Frame",nil,UIParent)
	frame:SetHeight(100)
	frame:SetWidth(100)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local titletext = frame:CreateFontString(nil,"OVERLAY","GameFontNormal")
	titletext:SetPoint("TOPLEFT", 14, 0)
	titletext:SetPoint("TOPRIGHT", -14, 0)
	titletext:SetJustifyH("LEFT")
	titletext:SetHeight(18)
	titletext:SetText("")

	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
	border:SetPoint("TOPLEFT", 1, -27)
	border:SetPoint("BOTTOMRIGHT", -1, 3)
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	border:SetBackdropBorderColor(0.4, 0.4, 0.4)

	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -7)
	content:SetPoint("BOTTOMRIGHT", -10, 7)

	local widget = {
		num          = num,
		frame        = frame,
		localstatus  = {},
		alignoffset  = 18,
		titletext    = titletext,
		border       = border,
		borderoffset = 27,
		tabs         = {},
		content      = content,
		type         = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-TabGroup.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua ===
--[[-----------------------------------------------------------------------------
TreeGroup Container
Container that uses a tree control to switch between groups.
-------------------------------------------------------------------------------]]
local Type, Version = "TreeGroup", 48
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local next, pairs, ipairs, assert, type = next, pairs, ipairs, assert, type
local math_min, math_max, floor = math.min, math.max, math.floor
local select, tremove, unpack, tconcat = select, table.remove, unpack, table.concat

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

-- Recycling functions
local new, del
do
	local pool = setmetatable({},{__mode='k'})
	function new()
		local t = next(pool)
		if t then
			pool[t] = nil
			return t
		else
			return {}
		end
	end
	function del(t)
		for k in pairs(t) do
			t[k] = nil
		end
		pool[t] = true
	end
end

local DEFAULT_TREE_WIDTH = 175
local DEFAULT_TREE_SIZABLE = true

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function GetButtonUniqueValue(line)
	local parent = line.parent
	if parent and parent.value then
		return GetButtonUniqueValue(parent).."\001"..line.value
	else
		return line.value
	end
end

local function UpdateButton(button, treeline, selected, canExpand, isExpanded)
	local self = button.obj
	local toggle = button.toggle
	local text = treeline.text or ""
	local icon = treeline.icon
	local iconCoords = treeline.iconCoords
	local level = treeline.level
	local value = treeline.value
	local uniquevalue = treeline.uniquevalue
	local disabled = treeline.disabled

	button.treeline = treeline
	button.value = value
	button.uniquevalue = uniquevalue
	if selected then
		button:LockHighlight()
		button.selected = true
	else
		button:UnlockHighlight()
		button.selected = false
	end
	button.level = level
	if ( level == 1 ) then
		button:SetNormalFontObject("GameFontNormal")
		button:SetHighlightFontObject("GameFontHighlight")
		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8, 2)
	else
		button:SetNormalFontObject("GameFontHighlightSmall")
		button:SetHighlightFontObject("GameFontHighlightSmall")
		button.text:SetPoint("LEFT", (icon and 16 or 0) + 8 * level, 2)
	end

	if disabled then
		button:EnableMouse(false)
		button.text:SetText("|cff808080"..text..FONT_COLOR_CODE_CLOSE)
	else
		button.text:SetText(text)
		button:EnableMouse(true)
	end

	if icon then
		button.icon:SetTexture(icon)
		button.icon:SetPoint("LEFT", 8 * level, (level == 1) and 0 or 1)
	else
		button.icon:SetTexture(nil)
	end

	if iconCoords then
		button.icon:SetTexCoord(unpack(iconCoords))
	else
		button.icon:SetTexCoord(0, 1, 0, 1)
	end

	if canExpand then
		if not isExpanded then
			toggle:SetNormalTexture(130838) -- Interface\\Buttons\\UI-PlusButton-UP
			toggle:SetPushedTexture(130836) -- Interface\\Buttons\\UI-PlusButton-DOWN
		else
			toggle:SetNormalTexture(130821) -- Interface\\Buttons\\UI-MinusButton-UP
			toggle:SetPushedTexture(130820) -- Interface\\Buttons\\UI-MinusButton-DOWN
		end
		toggle:Show()
	else
		toggle:Hide()
	end
end

local function ShouldDisplayLevel(tree)
	local result = false
	for k, v in ipairs(tree) do
		if v.children == nil and v.visible ~= false then
			result = true
		elseif v.children then
			result = result or ShouldDisplayLevel(v.children)
		end
		if result then return result end
	end
	return false
end

local function addLine(self, v, tree, level, parent)
	local line = new()
	line.value = v.value
	line.text = v.text
	line.icon = v.icon
	line.iconCoords = v.iconCoords
	line.disabled = v.disabled
	line.tree = tree
	line.level = level
	line.parent = parent
	line.visible = v.visible
	line.uniquevalue = GetButtonUniqueValue(line)
	if v.children then
		line.hasChildren = true
	else
		line.hasChildren = nil
	end
	self.lines[#self.lines+1] = line
	return line
end

--fire an update after one frame to catch the treeframes height
local function FirstFrameUpdate(frame)
	local self = frame.obj
	frame:SetScript("OnUpdate", nil)
	self:RefreshTree(nil, true)
end

local function BuildUniqueValue(...)
	local n = select('#', ...)
	if n == 1 then
		return ...
	else
		return (...).."\001"..BuildUniqueValue(select(2,...))
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Expand_OnClick(frame)
	local button = frame.button
	local self = button.obj
	local status = (self.status or self.localstatus).groups
	status[button.uniquevalue] = not status[button.uniquevalue]
	self:RefreshTree()
end

local function Button_OnClick(frame)
	local self = frame.obj
	self:Fire("OnClick", frame.uniquevalue, frame.selected)
	if not frame.selected then
		self:SetSelected(frame.uniquevalue)
		frame.selected = true
		frame:LockHighlight()
		self:RefreshTree()
	end
	AceGUI:ClearFocus()
end

local function Button_OnDoubleClick(button)
	local self = button.obj
	local status = (self.status or self.localstatus).groups
	status[button.uniquevalue] = not status[button.uniquevalue]
	self:RefreshTree()
end

local function Button_OnEnter(frame)
	local self = frame.obj
	self:Fire("OnButtonEnter", frame.uniquevalue, frame)

	if self.enabletooltips then
		local tooltip = AceGUI.tooltip
		tooltip:SetOwner(frame, "ANCHOR_NONE")
		tooltip:ClearAllPoints()
		tooltip:SetPoint("LEFT",frame,"RIGHT")
		tooltip:SetText(frame.text:GetText() or "", 1, .82, 0, true)

		tooltip:Show()
	end
end

local function Button_OnLeave(frame)
	local self = frame.obj
	self:Fire("OnButtonLeave", frame.uniquevalue, frame)

	if self.enabletooltips then
		AceGUI.tooltip:Hide()
	end
end

local function OnScrollValueChanged(frame, value)
	if frame.obj.noupdate then return end
	local self = frame.obj
	local status = self.status or self.localstatus
	status.scrollvalue = floor(value + 0.5)
	self:RefreshTree()
	AceGUI:ClearFocus()
end

local function Tree_OnSizeChanged(frame)
	frame.obj:RefreshTree()
end

local function Tree_OnMouseWheel(frame, delta)
	local self = frame.obj
	if self.showscroll then
		local scrollbar = self.scrollbar
		local min, max = scrollbar:GetMinMaxValues()
		local value = scrollbar:GetValue()
		local newvalue = math_min(max,math_max(min,value - delta))
		if value ~= newvalue then
			scrollbar:SetValue(newvalue)
		end
	end
end

local function Dragger_OnLeave(frame)
	frame:SetBackdropColor(1, 1, 1, 0)
end

local function Dragger_OnEnter(frame)
	frame:SetBackdropColor(1, 1, 1, 0.8)
end

local function Dragger_OnMouseDown(frame)
	local treeframe = frame:GetParent()
	treeframe:StartSizing("RIGHT")
end

local function Dragger_OnMouseUp(frame)
	local treeframe = frame:GetParent()
	local self = treeframe.obj
	local treeframeParent = treeframe:GetParent()
	treeframe:StopMovingOrSizing()
	--treeframe:SetScript("OnUpdate", nil)
	treeframe:SetUserPlaced(false)
	--Without this :GetHeight will get stuck on the current height, causing the tree contents to not resize
	treeframe:SetHeight(0)
	treeframe:ClearAllPoints()
	treeframe:SetPoint("TOPLEFT", treeframeParent, "TOPLEFT",0,0)
	treeframe:SetPoint("BOTTOMLEFT", treeframeParent, "BOTTOMLEFT",0,0)

	local status = self.status or self.localstatus
	status.treewidth = treeframe:GetWidth()

	treeframe.obj:Fire("OnTreeResize",treeframe:GetWidth())
	-- recalculate the content width
	treeframe.obj:OnWidthSet(status.fullwidth)
	-- update the layout of the content
	treeframe.obj:DoLayout()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetTreeWidth(DEFAULT_TREE_WIDTH, DEFAULT_TREE_SIZABLE)
		self:EnableButtonTooltips(true)
		self.frame:SetScript("OnUpdate", FirstFrameUpdate)
	end,

	["OnRelease"] = function(self)
		self.status = nil
		self.tree = nil
		self.frame:SetScript("OnUpdate", nil)
		for k, v in pairs(self.localstatus) do
			if k == "groups" then
				for k2 in pairs(v) do
					v[k2] = nil
				end
			else
				self.localstatus[k] = nil
			end
		end
		self.localstatus.scrollvalue = 0
		self.localstatus.treewidth = DEFAULT_TREE_WIDTH
		self.localstatus.treesizable = DEFAULT_TREE_SIZABLE
	end,

	["EnableButtonTooltips"] = function(self, enable)
		self.enabletooltips = enable
	end,

	["CreateButton"] = function(self)
		local num = AceGUI:GetNextWidgetNum("TreeGroupButton")
		local button = CreateFrame("Button", ("AceGUI30TreeButton%d"):format(num), self.treeframe, "OptionsListButtonTemplate")
		button.obj = self

		local icon = button:CreateTexture(nil, "OVERLAY")
		icon:SetWidth(14)
		icon:SetHeight(14)
		button.icon = icon

		button:SetScript("OnClick",Button_OnClick)
		button:SetScript("OnDoubleClick", Button_OnDoubleClick)
		button:SetScript("OnEnter",Button_OnEnter)
		button:SetScript("OnLeave",Button_OnLeave)

		button.toggle.button = button
		button.toggle:SetScript("OnClick",Expand_OnClick)

		button.text:SetHeight(14) -- Prevents text wrapping

		return button
	end,

	["SetStatusTable"] = function(self, status)
		assert(type(status) == "table")
		self.status = status
		if not status.groups then
			status.groups = {}
		end
		if not status.scrollvalue then
			status.scrollvalue = 0
		end
		if not status.treewidth then
			status.treewidth = DEFAULT_TREE_WIDTH
		end
		if status.treesizable == nil then
			status.treesizable = DEFAULT_TREE_SIZABLE
		end
		self:SetTreeWidth(status.treewidth,status.treesizable)
		self:RefreshTree()
	end,

	--sets the tree to be displayed
	["SetTree"] = function(self, tree, filter)
		self.filter = filter
		if tree then
			assert(type(tree) == "table")
		end
		self.tree = tree
		self:RefreshTree()
	end,

	["BuildLevel"] = function(self, tree, level, parent)
		local groups = (self.status or self.localstatus).groups

		for i, v in ipairs(tree) do
			if v.children then
				if not self.filter or ShouldDisplayLevel(v.children) then
					local line = addLine(self, v, tree, level, parent)
					if groups[line.uniquevalue] then
						self:BuildLevel(v.children, level+1, line)
					end
				end
			elseif v.visible ~= false or not self.filter then
				addLine(self, v, tree, level, parent)
			end
		end
	end,

	["RefreshTree"] = function(self,scrollToSelection,fromOnUpdate)
		local buttons = self.buttons
		local lines = self.lines
		while lines[1] do
			local t = tremove(lines)
			for k in pairs(t) do
				t[k] = nil
			end
			del(t)
		end

		if not self.tree then return end
		--Build the list of visible entries from the tree and status tables
		local status = self.status or self.localstatus
		local groupstatus = status.groups
		local tree = self.tree

		local treeframe = self.treeframe

		status.scrollToSelection = status.scrollToSelection or scrollToSelection	-- needs to be cached in case the control hasn't been drawn yet (code bails out below)

		self:BuildLevel(tree, 1)

		local numlines = #lines

		local maxlines = (floor(((self.treeframe:GetHeight()or 0) - 20 ) / 18))
		if maxlines <= 0 then return end

		if self.frame:GetParent() == UIParent and not fromOnUpdate then
			self.frame:SetScript("OnUpdate", FirstFrameUpdate)
			return
		end

		local first, last

		scrollToSelection = status.scrollToSelection
		status.scrollToSelection = nil

		if numlines <= maxlines then
			--the whole tree fits in the frame
			status.scrollvalue = 0
			self:ShowScroll(false)
			first, last = 1, numlines
		else
			self:ShowScroll(true)
			--scrolling will be needed
			self.noupdate = true
			self.scrollbar:SetMinMaxValues(0, numlines - maxlines)
			--check if we are scrolled down too far
			if numlines - status.scrollvalue < maxlines then
				status.scrollvalue = numlines - maxlines
			end
			self.noupdate = nil
			first, last = status.scrollvalue+1, status.scrollvalue + maxlines
			--show selection?
			if scrollToSelection and status.selected then
				local show
				for i,line in ipairs(lines) do	-- find the line number
					if line.uniquevalue==status.selected then
						show=i
					end
				end
				if not show then
					-- selection was deleted or something?
				elseif show>=first and show<=last then
					-- all good
				else
					-- scrolling needed!
					if show<first then
						status.scrollvalue = show-1
					else
						status.scrollvalue = show-maxlines
					end
					first, last = status.scrollvalue+1, status.scrollvalue + maxlines
				end
			end
			if self.scrollbar:GetValue() ~= status.scrollvalue then
				self.scrollbar:SetValue(status.scrollvalue)
			end
		end

		local buttonnum = 1
		for i = first, last do
			local line = lines[i]
			local button = buttons[buttonnum]
			if not button then
				button = self:CreateButton()

				buttons[buttonnum] = button
				button:SetParent(treeframe)
				button:SetFrameLevel(treeframe:GetFrameLevel()+1)
				button:ClearAllPoints()
				if buttonnum == 1 then
					if self.showscroll then
						button:SetPoint("TOPRIGHT", -22, -10)
						button:SetPoint("TOPLEFT", 0, -10)
					else
						button:SetPoint("TOPRIGHT", 0, -10)
						button:SetPoint("TOPLEFT", 0, -10)
					end
				else
					button:SetPoint("TOPRIGHT", buttons[buttonnum-1], "BOTTOMRIGHT",0,0)
					button:SetPoint("TOPLEFT", buttons[buttonnum-1], "BOTTOMLEFT",0,0)
				end
			end

			UpdateButton(button, line, status.selected == line.uniquevalue, line.hasChildren, groupstatus[line.uniquevalue] )
			button:Show()
			buttonnum = buttonnum + 1
		end

		-- We hide the remaining buttons after updating others to avoid a blizzard bug that keeps them interactable even if hidden when hidden before updating the buttons.
		for i = buttonnum, #buttons do
			buttons[i]:Hide()
		end
	end,

	["SetSelected"] = function(self, value)
		local status = self.status or self.localstatus
		if status.selected ~= value then
			status.selected = value
			self:Fire("OnGroupSelected", value)
		end
	end,

	["Select"] = function(self, uniquevalue, ...)
		self.filter = false
		local status = self.status or self.localstatus
		local groups = status.groups
		local path = {...}
		for i = 1, #path do
			groups[tconcat(path, "\001", 1, i)] = true
		end
		status.selected = uniquevalue
		self:RefreshTree(true)
		self:Fire("OnGroupSelected", uniquevalue)
	end,

	["SelectByPath"] = function(self, ...)
		self:Select(BuildUniqueValue(...), ...)
	end,

	["SelectByValue"] = function(self, uniquevalue)
		self:Select(uniquevalue, ("\001"):split(uniquevalue))
	end,

	["ShowScroll"] = function(self, show)
		self.showscroll = show
		if show then
			self.scrollbar:Show()
			if self.buttons[1] then
				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",-22,-10)
			end
		else
			self.scrollbar:Hide()
			if self.buttons[1] then
				self.buttons[1]:SetPoint("TOPRIGHT", self.treeframe,"TOPRIGHT",0,-10)
			end
		end
	end,

	["OnWidthSet"] = function(self, width)
		local content = self.content
		local treeframe = self.treeframe
		local status = self.status or self.localstatus
		status.fullwidth = width

		local contentwidth = width - status.treewidth - 20
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth

		local maxtreewidth = math_min(400, width - 50)

		if maxtreewidth > 100 and status.treewidth > maxtreewidth then
			self:SetTreeWidth(maxtreewidth, status.treesizable)
		end
		if treeframe.SetResizeBounds then
			treeframe:SetResizeBounds(100, 1, maxtreewidth, 1600)
		else
			treeframe:SetMaxResize(maxtreewidth, 1600)
		end
	end,

	["OnHeightSet"] = function(self, height)
		local content = self.content
		local contentheight = height - 20
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end,

	["SetTreeWidth"] = function(self, treewidth, resizable)
		if not resizable then
			if type(treewidth) == 'number' then
				resizable = false
			elseif type(treewidth) == 'boolean' then
				resizable = treewidth
				treewidth = DEFAULT_TREE_WIDTH
			else
				resizable = false
				treewidth = DEFAULT_TREE_WIDTH
			end
		end
		self.treeframe:SetWidth(treewidth)
		self.dragger:EnableMouse(resizable)

		local status = self.status or self.localstatus
		status.treewidth = treewidth
		status.treesizable = resizable

		-- recalculate the content width
		if status.fullwidth then
			self:OnWidthSet(status.fullwidth)
		end
	end,

	["GetTreeWidth"] = function(self)
		local status = self.status or self.localstatus
		return status.treewidth or DEFAULT_TREE_WIDTH
	end,

	["LayoutFinished"] = function(self, width, height)
		if self.noAutoHeight then return end
		self:SetHeight((height or 0) + 20)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local PaneBackdrop  = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 5, bottom = 3 }
}

local DraggerBackdrop  = {
	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
	edgeFile = nil,
	tile = true, tileSize = 16, edgeSize = 1,
	insets = { left = 3, right = 3, top = 7, bottom = 7 }
}

local function Constructor()
	local num = AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Frame", nil, UIParent)

	local treeframe = CreateFrame("Frame", nil, frame, "BackdropTemplate")
	treeframe:SetPoint("TOPLEFT")
	treeframe:SetPoint("BOTTOMLEFT")
	treeframe:SetWidth(DEFAULT_TREE_WIDTH)
	treeframe:EnableMouseWheel(true)
	treeframe:SetBackdrop(PaneBackdrop)
	treeframe:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	treeframe:SetBackdropBorderColor(0.4, 0.4, 0.4)
	treeframe:SetResizable(true)
	if treeframe.SetResizeBounds then -- WoW 10.0
		treeframe:SetResizeBounds(100, 1, 400, 1600)
	else
		treeframe:SetMinResize(100, 1)
		treeframe:SetMaxResize(400, 1600)
	end
	treeframe:SetScript("OnUpdate", FirstFrameUpdate)
	treeframe:SetScript("OnSizeChanged", Tree_OnSizeChanged)
	treeframe:SetScript("OnMouseWheel", Tree_OnMouseWheel)

	local dragger = CreateFrame("Frame", nil, treeframe, "BackdropTemplate")
	dragger:SetWidth(8)
	dragger:SetPoint("TOP", treeframe, "TOPRIGHT")
	dragger:SetPoint("BOTTOM", treeframe, "BOTTOMRIGHT")
	dragger:SetBackdrop(DraggerBackdrop)
	dragger:SetBackdropColor(1, 1, 1, 0)
	dragger:SetScript("OnEnter", Dragger_OnEnter)
	dragger:SetScript("OnLeave", Dragger_OnLeave)
	dragger:SetScript("OnMouseDown", Dragger_OnMouseDown)
	dragger:SetScript("OnMouseUp", Dragger_OnMouseUp)

	local scrollbar = CreateFrame("Slider", ("AceConfigDialogTreeGroup%dScrollBar"):format(num), treeframe, "UIPanelScrollBarTemplate")
	scrollbar:SetScript("OnValueChanged", nil)
	scrollbar:SetPoint("TOPRIGHT", -10, -26)
	scrollbar:SetPoint("BOTTOMRIGHT", -10, 26)
	scrollbar:SetMinMaxValues(0,0)
	scrollbar:SetValueStep(1)
	scrollbar:SetValue(0)
	scrollbar:SetWidth(16)
	scrollbar:SetScript("OnValueChanged", OnScrollValueChanged)

	local scrollbg = scrollbar:CreateTexture(nil, "BACKGROUND")
	scrollbg:SetAllPoints(scrollbar)
	scrollbg:SetColorTexture(0,0,0,0.4)

	local border = CreateFrame("Frame", nil, frame, "BackdropTemplate")
	border:SetPoint("TOPLEFT", treeframe, "TOPRIGHT")
	border:SetPoint("BOTTOMRIGHT")
	border:SetBackdrop(PaneBackdrop)
	border:SetBackdropColor(0.1, 0.1, 0.1, 0.5)
	border:SetBackdropBorderColor(0.4, 0.4, 0.4)

	--Container Support
	local content = CreateFrame("Frame", nil, border)
	content:SetPoint("TOPLEFT", 10, -10)
	content:SetPoint("BOTTOMRIGHT", -10, 10)

	local widget = {
		frame        = frame,
		lines        = {},
		levels       = {},
		buttons      = {},
		hasChildren  = {},
		localstatus  = { groups = {}, scrollvalue = 0 },
		filter       = false,
		treeframe    = treeframe,
		dragger      = dragger,
		scrollbar    = scrollbar,
		border       = border,
		content      = content,
		type         = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	treeframe.obj, dragger.obj, scrollbar.obj = widget, widget, widget

	return AceGUI:RegisterAsContainer(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-TreeGroup.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-Window.lua ===
local AceGUI = LibStub("AceGUI-3.0")

-- Lua APIs
local pairs, assert, type = pairs, assert, type

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

----------------
-- Main Frame --
----------------
--[[
	Events :
		OnClose

]]
do
	local Type = "Window"
	local Version = 8

	local function frameOnShow(this)
		this.obj:Fire("OnShow")
	end

	local function frameOnClose(this)
		this.obj:Fire("OnClose")
	end

	local function closeOnClick(this)
		PlaySound(799) -- SOUNDKIT.GS_TITLE_OPTION_EXIT
		this.obj:Hide()
	end

	local function frameOnMouseDown(this)
		AceGUI:ClearFocus()
	end

	local function titleOnMouseDown(this)
		this:GetParent():StartMoving()
		AceGUI:ClearFocus()
	end

	local function frameOnMouseUp(this)
		local frame = this:GetParent()
		frame:StopMovingOrSizing()
		local self = frame.obj
		local status = self.status or self.localstatus
		status.width = frame:GetWidth()
		status.height = frame:GetHeight()
		status.top = frame:GetTop()
		status.left = frame:GetLeft()
	end

	local function sizerseOnMouseDown(this)
		this:GetParent():StartSizing("BOTTOMRIGHT")
		AceGUI:ClearFocus()
	end

	local function sizersOnMouseDown(this)
		this:GetParent():StartSizing("BOTTOM")
		AceGUI:ClearFocus()
	end

	local function sizereOnMouseDown(this)
		this:GetParent():StartSizing("RIGHT")
		AceGUI:ClearFocus()
	end

	local function sizerOnMouseUp(this)
		this:GetParent():StopMovingOrSizing()
	end

	local function SetTitle(self,title)
		self.titletext:SetText(title)
	end

	local function SetStatusText(self,text)
		-- self.statustext:SetText(text)
	end

	local function Hide(self)
		self.frame:Hide()
	end

	local function Show(self)
		self.frame:Show()
	end

	local function OnAcquire(self)
		self.frame:SetParent(UIParent)
		self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
		self:ApplyStatus()
		self:EnableResize(true)
		self:Show()
	end

	local function OnRelease(self)
		self.status = nil
		for k in pairs(self.localstatus) do
			self.localstatus[k] = nil
		end
	end

	-- called to set an external table to store status in
	local function SetStatusTable(self, status)
		assert(type(status) == "table")
		self.status = status
		self:ApplyStatus()
	end

	local function ApplyStatus(self)
		local status = self.status or self.localstatus
		local frame = self.frame
		self:SetWidth(status.width or 700)
		self:SetHeight(status.height or 500)
		if status.top and status.left then
			frame:SetPoint("TOP",UIParent,"BOTTOM",0,status.top)
			frame:SetPoint("LEFT",UIParent,"LEFT",status.left,0)
		else
			frame:SetPoint("CENTER",UIParent,"CENTER")
		end
	end

	local function OnWidthSet(self, width)
		local content = self.content
		local contentwidth = width - 34
		if contentwidth < 0 then
			contentwidth = 0
		end
		content:SetWidth(contentwidth)
		content.width = contentwidth
	end


	local function OnHeightSet(self, height)
		local content = self.content
		local contentheight = height - 57
		if contentheight < 0 then
			contentheight = 0
		end
		content:SetHeight(contentheight)
		content.height = contentheight
	end

	local function EnableResize(self, state)
		local func = state and "Show" or "Hide"
		self.sizer_se[func](self.sizer_se)
		self.sizer_s[func](self.sizer_s)
		self.sizer_e[func](self.sizer_e)
	end

	local function Constructor()
		local frame = CreateFrame("Frame",nil,UIParent)
		local self = {}
		self.type = "Window"

		self.Hide = Hide
		self.Show = Show
		self.SetTitle =  SetTitle
		self.OnRelease = OnRelease
		self.OnAcquire = OnAcquire
		self.SetStatusText = SetStatusText
		self.SetStatusTable = SetStatusTable
		self.ApplyStatus = ApplyStatus
		self.OnWidthSet = OnWidthSet
		self.OnHeightSet = OnHeightSet
		self.EnableResize = EnableResize

		self.localstatus = {}

		self.frame = frame
		frame.obj = self
		frame:SetWidth(700)
		frame:SetHeight(500)
		frame:SetPoint("CENTER",UIParent,"CENTER",0,0)
		frame:EnableMouse()
		frame:SetMovable(true)
		frame:SetResizable(true)
		frame:SetFrameStrata("FULLSCREEN_DIALOG")
		frame:SetScript("OnMouseDown", frameOnMouseDown)

		frame:SetScript("OnShow",frameOnShow)
		frame:SetScript("OnHide",frameOnClose)
		if frame.SetResizeBounds then -- WoW 10.0
			frame:SetResizeBounds(240,240)
		else
			frame:SetMinResize(240,240)
		end
		frame:SetToplevel(true)

		local titlebg = frame:CreateTexture(nil, "BACKGROUND")
		titlebg:SetTexture(251966) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Title-Background
		titlebg:SetPoint("TOPLEFT", 9, -6)
		titlebg:SetPoint("BOTTOMRIGHT", frame, "TOPRIGHT", -28, -24)

		local dialogbg = frame:CreateTexture(nil, "BACKGROUND")
		dialogbg:SetTexture(137056) -- Interface\\Tooltips\\UI-Tooltip-Background
		dialogbg:SetPoint("TOPLEFT", 8, -24)
		dialogbg:SetPoint("BOTTOMRIGHT", -6, 8)
		dialogbg:SetVertexColor(0, 0, 0, .75)

		local topleft = frame:CreateTexture(nil, "BORDER")
		topleft:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		topleft:SetWidth(64)
		topleft:SetHeight(64)
		topleft:SetPoint("TOPLEFT")
		topleft:SetTexCoord(0.501953125, 0.625, 0, 1)

		local topright = frame:CreateTexture(nil, "BORDER")
		topright:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		topright:SetWidth(64)
		topright:SetHeight(64)
		topright:SetPoint("TOPRIGHT")
		topright:SetTexCoord(0.625, 0.75, 0, 1)

		local top = frame:CreateTexture(nil, "BORDER")
		top:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		top:SetHeight(64)
		top:SetPoint("TOPLEFT", topleft, "TOPRIGHT")
		top:SetPoint("TOPRIGHT", topright, "TOPLEFT")
		top:SetTexCoord(0.25, 0.369140625, 0, 1)

		local bottomleft = frame:CreateTexture(nil, "BORDER")
		bottomleft:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		bottomleft:SetWidth(64)
		bottomleft:SetHeight(64)
		bottomleft:SetPoint("BOTTOMLEFT")
		bottomleft:SetTexCoord(0.751953125, 0.875, 0, 1)

		local bottomright = frame:CreateTexture(nil, "BORDER")
		bottomright:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		bottomright:SetWidth(64)
		bottomright:SetHeight(64)
		bottomright:SetPoint("BOTTOMRIGHT")
		bottomright:SetTexCoord(0.875, 1, 0, 1)

		local bottom = frame:CreateTexture(nil, "BORDER")
		bottom:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		bottom:SetHeight(64)
		bottom:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMRIGHT")
		bottom:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMLEFT")
		bottom:SetTexCoord(0.376953125, 0.498046875, 0, 1)

		local left = frame:CreateTexture(nil, "BORDER")
		left:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		left:SetWidth(64)
		left:SetPoint("TOPLEFT", topleft, "BOTTOMLEFT")
		left:SetPoint("BOTTOMLEFT", bottomleft, "TOPLEFT")
		left:SetTexCoord(0.001953125, 0.125, 0, 1)

		local right = frame:CreateTexture(nil, "BORDER")
		right:SetTexture(251963) -- Interface\\PaperDollInfoFrame\\UI-GearManager-Border
		right:SetWidth(64)
		right:SetPoint("TOPRIGHT", topright, "BOTTOMRIGHT")
		right:SetPoint("BOTTOMRIGHT", bottomright, "TOPRIGHT")
		right:SetTexCoord(0.1171875, 0.2421875, 0, 1)

		local close = CreateFrame("Button", nil, frame, "UIPanelCloseButton")
		close:SetPoint("TOPRIGHT", 2, 1)
		close:SetScript("OnClick", closeOnClick)
		self.closebutton = close
		close.obj = self

		local titletext = frame:CreateFontString(nil, "ARTWORK")
		titletext:SetFontObject(GameFontNormal)
		titletext:SetPoint("TOPLEFT", 12, -8)
		titletext:SetPoint("TOPRIGHT", -32, -8)
		self.titletext = titletext

		local title = CreateFrame("Button", nil, frame)
		title:SetPoint("TOPLEFT", titlebg)
		title:SetPoint("BOTTOMRIGHT", titlebg)
		title:EnableMouse()
		title:SetScript("OnMouseDown",titleOnMouseDown)
		title:SetScript("OnMouseUp", frameOnMouseUp)
		self.title = title

		local sizer_se = CreateFrame("Frame",nil,frame)
		sizer_se:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,0)
		sizer_se:SetWidth(25)
		sizer_se:SetHeight(25)
		sizer_se:EnableMouse()
		sizer_se:SetScript("OnMouseDown",sizerseOnMouseDown)
		sizer_se:SetScript("OnMouseUp", sizerOnMouseUp)
		self.sizer_se = sizer_se

		local line1 = sizer_se:CreateTexture(nil, "BACKGROUND")
		self.line1 = line1
		line1:SetWidth(14)
		line1:SetHeight(14)
		line1:SetPoint("BOTTOMRIGHT", -8, 8)
		line1:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
		local x = 0.1 * 14/17
		line1:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)

		local line2 = sizer_se:CreateTexture(nil, "BACKGROUND")
		self.line2 = line2
		line2:SetWidth(8)
		line2:SetHeight(8)
		line2:SetPoint("BOTTOMRIGHT", -8, 8)
		line2:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
		x = 0.1 * 8/17
		line2:SetTexCoord(0.05 - x, 0.5, 0.05, 0.5 + x, 0.05, 0.5 - x, 0.5 + x, 0.5)

		local sizer_s = CreateFrame("Frame",nil,frame)
		sizer_s:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-25,0)
		sizer_s:SetPoint("BOTTOMLEFT",frame,"BOTTOMLEFT",0,0)
		sizer_s:SetHeight(25)
		sizer_s:EnableMouse()
		sizer_s:SetScript("OnMouseDown",sizersOnMouseDown)
		sizer_s:SetScript("OnMouseUp", sizerOnMouseUp)
		self.sizer_s = sizer_s

		local sizer_e = CreateFrame("Frame",nil,frame)
		sizer_e:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",0,25)
		sizer_e:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
		sizer_e:SetWidth(25)
		sizer_e:EnableMouse()
		sizer_e:SetScript("OnMouseDown",sizereOnMouseDown)
		sizer_e:SetScript("OnMouseUp", sizerOnMouseUp)
		self.sizer_e = sizer_e

		--Container Support
		local content = CreateFrame("Frame",nil,frame)
		self.content = content
		content.obj = self
		content:SetPoint("TOPLEFT",frame,"TOPLEFT",12,-32)
		content:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-12,13)

		AceGUI:RegisterAsContainer(self)
		return self
	end

	AceGUI:RegisterWidgetType(Type,Constructor,Version)
end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIContainer-Window.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Button.lua ===
--[[-----------------------------------------------------------------------------
Button Widget
Graphical Button.
-------------------------------------------------------------------------------]]
local Type, Version = "Button", 24
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local _G = _G
local PlaySound, CreateFrame, UIParent = PlaySound, CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Button_OnClick(frame, ...)
	AceGUI:ClearFocus()
	PlaySound(852) -- SOUNDKIT.IG_MAINMENU_OPTION
	frame.obj:Fire("OnClick", ...)
end

local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		-- restore default values
		self:SetHeight(24)
		self:SetWidth(200)
		self:SetDisabled(false)
		self:SetAutoWidth(false)
		self:SetText()
	end,

	-- ["OnRelease"] = nil,

	["SetText"] = function(self, text)
		self.text:SetText(text)
		if self.autoWidth then
			self:SetWidth(self.text:GetStringWidth() + 30)
		end
	end,

	["SetAutoWidth"] = function(self, autoWidth)
		self.autoWidth = autoWidth
		if self.autoWidth then
			self:SetWidth(self.text:GetStringWidth() + 30)
		end
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
		else
			self.frame:Enable()
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local name = "AceGUI30Button" .. AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Button", name, UIParent, "UIPanelButtonTemplate")
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnClick", Button_OnClick)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)

	local text = frame:GetFontString()
	text:ClearAllPoints()
	text:SetPoint("TOPLEFT", 15, -1)
	text:SetPoint("BOTTOMRIGHT", -15, 1)
	text:SetJustifyV("MIDDLE")

	local widget = {
		text  = text,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Button.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua ===
--[[-----------------------------------------------------------------------------
Checkbox Widget
-------------------------------------------------------------------------------]]
local Type, Version = "CheckBox", 26
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local select, pairs = select, pairs

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function AlignImage(self)
	local img = self.image:GetTexture()
	self.text:ClearAllPoints()
	if not img then
		self.text:SetPoint("LEFT", self.checkbg, "RIGHT")
		self.text:SetPoint("RIGHT")
	else
		self.text:SetPoint("LEFT", self.image, "RIGHT", 1, 0)
		self.text:SetPoint("RIGHT")
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function CheckBox_OnMouseDown(frame)
	local self = frame.obj
	if not self.disabled then
		if self.image:GetTexture() then
			self.text:SetPoint("LEFT", self.image,"RIGHT", 2, -1)
		else
			self.text:SetPoint("LEFT", self.checkbg, "RIGHT", 1, -1)
		end
	end
	AceGUI:ClearFocus()
end

local function CheckBox_OnMouseUp(frame)
	local self = frame.obj
	if not self.disabled then
		self:ToggleChecked()

		if self.checked then
			PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
		else -- for both nil and false (tristate)
			PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
		end

		self:Fire("OnValueChanged", self.checked)
		AlignImage(self)
	end
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetType()
		self:SetValue(false)
		self:SetTriState(nil)
		-- height is calculated from the width and required space for the description
		self:SetWidth(200)
		self:SetImage()
		self:SetDisabled(nil)
		self:SetDescription(nil)
	end,

	-- ["OnRelease"] = nil,

	["OnWidthSet"] = function(self, width)
		if self.desc then
			self.desc:SetWidth(width - 30)
			if self.desc:GetText() and self.desc:GetText() ~= "" then
				self:SetHeight(28 + self.desc:GetStringHeight())
			end
		end
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.text:SetTextColor(0.5, 0.5, 0.5)
			SetDesaturation(self.check, true)
			if self.desc then
				self.desc:SetTextColor(0.5, 0.5, 0.5)
			end
		else
			self.frame:Enable()
			self.text:SetTextColor(1, 1, 1)
			if self.tristate and self.checked == nil then
				SetDesaturation(self.check, true)
			else
				SetDesaturation(self.check, false)
			end
			if self.desc then
				self.desc:SetTextColor(1, 1, 1)
			end
		end
	end,

	["SetValue"] = function(self, value)
		local check = self.check
		self.checked = value
		if value then
			SetDesaturation(check, false)
			check:Show()
		else
			--Nil is the unknown tristate value
			if self.tristate and value == nil then
				SetDesaturation(check, true)
				check:Show()
			else
				SetDesaturation(check, false)
				check:Hide()
			end
		end
		self:SetDisabled(self.disabled)
	end,

	["GetValue"] = function(self)
		return self.checked
	end,

	["SetTriState"] = function(self, enabled)
		self.tristate = enabled
		self:SetValue(self:GetValue())
	end,

	["SetType"] = function(self, type)
		local checkbg = self.checkbg
		local check = self.check
		local highlight = self.highlight

		local size
		if type == "radio" then
			size = 16
			checkbg:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
			checkbg:SetTexCoord(0, 0.25, 0, 1)
			check:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
			check:SetTexCoord(0.25, 0.5, 0, 1)
			check:SetBlendMode("ADD")
			highlight:SetTexture(130843) -- Interface\\Buttons\\UI-RadioButton
			highlight:SetTexCoord(0.5, 0.75, 0, 1)
		else
			size = 24
			checkbg:SetTexture(130755) -- Interface\\Buttons\\UI-CheckBox-Up
			checkbg:SetTexCoord(0, 1, 0, 1)
			check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
			check:SetTexCoord(0, 1, 0, 1)
			check:SetBlendMode("BLEND")
			highlight:SetTexture(130753) -- Interface\\Buttons\\UI-CheckBox-Highlight
			highlight:SetTexCoord(0, 1, 0, 1)
		end
		checkbg:SetHeight(size)
		checkbg:SetWidth(size)
	end,

	["ToggleChecked"] = function(self)
		local value = self:GetValue()
		if self.tristate then
			--cycle in true, nil, false order
			if value then
				self:SetValue(nil)
			elseif value == nil then
				self:SetValue(false)
			else
				self:SetValue(true)
			end
		else
			self:SetValue(not self:GetValue())
		end
	end,

	["SetLabel"] = function(self, label)
		self.text:SetText(label)
	end,

	["SetDescription"] = function(self, desc)
		if desc then
			if not self.desc then
				local f = self.frame:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
				f:ClearAllPoints()
				f:SetPoint("TOPLEFT", self.checkbg, "TOPRIGHT", 5, -21)
				f:SetWidth(self.frame.width - 30)
				f:SetPoint("RIGHT", self.frame, "RIGHT", -30, 0)
				f:SetJustifyH("LEFT")
				f:SetJustifyV("TOP")
				self.desc = f
			end
			self.desc:Show()
			--self.text:SetFontObject(GameFontNormal)
			self.desc:SetText(desc)
			self:SetHeight(28 + self.desc:GetStringHeight())
		else
			if self.desc then
				self.desc:SetText("")
				self.desc:Hide()
			end
			--self.text:SetFontObject(GameFontHighlight)
			self:SetHeight(24)
		end
	end,

	["SetImage"] = function(self, path, ...)
		local image = self.image
		image:SetTexture(path)

		if image:GetTexture() then
			local n = select("#", ...)
			if n == 4 or n == 8 then
				image:SetTexCoord(...)
			else
				image:SetTexCoord(0, 1, 0, 1)
			end
		end
		AlignImage(self)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Button", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnMouseDown", CheckBox_OnMouseDown)
	frame:SetScript("OnMouseUp", CheckBox_OnMouseUp)

	local checkbg = frame:CreateTexture(nil, "ARTWORK")
	checkbg:SetWidth(24)
	checkbg:SetHeight(24)
	checkbg:SetPoint("TOPLEFT")
	checkbg:SetTexture(130755) -- Interface\\Buttons\\UI-CheckBox-Up

	local check = frame:CreateTexture(nil, "OVERLAY")
	check:SetAllPoints(checkbg)
	check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check

	local text = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
	text:SetJustifyH("LEFT")
	text:SetHeight(18)
	text:SetPoint("LEFT", checkbg, "RIGHT")
	text:SetPoint("RIGHT")

	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	highlight:SetTexture(130753) -- Interface\\Buttons\\UI-CheckBox-Highlight
	highlight:SetBlendMode("ADD")
	highlight:SetAllPoints(checkbg)

	local image = frame:CreateTexture(nil, "OVERLAY")
	image:SetHeight(16)
	image:SetWidth(16)
	image:SetPoint("LEFT", checkbg, "RIGHT", 1, 0)

	local widget = {
		checkbg   = checkbg,
		check     = check,
		text      = text,
		highlight = highlight,
		image     = image,
		frame     = frame,
		type      = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-CheckBox.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua ===
--[[-----------------------------------------------------------------------------
ColorPicker Widget
-------------------------------------------------------------------------------]]
local Type, Version = "ColorPicker", 28
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

-- Unfortunately we have no way to realistically detect if a client uses inverted alpha
-- as no API will tell you. Wrath uses the old colorpicker, era uses the new one, both are inverted
local INVERTED_ALPHA = (WOW_PROJECT_ID ~= WOW_PROJECT_MAINLINE)

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function ColorCallback(self, r, g, b, a, isAlpha)
	if INVERTED_ALPHA and a then
		a = 1 - a
	end
	if not self.HasAlpha then
		a = 1
	end
	-- no change, skip update
	if r == self.r and g == self.g and b == self.b and a == self.a then
		return
	end
	self:SetColor(r, g, b, a)
	if ColorPickerFrame:IsVisible() then
		--colorpicker is still open
		self:Fire("OnValueChanged", r, g, b, a)
	else
		--colorpicker is closed, color callback is first, ignore it,
		--alpha callback is the final call after it closes so confirm now
		if isAlpha then
			self:Fire("OnValueConfirmed", r, g, b, a)
		end
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function ColorSwatch_OnClick(frame)
	ColorPickerFrame:Hide()
	local self = frame.obj
	if not self.disabled then
		ColorPickerFrame:SetFrameStrata("FULLSCREEN_DIALOG")
		ColorPickerFrame:SetFrameLevel(frame:GetFrameLevel() + 10)
		ColorPickerFrame:SetClampedToScreen(true)

		if ColorPickerFrame.SetupColorPickerAndShow then -- 10.2.5 color picker overhaul
			local r2, g2, b2, a2 = self.r, self.g, self.b, (self.a or 1)
			if INVERTED_ALPHA then
				a2 = 1 - a2
			end

			local info = {
				swatchFunc = function()
					local r, g, b = ColorPickerFrame:GetColorRGB()
					local a = ColorPickerFrame:GetColorAlpha()
					ColorCallback(self, r, g, b, a)
				end,

				hasOpacity = self.HasAlpha,
				opacityFunc = function()
					local r, g, b = ColorPickerFrame:GetColorRGB()
					local a = ColorPickerFrame:GetColorAlpha()
					ColorCallback(self, r, g, b, a, true)
				end,
				opacity = a2,

				cancelFunc = function()
					ColorCallback(self, r2, g2, b2, a2, true)
				end,

				r = r2,
				g = g2,
				b = b2,
			}

			ColorPickerFrame:SetupColorPickerAndShow(info)
		else
			ColorPickerFrame.func = function()
				local r, g, b = ColorPickerFrame:GetColorRGB()
				local a = OpacitySliderFrame:GetValue()
				ColorCallback(self, r, g, b, a)
			end

			ColorPickerFrame.hasOpacity = self.HasAlpha
			ColorPickerFrame.opacityFunc = function()
				local r, g, b = ColorPickerFrame:GetColorRGB()
				local a = OpacitySliderFrame:GetValue()
				ColorCallback(self, r, g, b, a, true)
			end

			local r, g, b, a = self.r, self.g, self.b, 1 - (self.a or 1)
			if self.HasAlpha then
				ColorPickerFrame.opacity = a
			end
			ColorPickerFrame:SetColorRGB(r, g, b)

			ColorPickerFrame.cancelFunc = function()
				ColorCallback(self, r, g, b, a, true)
			end

			ColorPickerFrame:Show()
		end
	end
	AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetHeight(24)
		self:SetWidth(200)
		self:SetHasAlpha(false)
		self:SetColor(0, 0, 0, 1)
		self:SetDisabled(nil)
		self:SetLabel(nil)
	end,

	-- ["OnRelease"] = nil,

	["SetLabel"] = function(self, text)
		self.text:SetText(text)
	end,

	["SetColor"] = function(self, r, g, b, a)
		self.r = r
		self.g = g
		self.b = b
		self.a = a or 1
		self.colorSwatch:SetVertexColor(r, g, b, a)
	end,

	["SetHasAlpha"] = function(self, HasAlpha)
		self.HasAlpha = HasAlpha
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if self.disabled then
			self.frame:Disable()
			self.text:SetTextColor(0.5, 0.5, 0.5)
		else
			self.frame:Enable()
			self.text:SetTextColor(1, 1, 1)
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Button", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnClick", ColorSwatch_OnClick)

	local colorSwatch = frame:CreateTexture(nil, "OVERLAY")
	colorSwatch:SetWidth(19)
	colorSwatch:SetHeight(19)
	colorSwatch:SetTexture(130939) -- Interface\\ChatFrame\\ChatFrameColorSwatch
	colorSwatch:SetPoint("LEFT")

	local texture = frame:CreateTexture(nil, "BACKGROUND")
	colorSwatch.background = texture
	texture:SetWidth(16)
	texture:SetHeight(16)
	texture:SetColorTexture(1, 1, 1)
	texture:SetPoint("CENTER", colorSwatch)
	texture:Show()

	local checkers = frame:CreateTexture(nil, "BACKGROUND")
	colorSwatch.checkers = checkers
	checkers:SetWidth(14)
	checkers:SetHeight(14)
	checkers:SetTexture(188523) -- Tileset\\Generic\\Checkers
	checkers:SetTexCoord(.25, 0, 0.5, .25)
	checkers:SetDesaturated(true)
	checkers:SetVertexColor(1, 1, 1, 0.75)
	checkers:SetPoint("CENTER", colorSwatch)
	checkers:Show()

	local text = frame:CreateFontString(nil,"OVERLAY","GameFontHighlight")
	text:SetHeight(24)
	text:SetJustifyH("LEFT")
	text:SetTextColor(1, 1, 1)
	text:SetPoint("LEFT", colorSwatch, "RIGHT", 2, 0)
	text:SetPoint("RIGHT")

	--local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	--highlight:SetTexture(136810) -- Interface\\QuestFrame\\UI-QuestTitleHighlight
	--highlight:SetBlendMode("ADD")
	--highlight:SetAllPoints(frame)

	local widget = {
		colorSwatch = colorSwatch,
		text        = text,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-ColorPicker.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua ===
--[[ $Id: AceGUIWidget-DropDown-Items.lua 1272 2022-08-29 15:56:35Z nevcairiel $ ]]--

local AceGUI = LibStub("AceGUI-3.0")

-- Lua APIs
local select, assert = select, assert

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame = CreateFrame

local function fixlevels(parent,...)
	local i = 1
	local child = select(i, ...)
	while child do
		child:SetFrameLevel(parent:GetFrameLevel()+1)
		fixlevels(child, child:GetChildren())
		i = i + 1
		child = select(i, ...)
	end
end

local function fixstrata(strata, parent, ...)
	local i = 1
	local child = select(i, ...)
	parent:SetFrameStrata(strata)
	while child do
		fixstrata(strata, child, child:GetChildren())
		i = i + 1
		child = select(i, ...)
	end
end

-- ItemBase is the base "class" for all dropdown items.
-- Each item has to use ItemBase.Create(widgetType) to
-- create an initial 'self' value.
-- ItemBase will add common functions and ui event handlers.
-- Be sure to keep basic usage when you override functions.

local ItemBase = {
	-- NOTE: The ItemBase version is added to each item's version number
	--       to ensure proper updates on ItemBase changes.
	--       Use at least 1000er steps.
	version = 2000,
	counter = 0,
}

function ItemBase.Frame_OnEnter(this)
	local self = this.obj

	if self.useHighlight then
		self.highlight:Show()
	end
	self:Fire("OnEnter")

	if self.specialOnEnter then
		self.specialOnEnter(self)
	end
end

function ItemBase.Frame_OnLeave(this)
	local self = this.obj

	self.highlight:Hide()
	self:Fire("OnLeave")

	if self.specialOnLeave then
		self.specialOnLeave(self)
	end
end

-- exported, AceGUI callback
function ItemBase.OnAcquire(self)
	self.frame:SetToplevel(true)
	self.frame:SetFrameStrata("FULLSCREEN_DIALOG")
end

-- exported, AceGUI callback
function ItemBase.OnRelease(self)
	self:SetDisabled(false)
	self.pullout = nil
	self.frame:SetParent(nil)
	self.frame:ClearAllPoints()
	self.frame:Hide()
end

-- exported
-- NOTE: this is called by a Dropdown-Pullout.
--       Do not call this method directly
function ItemBase.SetPullout(self, pullout)
	self.pullout = pullout

	self.frame:SetParent(nil)
	self.frame:SetParent(pullout.itemFrame)
	self.parent = pullout.itemFrame
	fixlevels(pullout.itemFrame, pullout.itemFrame:GetChildren())
end

-- exported
function ItemBase.SetText(self, text)
	self.text:SetText(text or "")
end

-- exported
function ItemBase.GetText(self)
	return self.text:GetText()
end

-- exported
function ItemBase.SetPoint(self, ...)
	self.frame:SetPoint(...)
end

-- exported
function ItemBase.Show(self)
	self.frame:Show()
end

-- exported
function ItemBase.Hide(self)
	self.frame:Hide()
end

-- exported
function ItemBase.SetDisabled(self, disabled)
	self.disabled = disabled
	if disabled then
		self.useHighlight = false
		self.text:SetTextColor(.5, .5, .5)
	else
		self.useHighlight = true
		self.text:SetTextColor(1, 1, 1)
	end
end

-- exported
-- NOTE: this is called by a Dropdown-Pullout.
--       Do not call this method directly
function ItemBase.SetOnLeave(self, func)
	self.specialOnLeave = func
end

-- exported
-- NOTE: this is called by a Dropdown-Pullout.
--       Do not call this method directly
function ItemBase.SetOnEnter(self, func)
	self.specialOnEnter = func
end

function ItemBase.Create(type)
	-- NOTE: Most of the following code is copied from AceGUI-3.0/Dropdown widget
	local count = AceGUI:GetNextWidgetNum(type)
	local frame = CreateFrame("Button", "AceGUI30DropDownItem"..count)
	local self = {}
	self.frame = frame
	frame.obj = self
	self.type = type

	self.useHighlight = true

	frame:SetHeight(17)
	frame:SetFrameStrata("FULLSCREEN_DIALOG")

	local text = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
	text:SetTextColor(1,1,1)
	text:SetJustifyH("LEFT")
	text:SetPoint("TOPLEFT",frame,"TOPLEFT",18,0)
	text:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",-8,0)
	self.text = text

	local highlight = frame:CreateTexture(nil, "OVERLAY")
	highlight:SetTexture(136810) -- Interface\\QuestFrame\\UI-QuestTitleHighlight
	highlight:SetBlendMode("ADD")
	highlight:SetHeight(14)
	highlight:ClearAllPoints()
	highlight:SetPoint("RIGHT",frame,"RIGHT",-3,0)
	highlight:SetPoint("LEFT",frame,"LEFT",5,0)
	highlight:Hide()
	self.highlight = highlight

	local check = frame:CreateTexture(nil, "OVERLAY")
	check:SetWidth(16)
	check:SetHeight(16)
	check:SetPoint("LEFT",frame,"LEFT",3,-1)
	check:SetTexture(130751) -- Interface\\Buttons\\UI-CheckBox-Check
	check:Hide()
	self.check = check

	local sub = frame:CreateTexture(nil, "OVERLAY")
	sub:SetWidth(16)
	sub:SetHeight(16)
	sub:SetPoint("RIGHT",frame,"RIGHT",-3,-1)
	sub:SetTexture(130940) -- Interface\\ChatFrame\\ChatFrameExpandArrow
	sub:Hide()
	self.sub = sub

	frame:SetScript("OnEnter", ItemBase.Frame_OnEnter)
	frame:SetScript("OnLeave", ItemBase.Frame_OnLeave)

	self.OnAcquire = ItemBase.OnAcquire
	self.OnRelease = ItemBase.OnRelease

	self.SetPullout = ItemBase.SetPullout
	self.GetText    = ItemBase.GetText
	self.SetText    = ItemBase.SetText
	self.SetDisabled = ItemBase.SetDisabled

	self.SetPoint   = ItemBase.SetPoint
	self.Show       = ItemBase.Show
	self.Hide       = ItemBase.Hide

	self.SetOnLeave = ItemBase.SetOnLeave
	self.SetOnEnter = ItemBase.SetOnEnter

	return self
end

-- Register a dummy LibStub library to retrieve the ItemBase, so other addons can use it.
local IBLib = LibStub:NewLibrary("AceGUI-3.0-DropDown-ItemBase", ItemBase.version)
if IBLib then
	IBLib.GetItemBase = function() return ItemBase end
end

--[[
	Template for items:

-- Item:
--
do
	local widgetType = "Dropdown-Item-"
	local widgetVersion = 1

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end
--]]

-- Item: Header
-- A single text entry.
-- Special: Different text color and no highlight
do
	local widgetType = "Dropdown-Item-Header"
	local widgetVersion = 1

	local function OnEnter(this)
		local self = this.obj
		self:Fire("OnEnter")

		if self.specialOnEnter then
			self.specialOnEnter(self)
		end
	end

	local function OnLeave(this)
		local self = this.obj
		self:Fire("OnLeave")

		if self.specialOnLeave then
			self.specialOnLeave(self)
		end
	end

	-- exported, override
	local function SetDisabled(self, disabled)
		ItemBase.SetDisabled(self, disabled)
		if not disabled then
			self.text:SetTextColor(1, 1, 0)
		end
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.SetDisabled = SetDisabled

		self.frame:SetScript("OnEnter", OnEnter)
		self.frame:SetScript("OnLeave", OnLeave)

		self.text:SetTextColor(1, 1, 0)

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Execute
-- A simple button
do
	local widgetType = "Dropdown-Item-Execute"
	local widgetVersion = 1

	local function Frame_OnClick(this, button)
		local self = this.obj
		if self.disabled then return end
		self:Fire("OnClick")
		if self.pullout then
			self.pullout:Close()
		end
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.frame:SetScript("OnClick", Frame_OnClick)

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Toggle
-- Some sort of checkbox for dropdown menus.
-- Does not close the pullout on click.
do
	local widgetType = "Dropdown-Item-Toggle"
	local widgetVersion = 4

	local function UpdateToggle(self)
		if self.value then
			self.check:Show()
		else
			self.check:Hide()
		end
	end

	local function OnRelease(self)
		ItemBase.OnRelease(self)
		self:SetValue(nil)
	end

	local function Frame_OnClick(this, button)
		local self = this.obj
		if self.disabled then return end
		self.value = not self.value
		if self.value then
			PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
		else
			PlaySound(857) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_OFF
		end
		UpdateToggle(self)
		self:Fire("OnValueChanged", self.value)
	end

	-- exported
	local function SetValue(self, value)
		self.value = value
		UpdateToggle(self)
	end

	-- exported
	local function GetValue(self)
		return self.value
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.frame:SetScript("OnClick", Frame_OnClick)

		self.SetValue = SetValue
		self.GetValue = GetValue
		self.OnRelease = OnRelease

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Menu
-- Shows a submenu on mouse over
-- Does not close the pullout on click
do
	local widgetType = "Dropdown-Item-Menu"
	local widgetVersion = 2

	local function OnEnter(this)
		local self = this.obj
		self:Fire("OnEnter")

		if self.specialOnEnter then
			self.specialOnEnter(self)
		end

		self.highlight:Show()

		if not self.disabled and self.submenu then
			self.submenu:Open("TOPLEFT", self.frame, "TOPRIGHT", self.pullout:GetRightBorderWidth(), 0, self.frame:GetFrameLevel() + 100)
		end
	end

	local function OnHide(this)
		local self = this.obj
		if self.submenu then
			self.submenu:Close()
		end
	end

	-- exported
	local function SetMenu(self, menu)
		assert(menu.type == "Dropdown-Pullout")
		self.submenu = menu
	end

	-- exported
	local function CloseMenu(self)
		self.submenu:Close()
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.sub:Show()

		self.frame:SetScript("OnEnter", OnEnter)
		self.frame:SetScript("OnHide", OnHide)

		self.SetMenu   = SetMenu
		self.CloseMenu = CloseMenu

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

-- Item: Separator
-- A single line to separate items
do
	local widgetType = "Dropdown-Item-Separator"
	local widgetVersion = 2

	-- exported, override
	local function SetDisabled(self, disabled)
		ItemBase.SetDisabled(self, disabled)
		self.useHighlight = false
	end

	local function Constructor()
		local self = ItemBase.Create(widgetType)

		self.SetDisabled = SetDisabled

		local line = self.frame:CreateTexture(nil, "OVERLAY")
		line:SetHeight(1)
		line:SetColorTexture(.5, .5, .5)
		line:SetPoint("LEFT", self.frame, "LEFT", 10, 0)
		line:SetPoint("RIGHT", self.frame, "RIGHT", -10, 0)

		self.text:Hide()

		self.useHighlight = false

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion + ItemBase.version)
end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown-Items.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua ===
--[[ $Id: AceGUIWidget-DropDown.lua 1284 2022-09-25 09:15:30Z nevcairiel $ ]]--
local AceGUI = LibStub("AceGUI-3.0")

-- Lua APIs
local min, max, floor = math.min, math.max, math.floor
local select, pairs, ipairs, type, tostring = select, pairs, ipairs, type, tostring
local tsort = table.sort

-- WoW APIs
local PlaySound = PlaySound
local UIParent, CreateFrame = UIParent, CreateFrame
local _G = _G

local function fixlevels(parent,...)
	local i = 1
	local child = select(i, ...)
	while child do
		child:SetFrameLevel(parent:GetFrameLevel()+1)
		fixlevels(child, child:GetChildren())
		i = i + 1
		child = select(i, ...)
	end
end

local function fixstrata(strata, parent, ...)
	local i = 1
	local child = select(i, ...)
	parent:SetFrameStrata(strata)
	while child do
		fixstrata(strata, child, child:GetChildren())
		i = i + 1
		child = select(i, ...)
	end
end

do
	local widgetType = "Dropdown-Pullout"
	local widgetVersion = 5

	--[[ Static data ]]--

	local backdrop = {
		bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
		edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
		edgeSize = 32,
		tileSize = 32,
		tile = true,
		insets = { left = 11, right = 12, top = 12, bottom = 11 },
	}
	local sliderBackdrop  = {
		bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
		edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
		tile = true, tileSize = 8, edgeSize = 8,
		insets = { left = 3, right = 3, top = 3, bottom = 3 }
	}

	local defaultWidth = 200
	local defaultMaxHeight = 600

	--[[ UI Event Handlers ]]--

	-- HACK: This should be no part of the pullout, but there
	--       is no other 'clean' way to response to any item-OnEnter
	--       Used to close Submenus when an other item is entered
	local function OnEnter(item)
		local self = item.pullout
		for k, v in ipairs(self.items) do
			if v.CloseMenu and v ~= item then
				v:CloseMenu()
			end
		end
	end

	-- See the note in Constructor() for each scroll related function
	local function OnMouseWheel(this, value)
		this.obj:MoveScroll(value)
	end

	local function OnScrollValueChanged(this, value)
		this.obj:SetScroll(value)
	end

	local function OnSizeChanged(this)
		this.obj:FixScroll()
	end

	--[[ Exported methods ]]--

	-- exported
	local function SetScroll(self, value)
		local status = self.scrollStatus
		local frame, child = self.scrollFrame, self.itemFrame
		local height, viewheight = frame:GetHeight(), child:GetHeight()

		local offset
		if height > viewheight then
			offset = 0
		else
			offset = floor((viewheight - height) / 1000 * value)
		end
		child:ClearAllPoints()
		child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
		child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", self.slider:IsShown() and -12 or 0, offset)
		status.offset = offset
		status.scrollvalue = value
	end

	-- exported
	local function MoveScroll(self, value)
		local status = self.scrollStatus
		local frame, child = self.scrollFrame, self.itemFrame
		local height, viewheight = frame:GetHeight(), child:GetHeight()

		if height > viewheight then
			self.slider:Hide()
		else
			self.slider:Show()
			local diff = height - viewheight
			local delta = 1
			if value < 0 then
				delta = -1
			end
			self.slider:SetValue(min(max(status.scrollvalue + delta*(1000/(diff/45)),0), 1000))
		end
	end

	-- exported
	local function FixScroll(self)
		local status = self.scrollStatus
		local frame, child = self.scrollFrame, self.itemFrame
		local height, viewheight = frame:GetHeight(), child:GetHeight()
		local offset = status.offset or 0

		if viewheight < height then
			self.slider:Hide()
			child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, offset)
			self.slider:SetValue(0)
		else
			self.slider:Show()
			local value = (offset / (viewheight - height) * 1000)
			if value > 1000 then value = 1000 end
			self.slider:SetValue(value)
			self:SetScroll(value)
			if value < 1000 then
				child:ClearAllPoints()
				child:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, offset)
				child:SetPoint("TOPRIGHT", frame, "TOPRIGHT", -12, offset)
				status.offset = offset
			end
		end
	end

	-- exported, AceGUI callback
	local function OnAcquire(self)
		self.frame:SetParent(UIParent)
		--self.itemFrame:SetToplevel(true)
	end

	-- exported, AceGUI callback
	local function OnRelease(self)
		self:Clear()
		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	-- exported
	local function AddItem(self, item)
		self.items[#self.items + 1] = item

		local h = #self.items * 16
		self.itemFrame:SetHeight(h)
		self.frame:SetHeight(min(h + 34, self.maxHeight)) -- +34: 20 for scrollFrame placement (10 offset) and +14 for item placement

		item.frame:SetPoint("LEFT", self.itemFrame, "LEFT")
		item.frame:SetPoint("RIGHT", self.itemFrame, "RIGHT")

		item:SetPullout(self)
		item:SetOnEnter(OnEnter)
	end

	-- exported
	local function Open(self, point, relFrame, relPoint, x, y)
		local items = self.items
		local frame = self.frame
		local itemFrame = self.itemFrame

		frame:SetPoint(point, relFrame, relPoint, x, y)


		local height = 8
		for i, item in pairs(items) do
			item:SetPoint("TOP", itemFrame, "TOP", 0, -2 + (i - 1) * -16)
			item:Show()

			height = height + 16
		end
		itemFrame:SetHeight(height)
		fixstrata("TOOLTIP", frame, frame:GetChildren())
		frame:Show()
		self:Fire("OnOpen")
	end

	-- exported
	local function Close(self)
		self.frame:Hide()
		self:Fire("OnClose")
	end

	-- exported
	local function Clear(self)
		local items = self.items
		for i, item in pairs(items) do
			AceGUI:Release(item)
			items[i] = nil
		end
	end

	-- exported
	local function IterateItems(self)
		return ipairs(self.items)
	end

	-- exported
	local function SetHideOnLeave(self, val)
		self.hideOnLeave = val
	end

	-- exported
	local function SetMaxHeight(self, height)
		self.maxHeight = height or defaultMaxHeight
		if self.frame:GetHeight() > height then
			self.frame:SetHeight(height)
		elseif (self.itemFrame:GetHeight() + 34) < height then
			self.frame:SetHeight(self.itemFrame:GetHeight() + 34) -- see :AddItem
		end
	end

	-- exported
	local function GetRightBorderWidth(self)
		return 6 + (self.slider:IsShown() and 12 or 0)
	end

	-- exported
	local function GetLeftBorderWidth(self)
		return 6
	end

	--[[ Constructor ]]--

	local function Constructor()
		local count = AceGUI:GetNextWidgetNum(widgetType)
		local frame = CreateFrame("Frame", "AceGUI30Pullout"..count, UIParent, "BackdropTemplate")
		local self = {}
		self.count = count
		self.type = widgetType
		self.frame = frame
		frame.obj = self

		self.OnAcquire = OnAcquire
		self.OnRelease = OnRelease

		self.AddItem = AddItem
		self.Open    = Open
		self.Close   = Close
		self.Clear   = Clear
		self.IterateItems = IterateItems
		self.SetHideOnLeave = SetHideOnLeave

		self.SetScroll  = SetScroll
		self.MoveScroll = MoveScroll
		self.FixScroll  = FixScroll

		self.SetMaxHeight = SetMaxHeight
		self.GetRightBorderWidth = GetRightBorderWidth
		self.GetLeftBorderWidth = GetLeftBorderWidth

		self.items = {}

		self.scrollStatus = {
			scrollvalue = 0,
		}

		self.maxHeight = defaultMaxHeight

		frame:SetBackdrop(backdrop)
		frame:SetBackdropColor(0, 0, 0)
		frame:SetFrameStrata("FULLSCREEN_DIALOG")
		frame:SetClampedToScreen(true)
		frame:SetWidth(defaultWidth)
		frame:SetHeight(self.maxHeight)
		--frame:SetToplevel(true)

		-- NOTE: The whole scroll frame code is copied from the AceGUI-3.0 widget ScrollFrame
		local scrollFrame = CreateFrame("ScrollFrame", nil, frame)
		local itemFrame = CreateFrame("Frame", nil, scrollFrame)

		self.scrollFrame = scrollFrame
		self.itemFrame = itemFrame

		scrollFrame.obj = self
		itemFrame.obj = self

		local slider = CreateFrame("Slider", "AceGUI30PulloutScrollbar"..count, scrollFrame, "BackdropTemplate")
		slider:SetOrientation("VERTICAL")
		slider:SetHitRectInsets(0, 0, -10, 0)
		slider:SetBackdrop(sliderBackdrop)
		slider:SetWidth(8)
		slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Vertical")
		slider:SetFrameStrata("FULLSCREEN_DIALOG")
		self.slider = slider
		slider.obj = self

		scrollFrame:SetScrollChild(itemFrame)
		scrollFrame:SetPoint("TOPLEFT", frame, "TOPLEFT", 6, -12)
		scrollFrame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -6, 12)
		scrollFrame:EnableMouseWheel(true)
		scrollFrame:SetScript("OnMouseWheel", OnMouseWheel)
		scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
		scrollFrame:SetToplevel(true)
		scrollFrame:SetFrameStrata("FULLSCREEN_DIALOG")

		itemFrame:SetPoint("TOPLEFT", scrollFrame, "TOPLEFT", 0, 0)
		itemFrame:SetPoint("TOPRIGHT", scrollFrame, "TOPRIGHT", -12, 0)
		itemFrame:SetHeight(400)
		itemFrame:SetToplevel(true)
		itemFrame:SetFrameStrata("FULLSCREEN_DIALOG")

		slider:SetPoint("TOPLEFT", scrollFrame, "TOPRIGHT", -16, 0)
		slider:SetPoint("BOTTOMLEFT", scrollFrame, "BOTTOMRIGHT", -16, 0)
		slider:SetScript("OnValueChanged", OnScrollValueChanged)
		slider:SetMinMaxValues(0, 1000)
		slider:SetValueStep(1)
		slider:SetValue(0)

		scrollFrame:Show()
		itemFrame:Show()
		slider:Hide()

		self:FixScroll()

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
end

do
	local widgetType = "Dropdown"
	local widgetVersion = 36

	--[[ Static data ]]--

	--[[ UI event handler ]]--

	local function Control_OnEnter(this)
		this.obj.button:LockHighlight()
		this.obj:Fire("OnEnter")
	end

	local function Control_OnLeave(this)
		this.obj.button:UnlockHighlight()
		this.obj:Fire("OnLeave")
	end

	local function Dropdown_OnHide(this)
		local self = this.obj
		if self.open then
			self.pullout:Close()
		end
	end

	local function Dropdown_TogglePullout(this)
		local self = this.obj
		if self.open then
			self.open = nil
			self.pullout:Close()
			AceGUI:ClearFocus()
		else
			self.open = true
			self.pullout:SetWidth(self.pulloutWidth or self.frame:GetWidth())
			self.pullout:Open("TOPLEFT", self.frame, "BOTTOMLEFT", 0, self.label:IsShown() and -2 or 0)
			AceGUI:SetFocus(self)
		end
	end

	local function OnPulloutOpen(this)
		local self = this.userdata.obj
		local value = self.value

		if not self.multiselect then
			for i, item in this:IterateItems() do
				item:SetValue(item.userdata.value == value)
			end
		end

		self.open = true
		self:Fire("OnOpened")
	end

	local function OnPulloutClose(this)
		local self = this.userdata.obj
		self.open = nil
		self:Fire("OnClosed")
	end

	local function ShowMultiText(self)
		local text
		for i, widget in self.pullout:IterateItems() do
			if widget.type == "Dropdown-Item-Toggle" then
				if widget:GetValue() then
					if text then
						text = text..", "..widget:GetText()
					else
						text = widget:GetText()
					end
				end
			end
		end
		self:SetText(text)
	end

	local function OnItemValueChanged(this, event, checked)
		local self = this.userdata.obj

		if self.multiselect then
			self:Fire("OnValueChanged", this.userdata.value, checked)
			ShowMultiText(self)
		else
			if checked then
				self:SetValue(this.userdata.value)
				self:Fire("OnValueChanged", this.userdata.value)
			else
				this:SetValue(true)
			end
			if self.open then
				self.pullout:Close()
			end
		end
	end

	--[[ Exported methods ]]--

	-- exported, AceGUI callback
	local function OnAcquire(self)
		local pullout = AceGUI:Create("Dropdown-Pullout")
		self.pullout = pullout
		pullout.userdata.obj = self
		pullout:SetCallback("OnClose", OnPulloutClose)
		pullout:SetCallback("OnOpen", OnPulloutOpen)
		self.pullout.frame:SetFrameLevel(self.frame:GetFrameLevel() + 1)
		fixlevels(self.pullout.frame, self.pullout.frame:GetChildren())

		self:SetHeight(44)
		self:SetWidth(200)
		self:SetLabel()
		self:SetPulloutWidth(nil)
		self.list = {}
	end

	-- exported, AceGUI callback
	local function OnRelease(self)
		if self.open then
			self.pullout:Close()
		end
		AceGUI:Release(self.pullout)
		self.pullout = nil

		self:SetText("")
		self:SetDisabled(false)
		self:SetMultiselect(false)

		self.value = nil
		self.list = nil
		self.open = nil
		self.hasClose = nil

		self.frame:ClearAllPoints()
		self.frame:Hide()
	end

	-- exported
	local function SetDisabled(self, disabled)
		self.disabled = disabled
		if disabled then
			self.text:SetTextColor(0.5,0.5,0.5)
			self.button:Disable()
			self.button_cover:Disable()
			self.label:SetTextColor(0.5,0.5,0.5)
		else
			self.button:Enable()
			self.button_cover:Enable()
			self.label:SetTextColor(1,.82,0)
			self.text:SetTextColor(1,1,1)
		end
	end

	-- exported
	local function ClearFocus(self)
		if self.open then
			self.pullout:Close()
		end
	end

	-- exported
	local function SetText(self, text)
		self.text:SetText(text or "")
	end

	-- exported
	local function SetLabel(self, text)
		if text and text ~= "" then
			self.label:SetText(text)
			self.label:Show()
			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,-14)
			self:SetHeight(40)
			self.alignoffset = 26
		else
			self.label:SetText("")
			self.label:Hide()
			self.dropdown:SetPoint("TOPLEFT",self.frame,"TOPLEFT",-15,0)
			self:SetHeight(26)
			self.alignoffset = 12
		end
	end

	-- exported
	local function SetValue(self, value)
		self:SetText(self.list[value] or "")
		self.value = value
	end

	-- exported
	local function GetValue(self)
		return self.value
	end

	-- exported
	local function SetItemValue(self, item, value)
		if not self.multiselect then return end
		for i, widget in self.pullout:IterateItems() do
			if widget.userdata.value == item then
				if widget.SetValue then
					widget:SetValue(value)
				end
			end
		end
		ShowMultiText(self)
	end

	-- exported
	local function SetItemDisabled(self, item, disabled)
		for i, widget in self.pullout:IterateItems() do
			if widget.userdata.value == item then
				widget:SetDisabled(disabled)
			end
		end
	end

	local function AddListItem(self, value, text, itemType)
		if not itemType then itemType = "Dropdown-Item-Toggle" end
		local exists = AceGUI:GetWidgetVersion(itemType)
		if not exists then error(("The given item type, %q, does not exist within AceGUI-3.0"):format(tostring(itemType)), 2) end

		local item = AceGUI:Create(itemType)
		item:SetText(text)
		item.userdata.obj = self
		item.userdata.value = value
		item:SetCallback("OnValueChanged", OnItemValueChanged)
		self.pullout:AddItem(item)
	end

	local function AddCloseButton(self)
		if not self.hasClose then
			local close = AceGUI:Create("Dropdown-Item-Execute")
			close:SetText(CLOSE)
			self.pullout:AddItem(close)
			self.hasClose = true
		end
	end

	-- exported
	local sortlist = {}
	local function sortTbl(x,y)
		local num1, num2 = tonumber(x), tonumber(y)
		if num1 and num2 then -- numeric comparison, either two numbers or numeric strings
			return num1 < num2
		else -- compare everything else tostring'ed
			return tostring(x) < tostring(y)
		end
	end
	local function SetList(self, list, order, itemType)
		self.list = list or {}
		self.pullout:Clear()
		self.hasClose = nil
		if not list then return end

		if type(order) ~= "table" then
			for v in pairs(list) do
				sortlist[#sortlist + 1] = v
			end
			tsort(sortlist, sortTbl)

			for i, key in ipairs(sortlist) do
				AddListItem(self, key, list[key], itemType)
				sortlist[i] = nil
			end
		else
			for i, key in ipairs(order) do
				AddListItem(self, key, list[key], itemType)
			end
		end
		if self.multiselect then
			ShowMultiText(self)
			AddCloseButton(self)
		end
	end

	-- exported
	local function AddItem(self, value, text, itemType)
		self.list[value] = text
		AddListItem(self, value, text, itemType)
	end

	-- exported
	local function SetMultiselect(self, multi)
		self.multiselect = multi
		if multi then
			ShowMultiText(self)
			AddCloseButton(self)
		end
	end

	-- exported
	local function GetMultiselect(self)
		return self.multiselect
	end

	local function SetPulloutWidth(self, width)
		self.pulloutWidth = width
	end

	--[[ Constructor ]]--

	local function Constructor()
		local count = AceGUI:GetNextWidgetNum(widgetType)
		local frame = CreateFrame("Frame", nil, UIParent)
		local dropdown = CreateFrame("Frame", "AceGUI30DropDown"..count, frame, "UIDropDownMenuTemplate")

		local self = {}
		self.type = widgetType
		self.frame = frame
		self.dropdown = dropdown
		self.count = count
		frame.obj = self
		dropdown.obj = self

		self.OnRelease   = OnRelease
		self.OnAcquire   = OnAcquire

		self.ClearFocus  = ClearFocus

		self.SetText     = SetText
		self.SetValue    = SetValue
		self.GetValue    = GetValue
		self.SetList     = SetList
		self.SetLabel    = SetLabel
		self.SetDisabled = SetDisabled
		self.AddItem     = AddItem
		self.SetMultiselect = SetMultiselect
		self.GetMultiselect = GetMultiselect
		self.SetItemValue = SetItemValue
		self.SetItemDisabled = SetItemDisabled
		self.SetPulloutWidth = SetPulloutWidth

		self.alignoffset = 26

		frame:SetScript("OnHide",Dropdown_OnHide)

		dropdown:ClearAllPoints()
		dropdown:SetPoint("TOPLEFT",frame,"TOPLEFT",-15,0)
		dropdown:SetPoint("BOTTOMRIGHT",frame,"BOTTOMRIGHT",17,0)
		dropdown:SetScript("OnHide", nil)

		local left = _G[dropdown:GetName() .. "Left"]
		local middle = _G[dropdown:GetName() .. "Middle"]
		local right = _G[dropdown:GetName() .. "Right"]

		middle:ClearAllPoints()
		right:ClearAllPoints()

		middle:SetPoint("LEFT", left, "RIGHT", 0, 0)
		middle:SetPoint("RIGHT", right, "LEFT", 0, 0)
		right:SetPoint("TOPRIGHT", dropdown, "TOPRIGHT", 0, 17)

		local button = _G[dropdown:GetName() .. "Button"]
		self.button = button
		button.obj = self
		button:SetScript("OnEnter",Control_OnEnter)
		button:SetScript("OnLeave",Control_OnLeave)
		button:SetScript("OnClick",Dropdown_TogglePullout)

		local button_cover = CreateFrame("BUTTON",nil,self.frame)
		self.button_cover = button_cover
		button_cover.obj = self
		button_cover:SetPoint("TOPLEFT",self.frame,"BOTTOMLEFT",0,25)
		button_cover:SetPoint("BOTTOMRIGHT",self.frame,"BOTTOMRIGHT")
		button_cover:SetScript("OnEnter",Control_OnEnter)
		button_cover:SetScript("OnLeave",Control_OnLeave)
		button_cover:SetScript("OnClick",Dropdown_TogglePullout)

		local text = _G[dropdown:GetName() .. "Text"]
		self.text = text
		text.obj = self
		text:ClearAllPoints()
		text:SetPoint("RIGHT", right, "RIGHT" ,-43, 2)
		text:SetPoint("LEFT", left, "LEFT", 25, 2)

		local label = frame:CreateFontString(nil,"OVERLAY","GameFontNormalSmall")
		label:SetPoint("TOPLEFT",frame,"TOPLEFT",0,0)
		label:SetPoint("TOPRIGHT",frame,"TOPRIGHT",0,0)
		label:SetJustifyH("LEFT")
		label:SetHeight(18)
		label:Hide()
		self.label = label

		AceGUI:RegisterAsWidget(self)
		return self
	end

	AceGUI:RegisterWidgetType(widgetType, Constructor, widgetVersion)
end

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-DropDown.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua ===
--[[-----------------------------------------------------------------------------
EditBox Widget
-------------------------------------------------------------------------------]]
local Type, Version = "EditBox", 29
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local tostring, pairs = tostring, pairs

-- WoW APIs
local PlaySound = PlaySound
local GetCursorInfo, ClearCursor = GetCursorInfo, ClearCursor
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = _G

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
if not AceGUIEditBoxInsertLink then
	-- upgradeable hook
	if ChatFrameUtil and ChatFrameUtil.InsertLink then
		hooksecurefunc(ChatFrameUtil, "InsertLink", function(...) return _G.AceGUIEditBoxInsertLink(...) end)
	elseif ChatEdit_InsertLink then
		hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIEditBoxInsertLink(...) end)
	end
end

function _G.AceGUIEditBoxInsertLink(text)
	for i = 1, AceGUI:GetWidgetCount(Type) do
		local editbox = _G["AceGUI-3.0EditBox"..i]
		if editbox and editbox:IsVisible() and editbox:HasFocus() then
			editbox:Insert(text)
			return true
		end
	end
end

local function ShowButton(self)
	if not self.disablebutton then
		self.button:Show()
		self.editbox:SetTextInsets(0, 20, 3, 3)
	end
end

local function HideButton(self)
	self.button:Hide()
	self.editbox:SetTextInsets(0, 0, 3, 3)
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function Frame_OnShowFocus(frame)
	frame.obj.editbox:SetFocus()
	frame:SetScript("OnShow", nil)
end

local function EditBox_OnEscapePressed(frame)
	AceGUI:ClearFocus()
end

local function EditBox_OnEnterPressed(frame)
	local self = frame.obj
	local value = frame:GetText()
	local cancel = self:Fire("OnEnterPressed", value)
	if not cancel then
		PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
		HideButton(self)
	end
end

local function EditBox_OnReceiveDrag(frame)
	local self = frame.obj
	local type, id, info, extra = GetCursorInfo()
	local name
	if type == "item" then
		name = info
	elseif type == "spell" then
		if C_Spell and C_Spell.GetSpellName then
			name = C_Spell.GetSpellName(extra)
		else
			name = GetSpellInfo(id, info)
		end
	elseif type == "macro" then
		name = GetMacroInfo(id)
	end
	if name then
		self:SetText(name)
		self:Fire("OnEnterPressed", name)
		ClearCursor()
		HideButton(self)
		AceGUI:ClearFocus()
	end
end

local function EditBox_OnTextChanged(frame)
	local self = frame.obj
	local value = frame:GetText()
	if tostring(value) ~= tostring(self.lasttext) then
		self:Fire("OnTextChanged", value)
		self.lasttext = value
		ShowButton(self)
	end
end

local function EditBox_OnFocusGained(frame)
	AceGUI:SetFocus(frame.obj)
end

local function Button_OnClick(frame)
	local editbox = frame.obj.editbox
	editbox:ClearFocus()
	EditBox_OnEnterPressed(editbox)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		-- height is controlled by SetLabel
		self:SetWidth(200)
		self:SetDisabled(false)
		self:SetLabel()
		self:SetText()
		self:DisableButton(false)
		self:SetMaxLetters(0)
	end,

	["OnRelease"] = function(self)
		self:ClearFocus()
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.editbox:EnableMouse(false)
			self.editbox:ClearFocus()
			self.editbox:SetTextColor(0.5,0.5,0.5)
			self.label:SetTextColor(0.5,0.5,0.5)
		else
			self.editbox:EnableMouse(true)
			self.editbox:SetTextColor(1,1,1)
			self.label:SetTextColor(1,.82,0)
		end
	end,

	["SetText"] = function(self, text)
		self.lasttext = text or ""
		self.editbox:SetText(text or "")
		self.editbox:SetCursorPosition(0)
		HideButton(self)
	end,

	["GetText"] = function(self, text)
		return self.editbox:GetText()
	end,

	["SetLabel"] = function(self, text)
		if text and text ~= "" then
			self.label:SetText(text)
			self.label:Show()
			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,-18)
			self:SetHeight(44)
			self.alignoffset = 30
		else
			self.label:SetText("")
			self.label:Hide()
			self.editbox:SetPoint("TOPLEFT",self.frame,"TOPLEFT",7,0)
			self:SetHeight(26)
			self.alignoffset = 12
		end
	end,

	["DisableButton"] = function(self, disabled)
		self.disablebutton = disabled
		if disabled then
			HideButton(self)
		end
	end,

	["SetMaxLetters"] = function (self, num)
		self.editbox:SetMaxLetters(num or 0)
	end,

	["ClearFocus"] = function(self)
		self.editbox:ClearFocus()
		self.frame:SetScript("OnShow", nil)
	end,

	["SetFocus"] = function(self)
		self.editbox:SetFocus()
		if not self.frame:IsShown() then
			self.frame:SetScript("OnShow", Frame_OnShowFocus)
		end
	end,

	["HighlightText"] = function(self, from, to)
		self.editbox:HighlightText(from, to)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local num  = AceGUI:GetNextWidgetNum(Type)
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local editbox = CreateFrame("EditBox", "AceGUI-3.0EditBox"..num, frame, "InputBoxTemplate")
	editbox:SetAutoFocus(false)
	editbox:SetFontObject(ChatFontNormal)
	editbox:SetScript("OnEnter", Control_OnEnter)
	editbox:SetScript("OnLeave", Control_OnLeave)
	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)
	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
	editbox:SetScript("OnTextChanged", EditBox_OnTextChanged)
	editbox:SetScript("OnReceiveDrag", EditBox_OnReceiveDrag)
	editbox:SetScript("OnMouseDown", EditBox_OnReceiveDrag)
	editbox:SetScript("OnEditFocusGained", EditBox_OnFocusGained)
	editbox:SetTextInsets(0, 0, 3, 3)
	editbox:SetMaxLetters(256)
	editbox:SetPoint("BOTTOMLEFT", 6, 0)
	editbox:SetPoint("BOTTOMRIGHT")
	editbox:SetHeight(19)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
	label:SetPoint("TOPLEFT", 0, -2)
	label:SetPoint("TOPRIGHT", 0, -2)
	label:SetJustifyH("LEFT")
	label:SetHeight(18)

	local button = CreateFrame("Button", nil, editbox, "UIPanelButtonTemplate")
	button:SetWidth(40)
	button:SetHeight(20)
	button:SetPoint("RIGHT", -2, 0)
	button:SetText(OKAY)
	button:SetScript("OnClick", Button_OnClick)
	button:Hide()

	local widget = {
		alignoffset = 30,
		editbox     = editbox,
		label       = label,
		button      = button,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	editbox.obj, button.obj = widget, widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-EditBox.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua ===
--[[-----------------------------------------------------------------------------
Heading Widget
-------------------------------------------------------------------------------]]
local Type, Version = "Heading", 20
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetText()
		self:SetFullWidth()
		self:SetHeight(18)
	end,

	-- ["OnRelease"] = nil,

	["SetText"] = function(self, text)
		self.label:SetText(text or "")
		if text and text ~= "" then
			self.left:SetPoint("RIGHT", self.label, "LEFT", -5, 0)
			self.right:Show()
		else
			self.left:SetPoint("RIGHT", -3, 0)
			self.right:Hide()
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontNormal")
	label:SetPoint("TOP")
	label:SetPoint("BOTTOM")
	label:SetJustifyH("CENTER")

	local left = frame:CreateTexture(nil, "BACKGROUND")
	left:SetHeight(8)
	left:SetPoint("LEFT", 3, 0)
	left:SetPoint("RIGHT", label, "LEFT", -5, 0)
	left:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
	left:SetTexCoord(0.81, 0.94, 0.5, 1)

	local right = frame:CreateTexture(nil, "BACKGROUND")
	right:SetHeight(8)
	right:SetPoint("RIGHT", -3, 0)
	right:SetPoint("LEFT", label, "RIGHT", 5, 0)
	right:SetTexture(137057) -- Interface\\Tooltips\\UI-Tooltip-Border
	right:SetTexCoord(0.81, 0.94, 0.5, 1)

	local widget = {
		label = label,
		left  = left,
		right = right,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Heading.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua ===
--[[-----------------------------------------------------------------------------
Icon Widget
-------------------------------------------------------------------------------]]
local Type, Version = "Icon", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local select, pairs, print = select, pairs, print

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function Button_OnClick(frame, button)
	frame.obj:Fire("OnClick", button)
	AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetHeight(110)
		self:SetWidth(110)
		self:SetLabel()
		self:SetImage(nil)
		self:SetImageSize(64, 64)
		self:SetDisabled(false)
	end,

	-- ["OnRelease"] = nil,

	["SetLabel"] = function(self, text)
		if text and text ~= "" then
			self.label:Show()
			self.label:SetText(text)
			self:SetHeight(self.image:GetHeight() + 25)
		else
			self.label:Hide()
			self:SetHeight(self.image:GetHeight() + 10)
		end
	end,

	["SetImage"] = function(self, path, ...)
		local image = self.image
		image:SetTexture(path)

		if image:GetTexture() then
			local n = select("#", ...)
			if n == 4 or n == 8 then
				image:SetTexCoord(...)
			else
				image:SetTexCoord(0, 1, 0, 1)
			end
		end
	end,

	["SetImageSize"] = function(self, width, height)
		self.image:SetWidth(width)
		self.image:SetHeight(height)
		--self.frame:SetWidth(width + 30)
		if self.label:IsShown() then
			self:SetHeight(height + 25)
		else
			self:SetHeight(height + 10)
		end
	end,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.frame:Disable()
			self.label:SetTextColor(0.5, 0.5, 0.5)
			self.image:SetVertexColor(0.5, 0.5, 0.5, 0.5)
		else
			self.frame:Enable()
			self.label:SetTextColor(1, 1, 1)
			self.image:SetVertexColor(1, 1, 1, 1)
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Button", nil, UIParent)
	frame:Hide()

	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnClick", Button_OnClick)

	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlight")
	label:SetPoint("BOTTOMLEFT")
	label:SetPoint("BOTTOMRIGHT")
	label:SetJustifyH("CENTER")
	label:SetJustifyV("TOP")
	label:SetHeight(18)

	local image = frame:CreateTexture(nil, "BACKGROUND")
	image:SetWidth(64)
	image:SetHeight(64)
	image:SetPoint("TOP", 0, -5)

	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	highlight:SetAllPoints(image)
	highlight:SetTexture(136580) -- Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight
	highlight:SetTexCoord(0, 1, 0.23, 0.77)
	highlight:SetBlendMode("ADD")

	local widget = {
		label = label,
		image = image,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	widget.SetText = function(self, ...) print("AceGUI-3.0-Icon: SetText is deprecated! Use SetLabel instead!"); self:SetLabel(...) end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Icon.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua ===
--[[-----------------------------------------------------------------------------
InteractiveLabel Widget
-------------------------------------------------------------------------------]]
local Type, Version = "InteractiveLabel", 21
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local select, pairs = select, pairs

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function Label_OnClick(frame, button)
	frame.obj:Fire("OnClick", button)
	AceGUI:ClearFocus()
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:LabelOnAcquire()
		self:SetHighlight()
		self:SetHighlightTexCoord()
		self:SetDisabled(false)
	end,

	-- ["OnRelease"] = nil,

	["SetHighlight"] = function(self, ...)
		self.highlight:SetTexture(...)
	end,

	["SetHighlightTexCoord"] = function(self, ...)
		local c = select("#", ...)
		if c == 4 or c == 8 then
			self.highlight:SetTexCoord(...)
		else
			self.highlight:SetTexCoord(0, 1, 0, 1)
		end
	end,

	["SetDisabled"] = function(self,disabled)
		self.disabled = disabled
		if disabled then
			self.frame:EnableMouse(false)
			self.label:SetTextColor(0.5, 0.5, 0.5)
		else
			self.frame:EnableMouse(true)
			self.label:SetTextColor(1, 1, 1)
		end
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	-- create a Label type that we will hijack
	local label = AceGUI:Create("Label")

	local frame = label.frame
	frame:EnableMouse(true)
	frame:SetScript("OnEnter", Control_OnEnter)
	frame:SetScript("OnLeave", Control_OnLeave)
	frame:SetScript("OnMouseDown", Label_OnClick)

	local highlight = frame:CreateTexture(nil, "HIGHLIGHT")
	highlight:SetTexture(nil)
	highlight:SetAllPoints()
	highlight:SetBlendMode("ADD")

	label.highlight = highlight
	label.type = Type
	label.LabelOnAcquire = label.OnAcquire
	for method, func in pairs(methods) do
		label[method] = func
	end

	return label
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)


=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-InteractiveLabel.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua ===
--[[-----------------------------------------------------------------------------
Keybinding Widget
Set Keybindings in the Config UI.
-------------------------------------------------------------------------------]]
local Type, Version = "Keybinding", 26
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown = IsShiftKeyDown, IsControlKeyDown, IsAltKeyDown
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]

local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function Keybinding_OnClick(frame, button)
	if button == "LeftButton" or button == "RightButton" then
		local self = frame.obj
		if self.waitingForKey then
			frame:EnableKeyboard(false)
			frame:EnableMouseWheel(false)
			self.msgframe:Hide()
			frame:UnlockHighlight()
			self.waitingForKey = nil
		else
			frame:EnableKeyboard(true)
			frame:EnableMouseWheel(true)
			self.msgframe:Show()
			frame:LockHighlight()
			self.waitingForKey = true
		end
	end
	AceGUI:ClearFocus()
end

local ignoreKeys = {
	["BUTTON1"] = true, ["BUTTON2"] = true,
	["UNKNOWN"] = true,
	["LSHIFT"] = true, ["LCTRL"] = true, ["LALT"] = true,
	["RSHIFT"] = true, ["RCTRL"] = true, ["RALT"] = true,
}
local function Keybinding_OnKeyDown(frame, key)
	local self = frame.obj
	if self.waitingForKey then
		local keyPressed = key
		if keyPressed == "ESCAPE" then
			keyPressed = ""
		else
			if ignoreKeys[keyPressed] then return end
			if IsShiftKeyDown() then
				keyPressed = "SHIFT-"..keyPressed
			end
			if IsControlKeyDown() then
				keyPressed = "CTRL-"..keyPressed
			end
			if IsAltKeyDown() then
				keyPressed = "ALT-"..keyPressed
			end
		end

		frame:EnableKeyboard(false)
		frame:EnableMouseWheel(false)
		self.msgframe:Hide()
		frame:UnlockHighlight()
		self.waitingForKey = nil

		if not self.disabled then
			self:SetKey(keyPressed)
			self:Fire("OnKeyChanged", keyPressed)
		end
	end
end

local function Keybinding_OnMouseDown(frame, button)
	if button == "LeftButton" or button == "RightButton" then
		return
	elseif button == "MiddleButton" then
		button = "BUTTON3"
	elseif button == "Button4" then
		button = "BUTTON4"
	elseif button == "Button5" then
		button = "BUTTON5"
	end
	Keybinding_OnKeyDown(frame, button)
end

local function Keybinding_OnMouseWheel(frame, direction)
	local button
	if direction >= 0 then
		button = "MOUSEWHEELUP"
	else
		button = "MOUSEWHEELDOWN"
	end
	Keybinding_OnKeyDown(frame, button)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(200)
		self:SetLabel("")
		self:SetKey("")
		self.waitingForKey = nil
		self.msgframe:Hide()
		self:SetDisabled(false)
		self.button:EnableKeyboard(false)
		self.button:EnableMouseWheel(false)
	end,

	-- ["OnRelease"] = nil,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.button:Disable()
			self.label:SetTextColor(0.5,0.5,0.5)
		else
			self.button:Enable()
			self.label:SetTextColor(1,1,1)
		end
	end,

	["SetKey"] = function(self, key)
		if (key or "") == "" then
			self.button:SetText(NOT_BOUND)
			self.button:SetNormalFontObject("GameFontNormal")
		else
			self.button:SetText(key)
			self.button:SetNormalFontObject("GameFontHighlight")
		end
	end,

	["GetKey"] = function(self)
		local key = self.button:GetText()
		if key == NOT_BOUND then
			key = nil
		end
		return key
	end,

	["SetLabel"] = function(self, label)
		self.label:SetText(label or "")
		if (label or "") == "" then
			self.alignoffset = nil
			self:SetHeight(24)
		else
			self.alignoffset = 30
			self:SetHeight(44)
		end
	end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]

local ControlBackdrop  = {
	bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
	edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
	tile = true, tileSize = 16, edgeSize = 16,
	insets = { left = 3, right = 3, top = 3, bottom = 3 }
}

local function keybindingMsgFixWidth(frame)
	frame:SetWidth(frame.msg:GetWidth() + 10)
	frame:SetScript("OnUpdate", nil)
end

local function Constructor()
	local name = "AceGUI30KeybindingButton" .. AceGUI:GetNextWidgetNum(Type)

	local frame = CreateFrame("Frame", nil, UIParent)
	local button = CreateFrame("Button", name, frame, "UIPanelButtonTemplate")

	button:EnableMouse(true)
	button:EnableMouseWheel(false)
	button:RegisterForClicks("AnyDown")
	button:SetScript("OnEnter", Control_OnEnter)
	button:SetScript("OnLeave", Control_OnLeave)
	button:SetScript("OnClick", Keybinding_OnClick)
	button:SetScript("OnKeyDown", Keybinding_OnKeyDown)
	button:SetScript("OnMouseDown", Keybinding_OnMouseDown)
	button:SetScript("OnMouseWheel", Keybinding_OnMouseWheel)
	button:SetPoint("BOTTOMLEFT")
	button:SetPoint("BOTTOMRIGHT")
	button:SetHeight(24)
	button:EnableKeyboard(false)

	local text = button:GetFontString()
	text:SetPoint("LEFT", 7, 0)
	text:SetPoint("RIGHT", -7, 0)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
	label:SetPoint("TOPLEFT")
	label:SetPoint("TOPRIGHT")
	label:SetJustifyH("CENTER")
	label:SetHeight(18)

	local msgframe = CreateFrame("Frame", nil, UIParent, "BackdropTemplate")
	msgframe:SetHeight(30)
	msgframe:SetBackdrop(ControlBackdrop)
	msgframe:SetBackdropColor(0,0,0)
	msgframe:SetFrameStrata("FULLSCREEN_DIALOG")
	msgframe:SetFrameLevel(1000)
	msgframe:SetToplevel(true)

	local msg = msgframe:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	msg:SetText("Press a key to bind, ESC to clear the binding or click the button again to cancel.")
	msgframe.msg = msg
	msg:SetPoint("TOPLEFT", 5, -5)
	msgframe:SetScript("OnUpdate", keybindingMsgFixWidth)
	msgframe:SetPoint("BOTTOM", button, "TOP")
	msgframe:Hide()

	local widget = {
		button      = button,
		label       = label,
		msgframe    = msgframe,
		frame       = frame,
		alignoffset = 30,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	button.obj = widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Keybinding.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Label.lua ===
--[[-----------------------------------------------------------------------------
Label Widget
Displays text and optionally an icon.
-------------------------------------------------------------------------------]]
local Type, Version = "Label", 28
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local max, select, pairs = math.max, select, pairs

-- WoW APIs
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

local function UpdateImageAnchor(self)
	if self.resizing then return end
	local frame = self.frame
	local width = frame.width or frame:GetWidth() or 0
	local image = self.image
	local label = self.label
	local height

	label:ClearAllPoints()
	image:ClearAllPoints()

	if self.imageshown then
		local imagewidth = image:GetWidth()
		if (width - imagewidth) < 200 or (label:GetText() or "") == "" then
			-- image goes on top centered when less than 200 width for the text, or if there is no text
			image:SetPoint("TOP")
			label:SetPoint("TOP", image, "BOTTOM")
			label:SetPoint("LEFT")
			label:SetWidth(width)
			height = image:GetHeight() + label:GetStringHeight()
		else
			-- image on the left
			image:SetPoint("TOPLEFT")
			if image:GetHeight() > label:GetStringHeight() then
				label:SetPoint("LEFT", image, "RIGHT", 4, 0)
			else
				label:SetPoint("TOPLEFT", image, "TOPRIGHT", 4, 0)
			end
			label:SetWidth(width - imagewidth - 4)
			height = max(image:GetHeight(), label:GetStringHeight())
		end
	else
		-- no image shown
		label:SetPoint("TOPLEFT")
		label:SetWidth(width)
		height = label:GetStringHeight()
	end

	-- avoid zero-height labels, since they can used as spacers
	if not height or height == 0 then
		height = 1
	end

	self.resizing = true
	frame:SetHeight(height)
	frame.height = height
	self.resizing = nil
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		-- set the flag to stop constant size updates
		self.resizing = true
		-- height is set dynamically by the text and image size
		self:SetWidth(200)
		self:SetText()
		self:SetImage(nil)
		self:SetImageSize(16, 16)
		self:SetColor()
		self:SetFontObject()
		self:SetJustifyH("LEFT")
		self:SetJustifyV("TOP")

		-- reset the flag
		self.resizing = nil
		-- run the update explicitly
		UpdateImageAnchor(self)
	end,

	-- ["OnRelease"] = nil,

	["OnWidthSet"] = function(self, width)
		UpdateImageAnchor(self)
	end,

	["SetText"] = function(self, text)
		self.label:SetText(text)
		UpdateImageAnchor(self)
	end,

	["SetColor"] = function(self, r, g, b)
		if not (r and g and b) then
			r, g, b = 1, 1, 1
		end
		self.label:SetVertexColor(r, g, b)
	end,

	["SetImage"] = function(self, path, ...)
		local image = self.image
		image:SetTexture(path)

		if image:GetTexture() then
			self.imageshown = true
			local n = select("#", ...)
			if n == 4 or n == 8 then
				image:SetTexCoord(...)
			else
				image:SetTexCoord(0, 1, 0, 1)
			end
		else
			self.imageshown = nil
		end
		UpdateImageAnchor(self)
	end,

	["SetFont"] = function(self, font, height, flags)
		if not self.fontObject then
			self.fontObject = CreateFont("AceGUI30LabelFont" .. AceGUI:GetNextWidgetNum(Type))
		end
		self.fontObject:SetFont(font, height, flags)
		self:SetFontObject(self.fontObject)
	end,

	["SetFontObject"] = function(self, font)
		self.label:SetFontObject(font or GameFontHighlightSmall)
		UpdateImageAnchor(self)
	end,

	["SetImageSize"] = function(self, width, height)
		self.image:SetWidth(width)
		self.image:SetHeight(height)
		UpdateImageAnchor(self)
	end,

	["SetJustifyH"] = function(self, justifyH)
		self.label:SetJustifyH(justifyH)
	end,

	["SetJustifyV"] = function(self, justifyV)
		self.label:SetJustifyV(justifyV)
	end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local label = frame:CreateFontString(nil, "BACKGROUND", "GameFontHighlightSmall")
	local image = frame:CreateTexture(nil, "BACKGROUND")

	-- create widget
	local widget = {
		label = label,
		image = image,
		frame = frame,
		type  = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Label.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua ===
local Type, Version = "MultiLineEditBox", 33
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local pairs = pairs

-- WoW APIs
local GetCursorInfo, ClearCursor = GetCursorInfo, ClearCursor
local CreateFrame, UIParent = CreateFrame, UIParent
local _G = _G

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]

if not AceGUIMultiLineEditBoxInsertLink then
	-- upgradeable hook
	if ChatFrameUtil and ChatFrameUtil.InsertLink then
		hooksecurefunc(ChatFrameUtil, "InsertLink", function(...) return _G.AceGUIMultiLineEditBoxInsertLink(...) end)
	elseif ChatEdit_InsertLink then
		hooksecurefunc("ChatEdit_InsertLink", function(...) return _G.AceGUIMultiLineEditBoxInsertLink(...) end)
	end
end

function _G.AceGUIMultiLineEditBoxInsertLink(text)
	for i = 1, AceGUI:GetWidgetCount(Type) do
		local editbox = _G[("MultiLineEditBox%uEdit"):format(i)]
		if editbox and editbox:IsVisible() and editbox:HasFocus() then
			editbox:Insert(text)
			return true
		end
	end
end


local function Layout(self)
	self:SetHeight(self.numlines * 14 + (self.disablebutton and 19 or 41) + self.labelHeight)

	if self.labelHeight == 0 then
		self.scrollBar:SetPoint("TOP", self.frame, "TOP", 0, -23)
	else
		self.scrollBar:SetPoint("TOP", self.label, "BOTTOM", 0, -19)
	end

	if self.disablebutton then
		self.scrollBar:SetPoint("BOTTOM", self.frame, "BOTTOM", 0, 21)
		self.scrollBG:SetPoint("BOTTOMLEFT", 0, 4)
	else
		self.scrollBar:SetPoint("BOTTOM", self.button, "TOP", 0, 18)
		self.scrollBG:SetPoint("BOTTOMLEFT", self.button, "TOPLEFT")
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function OnClick(self)                                                     -- Button
	self = self.obj
	self.editBox:ClearFocus()
	if not self:Fire("OnEnterPressed", self.editBox:GetText()) then
		self.button:Disable()
	end
end

local function OnCursorChanged(self, _, y, _, cursorHeight)                      -- EditBox
	self, y = self.obj.scrollFrame, -y
	local offset = self:GetVerticalScroll()
	if y < offset then
		self:SetVerticalScroll(y)
	else
		y = y + cursorHeight - self:GetHeight()
		if y > offset then
			self:SetVerticalScroll(y)
		end
	end
end

local function OnEditFocusLost(self)                                             -- EditBox
	self:HighlightText(0, 0)
	self.obj:Fire("OnEditFocusLost")
end

local function OnEnter(self)                                                     -- EditBox / ScrollFrame
	self = self.obj
	if not self.entered then
		self.entered = true
		self:Fire("OnEnter")
	end
end

local function OnLeave(self)                                                     -- EditBox / ScrollFrame
	self = self.obj
	if self.entered then
		self.entered = nil
		self:Fire("OnLeave")
	end
end

local function OnMouseUp(self)                                                   -- ScrollFrame
	self = self.obj.editBox
	self:SetFocus()
	self:SetCursorPosition(self:GetNumLetters())
end

local function OnReceiveDrag(self)                                               -- EditBox / ScrollFrame
	local type, id, info, extra = GetCursorInfo()
	if type == "spell" then
		if C_Spell and C_Spell.GetSpellName then
			info = C_Spell.GetSpellName(extra)
		else
			info = GetSpellInfo(id, info)
		end
	elseif type ~= "item" then
		return
	end
	ClearCursor()
	self = self.obj
	local editBox = self.editBox
	if not editBox:HasFocus() then
		editBox:SetFocus()
		editBox:SetCursorPosition(editBox:GetNumLetters())
	end
	editBox:Insert(info)
	self.button:Enable()
end

local function OnSizeChanged(self, width, height)                                -- ScrollFrame
	self.obj.editBox:SetWidth(width)
end

local function OnTextChanged(self, userInput)                                    -- EditBox
	if userInput then
		self = self.obj
		self:Fire("OnTextChanged", self.editBox:GetText())
		self.button:Enable()
	end
end

local function OnTextSet(self)                                                   -- EditBox
	self:HighlightText(0, 0)
	self:SetCursorPosition(self:GetNumLetters())
	self:SetCursorPosition(0)
	self.obj.button:Disable()
end

local function OnVerticalScroll(self, offset)                                    -- ScrollFrame
	local editBox = self.obj.editBox
	editBox:SetHitRectInsets(0, 0, offset, editBox:GetHeight() - offset - self:GetHeight())
end

local function OnScrollRangeChanged(self, xrange, yrange)
	if yrange == 0 then
		self.obj.editBox:SetHitRectInsets(0, 0, 0, 0)
	else
		OnVerticalScroll(self, self:GetVerticalScroll())
	end
end

local function OnShowFocus(frame)
	frame.obj.editBox:SetFocus()
	frame:SetScript("OnShow", nil)
end

local function OnEditFocusGained(frame)
	AceGUI:SetFocus(frame.obj)
	frame.obj:Fire("OnEditFocusGained")
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self.editBox:SetText("")
		self:SetDisabled(false)
		self:SetWidth(200)
		self:DisableButton(false)
		self:SetNumLines()
		self.entered = nil
		self:SetMaxLetters(0)
	end,

	["OnRelease"] = function(self)
		self:ClearFocus()
	end,

	["SetDisabled"] = function(self, disabled)
		local editBox = self.editBox
		if disabled then
			editBox:ClearFocus()
			editBox:EnableMouse(false)
			editBox:SetTextColor(0.5, 0.5, 0.5)
			self.label:SetTextColor(0.5, 0.5, 0.5)
			self.scrollFrame:EnableMouse(false)
			self.button:Disable()
		else
			editBox:EnableMouse(true)
			editBox:SetTextColor(1, 1, 1)
			self.label:SetTextColor(1, 0.82, 0)
			self.scrollFrame:EnableMouse(true)
		end
	end,

	["SetLabel"] = function(self, text)
		if text and text ~= "" then
			self.label:SetText(text)
			if self.labelHeight ~= 10 then
				self.labelHeight = 10
				self.label:Show()
			end
		elseif self.labelHeight ~= 0 then
			self.labelHeight = 0
			self.label:Hide()
		end
		Layout(self)
	end,

	["SetNumLines"] = function(self, value)
		if not value or value < 4 then
			value = 4
		end
		self.numlines = value
		Layout(self)
	end,

	["SetText"] = function(self, text)
		self.editBox:SetText(text)
	end,

	["GetText"] = function(self)
		return self.editBox:GetText()
	end,

	["SetMaxLetters"] = function (self, num)
		self.editBox:SetMaxLetters(num or 0)
	end,

	["DisableButton"] = function(self, disabled)
		self.disablebutton = disabled
		if disabled then
			self.button:Hide()
		else
			self.button:Show()
		end
		Layout(self)
	end,

	["ClearFocus"] = function(self)
		self.editBox:ClearFocus()
		self.frame:SetScript("OnShow", nil)
	end,

	["SetFocus"] = function(self)
		self.editBox:SetFocus()
		if not self.frame:IsShown() then
			self.frame:SetScript("OnShow", OnShowFocus)
		end
	end,

	["HighlightText"] = function(self, from, to)
		self.editBox:HighlightText(from, to)
	end,

	["GetCursorPosition"] = function(self)
		return self.editBox:GetCursorPosition()
	end,

	["SetCursorPosition"] = function(self, ...)
		return self.editBox:SetCursorPosition(...)
	end,
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local backdrop = {
	bgFile = [[Interface\Tooltips\UI-Tooltip-Background]],
	edgeFile = [[Interface\Tooltips\UI-Tooltip-Border]], edgeSize = 16,
	insets = { left = 4, right = 3, top = 4, bottom = 3 }
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)
	frame:Hide()

	local widgetNum = AceGUI:GetNextWidgetNum(Type)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
	label:SetPoint("TOPLEFT", frame, "TOPLEFT", 0, -4)
	label:SetPoint("TOPRIGHT", frame, "TOPRIGHT", 0, -4)
	label:SetJustifyH("LEFT")
	label:SetText(ACCEPT)
	label:SetHeight(10)

	local button = CreateFrame("Button", ("%s%dButton"):format(Type, widgetNum), frame, "UIPanelButtonTemplate")
	button:SetPoint("BOTTOMLEFT", 0, 4)
	button:SetHeight(22)
	button:SetWidth(label:GetStringWidth() + 24)
	button:SetText(ACCEPT)
	button:SetScript("OnClick", OnClick)
	button:Disable()

	local text = button:GetFontString()
	text:ClearAllPoints()
	text:SetPoint("TOPLEFT", button, "TOPLEFT", 5, -5)
	text:SetPoint("BOTTOMRIGHT", button, "BOTTOMRIGHT", -5, 1)
	text:SetJustifyV("MIDDLE")

	local scrollBG = CreateFrame("Frame", nil, frame, "BackdropTemplate")
	scrollBG:SetBackdrop(backdrop)
	scrollBG:SetBackdropColor(0, 0, 0)
	scrollBG:SetBackdropBorderColor(0.4, 0.4, 0.4)

	local scrollFrame = CreateFrame("ScrollFrame", ("%s%dScrollFrame"):format(Type, widgetNum), frame, "UIPanelScrollFrameTemplate")

	local scrollBar = _G[scrollFrame:GetName() .. "ScrollBar"]
	scrollBar:ClearAllPoints()
	scrollBar:SetPoint("TOP", label, "BOTTOM", 0, -19)
	scrollBar:SetPoint("BOTTOM", button, "TOP", 0, 18)
	scrollBar:SetPoint("RIGHT", frame, "RIGHT")

	scrollBG:SetPoint("TOPRIGHT", scrollBar, "TOPLEFT", 0, 19)
	scrollBG:SetPoint("BOTTOMLEFT", button, "TOPLEFT")

	scrollFrame:SetPoint("TOPLEFT", scrollBG, "TOPLEFT", 5, -6)
	scrollFrame:SetPoint("BOTTOMRIGHT", scrollBG, "BOTTOMRIGHT", -4, 4)
	scrollFrame:SetScript("OnEnter", OnEnter)
	scrollFrame:SetScript("OnLeave", OnLeave)
	scrollFrame:SetScript("OnMouseUp", OnMouseUp)
	scrollFrame:SetScript("OnReceiveDrag", OnReceiveDrag)
	scrollFrame:SetScript("OnSizeChanged", OnSizeChanged)
	scrollFrame:HookScript("OnVerticalScroll", OnVerticalScroll)
	scrollFrame:HookScript("OnScrollRangeChanged", OnScrollRangeChanged)

	local editBox = CreateFrame("EditBox", ("%s%dEdit"):format(Type, widgetNum), scrollFrame)
	editBox:SetAllPoints()
	editBox:SetFontObject(ChatFontNormal)
	editBox:SetMultiLine(true)
	editBox:EnableMouse(true)
	editBox:SetAutoFocus(false)
	editBox:SetCountInvisibleLetters(false)
	editBox:SetScript("OnCursorChanged", OnCursorChanged)
	editBox:SetScript("OnEditFocusLost", OnEditFocusLost)
	editBox:SetScript("OnEnter", OnEnter)
	editBox:SetScript("OnEscapePressed", editBox.ClearFocus)
	editBox:SetScript("OnLeave", OnLeave)
	editBox:SetScript("OnMouseDown", OnReceiveDrag)
	editBox:SetScript("OnReceiveDrag", OnReceiveDrag)
	editBox:SetScript("OnTextChanged", OnTextChanged)
	editBox:SetScript("OnTextSet", OnTextSet)
	editBox:SetScript("OnEditFocusGained", OnEditFocusGained)


	scrollFrame:SetScrollChild(editBox)

	local widget = {
		button      = button,
		editBox     = editBox,
		frame       = frame,
		label       = label,
		labelHeight = 10,
		numlines    = 4,
		scrollBar   = scrollBar,
		scrollBG    = scrollBG,
		scrollFrame = scrollFrame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	button.obj, editBox.obj, scrollFrame.obj = widget, widget, widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type, Constructor, Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-MultiLineEditBox.lua ===


=== FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua ===
--[[-----------------------------------------------------------------------------
Slider Widget
Graphical Slider, like, for Range values.
-------------------------------------------------------------------------------]]
local Type, Version = "Slider", 23
local AceGUI = LibStub and LibStub("AceGUI-3.0", true)
if not AceGUI or (AceGUI:GetWidgetVersion(Type) or 0) >= Version then return end

-- Lua APIs
local min, max, floor = math.min, math.max, math.floor
local tonumber, pairs = tonumber, pairs

-- WoW APIs
local PlaySound = PlaySound
local CreateFrame, UIParent = CreateFrame, UIParent

--[[-----------------------------------------------------------------------------
Support functions
-------------------------------------------------------------------------------]]
local function UpdateText(self)
	local value = self.value or 0
	if self.ispercent then
		self.editbox:SetText(("%s%%"):format(floor(value * 1000 + 0.5) / 10))
	else
		self.editbox:SetText(floor(value * 100 + 0.5) / 100)
	end
end

local function UpdateLabels(self)
	local min_value, max_value = (self.min or 0), (self.max or 100)
	if self.ispercent then
		self.lowtext:SetFormattedText("%s%%", (min_value * 100))
		self.hightext:SetFormattedText("%s%%", (max_value * 100))
	else
		self.lowtext:SetText(min_value)
		self.hightext:SetText(max_value)
	end
end

--[[-----------------------------------------------------------------------------
Scripts
-------------------------------------------------------------------------------]]
local function Control_OnEnter(frame)
	frame.obj:Fire("OnEnter")
end

local function Control_OnLeave(frame)
	frame.obj:Fire("OnLeave")
end

local function Frame_OnMouseDown(frame)
	frame.obj.slider:EnableMouseWheel(true)
	AceGUI:ClearFocus()
end

local function Slider_OnValueChanged(frame, newvalue)
	local self = frame.obj
	if not frame.setup then
		if self.step and self.step > 0 then
			local min_value = self.min or 0
			newvalue = floor((newvalue - min_value) / self.step + 0.5) * self.step + min_value
		end
		if newvalue ~= self.value and not self.disabled then
			self.value = newvalue
			self:Fire("OnValueChanged", newvalue)
		end
		if self.value then
			UpdateText(self)
		end
	end
end

local function Slider_OnMouseUp(frame)
	local self = frame.obj
	self:Fire("OnMouseUp", self.value)
end

local function Slider_OnMouseWheel(frame, v)
	local self = frame.obj
	if not self.disabled then
		local value = self.value
		if v > 0 then
			value = min(value + (self.step or 1), self.max)
		else
			value = max(value - (self.step or 1), self.min)
		end
		self.slider:SetValue(value)
	end
end

local function EditBox_OnEscapePressed(frame)
	frame:ClearFocus()
end

local function EditBox_OnEnterPressed(frame)
	local self = frame.obj
	local value = frame:GetText()
	if self.ispercent then
		value = value:gsub('%%', '')
		value = tonumber(value) / 100
	else
		value = tonumber(value)
	end

	if value then
		PlaySound(856) -- SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON
		self.slider:SetValue(value)
		self:Fire("OnMouseUp", value)
	end
end

local function EditBox_OnEnter(frame)
	frame:SetBackdropBorderColor(0.5, 0.5, 0.5, 1)
end

local function EditBox_OnLeave(frame)
	frame:SetBackdropBorderColor(0.3, 0.3, 0.3, 0.8)
end

--[[-----------------------------------------------------------------------------
Methods
-------------------------------------------------------------------------------]]
local methods = {
	["OnAcquire"] = function(self)
		self:SetWidth(200)
		self:SetHeight(44)
		self:SetDisabled(false)
		self:SetIsPercent(nil)
		self:SetSliderValues(0,100,1)
		self:SetValue(0)
		self.slider:EnableMouseWheel(false)
	end,

	-- ["OnRelease"] = nil,

	["SetDisabled"] = function(self, disabled)
		self.disabled = disabled
		if disabled then
			self.slider:EnableMouse(false)
			self.label:SetTextColor(.5, .5, .5)
			self.hightext:SetTextColor(.5, .5, .5)
			self.lowtext:SetTextColor(.5, .5, .5)
			--self.valuetext:SetTextColor(.5, .5, .5)
			self.editbox:SetTextColor(.5, .5, .5)
			self.editbox:EnableMouse(false)
			self.editbox:ClearFocus()
		else
			self.slider:EnableMouse(true)
			self.label:SetTextColor(1, .82, 0)
			self.hightext:SetTextColor(1, 1, 1)
			self.lowtext:SetTextColor(1, 1, 1)
			--self.valuetext:SetTextColor(1, 1, 1)
			self.editbox:SetTextColor(1, 1, 1)
			self.editbox:EnableMouse(true)
		end
	end,

	["SetValue"] = function(self, value)
		self.slider.setup = true
		self.slider:SetValue(value)
		self.value = value
		UpdateText(self)
		self.slider.setup = nil
	end,

	["GetValue"] = function(self)
		return self.value
	end,

	["SetLabel"] = function(self, text)
		self.label:SetText(text)
	end,

	["SetSliderValues"] = function(self, min_value, max_value, step)
		local frame = self.slider
		frame.setup = true
		self.min = min_value
		self.max = max_value
		self.step = step
		frame:SetMinMaxValues(min_value or 0,max_value or 100)
		UpdateLabels(self)
		frame:SetValueStep(step or 1)
		if self.value then
			frame:SetValue(self.value)
		end
		frame.setup = nil
	end,

	["SetIsPercent"] = function(self, value)
		self.ispercent = value
		UpdateLabels(self)
		UpdateText(self)
	end
}

--[[-----------------------------------------------------------------------------
Constructor
-------------------------------------------------------------------------------]]
local SliderBackdrop  = {
	bgFile = "Interface\\Buttons\\UI-SliderBar-Background",
	edgeFile = "Interface\\Buttons\\UI-SliderBar-Border",
	tile = true, tileSize = 8, edgeSize = 8,
	insets = { left = 3, right = 3, top = 6, bottom = 6 }
}

local ManualBackdrop = {
	bgFile = "Interface\\ChatFrame\\ChatFrameBackground",
	edgeFile = "Interface\\ChatFrame\\ChatFrameBackground",
	tile = true, edgeSize = 1, tileSize = 5,
}

local function Constructor()
	local frame = CreateFrame("Frame", nil, UIParent)

	frame:EnableMouse(true)
	frame:SetScript("OnMouseDown", Frame_OnMouseDown)

	local label = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
	label:SetPoint("TOPLEFT")
	label:SetPoint("TOPRIGHT")
	label:SetJustifyH("CENTER")
	label:SetHeight(15)

	local slider = CreateFrame("Slider", nil, frame, "BackdropTemplate")
	slider:SetOrientation("HORIZONTAL")
	slider:SetHeight(15)
	slider:SetHitRectInsets(0, 0, -10, 0)
	slider:SetBackdrop(SliderBackdrop)
	slider:SetThumbTexture("Interface\\Buttons\\UI-SliderBar-Button-Horizontal")
	slider:SetPoint("TOP", label, "BOTTOM")
	slider:SetPoint("LEFT", 3, 0)
	slider:SetPoint("RIGHT", -3, 0)
	slider:SetValue(0)
	slider:SetScript("OnValueChanged",Slider_OnValueChanged)
	slider:SetScript("OnEnter", Control_OnEnter)
	slider:SetScript("OnLeave", Control_OnLeave)
	slider:SetScript("OnMouseUp", Slider_OnMouseUp)
	slider:SetScript("OnMouseWheel", Slider_OnMouseWheel)

	local lowtext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
	lowtext:SetPoint("TOPLEFT", slider, "BOTTOMLEFT", 2, 3)

	local hightext = slider:CreateFontString(nil, "ARTWORK", "GameFontHighlightSmall")
	hightext:SetPoint("TOPRIGHT", slider, "BOTTOMRIGHT", -2, 3)

	local editbox = CreateFrame("EditBox", nil, frame, "BackdropTemplate")
	editbox:SetAutoFocus(false)
	editbox:SetFontObject(GameFontHighlightSmall)
	editbox:SetPoint("TOP", slider, "BOTTOM")
	editbox:SetHeight(14)
	editbox:SetWidth(70)
	editbox:SetJustifyH("CENTER")
	editbox:EnableMouse(true)
	editbox:SetBackdrop(ManualBackdrop)
	editbox:SetBackdropColor(0, 0, 0, 0.5)
	editbox:SetBackdropBorderColor(0.3, 0.3, 0.30, 0.80)
	editbox:SetScript("OnEnter", EditBox_OnEnter)
	editbox:SetScript("OnLeave", EditBox_OnLeave)
	editbox:SetScript("OnEnterPressed", EditBox_OnEnterPressed)
	editbox:SetScript("OnEscapePressed", EditBox_OnEscapePressed)

	local widget = {
		label       = label,
		slider      = slider,
		lowtext     = lowtext,
		hightext    = hightext,
		editbox     = editbox,
		alignoffset = 25,
		frame       = frame,
		type        = Type
	}
	for method, func in pairs(methods) do
		widget[method] = func
	end
	slider.obj, editbox.obj = widget, widget

	return AceGUI:RegisterAsWidget(widget)
end

AceGUI:RegisterWidgetType(Type,Constructor,Version)

=== END OF FILE: WeakAurasOptions/Libs/AceGUI-3.0/widgets/AceGUIWidget-Slider.lua ===


=== FILE: WeakAurasOptions/Libs/LibAPIAutoComplete-1.0/LibAPIAutoComplete-1.0.lua ===
local MAJOR, MINOR = "LibAPIAutoComplete-1.0", 5
local lib = LibStub:NewLibrary(MAJOR, MINOR)
if not lib then return end

local SharedMedia = LibStub("LibSharedMedia-3.0")

local config = {}

local skipWords = {
  ["local"] = true,
  ["print"] = true,
  ["player"] = true,
  ["display"] = true,
  ["return"] = true,
  ["function"] = true
}

local maxMatches = 100

for k in pairs(skipWords) do
  for i = #k, 5, -1 do
     skipWords[k:sub(1, i)] = true
  end
end

local function LoadBlizzard_APIDocumentation()
  local apiAddonName = "Blizzard_APIDocumentation"
  local _, loaded = C_AddOns.IsAddOnLoaded(apiAddonName)
  if not loaded then
    C_AddOns.LoadAddOn(apiAddonName)
  end
  if #APIDocumentation.systems == 0 then
    -- workaround nil errors when loading PetConstantsDocumentation.lua
    Constants.PetConsts = Constants.PetConsts or {
      MAX_STABLE_SLOTS = 200,
      MAX_SUMMONABLE_PETS = 25,
      MAX_SUMMONABLE_HUNTER_PETS = 5,
      NUM_PET_SLOTS_THAT_NEED_LEARNED_SPELL = 5,
      NUM_PET_SLOTS = 205,
      EXTRA_PET_STABLE_SLOT = 5,
      STABLED_PETS_FIRST_SLOT_INDEX = 6
    }
    MAX_STABLE_SLOTS = MAX_STABLE_SLOTS or 2
    NUM_PET_SLOTS_THAT_NEED_LEARNED_SPELL = NUM_PET_SLOTS_THAT_NEED_LEARNED_SPELL or 1
    EXTRA_PET_STABLE_SLOT = EXTRA_PET_STABLE_SLOT or 0
    -- end of workaround
    APIDocumentation_LoadUI()
  end
end

function lib:Hide()
  self.scrollBox:Hide()
  self.scrollBar:Hide()
end

---Create APIDoc widget and ensure Blizzard_APIDocumentation is loaded
local isInit = false
local function Init()
  if isInit then
    return
  end
  isInit = true

  -- load Blizzard_APIDocumentation
  LoadBlizzard_APIDocumentation()

  local scrollBox = CreateFrame("Frame", nil, UIParent, "WowScrollBoxList")
  scrollBox:SetSize(400, 150)
  scrollBox:Hide()

  local background = scrollBox:CreateTexture(nil, "BACKGROUND")
  background:SetAllPoints()
  scrollBox.background = background

  local scrollBar = CreateFrame("EventFrame", nil, UIParent, "WowTrimScrollBar")
  scrollBar:SetPoint("TOPLEFT", scrollBox, "TOPRIGHT")
  scrollBar:SetPoint("BOTTOMLEFT", scrollBox, "BOTTOMRIGHT")
  scrollBar:Hide()

  local view = CreateScrollBoxListLinearView()
  view:SetElementExtentCalculator(function(dataIndex, elementData)
    return 20
  end)
  view:SetElementInitializer("button", function(frame, elementData)
    Mixin(frame, APIAutoCompleteLineMixin)
    frame:Init(elementData)
  end)
  ScrollUtil.InitScrollBoxListWithScrollBar(scrollBox, scrollBar, view)
  local selectionBehaviour = ScrollUtil.AddSelectionBehavior(scrollBox, SelectionBehaviorFlags.Deselectable, SelectionBehaviorFlags.Intrusive)
  selectionBehaviour:RegisterCallback(SelectionBehaviorMixin.Event.OnSelectionChanged, function(o, elementData, selected)
    local elementFrame = scrollBox:FindFrame(elementData)
    if elementFrame then
      elementFrame:SetSelected(selected)
    end

    if selected and lib.editbox and config[lib.editbox] then
      local maxLinesShown = config[lib.editbox].maxLinesShown
      local index = lib.data:FindIndex(elementData)
      local divisor = lib.data:GetSize() - maxLinesShown
      if divisor == 0 then
        divisor = 1
      end
      local percent = (index - maxLinesShown / 2) / divisor
      if percent < 0 then
        percent = 0
      elseif percent > 1 then
        percent = 1
      end
      scrollBar:SetScrollPercentage(percent)
    end
  end)

  lib.data = CreateDataProvider()
  scrollBox:SetDataProvider(lib.data)

  lib.scrollBar = scrollBar
  lib.scrollBox = scrollBox
  lib.selectionBehaviour = selectionBehaviour

  scrollBox.selectionBehaviour = selectionBehaviour

  scrollBox:SetScript("OnKeyDown", function(self, key)
    if key == "DOWN" then
      lib.scrollBox:SetPropagateKeyboardInput(false)
      if not self.selectionBehaviour:HasSelection() then
        self.selectionBehaviour:SelectFirstElementData()
      else
        self.selectionBehaviour:SelectNextElementData()
      end
    elseif key == "UP" then
      lib.scrollBox:SetPropagateKeyboardInput(false)
      if not self.selectionBehaviour:HasSelection() then
        self.selectionBehaviour:SelectFirstElementData()
      else
        self.selectionBehaviour:SelectPreviousElementData()
      end
    elseif key == "ENTER" and not IsModifierKeyDown() then
      local selectedElementData = self.selectionBehaviour:GetFirstSelectedElementData()
      if selectedElementData then
        lib.scrollBox:SetPropagateKeyboardInput(false)
        local elementFrame = scrollBox:FindFrame(selectedElementData)
        elementFrame:Insert()
      end
    elseif key == "ESCAPE" then
      lib.scrollBox:SetPropagateKeyboardInput(false)
      lib.data:Flush()
      lib:UpdateWidget(lib.editbox)
    else
      lib.scrollBox:SetPropagateKeyboardInput(true)
      lib.data:Flush()
      lib:UpdateWidget(lib.editbox)
    end
  end)
end

local lastPosition

---@private
---@param editbox EditBox
---@param x number
---@param y number
---@param w number
---@param h number
local function OnTextChanged(editbox, x, y, w, h)
  local cursorPosition = editbox:GetCursorPosition()
  if cursorPosition ~= lastPosition then
    lib:Hide()
    lib.scrollBox:ClearAllPoints()
    lib.scrollBox:SetPoint("TOPLEFT", editbox, "TOPLEFT", x, y - h)
    local currentWord = lib:GetWord(editbox)
    if #currentWord > 4 and not skipWords[currentWord] then
      lib:Search(currentWord, config[editbox])
      if lib.data:GetSize() == 1 and lib.data:Find(1).name == currentWord then
        lib.data:Flush()
      end
      lib:UpdateWidget(editbox)
    end
  end
  lastPosition = cursorPosition
end

---@class Color
---@field r integer
---@field g integer
---@field b integer
---@field a integer?

---@class Params
---@field backgroundColor Color?
---@field maxLinesShown integer?
---@field disableFunctions boolean?
---@field disableEvents boolean?
---@field disableSystems boolean?

---Enable APIDoc widget on editbox
---ForAllIndentsAndPurpose replace GetText, APIDoc must be enabled before FAIAP
---@param editbox EditBox
---@param params Params
function lib:enable(editbox, params)
  if config[editbox] then
    return
  end
  config[editbox] = {
    backgroundColor = params and params.backgroundColor or {.3, .3, .3, .9},
    maxLinesShown = params and params.maxLinesShown or 7,
    disableFunctions = params and params.disableFunctions or false,
    disableEvents = params and params.disableEvents or false,
    disableSystems = params and params.disableSystems or false,
  }
  Init()
  -- hack for WeakAuras
  editbox.APIDoc_originalGetText = editbox.GetText
  editbox.APIDoc_originalSetText = editbox.SetText
  -- hack for WowLua
  if editbox == WowLuaFrameEditBox then
    editbox.APIDoc_originalGetText = function()
      return WowLua.indent.coloredGetText(editbox)
    end
  end
  editbox.APIDoc_oldOnCursorChanged = editbox:GetScript("OnCursorChanged")
  editbox:SetScript("OnCursorChanged", function(...)
    if editbox.APIDoc_oldOnCursorChanged then
      editbox.APIDoc_oldOnCursorChanged(...)
    end
    local _, x, y, w, h = ...
    editbox.lastCursorChanged = {
      time = GetTime(),
      x = x,
      y = y,
      w = w,
      h = h
    }
  end)
  editbox.APIDoc_oldOnTextChanged = editbox:GetScript("OnTextChanged")
  editbox:SetScript("OnTextChanged", function(...)
    if editbox.APIDoc_oldOnTextChanged then
      editbox.APIDoc_oldOnTextChanged(...)
    end
    local info = editbox.lastCursorChanged
    if info and info.time == GetTime() then
      OnTextChanged(editbox, info.x, info.y, info.w, info.h)
    end
  end)
  editbox:SetScript("OnHide", function(...)
    lib:Hide()
  end)
  editbox.APIDoc_hiddenString = editbox:CreateFontString()
end

---Disable APIDoc widget on editbox
---@param editbox EditBox
function lib:disable(editbox)
  if not config[editbox] then
    return
  end
  config[editbox] = nil
  editbox:SetScript("OnCursorChanged", editbox.APIDoc_oldOnCursorChanged)
  editbox.APIDoc_oldOnCursorChanged = nil
  editbox:SetScript("OnTextChanged", editbox.APIDoc_oldOnTextChanged)
  editbox.APIDoc_oldOnTextChanged = nil
end

function lib:addLine(apiInfo)
  local name
  if apiInfo.Type == "System" then
    name = apiInfo.Namespace
  elseif apiInfo.Type == "Function" then
    name = apiInfo:GetFullName()
  elseif apiInfo.Type == "Event" then
    name = apiInfo.LiteralName
  end
  self.data:Insert({ name = name, apiInfo = apiInfo })
end

---Search a word in documentation, set results in lib.data
---@param word string
---@param config Params
function lib:Search(word, config)
  self.data:Flush()
  if word and #word > 3 then
    local lowerWord = word:lower();
    local nsName, rest = lowerWord:match("^([%w%_]+)(.*)")
    local funcName = rest and rest:match("^%.([%w%_]+)")
    for _, systemInfo in ipairs(APIDocumentation.systems) do
      local systemMatch = (not config.disableSystems)
        and (nsName and #nsName >= 4)
        and (systemInfo.Namespace and systemInfo.Namespace:lower():match(nsName))

      if not config.disableFunctions then
        for _, apiInfo in ipairs(systemInfo.Functions) do
          if systemMatch then
            if funcName then
              if apiInfo:MatchesSearchString(funcName) then
                self:addLine(apiInfo)
              end
            else
              self:addLine(apiInfo)
            end
          else
            if apiInfo:MatchesSearchString(lowerWord) then
              self:addLine(apiInfo)
            end
          end
        end
      end

      if not config.disableEvents then
        if systemMatch and rest == "" then
          for _, apiInfo in ipairs(systemInfo.Events) do
            self:addLine(apiInfo)
          end
        else
          for _, apiInfo in ipairs(systemInfo.Events) do
            if apiInfo:MatchesSearchString(lowerWord) then
              self:addLine(apiInfo)
            end
          end
        end
      end

      if self.data:GetSize() > maxMatches then
        break
      end
    end
  end
end

---set in lib.data the list of systems
function lib:ListSystems()
  self.data:Flush()
  for i, systemInfo in ipairs(APIDocumentation.systems) do
    if systemInfo.Namespace and #systemInfo.Functions > 0 then
      self:addLine(systemInfo)
    end
  end
end

---Hide, or Show and fill APIDoc widget, using lib.data data
---@param editbox EditBox
function lib:UpdateWidget(editbox)
  if self.data:IsEmpty() then
    self:Hide()
    self.editbox = nil
  else
    -- fix size
    local maxLinesShown = config[editbox].maxLinesShown
    local lines = self.data:GetSize()
    local height = math.min(lines, maxLinesShown) * 20
    local width = 0
    local hiddenString = editbox.APIDoc_hiddenString
    local fontPath = SharedMedia:Fetch("font", "Fira Mono Medium")
    hiddenString:SetFont(fontPath, 12, "")
    for _, elementData in self.data:Enumerate() do
      hiddenString:SetText(elementData.name)
      width = math.max(width, hiddenString:GetStringWidth())
    end
    self.scrollBox:SetSize(width, height)

    -- fix look
    local backgroundColor = config[editbox].backgroundColor
    self.scrollBox.background:SetColorTexture(unpack(backgroundColor))

    -- show
    self.scrollBox:SetParent(UIParent)
    self.scrollBar:SetParent(UIParent)
    self.scrollBox:SetFrameStrata("TOOLTIP")
    self.scrollBar:SetFrameStrata("TOOLTIP")
    self.scrollBox:Show()
    self.scrollBar:SetShown(lines > maxLinesShown)
    self.editbox = editbox
  end
end

local function OnClickCallback(self)
  local name
  if IndentationLib then
    name = IndentationLib.stripWowColors(self.name)
  elseif WowLua and WowLua.indent then
    name = WowLua.indent.stripWowColors(self.name)
  end
  lib:SetWord(lib.editbox, name)
  lib:Hide()
  lib.editbox:SetFocus()
end

---@param editbox EditBox
---@return string currentWord
---@return integer startPosition
---@return integer endPosition
function lib:GetWord(editbox)
  -- get cursor position
  local cursorPosition = editbox:GetCursorPosition()
  local text = editbox:APIDoc_originalGetText()
  if IndentationLib then
    text, cursorPosition = IndentationLib.stripWowColorsWithPos(text, cursorPosition)
  end

  -- get start position of current word
  local startPosition = cursorPosition
  while startPosition - 1 > 0 and text:sub(startPosition - 1, startPosition - 1):find("[%w%.%_]") do
    startPosition = startPosition - 1
  end

  -- get end position of current word
  local endPosition = startPosition
  while endPosition < #text and text:sub(endPosition + 1, endPosition + 1):find("[%w%.%_]") do
    endPosition = endPosition + 1
  end

  local nextChar = text:sub(cursorPosition, cursorPosition)
  if nextChar ~= "" and nextChar ~= " " and nextChar ~= "\n" then
    return "", nil, nil
  end

  local currentWord = text:sub(startPosition, endPosition)
  return currentWord, startPosition, endPosition
end

---@param editbox EditBox
---@param word string
function lib:SetWord(editbox, word)
  -- get cursor position
  local cursorPosition = editbox:GetCursorPosition()
  local text = editbox:APIDoc_originalGetText()
  if IndentationLib then
    text, cursorPosition = IndentationLib.stripWowColorsWithPos(text, cursorPosition)
  end

  -- get start position of current word
  local startPosition = cursorPosition
  while startPosition > 0 and text:sub(startPosition - 1, startPosition - 1):find("[%w%.%_]") do
    startPosition = startPosition - 1
  end

  -- get end position of current word
  local endPosition = startPosition
  while endPosition < #text and text:sub(endPosition + 1, endPosition + 1):find("[%w%.%_]") do
    endPosition = endPosition + 1
  end

  -- check if replacement word looks like a function and has args
  local funcName, argsString = word:match("([%w%.%_]+)%(([%w%.%_,\"%s]*)%)")
  local funcArgs = {}
  if funcName and argsString then
    for arg in argsString:gmatch("([%w%.%_\"]+),?") do
      table.insert(funcArgs, arg)
    end
  end

  -- check if current word has parentheses and args
  local oldFuncArgs = {}
  if funcName then
    local currentWordArgs = text:sub(endPosition + 1, #text):match("^%(([%w%.%_,\"%s]*)%)")
    if currentWordArgs then
      for arg in currentWordArgs:gmatch("([%w%.%_\"]+),?") do
        table.insert(oldFuncArgs, arg)
      end
      -- move endPosition
      endPosition = endPosition + #currentWordArgs + 2
    end
  end

  -- replace replacement word's args with args from current word
  if funcName then
    local concatArgs = {}
    for i = 1, math.max(#funcArgs, #oldFuncArgs) do
      concatArgs[i] = oldFuncArgs[i] or funcArgs[i]
    end
    word = funcName .. "(" .. table.concat(concatArgs, ", ") .. ")"
  end

  -- replace word
  text = text:sub(1, startPosition - 1) .. word .. text:sub(endPosition + 1, #text)
  editbox:APIDoc_originalSetText(text)
  -- SetText triggers the OnTextChanged handler without the "userInput" flag. We need that flag set to true, so run the handler again
  local script = editbox:GetScript("OnTextChanged")
  if script then
    script(editbox, true)
  end

  -- move cursor at end of word or start of parenthese
  local parenthesePosition = word:find("%(")
  editbox:SetCursorPosition(startPosition - 1 + (parenthesePosition or #word))
end

local function showTooltip(self)
  if self.apiInfo then
    GameTooltip:SetOwner(self, "ANCHOR_BOTTOMRIGHT", 20, 20)
    GameTooltip:ClearLines()
    for _, line in ipairs(self.apiInfo:GetDetailedOutputLines()) do
      GameTooltip:AddLine(line)
    end
    GameTooltip:Show()
  end
end

local function hideTooltip(self)
  GameTooltip:Hide()
  GameTooltip:ClearLines()
end

APIAutoCompleteLineMixin = {}
function APIAutoCompleteLineMixin:Init(elementData)
  self.name = elementData.name
  self.apiInfo = elementData.apiInfo
  self:SetText(elementData.name)
  self:SetScript("OnClick", OnClickCallback)
  self:SetScript("OnEnter", showTooltip)
  self:SetScript("OnLeave", hideTooltip)
  local fontString = self:GetFontString()
  fontString:ClearAllPoints()
  local fontPath = SharedMedia:Fetch("font", "Fira Mono Medium")
  fontString:SetFont(fontPath, 12, "")
  fontString:SetPoint("LEFT")
  fontString:SetTextColor(0.973, 0.902, 0.581)
  if not self:GetHighlightTexture() then
    local texture = self:CreateTexture()
    texture:SetColorTexture(0.4,0.4,0.4,0.5)
    texture:SetAllPoints()
    self:SetHighlightTexture(texture)
  end
  self:SetSelected(false)
end

function APIAutoCompleteLineMixin:SetSelected(selected)
  self:SetHighlightLocked(selected)
end

function APIAutoCompleteLineMixin:Insert()
  OnClickCallback(self)
end

=== END OF FILE: WeakAurasOptions/Libs/LibAPIAutoComplete-1.0/LibAPIAutoComplete-1.0.lua ===


=== FILE: WeakAurasOptions/Libs/LibUIDropDownMenu/LibEasyMenu.lua ===
--$Id: LibEasyMenu.lua 64 2020-11-18 13:13:15Z arithmandar $
-- //////////////////////////////////////////////////////////////
-- Notes: 
--      Functions have been moved to under LibUIDropDownMenu.lua
--      New function calls are as below:
--
--      - lib:EasyMenu(menuList, menuFrame, anchor, x, y, displayMode, autoHideDelay )
--      - lib:EasyMenu_Initialize( frame, level, menuList )
--
-- //////////////////////////////////////////////////////////////
-- Simplified Menu Display System
--	This is a basic system for displaying a menu from a structure table.
--
--	See UIDropDownMenu.lua for the menuList details.
--
--	Args:
--		menuList - menu table
--		menuFrame - the UI frame to populate
--		anchor - where to anchor the frame (e.g. CURSOR)
--		x - x offset
--		y - y offset
--		displayMode - border type
--		autoHideDelay - how long until the menu disappears
--
--
--[[
function EasyMenu(menuList, menuFrame, anchor, x, y, displayMode, autoHideDelay )
	if ( displayMode == "MENU" ) then
		menuFrame.displayMode = displayMode;
	end
	UIDropDownMenu_Initialize(menuFrame, EasyMenu_Initialize, displayMode, nil, menuList);
	ToggleDropDownMenu(1, nil, menuFrame, anchor, x, y, menuList, nil, autoHideDelay);
end

function EasyMenu_Initialize( frame, level, menuList )
	for index = 1, #menuList do
		local value = menuList[index]
		if (value.text) then
			value.index = index;
			UIDropDownMenu_AddButton( value, level );
		end
	end
end
]]
=== END OF FILE: WeakAurasOptions/Libs/LibUIDropDownMenu/LibEasyMenu.lua ===


=== FILE: WeakAurasOptions/Libs/LibUIDropDownMenu/LibUIDropDownMenu.lua ===
-- $Id: LibUIDropDownMenu.lua 135 2024-02-05 16:50:14Z arithmandar $
-- ----------------------------------------------------------------------------
-- Localized Lua globals.
-- ----------------------------------------------------------------------------
local _G = getfenv(0)
local tonumber, type, string, table = _G.tonumber, _G.type, _G.string, _G.table
local tinsert = table.insert
local strsub, strlen, strmatch, gsub = _G.strsub, _G.strlen, _G.strmatch, _G.gsub
local max, match = _G.max, _G.match
local securecall, issecure = _G.securecall, _G.issecure
local wipe = table.wipe
-- WoW
local CreateFrame, GetCursorPosition, GetCVar, GetScreenHeight, GetScreenWidth, PlaySound = _G.CreateFrame, _G.GetCursorPosition, _G.GetCVar, _G.GetScreenHeight, _G.GetScreenWidth, _G.PlaySound
local GetBuildInfo = _G.GetBuildInfo
local GameTooltip, GetAppropriateTooltip, tooltip, GetValueOrCallFunction
local CloseMenus, ShowUIPanel = _G.CloseMenus, _G.ShowUIPanel
local GameTooltip_SetTitle, GameTooltip_AddInstructionLine, GameTooltip_AddNormalLine, GameTooltip_AddColoredLine = _G.GameTooltip_SetTitle, _G.GameTooltip_AddInstructionLine, _G.GameTooltip_AddNormalLine, _G.GameTooltip_AddColoredLine

-- ----------------------------------------------------------------------------
local MAJOR_VERSION = "LibUIDropDownMenu-4.0"
local MINOR_VERSION = 90000 + tonumber(("$Rev: 135 $"):match("%d+"))


local LibStub = _G.LibStub
if not LibStub then error(MAJOR_VERSION .. " requires LibStub.") end
local lib = LibStub:NewLibrary(MAJOR_VERSION, MINOR_VERSION)
if not lib then return end

-- Determine WoW TOC Version
local WoWClassicEra, WoWClassicTBC, WoWWOTLKC, WoWRetail
local wowversion  = select(4, GetBuildInfo())
if wowversion < 20000 then
	WoWClassicEra = true
elseif wowversion < 30000 then 
	WoWClassicTBC = true
elseif wowversion < 40000 then 
	WoWWOTLKC = true
elseif wowversion > 90000 then
	WoWRetail = true

else
	-- n/a
end

if WoWClassicEra or WoWClassicTBC or WoWWOTLKC then
	GameTooltip = _G.GameTooltip
	tooltip = GameTooltip
else -- Retail
	GetAppropriateTooltip = _G.GetAppropriateTooltip
	tooltip = GetAppropriateTooltip()
	GetValueOrCallFunction = _G.GetValueOrCallFunction
end

-- //////////////////////////////////////////////////////////////
L_UIDROPDOWNMENU_MINBUTTONS = 8; -- classic only
L_UIDROPDOWNMENU_MAXBUTTONS = 1;
L_UIDROPDOWNMENU_MAXLEVELS = 3;
L_UIDROPDOWNMENU_BUTTON_HEIGHT = 16;
L_UIDROPDOWNMENU_BORDER_HEIGHT = 15;
-- The current open menu
L_UIDROPDOWNMENU_OPEN_MENU = nil;
-- The current menu being initialized
L_UIDROPDOWNMENU_INIT_MENU = nil;
-- Current level shown of the open menu
L_UIDROPDOWNMENU_MENU_LEVEL = 1;
-- Current value of the open menu
L_UIDROPDOWNMENU_MENU_VALUE = nil;
-- Time to wait to hide the menu
L_UIDROPDOWNMENU_SHOW_TIME = 2;
-- Default dropdown text height
L_UIDROPDOWNMENU_DEFAULT_TEXT_HEIGHT = nil;
-- For Classic checkmarks, this is the additional padding that we give to the button text.
L_UIDROPDOWNMENU_CLASSIC_CHECK_PADDING = 4;
-- Default dropdown width padding
L_UIDROPDOWNMENU_DEFAULT_WIDTH_PADDING = 25;
-- List of open menus
L_OPEN_DROPDOWNMENUS = {};

local L_DropDownList1, L_DropDownList2, L_DropDownList3

local delegateFrame = CreateFrame("FRAME");
delegateFrame:SetScript("OnAttributeChanged", function(self, attribute, value)
	if ( attribute == "createframes" and value == true ) then
		lib:UIDropDownMenu_CreateFrames(self:GetAttribute("createframes-level"), self:GetAttribute("createframes-index"));
	elseif ( attribute == "initmenu" ) then
		L_UIDROPDOWNMENU_INIT_MENU = value;
	elseif ( attribute == "openmenu" ) then
		L_UIDROPDOWNMENU_OPEN_MENU = value;
	end
end);

function lib:UIDropDownMenu_InitializeHelper(frame)
	-- This deals with the potentially tainted stuff!
	if ( frame ~= L_UIDROPDOWNMENU_OPEN_MENU ) then
		L_UIDROPDOWNMENU_MENU_LEVEL = 1;
	end

	-- Set the frame that's being intialized
	delegateFrame:SetAttribute("initmenu", frame);

	-- Hide all the buttons
	local button, dropDownList;
	for i = 1, L_UIDROPDOWNMENU_MAXLEVELS, 1 do
		dropDownList = _G["L_DropDownList"..i];
		if ( i >= L_UIDROPDOWNMENU_MENU_LEVEL or frame ~= L_UIDROPDOWNMENU_OPEN_MENU ) then
			dropDownList.numButtons = 0;
			dropDownList.maxWidth = 0;
			for j=1, L_UIDROPDOWNMENU_MAXBUTTONS, 1 do
				button = _G["L_DropDownList"..i.."Button"..j];
				button:Hide();
			end
			dropDownList:Hide();
		end
	end
	frame:SetHeight(L_UIDROPDOWNMENU_BUTTON_HEIGHT * 2);
end

function lib:UIDropDownMenuButton_ShouldShowIconTooltip(self)
	if self.Icon and (self.iconTooltipTitle or self.iconTooltipText) and (self.icon or self.mouseOverIcon) then
		return GetMouseFocus() == self.Icon;
	end
	return false;
end


-- //////////////////////////////////////////////////////////////
-- L_UIDropDownMenuButtonTemplate
local function create_MenuButton(name, parent)
	-- UIDropDownMenuButton Scripts BEGIN
	local function button_OnEnter(self)
		if ( self.hasArrow ) then
			local level =  self:GetParent():GetID() + 1;
			local listFrame = _G["L_DropDownList"..level];
			if ( not listFrame or not listFrame:IsShown() or select(2, listFrame:GetPoint(1)) ~= self ) then
				lib:ToggleDropDownMenu(self:GetParent():GetID() + 1, self.value, nil, nil, nil, nil, self.menuList, self, nil, self.menuListDisplayMode);
			end
		else
			lib:CloseDropDownMenus(self:GetParent():GetID() + 1);
		end
		self.Highlight:Show();
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
	    		lib:UIDropDownMenu_StopCounting(self:GetParent());
		end
		-- To check: do we need special handle for classic since there is no UIDropDownMenuButton_ShouldShowIconTooltip()?
		-- if ( self.tooltipTitle and not self.noTooltipWhileEnabled ) then
		if ( self.tooltipTitle and not self.noTooltipWhileEnabled and not lib:UIDropDownMenuButton_ShouldShowIconTooltip(self)) then
			if ( self.tooltipOnButton ) then
				tooltip:SetOwner(self, "ANCHOR_RIGHT");
				GameTooltip_SetTitle(tooltip, self.tooltipTitle);
				if self.tooltipInstruction then
					GameTooltip_AddInstructionLine(tooltip, self.tooltipInstruction);
				end
				if self.tooltipText then
					GameTooltip_AddNormalLine(tooltip, self.tooltipText, true);
				end
				if self.tooltipWarning then
					GameTooltip_AddColoredLine(tooltip, self.tooltipWarning, RED_FONT_COLOR, true);
				end
				if self.tooltipBackdropStyle then
					SharedTooltip_SetBackdropStyle(tooltip, self.tooltipBackdropStyle);
				end
				tooltip:Show();
			end
		end
					
		if ( self.mouseOverIcon ~= nil ) then
			self.Icon:SetTexture(self.mouseOverIcon);
			self.Icon:Show();
		end
		if (WoWRetail) then
			GetValueOrCallFunction(self, "funcOnEnter", self);
			if self.NewFeature then
				self.NewFeature:Hide();
			end
		end
	end

	local function button_OnLeave(self)
		self.Highlight:Hide();
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			lib:UIDropDownMenu_StartCounting(self:GetParent());
		end

		tooltip:Hide();
					
		if ( self.mouseOverIcon ~= nil ) then
			if ( self.icon ~= nil ) then
				self.Icon:SetTexture(self.icon);
			else
				self.Icon:Hide();
			end
		end

		if (WoWRetail) then
			GetValueOrCallFunction(self, "funcOnLeave", self);
		end
	end

	local function button_OnClick(self, button)
		local checked = self.checked;
		if ( type (checked) == "function" ) then
			checked = checked(self);
		end

		if ( self.keepShownOnClick ) then
			if not self.notCheckable then
				if ( checked ) then
					_G[self:GetName().."Check"]:Hide();
					_G[self:GetName().."UnCheck"]:Show();
					checked = false;
				else
					_G[self:GetName().."Check"]:Show();
					_G[self:GetName().."UnCheck"]:Hide();
					checked = true;
				end
			end
		else
			self:GetParent():Hide();
		end

		if ( type (self.checked) ~= "function" ) then
			self.checked = checked;
		end

		-- saving this here because func might use a dropdown, changing this self's attributes
		local playSound = true;
		if ( self.noClickSound ) then
			playSound = false;
		end

		local func = self.func;
		if ( func ) then
			func(self, self.arg1, self.arg2, checked, button);
		else
			return;
		end

		if ( playSound ) then
			PlaySound(SOUNDKIT.U_CHAT_SCROLL_BUTTON);
		end
	end
	-- UIDropDownMenuButton Scripts END
	
	-- UIDropDownMenuButtonIcon Script BEGIN
	local function icon_OnClick(self, button)
		local buttonParent = self:GetParent()
		if not buttonParent then
			return
		end
		button_OnClick(buttonParent, button)
	end
	
	local function icon_OnEnter(self)
		local button = self:GetParent();
		if not button then
			return;
		end

		local shouldShowIconTooltip = lib:UIDropDownMenuButton_ShouldShowIconTooltip(button);

		if shouldShowIconTooltip then
			tooltip:SetOwner(button, "ANCHOR_RIGHT");
			if button.iconTooltipTitle then
				GameTooltip_SetTitle(tooltip, button.iconTooltipTitle);
			end
			if button.iconTooltipText then
				GameTooltip_AddNormalLine(tooltip, button.iconTooltipText, true);
			end
			if button.iconTooltipBackdropStyle then
				SharedTooltip_SetBackdropStyle(tooltip, button.iconTooltipBackdropStyle);
			end
			tooltip:Show();
		end
		button_OnEnter(button);
	end
	
	local function icon_OnLeave(self)
		local button = self:GetParent();
		if not button then
			return;
		end
		
		button_OnLeave(button);
	end
	
	local function icon_OnMouseUp(self, button)
		if ( button == "LeftButton" ) then
			icon_OnClick(self, button)
		end
	end
	-- UIDropDownMenuButtonIcon Script END
	
	-- Button Frame
	local f = CreateFrame("Button", name, parent or nil)
    f:SetWidth(100)
    f:SetHeight(16)
    f:SetFrameLevel(f:GetParent():GetFrameLevel()+2)

	f.Highlight = f:CreateTexture( name and (name.."Highlight") or nil, "BACKGROUND")
	f.Highlight:SetTexture("Interface\\QuestFrame\\UI-QuestTitleHighlight")
	f.Highlight:SetBlendMode("ADD")
	f.Highlight:SetAllPoints()
	f.Highlight:Hide()
	
	f.Check = f:CreateTexture( name and (name.."Check") or nil, "ARTWORK")
	f.Check:SetTexture("Interface\\Common\\UI-DropDownRadioChecks")
	f.Check:SetSize(16, 16)
	f.Check:SetPoint("LEFT", f, 0, 0)
	f.Check:SetTexCoord(0, 0.5, 0.5, 1)

	f.UnCheck = f:CreateTexture( name and (name.."UnCheck") or nil, "ARTWORK")
	f.UnCheck:SetTexture("Interface\\Common\\UI-DropDownRadioChecks")
	f.UnCheck:SetSize(16, 16)
	f.UnCheck:SetPoint("LEFT", f, 0, 0)
	f.UnCheck:SetTexCoord(0.5, 1, 0.5, 1)
	
	-- Icon Texture
	local fIcon
	fIcon = f:CreateTexture( name and (name.."Icon") or nil, "ARTWORK")
	fIcon:SetSize(16, 16)
	fIcon:SetPoint("RIGHT", f, 0, 0)
	fIcon:Hide()
	if (WoWRetail) then
		fIcon:SetScript("OnEnter", function(self)
			icon_OnEnter(self)
		end)
		fIcon:SetScript("OnLeave", function(self)
			icon_OnLeave(self)
		end)
		fIcon:SetScript("OnMouseUp", function(self, button)
			icon_OnMouseUp(self, button)
		end)
	end
	f.Icon = fIcon
	
	-- ColorSwatch
	local fcw
	fcw = CreateFrame("Button", name and (name.."ColorSwatch") or nil, f, BackdropTemplateMixin and DropDownMenuButtonMixin and "BackdropTemplate,ColorSwatchTemplate" or BackdropTemplateMixin and "BackdropTemplate" or nil)
	fcw:SetPoint("RIGHT", f, -6, 0)
	fcw:Hide()
	if not DropDownMenuButtonMixin then
		fcw:SetSize(16, 16)
		fcw.SwatchBg = fcw:CreateTexture( name and (name.."ColorSwatchSwatchBg") or nil, "BACKGROUND")
		fcw.SwatchBg:SetVertexColor(1, 1, 1)
		fcw.SwatchBg:SetWidth(14)
		fcw.SwatchBg:SetHeight(14)
		fcw.SwatchBg:SetPoint("CENTER", fcw, 0, 0)
		local button1NormalTexture = fcw:CreateTexture( name and (name.."ColorSwatchNormalTexture") or nil)
		button1NormalTexture:SetTexture("Interface\\ChatFrame\\ChatFrameColorSwatch")
		button1NormalTexture:SetAllPoints()
		fcw:SetNormalTexture(button1NormalTexture)
	end
	fcw:SetScript("OnClick", function(self, button, down)
		CloseMenus()
		lib:UIDropDownMenuButton_OpenColorPicker(self:GetParent())
	end)
	fcw:SetScript("OnEnter", function(self, motion)
		lib:CloseDropDownMenus(self:GetParent():GetParent():GetID() + 1)
		_G[self:GetName().."SwatchBg"]:SetVertexColor(NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b)
		lib:UIDropDownMenu_StopCounting(self:GetParent():GetParent())
	end)
	fcw:SetScript("OnLeave", function(self, motion)
		_G[self:GetName().."SwatchBg"]:SetVertexColor(HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b);
		lib:UIDropDownMenu_StartCounting(self:GetParent():GetParent())
	end)
	f.ColorSwatch = fcw
	
	-- ExpandArrow
	local fea = CreateFrame("Button", name and (name.."ExpandArrow") or nil, f)
	fea:SetSize(16, 16)
	fea:SetPoint("RIGHT", f, 0, 0)
	fea:Hide()
	local button2NormalTexture = fea:CreateTexture( name and (name.."ExpandArrowNormalTexture") or nil)
	button2NormalTexture:SetTexture("Interface\\ChatFrame\\ChatFrameExpandArrow")
	button2NormalTexture:SetAllPoints()
	fea:SetNormalTexture(button2NormalTexture)
	fea:SetScript("OnMouseDown", function(self, button)
		if self:IsEnabled() then
			lib:ToggleDropDownMenu(self:GetParent():GetParent():GetID() + 1, self:GetParent().value, nil, nil, nil, nil, self:GetParent().menuList, self);
			PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
		end
	end)
	fea:SetScript("OnEnter", function(self, motion)
		local level =  self:GetParent():GetParent():GetID() + 1
		lib:CloseDropDownMenus(level)
		if self:IsEnabled() then
			local listFrame = _G["L_DropDownList"..level];
			if ( not listFrame or not listFrame:IsShown() or select(2, listFrame:GetPoint()) ~= self ) then
				lib:ToggleDropDownMenu(level, self:GetParent().value, nil, nil, nil, nil, self:GetParent().menuList, self)
			end
		end
		lib:UIDropDownMenu_StopCounting(self:GetParent():GetParent())
	end)
	fea:SetScript("OnLeave", function(self, motion)
		lib:UIDropDownMenu_StartCounting(self:GetParent():GetParent())
	end)
	f.ExpandArrow = fea

	-- InvisibleButton
	local fib = CreateFrame("Button", name and (name.."InvisibleButton") or nil, f)
	fib:Hide()
	fib:SetPoint("TOPLEFT", f, 0, 0)
	fib:SetPoint("BOTTOMLEFT", f, 0, 0)
	fib:SetPoint("RIGHT", fcw, "LEFT", 0, 0)
	fib:SetScript("OnEnter", function(self, motion)
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			lib:UIDropDownMenu_StopCounting(self:GetParent():GetParent());
		end
		lib:CloseDropDownMenus(self:GetParent():GetParent():GetID() + 1);
		local parent = self:GetParent();
		if ( parent.tooltipTitle and parent.tooltipWhileDisabled) then
			if ( parent.tooltipOnButton ) then
				tooltip:SetOwner(parent, "ANCHOR_RIGHT");
				GameTooltip_SetTitle(tooltip, parent.tooltipTitle);
				if parent.tooltipInstruction then
					GameTooltip_AddInstructionLine(tooltip, parent.tooltipInstruction);
				end
				if parent.tooltipText then
					GameTooltip_AddNormalLine(tooltip, parent.tooltipText, true);
				end
				if parent.tooltipWarning then
					GameTooltip_AddColoredLine(tooltip, parent.tooltipWarning, RED_FONT_COLOR, true);
				end
				if parent.tooltipBackdropStyle then
					SharedTooltip_SetBackdropStyle(tooltip, parent.tooltipBackdropStyle);
				end
				tooltip:Show();
			end
		end
	end)
	fib:SetScript("OnLeave", function(self, motion)
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			lib:UIDropDownMenu_StartCounting(self:GetParent():GetParent());
		end
		tooltip:Hide();
	end)
	f.invisibleButton = fib
	
	-- NewFeature
	if (WoWRetail) then
		local fnf = CreateFrame("Frame", name and (name.."NewFeature") or nil, f, "NewFeatureLabelTemplate");
		fnf:SetFrameStrata("HIGH");
		fnf:SetScale(0.8);
		fnf:SetFrameLevel(100);
		fnf:SetSize(1, 1);
		fnf:Hide();
		
		f.NewFeature = fnf;
	end

	-- MenuButton scripts
	f:SetScript("OnClick", function(self, button)
		button_OnClick(self, button)
	end)
	f:SetScript("OnEnter", function(self, motion)
		button_OnEnter(self)
	end)
	f:SetScript("OnLeave", function(self, motion)
		button_OnLeave(self)
	end)
	f:SetScript("OnEnable", function(self)
		self.invisibleButton:Hide()
	end)
	f:SetScript("OnDisable", function(self)
		self.invisibleButton:Show()
	end)

	local text1 = f:CreateFontString( name and (name.."NormalText") or nil)
	f:SetFontString(text1)
	text1:SetPoint("LEFT", f, -5, 0)
	f:SetNormalFontObject("GameFontHighlightSmallLeft")
	f:SetHighlightFontObject("GameFontHighlightSmallLeft")
	f:SetDisabledFontObject("GameFontDisableSmallLeft")

	return f
end

-- //////////////////////////////////////////////////////////////
-- L_UIDropDownListTemplate
local function creatre_DropDownList(name, parent)
	-- This has been removed from Backdrop.lua, so we added the definition here.
	local BACKDROP_DIALOG_DARK = {
		bgFile = "Interface\\DialogFrame\\UI-DialogBox-Background-Dark",
		edgeFile = "Interface\\DialogFrame\\UI-DialogBox-Border",
		tile = true,
		tileEdge = true,
		tileSize = 32,
		edgeSize = 32,
		insets = { left = 11, right = 12, top = 12, bottom = 11, },
	}
	local BACKDROP_TOOLTIP_16_16_5555 = {
		bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
		edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
		tile = true,
		tileEdge = true,
		tileSize = 16,
		edgeSize = 16,
		insets = { left = 5, right = 5, top = 5, bottom = 5 },
	}
	
	local f = name and _G[name] or CreateFrame("Button", name)
	f:SetParent(parent or nil)
	f:Hide()
	f:SetFrameStrata("DIALOG")
	f:EnableMouse(true)
	
	local fbd = name and _G[name.."Backdrop"] or CreateFrame("Frame", name and (name.."Backdrop") or nil, f, BackdropTemplateMixin and "DialogBorderDarkTemplate" or nil)
	fbd:SetAllPoints()
	fbd.backdropInfo = BACKDROP_DIALOG_DARK
	f.Backdrop = fbd
	
	local fmb = name and _G[name.."MenuBackdrop"] or CreateFrame("Frame", name and (name.."MenuBackdrop") or nil, f, TooltipBackdropTemplateMixin and "TooltipBackdropTemplate" or nil)
	fmb:SetAllPoints()
	fmb.backdropInfo = BACKDROP_TOOLTIP_16_16_5555
	fmb:SetBackdropBorderColor(TOOLTIP_DEFAULT_COLOR.r, TOOLTIP_DEFAULT_COLOR.g, TOOLTIP_DEFAULT_COLOR.b)
	fmb:SetBackdropColor(TOOLTIP_DEFAULT_BACKGROUND_COLOR.r, TOOLTIP_DEFAULT_BACKGROUND_COLOR.g, TOOLTIP_DEFAULT_BACKGROUND_COLOR.b)
	f.MenuBackdrop = fmb
	
	f.Button1 = name and _G[name.."Button1"] or create_MenuButton(name and (name.."Button1") or nil, f) -- to replace the inherits of "UIDropDownMenuButtonTemplate"
	f.Button1:SetID(1)

	-- Checking if NewFeature exists or not
	if (WoWRetail) then
		if not f.Button1.NewFeature then
			local fnf = CreateFrame("Frame", name and (name.."NewFeature") or nil, f, "NewFeatureLabelTemplate");
			fnf:SetFrameStrata("HIGH");
			fnf:SetScale(0.8);
			fnf:SetFrameLevel(100);
			fnf:SetSize(1, 1);
			fnf:Hide();
			
			f.Button1.NewFeature = fnf;
		end
	end
	
	
	f:SetScript("OnClick", function(self)
		self:Hide()
	end)
	f:SetScript("OnEnter", function(self, motion)
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			lib:UIDropDownMenu_StopCounting(self, motion)
		end
	end)
	f:SetScript("OnLeave", function(self, motion)
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			lib:UIDropDownMenu_StartCounting(self, motion)
		end
	end)
	-- If dropdown is visible then see if its timer has expired, if so hide the frame
	f:SetScript("OnUpdate", function(self, elapsed)
		if ( self.shouldRefresh ) then
			lib:UIDropDownMenu_RefreshDropDownSize(self);
			self.shouldRefresh = false;
		end
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			if ( not self.showTimer or not self.isCounting ) then
				return;
			elseif ( self.showTimer < 0 ) then
				self:Hide();
				self.showTimer = nil;
				self.isCounting = nil;
			else
				self.showTimer = self.showTimer - elapsed;
			end
		end
	end)
	f:SetScript("OnShow", function(self)
		if ( self.onShow ) then
			self.onShow();
			self.onShow = nil;
		end

		for i=1, L_UIDROPDOWNMENU_MAXBUTTONS do
			if (not self.noResize) then
				_G[self:GetName().."Button"..i]:SetWidth(self.maxWidth);
			end
		end

		if (not self.noResize) then
			self:SetWidth(self.maxWidth+25);
		end
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			self.showTimer = nil;
		end
		if ( self:GetID() > 1 ) then
			self.parent = _G["L_DropDownList"..(self:GetID() - 1)];
		end
		EventRegistry:TriggerEvent("UIDropDownMenu.Show", self);
	end)
	f:SetScript("OnHide", function(self)
		local id = self:GetID()
		if ( self.onHide ) then
			self.onHide(id+1);
			self.onHide = nil;
		end
		if ( self.baseFrameStrata ) then
			self:SetFrameStrata(self.baseFrameStrata);
			self.baseFrameStrata = nil;
		end
		lib:CloseDropDownMenus(id+1);
		L_OPEN_DROPDOWNMENUS[id] = nil;
		if (id == 1) then
			L_UIDROPDOWNMENU_OPEN_MENU = nil;
		end

		lib:UIDropDownMenu_ClearCustomFrames(self);
		EventRegistry:TriggerEvent("UIDropDownMenu.Hide");
	end)
	
	return f
end

-- //////////////////////////////////////////////////////////////
-- L_UIDropDownMenuTemplate
local function create_DropDownMenu(name, parent)
	local f
	if type(name) == "table" then
		f = name
		name = f:GetName()
	else
		f = CreateFrame("Frame", name, parent or nil)
	end
	
	--if not name then name = "" end
	
	f:SetSize(40, 32)
	
	f.Left = f:CreateTexture( name and (name.."Left") or nil, "ARTWORK")
	f.Left:SetTexture("Interface\\Glues\\CharacterCreate\\CharacterCreate-LabelFrame")
	f.Left:SetSize(25, 64)
	f.Left:SetPoint("TOPLEFT", f, 0, 17)
	f.Left:SetTexCoord(0, 0.1953125, 0, 1)
	
	f.Middle = f:CreateTexture( name and (name.."Middle") or nil, "ARTWORK")
	f.Middle:SetTexture("Interface\\Glues\\CharacterCreate\\CharacterCreate-LabelFrame")
	f.Middle:SetSize(115, 64)
	f.Middle:SetPoint("LEFT", f.Left, "RIGHT")
	f.Middle:SetTexCoord(0.1953125, 0.8046875, 0, 1)
	
	f.Right = f:CreateTexture( name and (name.."Right") or nil, "ARTWORK")
	f.Right:SetTexture("Interface\\Glues\\CharacterCreate\\CharacterCreate-LabelFrame")
	f.Right:SetSize(25, 64)
	f.Right:SetPoint("LEFT", f.Middle, "RIGHT")
	f.Right:SetTexCoord(0.8046875, 1, 0, 1)
	
	f.Text = f:CreateFontString( name and (name.."Text") or nil, "ARTWORK", "GameFontHighlightSmall")
	f.Text:SetWordWrap(false)
	f.Text:SetJustifyH("RIGHT")
	f.Text:SetSize(0, 10)
	f.Text:SetPoint("RIGHT", f.Right, -43, 2)
	
	f.Icon = f:CreateTexture( name and (name.."Icon") or nil, "OVERLAY")
	f.Icon:Hide()
	f.Icon:SetSize(16, 16)
	f.Icon:SetPoint("LEFT", 30, 2)
	
	-- // UIDropDownMenuButtonScriptTemplate
	f.Button = CreateFrame("Button", name and (name.."Button") or nil, f)
	f.Button:SetMotionScriptsWhileDisabled(true)
	f.Button:SetSize(24, 24)
	f.Button:SetPoint("TOPRIGHT", f.Right, -16, -18)
	
	f.Button.NormalTexture = f.Button:CreateTexture( name and (name.."NormalTexture") or nil)
	f.Button.NormalTexture:SetTexture("Interface\\ChatFrame\\UI-ChatIcon-ScrollDown-Up")
	f.Button.NormalTexture:SetSize(24, 24)
	f.Button.NormalTexture:SetPoint("RIGHT", f.Button, 0, 0)
	f.Button:SetNormalTexture(f.Button.NormalTexture)
	
	f.Button.PushedTexture = f.Button:CreateTexture( name and (name.."PushedTexture") or nil)
	f.Button.PushedTexture:SetTexture("Interface\\ChatFrame\\UI-ChatIcon-ScrollDown-Down")
	f.Button.PushedTexture:SetSize(24, 24)
	f.Button.PushedTexture:SetPoint("RIGHT", f.Button, 0, 0)
	f.Button:SetPushedTexture(f.Button.PushedTexture)
	
	f.Button.DisabledTexture = f.Button:CreateTexture( name and (name.."DisabledTexture") or nil)
	f.Button.DisabledTexture:SetTexture("Interface\\ChatFrame\\UI-ChatIcon-ScrollDown-Disabled")
	f.Button.DisabledTexture:SetSize(24, 24)
	f.Button.DisabledTexture:SetPoint("RIGHT", f.Button, 0, 0)
	f.Button:SetDisabledTexture(f.Button.DisabledTexture)
	
	f.Button.HighlightTexture = f.Button:CreateTexture( name and (name.."HighlightTexture") or nil)
	f.Button.HighlightTexture:SetTexture("Interface\\Buttons\\UI-Common-MouseHilight")
	f.Button.HighlightTexture:SetSize(24, 24)
	f.Button.HighlightTexture:SetPoint("RIGHT", f.Button, 0, 0)
	f.Button.HighlightTexture:SetBlendMode("ADD")
	f.Button:SetHighlightTexture(f.Button.HighlightTexture)
	
	-- Button Script
	f.Button:SetScript("OnEnter", function(self, motion)
		local parent = self:GetParent()
		local myscript = parent:GetScript("OnEnter")
		if(myscript ~= nil) then
			myscript(parent)
		end
	end)
	f.Button:SetScript("OnLeave", function(self, motion)
		local parent = self:GetParent()
		local myscript = parent:GetScript("OnLeave")
		if(myscript ~= nil) then
			myscript(parent)
		end
	end)
	f.Button:SetScript("OnMouseDown", function(self, button)
		if self:IsEnabled() then
			local parent = self:GetParent()
			lib:ToggleDropDownMenu(nil, nil, parent)
			PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON)
		end
	end)
	
	-- UIDropDownMenu Script
	f:SetScript("OnHide", function(self)
		lib:CloseDropDownMenus()
	end)
	
	return f
end
-- End of frame templates
-- //////////////////////////////////////////////////////////////

-- //////////////////////////////////////////////////////////////
-- Handling two frames from LibUIDropDownMenu.xml
local function create_DropDownButtons()
	L_DropDownList1 = creatre_DropDownList("L_DropDownList1")
	L_DropDownList1:SetToplevel(true)
	L_DropDownList1:SetFrameStrata("FULLSCREEN_DIALOG")
	L_DropDownList1:Hide()
	L_DropDownList1:SetID(1)
	L_DropDownList1:SetSize(180, 10)
	local _, fontHeight, _ = _G["L_DropDownList1Button1NormalText"]:GetFont()
	L_UIDROPDOWNMENU_DEFAULT_TEXT_HEIGHT = fontHeight
	
	L_DropDownList2 = creatre_DropDownList("L_DropDownList2")
	L_DropDownList2:SetToplevel(true)
	L_DropDownList2:SetFrameStrata("FULLSCREEN_DIALOG")
	L_DropDownList2:Hide()
	L_DropDownList2:SetID(2)
	L_DropDownList2:SetSize(180, 10)

	L_DropDownList3 = creatre_DropDownList("L_DropDownList3")
	L_DropDownList3:SetToplevel(true)
	L_DropDownList3:SetFrameStrata("FULLSCREEN_DIALOG")
	L_DropDownList3:Hide()
	L_DropDownList3:SetID(3)
	L_DropDownList3:SetSize(180, 10)

	-- UIParent integration; since we customize the name of DropDownList, we need to add it to golbal UIMenus table.
	--tinsert(UIMenus, "L_DropDownList1");
	--tinsert(UIMenus, "L_DropDownList2");
	--tinsert(UIMenus, "L_DropDownList3");
	
	-- Alternative by Dahk Celes (DDC) that avoids tainting UIMenus and CloseMenus()
	hooksecurefunc("CloseMenus", function()
		L_DropDownList1:Hide()
		L_DropDownList2:Hide()
		L_DropDownList3:Hide()
	end)
end

do
	if lib then 
		create_DropDownButtons()
	end
end

-- //////////////////////////////////////////////////////////////
-- Global function to replace L_UIDropDownMenuTemplate
function lib:Create_UIDropDownMenu(name, parent)
    return create_DropDownMenu(name, parent)
end

local function GetChild(frame, name, key)
	if (frame[key]) then
		return frame[key];
	elseif name then
		return _G[name..key];
	end

	return nil;
end

function lib:UIDropDownMenu_Initialize(frame, initFunction, displayMode, level, menuList)
	frame.menuList = menuList;

	--securecall("initializeHelper", frame);
	lib:UIDropDownMenu_InitializeHelper(frame)

	-- Set the initialize function and call it.  The initFunction populates the dropdown list.
	if ( initFunction ) then
		lib:UIDropDownMenu_SetInitializeFunction(frame, initFunction);
		initFunction(frame, level, frame.menuList);
	end

	--master frame
	if(level == nil) then
		level = 1;
	end

	local dropDownList = _G["L_DropDownList"..level];
	dropDownList.dropdown = frame;
	dropDownList.shouldRefresh = true;
	if (WoWRetail) then
		dropDownList:SetWindow(frame:GetWindow());
	end

	lib:UIDropDownMenu_SetDisplayMode(frame, displayMode);
end

function lib:UIDropDownMenu_SetInitializeFunction(frame, initFunction)
	frame.initialize = initFunction;
end

function lib:UIDropDownMenu_SetDisplayMode(frame, displayMode)
	-- Change appearance based on the displayMode
	-- Note: this is a one time change based on previous behavior.
	if ( displayMode == "MENU" ) then
		local name = frame:GetName();
		GetChild(frame, name, "Left"):Hide();
		GetChild(frame, name, "Middle"):Hide();
		GetChild(frame, name, "Right"):Hide();
		local button = GetChild(frame, name, "Button");
		local buttonName = button:GetName();
		GetChild(button, buttonName, "NormalTexture"):SetTexture(nil);
		GetChild(button, buttonName, "DisabledTexture"):SetTexture(nil);
		GetChild(button, buttonName, "PushedTexture"):SetTexture(nil);
		GetChild(button, buttonName, "HighlightTexture"):SetTexture(nil);
		local text = GetChild(frame, name, "Text");

		button:ClearAllPoints();
		button:SetPoint("LEFT", text, "LEFT", -9, 0);
		button:SetPoint("RIGHT", text, "RIGHT", 6, 0);
		frame.displayMode = "MENU";
	end
end

function lib:UIDropDownMenu_SetFrameStrata(frame, frameStrata)
	frame.listFrameStrata = frameStrata;
end

function lib:UIDropDownMenu_RefreshDropDownSize(self)
	self.maxWidth = lib:UIDropDownMenu_GetMaxButtonWidth(self);
	self:SetWidth(self.maxWidth + 25);

	for i=1, L_UIDROPDOWNMENU_MAXBUTTONS, 1 do
		local icon = _G[self:GetName().."Button"..i.."Icon"];

		if ( icon.tFitDropDownSizeX ) then
			icon:SetWidth(self.maxWidth - 5);
		end
	end
end

-- Start the countdown on a frame
function lib:UIDropDownMenu_StartCounting(frame)
	if ( frame.parent ) then
		lib:UIDropDownMenu_StartCounting(frame.parent);
	else
		frame.showTimer = L_UIDROPDOWNMENU_SHOW_TIME;
		frame.isCounting = 1;
	end
end

-- Stop the countdown on a frame
function lib:UIDropDownMenu_StopCounting(frame)
	if ( frame.parent ) then
		lib:UIDropDownMenu_StopCounting(frame.parent);
	else
		frame.isCounting = nil;
	end
end


--[[
List of button attributes
======================================================
info.text = [STRING]  --  The text of the button
info.value = [ANYTHING]  --  The value that L_UIDROPDOWNMENU_MENU_VALUE is set to when the button is clicked
info.func = [function()]  --  The function that is called when you click the button
info.checked = [nil, true, function]  --  Check the button if true or function returns true
info.isNotRadio = [nil, true]  --  Check the button uses radial image if false check box image if true
info.isTitle = [nil, true]  --  If it's a title the button is disabled and the font color is set to yellow
info.disabled = [nil, true]  --  Disable the button and show an invisible button that still traps the mouseover event so menu doesn't time out
info.tooltipWhileDisabled = [nil, 1] -- Show the tooltip, even when the button is disabled.
info.hasArrow = [nil, true]  --  Show the expand arrow for multilevel menus
info.arrowXOffset = [nil, NUMBER] -- Number of pixels to shift the button's icon to the left or right (positive numbers shift right, negative numbers shift left).
info.hasColorSwatch = [nil, true]  --  Show color swatch or not, for color selection
info.r = [1 - 255]  --  Red color value of the color swatch
info.g = [1 - 255]  --  Green color value of the color swatch
info.b = [1 - 255]  --  Blue color value of the color swatch
info.colorCode = [STRING] -- "|cAARRGGBB" embedded hex value of the button text color. Only used when button is enabled
info.swatchFunc = [function()]  --  Function called by the color picker on color change
info.hasOpacity = [nil, 1]  --  Show the opacity slider on the colorpicker frame
info.opacity = [0.0 - 1.0]  --  Percentatge of the opacity, 1.0 is fully shown, 0 is transparent
info.opacityFunc = [function()]  --  Function called by the opacity slider when you change its value
info.cancelFunc = [function(previousValues)] -- Function called by the colorpicker when you click the cancel button (it takes the previous values as its argument)
info.notClickable = [nil, 1]  --  Disable the button and color the font white
info.notCheckable = [nil, 1]  --  Shrink the size of the buttons and don't display a check box
info.owner = [Frame]  --  Dropdown frame that "owns" the current dropdownlist
info.keepShownOnClick = [nil, 1]  --  Don't hide the dropdownlist after a button is clicked
info.tooltipTitle = [nil, STRING] -- Title of the tooltip shown on mouseover
info.tooltipText = [nil, STRING] -- Text of the tooltip shown on mouseover
info.tooltipWarning = [nil, STRING] -- Warning-style text of the tooltip shown on mouseover
info.tooltipInstruction = [nil, STRING] -- Instruction-style text of the tooltip shown on mouseover
info.tooltipOnButton = [nil, 1] -- Show the tooltip attached to the button instead of as a Newbie tooltip.
info.tooltipBackdropStyle = [nil, TABLE] -- Optional Backdrop style of the tooltip shown on mouseover
info.justifyH = [nil, "CENTER"] -- Justify button text
info.arg1 = [ANYTHING] -- This is the first argument used by info.func
info.arg2 = [ANYTHING] -- This is the second argument used by info.func
info.fontObject = [FONT] -- font object replacement for Normal and Highlight
info.menuList = [TABLE] -- This contains an array of info tables to be displayed as a child menu
info.menuListDisplayMode = [nil, "MENU"] -- If menuList is set, show the sub drop down with an override display mode.
info.noClickSound = [nil, 1]  --  Set to 1 to suppress the sound when clicking the button. The sound only plays if .func is set.
info.padding = [nil, NUMBER] -- Number of pixels to pad the text on the right side
info.topPadding = [nil, NUMBER] -- Extra spacing between buttons.
info.leftPadding = [nil, NUMBER] -- Number of pixels to pad the button on the left side
info.minWidth = [nil, NUMBER] -- Minimum width for this line
info.customFrame = frame -- Allows this button to be a completely custom frame, should inherit from UIDropDownCustomMenuEntryTemplate and override appropriate methods.
info.icon = [TEXTURE] -- An icon for the button.
info.iconXOffset = [nil, NUMBER] -- Number of pixels to shift the button's icon to the left or right (positive numbers shift right, negative numbers shift left).
info.iconTooltipTitle = [nil, STRING] -- Title of the tooltip shown on icon mouseover
info.iconTooltipText = [nil, STRING] -- Text of the tooltip shown on icon mouseover
info.iconTooltipBackdropStyle = [nil, TABLE] -- Optional Backdrop style of the tooltip shown on icon mouseover
info.mouseOverIcon = [TEXTURE] -- An override icon when a button is moused over.
info.ignoreAsMenuSelection [nil, true] -- Never set the menu text/icon to this, even when this button is checked
info.registerForRightClick [nil, true] -- Register dropdown buttons for right clicks
info.registerForAnyClick [nil, true] -- Register dropdown buttons for any clicks
info.showNewLabel
]]

-- Create (return) empty table
function lib:UIDropDownMenu_CreateInfo()
	return {};
end

function lib:UIDropDownMenu_CreateFrames(level, index)
	while ( level > L_UIDROPDOWNMENU_MAXLEVELS ) do
		L_UIDROPDOWNMENU_MAXLEVELS = L_UIDROPDOWNMENU_MAXLEVELS + 1;
		--local newList = CreateFrame("Button", "L_DropDownList"..L_UIDROPDOWNMENU_MAXLEVELS, nil, "L_UIDropDownListTemplate");
		local newList = creatre_DropDownList("L_DropDownList"..L_UIDROPDOWNMENU_MAXLEVELS)
		newList:SetFrameStrata("FULLSCREEN_DIALOG");
		newList:SetToplevel(true);
		newList:Hide();
		newList:SetID(L_UIDROPDOWNMENU_MAXLEVELS);
		newList:SetWidth(180)
		newList:SetHeight(10)
--		for i = WoWRetail and 1 or (L_UIDROPDOWNMENU_MINBUTTONS+1), L_UIDROPDOWNMENU_MAXBUTTONS do
		for i=1, L_UIDROPDOWNMENU_MAXBUTTONS do
			--local newButton = CreateFrame("Button", "L_DropDownList"..L_UIDROPDOWNMENU_MAXLEVELS.."Button"..i, newList, "L_UIDropDownMenuButtonTemplate");
			local newButton = create_MenuButton("L_DropDownList"..L_UIDROPDOWNMENU_MAXLEVELS.."Button"..i, newList)
			newButton:SetID(i);
		end
	end

	while ( index > L_UIDROPDOWNMENU_MAXBUTTONS ) do
		L_UIDROPDOWNMENU_MAXBUTTONS = L_UIDROPDOWNMENU_MAXBUTTONS + 1;
		for i=1, L_UIDROPDOWNMENU_MAXLEVELS do
			--local newButton = CreateFrame("Button", "L_DropDownList"..i.."Button"..L_UIDROPDOWNMENU_MAXBUTTONS, _G["L_DropDownList"..i], "L_UIDropDownMenuButtonTemplate");
			local newButton = create_MenuButton("L_DropDownList"..i.."Button"..L_UIDROPDOWNMENU_MAXBUTTONS, _G["L_DropDownList"..i])
			newButton:SetID(L_UIDROPDOWNMENU_MAXBUTTONS);
		end
	end
end

function lib:UIDropDownMenu_AddSeparator(level)
	local separatorInfo = {
		hasArrow = false;
		dist = 0;
		isTitle = true;
		isUninteractable = true;
		notCheckable = true;
		iconOnly = true;
		icon = "Interface\\Common\\UI-TooltipDivider-Transparent";
		tCoordLeft = 0;
		tCoordRight = 1;
		tCoordTop = 0;
		tCoordBottom = 1;
		tSizeX = 0;
		tSizeY = 8;
		tFitDropDownSizeX = true;
		iconInfo = {
			tCoordLeft = 0,
			tCoordRight = 1,
			tCoordTop = 0,
			tCoordBottom = 1,
			tSizeX = 0,
			tSizeY = 8,
			tFitDropDownSizeX = true
		},
	};

	lib:UIDropDownMenu_AddButton(separatorInfo, level);
end

function lib:UIDropDownMenu_AddSpace(level)
	local spaceInfo = {
		hasArrow = false,
		dist = 0,
		isTitle = true,
		isUninteractable = true,
		notCheckable = true,
	};

	lib:UIDropDownMenu_AddButton(spaceInfo, level);
end

function lib:UIDropDownMenu_AddButton(info, level)
	--[[
	Might to uncomment this if there are performance issues
	if ( not L_UIDROPDOWNMENU_OPEN_MENU ) then
		return;
	end
	]]
	if ( not level ) then
		level = 1;
	end

	local listFrame = _G["L_DropDownList"..level];
	local index;
	if (listFrame) then
		index = listFrame.numButtons and (listFrame.numButtons + 1) or 1
	else
		index = 0
	end
	--local index = listFrame and (listFrame.numButtons + 1) or 1;
	local width;

	delegateFrame:SetAttribute("createframes-level", level);
	delegateFrame:SetAttribute("createframes-index", index);
	delegateFrame:SetAttribute("createframes", true);

	listFrame = listFrame or _G["L_DropDownList"..level];
	local listFrameName = listFrame:GetName();

	-- Set the number of buttons in the listframe
	listFrame.numButtons = index;

	local button = _G[listFrameName.."Button"..index];
	local normalText = _G[button:GetName().."NormalText"];
	local icon = _G[button:GetName().."Icon"];
	-- This button is used to capture the mouse OnEnter/OnLeave events if the dropdown button is disabled, since a disabled button doesn't receive any events
	-- This is used specifically for drop down menu time outs
	local invisibleButton = _G[button:GetName().."InvisibleButton"];

	-- Default settings
	button:SetDisabledFontObject(GameFontDisableSmallLeft);
	invisibleButton:Hide();
	button:Enable();

	if ( info.registerForAnyClick ) then
		button:RegisterForClicks("AnyUp");
	elseif ( info.registerForRightClick ) then
		button:RegisterForClicks("LeftButtonUp", "RightButtonUp");
	else
		button:RegisterForClicks("LeftButtonUp");
	end

	-- If not clickable then disable the button and set it white
	if ( info.notClickable ) then
		info.disabled = true;
		button:SetDisabledFontObject(GameFontHighlightSmallLeft);
	end

	-- Set the text color and disable it if its a title
	if ( info.isTitle ) then
		info.disabled = true;
		button:SetDisabledFontObject(GameFontNormalSmallLeft);
	end

	-- Disable the button if disabled and turn off the color code
	if ( info.disabled ) then
		button:Disable();
		invisibleButton:Show();
		info.colorCode = nil;
	end

	-- If there is a color for a disabled line, set it
	if( info.disablecolor ) then
		info.colorCode = info.disablecolor;
	end

	-- Configure button
	if ( info.text ) then
		-- look for inline color code this is only if the button is enabled
		if ( info.colorCode ) then
			button:SetText(info.colorCode..info.text.."|r");
		else
			button:SetText(info.text);
		end

		-- Set icon
		if ( info.icon or info.mouseOverIcon ) then
			icon:SetSize(16,16);
			if (WoWRetail) then
				if(info.icon and C_Texture.GetAtlasInfo(info.icon)) then
					icon:SetAtlas(info.icon);
				else
					icon:SetTexture(info.icon);
				end
				icon:ClearAllPoints();
				icon:SetPoint("RIGHT", info.iconXOffset or 0, 0);
			else
				icon:SetTexture(info.icon);
				icon:ClearAllPoints();
				icon:SetPoint("RIGHT");
			end

			if ( info.tCoordLeft ) then
				icon:SetTexCoord(info.tCoordLeft, info.tCoordRight, info.tCoordTop, info.tCoordBottom);
			else
				icon:SetTexCoord(0, 1, 0, 1);
			end
			icon:Show();
		else
			icon:Hide();
		end

		-- Check to see if there is a replacement font
		if ( info.fontObject ) then
			button:SetNormalFontObject(info.fontObject);
			button:SetHighlightFontObject(info.fontObject);
		else
			button:SetNormalFontObject(GameFontHighlightSmallLeft);
			button:SetHighlightFontObject(GameFontHighlightSmallLeft);
		end
	else
		button:SetText("");
		icon:Hide();
	end

	button.iconOnly = nil;
	button.icon = nil;
	button.iconInfo = nil;

	if (info.iconInfo) then
		icon.tFitDropDownSizeX = info.iconInfo.tFitDropDownSizeX;
	else
		icon.tFitDropDownSizeX = nil;
	end
	if (info.iconOnly and info.icon) then
		button.iconOnly = true;
		button.icon = info.icon;
		button.iconInfo = info.iconInfo;

		lib:UIDropDownMenu_SetIconImage(icon, info.icon, info.iconInfo);
		icon:ClearAllPoints();
		icon:SetPoint("LEFT");
	end

	-- Pass through attributes
	button.func = info.func;
	button.funcOnEnter = info.funcOnEnter;
	button.funcOnLeave = info.funcOnLeave;
	if (WoWRetail) then
		button.iconXOffset = info.iconXOffset;
		button.ignoreAsMenuSelection = info.ignoreAsMenuSelection;
		button.showNewLabel = info.showNewLabel;
	else
		button.classicChecks = info.classicChecks;
	end
	button.owner = info.owner;
	button.hasOpacity = info.hasOpacity;
	button.opacity = info.opacity;
	button.opacityFunc = info.opacityFunc;
	button.cancelFunc = info.cancelFunc;
	button.swatchFunc = info.swatchFunc;
	button.keepShownOnClick = info.keepShownOnClick;
	button.tooltipTitle = info.tooltipTitle;
	button.tooltipText = info.tooltipText;
	button.tooltipInstruction = info.tooltipInstruction;
	button.tooltipWarning = info.tooltipWarning;
	button.arg1 = info.arg1;
	button.arg2 = info.arg2;
	button.hasArrow = info.hasArrow;
	button.arrowXOffset = info.arrowXOffset;
	button.hasColorSwatch = info.hasColorSwatch;
	button.notCheckable = info.notCheckable;
	button.menuList = info.menuList;
	button.menuListDisplayMode = info.menuListDisplayMode;
	button.tooltipWhileDisabled = info.tooltipWhileDisabled;
	button.noTooltipWhileEnabled = info.noTooltipWhileEnabled;
	button.tooltipOnButton = info.tooltipOnButton;
	button.noClickSound = info.noClickSound;
	button.padding = info.padding;
	button.icon = info.icon;
	button.mouseOverIcon = info.mouseOverIcon;
	if (WoWRetail) then
		button.tooltipBackdropStyle = info.tooltipBackdropStyle;
		button.iconTooltipTitle = info.iconTooltipTitle;
		button.iconTooltipText = info.iconTooltipText;
		button.iconTooltipBackdropStyle = info.iconTooltipBackdropStyle;
		button.iconXOffset = info.iconXOffset;
		button.ignoreAsMenuSelection = info.ignoreAsMenuSelection;
	else
		button.classicChecks = info.classicChecks;
	end

	if ( info.value ~= nil ) then
		button.value = info.value;
	elseif ( info.text ) then
		button.value = info.text;
	else
		button.value = nil;
	end

	local expandArrow = _G[listFrameName.."Button"..index.."ExpandArrow"];
	expandArrow:SetPoint("RIGHT", info.arrowXOffset or 0, 0);
	expandArrow:SetShown(info.hasArrow);
	expandArrow:SetEnabled(not info.disabled);

	-- If not checkable move everything over to the left to fill in the gap where the check would be
	local xPos = 5;
	local buttonHeight = (info.topPadding or 0) + L_UIDROPDOWNMENU_BUTTON_HEIGHT;
	local yPos = -((button:GetID() - 1) * buttonHeight) - L_UIDROPDOWNMENU_BORDER_HEIGHT;
	local displayInfo = normalText;
	if (info.iconOnly) then
		displayInfo = icon;
	end

	displayInfo:ClearAllPoints();
	if ( info.notCheckable ) then
		if ( info.justifyH and info.justifyH == "CENTER" ) then
			displayInfo:SetPoint("CENTER", button, "CENTER", -7, 0);
		else
			displayInfo:SetPoint("LEFT", button, "LEFT", 0, 0);
		end
		xPos = xPos + 10;

	else
		xPos = xPos + 12;
		displayInfo:SetPoint("LEFT", button, "LEFT", 20, 0);
	end

	-- Adjust offset if displayMode is menu
	local frame = L_UIDROPDOWNMENU_OPEN_MENU;
	if ( frame and frame.displayMode == "MENU" ) then
		if ( not info.notCheckable ) then
			xPos = xPos - 6;
		end
	end

	-- If no open frame then set the frame to the currently initialized frame
	frame = frame or L_UIDROPDOWNMENU_INIT_MENU;

	if ( info.leftPadding ) then
		xPos = xPos + info.leftPadding;
	end
	button:SetPoint("TOPLEFT", button:GetParent(), "TOPLEFT", xPos, yPos);

	-- See if button is selected by id or name
	if ( frame ) then
		if ( lib:UIDropDownMenu_GetSelectedName(frame) ) then
			if ( button:GetText() == lib:UIDropDownMenu_GetSelectedName(frame) ) then
				info.checked = 1;
			end
		elseif ( lib:UIDropDownMenu_GetSelectedID(frame) ) then
			if ( button:GetID() == lib:UIDropDownMenu_GetSelectedID(frame) ) then
				info.checked = 1;
			end
		elseif ( lib:UIDropDownMenu_GetSelectedValue(frame) ~= nil ) then
			if ( button.value == lib:UIDropDownMenu_GetSelectedValue(frame) ) then
				info.checked = 1;
			end
		end
	end

	if not info.notCheckable then 
		local check = _G[listFrameName.."Button"..index.."Check"];
		local uncheck = _G[listFrameName.."Button"..index.."UnCheck"];
		if ( info.disabled ) then
			check:SetDesaturated(true);
			check:SetAlpha(0.5);
			uncheck:SetDesaturated(true);
			uncheck:SetAlpha(0.5);
		else
			check:SetDesaturated(false);
			check:SetAlpha(1);
			uncheck:SetDesaturated(false);
			uncheck:SetAlpha(1);
		end
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			check:SetSize(16,16);
			uncheck:SetSize(16,16);
			normalText:SetPoint("LEFT", check, "RIGHT", 0, 0);
		end
		
		if info.customCheckIconAtlas or info.customCheckIconTexture then
			check:SetTexCoord(0, 1, 0, 1);
			uncheck:SetTexCoord(0, 1, 0, 1);
			
			if info.customCheckIconAtlas then
				check:SetAtlas(info.customCheckIconAtlas);
				uncheck:SetAtlas(info.customUncheckIconAtlas or info.customCheckIconAtlas);
			else
				check:SetTexture(info.customCheckIconTexture);
				uncheck:SetTexture(info.customUncheckIconTexture or info.customCheckIconTexture);
			end
		elseif info.classicChecks then
			check:SetTexCoord(0, 1, 0, 1);
			uncheck:SetTexCoord(0, 1, 0, 1);

			check:SetSize(24,24);
			uncheck:SetSize(24,24);

			check:SetTexture("Interface\\Buttons\\UI-CheckBox-Check");
			uncheck:SetTexture("");

			normalText:SetPoint("LEFT", check, "RIGHT", L_UIDROPDOWNMENU_CLASSIC_CHECK_PADDING, 0);
		elseif info.isNotRadio then
			check:SetTexCoord(0.0, 0.5, 0.0, 0.5);
			check:SetTexture("Interface\\Common\\UI-DropDownRadioChecks");
			uncheck:SetTexCoord(0.5, 1.0, 0.0, 0.5);
			uncheck:SetTexture("Interface\\Common\\UI-DropDownRadioChecks");
		else
			check:SetTexCoord(0.0, 0.5, 0.5, 1.0);
			check:SetTexture("Interface\\Common\\UI-DropDownRadioChecks");
			uncheck:SetTexCoord(0.5, 1.0, 0.5, 1.0);
			uncheck:SetTexture("Interface\\Common\\UI-DropDownRadioChecks");
		end

		-- Checked can be a function now
		local checked = info.checked;
		if ( type(checked) == "function" ) then
			checked = checked(button);
		end

		-- Show the check if checked
		if ( checked ) then
			button:LockHighlight();
			check:Show();
			uncheck:Hide();
		else
			button:UnlockHighlight();
			check:Hide();
			uncheck:Show();
		end
	else
		_G[listFrameName.."Button"..index.."Check"]:Hide();
		_G[listFrameName.."Button"..index.."UnCheck"]:Hide();
	end
	button.checked = info.checked;
	if (WoWRetail and button.NewFeature) then
		button.NewFeature:SetShown(button.showNewLabel);
	end
	
	-- If has a colorswatch, show it and vertex color it
	local colorSwatch = _G[listFrameName.."Button"..index.."ColorSwatch"];
	if ( info.hasColorSwatch ) then
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			_G["L_DropDownList"..level.."Button"..index.."ColorSwatch".."NormalTexture"]:SetVertexColor(info.r, info.g, info.b);
		else
			_G["L_DropDownList"..level.."Button"..index.."ColorSwatch"].Color:SetVertexColor(info.r, info.g, info.b);
		end
		button.r = info.r;
		button.g = info.g;
		button.b = info.b;
		colorSwatch:Show();
	else
		colorSwatch:Hide();
	end

	lib:UIDropDownMenu_CheckAddCustomFrame(listFrame, button, info);

	button:SetShown(button.customFrame == nil);

	button.minWidth = info.minWidth;

	width = max(lib:UIDropDownMenu_GetButtonWidth(button), info.minWidth or 0);
	--Set maximum button width
	if ( width > (listFrame and listFrame.maxWidth or 0) ) then
		listFrame.maxWidth = width;
	end

	if (WoWRetail) then
		local customFrameCount = listFrame.customFrames and #listFrame.customFrames or 0;
		local height = ((index - customFrameCount) * buttonHeight) + (L_UIDROPDOWNMENU_BORDER_HEIGHT * 2);
		for frameIndex = 1, customFrameCount do
			local frame = listFrame.customFrames[frameIndex];
			height = height + frame:GetPreferredEntryHeight();
		end
		
		-- Set the height of the listframe
		listFrame:SetHeight(height);
	else
		-- Set the height of the listframe
		listFrame:SetHeight((index * L_UIDROPDOWNMENU_BUTTON_HEIGHT) + (L_UIDROPDOWNMENU_BORDER_HEIGHT * 2));	
	end

	return button;
end

function lib:UIDropDownMenu_CheckAddCustomFrame(self, button, info)
	local customFrame = info.customFrame;
	button.customFrame = customFrame;
	if customFrame then
		customFrame:SetOwningButton(button);
		customFrame:ClearAllPoints();
		customFrame:SetPoint("TOPLEFT", button, "TOPLEFT", 0, 0);
		customFrame:Show();

		lib:UIDropDownMenu_RegisterCustomFrame(self, customFrame);
	end
end

function lib:UIDropDownMenu_RegisterCustomFrame(self, customFrame)
	self.customFrames = self.customFrames or {}
	table.insert(self.customFrames, customFrame);
end

function lib:UIDropDownMenu_GetMaxButtonWidth(self)
	local maxWidth = 0;
	for i=1, self.numButtons do
		local button = _G[self:GetName().."Button"..i];
		local width = lib:UIDropDownMenu_GetButtonWidth(button);
		if ( width > maxWidth ) then
			maxWidth = width;
		end
	end
	return maxWidth;
end

function lib:UIDropDownMenu_GetButtonWidth(button)
	local minWidth = button.minWidth or 0;
	if button.customFrame and button.customFrame:IsShown() then
		return math.max(minWidth, button.customFrame:GetPreferredEntryWidth());
	end

	if not button:IsShown() then
		return 0;
	end

	local width;
	local buttonName = button:GetName();
	local icon = _G[buttonName.."Icon"];
	local normalText = _G[buttonName.."NormalText"];

	if ( button.iconOnly and icon ) then
		width = icon:GetWidth();
	elseif ( normalText and normalText:GetText() ) then
		width = normalText:GetWidth() + 40;

		if ( button.icon ) then
			-- Add padding for the icon
			width = width + 10;
		end
		if ( button.classicChecks ) then
			width = width + L_UIDROPDOWNMENU_CLASSIC_CHECK_PADDING;
		end
	else
		return minWidth;
	end

	-- Add padding if has and expand arrow or color swatch
	if ( button.hasArrow or button.hasColorSwatch ) then
		width = width + 10;
	end
	if (WoWRetail and button.showNewLabel and button.NewFeature) then
		width = width + button.NewFeature.Label:GetUnboundedStringWidth();
	end
	if ( button.notCheckable ) then
		width = width - 30;
	end
	if ( button.padding ) then
		width = width + button.padding;
	end

	return math.max(minWidth, width);
end

function lib:UIDropDownMenu_Refresh(frame, useValue, dropdownLevel)
	local maxWidth = 0;
	local somethingChecked = nil; 
	if ( not dropdownLevel ) then
		dropdownLevel = L_UIDROPDOWNMENU_MENU_LEVEL;
	end

	local listFrame = _G["L_DropDownList"..dropdownLevel];
	listFrame.numButtons = listFrame.numButtons or 0;
	-- Just redraws the existing menu
	for i=1, L_UIDROPDOWNMENU_MAXBUTTONS do
		local button = _G["L_DropDownList"..dropdownLevel.."Button"..i];
		local checked = nil;

		if(i <= listFrame.numButtons) then
			-- See if checked or not
			if ( lib:UIDropDownMenu_GetSelectedName(frame) ) then
				if ( button:GetText() == lib:UIDropDownMenu_GetSelectedName(frame) ) then
					checked = 1;
				end
			elseif ( lib:UIDropDownMenu_GetSelectedID(frame) ) then
				if ( button:GetID() == lib:UIDropDownMenu_GetSelectedID(frame) ) then
					checked = 1;
				end
			elseif ( lib:UIDropDownMenu_GetSelectedValue(frame) ) then
				if ( button.value == lib:UIDropDownMenu_GetSelectedValue(frame) ) then
					checked = 1;
				end
			end
		end
		if (button.checked and type(button.checked) == "function") then
			checked = button.checked(button);
		end

		if not button.notCheckable and button:IsShown() then
			-- If checked show check image
			local checkImage = _G["L_DropDownList"..dropdownLevel.."Button"..i.."Check"];
			local uncheckImage = _G["L_DropDownList"..dropdownLevel.."Button"..i.."UnCheck"];
			if ( checked ) then
				if not button.ignoreAsMenuSelection then
					somethingChecked = true;
					local icon = GetChild(frame, frame:GetName(), "Icon");
					if (button.iconOnly and icon and button.icon) then
						lib:UIDropDownMenu_SetIconImage(icon, button.icon, button.iconInfo);
					elseif ( useValue ) then
						lib:UIDropDownMenu_SetText(frame, button.value);
						icon:Hide();
					else
						lib:UIDropDownMenu_SetText(frame, button:GetText());
						icon:Hide();
					end
				end
				button:LockHighlight();
				checkImage:Show();
				uncheckImage:Hide();
			else
				button:UnlockHighlight();
				checkImage:Hide();
				uncheckImage:Show();
			end
		end

		if (WoWRetail and button.NewFeature) then
			local normalText = _G[button:GetName().."NormalText"];
			button.NewFeature:SetShown(button.showNewLabel);
			button.NewFeature:SetPoint("LEFT", normalText, "RIGHT", 20, 0);
		end

		if ( button:IsShown() ) then
			local width = lib:UIDropDownMenu_GetButtonWidth(button);
			if ( width > maxWidth ) then
				maxWidth = width;
			end
		end
	end
	if(somethingChecked == nil) then
		lib:UIDropDownMenu_SetText(frame, VIDEO_QUALITY_LABEL6);
		local icon = GetChild(frame, frame:GetName(), "Icon");
		icon:Hide();
	end
	if (not frame.noResize) then
		for i=1, L_UIDROPDOWNMENU_MAXBUTTONS do
			local button = _G["L_DropDownList"..dropdownLevel.."Button"..i];
			button:SetWidth(maxWidth);
		end
		lib:UIDropDownMenu_RefreshDropDownSize(_G["L_DropDownList"..dropdownLevel]);
	end
end

function lib:UIDropDownMenu_RefreshAll(frame, useValue)
	for dropdownLevel = L_UIDROPDOWNMENU_MENU_LEVEL, 2, -1 do
		local listFrame = _G["L_DropDownList"..dropdownLevel];
		if ( listFrame:IsShown() ) then
			lib:UIDropDownMenu_Refresh(frame, nil, dropdownLevel);
		end
	end
	-- useValue is the text on the dropdown, only needs to be set once
	lib:UIDropDownMenu_Refresh(frame, useValue, 1);
end

function lib:UIDropDownMenu_SetIconImage(icon, texture, info)
	icon:SetTexture(texture);
	if ( info.tCoordLeft ) then
		icon:SetTexCoord(info.tCoordLeft, info.tCoordRight, info.tCoordTop, info.tCoordBottom);
	else
		icon:SetTexCoord(0, 1, 0, 1);
	end
	if ( info.tSizeX ) then
		icon:SetWidth(info.tSizeX);
	else
		icon:SetWidth(16);
	end
	if ( info.tSizeY ) then
		icon:SetHeight(info.tSizeY);
	else
		icon:SetHeight(16);
	end
	icon:Show();
end

function lib:UIDropDownMenu_SetSelectedName(frame, name, useValue)
	frame.selectedName = name;
	frame.selectedID = nil;
	frame.selectedValue = nil;
	lib:UIDropDownMenu_Refresh(frame, useValue);
end

function lib:UIDropDownMenu_SetSelectedValue(frame, value, useValue)
	-- useValue will set the value as the text, not the name
	frame.selectedName = nil;
	frame.selectedID = nil;
	frame.selectedValue = value;
	lib:UIDropDownMenu_Refresh(frame, useValue);
end

function lib:UIDropDownMenu_SetSelectedID(frame, id, useValue)
	frame.selectedID = id;
	frame.selectedName = nil;
	frame.selectedValue = nil;
	lib:UIDropDownMenu_Refresh(frame, useValue);
end

function lib:UIDropDownMenu_GetSelectedName(frame)
	return frame.selectedName;
end

function lib:UIDropDownMenu_GetSelectedID(frame)
	if ( frame.selectedID ) then
		return frame.selectedID;
	else
		-- If no explicit selectedID then try to send the id of a selected value or name
--[[		local maxNum;
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			maxNum = L_UIDROPDOWNMENU_MAXBUTTONS
		else
			local listFrame = _G["L_DropDownList"..L_UIDROPDOWNMENU_MENU_LEVEL];
			maxNum = listFrame.numButtons
		end
		for i=1, maxNum do]]
		local listFrame = _G["L_DropDownList"..L_UIDROPDOWNMENU_MENU_LEVEL];
		for i=1, listFrame.numButtons do
			local button = _G["L_DropDownList"..L_UIDROPDOWNMENU_MENU_LEVEL.."Button"..i];
			-- See if checked or not
			if ( lib:UIDropDownMenu_GetSelectedName(frame) ) then
				if ( button:GetText() == lib:UIDropDownMenu_GetSelectedName(frame) ) then
					return i;
				end
			elseif ( lib:UIDropDownMenu_GetSelectedValue(frame) ) then
				if ( button.value == lib:UIDropDownMenu_GetSelectedValue(frame) ) then
					return i;
				end
			end
		end
	end
end

function lib:UIDropDownMenu_GetSelectedValue(frame)
	return frame.selectedValue;
end

function lib:HideDropDownMenu(level)
	local listFrame = _G["L_DropDownList"..level];
	listFrame:Hide();
end

function lib:ToggleDropDownMenu(level, value, dropDownFrame, anchorName, xOffset, yOffset, menuList, button, autoHideDelay, overrideDisplayMode)
	if ( not level ) then
		level = 1;
	end
	delegateFrame:SetAttribute("createframes-level", level);
	delegateFrame:SetAttribute("createframes-index", 0);
	delegateFrame:SetAttribute("createframes", true);
	L_UIDROPDOWNMENU_MENU_LEVEL = level;
	L_UIDROPDOWNMENU_MENU_VALUE = value;
	local listFrameName = "L_DropDownList"..level;
	local listFrame = _G[listFrameName];
	if (WoWRetail) then
		lib:UIDropDownMenu_ClearCustomFrames(listFrame);
	end
	
	local tempFrame;
	local point, relativePoint, relativeTo;
	if ( not dropDownFrame ) then
		tempFrame = button:GetParent();
	else
		tempFrame = dropDownFrame;
	end
	if ( listFrame:IsShown() and (L_UIDROPDOWNMENU_OPEN_MENU == tempFrame) ) then
		listFrame:Hide();
	else
		-- Set the dropdownframe scale
		local uiScale;
		local uiParentScale = UIParent:GetScale();
		if ( GetCVar("useUIScale") == "1" ) then
			uiScale = tonumber(GetCVar("uiscale"));
			if ( uiParentScale < uiScale ) then
				uiScale = uiParentScale;
			end
		else
			uiScale = uiParentScale;
		end
		listFrame:SetScale(uiScale);

		-- Hide the listframe anyways since it is redrawn OnShow()
		listFrame:Hide();

		-- Frame to anchor the dropdown menu to
		local anchorFrame;

		-- Display stuff
		-- Level specific stuff
		if ( level == 1 ) then
			delegateFrame:SetAttribute("openmenu", dropDownFrame);
			listFrame:ClearAllPoints();
			-- If there's no specified anchorName then use left side of the dropdown menu
			if ( not anchorName ) then
				-- See if the anchor was set manually using setanchor
				if ( dropDownFrame.xOffset ) then
					xOffset = dropDownFrame.xOffset;
				end
				if ( dropDownFrame.yOffset ) then
					yOffset = dropDownFrame.yOffset;
				end
				if ( dropDownFrame.point ) then
					point = dropDownFrame.point;
				end
				if ( dropDownFrame.relativeTo ) then
					relativeTo = dropDownFrame.relativeTo;
				else
					relativeTo = GetChild(L_UIDROPDOWNMENU_OPEN_MENU, L_UIDROPDOWNMENU_OPEN_MENU:GetName(), "Left");
				end
				if ( dropDownFrame.relativePoint ) then
					relativePoint = dropDownFrame.relativePoint;
				end
			elseif ( anchorName == "cursor" ) then
				relativeTo = nil;
				local cursorX, cursorY = GetCursorPosition();
				cursorX = cursorX/uiScale;
				cursorY =  cursorY/uiScale;

				if ( not xOffset ) then
					xOffset = 0;
				end
				if ( not yOffset ) then
					yOffset = 0;
				end
				xOffset = cursorX + xOffset;
				yOffset = cursorY + yOffset;
			else
				-- See if the anchor was set manually using setanchor
				if ( dropDownFrame.xOffset ) then
					xOffset = dropDownFrame.xOffset;
				end
				if ( dropDownFrame.yOffset ) then
					yOffset = dropDownFrame.yOffset;
				end
				if ( dropDownFrame.point ) then
					point = dropDownFrame.point;
				end
				if ( dropDownFrame.relativeTo ) then
					relativeTo = dropDownFrame.relativeTo;
				else
					relativeTo = anchorName;
				end
				if ( dropDownFrame.relativePoint ) then
					relativePoint = dropDownFrame.relativePoint;
				end
			end
			if ( not xOffset or not yOffset ) then
				xOffset = 8;
				yOffset = 22;
			end
			if ( not point ) then
				point = "TOPLEFT";
			end
			if ( not relativePoint ) then
				relativePoint = "BOTTOMLEFT";
			end
			listFrame:SetPoint(point, relativeTo, relativePoint, xOffset, yOffset);
		else
			if ( not dropDownFrame ) then
				dropDownFrame = L_UIDROPDOWNMENU_OPEN_MENU;
			end
			listFrame:ClearAllPoints();
			-- If this is a dropdown button, not the arrow anchor it to itself
			if ( strsub(button:GetParent():GetName(), 0,14) == "L_DropDownList" and strlen(button:GetParent():GetName()) == 15 ) then
				anchorFrame = button;
			else
				anchorFrame = button:GetParent();
			end
			point = "TOPLEFT";
			relativePoint = "TOPRIGHT";
			listFrame:SetPoint(point, anchorFrame, relativePoint, 0, 0);
		end

		if dropDownFrame.hideBackdrops then
			_G[listFrameName.."Backdrop"]:Hide();
			_G[listFrameName.."MenuBackdrop"]:Hide();
		else
			-- Change list box appearance depending on display mode
			local displayMode = overrideDisplayMode or (dropDownFrame and dropDownFrame.displayMode) or nil;
			if ( displayMode == "MENU" ) then
				_G[listFrameName.."Backdrop"]:Hide();
				_G[listFrameName.."MenuBackdrop"]:Show();
			else
				_G[listFrameName.."Backdrop"]:Show();
				_G[listFrameName.."MenuBackdrop"]:Hide();
			end
		end
		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			dropDownFrame.menuList = menuList;
		end

		lib:UIDropDownMenu_Initialize(dropDownFrame, dropDownFrame.initialize, nil, level, menuList);
		-- If no items in the drop down don't show it
		if ( listFrame.numButtons == 0 ) then
			return;
		end

		if (WoWRetail) then
			listFrame.onShow = dropDownFrame.listFrameOnShow;
		end

		-- Check to see if the dropdownlist is off the screen, if it is anchor it to the top of the dropdown button
		listFrame:Show();
		-- Hack since GetCenter() is returning coords relative to 1024x768
		local x, y = listFrame:GetCenter();
		-- Hack will fix this in next revision of dropdowns
		if ( not x or not y ) then
			listFrame:Hide();
			return;
		end

		listFrame.onHide = dropDownFrame.onHide;

		-- Set the listframe frameStrata
		if dropDownFrame.listFrameStrata then
			listFrame.baseFrameStrata = listFrame:GetFrameStrata();
			listFrame:SetFrameStrata(dropDownFrame.listFrameStrata);
		end

		--  We just move level 1 enough to keep it on the screen. We don't necessarily change the anchors.
		if ( level == 1 ) then
			local offLeft = listFrame:GetLeft()/uiScale;
			local offRight = (GetScreenWidth() - listFrame:GetRight())/uiScale;
			local offTop = (GetScreenHeight() - listFrame:GetTop())/uiScale;
			local offBottom = listFrame:GetBottom()/uiScale;

			local xAddOffset, yAddOffset = 0, 0;
			if ( offLeft < 0 ) then
				xAddOffset = -offLeft;
			elseif ( offRight < 0 ) then
				xAddOffset = offRight;
			end

			if ( offTop < 0 ) then
				yAddOffset = offTop;
			elseif ( offBottom < 0 ) then
				yAddOffset = -offBottom;
			end

			listFrame:ClearAllPoints();
			if ( anchorName == "cursor" ) then
				listFrame:SetPoint(point, relativeTo, relativePoint, xOffset + xAddOffset, yOffset + yAddOffset);
			else
				listFrame:SetPoint(point, relativeTo, relativePoint, xOffset + xAddOffset, yOffset + yAddOffset);
			end
		else
			-- Determine whether the menu is off the screen or not
			local offscreenY, offscreenX;
			if ( (y - listFrame:GetHeight()/2) < 0 ) then
				offscreenY = 1;
			end
			if ( listFrame:GetRight() > GetScreenWidth() ) then
				offscreenX = 1;
			end
			if ( offscreenY and offscreenX ) then
				point = gsub(point, "TOP(.*)", "BOTTOM%1");
				point = gsub(point, "(.*)LEFT", "%1RIGHT");
				relativePoint = gsub(relativePoint, "TOP(.*)", "BOTTOM%1");
				relativePoint = gsub(relativePoint, "(.*)RIGHT", "%1LEFT");
				xOffset = -11;
				yOffset = -14;
			elseif ( offscreenY ) then
				point = gsub(point, "TOP(.*)", "BOTTOM%1");
				relativePoint = gsub(relativePoint, "TOP(.*)", "BOTTOM%1");
				xOffset = 0;
				yOffset = -14;
			elseif ( offscreenX ) then
				point = gsub(point, "(.*)LEFT", "%1RIGHT");
				relativePoint = gsub(relativePoint, "(.*)RIGHT", "%1LEFT");
				xOffset = -11;
				yOffset = 14;
			else
				xOffset = 0;
				yOffset = 14;
			end

			listFrame:ClearAllPoints();
			listFrame.parentLevel = tonumber(strmatch(anchorFrame:GetName(), "L_DropDownList(%d+)"));
			listFrame.parentID = anchorFrame:GetID();
			listFrame:SetPoint(point, anchorFrame, relativePoint, xOffset, yOffset);
		end

		if (WoWClassicEra or WoWClassicTBC or WoWWOTLKC) then
			if ( autoHideDelay and tonumber(autoHideDelay)) then
				listFrame.showTimer = autoHideDelay;
				listFrame.isCounting = 1;
			end
		end
	end
end

function lib:CloseDropDownMenus(level)
	if ( not level ) then
		level = 1;
	end
	for i=level, L_UIDROPDOWNMENU_MAXLEVELS do
		_G["L_DropDownList"..i]:Hide();
	end
	-- yes, we also want to close the menus which created by built-in UIDropDownMenus
	for i=level, UIDROPDOWNMENU_MAXLEVELS do
		_G["DropDownList"..i]:Hide();
	end
end

local function containsMouse()
	local result = false
	
	for i = 1, L_UIDROPDOWNMENU_MAXLEVELS do
		local dropdown = _G["L_DropDownList"..i];
		if dropdown:IsShown() and dropdown:IsMouseOver() then
			result = true;
		end
	end
	for i = 1, UIDROPDOWNMENU_MAXLEVELS do
		local dropdown = _G["DropDownList"..i];
		if dropdown:IsShown() and dropdown:IsMouseOver() then
			result = true;
		end
	end
	-- TeeloJubeithos: 
	--   If the menu is open, and you click the button to close it, 
	--   the Global Mouse Down triggers to close it, but then the MouseDown for the button triggers to open it back up again.
	--   I fixed this by adding a filter to the global mouse down check, don't count it if the mouse is still over the DropDownMenu's Button
	if L_UIDROPDOWNMENU_OPEN_MENU and L_UIDROPDOWNMENU_OPEN_MENU.Button:IsMouseOver() then
		result = true;
	end

	return result;
end

function lib:containsMouse()
	containsMouse()
end

-- GLOBAL_MOUSE_DOWN event is only available in retail, not classic
function lib:UIDropDownMenu_HandleGlobalMouseEvent(button, event)
	if event == "GLOBAL_MOUSE_DOWN" and (button == "LeftButton" or button == "RightButton") then
		if not containsMouse() then
			lib:CloseDropDownMenus();
		end
	end
end

-- hooking UIDropDownMenu_HandleGlobalMouseEvent
do
	if lib and WoWRetail then
		hooksecurefunc("UIDropDownMenu_HandleGlobalMouseEvent", function(button, event) 
			lib:UIDropDownMenu_HandleGlobalMouseEvent(button, event) 
		end)

	end
end

function lib:UIDropDownMenu_ClearCustomFrames(self)
	if self.customFrames then
		for index, frame in ipairs(self.customFrames) do
			frame:Hide();
		end

		self.customFrames = nil;
	end
end

function lib:UIDropDownMenu_MatchTextWidth(frame, minWidth, maxWidth)
	local frameName = frame:GetName();
	local newWidth = GetChild(frame, frameName, "Text"):GetUnboundedStringWidth() + L_UIDROPDOWNMENU_DEFAULT_WIDTH_PADDING;
	
	if minWidth or maxWidth then
		newWidth = Clamp(newWidth, minWidth or newWidth, maxWidth or newWidth);
	end

	lib:UIDropDownMenu_SetWidth(frame, newWidth);
end

function lib:UIDropDownMenu_SetWidth(frame, width, padding)
	local frameName = frame:GetName();
	GetChild(frame, frameName, "Middle"):SetWidth(width);
	if ( padding ) then
		frame:SetWidth(width + padding);
	else
		frame:SetWidth(width + L_UIDROPDOWNMENU_DEFAULT_WIDTH_PADDING + L_UIDROPDOWNMENU_DEFAULT_WIDTH_PADDING);
	end
	if ( padding ) then
		GetChild(frame, frameName, "Text"):SetWidth(width);
	else
		GetChild(frame, frameName, "Text"):SetWidth(width - L_UIDROPDOWNMENU_DEFAULT_WIDTH_PADDING);
	end
	frame.noResize = 1;
end

function lib:UIDropDownMenu_SetButtonWidth(frame, width)
	local frameName = frame:GetName();
	if ( width == "TEXT" ) then
		width = GetChild(frame, frameName, "Text"):GetWidth();
	end

	GetChild(frame, frameName, "Button"):SetWidth(width);
	frame.noResize = 1;
end

function lib:UIDropDownMenu_SetText(frame, text)
	local frameName = frame:GetName();
	GetChild(frame, frameName, "Text"):SetText(text);
end

function lib:UIDropDownMenu_GetText(frame)
	local frameName = frame:GetName();
	return GetChild(frame, frameName, "Text"):GetText();
end

function lib:UIDropDownMenu_ClearAll(frame)
	-- Previous code refreshed the menu quite often and was a performance bottleneck
	frame.selectedID = nil;
	frame.selectedName = nil;
	frame.selectedValue = nil;
	lib:UIDropDownMenu_SetText(frame, "");

	local button, checkImage, uncheckImage;
	for i=1, L_UIDROPDOWNMENU_MAXBUTTONS do
		button = _G["L_DropDownList"..L_UIDROPDOWNMENU_MENU_LEVEL.."Button"..i];
		button:UnlockHighlight();

		checkImage = _G["L_DropDownList"..L_UIDROPDOWNMENU_MENU_LEVEL.."Button"..i.."Check"];
		checkImage:Hide();
		uncheckImage = _G["L_DropDownList"..L_UIDROPDOWNMENU_MENU_LEVEL.."Button"..i.."UnCheck"];
		uncheckImage:Hide();
	end
end

function lib:UIDropDownMenu_JustifyText(frame, justification, customXOffset, customYOffset)
	local frameName = frame:GetName();
	local text = GetChild(frame, frameName, "Text");
	text:ClearAllPoints();
	if ( justification == "LEFT" ) then
		text:SetPoint("LEFT", GetChild(frame, frameName, "Left"), "LEFT", customXOffset or 27, customYOffset or 2);
		text:SetJustifyH("LEFT");
	elseif ( justification == "RIGHT" ) then
		text:SetPoint("RIGHT", GetChild(frame, frameName, "Right"), "RIGHT", customXOffset or -43, customYOffset or 2);
		text:SetJustifyH("RIGHT");
	elseif ( justification == "CENTER" ) then
		text:SetPoint("CENTER", GetChild(frame, frameName, "Middle"), "CENTER", customXOffset or -5, customYOffset or 2);
		text:SetJustifyH("CENTER");
	end
end

function lib:UIDropDownMenu_SetAnchor(dropdown, xOffset, yOffset, point, relativeTo, relativePoint)
	dropdown.xOffset = xOffset;
	dropdown.yOffset = yOffset;
	dropdown.point = point;
	dropdown.relativeTo = relativeTo;
	dropdown.relativePoint = relativePoint;
end

function lib:UIDropDownMenu_GetCurrentDropDown()
	if ( L_UIDROPDOWNMENU_OPEN_MENU ) then
		return L_UIDROPDOWNMENU_OPEN_MENU;
	elseif ( L_UIDROPDOWNMENU_INIT_MENU ) then
		return L_UIDROPDOWNMENU_INIT_MENU;
	end
end

function lib:UIDropDownMenuButton_GetChecked(self)
	return _G[self:GetName().."Check"]:IsShown();
end

function lib:UIDropDownMenuButton_GetName(self)
	return _G[self:GetName().."NormalText"]:GetText();
end

function lib:UIDropDownMenuButton_OpenColorPicker(self, button)
	securecall("CloseMenus");
	if ( not button ) then
		button = self;
	end
	L_UIDROPDOWNMENU_MENU_VALUE = button.value;
	if (WoWRetail) then
		ColorPickerFrame:SetupColorPickerAndShow(button);
	else
		lib:OpenColorPicker(button); 
	end
end

function lib:UIDropDownMenu_DisableButton(level, id)
	lib:UIDropDownMenu_SetDropdownButtonEnabled(_G["DropDownList"..level.."Button"..id], false);
end

function lib:UIDropDownMenu_EnableButton(level, id)
	lib:UIDropDownMenu_SetDropdownButtonEnabled(_G["DropDownList"..level.."Button"..id], true);
end

function lib:UIDropDownMenu_SetDropdownButtonEnabled(button, enabled)
	if enabled then
		button:Enable();
	else
		button:Disable();
	end
end

function lib:UIDropDownMenu_SetButtonText(level, id, text, colorCode)
	local button = _G["L_DropDownList"..level.."Button"..id];
	if ( colorCode) then
		button:SetText(colorCode..text.."|r");
	else
		button:SetText(text);
	end
end

function lib:UIDropDownMenu_SetButtonNotClickable(level, id)
	_G["L_DropDownList"..level.."Button"..id]:SetDisabledFontObject(GameFontHighlightSmallLeft);
end

function lib:UIDropDownMenu_SetButtonClickable(level, id)
	_G["L_DropDownList"..level.."Button"..id]:SetDisabledFontObject(GameFontDisableSmallLeft);
end


function lib:UIDropDownMenu_DisableDropDown(dropDown)
	lib:UIDropDownMenu_SetDropDownEnabled(dropDown, false, disabledtooltip);
end

function lib:UIDropDownMenu_EnableDropDown(dropDown)
	lib:UIDropDownMenu_SetDropDownEnabled(dropDown, true);
end

function lib:UIDropDownMenu_SetDropDownEnabled(dropDown, enabled, disabledtooltip)
	local dropDownName = dropDown:GetName();
	local label = GetChild(dropDown, dropDownName, "Label");
	if label then
		label:SetVertexColor((enabled and NORMAL_FONT_COLOR or GRAY_FONT_COLOR):GetRGB());
	end

	local icon = GetChild(dropDown, dropDownName, "Icon");
	if icon then
		icon:SetVertexColor((enabled and HIGHLIGHT_FONT_COLOR or GRAY_FONT_COLOR):GetRGB());
	end

	local text = GetChild(dropDown, dropDownName, "Text");
	if text then
		text:SetVertexColor((enabled and HIGHLIGHT_FONT_COLOR or GRAY_FONT_COLOR):GetRGB());
	end

	local button = GetChild(dropDown, dropDownName, "Button");
	if button then
		button:SetEnabled(enabled);

		-- Clear any previously set disabledTooltip (it will be reset below if needed).
		if button:GetMotionScriptsWhileDisabled() then
			button:SetMotionScriptsWhileDisabled(false);
			button:SetScript("OnEnter", nil);
			button:SetScript("OnLeave", nil);
		end
	end

	if enabled then
		dropDown.isDisabled = nil;
	else
		dropDown.isDisabled = 1;

		if button then
			if disabledTooltip then
				button:SetMotionScriptsWhileDisabled(true);
				button:SetScript("OnEnter", function()
					GameTooltip:SetOwner(button, "ANCHOR_RIGHT");
					GameTooltip_AddErrorLine(GameTooltip, disabledTooltip);
					GameTooltip:Show();
				end);

				button:SetScript("OnLeave", GameTooltip_Hide);
			end
		end
	end
end

function lib:UIDropDownMenu_IsEnabled(dropDown)
	return not dropDown.isDisabled;
end

function lib:UIDropDownMenu_GetValue(id)
	--Only works if the dropdown has just been initialized, lame, I know =(
	local button = _G["L_DropDownList1Button"..id];
	if ( button ) then
		return _G["L_DropDownList1Button"..id].value;
	else
		return nil;
	end
end

function lib:OpenColorPicker(info)
	if (WoWRetail) then
		ColorPickerFrame:SetupColorPickerAndShow(info);
	else
		ColorPickerFrame.func = info.swatchFunc;
		ColorPickerFrame.hasOpacity = info.hasOpacity;
		ColorPickerFrame.opacityFunc = info.opacityFunc;
		ColorPickerFrame.opacity = info.opacity;
		ColorPickerFrame.previousValues = {r = info.r, g = info.g, b = info.b, opacity = info.opacity};
		ColorPickerFrame.cancelFunc = info.cancelFunc;
		ColorPickerFrame.extraInfo = info.extraInfo;
		-- This must come last, since it triggers a call to ColorPickerFrame.func()
		ColorPickerFrame:SetColorRGB(info.r, info.g, info.b);
		ShowUIPanel(ColorPickerFrame);
	end
end

function lib:ColorPicker_GetPreviousValues()
	if (WoWRetail) then
		local r, g, b = ColorPickerFrame:GetPreviousValues();
		return r, g, b;
	else
		return ColorPickerFrame.previousValues.r, ColorPickerFrame.previousValues.g, ColorPickerFrame.previousValues.b;
	end
end

-- //////////////////////////////////////////////////////////////
-- LibUIDropDownMenuTemplates
-- //////////////////////////////////////////////////////////////

-- Custom dropdown buttons are instantiated by some external system.
-- When calling L_UIDropDownMenu_AddButton that system sets info.customFrame to the instance of the frame it wants to place on the menu.
-- The dropdown menu creates its button for the entry as it normally would, but hides all elements.  The custom frame is then anchored
-- to that button and assumes responsibility for all relevant dropdown menu operations.
-- The hidden button will request a size that it should become from the custom frame.

lib.DropDownMenuButtonMixin = {}

function lib.DropDownMenuButtonMixin:OnEnter(...)
	ExecuteFrameScript(self:GetParent(), "OnEnter", ...);
end

function lib.DropDownMenuButtonMixin:OnLeave(...)
	ExecuteFrameScript(self:GetParent(), "OnLeave", ...);
end

function lib.DropDownMenuButtonMixin:OnMouseDown(button)
	if self:IsEnabled() then
		lib:ToggleDropDownMenu(nil, nil, self:GetParent());
		PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
	end
end

lib.LargeDropDownMenuButtonMixin = CreateFromMixins(lib.DropDownMenuButtonMixin);

function lib.LargeDropDownMenuButtonMixin:OnMouseDown(button)
	if self:IsEnabled() then
		local parent = self:GetParent();
		lib:ToggleDropDownMenu(nil, nil, parent, parent, -8, 8);
		PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
	end
end

lib.DropDownExpandArrowMixin = {};

function lib.DropDownExpandArrowMixin:OnEnter()
	local level =  self:GetParent():GetParent():GetID() + 1;

	lib:CloseDropDownMenus(level);

	if self:IsEnabled() then
		local listFrame = _G["L_DropDownList"..level];
		if ( not listFrame or not listFrame:IsShown() or select(2, listFrame:GetPoint()) ~= self ) then
			lib:ToggleDropDownMenu(level, self:GetParent().value, nil, nil, nil, nil, self:GetParent().menuList, self, nil, self:GetParent().menuListDisplayMode);
		end
	end
end

function lib.DropDownExpandArrowMixin:OnMouseDown(button)
	if self:IsEnabled() then
		lib:ToggleDropDownMenu(self:GetParent():GetParent():GetID() + 1, self:GetParent().value, nil, nil, nil, nil, self:GetParent().menuList, self, nil, self:GetParent().menuListDisplayMode);
		PlaySound(SOUNDKIT.IG_MAINMENU_OPTION_CHECKBOX_ON);
	end
end

lib.UIDropDownCustomMenuEntryMixin = {};

function lib.UIDropDownCustomMenuEntryMixin:GetPreferredEntryWidth()
	return self:GetWidth();
end

function lib.UIDropDownCustomMenuEntryMixin:GetPreferredEntryHeight()
	return self:GetHeight();
end

function lib.UIDropDownCustomMenuEntryMixin:OnSetOwningButton()
	-- for derived objects to implement
end

function lib.UIDropDownCustomMenuEntryMixin:SetOwningButton(button)
	self:SetParent(button:GetParent());
	self.owningButton = button;
	self:OnSetOwningButton();
end

function lib.UIDropDownCustomMenuEntryMixin:GetOwningDropdown()
	return self.owningButton:GetParent();
end

function lib.UIDropDownCustomMenuEntryMixin:SetContextData(contextData)
	self.contextData = contextData;
end

function lib.UIDropDownCustomMenuEntryMixin:GetContextData()
	return self.contextData;
end


lib.ColorSwatchMixin = {}

function lib.ColorSwatchMixin:SetColor(color)
	self.Color:SetVertexColor(color:GetRGB());
end

-- //////////////////////////////////////////////////////////////
-- L_UIDropDownCustomMenuEntryTemplate
function lib:Create_UIDropDownCustomMenuEntry(name, parent)
	local f = _G[name] or CreateFrame("Frame", name, parent or nil)
	f:EnableMouse(true)
	f:Hide()
	
	-- I am not 100% sure if below works for replacing the mixins
	f:SetScript("GetPreferredEntryWidth", function(self)
		return self:GetWidth()
	end)
	f:SetScript("SetOwningButton", function(self, button)
		self:SetParent(button:GetParent())
		self.owningButton = button
		self:OnSetOwningButton()
	end)
	f:SetScript("GetOwningDropdown", function(self)
		return self.owningButton:GetParent()
	end)
	f:SetScript("SetContextData", function(self, contextData)
		self.contextData = contextData
	end)
	f:SetScript("GetContextData", function(self)
		return self.contextData
	end)
	
	return f
end

-- //////////////////////////////////////////////////////////////
-- UIDropDownMenuButtonScriptTemplate
--
-- TBD
--

-- //////////////////////////////////////////////////////////////
-- LargeUIDropDownMenuTemplate
--
-- TBD
--

-- //////////////////////////////////////////////////////////////
-- EasyMenu
-- Simplified Menu Display System
--	This is a basic system for displaying a menu from a structure table.
--
--	Args:
--		menuList - menu table
--		menuFrame - the UI frame to populate
--		anchor - where to anchor the frame (e.g. CURSOR)
--		x - x offset
--		y - y offset
--		displayMode - border type
--		autoHideDelay - how long until the menu disappears
local function easyMenu_Initialize( frame, level, menuList )
	for index = 1, #menuList do
		local value = menuList[index]
		if (value.text) then
			value.index = index;
			lib:UIDropDownMenu_AddButton( value, level );
		end
	end
end

function lib:EasyMenu(menuList, menuFrame, anchor, x, y, displayMode, autoHideDelay )
	if ( displayMode == "MENU" ) then
		menuFrame.displayMode = displayMode;
	end
	lib:UIDropDownMenu_Initialize(menuFrame, easyMenu_Initialize, displayMode, nil, menuList);
	lib:ToggleDropDownMenu(1, nil, menuFrame, anchor, x, y, menuList, nil, autoHideDelay);
end

function lib:EasyMenu_Initialize( frame, level, menuList )
	easyMenu_Initialize( frame, level, menuList )
end


=== END OF FILE: WeakAurasOptions/Libs/LibUIDropDownMenu/LibUIDropDownMenu.lua ===


=== FILE: WeakAurasOptions/LoadOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local removeFuncs = OptionsPrivate.commonOptions.removeFuncs
local replaceNameDescFuncs = OptionsPrivate.commonOptions.replaceNameDescFuncs
local replaceImageFuncs = OptionsPrivate.commonOptions.replaceImageFuncs
local replaceValuesFuncs = OptionsPrivate.commonOptions.replaceValuesFuncs
local disabledAll = OptionsPrivate.commonOptions.CreateDisabledAll("load")
local hiddenAll = OptionsPrivate.commonOptions.CreateHiddenAll("load")
local getAll = OptionsPrivate.commonOptions.CreateGetAll("load")
local setAll = OptionsPrivate.commonOptions.CreateSetAll("load", getAll)

local ValidateNumeric = WeakAuras.ValidateNumeric;

local spellCache = WeakAuras.spellCache;

local function CorrectSpellName(input)
  local inputId = tonumber(input)
  if(inputId) then
    return inputId
  elseif WeakAuras.IsClassicEra() and input then
    local _, _, _, _, _, _, spellId = OptionsPrivate.Private.ExecEnv.GetSpellInfo(input)
    if spellId then
      return spellId
    end
  elseif(input) then
    local link;
    if(input:sub(1,1) == "\124") then
      link = input;
    else
      link = (GetSpellLink and GetSpellLink(input)) or (C_Spell and C_Spell.GetSpellLink and C_Spell.GetSpellLink(input));
    end
    if(link) and link ~= "" then
      local itemId = link:match("spell:(%d+)");
      return tonumber(itemId);
    else
      local spells = spellCache.GetSpellsMatching(input)
      if type(spells) == "table" then
        for id in pairs(spells) do
          if IsPlayerSpell(id) then
            return id
          end
        end
        return next(spells)
      end
    end
  end
end

local function CorrectItemName(input)
  local inputId = tonumber(input);
  if(inputId) then
    return inputId;
  elseif(input) then
    local _, link = C_Item.GetItemInfo(input);
    if(link) then
      local itemId = link:match("item:(%d+)");
      return tonumber(itemId);
    end
  end
end

-- Also used by the GenericTrigger

local function getValue(trigger, preCheckField, field, multiEntry, entryNumber, tristate)
  if preCheckField then
    if tristate then
      if trigger[preCheckField] ~= nil then
        return nil
      end
    else
      if not trigger[preCheckField] then
        return nil
      end
    end
  end
  if multiEntry then
    return type(trigger[field]) == "table" and trigger[field][entryNumber] or nil
  else
    return trigger[field] or nil
  end
end

local function shiftTable(tbl, pos)
  local size = #tbl
  for i = pos, size, 1 do
    tbl[i] = tbl[i + 1]
  end
end

local function setValue(trigger, field, value, multiEntry, entryNumber)
  if multiEntry then
    if type(trigger[field]) ~= "table" then
      if trigger[field] == nil then
        trigger[field] = {}
      else
        trigger[field] = { trigger[field] }
      end
    end
    if value == "" or value == nil then
      shiftTable(trigger[field], entryNumber)
    else
      trigger[field][entryNumber] = value
    end
  else
    trigger[field] = value
  end
end

function OptionsPrivate.ConstructOptions(prototype, data, startorder, triggernum, triggertype)
  local trigger
  -- For load options only the hidden property counts, but for the generic trigger
  -- we look at enabled.
  local hiddenProperty = triggertype == "load" and "hidden" or "enable"
  if(data.controlledChildren) then
    trigger = {}
  elseif(triggertype == "load") then
    trigger = data.load;
  elseif data.triggers[triggernum] then
    trigger = data.triggers[triggernum].trigger
  else
    error("Improper argument to OptionsPrivate.ConstructOptions - trigger number not in range");
  end
  local options = {};
  local order = startorder or 10;

  local isCollapsedFunctions;
  local positionsForCollapseAnchor = {}
  for index, arg in pairs(prototype.args) do
    local hidden = nil;
    if(type(arg.sortOrder) == "function") then
      arg.sortOrder = arg.sortOrder()
    end
    if(arg.collapse and isCollapsedFunctions[arg.collapse] and type(arg[hiddenProperty]) == "function") then
      local isCollapsed = isCollapsedFunctions[arg.collapse]
      if hiddenProperty == "hidden" then
        hidden = function() return isCollapsed() or arg[hiddenProperty](trigger) end
      else
        hidden = function() return isCollapsed() or not arg[hiddenProperty](trigger) end
      end
    elseif type(arg[hiddenProperty]) == "function" then
      if hiddenProperty == "hidden" then
        hidden = function() return arg[hiddenProperty](trigger) end
      else
        hidden = function() return not arg[hiddenProperty](trigger) end
      end
    elseif type(arg[hiddenProperty]) == "boolean" then
      if hiddenProperty == "hidden" then
        hidden = arg[hiddenProperty]
      else
        hidden = not arg[hiddenProperty]
      end
    elseif(arg.collapse and isCollapsedFunctions[arg.collapse]) then
      hidden = isCollapsedFunctions[arg.collapse]
    end
    local name = arg.name;
    local validate = arg.validate;
    local reloadOptions = arg.reloadOptions or arg.multiEntry ~= nil
    if (name and arg.type == "collapse") then
      options["summary_" .. arg.name] = {
        type = "execute",
        control = "WeakAurasExpandSmall",
        width = WeakAuras.doubleWidth,
        name = type(arg.display) == "function" and arg.display(trigger) or arg.display,
        order = order,
        image = function()
          local collapsed = OptionsPrivate.IsCollapsed("trigger", name, "", true)
          return collapsed and "collapsed" or "expanded"
        end,
        imageWidth = 15,
        imageHeight = 15,
        func = function(info, button, secondCall)
          if not secondCall then
            local collapsed = OptionsPrivate.IsCollapsed("trigger", name, "", true)
            OptionsPrivate.SetCollapsed("trigger", name, "", not collapsed)
          end
        end,
        arg = {
          expanderName = triggernum .. "#" .. tostring(prototype) .. "#"  .. name
        }
      }
      order = order + 1;

      isCollapsedFunctions = isCollapsedFunctions or {};
      isCollapsedFunctions[name] = function()
        return OptionsPrivate.IsCollapsed("trigger", name, "", true);
      end
    elseif name and (hiddenProperty == "hidden" or not arg.hidden) then
      local realname = name;
      if (arg.type == "multiselect") then
        -- Ensure new line for non-toggle options
        options["spacer_"..name] = {
          type = "description",
          width = WeakAuras.doubleWidth,
          name = "",
          order = order,
          hidden = hidden,
        }
        order = order + 1;
      end
      if(arg.type == "tristate" or arg.type == "tristatestring") then
        options["use_"..name] = {
          type = "toggle",
          width = WeakAuras.normalWidth,
          name = function(input)
            local value = trigger["use_"..realname];
            if(value == nil) then return arg.display;
            elseif(value == false) then return "|cFFFF0000 "..L["Negator"].." "..arg.display.."|r";
            else return "|cFF00FF00"..arg.display.."|r"; end
          end,
          desc = arg.desc,
          get = function()
            local value = trigger["use_"..realname];
            if(value == nil) then return false;
            elseif(value == false) then return "false";
            else return "true"; end
          end,
          set = function(info, v)
            if(v) then
              trigger["use_"..realname] = true;
            else
              local value = trigger["use_"..realname];
              if(value == false) then
                trigger["use_"..realname] = nil;
              else
                trigger["use_"..realname] = false
              end
            end
            WeakAuras.Add(data);
            WeakAuras.ClearAndUpdateOptions(data.id)
            OptionsPrivate.Private.ScanForLoads({[data.id] = true});
            WeakAuras.UpdateThumbnail(data);
            OptionsPrivate.SortDisplayButtons(nil, true);
          end,
          hidden = hidden,
          order = order
        };
      elseif(arg.type == "multiselect") then
        options["use_"..name] = {
          type = "toggle",
          width = WeakAuras.normalWidth,
          name = arg.display,
          desc = function()
            if arg.multiNoSingle or arg.desc then return arg.desc end
            local v = trigger["use_"..realname];
            if(v == true) then
              return L["Multiselect single tooltip"];
            elseif(v == false) then
              return L["Multiselect multiple tooltip"];
            else
              return L["Multiselect ignored tooltip"];
            end
          end,
          get = function()
            local value = trigger["use_"..realname];
            if arg.multiNoSingle then
              if value == nil then
                return false;
              else
                return "false"
              end
            else
              if(value == nil) then return false;
              elseif(value == false) then return "false";
              else return "true"; end
            end
          end,
          set = function(info, v)
            if arg.multiNoSingle then
              trigger[realname] = trigger[realname] or {};
              trigger[realname].multi = trigger[realname].multi or {};
              if v == true then
                trigger["use_"..realname] = false;
              else
                trigger["use_"..realname] = nil;
              end
            else
              if v then
                trigger["use_"..realname] = true;
              else
                local value = trigger["use_"..realname];
                if(value == false) then
                  trigger["use_"..realname] = nil;
                else
                  trigger["use_"..realname] = false
                  trigger[realname] = trigger[realname] or {};
                  if(trigger[realname].single) then
                    trigger[realname].multi = trigger[realname].multi or {};
                    trigger[realname].multi[trigger[realname].single] = true;
                  end
                end
              end
            end
            WeakAuras.Add(data);
            WeakAuras.ClearAndUpdateOptions(data.id)
            OptionsPrivate.Private.ScanForLoads({[data.id] = true});
            WeakAuras.UpdateThumbnail(data);
            OptionsPrivate.SortDisplayButtons(nil, true);
          end,
          hidden = hidden,
          order = order
        };
      elseif (arg.type == "description") then
        options["description_space_"..name] = {
          type = "description",
          width = WeakAuras.doubleWidth,
          name = "",
          order = order,
          hidden = hidden,
        }
        order = order + 1;
        options["description_title_"..name] = {
          type = "description",
          width = WeakAuras.doubleWidth,
          name = arg.display,
          order = order,
          hidden = hidden,
          fontSize = "large",
        }
        order = order + 1;
        options["description_"..name] = {
          type = "description",
          width = WeakAuras.doubleWidth,
          name = arg.text,
          order = order,
          hidden = hidden,
        }
        order = order + 1;
      elseif (arg.type == "header") then
        options["header_"..name] = {
          type = "header",
          width = WeakAuras.doubleWidth,
          name = arg.display,
          order = order,
          hidden = hidden,
        }
        order = order + 1
      else
        options["use_"..name] = {
          type = "toggle",
          width = arg.width or WeakAuras.normalWidth,
          name = arg.display,
          order = order,
          hidden = hidden,
          desc = arg.desc,
          get = function() return trigger["use_"..realname]; end,
          set = function(info, v)
            trigger["use_"..realname] = v;
            WeakAuras.Add(data);
            WeakAuras.ClearAndUpdateOptions(data.id)
            OptionsPrivate.Private.ScanForLoads({[data.id] = true});
            WeakAuras.UpdateThumbnail(data);
            OptionsPrivate.SortDisplayButtons(nil, true);
          end
        };
      end
      if(arg.type == "toggle" or arg.type == "tristate") then
        options["use_"..name].width = arg.width or WeakAuras.doubleWidth;
      end
      if(arg.type == "spell" or arg.type == "aura" or arg.type == "item") then
        if not arg.showExactOption then
          options["use_"..name].width = (arg.width or WeakAuras.normalWidth) - 0.2;
        end
      end

      if(arg.type == "toggle") then
        options["use_"..name].desc = arg.desc;
      end
      if(arg.required) then
        if arg.type == "multiselect" and arg.multiNoSingle then
          trigger["use_"..realname] = false
        else
          trigger["use_"..realname] = true
        end
        if not(triggertype) then
          options["use_"..name].disabled = true;
        else
          options["use_"..name] = nil;
          order = order - 1;
        end
      end
      order = order + 1;

      local countEntries = 0
      local multiEntry = arg.multiEntry ~= nil
      if multiEntry then
        if type(trigger[realname]) == "table" then
          countEntries = #trigger[realname]
        elseif trigger[realname] ~= nil then
          countEntries = 1
        end
      end

      for entryNumber = 1, countEntries + 1 do
        if arg.multiEntry then
          if arg.multiEntry.limit and entryNumber > arg.multiEntry.limit then
            break
          end
          if entryNumber > 1 then
            if arg.type == "tristate" or arg.type == "tristatestring" then
              if trigger["use_"..realname] == nil then
                break
              end
            else
              if not trigger["use_"..realname] then
                break
              end
            end
          end
        end

        local suffix = multiEntry and entryNumber or ""
        if entryNumber > 1 then
          options["spacer_"..name..suffix] = {
            type = "execute",
            name = arg.multiEntry.operator == "and" and L["and"] or L["or"],
            image = function() return "", 0, 0 end,
            order = order,
            hidden = hidden,
          }
          order = order + 1
        end

        if(arg.type == "number") then
          if entryNumber > 1 then
            options["spacer_"..name..suffix].width = WeakAuras.normalWidth
          end
          local disabled = not trigger["use_"..realname]
          options[name..suffix .. "dummy"] = {
            type = "description",
            name = "",
            width = WeakAuras.normalWidth,
            order = order,
            hidden = not disabled or hidden,
            hiddenAllIfAnyHidden = true
          }
          order = order + 1
          if (not arg.noOperator) then
            options[name.."_operator"..suffix] = {
              type = "select",
              width = WeakAuras.halfWidth,
              name = L["Operator"],
              order = order,
              hidden = disabled or hidden,
              values = arg.operator_types == "without_equal" and OptionsPrivate.Private.operator_types_without_equal
                       or arg.operator_types == "only_equal" and OptionsPrivate.Private.equality_operator_types
                       or OptionsPrivate.Private.operator_types,

              get = function()
                return getValue(trigger, "use_"..realname, realname.."_operator", multiEntry, entryNumber)
              end,
              set = function(info, v)
                setValue(trigger, realname.."_operator", v, multiEntry, entryNumber)
                WeakAuras.Add(data);
                if (reloadOptions) then
                  WeakAuras.ClearAndUpdateOptions(data.id)
                end
                OptionsPrivate.Private.ScanForLoads({[data.id] = true});
                WeakAuras.UpdateThumbnail(data);
                OptionsPrivate.SortDisplayButtons(nil, true);
              end
            };
            order = order + 1;
          end
          options[name..suffix] = {
            type = "input",
            width = arg.noOperator and WeakAuras.normalWidth or WeakAuras.halfWidth,
            validate = ValidateNumeric,
            name = arg.display,
            order = order,
            hidden = disabled or hidden,
            desc = arg.desc,
            get = function() return getValue(trigger, "use_"..realname, realname, multiEntry, entryNumber) end,
            set = function(info, v)
              setValue(trigger, realname, v, multiEntry, entryNumber)
              WeakAuras.Add(data);
              if (reloadOptions) then
                WeakAuras.ClearAndUpdateOptions(data.id)
              end
              OptionsPrivate.Private.ScanForLoads({[data.id] = true});
              WeakAuras.UpdateThumbnail(data);
              OptionsPrivate.SortDisplayButtons(nil, true);
            end
          };
          order = order + 1;
        elseif(arg.type == "string" or arg.type == "tristatestring") then
          if not arg.multiline and entryNumber > 1 then
            options["spacer_"..name..suffix].width = WeakAuras.normalWidth
          end

          local disabled
          if arg.type == "string" then
            disabled = not trigger["use_"..realname]
          else
            disabled = trigger["use_"..realname] == nil
          end

          options[name..suffix.."dummy"] = {
            type = "description",
            name = "",
            width = WeakAuras.normalWidth,
            order = order,
            hidden = not disabled or hidden,
            hiddenAllIfAnyHidden = true
          }
          order = order + 1
          options[name..suffix] = {
            type = "input",
            width = arg.multiline and WeakAuras.doubleWidth or WeakAuras.normalWidth,
            name = arg.display,
            order = order,
            hidden = disabled or hidden,
            validate = validate,
            desc = arg.desc,
            multiline = arg.multiline,
            control = arg.multiline and "WeakAuras-MultiLineEditBoxWithEnter" or nil,
            get = function()
              return getValue(trigger, "use_"..realname, realname, multiEntry, entryNumber, arg.type == "tristatestring")
            end,
            set = function(info, v)
              setValue(trigger, realname, v, multiEntry, entryNumber)
              WeakAuras.Add(data);
              if (reloadOptions) then
                WeakAuras.ClearAndUpdateOptions(data.id)
              end
              OptionsPrivate.Private.ScanForLoads({[data.id] = true});
              WeakAuras.UpdateThumbnail(data);
              OptionsPrivate.SortDisplayButtons(nil, true);
            end
          };
          order = order + 1
        elseif(arg.type == "longstring") then
          if entryNumber > 1 then
            options["spacer_"..name..suffix].width = WeakAuras.normalWidth
          end
          local disabled = not trigger["use_"..realname]
          options[name..suffix.."dummy"] = {
            type = "description",
            name = "",
            width = WeakAuras.normalWidth,
            order = order,
            hidden = not disabled or hidden,
            hiddenAllIfAnyHidden = true
          }
          order = order + 1;
          options[name.."_operator"..suffix] = {
            type = "select",
            width = WeakAuras.normalWidth,
            name = L["Operator"],
            order = order,
            hidden = disabled or hidden,
            values = OptionsPrivate.Private.string_operator_types,
            get = function() return getValue(trigger, "use_"..realname, realname.."_operator", multiEntry, entryNumber) end,
            set = function(info, v)
              setValue(trigger, realname.."_operator", v, multiEntry, entryNumber)
              WeakAuras.Add(data);
              if (reloadOptions) then
                WeakAuras.ClearAndUpdateOptions(data.id)
              end
              OptionsPrivate.Private.ScanForLoads({[data.id] = true});
              WeakAuras.UpdateThumbnail(data);
              OptionsPrivate.SortDisplayButtons(nil, true);
            end
          };
          order = order + 1;
          options[name..suffix] = {
            type = "input",
            width = arg.canBeCaseInsensitive and WeakAuras.normalWidth or WeakAuras.doubleWidth,
            name = arg.display,
            order = order,
            hidden = disabled or hidden,
            validate = validate,
            get = function() return getValue(trigger, "use_"..realname, realname, multiEntry, entryNumber) end,
            set = function(info, v)
              setValue(trigger, realname, v, multiEntry, entryNumber)
              WeakAuras.Add(data);
              if (reloadOptions) then
                WeakAuras.ClearAndUpdateOptions(data.id)
              end
              OptionsPrivate.Private.ScanForLoads({[data.id] = true});
              WeakAuras.UpdateThumbnail(data);
              OptionsPrivate.SortDisplayButtons(nil, true);
            end
          };
          order = order + 1;
          if arg.canBeCaseInsensitive then
            options[name.."_caseInsensitive"..suffix] = {
              type = "toggle",
              width = WeakAuras.normalWidth,
              name = L["Case Insensitive"],
              order = order,
              hidden = disabled or hidden,
              get = function() return getValue(trigger, "use_"..realname, realname.."_caseInsensitive", multiEntry, entryNumber) end,
              set = function(info, v)
                setValue(trigger, realname.."_caseInsensitive", v, multiEntry, entryNumber)
                WeakAuras.Add(data);
                if (reloadOptions) then
                  WeakAuras.ClearAndUpdateOptions(data.id)
                end
                OptionsPrivate.Private.ScanForLoads({[data.id] = true});
                WeakAuras.UpdateThumbnail(data);
                OptionsPrivate.SortDisplayButtons(nil, true);
              end
            };
            order = order + 1;
          end
        elseif(arg.type == "spell" or arg.type == "aura" or arg.type == "item") then
          if entryNumber > 1 then
            options["spacer_"..name..suffix].width = WeakAuras.normalWidth - (arg.showExactOption and 0 or 0.2)
          end
          local disabled = not trigger["use_"..realname]
          options[name..suffix.."dummy"] = {
            type = "description",
            name = "",
            width = WeakAuras.normalWidth,
            order = order,
            hidden = not disabled or hidden,
            hiddenAllIfAnyHidden = true
          }
          order = order + 1
          if (arg.showExactOption) then
            options["exact"..name..suffix] = {
              type = "toggle",
              width = WeakAuras.normalWidth,
              name = arg.type == "item" and L["Exact Item Match"] or L["Exact Spell Match"],
              order = order,
              hidden = disabled or hidden,
              get = function()
                return getValue(trigger, nil, "use_exact_"..realname, multiEntry, entryNumber)
              end,
              set = function(info, v)
                setValue(trigger, "use_exact_"..realname, v, multiEntry, entryNumber)
                WeakAuras.Add(data);
                OptionsPrivate.Private.ScanForLoads({[data.id] = true});
                WeakAuras.UpdateThumbnail(data);
                OptionsPrivate.SortDisplayButtons(nil, true);
              end,
            };
            order = order + 1;
          end
          options["icon"..name..suffix] = {
            type = "execute",
            width = 0.2,
            name = "",
            order = order,
            hidden = disabled or hidden,
            image = function()
              local value = getValue(trigger, "use_"..realname, realname, multiEntry, entryNumber)
              if type(value) == "number" or type(value) == "string" then
                if(arg.type == "aura") then
                  local icon = spellCache.GetIcon(value);
                  return icon and tostring(icon) or "", 18, 18;
                elseif(arg.type == "spell") then
                  if arg.negativeIsEJ and WeakAuras.IsRetail() then
                    local key = WeakAuras.SafeToNumber(value)
                    if key and key < 0 then
                      local tbl = C_EncounterJournal.GetSectionInfo(-key)
                      if tbl and tbl.abilityIcon then
                        return tostring(tbl.abilityIcon) or "", 18, 18;
                      end
                    end
                  end
                  local name, _, icon = OptionsPrivate.Private.ExecEnv.GetSpellInfo(value)
                  if arg.noValidation then
                    -- GetSpellInfo and other wow apis are case insensitive, but the later matching we do
                    -- isn't. For validted inputs, we automatically correct the casing via GetSpellName
                    -- Since we don't do that for noValidation, we are extra picky on the input
                    if type(value) == "string" and name ~= value then
                      return "", 18, 18
                    end
                  end
                  return icon and tostring(icon) or "", 18, 18;
                elseif(arg.type == "item") then
                  local _, _, _, _, _, _, _, _, _, icon = C_Item.GetItemInfo(value);
                  return icon and tostring(icon) or "", 18, 18;
                end
              else
                return "", 18, 18;
              end
            end,
            disabled = function()
              local value = getValue(trigger, nil, realname, multiEntry, entryNumber)
              if type(value) ~= "number" and type(value) ~= "string" then
                return true
              end
              return not ((arg.type == "aura" and value and spellCache.GetIcon(value)) or (arg.type == "spell" and value and OptionsPrivate.Private.ExecEnv.GetSpellName(value)) or (arg.type == "item" and value and C_Item.GetItemIconByID(value or '')))
            end
          };
          order = order + 1;
          options[name..suffix] = {
            type = "input",
            width = (arg.showExactOption and WeakAuras.doubleWidth or WeakAuras.normalWidth) - (arg.showExactOption and 0.2 or 0),
            name = arg.display,
            order = order,
            hidden = disabled or hidden,
            validate = validate,
            get = function()
              local value = getValue(trigger, "use_"..realname, realname, multiEntry, entryNumber)
              if(arg.type == "item") then
                local useExactSpellId = (arg.showExactOption and getValue(trigger, nil, "use_exact_"..realname, multiEntry, entryNumber))
                                        or arg.only_exact
                if value and value ~= "" then
                  if useExactSpellId then
                    local itemId = tonumber(value)
                    if itemId and itemId ~= 0 then
                      local itemName = C_Item.GetItemInfo(value)
                      if itemName then
                        return ("%s (%s)"):format(itemId, itemName) .. "\0" .. value
                      end
                      return tostring(value)
                    end
                  else
                    local name = C_Item.GetItemInfo(value);
                    if name then
                      return name;
                    end
                  end
                  return (useExactSpellId and L["Invalid Item ID"] or L["Invalid Item Name/ID/Link"]) .. "\0"
                else
                  return nil;
                end
              elseif(arg.type == "spell") then
                local useExactSpellId = (arg.showExactOption and getValue(trigger, nil, "use_exact_"..realname, multiEntry, entryNumber))
                                        or arg.only_exact
                if value and value ~= "" and (type(value) == "number" or type(value) == "string") then
                  local spellID = WeakAuras.SafeToNumber(value)
                  if spellID then
                    if arg.negativeIsEJ and WeakAuras.IsRetail() and spellID < 0 then
                      local tbl = C_EncounterJournal.GetSectionInfo(-spellID)
                      if tbl and tbl.title then
                        return ("%s (%s)"):format(spellID, tbl.title) .. "\0" .. value
                      end
                      return ("%s (%s)"):format(spellID, L["Unknown Encounter's Spell Id"]) .. "\0" .. value
                    end
                    local spellName = OptionsPrivate.Private.ExecEnv.GetSpellName(spellID)
                    if spellName then
                      return ("%s (%s)"):format(spellID, spellName) .. "\0" .. value
                    end
                    return ("%s (%s)"):format(spellID, L["Unknown Spell"]) .. "\0" .. value
                  elseif not useExactSpellId and not arg.noValidation then
                    local spellName = OptionsPrivate.Private.ExecEnv.GetSpellName(value)
                    if spellName then
                      return spellName
                    end
                  end
                end
                if arg.noValidation then
                  return value and tostring(value)
                end
                if value == nil then
                  return nil
                end
                return (useExactSpellId and L["Invalid Spell ID"] or L["Invalid Spell Name/ID/Link"]) .. "\0"
              else
                return value or nil
              end
            end,
            set = function(info, v)
              local fixedInput = v;
              if not arg.noValidation then
                if(arg.type == "aura") then
                  fixedInput = WeakAuras.spellCache.CorrectAuraName(v);
                elseif(arg.type == "spell") then
                  fixedInput = CorrectSpellName(v);
                elseif(arg.type == "item") then
                  fixedInput = CorrectItemName(v);
                end
              end
              setValue(trigger, realname, fixedInput, multiEntry, entryNumber)
              WeakAuras.Add(data);
              if (reloadOptions) then
                WeakAuras.ClearAndUpdateOptions(data.id)
              end
              OptionsPrivate.Private.ScanForLoads({[data.id] = true});
              WeakAuras.UpdateThumbnail(data);
              OptionsPrivate.SortDisplayButtons(nil, true);
            end,
            control = "WeakAurasInputFocus",
          };
          order = order + 1;
        elseif(arg.type == "select" or arg.type == "unit" or arg.type == "currency") then
          if entryNumber > 1 then
            options["spacer_"..name..suffix].width = WeakAuras.normalWidth
          end

          local disabled = not trigger["use_"..realname]
          options[name..suffix.."dummy"] = {
            type = "description",
            name = "",
            width = WeakAuras.normalWidth,
            order = order,
            hidden = not disabled or hidden,
            hiddenAllIfAnyHidden = true
          }
          order = order + 1
          local values;
          if(type(arg.values) == "function") then
            values = arg.values(trigger);
          else
            if OptionsPrivate.Private[arg.values] then
              values = OptionsPrivate.Private[arg.values]
            else
              values = WeakAuras[arg.values];
            end
          end
          local sortOrder = arg.sorted and (arg.sortOrder or OptionsPrivate.Private.SortOrderForValues(values)) or nil
          options[name..suffix] = {
            type = "select",
            width = WeakAuras.normalWidth,
            name = arg.display,
            order = order,
            hidden = disabled or hidden,
            values = values,
            sorting = sortOrder,
            desc = arg.desc,
            itemControl = arg.itemControl,
            headers = arg.headers,

            get = function()
              if((arg.type == "unit" or arg.type == "currency") and trigger["use_specific_"..realname]) then
                return "member";
              end

              if (not trigger["use_"..realname]) then
                return nil;
              end

              if (arg.default and (not trigger[realname] or not values[trigger[realname]])) then
                trigger[realname] = arg.default;
                return arg.default;
              end

              return trigger[realname] or nil;
            end,
            set = function(info, v)
              setValue(trigger, realname, v, multiEntry, entryNumber)
              if((arg.type == "unit" or arg.type == "currency") and v == "member") then
                trigger["use_specific_"..realname] = true;
                trigger[realname] = arg.type == "unit" and UnitName("player") or nil;
              else
                trigger["use_specific_"..realname] = nil;
              end
              WeakAuras.Add(data);
              if (reloadOptions) then
                WeakAuras.ClearAndUpdateOptions(data.id)
              end
              OptionsPrivate.Private.ScanForLoads({[data.id] = true});
              WeakAuras.UpdateThumbnail(data);
              OptionsPrivate.SortDisplayButtons(nil, true);
            end
          };
          if (arg.control) then
            options[name .. suffix].control = arg.control;
          end
          order = order + 1;
          if(arg.type == "unit" or arg.type == "currency") then
            local specificName = arg.type == "unit" and L["Specific Unit"] or L["Specific Currency ID"];
            local specificDesc = arg.type == "unit" and L["Can be a UID (e.g., party1)."] or nil;
            options["use_specific_"..name..suffix] = {
              type = "toggle",
              width = WeakAuras.normalWidth,
              name = specificName,
              order = order,
              hidden = disabled or function()
                return (not trigger["use_specific_"..realname] and trigger[realname] ~= "member")
                      or (type(hidden) == "function" and hidden(trigger))
                      or (type(hidden) ~= "function" and hidden)
                end,
              get = function() return true end,
              set = function(info, v)
                trigger["use_specific_"..realname] = nil;
                options[name .. suffix].set(info, "player");
                WeakAuras.Add(data)
              end
            }
            order = order + 1;
            options["specific_"..name..suffix] = {
              type = "input",
              width = WeakAuras.normalWidth,
              name = specificName,
              desc = specificDesc,
              order = order,
              validate = arg.type == "currency" and WeakAuras.ValidateNumeric or false,
              hidden = disabled or function() return (not trigger["use_specific_"..realname] and trigger[realname] ~= "member") or (type(hidden) == "function" and hidden(trigger)) or (type(hidden) ~= "function" and hidden) end,
              get = function() return trigger[realname] end,
              set = function(info, v)
                trigger[realname] = v;
                WeakAuras.Add(data);
                if (reloadOptions) then
                  WeakAuras.ClearAndUpdateOptions(data.id)
                end
              end
            };
            order = order + 1;
          end
        elseif(arg.type == "multiselect") then
          if entryNumber > 1 then
            options["spacer_"..name..suffix].width = WeakAuras.normalWidth
          end
          local disabled = trigger["use_"..realname] == nil
          options[name..suffix.."dummy"] = {
            type = "description",
            name = "",
            width = WeakAuras.normalWidth,
            order = order,
            hidden = not disabled or hidden,
            hiddenAllIfAnyHidden = true
          }
          order = order + 1
          local values;
          if(type(arg.values) == "function") then
            values = arg.values(trigger);
          else
            if OptionsPrivate.Private[arg.values] then
              values = OptionsPrivate.Private[arg.values]
            else
              values = WeakAuras[arg.values];
            end
          end
          local sortOrder = arg.sorted and (arg.sortOrder or OptionsPrivate.Private.SortOrderForValues(values)) or nil
          options[name..suffix] = {
            type = "select",
            width = WeakAuras.normalWidth,
            name = arg.display,
            order = order,
            values = values,
            sorting = sortOrder,
            control = arg.control,
            hidden = disabled or function()
              return (type(hidden) == "function" and hidden(trigger)) or (type(hidden) ~= "function" and hidden) or trigger["use_"..realname] == false;
            end,
            get = function() return trigger["use_"..realname] and trigger[realname] and trigger[realname].single or nil; end,
            set = function(info, v)
              trigger[realname] = trigger[realname] or {};
              trigger[realname].single = v;
              WeakAuras.Add(data);
              if (reloadOptions) then
                WeakAuras.ClearAndUpdateOptions(data.id)
              end
              OptionsPrivate.Private.ScanForLoads({[data.id] = true});
              WeakAuras.UpdateThumbnail(data);
              OptionsPrivate.SortDisplayButtons(nil, true);
            end
          };

          if arg.extraOption then
            options["multiselect_extraOption_" .. name..suffix] =
            {
              name = arg.extraOption.display,
              type = "select",
              values = arg.extraOption.values,
              order = order,
              width = WeakAuras.normalWidth,
              hidden = disabled or function() return (type(hidden) == "function" and hidden(trigger)) or (type(hidden) ~= "function" and hidden) or trigger["use_"..realname] ~= false; end,
              get = function(info, v)
                return trigger[realname .. "_extraOption"] or 0
              end,
              set = function(info, v)
                trigger[realname .. "_extraOption"] = v
                WeakAuras.Add(data)
                OptionsPrivate.Private.ScanForLoads({[data.id] = true})
                OptionsPrivate.SortDisplayButtons(nil, true)
              end
            }
            order = order + 1
          end

          options["multiselect_"..name..suffix] = {
            type = "multiselect",
            name = arg.display,
            width = WeakAuras.doubleWidth,
            order = order,
            hidden = disabled or function() return (type(hidden) == "function" and hidden(trigger)) or (type(hidden) ~= "function" and hidden) or trigger["use_"..realname] ~= false; end,
            values = values,
            control = arg.multiUseControlWhenFalse and arg.control,
            multiTristate = arg.multiTristate,
            get = function(info, v)
              if(trigger["use_"..realname] == false and trigger[realname] and trigger[realname].multi) then
                if arg.multiConvertKey then
                  v = arg.multiConvertKey(trigger, v)
                end
                if v then
                  return trigger[realname].multi[v];
                end
              end
            end,
            set = function(info, v, calledFromSetAll)
              if arg.multiConvertKey then
                v = arg.multiConvertKey(trigger, v)
              end
              if v then
                trigger[realname] = trigger[realname] or {}
                trigger[realname].multi = trigger[realname].multi or {};
                if (calledFromSetAll or arg.multiTristate) then
                  trigger[realname].multi[v] = calledFromSetAll;
                elseif(trigger[realname].multi[v]) then
                  trigger[realname].multi[v] = nil;
                else
                  trigger[realname].multi[v] = true;
                end
                WeakAuras.Add(data);
                if (reloadOptions) then
                  -- Hack specifally for dragon flight mini talent
                  -- That widget needs to be informed before and
                  -- after a reload
                  OptionsPrivate.Private.callbacks:Fire("BeforeReload")
                  WeakAuras.ClearAndUpdateOptions(data.id)
                  WeakAuras.FillOptions()
                  OptionsPrivate.Private.callbacks:Fire("AfterReload")
                end
                OptionsPrivate.Private.ScanForLoads({[data.id] = true});
                WeakAuras.UpdateThumbnail(data);
                OptionsPrivate.SortDisplayButtons(nil, true);
              end
            end
          };
          order = order + 1;
        end
      end
    end

    if(arg.collapse and isCollapsedFunctions[arg.collapse]) then
      positionsForCollapseAnchor[arg.collapse] = order
      order = order +1
    end
  end

  if prototype.countEvents then
    options.use_count = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = WeakAuras.newFeatureString .. L["Count"],
      order = order,
      get = function()
        return trigger.use_count
      end,
      set = function(info, v)
        trigger.use_count = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    };
    order = order + 1;

    local disabled = not trigger.use_count
    if disabled then
      options.countDummy = {
        type = "description",
        name = "",
        width = WeakAuras.normalWidth,
        order = order,
        hidden = not disabled,
        hiddenAllIfAnyHidden = true
      }
      order = order + 1
    else
      options.count = {
        type = "input",
        width = WeakAuras.normalWidth,
        name = L["Count"],
        desc = L["Occurrence of the event, reset when aura is unloaded\nCan be a range of values\nCan have multiple values separated by a comma or a space\n\nExamples:\n2nd 5th and 6th events: 2, 5, 6\n2nd to 6th: 2-6\nevery 2 events: /2\nevery 3 events starting from 2nd: 2/3\nevery 3 events starting from 2nd and ending at 11th: 2-11/3"],
        order = order,
        get = function()
          return trigger.count
        end,
        set = function(info, v)
          trigger.count = v
          WeakAuras.Add(data)
        end,
        hidden = disabled
      };
      order = order + 1;
    end
  end
  if prototype.delayEvents then
    options.use_delay = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = WeakAuras.newFeatureString .. L["Delay"],
      order = order,
      get = function()
        return trigger.use_delay
      end,
      set = function(info, v)
        trigger.use_delay = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    };
    order = order + 1;

    local disabled = not trigger.use_delay
    if disabled then
      options.delayDummy = {
        type = "description",
        name = "",
        width = WeakAuras.normalWidth,
        order = order,
        hiddenAllIfAnyHidden = true
      }
      order = order + 1
    else
      options.delay = {
        type = "input",
        width = WeakAuras.normalWidth,
        name = L["Delay"],
        order = order,

        validate = WeakAuras.ValidateTime,
        get = function()
          return OptionsPrivate.Private.tinySecondFormat(trigger.delay)
        end,
        set = function(info, v)
          trigger.delay = WeakAuras.TimeToSeconds(v)
          WeakAuras.Add(data)
        end
      };
      order = order + 1;
    end
  end
  if prototype.timedrequired then
    options.unevent = {
      type = "toggle",
      disabled = true,
      width = WeakAuras.normalWidth,
      name = L["Hide After"],
      order = order,
      get = function()
        return true
      end,
      set = function(info, v)
        -- unevent is no longer used
      end
    };
    order = order + 1;

    options.duration = {
      type = "input",
      width = WeakAuras.normalWidth,
      name = L["Duration (s)"],
      validate = WeakAuras.ValidateTime,
      order = order,
      get = function()
        return OptionsPrivate.Private.tinySecondFormat(trigger.duration)
      end,
      set = function(info, v)
        trigger.duration = tostring(WeakAuras.TimeToSeconds(v))
        WeakAuras.Add(data)
      end
    }
    order = order + 1;
  end

  for name, order in pairs(positionsForCollapseAnchor) do
    options[name .. "anchor"] = {
      type = "description",
      name = "",
      control = "WeakAurasExpandAnchor",
      order = order,
      arg = {
        expanderName = triggernum .. "#" .. tostring(prototype) .. "#"  .. name
      },
      hidden = isCollapsedFunctions[name]
    }
  end

  return options;
end

function OptionsPrivate.GetLoadOptions(data)
  local load = {
    type = "group",
    name = L["Load"],
    order = 0,
    get = function(info) return data.load[info[#info]] end,
    set = function(info, v)
        data.load[info[#info]] = (v ~= "" and v) or nil;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.Private.ScanForLoads({[data.id] = true});
        OptionsPrivate.SortDisplayButtons(nil, true);
      end,
      args = {}
    }

    load.args = OptionsPrivate.ConstructOptions(OptionsPrivate.Private.load_prototype, data, 10, nil, "load");

    if(data.controlledChildren) then
      removeFuncs(load);
      replaceNameDescFuncs(load, data, "load");
      replaceImageFuncs(load, data, "load");
      replaceValuesFuncs(load, data, "load");

      load.get = function(info, ...) return getAll(data, info, ...); end;
      load.set = function(info, ...)
        setAll(data, info, ...);
        if(type(data.id) == "string") then
          WeakAuras.Add(data);
          WeakAuras.UpdateThumbnail(data);
          OptionsPrivate.ResetMoverSizer();
        end
      end
      load.hidden = function(info, ...) return hiddenAll(data, info, ...); end;
      load.disabled = function(info, ...) return disabledAll(data, info, ...); end;
    end
    return load
end

=== END OF FILE: WeakAurasOptions/LoadOptions.lua ===


=== FILE: WeakAurasOptions/Locales/deDE.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "deDE" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = "und |cFFFF0000gespiegelt|r"
	--[[Translation missing --]]
	L["-- Do not remove this comment, it is part of this aura: "] = "-- Do not remove this comment, it is part of this aura: "
	L[" rotated |cFFFF0000%s|r degrees"] = "rotiert um |cFFFF0000%s|r grad"
	L["% - To show a percent sign"] = "% - Um ein Prozent Symbol zu erzeugen."
	L["% of Progress"] = "Fortschritt in %"
	L["%d |4aura:auras; added"] = "%d |4aura:auras; hinzugefgt"
	L["%d |4aura:auras; deleted"] = "%d |4aura:auras; gelscht"
	L["%d |4aura:auras; modified"] = "%d |4aura:auras; gendert"
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; in denen meta daten modifiziert wurden"
	L["%d displays loaded"] = "%d Auren geladen"
	L["%d displays not loaded"] = "%d Auren nicht geladen"
	L["%d displays on standby"] = "%d Auren auf standby"
	L["%i auras selected"] = "%i Auren ausgew\\195\\164hlt"
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i. Trigger"
	L["%s - Alpha Animation"] = "%s - Alpha-Animation"
	L["%s - Color Animation"] = "%s - Farb-Animation"
	L["%s - Condition Custom Chat %s"] = "%s - Bedingung benutzerdefiniert Chat %s"
	L["%s - Condition Custom Check %s"] = "%s - Bedingung Benutzerdefinierter Check %s"
	L["%s - Condition Custom Code %s"] = "%s - Bedingung benutzerdefinierter Code %s"
	L["%s - Custom Anchor"] = "%s - Benutzerdefinierter Anker"
	L["%s - Custom Grow"] = "%s - Benutzerdefiniertes Wachstum"
	L["%s - Custom Sort"] = "%s - Benutzerdefinierte Sortierung"
	L["%s - Custom Text"] = "%s - Benutzerdefinierter Text"
	L["%s - Finish"] = "%s - Ende"
	L["%s - Finish Action"] = "%s - Endaktion"
	L["%s - Finish Custom Text"] = "%s - Benutzerdefinierter Endtext"
	L["%s - Init Action"] = "%s - Initialisierung"
	L["%s - Main"] = "%s - Haupt"
	--[[Translation missing --]]
	L["%s - OnLoad"] = "%s - OnLoad"
	--[[Translation missing --]]
	L["%s - OnUnload"] = "%s - OnUnload"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "Die %s - Option #%i hat bereits den Schlssel %s. Bitte whle einen anderen Optionsschlssel."
	L["%s - Rotate Animation"] = "%s - Rotierungsanimation"
	L["%s - Scale Animation"] = "%s - Skalierungsanimation"
	L["%s - Start"] = "%s - Start"
	L["%s - Start Action"] = "%s - Startaktion"
	L["%s - Start Custom Text"] = "%s - Benutzerdefiniertet Starttext"
	L["%s - Translate Animation"] = "%s - bersetzungsanimation"
	L["%s - Trigger Logic"] = "%s - Triggerlogik"
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, Linien: %d, Frequenz: %0.2f, Lnge: %d, Breite: %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, Partikel: %d, Frequenz: %0.2f, Skalierung: %0.2f"
	L["%s %u. Overlay Function"] = "%s %u. Overlay Funkion"
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s Alpha: %d%%"
	L["%s Color"] = "%s Farbe"
	L["%s Custom Variables"] = "%s benutzerdefinierte Variablen"
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s Standard Alpha, Zoom, Bild, Einsatz, Aspekt Ratio"
	L["%s Duration Function"] = "%s Dauerfunktion"
	L["%s Icon Function"] = "%s Bildfunktion"
	L["%s Inset: %d%%"] = "%s Einsatz: %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s ist kein valides SubEvent fr COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s Behalte Aspekt Ratio"
	L["%s Name Function"] = "%s Namensfunktion"
	L["%s Stacks Function"] = "%s Stapelfunkion"
	L["%s stores around %s KB of data"] = "%s speichert um die %s KB an Daten"
	L["%s Texture"] = "%s Textur"
	L["%s Texture Function"] = "%s Texturfunktion"
	L["%s total auras"] = "%s gesamte Auren"
	L["%s Trigger Function"] = "%s Auslsefunktion"
	L["%s Untrigger Function"] = "%s Umkehrauslserfunkion"
	L["%s X offset by %d"] = "%s X versatz um %d"
	L["%s Y offset by %d"] = "%s Y versatz um %d"
	L["%s Zoom: %d%%"] = "%s Zoom: %d%%"
	L["%s, Border"] = "%s, Rahmen"
	L["%s, Offset: %0.2f;%0.2f"] = "%s, Versatz: %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, Versatz: %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s, Startanimation"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000benutzerdefiniert|r Texture mit |cFFFF0000%s|r Mischmodus%s%s"
	L["(Right click to rename)"] = "(Rechtsklick zum Umbenennen)"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02xbenutzerdefiniert Farbe|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999Trigger die multiplen Einheiten verfolgen sind standardmig aktiv, selbst wenn keine Einheiten gefunden werden, falls sie keinen UnitCount oder MatchCount Einstellung enthalten.|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000Notiz|r Dies setzt die Beschreibung nur fr '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000Notiz|r Dies setzt die URL fr alle ausgewhlten Auren"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000Notiz:|r Dies setzt die URL fr die Gruppe und alle Kinder"
	--[[Translation missing --]]
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000Automatic|r length"
	--[[Translation missing --]]
	L["|cFFFF0000default|r texture"] = "|cFFFF0000default|r texture"
	--[[Translation missing --]]
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000desaturated|r "
	--[[Translation missing --]]
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000Note:|r The unit '%s' is not a trackable unit."
	--[[Translation missing --]]
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"
	--[[Translation missing --]]
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00Extra Options:|r"
	--[[Translation missing --]]
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00Extra:|r %s and %s %s"
	--[[Translation missing --]]
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"
	--[[Translation missing --]]
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"
	--[[Translation missing --]]
	L["|cffffcc00Format Options|r"] = "|cffffcc00Format Options|r"
	--[[Translation missing --]]
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=]
	L["A 20x20 pixels icon"] = "Ein Symbol mit 20x20 Pixeln"
	L["A 32x32 pixels icon"] = "Ein Symbol mit 32x32 Pixeln"
	L["A 40x40 pixels icon"] = "Ein Symbol mit 40x40 Pixeln"
	L["A 48x48 pixels icon"] = "Ein Symbol mit 48x48 Pixeln"
	L["A 64x64 pixels icon"] = "Ein Symbol mit 64x64 Pixeln"
	L["A group that dynamically controls the positioning of its children"] = "Eine Gruppe, die dynamisch die Position ihrer Kinder steuert"
	--[[Translation missing --]]
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=]
	--[[Translation missing --]]
	L["A Unit ID (e.g., party1)."] = "A Unit ID (e.g., party1)."
	--[[Translation missing --]]
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	--[[Translation missing --]]
	L["Active Aura Filters and Info"] = "Active Aura Filters and Info"
	--[[Translation missing --]]
	L["Actual Spec"] = "Actual Spec"
	L["Add %s"] = "Fge %s hinzu"
	L["Add a new display"] = "Neue Anzeige hinzufgen"
	L["Add Condition"] = "Neue Bedingung"
	L["Add Entry"] = "Eintrag hinzufgen"
	--[[Translation missing --]]
	L["Add Extra Elements"] = "Add Extra Elements"
	L["Add Option"] = "Option hinzufgen"
	L["Add Overlay"] = "Overlay hinzufgen"
	L["Add Property Change"] = "Weitere nderung"
	--[[Translation missing --]]
	L["Add Snippet"] = "Add Snippet"
	L["Add Sub Option"] = "Unteroption hinzufgen"
	L["Add to group %s"] = "Zu Gruppe %s hinzufgen"
	L["Add to new Dynamic Group"] = "Neue dynamische Gruppe hinzufgen"
	L["Add to new Group"] = "Neue Gruppe hinzufgen"
	L["Add Trigger"] = "Auslser hinzufgen"
	--[[Translation missing --]]
	L["Additional Events"] = "Additional Events"
	L["Advanced"] = "Erweitert"
	--[[Translation missing --]]
	L["Affected Unit Filters and Info"] = "Affected Unit Filters and Info"
	L["Align"] = "Ausrichtung"
	L["Alignment"] = "Ausrichtung"
	--[[Translation missing --]]
	L["All maintainers of the libraries we use, especially:"] = "All maintainers of the libraries we use, especially:"
	L["All of"] = "Alles von"
	--[[Translation missing --]]
	L["Allow Full Rotation"] = "Allow Full Rotation"
	L["Anchor"] = "Anker"
	--[[Translation missing --]]
	L["Anchor Mode"] = "Anchor Mode"
	L["Anchor Point"] = "Ankerpunkt"
	L["Anchored To"] = "Angeheftet an"
	L["And "] = "Und"
	L["and"] = "und"
	--[[Translation missing --]]
	L["and %s"] = "and %s"
	L["and aligned left"] = "und links ausgerichtet"
	L["and aligned right"] = "und rechts ausgerichtet"
	--[[Translation missing --]]
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"
	L["and rotated left"] = "und nach links gedreht"
	L["and rotated right"] = "und nach rechts gedreht"
	--[[Translation missing --]]
	L["and with width |cFFFF0000%s|r and %s"] = "and with width |cFFFF0000%s|r and %s"
	L["Angle"] = "Winkel"
	--[[Translation missing --]]
	L["Angle Between Auras"] = "Angle Between Auras"
	L["Animate"] = "Animieren"
	L["Animated Expand and Collapse"] = "Erweitern und Verbergen animieren"
	L["Animates progress changes"] = "Animiert Fortschrittsnderungen"
	--[[Translation missing --]]
	L["Animation End"] = "Animation End"
	L["Animation Mode"] = "Animationsmodus"
	L["Animation relative duration description"] = [=[Die Dauer der Animation relativ zur Dauer der Anzeige als Bruchteil (1/2), als Prozent (50%) oder als Dezimal (0.5).
|cFFFF0000Notiz:|r Falls die Anzeige keine Dauer besitzt (zb. Aura ohne Dauer), wird diese Animation nicht ausgefhrt.

|cFF4444FFFBeispiel:|r
Falls die Dauer der Animation auf |cFF00CC0010%|r gesetzt wurde und die Dauer der Anzeige 20 Sekunden betrgt (zb. Debuff), dann wird diese Animation ber eine Dauer von 2 Sekunden abgespielt.
Falls die Dauer der Animation auf |cFF00CC0010%|r gesetzt wurde und fr die Anzeige keine Dauer bekannt ist (Meistens kann diese auch manuell festgelegt werden), wird diese Animation nicht abgespielt.]=]
	L["Animation Sequence"] = "Animationssequenz"
	--[[Translation missing --]]
	L["Animation Start"] = "Animation Start"
	--[[Translation missing --]]
	L["Any of"] = "Any of"
	L["Apply Template"] = "Vorlage bernehmen"
	L["Arcane Orb"] = "Arkane Kugel"
	--[[Translation missing --]]
	L["Area"] = "Area"
	--[[Translation missing --]]
	L["At a position a bit left of Left HUD position."] = "At a position a bit left of Left HUD position."
	--[[Translation missing --]]
	L["At a position a bit left of Right HUD position"] = "At a position a bit left of Right HUD position"
	L["At the same position as Blizzard's spell alert"] = "An der Position von Blizzards Zauberwarnmeldung"
	--[[Translation missing --]]
	L["Attach to Foreground"] = "Attach to Foreground"
	--[[Translation missing --]]
	L[ [=[Aura is
Off Screen]=] ] = [=[Aura is
Off Screen]=]
	L["Aura Name Pattern"] = "Aura Namensmuster"
	--[[Translation missing --]]
	L["Aura Order"] = "Aura Order"
	--[[Translation missing --]]
	L["Aura received from: %s"] = "Aura received from: %s"
	--[[Translation missing --]]
	L["Aura: '%s'"] = "Aura: '%s'"
	--[[Translation missing --]]
	L["Auto-Clone (Show All Matches)"] = "Auto-Clone (Show All Matches)"
	--[[Translation missing --]]
	L["Automatic length"] = "Automatic length"
	L["Backdrop Color"] = "Hintergrundfarbe"
	--[[Translation missing --]]
	L["Backdrop in Front"] = "Backdrop in Front"
	L["Backdrop Style"] = "Hintergrundstil"
	--[[Translation missing --]]
	L["Background Inner"] = "Background Inner"
	L["Background Offset"] = "Hintergrundversatz"
	L["Background Texture"] = "Hintergrundtextur"
	L["Bar Alpha"] = "Balkentransparenz"
	L["Bar Color Settings"] = "Balkenfarbeneinstellungen"
	L["Big Icon"] = "Groes Symbol"
	L["Blend Mode"] = "Mischmodus"
	L["Blue Rune"] = "Blaue Rune"
	L["Blue Sparkle Orb"] = "Blau funkelnde Kugel"
	L["Border %s"] = "Rahmen %s"
	--[[Translation missing --]]
	L["Border Anchor"] = "Border Anchor"
	L["Border Color"] = "Randfarbe"
	--[[Translation missing --]]
	L["Border in Front"] = "Border in Front"
	L["Border Inset"] = "Rahmeneinlassung"
	L["Border Offset"] = "Randversatz"
	L["Border Settings"] = "Rahmeneinstellungen"
	L["Border Size"] = "Rahmengre"
	L["Border Style"] = "Rahmenstil"
	--[[Translation missing --]]
	L["Bracket Matching"] = "Bracket Matching"
	--[[Translation missing --]]
	L["Browse Wago, the largest collection of auras."] = "Browse Wago, the largest collection of auras."
	--[[Translation missing --]]
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."
	--[[Translation missing --]]
	L["Can be a UID (e.g., party1)."] = "Can be a UID (e.g., party1)."
	--[[Translation missing --]]
	L["Can set to 0 if Columns * Width equal File Width"] = "Can set to 0 if Columns * Width equal File Width"
	--[[Translation missing --]]
	L["Can set to 0 if Rows * Height equal File Height"] = "Can set to 0 if Rows * Height equal File Height"
	--[[Translation missing --]]
	L["Case Insensitive"] = "Case Insensitive"
	--[[Translation missing --]]
	L["Cast by a Player Character"] = "Cast by a Player Character"
	--[[Translation missing --]]
	L["Categories to Update"] = "Categories to Update"
	--[[Translation missing --]]
	L["Changelog"] = "Changelog"
	--[[Translation missing --]]
	L["Chat with WeakAuras experts on our Discord server."] = "Chat with WeakAuras experts on our Discord server."
	L["Check On..."] = "Prfen auf..."
	--[[Translation missing --]]
	L["Check out our wiki for a large collection of examples and snippets."] = "Check out our wiki for a large collection of examples and snippets."
	L["Children:"] = "Kinder:"
	L["Choose"] = "Auswhlen"
	--[[Translation missing --]]
	L["Circular Texture %s"] = "Circular Texture %s"
	--[[Translation missing --]]
	L["Clear Debug Logs"] = "Clear Debug Logs"
	--[[Translation missing --]]
	L["Clear Saved Data"] = "Clear Saved Data"
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	--[[Translation missing --]]
	L["Clip Overlays"] = "Clip Overlays"
	--[[Translation missing --]]
	L["Clipped by Foreground"] = "Clipped by Foreground"
	L["Close"] = "Schlieen"
	--[[Translation missing --]]
	L["Code Editor"] = "Code Editor"
	L["Collapse"] = "Minimieren"
	L["Collapse all loaded displays"] = "Alle geladenen Anzeigen minimieren"
	L["Collapse all non-loaded displays"] = "Alle nicht geladenen Anzeigen minimieren"
	--[[Translation missing --]]
	L["Collapse all pending Import"] = "Collapse all pending Import"
	--[[Translation missing --]]
	L["Collapsible Group"] = "Collapsible Group"
	L["color"] = "Farbe"
	L["Column Height"] = "Spaltenhhe"
	L["Column Space"] = "Spaltenabstand"
	--[[Translation missing --]]
	L["Columns"] = "Columns"
	--[[Translation missing --]]
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."
	L["Combinations"] = "Kombinationen"
	--[[Translation missing --]]
	L["Combine Matches Per Unit"] = "Combine Matches Per Unit"
	--[[Translation missing --]]
	L["Common Text"] = "Common Text"
	--[[Translation missing --]]
	L["Compare against the number of units affected."] = "Compare against the number of units affected."
	--[[Translation missing --]]
	L["Compatibility Options"] = "Compatibility Options"
	L["Compress"] = "Stauchen"
	--[[Translation missing --]]
	L["Configure what options appear on this panel."] = "Configure what options appear on this panel."
	L["Constant Factor"] = "Konstanter Faktor"
	L["Control-click to select multiple displays"] = "Strg-Klick, um mehrere Anzeigen auszuwhlen"
	L["Controls the positioning and configuration of multiple displays at the same time"] = "Eine Gruppe, die die Position und Konfiguration ihrer Kinder kontrolliert"
	L["Convert to..."] = "Konvertieren zu..."
	--[[Translation missing --]]
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "Cooldown Numbers might be added by WoW. You can configure these in the game settings."
	L["Copy"] = "Kopieren"
	L["Copy settings..."] = "Einstellungen kopieren..."
	L["Copy to all auras"] = "Kopiere zu allen Auren"
	--[[Translation missing --]]
	L["Could not parse '%s'. Expected a table."] = "Could not parse '%s'. Expected a table."
	--[[Translation missing --]]
	L["Counts the number of matches over all units."] = "Counts the number of matches over all units."
	--[[Translation missing --]]
	L["Counts the number of matches per unit."] = "Counts the number of matches per unit."
	--[[Translation missing --]]
	L["Create a Copy"] = "Create a Copy"
	L["Creating buttons: "] = "Erstelle Schaltflchen:"
	L["Creating options: "] = "Erstelle Optionen:"
	--[[Translation missing --]]
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."
	L["Custom Code"] = "Benutzerdefinierter Code"
	--[[Translation missing --]]
	L["Custom Code Viewer"] = "Custom Code Viewer"
	--[[Translation missing --]]
	L["Custom Frames"] = "Custom Frames"
	--[[Translation missing --]]
	L["Custom Functions"] = "Custom Functions"
	--[[Translation missing --]]
	L["Custom Init"] = "Custom Init"
	--[[Translation missing --]]
	L["Custom Load"] = "Custom Load"
	--[[Translation missing --]]
	L["Custom Options"] = "Custom Options"
	--[[Translation missing --]]
	L["Custom Text Update Throttle"] = "Custom Text Update Throttle"
	L["Custom Trigger"] = "Benutzerdefinierter Auslser"
	L["Custom trigger event tooltip"] = [=[Whle die Ereignisse, die den benutzerdefinierten Auslser aufrufen sollen.
Mehrere Ereignisse knnen durch Komma oder Leerzeichen getrennt werden.

|cFF4444FFBeispiel:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED]=]
	L["Custom trigger status tooltip"] = [=[Whle die Events, die den benutzerdefinierten Auslser aufrufen sollen.
Da es sich um einen Zustands-Auslser handelt, kann es passieren, dass WeakAuras nicht die in der WoW-API spezifizierten Argumente bergibt.
Mehrere Events knnen durch Komma oder Leerzeichen getrennt werden.

|cFF4444FFBeispiel:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED]=]
	--[[Translation missing --]]
	L["Custom trigger Update Throttle"] = "Custom trigger Update Throttle"
	--[[Translation missing --]]
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "Custom Trigger: Ignore Lua Errors on OPTIONS event"
	--[[Translation missing --]]
	L["Custom Trigger: Send fake events instead of STATUS event"] = "Custom Trigger: Send fake events instead of STATUS event"
	--[[Translation missing --]]
	L["Custom Unload"] = "Custom Unload"
	L["Custom Untrigger"] = "Benutzerdefinierter Umkehrauslser"
	--[[Translation missing --]]
	L["Debug Log"] = "Debug Log"
	--[[Translation missing --]]
	L["Debug Log:"] = "Debug Log:"
	L["Default"] = "Standard"
	L["Default Color"] = "Standardfarbe"
	L["Delay"] = "Verzgerung"
	L["Delete"] = "Lschen"
	L["Delete all"] = "Alle lschen"
	L["Delete children and group"] = "Kinder und Gruppe lschen"
	L["Delete Entry"] = "Eintrag lschen"
	--[[Translation missing --]]
	L["Deleting auras: "] = "Deleting auras: "
	L["Description Text"] = "Beschreibungstext"
	--[[Translation missing --]]
	L["Determines how many entries can be in the table."] = "Determines how many entries can be in the table."
	L["Differences"] = "Unterschiede"
	--[[Translation missing --]]
	L["Disallow Entry Reordering"] = "Disallow Entry Reordering"
	--[[Translation missing --]]
	L["Discord"] = "Discord"
	L["Display Name"] = "Anzeigename"
	L["Display Text"] = "Anzeigetext"
	L["Displays a text, works best in combination with other displays"] = "Zeigt einen Text an, funktioniert am besten in Kombination mit anderen Anzeigen"
	L["Distribute Horizontally"] = "Horizontal verteilen"
	L["Distribute Vertically"] = "Vertikal verteilen"
	L["Do not group this display"] = "Diese Anzeige nicht kopieren"
	--[[Translation missing --]]
	L["Do you want to enable updates for this aura"] = "Do you want to enable updates for this aura"
	--[[Translation missing --]]
	L["Do you want to ignore updates for this aura"] = "Do you want to ignore updates for this aura"
	L["Documentation"] = "Dokumentation"
	L["Done"] = "Fertig"
	L["Drag to move"] = "Ziehen, um diese Anzeige zu verschieben"
	L["Duplicate"] = "Duplizieren"
	L["Duplicate All"] = "Alle duplizieren"
	L["Duration (s)"] = "Dauer (s)"
	L["Duration Info"] = "Dauerinformationen"
	--[[Translation missing --]]
	L["Dynamic Duration"] = "Dynamic Duration"
	L["Dynamic Group"] = "Dynamische Gruppe"
	--[[Translation missing --]]
	L["Dynamic Group Settings"] = "Dynamic Group Settings"
	L["Dynamic Information"] = "Dynamische Information"
	L["Dynamic information from first active trigger"] = "Dynamische Information vom ersten aktiven Auslser"
	L["Dynamic information from Trigger %i"] = "Dynamische Information des %i. Auslsers"
	--[[Translation missing --]]
	L["Dynamic Text Replacements"] = "Dynamic Text Replacements"
	--[[Translation missing --]]
	L["Ease Strength"] = "Ease Strength"
	--[[Translation missing --]]
	L["Ease type"] = "Ease type"
	--[[Translation missing --]]
	L["eliding"] = "eliding"
	--[[Translation missing --]]
	L["Else If"] = "Else If"
	--[[Translation missing --]]
	L["Else If %s"] = "Else If %s"
	--[[Translation missing --]]
	L["Empty Base Region"] = "Empty Base Region"
	--[[Translation missing --]]
	L["Enable \"Edge\" part of the overlay"] = "Enable \"Edge\" part of the overlay"
	--[[Translation missing --]]
	L["Enable \"swipe\" part of the overlay"] = "Enable \"swipe\" part of the overlay"
	--[[Translation missing --]]
	L["Enable Debug Log"] = "Enable Debug Log"
	--[[Translation missing --]]
	L["Enable Debug Logging"] = "Enable Debug Logging"
	--[[Translation missing --]]
	L["Enable Gradient"] = "Enable Gradient"
	--[[Translation missing --]]
	L["Enable Swipe"] = "Enable Swipe"
	--[[Translation missing --]]
	L["Enable the \"Swipe\" radial overlay"] = "Enable the \"Swipe\" radial overlay"
	L["Enabled"] = "Aktivieren"
	L["End Angle"] = "Endewinkel"
	--[[Translation missing --]]
	L["End of %s"] = "End of %s"
	--[[Translation missing --]]
	L["Enemy nameplate(s) found"] = "Enemy nameplate(s) found"
	--[[Translation missing --]]
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "Enter a Spell ID. You can use the addon idTip to determine spell ids."
	--[[Translation missing --]]
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = "Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."
	--[[Translation missing --]]
	L["Enter Author Mode"] = "Enter Author Mode"
	--[[Translation missing --]]
	L["Enter in a value for the tick's placement."] = "Enter in a value for the tick's placement."
	--[[Translation missing --]]
	L["Enter static or relative values with %"] = "Enter static or relative values with %"
	--[[Translation missing --]]
	L["Enter User Mode"] = "Enter User Mode"
	--[[Translation missing --]]
	L["Enter user mode."] = "Enter user mode."
	L["Entry %i"] = "Eintrag %i"
	L["Entry limit"] = "Eintragsgrenze"
	L["Entry Name Source"] = "Eintragsnamensquelle"
	L["Event Type"] = "Ereignistyp"
	L["Everything"] = "Alles"
	--[[Translation missing --]]
	L["Exact Item Match"] = "Exact Item Match"
	L["Exact Spell Match"] = "Exakte Zauberbereinstimmung"
	L["Expand"] = "Erweitern"
	L["Expand all loaded displays"] = "Alle geladenen Anzeigen erweitern"
	L["Expand all non-loaded displays"] = "Alle nicht geladenen Anzeigen erweitern"
	--[[Translation missing --]]
	L["Expand all pending Import"] = "Expand all pending Import"
	L["Expansion is disabled because this group has no children"] = "Erweiterung deaktiviert, da diese Gruppe keine Kinder hat"
	--[[Translation missing --]]
	L["Export debug table..."] = "Export debug table..."
	--[[Translation missing --]]
	L["Export..."] = "Export..."
	--[[Translation missing --]]
	L["Exporting"] = "Exporting"
	L["External"] = "Extern"
	--[[Translation missing --]]
	L["Extra Height"] = "Extra Height"
	--[[Translation missing --]]
	L["Extra Width"] = "Extra Width"
	L["Fade"] = "Verblassen"
	--[[Translation missing --]]
	L["Fadeout Sound"] = "Fadeout Sound"
	--[[Translation missing --]]
	L["Fadeout Time (seconds)"] = "Fadeout Time (seconds)"
	--[[Translation missing --]]
	L["Fetch Affected/Unaffected Names and Units"] = "Fetch Affected/Unaffected Names and Units"
	--[[Translation missing --]]
	L["Fetch Raid Mark Information"] = "Fetch Raid Mark Information"
	--[[Translation missing --]]
	L["Fetch Role Information"] = "Fetch Role Information"
	--[[Translation missing --]]
	L["Fetch Tooltip Information"] = "Fetch Tooltip Information"
	--[[Translation missing --]]
	L["File Height"] = "File Height"
	--[[Translation missing --]]
	L["File Width"] = "File Width"
	--[[Translation missing --]]
	L["Filter based on the spell Name string."] = "Filter based on the spell Name string."
	--[[Translation missing --]]
	L["Filter by Arena Spec"] = "Filter by Arena Spec"
	L["Filter by Class"] = "Nach Klasse filtern"
	L["Filter by Group Role"] = "Nach Gruppenrolle filtern"
	--[[Translation missing --]]
	L["Filter by Hostility"] = "Filter by Hostility"
	--[[Translation missing --]]
	L["Filter by Npc ID"] = "Filter by Npc ID"
	L["Filter by Raid Role"] = "Filter nach Schlachtzugsrollen"
	--[[Translation missing --]]
	L["Filter by Specialization"] = "Filter by Specialization"
	--[[Translation missing --]]
	L["Filter by Unit Name"] = "Filter by Unit Name"
	--[[Translation missing --]]
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
	--[[Translation missing --]]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=]
	L["Find Auras"] = "Finde Auren"
	L["Finish"] = "Endanimation"
	--[[Translation missing --]]
	L["Finishing..."] = "Finishing..."
	L["Fire Orb"] = "Feuerkugel"
	--[[Translation missing --]]
	L["Flat Framelevels"] = "Flat Framelevels"
	L["Foreground Texture"] = "Vordergrundtextur"
	--[[Translation missing --]]
	L["Format for %s"] = "Format for %s"
	--[[Translation missing --]]
	L["Found a Bug?"] = "Found a Bug?"
	L["Frame"] = "Frame"
	--[[Translation missing --]]
	L["Frame Count"] = "Frame Count"
	--[[Translation missing --]]
	L["Frame Height"] = "Frame Height"
	--[[Translation missing --]]
	L["Frame Rate"] = "Frame Rate"
	L["Frame Strata"] = "Frame-Schicht"
	--[[Translation missing --]]
	L["Frame Width"] = "Frame Width"
	--[[Translation missing --]]
	L["Full Bar"] = "Full Bar"
	--[[Translation missing --]]
	L["Full Circle"] = "Full Circle"
	L["Global Conditions"] = "Globale Bedingungen"
	L["Glow %s"] = "Leuchten %s"
	L["Glow Action"] = "Leuchtaktion"
	--[[Translation missing --]]
	L["Glow Anchor"] = "Glow Anchor"
	L["Glow Color"] = "Leuchtfarbe"
	--[[Translation missing --]]
	L["Glow Frame Type"] = "Glow Frame Type"
	L["Glow Type"] = "Leuchttyp"
	L["Green Rune"] = "Grne Rune"
	--[[Translation missing --]]
	L["Grid direction"] = "Grid direction"
	L["Group (verb)"] = "Gruppieren"
	--[[Translation missing --]]
	L["Group Alpha"] = "Group Alpha"
	--[[Translation missing --]]
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=]
	L["Group aura count description"] = [=[Die Anzahl der %s-Mitglieder, die von einer der Auren betroffen sein mssen, um den Trigger auszulsen.
Falls der eingegebene Wert eine ganze Zahl (z.B. 5) ist, wird die Anzahl der betroffenen Gruppenmitglieder damit verglichen.
Falls die Zahl als Dezimalzahl (z.B. 0.5), Bruch (z.B. 1/2) oder Prozentsatz (z.B. 50%%) eingegeben wird, muss dieser Teil der %s betroffen sein.

|cFF4444FBeispiel:|r
|cFF00CC00> 0|r Lst aus, wenn irgendjemand in der %s betroffen ist.
|cFF00CC00= 100%%|r Lst aus, wenn alle in der %s betroffen sind.
|cFF00CC00!= 2|r Lst aus, wenn weniger oder mehr als 2 Spieler in der %s betroffen sind.
|cFF00CC00<= 0.8|r Lst aus, wenn weniger als 80%% in der %s betroffen sind (4 von 5 Gruppenmitgliedern, 8 von 10 oder 20 von 25 Schlachtzugsmitgliedern).
|cFF00CC00> 1/2|r Lst aus, wenn mehr als die Hlfte der %s betroffen sind.
|cFF00CC00>= 0|r Lst immer aus.]=]
	--[[Translation missing --]]
	L["Group by Frame"] = "Group by Frame"
	--[[Translation missing --]]
	L["Group Description"] = "Group Description"
	L["Group Icon"] = "Gruppensymbol"
	L["Group key"] = "Gruppenschlssel"
	--[[Translation missing --]]
	L["Group Options"] = "Group Options"
	--[[Translation missing --]]
	L["Group player(s) found"] = "Group player(s) found"
	L["Group Role"] = "Gruppenrolle"
	L["Group Scale"] = "Gruppenskalierung"
	--[[Translation missing --]]
	L["Group Settings"] = "Group Settings"
	L["Hawk"] = "Falke"
	L["Help"] = "Hilfe"
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	--[[Translation missing --]]
	L["Hide Background"] = "Hide Background"
	--[[Translation missing --]]
	L["Hide Glows applied by this aura"] = "Hide Glows applied by this aura"
	L["Hide on"] = "Verbergen falls"
	L["Hide this group's children"] = "Die Kinder dieser Gruppe ausblenden"
	--[[Translation missing --]]
	L["Highlights"] = "Highlights"
	L["Horizontal Align"] = "Horizontale Ausrichtung"
	L["Horizontal Bar"] = "Horizontaler Balken"
	L["Huge Icon"] = "Riesiges Symbol"
	--[[Translation missing --]]
	L["Hybrid Position"] = "Hybrid Position"
	--[[Translation missing --]]
	L["Hybrid Sort Mode"] = "Hybrid Sort Mode"
	--[[Translation missing --]]
	L["Icon - The icon associated with the display"] = "Icon - The icon associated with the display"
	L["Icon Info"] = "Symbolinfo"
	L["Icon Inset"] = "Symboleinrckung"
	--[[Translation missing --]]
	L["Icon Picker"] = "Icon Picker"
	--[[Translation missing --]]
	L["Icon Position"] = "Icon Position"
	--[[Translation missing --]]
	L["Icon Settings"] = "Icon Settings"
	--[[Translation missing --]]
	L["Icon Source"] = "Icon Source"
	L["If"] = "Falls"
	--[[Translation missing --]]
	L["If %s"] = "If %s"
	--[[Translation missing --]]
	L["If checked, then the combo box in the User settings will be sorted."] = "If checked, then the combo box in the User settings will be sorted."
	--[[Translation missing --]]
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."
	--[[Translation missing --]]
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "If checked, then this group will not merge with other group when selecting multiple auras."
	--[[Translation missing --]]
	L["If checked, then this option group can be temporarily collapsed by the user."] = "If checked, then this option group can be temporarily collapsed by the user."
	--[[Translation missing --]]
	L["If checked, then this option group will start collapsed."] = "If checked, then this option group will start collapsed."
	--[[Translation missing --]]
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "If checked, then this separator will include text. Otherwise, it will be just a horizontal line."
	--[[Translation missing --]]
	L["If checked, then this space will span across multiple lines."] = "If checked, then this space will span across multiple lines."
	--[[Translation missing --]]
	L["If unchecked, then a default color will be used (usually yellow)"] = "If unchecked, then a default color will be used (usually yellow)"
	--[[Translation missing --]]
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "If unchecked, then this space will fill the entire line it is on in User Mode."
	--[[Translation missing --]]
	L["Ignore out of casting range"] = "Ignore out of casting range"
	--[[Translation missing --]]
	L["Ignore out of checking range"] = "Ignore out of checking range"
	--[[Translation missing --]]
	L["Ignore Wago updates"] = "Ignore Wago updates"
	L["Ignored"] = "Ignoriert"
	--[[Translation missing --]]
	L["Ignored Aura Name"] = "Ignored Aura Name"
	--[[Translation missing --]]
	L["Ignored Exact Spell ID(s)"] = "Ignored Exact Spell ID(s)"
	--[[Translation missing --]]
	L["Ignored Name(s)"] = "Ignored Name(s)"
	--[[Translation missing --]]
	L["Ignored Spell ID"] = "Ignored Spell ID"
	L["Import"] = "Importieren"
	--[[Translation missing --]]
	L["Import / Export"] = "Import / Export"
	L["Import a display from an encoded string"] = "Anzeige von Klartext importieren"
	--[[Translation missing --]]
	L["Import as Copy"] = "Import as Copy"
	--[[Translation missing --]]
	L["Import has no UID, cannot be matched to existing auras."] = "Import has no UID, cannot be matched to existing auras."
	--[[Translation missing --]]
	L["Importing"] = "Importing"
	--[[Translation missing --]]
	L["Importing %s"] = "Importing %s"
	--[[Translation missing --]]
	L["Importing a group with %s child auras."] = "Importing a group with %s child auras."
	--[[Translation missing --]]
	L["Importing a stand-alone aura."] = "Importing a stand-alone aura."
	--[[Translation missing --]]
	L["Importing...."] = "Importing...."
	--[[Translation missing --]]
	L["Incompatible changes to group region types detected"] = "Incompatible changes to group region types detected"
	--[[Translation missing --]]
	L["Incompatible changes to group structure detected"] = "Incompatible changes to group structure detected"
	--[[Translation missing --]]
	L["Indent Size"] = "Indent Size"
	--[[Translation missing --]]
	L["Inner"] = "Inner"
	--[[Translation missing --]]
	L["Insert text replacement codes to make text dynamic."] = "Insert text replacement codes to make text dynamic."
	--[[Translation missing --]]
	L["Invalid Item ID"] = "Invalid Item ID"
	L["Invalid Item Name/ID/Link"] = "Ungltige(r) Gegenstandsname/-ID/-link"
	L["Invalid Spell ID"] = "Ungltige Zauber-ID"
	L["Invalid Spell Name/ID/Link"] = "Ungltige(r) Zaubername/-ID/-link"
	--[[Translation missing --]]
	L["Invalid target aura"] = "Invalid target aura"
	--[[Translation missing --]]
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."
	--[[Translation missing --]]
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "Invalid type for property '%s' in '%s'. Expected '%s'"
	--[[Translation missing --]]
	L["Inverse Slant"] = "Inverse Slant"
	--[[Translation missing --]]
	L["Invert the direction of progress"] = "Invert the direction of progress"
	--[[Translation missing --]]
	L["Is Boss Debuff"] = "Is Boss Debuff"
	L["Is Stealable"] = "Ist stehlbar"
	--[[Translation missing --]]
	L["Is Unit"] = "Is Unit"
	L["Justify"] = "Ausrichten"
	--[[Translation missing --]]
	L["Keep Aspect Ratio"] = "Keep Aspect Ratio"
	--[[Translation missing --]]
	L["Keep your Wago imports up to date with the Companion App."] = "Keep your Wago imports up to date with the Companion App."
	--[[Translation missing --]]
	L["Large Input"] = "Large Input"
	L["Leaf"] = "Blatt"
	--[[Translation missing --]]
	L["Left 2 HUD position"] = "Left 2 HUD position"
	L["Left HUD position"] = "Linke HUD Position"
	--[[Translation missing --]]
	L["Length of |cFFFF0000%s|r"] = "Length of |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	--[[Translation missing --]]
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	--[[Translation missing --]]
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	--[[Translation missing --]]
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	--[[Translation missing --]]
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	--[[Translation missing --]]
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = "Limit"
	--[[Translation missing --]]
	L["Line"] = "Line"
	--[[Translation missing --]]
	L["Linear Texture %s"] = "Linear Texture %s"
	--[[Translation missing --]]
	L["Linked aura: "] = "Linked aura: "
	--[[Translation missing --]]
	L["Linked Auras"] = "Linked Auras"
	L["Load"] = "Laden"
	L["Loaded"] = "Geladen"
	--[[Translation missing --]]
	L["Loaded/Standby"] = "Loaded/Standby"
	--[[Translation missing --]]
	L["Lock Positions"] = "Lock Positions"
	L["Low Mana"] = "Niedriges Mana"
	--[[Translation missing --]]
	L["Magnetically Align"] = "Magnetically Align"
	L["Main"] = "Hauptanimation"
	--[[Translation missing --]]
	L["Manual with %i/%i"] = "Manual with %i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	--[[Translation missing --]]
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "Matches the height setting of a horizontal bar or width for a vertical bar."
	L["Max"] = "Max"
	--[[Translation missing --]]
	L["Max Length"] = "Max Length"
	--[[Translation missing --]]
	L["Maximum"] = "Maximum"
	--[[Translation missing --]]
	L["Media Type"] = "Media Type"
	L["Medium Icon"] = "Mittelgroes Symbol"
	--[[Translation missing --]]
	L["Min"] = "Min"
	--[[Translation missing --]]
	L["Minimum"] = "Minimum"
	--[[Translation missing --]]
	L["Model %s"] = "Model %s"
	--[[Translation missing --]]
	L["Model Picker"] = "Model Picker"
	--[[Translation missing --]]
	L["Model Settings"] = "Model Settings"
	--[[Translation missing --]]
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths could not be loaded, the addon is %s"
	L["Move Above Group"] = "ber die Gruppe verschieben"
	L["Move Below Group"] = "Unter die Gruppe verschieben"
	L["Move Down"] = "Nach unten verschieben"
	L["Move Entry Down"] = "Eintrag nach unten verschieben"
	L["Move Entry Up"] = "Eintrag nach oben verschieben"
	--[[Translation missing --]]
	L["Move Into Above Group"] = "Move Into Above Group"
	--[[Translation missing --]]
	L["Move Into Below Group"] = "Move Into Below Group"
	L["Move this display down in its group's order"] = "Verschiebt diese Anzeige in der Reihenfolge seiner Gruppe nach unten"
	L["Move this display up in its group's order"] = "Verschiebt diese Anzeige in der Reihenfolge seiner Gruppe nach oben"
	L["Move Up"] = "Nach oben verschieben"
	--[[Translation missing --]]
	L["Moving auras: "] = "Moving auras: "
	L["Multiple Displays"] = "Mehrere Anzeigen"
	L["Multiselect ignored tooltip"] = [=[
|cFFFF0000Ignoriert|r - |cFF777777Einfach|r - |cFF777777Mehrfach|r
Diese Option wird nicht verwendet, um zu prfen, wann die Anzeige geladen wird.]=]
	L["Multiselect multiple tooltip"] = [=[
|cFFFF0000Ignoriert|r - |cFF777777Einfach|r - |cFF777777Mehrfach|r
Beliebige Anzahl an Werten zum Vergleichen knnen ausgewhlt werden.]=]
	L["Multiselect single tooltip"] = [=[
|cFFFF0000Ignoriert|r - |cFF777777Einfach|r - |cFF777777Mehrfach|r
Nur ein Wert kann ausgewhlt werden.]=]
	--[[Translation missing --]]
	L["Must be a power of 2"] = "Must be a power of 2"
	--[[Translation missing --]]
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"
	L["Name Info"] = "Namensinfo"
	--[[Translation missing --]]
	L["Name Pattern Match"] = "Name Pattern Match"
	--[[Translation missing --]]
	L["Name:"] = "Name:"
	L["Negator"] = "Nicht"
	L["New Aura"] = "Neue Aura"
	--[[Translation missing --]]
	L["New Template"] = "New Template"
	L["New Value"] = "Neuer Wert"
	L["No Children"] = "Keine Kinder"
	--[[Translation missing --]]
	L["No Logs saved."] = "No Logs saved."
	--[[Translation missing --]]
	L["Not a table"] = "Not a table"
	L["Not all children have the same value for this option"] = "Nicht alle Kinder besitzen denselben Wert"
	L["Not Loaded"] = "Nicht geladen"
	--[[Translation missing --]]
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "Note: Automated Messages to SAY and YELL are blocked outside of Instances."
	--[[Translation missing --]]
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""
	--[[Translation missing --]]
	L["Number of Entries"] = "Number of Entries"
	--[[Translation missing --]]
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=]
	--[[Translation missing --]]
	L["OFF"] = "OFF"
	--[[Translation missing --]]
	L["Offer a guided way to create auras for your character"] = "Offer a guided way to create auras for your character"
	--[[Translation missing --]]
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"
	--[[Translation missing --]]
	L["Offset by 1px"] = "Offset by 1px"
	L["Okay"] = "Okey"
	--[[Translation missing --]]
	L["ON"] = "ON"
	L["On Hide"] = "Beim Ausblenden"
	L["On Show"] = "Beim Einblenden"
	--[[Translation missing --]]
	L["Only Match auras cast by a player (not an npc)"] = "Only Match auras cast by a player (not an npc)"
	--[[Translation missing --]]
	L["Only match auras cast by people other than the player or their pet"] = "Only match auras cast by people other than the player or their pet"
	--[[Translation missing --]]
	L["Only match auras cast by the player or their pet"] = "Only match auras cast by the player or their pet"
	L["Operator"] = "Operator"
	--[[Translation missing --]]
	L["Option %i"] = "Option %i"
	--[[Translation missing --]]
	L["Option key"] = "Option key"
	--[[Translation missing --]]
	L["Option Type"] = "Option Type"
	--[[Translation missing --]]
	L["Options will open after combat ends."] = "Options will open after combat ends."
	L["or"] = "oder"
	--[[Translation missing --]]
	L["or %s"] = "or %s"
	L["Orange Rune"] = "Orange Rune"
	--[[Translation missing --]]
	L["Our translators (too many to name)"] = "Our translators (too many to name)"
	--[[Translation missing --]]
	L["Outer"] = "Outer"
	--[[Translation missing --]]
	L["Overflow"] = "Overflow"
	--[[Translation missing --]]
	L["Overlay %s Info"] = "Overlay %s Info"
	--[[Translation missing --]]
	L["Overlays"] = "Overlays"
	L["Own Only"] = "Nur eigene"
	--[[Translation missing --]]
	L["Paste Action Settings"] = "Paste Action Settings"
	--[[Translation missing --]]
	L["Paste Animations Settings"] = "Paste Animations Settings"
	--[[Translation missing --]]
	L["Paste Author Options Settings"] = "Paste Author Options Settings"
	--[[Translation missing --]]
	L["Paste Condition Settings"] = "Paste Condition Settings"
	--[[Translation missing --]]
	L["Paste Custom Configuration"] = "Paste Custom Configuration"
	--[[Translation missing --]]
	L["Paste Display Settings"] = "Paste Display Settings"
	--[[Translation missing --]]
	L["Paste Group Settings"] = "Paste Group Settings"
	--[[Translation missing --]]
	L["Paste Load Settings"] = "Paste Load Settings"
	--[[Translation missing --]]
	L["Paste Settings"] = "Paste Settings"
	L["Paste text below"] = "Text unten einfgen"
	--[[Translation missing --]]
	L["Paste Trigger Settings"] = "Paste Trigger Settings"
	--[[Translation missing --]]
	L["Places a tick on the bar"] = "Places a tick on the bar"
	L["Play Sound"] = "Sound abspielen"
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	L["Portrait Zoom"] = "Portraitzoom"
	--[[Translation missing --]]
	L["Position and Size Settings"] = "Position and Size Settings"
	--[[Translation missing --]]
	L["Preferred Match"] = "Preferred Match"
	--[[Translation missing --]]
	L["Premade Auras"] = "Premade Auras"
	--[[Translation missing --]]
	L["Premade Snippets"] = "Premade Snippets"
	--[[Translation missing --]]
	L["Preparing auras: "] = "Preparing auras: "
	L["Press Ctrl+C to copy"] = "Drcke Strg+C zum kopieren"
	--[[Translation missing --]]
	L["Press Ctrl+C to copy the URL"] = "Press Ctrl+C to copy the URL"
	--[[Translation missing --]]
	L["Prevent Merging"] = "Prevent Merging"
	--[[Translation missing --]]
	L["Progress - The remaining time of a timer, or a non-timer value"] = "Progress - The remaining time of a timer, or a non-timer value"
	L["Progress Bar"] = "Fortschrittsbalken"
	--[[Translation missing --]]
	L["Progress Bar Settings"] = "Progress Bar Settings"
	--[[Translation missing --]]
	L["Progress Settings"] = "Progress Settings"
	L["Progress Texture"] = "Fortschrittstextur"
	--[[Translation missing --]]
	L["Progress Texture Settings"] = "Progress Texture Settings"
	L["Purple Rune"] = "Violette Rune"
	L["Put this display in a group"] = "Diese Anzeige in eine Gruppe stecken"
	--[[Translation missing --]]
	L["Range in yards"] = "Range in yards"
	--[[Translation missing --]]
	L["Ready for Install"] = "Ready for Install"
	--[[Translation missing --]]
	L["Ready for Update"] = "Ready for Update"
	L["Re-center X"] = "Zentrum (X)"
	L["Re-center Y"] = "Zentrum (Y)"
	--[[Translation missing --]]
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "Reciprocal TRIGGER:# requests will be ignored!"
	--[[Translation missing --]]
	L["Redo"] = "Redo"
	--[[Translation missing --]]
	L["Regions of type \"%s\" are not supported."] = "Regions of type \"%s\" are not supported."
	L["Remove"] = "Entfernen"
	--[[Translation missing --]]
	L["Remove All Sounds"] = "Remove All Sounds"
	--[[Translation missing --]]
	L["Remove All Text To Speech"] = "Remove All Text To Speech"
	L["Remove this display from its group"] = "Diese Anzeige aus seiner Gruppe entfernen"
	L["Remove this property"] = "Eigenschaft entfernen"
	L["Rename"] = "Umbenennen"
	L["Repeat After"] = "Wiederholen nach"
	L["Repeat every"] = "Wiederhole alle"
	--[[Translation missing --]]
	L["Report bugs on our issue tracker."] = "Report bugs on our issue tracker."
	--[[Translation missing --]]
	L["Require unit from trigger"] = "Require unit from trigger"
	L["Required for Activation"] = "Bentigt zur Aktivierung"
	--[[Translation missing --]]
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"
	--[[Translation missing --]]
	L["Reset all options to their default values."] = "Reset all options to their default values."
	L["Reset Entry"] = "Eintrag zurcksetzen"
	L["Reset to Defaults"] = "Auf Standard zurcksetzen"
	--[[Translation missing --]]
	L["Right 2 HUD position"] = "Right 2 HUD position"
	L["Right HUD position"] = "Rechte HUD Position"
	L["Right-click for more options"] = "|cFF8080FF(Rechtsklick)|r fr mehr Optionen"
	L["Rotate"] = "Rotieren"
	L["Rotate In"] = "Nach innen rotieren"
	L["Rotate Out"] = "Nach auen rotieren"
	L["Rotate Text"] = "Text rotieren"
	L["Rotation Mode"] = "Rotationsmodus"
	L["Row Space"] = "Zeilenabstand"
	L["Row Width"] = "Zeilenbreite"
	--[[Translation missing --]]
	L["Rows"] = "Rows"
	--[[Translation missing --]]
	L["Run on..."] = "Run on..."
	L["Same"] = "Gleich"
	--[[Translation missing --]]
	L["Same texture as Foreground"] = "Same texture as Foreground"
	--[[Translation missing --]]
	L["Saved Data"] = "Saved Data"
	--[[Translation missing --]]
	L["Scale Factor"] = "Scale Factor"
	--[[Translation missing --]]
	L["Search API"] = "Search API"
	--[[Translation missing --]]
	L["Select Talent"] = "Select Talent"
	L["Select the auras you always want to be listed first"] = "Whle die Auren aus, die immer an oberster Stelle angezeigt werden sollen"
	--[[Translation missing --]]
	L["Selected Frame"] = "Selected Frame"
	L["Send To"] = "Senden an"
	--[[Translation missing --]]
	L["Separator Text"] = "Separator Text"
	--[[Translation missing --]]
	L["Separator text"] = "Separator text"
	--[[Translation missing --]]
	L["Set Maximum Progress"] = "Set Maximum Progress"
	--[[Translation missing --]]
	L["Set Minimum Progress"] = "Set Minimum Progress"
	--[[Translation missing --]]
	L["Set Parent to Anchor"] = "Set Parent to Anchor"
	--[[Translation missing --]]
	L["Set Thumbnail Icon"] = "Set Thumbnail Icon"
	--[[Translation missing --]]
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."
	L["Settings"] = "Einstellungen"
	L["Shadow Color"] = "Schattenfarbe"
	--[[Translation missing --]]
	L["Shadow X Offset"] = "Shadow X Offset"
	--[[Translation missing --]]
	L["Shadow Y Offset"] = "Shadow Y Offset"
	L["Shift-click to create chat link"] = "Shift-Klick, um einen Chatlink zu erstellen"
	--[[Translation missing --]]
	L["Show \"Edge\""] = "Show \"Edge\""
	--[[Translation missing --]]
	L["Show \"Swipe\""] = "Show \"Swipe\""
	--[[Translation missing --]]
	L["Show and Clone Settings"] = "Show and Clone Settings"
	L["Show Border"] = "Rahmen anzeigen"
	--[[Translation missing --]]
	L["Show Circular Texture"] = "Show Circular Texture"
	--[[Translation missing --]]
	L["Show Debug Logs"] = "Show Debug Logs"
	L["Show Glow"] = "Leuchten anzeigen"
	L["Show Icon"] = "Symbol anzeigen"
	--[[Translation missing --]]
	L["Show If Unit Does Not Exist"] = "Show If Unit Does Not Exist"
	--[[Translation missing --]]
	L["Show Linear Texture"] = "Show Linear Texture"
	--[[Translation missing --]]
	L["Show Matches for"] = "Show Matches for"
	--[[Translation missing --]]
	L["Show Matches for Units"] = "Show Matches for Units"
	--[[Translation missing --]]
	L["Show Model"] = "Show Model"
	L["Show model of unit "] = "Modell der Einheit zeigen"
	--[[Translation missing --]]
	L["Show Sound Setting"] = "Show Sound Setting"
	--[[Translation missing --]]
	L["Show Spark"] = "Show Spark"
	--[[Translation missing --]]
	L["Show Stop Motion"] = "Show Stop Motion"
	--[[Translation missing --]]
	L["Show Text"] = "Show Text"
	--[[Translation missing --]]
	L["Show Text To Speech Setting"] = "Show Text To Speech Setting"
	--[[Translation missing --]]
	L["Show Texture"] = "Show Texture"
	L["Show this group's children"] = "Die Kinder dieser Gruppe anzeigen"
	--[[Translation missing --]]
	L["Show Tick"] = "Show Tick"
	L["Shows a 3D model from the game files"] = "Zeigt ein 3D-Modell aus den Spieldateien"
	--[[Translation missing --]]
	L["Shows a border"] = "Shows a border"
	--[[Translation missing --]]
	L["Shows a Circular Progress Texture"] = "Shows a Circular Progress Texture"
	L["Shows a custom texture"] = "Zeigt eine benutzerdefinierte Textur"
	--[[Translation missing --]]
	L["Shows a glow"] = "Shows a glow"
	--[[Translation missing --]]
	L["Shows a Linear Progress Texture"] = "Shows a Linear Progress Texture"
	--[[Translation missing --]]
	L["Shows a model"] = "Shows a model"
	L["Shows a progress bar with name, timer, and icon"] = "Zeigt einen Fortschrittsbalken mit Name, Zeitanzeige und Symbol"
	L["Shows a spell icon with an optional cooldown overlay"] = "Zeigt ein Zaubersymbol mit optionaler Abklingzeit-Anzeige."
	--[[Translation missing --]]
	L["Shows a Stop Motion"] = "Shows a Stop Motion"
	--[[Translation missing --]]
	L["Shows a stop motion texture"] = "Shows a stop motion texture"
	--[[Translation missing --]]
	L["Shows a Texture"] = "Shows a Texture"
	L["Shows a texture that changes based on duration"] = "Zeigt eine Textur, die sich ber die Zeit verndert"
	--[[Translation missing --]]
	L["Shows nothing, except sub elements"] = "Shows nothing, except sub elements"
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Zeigt ein oder mehrere Zeilen Text an, der dynamische Informationen anzeigen kann, z.B. Fortschritt oder Stapel"
	L["Size"] = "Gre"
	--[[Translation missing --]]
	L["Slant Amount"] = "Slant Amount"
	--[[Translation missing --]]
	L["Slant Mode"] = "Slant Mode"
	--[[Translation missing --]]
	L["Slanted"] = "Slanted"
	L["Slide"] = "Gleiten"
	L["Slide In"] = "Einschieben"
	L["Slide Out"] = "Ausschieben"
	--[[Translation missing --]]
	L["Slider Step Size"] = "Slider Step Size"
	L["Small Icon"] = "Kleines Symbol"
	--[[Translation missing --]]
	L["Smooth Progress"] = "Smooth Progress"
	--[[Translation missing --]]
	L["Snippets"] = "Snippets"
	--[[Translation missing --]]
	L["Soft Max"] = "Soft Max"
	--[[Translation missing --]]
	L["Soft Min"] = "Soft Min"
	L["Sort"] = "Sortieren"
	L["Sound Channel"] = "Soundkanal"
	L["Sound File Path"] = "Sound Dateipfad"
	L["Sound Kit ID"] = "Sound Kit ID"
	L["Space Horizontally"] = "Horizontaler Abstand"
	L["Space Vertically"] = "Vertikaler Abstand"
	L["Spark Settings"] = "Funkeneinstellungen"
	L["Spark Texture"] = "Funkentextur"
	--[[Translation missing --]]
	L["Specific Currency ID"] = "Specific Currency ID"
	--[[Translation missing --]]
	L["Spell Selection Filters"] = "Spell Selection Filters"
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = "Stapelinfo"
	--[[Translation missing --]]
	L["Stacks - The number of stacks of an aura (usually)"] = "Stacks - The number of stacks of an aura (usually)"
	--[[Translation missing --]]
	L["Standby"] = "Standby"
	L["Star"] = "Stern"
	L["Start"] = "Start"
	L["Start Angle"] = "Startwinkel"
	--[[Translation missing --]]
	L["Start Collapsed"] = "Start Collapsed"
	--[[Translation missing --]]
	L["Start of %s"] = "Start of %s"
	L["Step Size"] = "Schrittgre"
	--[[Translation missing --]]
	L["Stop Motion %s"] = "Stop Motion %s"
	--[[Translation missing --]]
	L["Stop Motion Settings"] = "Stop Motion Settings"
	L["Stop Sound"] = "Sound stoppen"
	--[[Translation missing --]]
	L["Stretched by Foreground"] = "Stretched by Foreground"
	--[[Translation missing --]]
	L["Sub Elements"] = "Sub Elements"
	--[[Translation missing --]]
	L["Sub Option %i"] = "Sub Option %i"
	--[[Translation missing --]]
	L["Subevent"] = "Subevent"
	--[[Translation missing --]]
	L["Subevent Suffix"] = "Subevent Suffix"
	--[[Translation missing --]]
	L["Swipe Overlay Settings"] = "Swipe Overlay Settings"
	--[[Translation missing --]]
	L["Templates could not be loaded, the addon is %s"] = "Templates could not be loaded, the addon is %s"
	L["Temporary Group"] = "Temporre Gruppe"
	L["Text %s"] = "Text %s"
	L["Text Color"] = "Textfarbe"
	L["Text Settings"] = "Texteinstellungen"
	--[[Translation missing --]]
	L["Texture %s"] = "Texture %s"
	L["Texture Info"] = "Texturinfo"
	--[[Translation missing --]]
	L["Texture Selection Mode"] = "Texture Selection Mode"
	--[[Translation missing --]]
	L["Texture Settings"] = "Texture Settings"
	--[[Translation missing --]]
	L["Texture Wrap"] = "Texture Wrap"
	--[[Translation missing --]]
	L["Texture X Offset"] = "Texture X Offset"
	--[[Translation missing --]]
	L["Texture Y Offset"] = "Texture Y Offset"
	--[[Translation missing --]]
	L["Thanks"] = "Thanks"
	--[[Translation missing --]]
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"
	--[[Translation missing --]]
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"
	L["The duration of the animation in seconds."] = "Die Dauer der Animation in Sekunden."
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = "Die Dauer der Animation in Sekunden. Die Endanimation erscheint erst zum Zeitpunkt des Ausblendens."
	--[[Translation missing --]]
	L["The group and all direct children will share the same base frame level."] = "The group and all direct children will share the same base frame level."
	--[[Translation missing --]]
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."
	L["The type of trigger"] = "Auslsertyp"
	--[[Translation missing --]]
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"
	L["Then "] = "Dann"
	--[[Translation missing --]]
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."
	--[[Translation missing --]]
	L["This adds %raidMark as text replacements."] = "This adds %raidMark as text replacements."
	--[[Translation missing --]]
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."
	--[[Translation missing --]]
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."
	--[[Translation missing --]]
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=]
	--[[Translation missing --]]
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=]
	--[[Translation missing --]]
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=]
	L["This display is currently loaded"] = "Diese Anzeige ist momentan geladen"
	L["This display is not currently loaded"] = "Diese Anzeige ist momentan nicht geladen"
	--[[Translation missing --]]
	L["This display is on standby, it will be loaded when needed."] = "This display is on standby, it will be loaded when needed."
	--[[Translation missing --]]
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."
	--[[Translation missing --]]
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "This is a modified version of your aura, |cff9900FF%s.|r"
	--[[Translation missing --]]
	L["This is a modified version of your group: |cff9900FF%s|r"] = "This is a modified version of your group: |cff9900FF%s|r"
	L["This region of type \"%s\" is not supported."] = "Diese Region des Typs \"%s\" wird nicht untersttzt."
	--[[Translation missing --]]
	L["This setting controls what widget is generated in user mode."] = "This setting controls what widget is generated in user mode."
	--[[Translation missing --]]
	L["Thumbnail Icon"] = "Thumbnail Icon"
	--[[Translation missing --]]
	L["Tick %s"] = "Tick %s"
	--[[Translation missing --]]
	L["Tick Area %s"] = "Tick Area %s"
	--[[Translation missing --]]
	L["Tick Center %s"] = "Tick Center %s"
	--[[Translation missing --]]
	L["Tick Mode"] = "Tick Mode"
	--[[Translation missing --]]
	L["Tick Placement"] = "Tick Placement"
	L["Time in"] = "Zeit in"
	L["Tiny Icon"] = "Winziges Symbol"
	--[[Translation missing --]]
	L["To Frame's"] = "To Frame's"
	--[[Translation missing --]]
	L["To Group's"] = "To Group's"
	--[[Translation missing --]]
	L["To Personal Ressource Display's"] = "To Personal Ressource Display's"
	--[[Translation missing --]]
	L["To Region's"] = "To Region's"
	--[[Translation missing --]]
	L["To Screen's"] = "To Screen's"
	L["Toggle the visibility of all loaded displays"] = "Sichtbarkeit aller geladener Anzeigen umschalten"
	L["Toggle the visibility of all non-loaded displays"] = "Sichtbarkeit aller nicht geladener Anzeigen umschalten"
	L["Toggle the visibility of this display"] = "Die Sichtbarkeit dieser Anzeige umschalten"
	L["Tooltip Content"] = "Tooltip Inhalt"
	L["Tooltip on Mouseover"] = "Tooltip bei Mausberhrung"
	--[[Translation missing --]]
	L["Tooltip Pattern Match"] = "Tooltip Pattern Match"
	L["Tooltip Text"] = "Tooltip Text"
	L["Tooltip Value"] = "Tooltip Wert"
	L["Tooltip Value #"] = "Tooltip Wert #"
	L["Top HUD position"] = "Hchste HUD Position"
	--[[Translation missing --]]
	L["Total"] = "Total"
	--[[Translation missing --]]
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = "Total - The maximum duration of a timer, or a maximum non-timer value"
	--[[Translation missing --]]
	L["Total Angle"] = "Total Angle"
	--[[Translation missing --]]
	L["Total Time"] = "Total Time"
	--[[Translation missing --]]
	L["Trigger %i: %s"] = "Trigger %i: %s"
	--[[Translation missing --]]
	L["Trigger Combination"] = "Trigger Combination"
	--[[Translation missing --]]
	L["Type 'select' for '%s' requires a values member'"] = "Type 'select' for '%s' requires a values member'"
	--[[Translation missing --]]
	L["Undo"] = "Undo"
	L["Ungroup"] = "Gruppierung aufheben"
	--[[Translation missing --]]
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "Unit %s is not a valid unit for RegisterUnitEvent"
	--[[Translation missing --]]
	L["Unit Count"] = "Unit Count"
	--[[Translation missing --]]
	L["Unknown"] = "Unknown"
	--[[Translation missing --]]
	L["Unknown Encounter's Spell Id"] = "Unknown Encounter's Spell Id"
	--[[Translation missing --]]
	L["Unknown property '%s' found in '%s'"] = "Unknown property '%s' found in '%s'"
	--[[Translation missing --]]
	L["Unknown Spell"] = "Unknown Spell"
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Anders als die Start- und Endanimation wird die Hauptanimation immer wieder wiederholt, bis die Anzeige in den Endstatus versetzt wird."
	--[[Translation missing --]]
	L["Update"] = "Update"
	--[[Translation missing --]]
	L["Update Auras"] = "Update Auras"
	L["Update Custom Text On..."] = "Aktualisiere benutzerdefinierten Text bei..."
	--[[Translation missing --]]
	L["URL"] = "URL"
	--[[Translation missing --]]
	L["Url: %s"] = "Url: %s"
	--[[Translation missing --]]
	L["Use Display Info Id"] = "Use Display Info Id"
	--[[Translation missing --]]
	L["Use SetTransform"] = "Use SetTransform"
	--[[Translation missing --]]
	L["Used in Auras:"] = "Used in Auras:"
	--[[Translation missing --]]
	L["Used in auras:"] = "Used in auras:"
	--[[Translation missing --]]
	L["Uses Texture Coordinates to rotate the texture."] = "Uses Texture Coordinates to rotate the texture."
	--[[Translation missing --]]
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."
	--[[Translation missing --]]
	L["Value"] = "Value"
	--[[Translation missing --]]
	L["Value %i"] = "Value %i"
	--[[Translation missing --]]
	L["Values are in normalized rgba format."] = "Values are in normalized rgba format."
	--[[Translation missing --]]
	L["Values/Remaining Time above this value are displayed as full progress."] = "Values/Remaining Time above this value are displayed as full progress."
	--[[Translation missing --]]
	L["Values/Remaining Time below this value are displayed as zero progress."] = "Values/Remaining Time below this value are displayed as zero progress."
	L["Values:"] = "Werte:"
	L["Version: "] = "Version:"
	--[[Translation missing --]]
	L["Version: %s"] = "Version: %s"
	L["Vertical Align"] = "Vertikale Ausrichtung"
	L["Vertical Bar"] = "Vertikaler Balken"
	L["View"] = "Ansicht"
	--[[Translation missing --]]
	L["View custom code"] = "View custom code"
	--[[Translation missing --]]
	L["Voice Settings"] = "Voice Settings"
	--[[Translation missing --]]
	L["We thank"] = "We thank"
	--[[Translation missing --]]
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s on WoW %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	--[[Translation missing --]]
	L["What do you want to do?"] = "What do you want to do?"
	--[[Translation missing --]]
	L["Whole Area"] = "Whole Area"
	--[[Translation missing --]]
	L["wrapping"] = "wrapping"
	L["X Offset"] = "X-Versatz"
	L["X Rotation"] = "X-Rotation"
	L["X Scale"] = "Skalierung (X)"
	--[[Translation missing --]]
	L["x-Offset"] = "x-Offset"
	L["Y Offset"] = "Y-Versatz"
	L["Y Rotation"] = "Y-Rotation"
	L["Y Scale"] = "Skalierung (Y)"
	L["Yellow Rune"] = "Gelbe Rune"
	--[[Translation missing --]]
	L["y-Offset"] = "y-Offset"
	--[[Translation missing --]]
	L["You already have this group/aura. Importing will create a duplicate."] = "You already have this group/aura. Importing will create a duplicate."
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "Du bist im Begriff %d Aura/Auren zu lschen. |cFFFF0000Das Lschen kann nicht rckgngig gemacht werden!|r Willst du fortfahren?"
	--[[Translation missing --]]
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."
	--[[Translation missing --]]
	L["Your Saved Snippets"] = "Your Saved Snippets"
	L["Z Offset"] = "Z-Versatz"
	L["Z Rotation"] = "Z-Rotation"
	L["Zoom In"] = "Einzoomen"
	L["Zoom Out"] = "Auszoomen"



=== END OF FILE: WeakAurasOptions/Locales/deDE.lua ===


=== FILE: WeakAurasOptions/Locales/enUS.lua ===
if not WeakAuras.IsLibsOK() then return end

if ((GAME_LOCALE or GetLocale()) ~= "enUS") and ((GAME_LOCALE or GetLocale()) ~= "enGB") then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = " and |cFFFF0000mirrored|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- Do not remove this comment, it is part of this aura: "
	L[" rotated |cFFFF0000%s|r degrees"] = " rotated |cFFFF0000%s|r degrees"
	L["% - To show a percent sign"] = "% - To show a percent sign"
	L["% of Progress"] = "% of Progress"
	L["%d |4aura:auras; added"] = "%d |4aura:auras; added"
	L["%d |4aura:auras; deleted"] = "%d |4aura:auras; deleted"
	L["%d |4aura:auras; modified"] = "%d |4aura:auras; modified"
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; with meta data modified"
	L["%d displays loaded"] = "%d displays loaded"
	L["%d displays not loaded"] = "%d displays not loaded"
	L["%d displays on standby"] = "%d displays on standby"
	L["%i auras selected"] = "%i auras selected"
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i. Trigger"
	L["%s - Alpha Animation"] = "%s - Alpha Animation"
	L["%s - Color Animation"] = "%s - Color Animation"
	L["%s - Condition Custom Chat %s"] = "%s - Condition Custom Chat %s"
	L["%s - Condition Custom Check %s"] = "%s - Condition Custom Check %s"
	L["%s - Condition Custom Code %s"] = "%s - Condition Custom Code %s"
	L["%s - Custom Anchor"] = "%s - Custom Anchor"
	L["%s - Custom Grow"] = "%s - Custom Grow"
	L["%s - Custom Sort"] = "%s - Custom Sort"
	L["%s - Custom Text"] = "%s - Custom Text"
	L["%s - Finish"] = "%s - Finish"
	L["%s - Finish Action"] = "%s - Finish Action"
	L["%s - Finish Custom Text"] = "%s - Finish Custom Text"
	L["%s - Init Action"] = "%s - Init Action"
	L["%s - Main"] = "%s - Main"
	L["%s - OnLoad"] = "%s - OnLoad"
	L["%s - OnUnload"] = "%s - OnUnload"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - Option #%i has the key %s. Please choose a different option key."
	L["%s - Rotate Animation"] = "%s - Rotate Animation"
	L["%s - Scale Animation"] = "%s - Scale Animation"
	L["%s - Start"] = "%s - Start"
	L["%s - Start Action"] = "%s - Start Action"
	L["%s - Start Custom Text"] = "%s - Start Custom Text"
	L["%s - Translate Animation"] = "%s - Translate Animation"
	L["%s - Trigger Logic"] = "%s - Trigger Logic"
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"
	L["%s %u. Overlay Function"] = "%s %u. Overlay Function"
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s Alpha: %d%%"
	L["%s Color"] = "%s Color"
	L["%s Custom Variables"] = "%s Custom Variables"
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"
	L["%s Duration Function"] = "%s Duration Function"
	L["%s Icon Function"] = "%s Icon Function"
	L["%s Inset: %d%%"] = "%s Inset: %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s Keep Aspect Ratio"
	L["%s Name Function"] = "%s Name Function"
	L["%s Stacks Function"] = "%s Stacks Function"
	L["%s stores around %s KB of data"] = "%s stores around %s KB of data"
	L["%s Texture"] = "%s Texture"
	L["%s Texture Function"] = "%s Texture Function"
	L["%s total auras"] = "%s total auras"
	L["%s Trigger Function"] = "%s Trigger Function"
	L["%s Untrigger Function"] = "%s Untrigger Function"
	L["%s X offset by %d"] = "%s X offset by %d"
	L["%s Y offset by %d"] = "%s Y offset by %d"
	L["%s Zoom: %d%%"] = "%s Zoom: %d%%"
	L["%s, Border"] = "%s, Border"
	L["%s, Offset: %0.2f;%0.2f"] = "%s, Offset: %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, offset: %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s, Start Animation"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"
	L["(Right click to rename)"] = "(Right click to rename)"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02xCustom Color|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000Note:|r This sets the description only on '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000Note:|r This sets the URL on all selected auras"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000Note:|r This sets the URL on this group and all its members."
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000Automatic|r length"
	L["|cFFFF0000default|r texture"] = "|cFFFF0000default|r texture"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000desaturated|r "
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000Note:|r The unit '%s' is not a trackable unit."
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00Extra Options:|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00Extra:|r %s and %s %s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cffffcc00Format Options|r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=]
	L["A 20x20 pixels icon"] = "A 20x20 pixels icon"
	L["A 32x32 pixels icon"] = "A 32x32 pixels icon"
	L["A 40x40 pixels icon"] = "A 40x40 pixels icon"
	L["A 48x48 pixels icon"] = "A 48x48 pixels icon"
	L["A 64x64 pixels icon"] = "A 64x64 pixels icon"
	L["A group that dynamically controls the positioning of its children"] = "A group that dynamically controls the positioning of its children"
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=]
	L["A Unit ID (e.g., party1)."] = "A Unit ID (e.g., party1)."
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = "Active Aura Filters and Info"
	L["Actual Spec"] = "Actual Spec"
	L["Add %s"] = "Add %s"
	L["Add a new display"] = "Add a new display"
	L["Add Condition"] = "Add Condition"
	L["Add Entry"] = "Add Entry"
	L["Add Extra Elements"] = "Add Extra Elements"
	L["Add Option"] = "Add Option"
	L["Add Overlay"] = "Add Overlay"
	L["Add Property Change"] = "Add Property Change"
	L["Add Snippet"] = "Add Snippet"
	L["Add Sub Option"] = "Add Sub Option"
	L["Add to group %s"] = "Add to group %s"
	L["Add to new Dynamic Group"] = "Add to new Dynamic Group"
	L["Add to new Group"] = "Add to new Group"
	L["Add Trigger"] = "Add Trigger"
	L["Additional Events"] = "Additional Events"
	L["Advanced"] = "Advanced"
	L["Affected Unit Filters and Info"] = "Affected Unit Filters and Info"
	L["Align"] = "Align"
	L["Alignment"] = "Alignment"
	L["All maintainers of the libraries we use, especially:"] = "All maintainers of the libraries we use, especially:"
	L["All of"] = "All of"
	L["Allow Full Rotation"] = "Allow Full Rotation"
	L["Anchor"] = "Anchor"
	L["Anchor Mode"] = "Anchor Mode"
	L["Anchor Point"] = "Anchor Point"
	L["Anchored To"] = "Anchored To"
	L["And "] = "And "
	L["and"] = "and"
	L["and %s"] = "and %s"
	L["and aligned left"] = "and aligned left"
	L["and aligned right"] = "and aligned right"
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"
	L["and rotated left"] = "and rotated left"
	L["and rotated right"] = "and rotated right"
	L["and with width |cFFFF0000%s|r and %s"] = "and with width |cFFFF0000%s|r and %s"
	L["Angle"] = "Angle"
	L["Angle Between Auras"] = "Angle Between Auras"
	L["Animate"] = "Animate"
	L["Animated Expand and Collapse"] = "Animated Expand and Collapse"
	L["Animates progress changes"] = "Animates progress changes"
	L["Animation End"] = "Animation End"
	L["Animation Mode"] = "Animation Mode"
	L["Animation relative duration description"] = [=[The duration of the animation relative to the duration of the display, expressed as a fraction (1/2), percentage (50%), or decimal (0.5).
|cFFFF0000Note:|r if a display does not have progress (it has a non-timed event trigger, is an aura with no duration, etc.), the animation will not play.

|cFF4444FFFor Example:|r
If the animation's duration is set to |cFF00CC0010%|r, and the display's trigger is a buff that lasts 20 seconds, the start animation will play for 2 seconds.
If the animation's duration is set to |cFF00CC0010%|r, and the display's trigger is a buff that has no set duration, no start animation will play (although it would if you specified a duration in seconds)."
]=]
	L["Animation Sequence"] = "Animation Sequence"
	L["Animation Start"] = "Animation Start"
	L["Any of"] = "Any of"
	L["Apply Template"] = "Apply Template"
	L["Arcane Orb"] = "Arcane Orb"
	L["Area"] = "Area"
	L["At a position a bit left of Left HUD position."] = "At a position a bit left of Left HUD position."
	L["At a position a bit left of Right HUD position"] = "At a position a bit left of Right HUD position"
	L["At the same position as Blizzard's spell alert"] = "At the same position as Blizzard's spell alert"
	L["Attach to Foreground"] = "Attach to Foreground"
	L[ [=[Aura is
Off Screen]=] ] = [=[Aura is
Off Screen]=]
	L["Aura Name Pattern"] = "Aura Name Pattern"
	L["Aura Order"] = "Aura Order"
	L["Aura received from: %s"] = "Aura received from: %s"
	L["Aura: '%s'"] = "Aura: '%s'"
	L["Auto-Clone (Show All Matches)"] = "Auto-Clone (Show All Matches)"
	L["Automatic length"] = "Automatic length"
	L["Backdrop Color"] = "Backdrop Color"
	L["Backdrop in Front"] = "Backdrop in Front"
	L["Backdrop Style"] = "Backdrop Style"
	L["Background Inner"] = "Background Inner"
	L["Background Offset"] = "Background Offset"
	L["Background Texture"] = "Background Texture"
	L["Bar Alpha"] = "Bar Alpha"
	L["Bar Color Settings"] = "Bar Color Settings"
	L["Big Icon"] = "Big Icon"
	L["Blend Mode"] = "Blend Mode"
	L["Blue Rune"] = "Blue Rune"
	L["Blue Sparkle Orb"] = "Blue Sparkle Orb"
	L["Border %s"] = "Border %s"
	L["Border Anchor"] = "Border Anchor"
	L["Border Color"] = "Border Color"
	L["Border in Front"] = "Border in Front"
	L["Border Inset"] = "Border Inset"
	L["Border Offset"] = "Border Offset"
	L["Border Settings"] = "Border Settings"
	L["Border Size"] = "Border Size"
	L["Border Style"] = "Border Style"
	L["Bracket Matching"] = "Bracket Matching"
	L["Browse Wago, the largest collection of auras."] = "Browse Wago, the largest collection of auras."
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."
	L["Can be a UID (e.g., party1)."] = "Can be a UID (e.g., party1)."
	L["Can set to 0 if Columns * Width equal File Width"] = "Can set to 0 if Columns * Width equal File Width"
	L["Can set to 0 if Rows * Height equal File Height"] = "Can set to 0 if Rows * Height equal File Height"
	L["Case Insensitive"] = "Case Insensitive"
	L["Cast by a Player Character"] = "Cast by a Player Character"
	L["Categories to Update"] = "Categories to Update"
	L["Changelog"] = "Changelog"
	L["Chat with WeakAuras experts on our Discord server."] = "Chat with WeakAuras experts on our Discord server."
	L["Check On..."] = "Check On..."
	L["Check out our wiki for a large collection of examples and snippets."] = "Check out our wiki for a large collection of examples and snippets."
	L["Children:"] = "Children:"
	L["Choose"] = "Choose"
	L["Circular Texture %s"] = "Circular Texture %s"
	L["Clear Debug Logs"] = "Clear Debug Logs"
	L["Clear Saved Data"] = "Clear Saved Data"
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	L["Clip Overlays"] = "Clip Overlays"
	L["Clipped by Foreground"] = "Clipped by Foreground"
	L["Close"] = "Close"
	L["Code Editor"] = "Code Editor"
	L["Collapse"] = "Collapse"
	L["Collapse all loaded displays"] = "Collapse all loaded displays"
	L["Collapse all non-loaded displays"] = "Collapse all non-loaded displays"
	L["Collapse all pending Import"] = "Collapse all pending Import"
	L["Collapsible Group"] = "Collapsible Group"
	L["color"] = "color"
	L["Column Height"] = "Column Height"
	L["Column Space"] = "Column Space"
	L["Columns"] = "Columns"
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."
	L["Combinations"] = "Combinations"
	L["Combine Matches Per Unit"] = "Combine Matches Per Unit"
	L["Common Text"] = "Common Text"
	L["Compare against the number of units affected."] = "Compare against the number of units affected."
	L["Compatibility Options"] = "Compatibility Options"
	L["Compress"] = "Compress"
	L["Configure what options appear on this panel."] = "Configure what options appear on this panel."
	L["Constant Factor"] = "Constant Factor"
	L["Control-click to select multiple displays"] = "Control-click to select multiple displays"
	L["Controls the positioning and configuration of multiple displays at the same time"] = "Controls the positioning and configuration of multiple displays at the same time"
	L["Convert to..."] = "Convert to..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "Cooldown Numbers might be added by WoW. You can configure these in the game settings."
	L["Copy"] = "Copy"
	L["Copy settings..."] = "Copy settings..."
	L["Copy to all auras"] = "Copy to all auras"
	L["Could not parse '%s'. Expected a table."] = "Could not parse '%s'. Expected a table."
	L["Counts the number of matches over all units."] = "Counts the number of matches over all units."
	L["Counts the number of matches per unit."] = "Counts the number of matches per unit."
	L["Create a Copy"] = "Create a Copy"
	L["Creating buttons: "] = "Creating buttons: "
	L["Creating options: "] = "Creating options: "
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."
	L["Custom Code"] = "Custom Code"
	L["Custom Code Viewer"] = "Custom Code Viewer"
	L["Custom Frames"] = "Custom Frames"
	L["Custom Functions"] = "Custom Functions"
	L["Custom Init"] = "Custom Init"
	L["Custom Load"] = "Custom Load"
	L["Custom Options"] = "Custom Options"
	L["Custom Text Update Throttle"] = "Custom Text Update Throttle"
	L["Custom Trigger"] = "Custom Trigger"
	L["Custom trigger event tooltip"] = [=[Choose which events cause the custom trigger to be checked. Multiple events can be specified using commas or spaces.
 "UNIT" events can use colons to define which unitIDs will be registered. In addition to UnitIDs Unit types can be used, they include "nameplate", "group", "raid", "party", "arena", "boss".
 "CLEU" can be used instead of COMBAT_LOG_EVENT_UNFILTERED and colons can be used to separate specific "subEvents" you want to receive.
 The keyword "TRIGGER" can be used, with colons separating trigger numbers, to have the custom trigger get updated when the specified trigger(s) update.

|cFF4444FFFor example:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1
]=]
	L["Custom trigger status tooltip"] = [=[Choose which events cause the custom trigger to be checked. Multiple events can be specified using commas or spaces.

 "UNIT" events can use colons to define which unitIDs will be registered. In addition to UnitIDs Unit types can be used, they include "nameplate", "group", "raid", "party", "arena", "boss".
 "CLEU" can be used instead of COMBAT_LOG_EVENT_UNFILTERED and colons can be used to separate specific "subEvents" you want to receive.
 The keyword "TRIGGER" can be used, with colons separating trigger numbers, to have the custom trigger get updated when the specified trigger(s) update.

Since this is a status-type trigger, the specified events may be called by WeakAuras without the expected arguments.

|cFF4444FFFor example:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1
]=]
	L["Custom trigger Update Throttle"] = "Custom trigger Update Throttle"
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "Custom Trigger: Ignore Lua Errors on OPTIONS event"
	L["Custom Trigger: Send fake events instead of STATUS event"] = "Custom Trigger: Send fake events instead of STATUS event"
	L["Custom Unload"] = "Custom Unload"
	L["Custom Untrigger"] = "Custom Untrigger"
	L["Debug Log"] = "Debug Log"
	L["Debug Log:"] = "Debug Log:"
	L["Default"] = "Default"
	L["Default Color"] = "Default Color"
	L["Delay"] = "Delay"
	L["Delete"] = "Delete"
	L["Delete all"] = "Delete all"
	L["Delete children and group"] = "Delete children and group"
	L["Delete Entry"] = "Delete Entry"
	L["Deleting auras: "] = "Deleting auras: "
	L["Description Text"] = "Description Text"
	L["Determines how many entries can be in the table."] = "Determines how many entries can be in the table."
	L["Differences"] = "Differences"
	L["Disallow Entry Reordering"] = "Disallow Entry Reordering"
	L["Discord"] = "Discord"
	L["Display Name"] = "Display Name"
	L["Display Text"] = "Display Text"
	L["Displays a text, works best in combination with other displays"] = "Displays a text, works best in combination with other displays"
	L["Distribute Horizontally"] = "Distribute Horizontally"
	L["Distribute Vertically"] = "Distribute Vertically"
	L["Do not group this display"] = "Do not group this display"
	L["Do you want to enable updates for this aura"] = "Do you want to enable updates for this aura"
	L["Do you want to ignore updates for this aura"] = "Do you want to ignore updates for this aura"
	L["Documentation"] = "Documentation"
	L["Done"] = "Done"
	L["Drag to move"] = "Drag to move"
	L["Duplicate"] = "Duplicate"
	L["Duplicate All"] = "Duplicate All"
	L["Duration (s)"] = "Duration (s)"
	L["Duration Info"] = "Duration Info"
	L["Dynamic Duration"] = "Dynamic Duration"
	L["Dynamic Group"] = "Dynamic Group"
	L["Dynamic Group Settings"] = "Dynamic Group Settings"
	L["Dynamic Information"] = "Dynamic Information"
	L["Dynamic information from first active trigger"] = "Dynamic information from first active trigger"
	L["Dynamic information from Trigger %i"] = "Dynamic information from Trigger %i"
	L["Dynamic Text Replacements"] = "Dynamic Text Replacements"
	L["Ease Strength"] = "Ease Strength"
	L["Ease type"] = "Ease type"
	L["eliding"] = "eliding"
	L["Else If"] = "Else If"
	L["Else If %s"] = "Else If %s"
	L["Empty Base Region"] = "Empty Base Region"
	L["Enable \"Edge\" part of the overlay"] = "Enable \"Edge\" part of the overlay"
	L["Enable \"swipe\" part of the overlay"] = "Enable \"swipe\" part of the overlay"
	L["Enable Debug Log"] = "Enable Debug Log"
	L["Enable Debug Logging"] = "Enable Debug Logging"
	L["Enable Gradient"] = "Enable Gradient"
	L["Enable Swipe"] = "Enable Swipe"
	L["Enable the \"Swipe\" radial overlay"] = "Enable the \"Swipe\" radial overlay"
	L["Enabled"] = "Enabled"
	L["End Angle"] = "End Angle"
	L["End of %s"] = "End of %s"
	L["Enemy nameplate(s) found"] = "Enemy nameplate(s) found"
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "Enter a Spell ID. You can use the addon idTip to determine spell ids."
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = "Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."
	L["Enter Author Mode"] = "Enter Author Mode"
	L["Enter in a value for the tick's placement."] = "Enter in a value for the tick's placement."
	L["Enter static or relative values with %"] = "Enter static or relative values with %"
	L["Enter User Mode"] = "Enter User Mode"
	L["Enter user mode."] = "Enter user mode."
	L["Entry %i"] = "Entry %i"
	L["Entry limit"] = "Entry limit"
	L["Entry Name Source"] = "Entry Name Source"
	L["Event Type"] = "Event Type"
	L["Everything"] = "Everything"
	L["Exact Item Match"] = "Exact Item Match"
	L["Exact Spell Match"] = "Exact Spell Match"
	L["Expand"] = "Expand"
	L["Expand all loaded displays"] = "Expand all loaded displays"
	L["Expand all non-loaded displays"] = "Expand all non-loaded displays"
	L["Expand all pending Import"] = "Expand all pending Import"
	L["Expansion is disabled because this group has no children"] = "Expansion is disabled because this group has no children"
	L["Export debug table..."] = "Export debug table..."
	L["Export..."] = "Export..."
	L["Exporting"] = "Exporting"
	L["External"] = "External"
	L["Extra Height"] = "Extra Height"
	L["Extra Width"] = "Extra Width"
	L["Fade"] = "Fade"
	L["Fadeout Sound"] = "Fadeout Sound"
	L["Fadeout Time (seconds)"] = "Fadeout Time (seconds)"
	L["Fetch Affected/Unaffected Names and Units"] = "Fetch Affected/Unaffected Names and Units"
	L["Fetch Raid Mark Information"] = "Fetch Raid Mark Information"
	L["Fetch Role Information"] = "Fetch Role Information"
	L["Fetch Tooltip Information"] = "Fetch Tooltip Information"
	L["File Height"] = "File Height"
	L["File Width"] = "File Width"
	L["Filter based on the spell Name string."] = "Filter based on the spell Name string."
	L["Filter by Arena Spec"] = "Filter by Arena Spec"
	L["Filter by Class"] = "Filter by Class"
	L["Filter by Group Role"] = "Filter by Group Role"
	L["Filter by Hostility"] = "Filter by Hostility"
	L["Filter by Npc ID"] = "Filter by Npc ID"
	L["Filter by Raid Role"] = "Filter by Raid Role"
	L["Filter by Specialization"] = "Filter by Specialization"
	L["Filter by Unit Name"] = "Filter by Unit Name"
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=]
	L["Find Auras"] = "Find Auras"
	L["Finish"] = "Finish"
	L["Finishing..."] = "Finishing..."
	L["Fire Orb"] = "Fire Orb"
	L["Flat Framelevels"] = "Flat Framelevels"
	L["Foreground Texture"] = "Foreground Texture"
	L["Format for %s"] = "Format for %s"
	L["Found a Bug?"] = "Found a Bug?"
	L["Frame"] = "Frame"
	L["Frame Count"] = "Frame Count"
	L["Frame Height"] = "Frame Height"
	L["Frame Rate"] = "Frame Rate"
	L["Frame Strata"] = "Frame Strata"
	L["Frame Width"] = "Frame Width"
	L["Full Bar"] = "Full Bar"
	L["Full Circle"] = "Full Circle"
	L["Global Conditions"] = "Global Conditions"
	L["Glow %s"] = "Glow %s"
	L["Glow Action"] = "Glow Action"
	L["Glow Anchor"] = "Glow Anchor"
	L["Glow Color"] = "Glow Color"
	L["Glow Frame Type"] = "Glow Frame Type"
	L["Glow Type"] = "Glow Type"
	L["Green Rune"] = "Green Rune"
	L["Grid direction"] = "Grid direction"
	L["Group (verb)"] = "Group"
	L["Group Alpha"] = "Group Alpha"
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=]
	L["Group aura count description"] = [=[The amount of units of type '%s' which must be affected by one or more of the given auras for the display to trigger.
If the entered number is a whole number (e.g. 5), the number of affected units will be compared with the entered number.
If the entered number is a decimal (e.g. 0.5), fraction (e.g. 1/2), or percentage (e.g. 50%%), then that fraction of the %s must be affected.

|cFF4444FFFor example:|r
|cFF00CC00> 0|r will trigger when any unit of type '%s' is affected
|cFF00CC00= 100%%|r will trigger when every unit of type '%s' is affected
|cFF00CC00!= 2|r will trigger when the number of units of type '%s' affected is not exactly 2
|cFF00CC00<= 0.8|r will trigger when less than 80%% of the units of type '%s' is affected (4 of 5 party members, 8 of 10 or 20 of 25 raid members)
|cFF00CC00> 1/2|r will trigger when more than half of the units of type '%s' is affected
]=]
	L["Group by Frame"] = "Group by Frame"
	L["Group Description"] = "Group Description"
	L["Group Icon"] = "Group Icon"
	L["Group key"] = "Group key"
	L["Group Options"] = "Group Options"
	L["Group player(s) found"] = "Group player(s) found"
	L["Group Role"] = "Group Role"
	L["Group Scale"] = "Group Scale"
	L["Group Settings"] = "Group Settings"
	L["Hawk"] = "Hawk"
	L["Help"] = "Help"
	L["Hide After"] = "Hide After"
	L["Hide Background"] = "Hide Background"
	L["Hide Glows applied by this aura"] = "Hide Glows applied by this aura"
	L["Hide on"] = "Hide on"
	L["Hide this group's children"] = "Hide this group's children"
	L["Highlights"] = "Highlights"
	L["Horizontal Align"] = "Horizontal Align"
	L["Horizontal Bar"] = "Horizontal Bar"
	L["Huge Icon"] = "Huge Icon"
	L["Hybrid Position"] = "Hybrid Position"
	L["Hybrid Sort Mode"] = "Hybrid Sort Mode"
	L["Icon - The icon associated with the display"] = "Icon - The icon associated with the display"
	L["Icon Info"] = "Icon Info"
	L["Icon Inset"] = "Icon Inset"
	L["Icon Picker"] = "Icon Picker"
	L["Icon Position"] = "Icon Position"
	L["Icon Settings"] = "Icon Settings"
	L["Icon Source"] = "Icon Source"
	L["If"] = "If"
	L["If %s"] = "If %s"
	L["If checked, then the combo box in the User settings will be sorted."] = "If checked, then the combo box in the User settings will be sorted."
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "If checked, then this group will not merge with other group when selecting multiple auras."
	L["If checked, then this option group can be temporarily collapsed by the user."] = "If checked, then this option group can be temporarily collapsed by the user."
	L["If checked, then this option group will start collapsed."] = "If checked, then this option group will start collapsed."
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "If checked, then this separator will include text. Otherwise, it will be just a horizontal line."
	L["If checked, then this space will span across multiple lines."] = "If checked, then this space will span across multiple lines."
	L["If unchecked, then a default color will be used (usually yellow)"] = "If unchecked, then a default color will be used (usually yellow)"
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "If unchecked, then this space will fill the entire line it is on in User Mode."
	L["Ignore out of casting range"] = "Ignore out of casting range"
	L["Ignore out of checking range"] = "Ignore out of checking range"
	L["Ignore Wago updates"] = "Ignore Wago updates"
	L["Ignored"] = "Ignored"
	L["Ignored Aura Name"] = "Ignored Aura Name"
	L["Ignored Exact Spell ID(s)"] = "Ignored Exact Spell ID(s)"
	L["Ignored Name(s)"] = "Ignored Name(s)"
	L["Ignored Spell ID"] = "Ignored Spell ID"
	L["Import"] = "Import"
	L["Import / Export"] = "Import / Export"
	L["Import a display from an encoded string"] = "Import a display from an encoded string"
	L["Import as Copy"] = "Import as Copy"
	L["Import has no UID, cannot be matched to existing auras."] = "Import has no UID, cannot be matched to existing auras."
	L["Importing"] = "Importing"
	L["Importing %s"] = "Importing %s"
	L["Importing a group with %s child auras."] = "Importing a group with %s child auras."
	L["Importing a stand-alone aura."] = "Importing a stand-alone aura."
	L["Importing...."] = "Importing...."
	L["Incompatible changes to group region types detected"] = "Incompatible changes to group region types detected"
	L["Incompatible changes to group structure detected"] = "Incompatible changes to group structure detected"
	L["Indent Size"] = "Indent Size"
	L["Inner"] = "Inner"
	L["Insert text replacement codes to make text dynamic."] = "Insert text replacement codes to make text dynamic."
	L["Invalid Item ID"] = "Invalid Item ID"
	L["Invalid Item Name/ID/Link"] = "Invalid Item Name/ID/Link"
	L["Invalid Spell ID"] = "Invalid Spell ID"
	L["Invalid Spell Name/ID/Link"] = "Invalid Spell Name/ID/Link"
	L["Invalid target aura"] = "Invalid target aura"
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "Invalid type for property '%s' in '%s'. Expected '%s'"
	L["Inverse Slant"] = "Inverse Slant"
	L["Invert the direction of progress"] = "Invert the direction of progress"
	L["Is Boss Debuff"] = "Is Boss Debuff"
	L["Is Stealable"] = "Is Stealable"
	L["Is Unit"] = "Is Unit"
	L["Justify"] = "Justify"
	L["Keep Aspect Ratio"] = "Keep Aspect Ratio"
	L["Keep your Wago imports up to date with the Companion App."] = "Keep your Wago imports up to date with the Companion App."
	L["Large Input"] = "Large Input"
	L["Leaf"] = "Leaf"
	L["Left 2 HUD position"] = "Left 2 HUD position"
	L["Left HUD position"] = "Left HUD position"
	L["Length of |cFFFF0000%s|r"] = "Length of |cFFFF0000%s|r"
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = "Limit"
	L["Line"] = "Line"
	L["Linear Texture %s"] = "Linear Texture %s"
	L["Linked aura: "] = "Linked aura: "
	L["Linked Auras"] = "Linked Auras"
	L["Load"] = "Load"
	L["Loaded"] = "Loaded"
	L["Loaded/Standby"] = "Loaded/Standby"
	L["Lock Positions"] = "Lock Positions"
	L["Low Mana"] = "Low Mana"
	L["Magnetically Align"] = "Magnetically Align"
	L["Main"] = "Main"
	L["Manual with %i/%i"] = "Manual with %i/%i"
	L["Matches %s spells"] = "Matches %s spells"
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "Matches the height setting of a horizontal bar or width for a vertical bar."
	L["Max"] = "Max"
	L["Max Length"] = "Max Length"
	L["Maximum"] = "Maximum"
	L["Media Type"] = "Media Type"
	L["Medium Icon"] = "Medium Icon"
	L["Min"] = "Min"
	L["Minimum"] = "Minimum"
	L["Model %s"] = "Model %s"
	L["Model Picker"] = "Model Picker"
	L["Model Settings"] = "Model Settings"
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths could not be loaded, the addon is %s"
	L["Move Above Group"] = "Move Above Group"
	L["Move Below Group"] = "Move Below Group"
	L["Move Down"] = "Move Down"
	L["Move Entry Down"] = "Move Entry Down"
	L["Move Entry Up"] = "Move Entry Up"
	L["Move Into Above Group"] = "Move Into Above Group"
	L["Move Into Below Group"] = "Move Into Below Group"
	L["Move this display down in its group's order"] = "Move this display down in its group's order"
	L["Move this display up in its group's order"] = "Move this display up in its group's order"
	L["Move Up"] = "Move Up"
	L["Moving auras: "] = "Moving auras: "
	L["Multiple Displays"] = "Multiple Displays"
	L["Multiselect ignored tooltip"] = [=[|cFFFF0000Ignored|r - |cFF777777Single|r - |cFF777777Multiple|r
This option will not be used to determine when this display should load]=]
	L["Multiselect multiple tooltip"] = [=[|cFF777777Ignored|r - |cFF777777Single|r - |cFF00FF00Multiple|r
Any number of matching values can be picked]=]
	L["Multiselect single tooltip"] = [=[|cFF777777Ignored|r - |cFF00FF00Single|r - |cFF777777Multiple|r
Only a single matching value can be picked]=]
	L["Must be a power of 2"] = "Must be a power of 2"
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"
	L["Name Info"] = "Name Info"
	L["Name Pattern Match"] = "Name Pattern Match"
	L["Name:"] = "Name:"
	L["Negator"] = "Not"
	L["New Aura"] = "New Aura"
	L["New Template"] = "New Template"
	L["New Value"] = "New Value"
	L["No Children"] = "No Children"
	L["No Logs saved."] = "No Logs saved."
	L["Not a table"] = "Not a table"
	L["Not all children have the same value for this option"] = "Not all children have the same value for this option"
	L["Not Loaded"] = "Not Loaded"
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "Note: Automated Messages to SAY and YELL are blocked outside of Instances."
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""
	L["Number of Entries"] = "Number of Entries"
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=]
	L["OFF"] = "OFF"
	L["Offer a guided way to create auras for your character"] = "Offer a guided way to create auras for your character"
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"
	L["Offset by 1px"] = "Offset by 1px"
	L["Okay"] = "Okay"
	L["ON"] = "ON"
	L["On Hide"] = "On Hide"
	L["On Show"] = "On Show"
	L["Only Match auras cast by a player (not an npc)"] = "Only Match auras cast by a player (not an npc)"
	L["Only match auras cast by people other than the player or their pet"] = "Only match auras cast by people other than the player or their pet"
	L["Only match auras cast by the player or their pet"] = "Only match auras cast by the player or their pet"
	L["Operator"] = "Operator"
	L["Option %i"] = "Option %i"
	L["Option key"] = "Option key"
	L["Option Type"] = "Option Type"
	L["Options will open after combat ends."] = "Options will open after combat ends."
	L["or"] = "or"
	L["or %s"] = "or %s"
	L["Orange Rune"] = "Orange Rune"
	L["Our translators (too many to name)"] = "Our translators (too many to name)"
	L["Outer"] = "Outer"
	L["Overflow"] = "Overflow"
	L["Overlay %s Info"] = "Overlay %s Info"
	L["Overlays"] = "Overlays"
	L["Own Only"] = "Own Only"
	L["Paste Action Settings"] = "Paste Action Settings"
	L["Paste Animations Settings"] = "Paste Animations Settings"
	L["Paste Author Options Settings"] = "Paste Author Options Settings"
	L["Paste Condition Settings"] = "Paste Condition Settings"
	L["Paste Custom Configuration"] = "Paste Custom Configuration"
	L["Paste Display Settings"] = "Paste Display Settings"
	L["Paste Group Settings"] = "Paste Group Settings"
	L["Paste Load Settings"] = "Paste Load Settings"
	L["Paste Settings"] = "Paste Settings"
	L["Paste text below"] = "Paste text below"
	L["Paste Trigger Settings"] = "Paste Trigger Settings"
	L["Places a tick on the bar"] = "Places a tick on the bar"
	L["Play Sound"] = "Play Sound"
	L["Player Spells found:"] = "Player Spells found:"
	L["Portrait Zoom"] = "Portrait Zoom"
	L["Position and Size Settings"] = "Position and Size Settings"
	L["Preferred Match"] = "Preferred Match"
	L["Premade Auras"] = "Premade Auras"
	L["Premade Snippets"] = "Premade Snippets"
	L["Preparing auras: "] = "Preparing auras: "
	L["Press Ctrl+C to copy"] = "Press Ctrl+C to copy"
	L["Press Ctrl+C to copy the URL"] = "Press Ctrl+C to copy the URL"
	L["Prevent Merging"] = "Prevent Merging"
	L["Progress - The remaining time of a timer, or a non-timer value"] = "Progress - The remaining time of a timer, or a non-timer value"
	L["Progress Bar"] = "Progress Bar"
	L["Progress Bar Settings"] = "Progress Bar Settings"
	L["Progress Settings"] = "Progress Settings"
	L["Progress Texture"] = "Progress Texture"
	L["Progress Texture Settings"] = "Progress Texture Settings"
	L["Purple Rune"] = "Purple Rune"
	L["Put this display in a group"] = "Put this display in a group"
	L["Range in yards"] = "Range in yards"
	L["Ready for Install"] = "Ready for Install"
	L["Ready for Update"] = "Ready for Update"
	L["Re-center X"] = "Re-center X"
	L["Re-center Y"] = "Re-center Y"
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "Reciprocal TRIGGER:# requests will be ignored!"
	L["Redo"] = "Redo"
	L["Regions of type \"%s\" are not supported."] = "Regions of type \"%s\" are not supported."
	L["Remove"] = "Remove"
	L["Remove All Sounds"] = "Remove All Sounds"
	L["Remove All Text To Speech"] = "Remove All Text To Speech"
	L["Remove this display from its group"] = "Remove this display from its group"
	L["Remove this property"] = "Remove this property"
	L["Rename"] = "Rename"
	L["Repeat After"] = "Repeat After"
	L["Repeat every"] = "Repeat every"
	L["Report bugs on our issue tracker."] = "Report bugs on our issue tracker."
	L["Require unit from trigger"] = "Require unit from trigger"
	L["Required for Activation"] = "Required for Activation"
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"
	L["Reset all options to their default values."] = "Reset all options to their default values."
	L["Reset Entry"] = "Reset Entry"
	L["Reset to Defaults"] = "Reset to Defaults"
	L["Right 2 HUD position"] = "Right 2 HUD position"
	L["Right HUD position"] = "Right HUD position"
	L["Right-click for more options"] = "Right-click for more options"
	L["Rotate"] = "Rotate"
	L["Rotate In"] = "Rotate In"
	L["Rotate Out"] = "Rotate Out"
	L["Rotate Text"] = "Rotate Text"
	L["Rotation Mode"] = "Rotation Mode"
	L["Row Space"] = "Row Space"
	L["Row Width"] = "Row Width"
	L["Rows"] = "Rows"
	L["Run on..."] = "Run on..."
	L["Same"] = "Same"
	L["Same texture as Foreground"] = "Same texture as Foreground"
	L["Saved Data"] = "Saved Data"
	L["Scale Factor"] = "Scale Factor"
	L["Search API"] = "Search API"
	L["Select Talent"] = "Select Talent"
	L["Select the auras you always want to be listed first"] = "Select the auras you always want to be listed first"
	L["Selected Frame"] = "Selected Frame"
	L["Send To"] = "Send To"
	L["Separator Text"] = "Separator Text"
	L["Separator text"] = "Separator text"
	L["Set Maximum Progress"] = "Set Maximum Progress"
	L["Set Minimum Progress"] = "Set Minimum Progress"
	L["Set Parent to Anchor"] = "Set Parent to Anchor"
	L["Set Thumbnail Icon"] = "Set Thumbnail Icon"
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."
	L["Settings"] = "Settings"
	L["Shadow Color"] = "Shadow Color"
	L["Shadow X Offset"] = "Shadow X Offset"
	L["Shadow Y Offset"] = "Shadow Y Offset"
	L["Shift-click to create chat link"] = "Shift-click to create a |cFF8800FF[Chat Link]"
	L["Show \"Edge\""] = "Show \"Edge\""
	L["Show \"Swipe\""] = "Show \"Swipe\""
	L["Show and Clone Settings"] = "Show and Clone Settings"
	L["Show Border"] = "Show Border"
	L["Show Circular Texture"] = "Show Circular Texture"
	L["Show Debug Logs"] = "Show Debug Logs"
	L["Show Glow"] = "Show Glow"
	L["Show Icon"] = "Show Icon"
	L["Show If Unit Does Not Exist"] = "Show If Unit Does Not Exist"
	L["Show Linear Texture"] = "Show Linear Texture"
	L["Show Matches for"] = "Show Matches for"
	L["Show Matches for Units"] = "Show Matches for Units"
	L["Show Model"] = "Show Model"
	L["Show model of unit "] = "Show model of unit "
	L["Show Sound Setting"] = "Show Sound Setting"
	L["Show Spark"] = "Show Spark"
	L["Show Stop Motion"] = "Show Stop Motion"
	L["Show Text"] = "Show Text"
	L["Show Text To Speech Setting"] = "Show Text To Speech Setting"
	L["Show Texture"] = "Show Texture"
	L["Show this group's children"] = "Show this group's children"
	L["Show Tick"] = "Show Tick"
	L["Shows a 3D model from the game files"] = "Shows a 3D model from the game files"
	L["Shows a border"] = "Shows a border"
	L["Shows a Circular Progress Texture"] = "Shows a Circular Progress Texture"
	L["Shows a custom texture"] = "Shows a custom texture"
	L["Shows a glow"] = "Shows a glow"
	L["Shows a Linear Progress Texture"] = "Shows a Linear Progress Texture"
	L["Shows a model"] = "Shows a model"
	L["Shows a progress bar with name, timer, and icon"] = "Shows a progress bar with name, timer, and icon"
	L["Shows a spell icon with an optional cooldown overlay"] = "Shows a spell icon with an optional cooldown overlay"
	L["Shows a Stop Motion"] = "Shows a Stop Motion"
	L["Shows a stop motion texture"] = "Shows a stop motion texture"
	L["Shows a Texture"] = "Shows a Texture"
	L["Shows a texture that changes based on duration"] = "Shows a texture that changes based on duration"
	L["Shows nothing, except sub elements"] = "Shows nothing, except sub elements"
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Shows one or more lines of text, which can include dynamic information such as progress or stacks"
	L["Size"] = "Size"
	L["Slant Amount"] = "Slant Amount"
	L["Slant Mode"] = "Slant Mode"
	L["Slanted"] = "Slanted"
	L["Slide"] = "Slide"
	L["Slide In"] = "Slide In"
	L["Slide Out"] = "Slide Out"
	L["Slider Step Size"] = "Slider Step Size"
	L["Small Icon"] = "Small Icon"
	L["Smooth Progress"] = "Smooth Progress"
	L["Snippets"] = "Snippets"
	L["Soft Max"] = "Soft Max"
	L["Soft Min"] = "Soft Min"
	L["Sort"] = "Sort"
	L["Sound Channel"] = "Sound Channel"
	L["Sound File Path"] = "Sound File Path"
	L["Sound Kit ID"] = "Sound Kit ID"
	L["Space Horizontally"] = "Space Horizontally"
	L["Space Vertically"] = "Space Vertically"
	L["Spark Settings"] = "Spark Settings"
	L["Spark Texture"] = "Spark Texture"
	L["Specific Currency ID"] = "Specific Currency ID"
	L["Spell Selection Filters"] = "Spell Selection Filters"
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = "Stack Info"
	L["Stacks - The number of stacks of an aura (usually)"] = "Stacks - The number of stacks of an aura (usually)"
	L["Standby"] = "Standby"
	L["Star"] = "Star"
	L["Start"] = "Start"
	L["Start Angle"] = "Start Angle"
	L["Start Collapsed"] = "Start Collapsed"
	L["Start of %s"] = "Start of %s"
	L["Step Size"] = "Step Size"
	L["Stop Motion %s"] = "Stop Motion %s"
	L["Stop Motion Settings"] = "Stop Motion Settings"
	L["Stop Sound"] = "Stop Sound"
	L["Stretched by Foreground"] = "Stretched by Foreground"
	L["Sub Elements"] = "Sub Elements"
	L["Sub Option %i"] = "Sub Option %i"
	L["Subevent"] = "Subevent"
	L["Subevent Suffix"] = "Subevent Suffix"
	L["Swipe Overlay Settings"] = "Swipe Overlay Settings"
	L["Templates could not be loaded, the addon is %s"] = "Templates could not be loaded, the addon is %s"
	L["Temporary Group"] = "Temporary Group"
	L["Text %s"] = "Text %s"
	L["Text Color"] = "Text Color"
	L["Text Settings"] = "Text Settings"
	L["Texture %s"] = "Texture %s"
	L["Texture Info"] = "Texture Info"
	L["Texture Selection Mode"] = "Texture Selection Mode"
	L["Texture Settings"] = "Texture Settings"
	L["Texture Wrap"] = "Texture Wrap"
	L["Texture X Offset"] = "Texture X Offset"
	L["Texture Y Offset"] = "Texture Y Offset"
	L["Thanks"] = "Thanks"
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"
	L["The duration of the animation in seconds."] = "The duration of the animation in seconds."
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = "The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."
	L["The group and all direct children will share the same base frame level."] = "The group and all direct children will share the same base frame level."
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."
	L["The type of trigger"] = "The type of trigger"
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"
	L["Then "] = "Then "
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."
	L["This adds %raidMark as text replacements."] = "This adds %raidMark as text replacements."
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=]
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=]
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=]
	L["This display is currently loaded"] = "This display is currently loaded"
	L["This display is not currently loaded"] = "This display is not currently loaded"
	L["This display is on standby, it will be loaded when needed."] = "This display is on standby, it will be loaded when needed."
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "This is a modified version of your aura, |cff9900FF%s.|r"
	L["This is a modified version of your group: |cff9900FF%s|r"] = "This is a modified version of your group: |cff9900FF%s|r"
	L["This region of type \"%s\" is not supported."] = "This region of type \"%s\" is not supported."
	L["This setting controls what widget is generated in user mode."] = "This setting controls what widget is generated in user mode."
	L["Thumbnail Icon"] = "Thumbnail Icon"
	L["Tick %s"] = "Tick %s"
	L["Tick Area %s"] = "Tick Area %s"
	L["Tick Center %s"] = "Tick Center %s"
	L["Tick Mode"] = "Tick Mode"
	L["Tick Placement"] = "Tick Placement"
	L["Time in"] = "Time in"
	L["Tiny Icon"] = "Tiny Icon"
	L["To Frame's"] = "To Frame's"
	L["To Group's"] = "To Group's"
	L["To Personal Ressource Display's"] = "To Personal Ressource Display's"
	L["To Region's"] = "To Region's"
	L["To Screen's"] = "To Screen's"
	L["Toggle the visibility of all loaded displays"] = "Toggle the visibility of all loaded displays"
	L["Toggle the visibility of all non-loaded displays"] = "Toggle the visibility of all non-loaded displays"
	L["Toggle the visibility of this display"] = "Toggle the visibility of this display"
	L["Tooltip Content"] = "Tooltip Content"
	L["Tooltip on Mouseover"] = "Tooltip on Mouseover"
	L["Tooltip Pattern Match"] = "Tooltip Pattern Match"
	L["Tooltip Text"] = "Tooltip Text"
	L["Tooltip Value"] = "Tooltip Value"
	L["Tooltip Value #"] = "Tooltip Value #"
	L["Top HUD position"] = "Top HUD position"
	L["Total"] = "Total"
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = "Total - The maximum duration of a timer, or a maximum non-timer value"
	L["Total Angle"] = "Total Angle"
	L["Total Time"] = "Total Time"
	L["Trigger %i: %s"] = "Trigger %i: %s"
	L["Trigger Combination"] = "Trigger Combination"
	L["Type 'select' for '%s' requires a values member'"] = "Type 'select' for '%s' requires a values member'"
	L["Undo"] = "Undo"
	L["Ungroup"] = "Ungroup"
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "Unit %s is not a valid unit for RegisterUnitEvent"
	L["Unit Count"] = "Unit Count"
	L["Unknown"] = "Unknown"
	L["Unknown Encounter's Spell Id"] = "Unknown Encounter's Spell Id"
	L["Unknown property '%s' found in '%s'"] = "Unknown property '%s' found in '%s'"
	L["Unknown Spell"] = "Unknown Spell"
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."
	L["Update"] = "Update"
	L["Update Auras"] = "Update Auras"
	L["Update Custom Text On..."] = "Update Custom Text On..."
	L["URL"] = "URL"
	L["Url: %s"] = "Url: %s"
	L["Use Display Info Id"] = "Use Display Info Id"
	L["Use SetTransform"] = "Use SetTransform"
	L["Used in Auras:"] = "Used in Auras:"
	L["Used in auras:"] = "Used in auras:"
	L["Uses Texture Coordinates to rotate the texture."] = "Uses Texture Coordinates to rotate the texture."
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."
	L["Value"] = "Value"
	L["Value %i"] = "Value %i"
	L["Values are in normalized rgba format."] = "Values are in normalized rgba format."
	L["Values/Remaining Time above this value are displayed as full progress."] = "Values/Remaining Time above this value are displayed as full progress."
	L["Values/Remaining Time below this value are displayed as zero progress."] = "Values/Remaining Time below this value are displayed as zero progress."
	L["Values:"] = "Values:"
	L["Version: "] = "Version: "
	L["Version: %s"] = "Version: %s"
	L["Vertical Align"] = "Vertical Align"
	L["Vertical Bar"] = "Vertical Bar"
	L["View"] = "View"
	L["View custom code"] = "View custom code"
	L["Voice Settings"] = "Voice Settings"
	L["We thank"] = "We thank"
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s on WoW %s"
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	L["What do you want to do?"] = "What do you want to do?"
	L["Whole Area"] = "Whole Area"
	L["wrapping"] = "wrapping"
	L["X Offset"] = "X Offset"
	L["X Rotation"] = "X Rotation"
	L["X Scale"] = "X Scale"
	L["x-Offset"] = "x-Offset"
	L["Y Offset"] = "Y Offset"
	L["Y Rotation"] = "Y Rotation"
	L["Y Scale"] = "Y Scale"
	L["Yellow Rune"] = "Yellow Rune"
	L["y-Offset"] = "y-Offset"
	L["You already have this group/aura. Importing will create a duplicate."] = "You already have this group/aura. Importing will create a duplicate."
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."
	L["Your Saved Snippets"] = "Your Saved Snippets"
	L["Z Offset"] = "Z Offset"
	L["Z Rotation"] = "Z Rotation"
	L["Zoom In"] = "Zoom In"
	L["Zoom Out"] = "Zoom Out"


=== END OF FILE: WeakAurasOptions/Locales/enUS.lua ===


=== FILE: WeakAurasOptions/Locales/esES.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "esES" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = "y |cFFFF0000reflejado|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- No elimines este comentario, forma parte de esta aura:"
	L[" rotated |cFFFF0000%s|r degrees"] = "rotado |cFFFF0000%s|r grados"
	L["% - To show a percent sign"] = "% - Para mostrar un signo de porcentaje"
	L["% of Progress"] = "% de progreso"
	L["%d |4aura:auras; added"] = "%d |4aura:auras; aadida(s)"
	L["%d |4aura:auras; deleted"] = "%d |4aura:auras; eliminada(s)"
	L["%d |4aura:auras; modified"] = "%d |4aura:auras; modificada(s)"
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; con metadatos modificados"
	L["%d displays loaded"] = "%d visualizaciones cargadas"
	L["%d displays not loaded"] = "%d visualizaciones no cargadas"
	L["%d displays on standby"] = "%d visualizaciones en espera"
	L["%i auras selected"] = "%i auras seleccionadas"
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i. Activador"
	L["%s - Alpha Animation"] = "%s - Transparencia de animacin"
	L["%s - Color Animation"] = "%s - Animacin de color"
	L["%s - Condition Custom Chat %s"] = "%s - Condicin de chat personalizado %s"
	L["%s - Condition Custom Check %s"] = "%s - Condicin de comprobacin personalizada %s"
	L["%s - Condition Custom Code %s"] = "%s - Condicin de cdigo personalizado %s"
	L["%s - Custom Anchor"] = "%s - Ancla personalizada"
	L["%s - Custom Grow"] = "%s - Crecimiento personalizado"
	L["%s - Custom Sort"] = "%s - Orden personalizado"
	L["%s - Custom Text"] = "%s - Texto personalizado"
	L["%s - Finish"] = "%s - Terminacin"
	L["%s - Finish Action"] = "%s - Accin de terminacin"
	L["%s - Finish Custom Text"] = "%s - Texto personalizado de terminacin"
	L["%s - Init Action"] = "%s - Iniciar accin"
	L["%s - Main"] = "%s - Principal"
	L["%s - OnLoad"] = "%s - Cargar"
	L["%s - OnUnload"] = "%s - Descargar"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - La opcin #%i tiene un clave %s. Por favor selecciona un clave diferente."
	L["%s - Rotate Animation"] = "%s - Rotar animacin"
	L["%s - Scale Animation"] = "%s - Redimensionar animacin"
	L["%s - Start"] = "%s - Iniciar"
	L["%s - Start Action"] = "%s - Iniciar accin"
	L["%s - Start Custom Text"] = "%s - Iniciar texto personalizado"
	L["%s - Translate Animation"] = "%s - Traducir animacin"
	L["%s - Trigger Logic"] = "%s - Lgica de activacin"
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, Lneas: %d, Frecuencia: %0.2f, Longitud: %d, Espesor: %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, Partculas: %d, Frecuencia: %0.2f, Escala: %0.2f"
	L["%s %u. Overlay Function"] = "%s %u. Funcin de superposicin"
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s Transparencia: %d%%"
	L["%s Color"] = "%s Color"
	L["%s Custom Variables"] = "%s Variables personalizadas"
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s Transparencia por defecto, Zoom, Insercin de iconos, Relacin de aspecto"
	L["%s Duration Function"] = "%s Funcin de duracin"
	L["%s Icon Function"] = "%s Funcin de icono"
	L["%s Inset: %d%%"] = "%s Insercin: %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s no es un vlido SubEvent para COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s Mantener relacin de aspecto"
	L["%s Name Function"] = "%s Funcin de nombre"
	L["%s Stacks Function"] = "%s Funcin de acumulaciones"
	L["%s stores around %s KB of data"] = "%s almacena alrededor de %s KB de datos"
	L["%s Texture"] = "%s Textura"
	L["%s Texture Function"] = "%s Funcin de textura"
	L["%s total auras"] = "%s auras en total"
	L["%s Trigger Function"] = "%s Funcin de activador"
	L["%s Untrigger Function"] = "%s Funcin de no-activador"
	L["%s X offset by %d"] = "%s desplazamiento X por %d"
	L["%s Y offset by %d"] = "%s desplazamiento Y por %d"
	L["%s Zoom: %d%%"] = "%s Zoom: %d%%"
	L["%s, Border"] = "%s, Borde"
	L["%s, Offset: %0.2f;%0.2f"] = "%s, Desplazamiento: %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, desplazamiento: %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s, Iniciar animacin"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000textura personalizada|r con |cFFFF0000%s|r modo de mezcla%s%s"
	L["(Right click to rename)"] = "(Clic derecho para cambiar el nombre)"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02xColor personalizado|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999Los activadores que rastreen varias unidades se activarn por defecto aunque no se encuentren unidades afectadas sin que se aplique un ajuste de Recuento de unidades o Recuento de coincidencias.|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000Nota:|r Esto establece la descripcin solo en '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000Nota:|r Esto establece la URL en todas las auras seleccionadas"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000Nota:|r Esto establece la URL en este grupo y todos sus miembros."
	L["|cFFFF0000Automatic|r length"] = "Longitud |cFFFF0000Automtica|r"
	L["|cFFFF0000default|r texture"] = "textura |cFFFF0000predeterminada|r"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000desaturado|r"
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000Nota:|r La unidad '%s' no es una unidad rastreable."
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000Nota:|r La unidad '%s' requiere que las cvars de objetivos flexibles estn habilitadas."
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anclas:|r anclado |cFFFF0000%s|r al |cFFFF0000%s|r del marco"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anclas:|r anclado |cFFFF0000%s|r al |cFFFF0000%s|r del marco con compensacin |cFFFF0000%s/%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anclas:|r anclado al |cFFFF0000%s|r del marco"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anclas:|r anclado al |cFFFF0000%s|r del marco con compensacin |cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00Opciones adicionales:|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00Extra:|r %s y %s %s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00Marcas de fuente:|r |cFFFF0000%s|r y |c%sColor|r de sombra con desplazamiento |cFFFF0000%s/%s|r%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00Marcas de fuente:|r |cFFFF0000%s|r y |c%sColor|r de sombra con desplazamiento |cFFFF0000%s/%s|r%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cffffcc00Opciones de formato|r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = " |cff00ff00Jugador|r, |cff00ff00Objetivo|r, |cff00ff00Enfoque|r y |cff00ff00Mascota|r corresponden directamente a esos ID de unidad individuales.  |cff00ff00Unidad especfica|r te permite proporcionar un ID de unidad vlido especfico para observar. |cffff0000Nota|r: El juego no activar eventos para todos los ID de unidad vlidos, lo que har que este activador no pueda rastrear algunos.  |cffffff00Grupo|r, |cffffff00Banda|r, |cffffff00Jefe|r, |cffffff00Arena|r y |cffffff00Placa de nombre|r pueden coincidir con mltiples ID de unidad correspondientes.  |cffffff00Grupo inteligente|r se ajusta a tu tipo de grupo actual, haciendo coincidir solo el \"jugador\" cuando ests solo, las unidades de \"grupo\" (incluido el \"jugador\") en un grupo o las unidades de \"banda\" en una banda.  |cffffff00Objetivos mltiples|r intenta utilizar los eventos del registro de combate, en lugar del ID de unidad, para rastrear las unidades afectadas. |cffff0000Nota|r: Sin una relacin directa con los ID de unidad reales, los resultados pueden variar. |cffffff00*|r Los ajustes de unidades amarillas puede coincidir con varias unidades y estar activa de forma predeterminada incluso cuando no se encuentren unidades afectadas sin un ajuste de recuento de unidades o recuento de coincidencias."
	L["A 20x20 pixels icon"] = "Un icono de 20x20 pxeles"
	L["A 32x32 pixels icon"] = "Un icono de 32x32 pxeles"
	L["A 40x40 pixels icon"] = "Un icono de 40x40 pxeles"
	L["A 48x48 pixels icon"] = "Un icono de 48x48 pxeles"
	L["A 64x64 pixels icon"] = "Un icono de 64x64 pxeles"
	L["A group that dynamically controls the positioning of its children"] = "Un grupo que controla dinmicamente la posicin de sus hijos"
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = "Un temporizador se mostrar automticamente de acuerdo con la configuracin predeterminada de la interfaz (anulada por algunos addons). Activa esta opcin si quieres que el temporizador est oculto, o cuando utilices un texto de WeakAuras para mostrar el temporizador."
	L["A Unit ID (e.g., party1)."] = "Una ID de unidad (ej., party1)."
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = "Informacin y filtros del aura activa"
	L["Actual Spec"] = "Especializacin actual"
	L["Add %s"] = "Aadir %s"
	L["Add a new display"] = "Aadir una nueva aura"
	L["Add Condition"] = "Aadir condicin"
	L["Add Entry"] = "Aadir entrada"
	L["Add Extra Elements"] = "Aadir elementos extra"
	L["Add Option"] = "Aadir opcin"
	L["Add Overlay"] = "Aadir superposicin"
	L["Add Property Change"] = "Aadir cambio de propiedad"
	L["Add Snippet"] = "Aadir snippet"
	L["Add Sub Option"] = "Aadir opcin secundaria"
	L["Add to group %s"] = "Aadir al grupo %s"
	L["Add to new Dynamic Group"] = "Aadir al nuevo grupo dinmico"
	L["Add to new Group"] = "Aadir al nuevo grupo"
	L["Add Trigger"] = "Aadir activador"
	L["Additional Events"] = "Eventos adicionales"
	L["Advanced"] = "Avanzado"
	L["Affected Unit Filters and Info"] = "Informacin y filtros de las unidades afectadas"
	L["Align"] = "Alinear"
	L["Alignment"] = "Alineamiento"
	L["All maintainers of the libraries we use, especially:"] = "Todos los responsables del mantenimiento de las bibliotecas que utilizamos, especialmente:"
	L["All of"] = "Todo"
	L["Allow Full Rotation"] = "Permitir rotacin completa"
	L["Anchor"] = "Ancla"
	L["Anchor Mode"] = "Modo de anclaje"
	L["Anchor Point"] = "Punto de anclaje"
	L["Anchored To"] = "Anclado a"
	L["And "] = "y"
	L["and"] = "y"
	L["and %s"] = "y %s"
	L["and aligned left"] = "y alineado a la izquierda"
	L["and aligned right"] = "y alineado a la derecha"
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "Y nuestros Patreons, usuarios regulares de Discord y suscriptores, y amigos del addon:"
	L["and rotated left"] = "y girado a la izquierda"
	L["and rotated right"] = "y girado a la derecha"
	L["and with width |cFFFF0000%s|r and %s"] = "y con anchura |cFFFF0000%s|r y %s"
	L["Angle"] = "ngulo"
	L["Angle Between Auras"] = "Anglo entre auras"
	L["Animate"] = "Animar"
	L["Animated Expand and Collapse"] = "Ampliar y contraer animado"
	L["Animates progress changes"] = "Anima los cambios de progreso"
	L["Animation End"] = "Fin de la animacin"
	L["Animation Mode"] = "Modo de animacin"
	L["Animation relative duration description"] = [=[Duracin de la animacin relativa a la duracin del aura, expresado en fracciones (1/2), porcentaje (50%),  o decimales (0.5).
|cFFFF0000Nota:|r si el aura no tiene progreso (por ejemplo, si no tiene un activador basado en tiempo, si el aura no tiene duracin, etc.), la animacin no correr.

|cFF4444FFPor Ejemplo:|r
Si la duracin de la animacin es |cFF00CC0010%|r, y el disparador del aura es un beneficio que dura 20 segundos, la animacin de entrada se mostrar por 2 segundos.
Si la duracin de la animacin es |cFF00CC0010%|r, y el disparador del aura es un beneficio sin tiempo asignado, la animacin de entrada se ignorar."
]=]
	L["Animation Sequence"] = "Secuencia de Animacin"
	L["Animation Start"] = "Inicio de la animacin"
	L["Any of"] = "Cualquiera de"
	L["Apply Template"] = "Aplicar plantilla"
	L["Arcane Orb"] = "Orbe arcano"
	L["Area"] = "rea"
	L["At a position a bit left of Left HUD position."] = "En una posicin un poco a la izquierda de la posicin izquierda del HUD."
	L["At a position a bit left of Right HUD position"] = "En una posicin un poco a la izquierda de la posicin derecha del HUD"
	L["At the same position as Blizzard's spell alert"] = "En la misma posicin que la alerta de hechizo de Blizzard"
	L["Attach to Foreground"] = "Adjuntar al primer plano"
	L[ [=[Aura is
Off Screen]=] ] = "El aura est fuera de la pantalla"
	L["Aura Name Pattern"] = "Patrn del nombre del aura"
	L["Aura Order"] = "Orden de auras"
	L["Aura received from: %s"] = "Aura recibida de: %s"
	L["Aura: '%s'"] = "Aura: '%s'"
	L["Auto-Clone (Show All Matches)"] = "Autoclonar (mostrar todas las coincidencias)"
	L["Automatic length"] = "Longitud automtica"
	L["Backdrop Color"] = "Color de fondo"
	L["Backdrop in Front"] = "Fondo delante"
	L["Backdrop Style"] = "Estilo de fondo"
	L["Background Inner"] = "Fondo interior"
	L["Background Offset"] = "Desplazamiento del Fondo"
	L["Background Texture"] = "Textura del Fondo"
	L["Bar Alpha"] = "Transparencia de la barra"
	L["Bar Color Settings"] = "Configuracin de color de barra"
	L["Big Icon"] = "Icono grande"
	L["Blend Mode"] = "Modo de mezcla"
	L["Blue Rune"] = "Runa azul"
	L["Blue Sparkle Orb"] = "Orbe de brillo azul"
	L["Border %s"] = "Borde %s"
	L["Border Anchor"] = "Ancla del borde"
	L["Border Color"] = "Color de borde"
	L["Border in Front"] = "Borde en frente"
	L["Border Inset"] = "Borde del recuadro"
	L["Border Offset"] = "Desplazamiento de Borde"
	L["Border Settings"] = "Configuracin de bordes"
	L["Border Size"] = "Tamao del borde"
	L["Border Style"] = "Estilo de borde"
	L["Bracket Matching"] = "Coincidencia de soportes"
	L["Browse Wago, the largest collection of auras."] = "Explora Wago, la mayor coleccin de auras."
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "Por defecto, esto muestra la informacin del disparador seleccionado a travs de informacin dinmica. La informacin de un disparador especfico puede mostrarse mediante, por ejemplo, %2.p."
	L["Can be a UID (e.g., party1)."] = "Puede ser un UID (por ejemplo, party1)."
	L["Can set to 0 if Columns * Width equal File Width"] = "Puede ponerse a 0 si Columnas * Anchura es igual a Anchura de fila"
	L["Can set to 0 if Rows * Height equal File Height"] = "Puede ponerse a 0 si Filas * Altura es igual a Altura de fila"
	L["Case Insensitive"] = "Insensible a maysculas/minsculas"
	L["Cast by a Player Character"] = "Lanzado por un personaje de jugador"
	L["Categories to Update"] = "Categoras a actualizar"
	L["Changelog"] = "Registro de cambios"
	L["Chat with WeakAuras experts on our Discord server."] = "Chatea con los expertos de WeakAuras en nuestro servidor Discord."
	L["Check On..."] = "Chequear..."
	L["Check out our wiki for a large collection of examples and snippets."] = "Consulta nuestra wiki para ver una amplia coleccin de ejemplos y snippets."
	L["Children:"] = "Hijo:"
	L["Choose"] = "Escoger"
	L["Circular Texture %s"] = "Textura circular de %s"
	L["Clear Debug Logs"] = "Borrar registros de depuracin"
	L["Clear Saved Data"] = "Borrar datos guardados"
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	L["Clip Overlays"] = "Superposiciones recortadas"
	L["Clipped by Foreground"] = "Recortado por el primer plano"
	L["Close"] = "Cerrar"
	L["Code Editor"] = "Editor de cdigo"
	L["Collapse"] = "Contraer"
	L["Collapse all loaded displays"] = "Contraer todas las auras"
	L["Collapse all non-loaded displays"] = "Contraer todas las auras no cargadas"
	L["Collapse all pending Import"] = "Contraer todas las importaciones pendientes"
	L["Collapsible Group"] = "Grupo contrable"
	L["color"] = "color"
	L["Column Height"] = "Altura de columna"
	L["Column Space"] = "Espacio de columna"
	L["Columns"] = "Columnas"
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "COMBAT_LOG_EVENT_UNFILTERED sin filtro puede provocar cadas de frames en entornos de bandas."
	L["Combinations"] = "Combinaciones"
	L["Combine Matches Per Unit"] = "Combinar encuentros por unidad"
	L["Common Text"] = "Texto comn"
	L["Compare against the number of units affected."] = "Comparar con el nmero de unidades afectadas."
	L["Compatibility Options"] = "Opciones de compatibilidad"
	L["Compress"] = "Comprimir"
	L["Configure what options appear on this panel."] = "Configura qu opciones aparecen en este panel."
	L["Constant Factor"] = "Factor Constante"
	L["Control-click to select multiple displays"] = "Control clic para seleccionar varias visualizaciones"
	L["Controls the positioning and configuration of multiple displays at the same time"] = "Controla la posicin y configuracin de varias auras a la vez"
	L["Convert to..."] = "Convertir a..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "Los nmeros de reutilizacin pueden ser aadidos por WoW. Puedes configurarlos en los ajustes del juego."
	L["Copy"] = "Copiar"
	L["Copy settings..."] = "Copiar configuracin..."
	L["Copy to all auras"] = "Copiar a todas las auras"
	L["Could not parse '%s'. Expected a table."] = "No se ha podido procesar '%s'. Se esperaba una tabla."
	L["Counts the number of matches over all units."] = "Cuenta el nmero de coincidencias en todas las unidades."
	L["Counts the number of matches per unit."] = "Cuenta el nmero de coincidencias por unidad."
	L["Create a Copy"] = "Crear una copia"
	L["Creating buttons: "] = "Crear pulsadores: "
	L["Creating options: "] = "Crear opciones: "
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "Personalizado - Te permite definir una funcin Lua personalizada que devuelve una lista de valores en cadena. %c1 ser reemplazado por el primer valor devuelto, %c2 por el segundo, etc."
	L["Custom Code"] = "Cdigo Personalizado"
	L["Custom Code Viewer"] = "Visor de cdigo personalizado"
	L["Custom Frames"] = "Marcos personalizados"
	L["Custom Functions"] = "Funciones personalizadas"
	L["Custom Init"] = "Inicializacin personalizada"
	L["Custom Load"] = "Carga personalizada"
	L["Custom Options"] = "Opciones personalizadas"
	L["Custom Text Update Throttle"] = "Limitador de actualizacin de texto personalizado"
	L["Custom Trigger"] = "Activador personalizado"
	L["Custom trigger event tooltip"] = "Informacin sobre eventos de activador personalizado"
	L["Custom trigger status tooltip"] = "Informacin sobre el estado del activador personalizado"
	L["Custom trigger Update Throttle"] = "Limitador de actualizacin de disparador personalizado"
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "Activador personalizado: ignorar errores de Lua en el evento OPCIONES"
	L["Custom Trigger: Send fake events instead of STATUS event"] = "Activador personalizado: enviar eventos falsos en lugar del evento STATUS"
	L["Custom Unload"] = "Descarga personalizada"
	L["Custom Untrigger"] = "No-activador personalizado"
	L["Debug Log"] = "Registro de depuracin"
	L["Debug Log:"] = "Registro de depuracin:"
	L["Default"] = "Por defecto"
	L["Default Color"] = "Color por defecto"
	L["Delay"] = "Retardo"
	L["Delete"] = "Eliminar"
	L["Delete all"] = "Eliminar todo"
	L["Delete children and group"] = "Eliminar grupo e hijos"
	L["Delete Entry"] = "Eliminar entrada"
	L["Deleting auras: "] = "Eliminando auras:"
	L["Description Text"] = "Texto de descripcin"
	L["Determines how many entries can be in the table."] = "Determina cuntas entradas puede haber en la tabla."
	L["Differences"] = "Diferencias"
	L["Disallow Entry Reordering"] = "No permitir la reordenacin de entradas"
	L["Discord"] = "Discord"
	L["Display Name"] = "Nombre de visualizacin"
	L["Display Text"] = "Mostrar Texto"
	L["Displays a text, works best in combination with other displays"] = "Muestra un texto, funciona mejor en combinacin con otras visualizaciones"
	L["Distribute Horizontally"] = "Distribucin Horizontal"
	L["Distribute Vertically"] = "Distribucin Vertical"
	L["Do not group this display"] = "No agrupa esta visualizacin"
	L["Do you want to enable updates for this aura"] = "Quieres habilitar actualizaciones para esta aura?"
	L["Do you want to ignore updates for this aura"] = "Quieres ignorar actualizaciones para esta aura?"
	L["Documentation"] = "Documentacin"
	L["Done"] = "Hecho"
	L["Drag to move"] = "Arrastra para mover"
	L["Duplicate"] = "Duplicar"
	L["Duplicate All"] = "Duplicar todo"
	L["Duration (s)"] = "Duracin (s)"
	L["Duration Info"] = "Informacin de Duracin"
	L["Dynamic Duration"] = "Duracin dinmica"
	L["Dynamic Group"] = "Grupo dinmico"
	L["Dynamic Group Settings"] = "Configuracin de grupos dinmicos"
	L["Dynamic Information"] = "Informacin dinmica"
	L["Dynamic information from first active trigger"] = "Informacin dinmica del primer activador activo"
	L["Dynamic information from Trigger %i"] = "Informacin dinmica del activador %i"
	L["Dynamic Text Replacements"] = "Reemplazos de texto dinmico"
	L["Ease Strength"] = "Fuerza"
	L["Ease type"] = "Tipo"
	L["eliding"] = "omitiendo"
	L["Else If"] = "Si ms"
	L["Else If %s"] = "Ms si %s"
	L["Empty Base Region"] = "Regin base vaca"
	L["Enable \"Edge\" part of the overlay"] = "Activar la zona \"Borde\" de la superposicin"
	L["Enable \"swipe\" part of the overlay"] = "Activar la funcin \"barrido\" de la superposicin"
	L["Enable Debug Log"] = "Activar registro de depuracin"
	L["Enable Debug Logging"] = "Activar el registro de depuracin"
	L["Enable Gradient"] = "Activar degradado"
	L["Enable Swipe"] = "Activar barrido"
	L["Enable the \"Swipe\" radial overlay"] = "Activar la superposicin radial de \"barrido\""
	L["Enabled"] = "Activado"
	L["End Angle"] = "ngulo final"
	L["End of %s"] = "Fin de %s"
	L["Enemy nameplate(s) found"] = "Placa(s) de enemigo(s) encontrada(s)"
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "Escribe un ID de hechizo. Puedes usar el addon idTip para averiguar los IDs de los hechizos."
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = "Introduce un nombre de aura, un nombre de aura parcial o un ID de hechizo. Un ID de hechizo coincidir con cualquier hechizo que tenga el mismo nombre."
	L["Enter Author Mode"] = "Acceder al modo autor"
	L["Enter in a value for the tick's placement."] = "Introduce un valor para la colocacin del tic."
	L["Enter static or relative values with %"] = "Ingrese valores estticos o relativos con %"
	L["Enter User Mode"] = "Acceder al modo usuario"
	L["Enter user mode."] = "Accede al modo usuario."
	L["Entry %i"] = "Entrada %i"
	L["Entry limit"] = "Lmite de entrada"
	L["Entry Name Source"] = "Fuente del nombre de entrada"
	L["Event Type"] = "Tipo de Evento"
	L["Everything"] = "Todo"
	L["Exact Item Match"] = "Coincidencia exacta de objeto"
	L["Exact Spell Match"] = "Coincidencia exacta de hechizo"
	L["Expand"] = "Ampliar"
	L["Expand all loaded displays"] = "Ampliar todas las auras"
	L["Expand all non-loaded displays"] = "Ampliar todas las auras no cargadas"
	L["Expand all pending Import"] = "Ampliar todas las importaciones pendientes"
	L["Expansion is disabled because this group has no children"] = "La expansin est desactivada porque este grupo no tiene hijos"
	L["Export debug table..."] = "Exportar tabla de depuracin..."
	L["Export..."] = "Exportar..."
	L["Exporting"] = "Exportando"
	L["External"] = "Externo"
	L["Extra Height"] = "Altura extra"
	L["Extra Width"] = "Anchura extra"
	L["Fade"] = "Apagar"
	L["Fadeout Sound"] = "Sonido de desvanecimiento"
	L["Fadeout Time (seconds)"] = "Tiempo de desvanecimiento (segundos)"
	L["Fetch Affected/Unaffected Names and Units"] = "Obtener nombres y unidades afectados / no afectados"
	L["Fetch Raid Mark Information"] = "Obtener informacin sobre la marca de banda"
	L["Fetch Role Information"] = "Obtener informacin del rol"
	L["Fetch Tooltip Information"] = "Obtener informacin del tooltip"
	L["File Height"] = "Altura de archivo"
	L["File Width"] = "Anchura de archivo"
	L["Filter based on the spell Name string."] = "Filtro basado en la cadena del nombre del hechizo."
	L["Filter by Arena Spec"] = "Filtrar por especializacin de arena"
	L["Filter by Class"] = "Filtrar por clase"
	L["Filter by Group Role"] = "Filtrar por rol de grupo"
	L["Filter by Hostility"] = "Filtrar por hostilidad"
	L["Filter by Npc ID"] = "Filtrar por ID de PNJ"
	L["Filter by Raid Role"] = "Filtrar por rol de banda"
	L["Filter by Specialization"] = "Filtrar por especializacin"
	L["Filter by Unit Name"] = "Filtrar por nombre de unidad"
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = "Formatos de filtro: 'Nombre', 'Nombre-Reino', '-Reino'. Admite varias entradas, separadas por comas. Puedes utilizar \\ para escapar -."
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = "Filtrar solo los perjuicios/beneficios de tipo clasificable como Sangrar mediante LibDispel"
	L["Find Auras"] = "Encontrar auras"
	L["Finish"] = "Finalizar"
	L["Finishing..."] = "Finalizando..."
	L["Fire Orb"] = "Orbe de fuego"
	L["Flat Framelevels"] = "Niveles de marco plano"
	L["Foreground Texture"] = "Textura Frontal"
	L["Format for %s"] = "Formato para %s"
	L["Found a Bug?"] = "Has encontrado un error?"
	L["Frame"] = "Marco"
	L["Frame Count"] = "Recuento de fotogramas"
	L["Frame Height"] = "Altura de marco"
	L["Frame Rate"] = "Cuadros por segundo"
	L["Frame Strata"] = "Estrato del marco"
	L["Frame Width"] = "Anchura de marco"
	L["Full Bar"] = "Barra llena"
	L["Full Circle"] = "Crculo completo"
	L["Global Conditions"] = "Condiciones globales"
	L["Glow %s"] = "Resplandor %s"
	L["Glow Action"] = "Accin de resplandor"
	L["Glow Anchor"] = "Ancla de resplandor"
	L["Glow Color"] = "Color del resplandor"
	L["Glow Frame Type"] = "Tipo de marco de resplandor"
	L["Glow Type"] = "Tipo de resplandor"
	L["Green Rune"] = "Runa verde"
	L["Grid direction"] = "Direccin de la rejilla"
	L["Group (verb)"] = "Grupo (verbo)"
	L["Group Alpha"] = "Transparencia del grupo"
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = "Agrupar y anclar cada aura por marco. - Placas de nombre: adjuntar a placas por unidad. - Marcos de unidad: adjuntar a botones de marco de unidad por unidad. - Marcos personalizados: elige a qu marco debe anclarse cada regin."
	L["Group aura count description"] = [=[La cantidad de miembros del grupo o banda que deben estar afectados por las auras indicadas para la activacin.
Si el nmero introducido es un entero (ej. 5), la cantidad de miembros del grupo o banda que deben estar afectados ser absoluta.
Si el nmero introducido es una fraccin (1/2), decimal (0.5) o porcentaje (50%%), se interpretar como que la cantidad de miembros del grupo o banda que deben estar afectados es una fraccin del total.

|cFF4444FFPor ejemplo:|r
Con |cFF00CC00> 0|r se activar cuando cualquier miembro del grupo o banda est afectado.
Con |cFF00CC00= 100%%|r se activar cuando todos los miembros del grupo o banda estn afectados.
Con |cFF00CC00!= 2|r se activar cuando el nmero de miembros del grupo o banda afectados no sea 2.
Con |cFF00CC00<= 0.8|r se activar cuando menos del 80%% del grupo o banda est afectado (4 de 5 miembros en grupos, 8 de 10  20 de 25 en bandas).
Con |cFF00CC00> 1/2|r se activar cuando ms de la mitad de miembros del grupo o banda estn afectados.
Con |cFF00CC00>= 0|r se activar siempre.]=]
	L["Group by Frame"] = "Agrupar por marco"
	L["Group Description"] = "Descripcin del grupo"
	L["Group Icon"] = "Icono de grupo"
	L["Group key"] = "Clave de grupo"
	L["Group Options"] = "Opciones de grupo"
	L["Group player(s) found"] = "Jugador(es) de grupo encontrado(s)"
	L["Group Role"] = "Rol de grupo"
	L["Group Scale"] = "Escala de grupo"
	L["Group Settings"] = "Configuracin de grupo"
	L["Hawk"] = "Halcn"
	L["Help"] = "Ayuda"
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	L["Hide Background"] = "Ocultar fondo"
	L["Hide Glows applied by this aura"] = "Ocultar resplandor aplicado por esta aura"
	L["Hide on"] = "Ocultar en"
	L["Hide this group's children"] = "Ocultar los hijos de este grupo"
	L["Highlights"] = "Resaltados"
	L["Horizontal Align"] = "Alineado Horizontal"
	L["Horizontal Bar"] = "Barra horizontal"
	L["Huge Icon"] = "Icono enorme"
	L["Hybrid Position"] = "Posicin de hbrido"
	L["Hybrid Sort Mode"] = "Modo de orden hbrido"
	L["Icon - The icon associated with the display"] = "Icono - El icono asociado con la visualizacin"
	L["Icon Info"] = "Informacin del Icono"
	L["Icon Inset"] = "Interior del Icono"
	L["Icon Picker"] = "Selector de iconos"
	L["Icon Position"] = "Posicin del icono"
	L["Icon Settings"] = "Confirugacin de icono"
	L["Icon Source"] = "Fuente del icono"
	L["If"] = "Si"
	L["If %s"] = "Si %s"
	L["If checked, then the combo box in the User settings will be sorted."] = "Si est marcada, entonces la lista desplegable en la configuracin de usuario se ordenar."
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "Si est marcada, el usuario ver un cuadro de edicin de varias lneas. Esto es til para introducir grandes cantidades de texto."
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "Si est marcada, este grupo no se fusionar con otro grupo al seleccionar varias auras."
	L["If checked, then this option group can be temporarily collapsed by the user."] = "Si est marcada, el usuario puede contraer temporalmente este grupo de opciones."
	L["If checked, then this option group will start collapsed."] = "Si est marcada, este grupo de opciones comenzar colapsado."
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "Si est marcada, este separador incluir texto. De lo contrario, ser solo una lnea horizontal."
	L["If checked, then this space will span across multiple lines."] = "Si est marcada, este espacio abarcar varias lneas."
	L["If unchecked, then a default color will be used (usually yellow)"] = "Si no est marcada, se utilizar un color por defecto (normalmente amarillo)"
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "Si no est marcada, este espacio ocupar toda la lnea en la que se encuentre en Modo Usuario."
	L["Ignore out of casting range"] = "Ignorar afuera de alcance"
	L["Ignore out of checking range"] = "Ignorar fuera de rango de comprobacin"
	L["Ignore Wago updates"] = "Ignorar actualizaciones de Wago"
	L["Ignored"] = "Ignorar"
	L["Ignored Aura Name"] = "Nombre de aura ignorado"
	L["Ignored Exact Spell ID(s)"] = "ID de hechizo exacto ignorado"
	L["Ignored Name(s)"] = "Nombres ignorados"
	L["Ignored Spell ID"] = "ID de hechizo ignorado"
	L["Import"] = "Importar"
	L["Import / Export"] = "Importar / Exportar"
	L["Import a display from an encoded string"] = "Importa un aura desde un texto cifrado"
	L["Import as Copy"] = "Importar como copia"
	L["Import has no UID, cannot be matched to existing auras."] = "La importacin no tiene UID y no se puede comparar con auras existentes."
	L["Importing"] = "Importacin"
	L["Importing %s"] = "Importando %s"
	L["Importing a group with %s child auras."] = "Importando un grupo con %s auras hijas."
	L["Importing a stand-alone aura."] = "Importar un aura independiente."
	L["Importing...."] = "Importando...."
	L["Incompatible changes to group region types detected"] = "Se detectaron cambios incompatibles en los tipos de regiones del grupo"
	L["Incompatible changes to group structure detected"] = "Se detectaron cambios incompatibles en la estructura del grupo"
	L["Indent Size"] = "Tamao de sangra"
	L["Inner"] = "Interior"
	L["Insert text replacement codes to make text dynamic."] = "Insertar cdigos de reemplazo de texto para hacer el texto dinmico."
	L["Invalid Item ID"] = "ID de objeto no vlido"
	L["Invalid Item Name/ID/Link"] = "Nombre de objeto/ID/enlace no vlidos"
	L["Invalid Spell ID"] = "ID de hechizo no vlido"
	L["Invalid Spell Name/ID/Link"] = "Nombre de hechizo/ID/enlace no vlido"
	L["Invalid target aura"] = "Aura objetivo no vlida"
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "Tipo no vlido para '%s'. Se esperaba 'bool', 'number', 'select', 'string', 'timer' o 'elapsedTimer'."
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "Tipo no vlido para la propiedad '%s' en '%s'. Se esperaba '%s'."
	L["Inverse Slant"] = "Invertir inclinacin"
	L["Invert the direction of progress"] = "Invertir la direccin del progreso"
	L["Is Boss Debuff"] = "Es perjuicio de jefe"
	L["Is Stealable"] = "Se puede robar"
	L["Is Unit"] = "Es unidad"
	L["Justify"] = "Justificar"
	L["Keep Aspect Ratio"] = "Mantener relacin de aspecto"
	L["Keep your Wago imports up to date with the Companion App."] = "Mantn tus importaciones de Wago actualizadas con la Companion App."
	L["Large Input"] = "Entrada grande"
	L["Leaf"] = "Hoja"
	L["Left 2 HUD position"] = "Posicin de HUD izquierda 2"
	L["Left HUD position"] = "Posicin de HUD izquierda"
	L["Length of |cFFFF0000%s|r"] = "Longitud de |cFFFF0000%s|r"
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = "Lmite"
	L["Line"] = "Lnea"
	L["Linear Texture %s"] = "Textura lineal de %s"
	L["Linked aura: "] = "Aura vinculada:"
	L["Linked Auras"] = "Auras vinculadas"
	L["Load"] = "Cargar"
	L["Loaded"] = "Cargado"
	L["Loaded/Standby"] = "Cargado/en espera"
	L["Lock Positions"] = "Bloquear posiciones"
	L["Low Mana"] = "Man bajo"
	L["Magnetically Align"] = "Alineacin magntica"
	L["Main"] = "Principal"
	L["Manual with %i/%i"] = "Manual con %i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "Coincide con la altura de una barra horizontal o la anchura de una barra vertical."
	L["Max"] = "Mx."
	L["Max Length"] = "Longitud mx."
	L["Maximum"] = "Mximo"
	L["Media Type"] = "Tipo de media"
	L["Medium Icon"] = "Icono medio"
	L["Min"] = "Mn."
	L["Minimum"] = "Mnimo"
	L["Model %s"] = "Modelo %s"
	L["Model Picker"] = "Selector de modelo"
	L["Model Settings"] = "Configuracin de modelo"
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths no se pudo cargar, el addon es %s"
	L["Move Above Group"] = "Mover por encima del grupo"
	L["Move Below Group"] = "Mover debajo del grupo"
	L["Move Down"] = "Mover abajo"
	L["Move Entry Down"] = "Mover entrada hacia abajo"
	L["Move Entry Up"] = "Mover entrada hacia arriba"
	L["Move Into Above Group"] = "Mover al grupo superior"
	L["Move Into Below Group"] = "Mover al grupo inferior"
	L["Move this display down in its group's order"] = "Mueva esta visualizacin hacia abajo en el orden de su grupo"
	L["Move this display up in its group's order"] = "Mueva esta visualizacin hacia arriba en el orden de su grupo"
	L["Move Up"] = "Mover arriba"
	L["Moving auras: "] = "Auras en movimiento:"
	L["Multiple Displays"] = "Mltiples auras"
	L["Multiselect ignored tooltip"] = [=[
|cFFFF0000Ignorado|r - |cFF777777nico|r - |cFF777777Mltiple|r
sta opcin no ser usada al determinar cundo se mostrar el aura]=]
	L["Multiselect multiple tooltip"] = [=[
|cFF777777Ignorado|r - |cFF777777nico|r - |cFF00FF00Mltiple|r
Cualquier combinacin de valores es posible.]=]
	L["Multiselect single tooltip"] = [=[
|cFF777777Ignorado|r - |cFF00FF00nico|r - |cFF777777Mltiple|r
Slo un valor coincidente puede ser escogido.]=]
	L["Must be a power of 2"] = "Debe ser una potencia de 2"
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "Nombre - El nombre de la visualizacin (usualmente un nombre de aura), o el ID de la visualizacin si no hay un nombre dinmico"
	L["Name Info"] = "Informacin del Nombre"
	L["Name Pattern Match"] = "Coincidencia de patrn de nombre"
	L["Name:"] = "Nombre:"
	L["Negator"] = "Negador"
	L["New Aura"] = "Nueva aura"
	L["New Template"] = "Nueva plantilla"
	L["New Value"] = "Nuevo valor"
	L["No Children"] = "Sin dependientes"
	L["No Logs saved."] = "No hay registros guardados."
	L["Not a table"] = "No es una tabla"
	L["Not all children have the same value for this option"] = "No todos los hijos contienen la misma configuracin."
	L["Not Loaded"] = "No cargado"
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "Nota: los mensajes automticos para DECIR y GRITAR estn bloqueados fuera de las instancias."
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "Nota: Esta fuente de progreso no proporciona un valor/duracin total. Se debe establecer un valor/duracin total mediante \"Establecer progreso mximo\"."
	L["Number of Entries"] = "Nmero de entradas"
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3"
	L["OFF"] = "DESACTIVO"
	L["Offer a guided way to create auras for your character"] = "Ofrece una forma guiada de crear auras para tu personaje"
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "Compensado por |cFFFF0000%s|r/|cFFFF0000%s|r"
	L["Offset by 1px"] = "Desplazamiento de 1px"
	L["Okay"] = "Aceptar"
	L["ON"] = "ACTIVO"
	L["On Hide"] = "Ocultar"
	L["On Show"] = "Mostrar"
	L["Only Match auras cast by a player (not an npc)"] = "Coincidir solo con auras lanzadas por un jugador (no un pnj)"
	L["Only match auras cast by people other than the player or their pet"] = "Coincidir solo con auras lanzadas por personas que no sean el jugador o su mascota."
	L["Only match auras cast by the player or their pet"] = "Coincidir solo con auras lanzadas por el jugador o su mascota"
	L["Operator"] = "Operador"
	L["Option %i"] = "Opcin %i"
	L["Option key"] = "Clave de opcin"
	L["Option Type"] = "Tipo de opcin"
	L["Options will open after combat ends."] = "Las opciones se abrirn una vez finalizado el combate."
	L["or"] = "o"
	L["or %s"] = "o %s"
	L["Orange Rune"] = "Runa naranja"
	L["Our translators (too many to name)"] = "Nuestros traductores (demasiados para nombrar)"
	L["Outer"] = "Exterior"
	L["Overflow"] = "Desbordamiento"
	L["Overlay %s Info"] = "Informacin de superposicin %s"
	L["Overlays"] = "Superposiciones"
	L["Own Only"] = "Solo mos"
	L["Paste Action Settings"] = "Pegar configuracin de accin"
	L["Paste Animations Settings"] = "Pegar configuracin de animacin"
	L["Paste Author Options Settings"] = "Pegar configuracin de opciones del autor"
	L["Paste Condition Settings"] = "Pegar configuracin de condiciones"
	L["Paste Custom Configuration"] = "Pegar ajustes personalizados"
	L["Paste Display Settings"] = "Pegar configuracin de visualizacin"
	L["Paste Group Settings"] = "Pegar configuracin de grupo"
	L["Paste Load Settings"] = "Pegar configuracin de carga"
	L["Paste Settings"] = "Pegar configuracin"
	L["Paste text below"] = "Pega el texto a continuacin"
	L["Paste Trigger Settings"] = "Pegar configuracin del activador"
	L["Places a tick on the bar"] = "Coloca una marca en la barra"
	L["Play Sound"] = "Reproducir sonido"
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	L["Portrait Zoom"] = "Zoom del retrato"
	L["Position and Size Settings"] = "Configuracin de posicin y tamao"
	L["Preferred Match"] = "Coincidencia preferida"
	L["Premade Auras"] = "Auras prediseadas"
	L["Premade Snippets"] = "Snippets prefabricados"
	L["Preparing auras: "] = "Preparando auras:"
	L["Press Ctrl+C to copy"] = "Pulsa Ctrl+C para copiar"
	L["Press Ctrl+C to copy the URL"] = "Pulsa Ctrl+C para copiar la URL"
	L["Prevent Merging"] = "Evitar la fusin"
	L["Progress - The remaining time of a timer, or a non-timer value"] = "Progreso - El tiempo restante de un temporizador, o un valor que no es de temporizador"
	L["Progress Bar"] = "Barra de progreso"
	L["Progress Bar Settings"] = "Configuracin de la barra de progreso"
	L["Progress Settings"] = "Configuracin de progreso"
	L["Progress Texture"] = "Textura de progreso"
	L["Progress Texture Settings"] = "Configuracin de textura de progreso"
	L["Purple Rune"] = "Runa morada"
	L["Put this display in a group"] = "Pon esta visualizacin en un grupo."
	L["Range in yards"] = "Rango en yardas"
	L["Ready for Install"] = "Listo para instalar"
	L["Ready for Update"] = "Listo para actualizar"
	L["Re-center X"] = "Re-centrar X"
	L["Re-center Y"] = "Re-centrar Y"
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "ACTIVADOR recproco: # solicitudes sern ignoradas."
	L["Redo"] = "Rehacer"
	L["Regions of type \"%s\" are not supported."] = "Las regiones del tipo \"%s\" no son compatibles."
	L["Remove"] = "Eliminar"
	L["Remove All Sounds"] = "Eliminar todos los sonidos"
	L["Remove All Text To Speech"] = "Eliminar todo el texto a voz"
	L["Remove this display from its group"] = "Elimina esta visualizacin de su grupo."
	L["Remove this property"] = "Eliminar esta propiedad"
	L["Rename"] = "Renombrar"
	L["Repeat After"] = "Repetir despus"
	L["Repeat every"] = "Repetir cada"
	L["Report bugs on our issue tracker."] = "Informa de los errores en nuestro rastreador de problemas."
	L["Require unit from trigger"] = "Requiere unidad del activador"
	L["Required for Activation"] = "Necesario para la activacin"
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "Requiere LibSpecialization, es decir, una versin actualizada de WeakAuras."
	L["Reset all options to their default values."] = "Restablece todas las opciones a sus valores por defecto."
	L["Reset Entry"] = "Restablecer entrada"
	L["Reset to Defaults"] = "Restablecer valores"
	L["Right 2 HUD position"] = "Posicin de HUD derecha 2"
	L["Right HUD position"] = "Posicin de HUD derecha"
	L["Right-click for more options"] = "Clic derecho para ms opciones"
	L["Rotate"] = "Rotacin"
	L["Rotate In"] = "Rotar"
	L["Rotate Out"] = "Rotar"
	L["Rotate Text"] = "Rotar Texto"
	L["Rotation Mode"] = "Modo de rotacin"
	L["Row Space"] = "Espacio de fila"
	L["Row Width"] = "Anchura de fila"
	L["Rows"] = "Filas"
	L["Run on..."] = "Ejecutar por..."
	L["Same"] = "Igual"
	L["Same texture as Foreground"] = "Misma textura que primer plano"
	L["Saved Data"] = "Datos guardados"
	L["Scale Factor"] = "Factor de escala"
	L["Search API"] = "API de bsqueda"
	L["Select Talent"] = "Seleccionar talento"
	L["Select the auras you always want to be listed first"] = "Selecciona las auras que quieres que siempre sean listadas primero"
	L["Selected Frame"] = "Marco seleccionado"
	L["Send To"] = "Envar A"
	L["Separator Text"] = "Texto del separador"
	L["Separator text"] = "Texto del separador"
	L["Set Maximum Progress"] = "Establecer progreso mximo"
	L["Set Minimum Progress"] = "Establecer progreso mnimo"
	L["Set Parent to Anchor"] = "Establecer padre a la ancla"
	L["Set Thumbnail Icon"] = "Establecer icono de miniatura"
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "Establece el marco anclado como el padre del aura, lo que hace que el aura herede atributos como la visibilidad y la escala."
	L["Settings"] = "Configuracin"
	L["Shadow Color"] = "Color de sombras"
	L["Shadow X Offset"] = "Desplazamiento de sombras X"
	L["Shadow Y Offset"] = "Desplazamiento de sombras Y"
	L["Shift-click to create chat link"] = "Mays clic para crear enlace de chat"
	L["Show \"Edge\""] = "Mostrar \"borde\""
	L["Show \"Swipe\""] = "Mostrar \"barrido\""
	L["Show and Clone Settings"] = "Mostrar y clonar configuracin"
	L["Show Border"] = "Mostrar borde"
	L["Show Circular Texture"] = "Mostrar textura circular"
	L["Show Debug Logs"] = "Mostrar registro de depuracin"
	L["Show Glow"] = "Mostrar resplandor"
	L["Show Icon"] = "Mostrar icono"
	L["Show If Unit Does Not Exist"] = "Mostrar si unidad no existe"
	L["Show Linear Texture"] = "Mostrar textura lineal"
	L["Show Matches for"] = "Mostrar coincidencias para"
	L["Show Matches for Units"] = "Mostrar coincidencias para unidades"
	L["Show Model"] = "Mostrar modelo"
	L["Show model of unit "] = "Mostrar modelo de la unidad"
	L["Show Sound Setting"] = "Mostrar configuracin de sonido"
	L["Show Spark"] = "Mostrar chispa"
	L["Show Stop Motion"] = "Mostrar stop motion"
	L["Show Text"] = "Mostrar texto"
	L["Show Text To Speech Setting"] = "Mostrar configuracin de texto a voz"
	L["Show Texture"] = "Mostrar textura"
	L["Show this group's children"] = "Mostrar hijos de este grupo"
	L["Show Tick"] = "Mostrar tic"
	L["Shows a 3D model from the game files"] = "Muestra un modelo 3D directamente de los ficheros de WoW"
	L["Shows a border"] = "Muestra un borde"
	L["Shows a Circular Progress Texture"] = "Muestra una textura de progreso circular"
	L["Shows a custom texture"] = "Muestra una textura"
	L["Shows a glow"] = "Muestra un resplandor"
	L["Shows a Linear Progress Texture"] = "Muestra una textura de progreso lineal"
	L["Shows a model"] = "Muestra un modelo"
	L["Shows a progress bar with name, timer, and icon"] = "Barra de progreso con nombre, temporizador e icono"
	L["Shows a spell icon with an optional cooldown overlay"] = "Muestra un icono de hechizo con una superposicin opcional del cooldown"
	L["Shows a Stop Motion"] = "Muestra una stop motion"
	L["Shows a stop motion texture"] = "Muestra una textura en stop motion"
	L["Shows a Texture"] = "Muestra una textura"
	L["Shows a texture that changes based on duration"] = "Muestra una textura que cambia con el tiempo"
	L["Shows nothing, except sub elements"] = "No muestra nada, excepto los subelementos"
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Muestra una o varias lneas de texto, que pueden incluir informacin dinmica como el progreso o las acumulaciones."
	L["Size"] = "Tamao"
	L["Slant Amount"] = "Cantidad inclinada"
	L["Slant Mode"] = "Modo inclinado"
	L["Slanted"] = "Inclinado"
	L["Slide"] = "Arrastrar"
	L["Slide In"] = "Arrastrar Dentro"
	L["Slide Out"] = "Arrastrar"
	L["Slider Step Size"] = "Tamao de paso del control deslizante"
	L["Small Icon"] = "Icono pequeo"
	L["Smooth Progress"] = "Progreso fluido"
	L["Snippets"] = "Snippets"
	L["Soft Max"] = "Mx. flexible"
	L["Soft Min"] = "Mn. flexible"
	L["Sort"] = "Ordenar"
	L["Sound Channel"] = "Canal de Sonido"
	L["Sound File Path"] = "Ruta al Fichero de Sonido"
	L["Sound Kit ID"] = "ID del kit de sonido"
	L["Space Horizontally"] = "Espacio Horizontal"
	L["Space Vertically"] = "Espacio Vertical"
	L["Spark Settings"] = "Configuracin de chispa"
	L["Spark Texture"] = "Textura de chispa"
	L["Specific Currency ID"] = "ID de moneda especfica"
	L["Spell Selection Filters"] = "Filtros de seleccin de hechizo"
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = "Informacin de Acumulaciones"
	L["Stacks - The number of stacks of an aura (usually)"] = "Acumulaciones - El nmero de acumulaciones de un aura (usualmente)"
	L["Standby"] = "En espera"
	L["Star"] = "Estrella"
	L["Start"] = "Empezar"
	L["Start Angle"] = "Iniciar ngulo"
	L["Start Collapsed"] = "Iniciar colapsado"
	L["Start of %s"] = "Inicio de %s"
	L["Step Size"] = "Tamao de paso"
	L["Stop Motion %s"] = "Stop motion de %s"
	L["Stop Motion Settings"] = "Configuracin de Stop Motion"
	L["Stop Sound"] = "Detener sonido"
	L["Stretched by Foreground"] = "Estirado por primer plano"
	L["Sub Elements"] = "Subelementos"
	L["Sub Option %i"] = "Subopcin %i"
	L["Subevent"] = "Subevento"
	L["Subevent Suffix"] = "Sufijo de subevento"
	L["Swipe Overlay Settings"] = "Configuracin de superposicin de barrido"
	L["Templates could not be loaded, the addon is %s"] = "No se pudieron cargar las plantillas, el addon es %s"
	L["Temporary Group"] = "Grupo Temporal"
	L["Text %s"] = "Texto %s"
	L["Text Color"] = "Color del Texto"
	L["Text Settings"] = "Configuracin de texto"
	L["Texture %s"] = "Textura de %s"
	L["Texture Info"] = "Informacin de textura"
	L["Texture Selection Mode"] = "Modo de seleccin de textura"
	L["Texture Settings"] = "Configuracin de textura"
	L["Texture Wrap"] = "Envoltura de textura"
	L["Texture X Offset"] = "Desplazmiento X de textura"
	L["Texture Y Offset"] = "Desplazmiento Y de textura"
	L["Thanks"] = "Gracias"
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "El addon ElvUI est activado. Podra agregar nmeros de tiempo de reutilizacin al barrido. Puedes configurarlos en la configuracin de ElvUI."
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "El addon OmniCC est activado. Podra agregar nmeros de tiempo de reutilizacin al barrido. Puedes configurarlos en la configuracin de OmniCC."
	L["The duration of the animation in seconds."] = "Duracin de la animacin (en segundos)."
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = [=[La duracin de la animacin en segundos. La animacin de finalizacin no comienza a reproducirse hasta que la visualizacin normalmente estara oculta.
]=]
	L["The group and all direct children will share the same base frame level."] = "El grupo y todos los hijos directos compartirn el mismo nivel de marco base."
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "El nmero de disparador es opcional. Cuando no se especifica un nmero de disparador, se usar el disparador seleccionado a travs de informacin dinmica."
	L["The type of trigger"] = "El tipo de activador"
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "La versin del addon WeakAuras Options %s no coincide con la versin de WeakAuras %s. Si actualizaste el addon mientras el juego estaba en ejecucin, intenta reiniciar World of Warcraft. De lo contrario, intenta reinstalar WeakAuras."
	L["Then "] = "Entonces"
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "Hay varios cdigos especiales disponibles para hacer que este texto sea dinmico. Haz clic para ver una lista con todos los cdigos de texto dinmico."
	L["This adds %raidMark as text replacements."] = "Esto agrega %raidMark como reemplazos de texto."
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "Esto agrega %role, %roleIcon como reemplazos de texto. No hace nada si la unidad no es miembro del grupo."
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "Esto agrega %tooltip, %tooltip1, %tooltip2, %tooltip3 y %tooltip4 como reemplazos de texto y tambin permite filtrar segn el contenido/valores de tooltip."
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = "Esta aura contiene un cdigo Lua personalizado. Asegrate de poder confiar en la persona que lo envi!"
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "Esta aura est marcada como una actualizacin de una aura '%s', pero no se puede usar para actualizar esa aura. Esto suele suceder si se saca una aura de un grupo."
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "Esta aura est marcada como una actualizacin de una aura '%s', pero no se puede usar para actualizar esa aura. Esto suele suceder si se saca una aura de un grupo."
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = "Esta aura fue creada con una versin diferente (%s) de World of Warcraft. Puede que no funcione correctamente!"
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = "Esta aura fue creada con una versin ms nueva de WeakAuras. Actualiza tu versin de WeakAuras o espera la prxima versin antes de instalar esta aura."
	L["This display is currently loaded"] = "Esta visualizacin est actualmente cargada."
	L["This display is not currently loaded"] = "Esta visualizacin no est actualmente cargada."
	L["This display is on standby, it will be loaded when needed."] = "Esta visualizacin est en espera, se cargar cuando sea necesario."
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = [=[Esto permite la recopilacin de registros de depuracin. El cdigo personalizado puede agregar informacin de depuracin al registro a travs de la funcin DebugPrint.
]=]
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "Esta es una versin modificada de tu aura, |cff9900FF%s.|r"
	L["This is a modified version of your group: |cff9900FF%s|r"] = "Esta es una versin modificada de tu grupo, |cff9900FF%s.|r"
	L["This region of type \"%s\" is not supported."] = "Esta regin de tipo \"%s\" no es compatible."
	L["This setting controls what widget is generated in user mode."] = "Este ajuste controla qu widget se genera en el modo de usuario."
	L["Thumbnail Icon"] = "Icono de miniatura"
	L["Tick %s"] = "Tic %s"
	L["Tick Area %s"] = "rea de marcado de %s"
	L["Tick Center %s"] = "Centro de marcado de %s"
	L["Tick Mode"] = "Modo de tic"
	L["Tick Placement"] = "Posicin de tic"
	L["Time in"] = "Contar En"
	L["Tiny Icon"] = "Icono miniatura"
	L["To Frame's"] = "Al marco"
	L["To Group's"] = "Al grupo"
	L["To Personal Ressource Display's"] = "A los recursos del aura personal"
	L["To Region's"] = "A la regin"
	L["To Screen's"] = "A la pantalla"
	L["Toggle the visibility of all loaded displays"] = "Alterar la visibilidad de todas las auras cargadas"
	L["Toggle the visibility of all non-loaded displays"] = "Alterar la visibilidad de todas las auras no cargadas"
	L["Toggle the visibility of this display"] = "Alterar la visibilidad de esta aura"
	L["Tooltip Content"] = "Contenido de la descripcin emergente"
	L["Tooltip on Mouseover"] = "Tooltip al pasar el ratn"
	L["Tooltip Pattern Match"] = "Coincidencia de patrn de tooltip"
	L["Tooltip Text"] = "Texto de tooltip"
	L["Tooltip Value"] = "Valor de tooltip"
	L["Tooltip Value #"] = "Valor # de tooltip"
	L["Top HUD position"] = "Posicin superior de la visualizacin (HUD)"
	L["Total"] = "Total"
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = "Total - La duracin mxima de un temporizador, o un valor mximo que no sea de temporizador"
	L["Total Angle"] = "ngulo total"
	L["Total Time"] = "Tiempo total"
	L["Trigger %i: %s"] = "Activador %i:%s"
	L["Trigger Combination"] = "Combinacin de activadores"
	L["Type 'select' for '%s' requires a values member'"] = "Tipo 'select' para '%s' requiere un miembro de valores'"
	L["Undo"] = "Deshacer"
	L["Ungroup"] = "Desagrupar"
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "La unidad %s no es una unidad vlida para RegisterUnitEvent"
	L["Unit Count"] = "Recuento de unidad"
	L["Unknown"] = "Desconocido"
	L["Unknown Encounter's Spell Id"] = "ID de hechizo de encuentro desconocido"
	L["Unknown property '%s' found in '%s'"] = "Propiedad desconocida '%s' encontrada en '%s'"
	L["Unknown Spell"] = "Hechizo desconocido"
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Ignorar animaciones de inicio y final: la animacin principal se repetir hasta que el aura se oculte."
	L["Update"] = "Actualizar"
	L["Update Auras"] = "Actualizar auras"
	L["Update Custom Text On..."] = "Actualizar Texto Personalizado En..."
	L["URL"] = "URL"
	L["Url: %s"] = "URL: %s"
	L["Use Display Info Id"] = "Utilizar ID de informacin de la visualizacin"
	L["Use SetTransform"] = "Utilizar SetTransform"
	L["Used in Auras:"] = "Utilizado en auras:"
	L["Used in auras:"] = "Utilizado en auras:"
	L["Uses Texture Coordinates to rotate the texture."] = "Utiliza coordenadas de textura para rotar la textura."
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "Utiliza UnitIsVisible() para comprobar si el cliente del juego ha cargado un objeto para esta unidad. Esta distancia es de unos 100 metros. Esto se encuesta cada segundo."
	L["Value"] = "Valor"
	L["Value %i"] = "Valor %i"
	L["Values are in normalized rgba format."] = "Los valores estn en formato rgba normalizado."
	L["Values/Remaining Time above this value are displayed as full progress."] = "Los valores/tiempo restante por encima de este valor se muestran como progreso completo."
	L["Values/Remaining Time below this value are displayed as zero progress."] = "Los valores/tiempo restante por debajo de este valor se muestran como sin progreso."
	L["Values:"] = "Valores:"
	L["Version: "] = "Versin:"
	L["Version: %s"] = "Versin: %s"
	L["Vertical Align"] = "Alineado Vertical"
	L["Vertical Bar"] = "Barra vertical"
	L["View"] = "Ver"
	L["View custom code"] = "Ver cdigo personalizado"
	L["Voice Settings"] = "Configuracin de voz"
	L["We thank"] = "Agradecemos a"
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s en WoW %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	L["What do you want to do?"] = "Qu es lo que quieres hacer?"
	L["Whole Area"] = "rea completa"
	L["wrapping"] = "envolviendo"
	L["X Offset"] = "Desplazamiento X"
	L["X Rotation"] = "Rotacin X"
	L["X Scale"] = "X Escala"
	L["x-Offset"] = "Desplazamiento x"
	L["Y Offset"] = "Desplazamiento Y"
	L["Y Rotation"] = "Rotacin Y"
	L["Y Scale"] = "Y Escala"
	L["Yellow Rune"] = "Runa amarilla"
	L["y-Offset"] = "Desplazamiento y"
	L["You already have this group/aura. Importing will create a duplicate."] = "Ya tienes este grupo/aura. La importacin crear un duplicado."
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "Ests a punto de eliminar aura(s) %d. |cFFFF0000Esto no se puede deshacer!|r Te gustaras continuar?"
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "Ests a punto de eliminar un activador. |cFFFF0000Esto no se puede deshacer!|r Te gustara continuar?"
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "Puedes agregar aqu una lista de valores de estado separados por comas en los que (cuando se modifican) WeakAuras tambin debera ejecutar el cdigo anclaje. WeakAuras siempre ejecutar el cdigo de orden personalizado si incluye \"cambiado\" en esta lista, o cuando se agrega, se elimina, o se reordena una regin"
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "Puedes agregar aqu una lista de valores de estado separados por comas en los que (cuando se modifican) WeakAuras tambin debera ejecutar el cdigo crecimiento. WeakAuras siempre ejecutar el cdigo de orden personalizado si incluye \"cambiado\" en esta lista, o cuando se agrega, se elimina, o se reordena una regin"
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "Puedes agregar aqu una lista de valores de estado separados por comas en los que (cuando se modifican) WeakAuras tambin debera ejecutar el cdigo de orden. WeakAuras siempre ejecutar el cdigo de orden personalizado si incluye \"cambiado\" en esta lista, o cuando se agrega o se elimina una regin"
	L["Your Saved Snippets"] = "Tus snippets guardados"
	L["Z Offset"] = "Desplazamiento Z"
	L["Z Rotation"] = "Rotacin Z"
	L["Zoom In"] = "Acercar"
	L["Zoom Out"] = "Alejar"


=== END OF FILE: WeakAurasOptions/Locales/esES.lua ===


=== FILE: WeakAurasOptions/Locales/esMX.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "esMX" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = "y |cFFFF0000reflejado|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- No elimines este comentario, forma parte de esta aura:"
	L[" rotated |cFFFF0000%s|r degrees"] = "rotado |cFFFF0000%s|r grados"
	L["% - To show a percent sign"] = "% - Para mostrar un signo de porcentaje"
	L["% of Progress"] = "% de progreso"
	L["%d |4aura:auras; added"] = "%d |4aura:auras; aadida(s)"
	L["%d |4aura:auras; deleted"] = "%d |4aura:auras; eliminada(s)"
	L["%d |4aura:auras; modified"] = "%d |4aura:auras; modificada(s)"
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; con metadatos modificados"
	L["%d displays loaded"] = "%d visualizaciones cargadas"
	L["%d displays not loaded"] = "%d visualizaciones no cargadas"
	L["%d displays on standby"] = "%d visualizaciones en espera"
	L["%i auras selected"] = "%i auras seleccionadas"
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i. Activador"
	L["%s - Alpha Animation"] = "%s - Transparencia de animacin"
	L["%s - Color Animation"] = "%s - Animacin de color"
	L["%s - Condition Custom Chat %s"] = "%s - Condicin de chat personalizado %s"
	L["%s - Condition Custom Check %s"] = "%s - Condicin de comprobacin personalizada %s"
	L["%s - Condition Custom Code %s"] = "%s - Condicin de cdigo personalizado %s"
	L["%s - Custom Anchor"] = "%s - Ancla personalizada"
	L["%s - Custom Grow"] = "%s - Crecimiento personalizado"
	L["%s - Custom Sort"] = "%s - Orden personalizado"
	L["%s - Custom Text"] = "%s - Texto personalizado"
	L["%s - Finish"] = "%s - Terminacin"
	L["%s - Finish Action"] = "%s - Accin de terminacin"
	L["%s - Finish Custom Text"] = "%s - Texto personalizado de terminacin"
	L["%s - Init Action"] = "%s - Iniciar accin"
	L["%s - Main"] = "%s - Principal"
	L["%s - OnLoad"] = "%s - Cargar"
	L["%s - OnUnload"] = "%s - Descargar"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - La opcin #%i tiene un clave %s. Por favor selecciona un clave diferente."
	L["%s - Rotate Animation"] = "%s - Rotar animacin"
	L["%s - Scale Animation"] = "%s - Redimensionar animacin"
	L["%s - Start"] = "%s - Iniciar"
	L["%s - Start Action"] = "%s - Iniciar accin"
	L["%s - Start Custom Text"] = "%s - Iniciar texto personalizado"
	L["%s - Translate Animation"] = "%s - Traducir animacin"
	L["%s - Trigger Logic"] = "%s - Lgica de activacin"
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, Lneas: %d, Frecuencia: %0.2f, Longitud: %d, Espesor: %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, Partculas: %d, Frecuencia: %0.2f, Escala: %0.2f"
	L["%s %u. Overlay Function"] = "%s %u. Funcin de superposicin"
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s Transparencia: %d%%"
	L["%s Color"] = "%s Color"
	L["%s Custom Variables"] = "%s Variables personalizadas"
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s Transparencia por defecto, zoom, insercin de iconos, relacin de aspecto"
	L["%s Duration Function"] = "%s Funcin de duracin"
	L["%s Icon Function"] = "%s Funcin de icono"
	L["%s Inset: %d%%"] = "%s Insercin: %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s no es un vlido SubEvent para COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s Mantener relacin de aspecto"
	L["%s Name Function"] = "%s Funcin de nombre"
	L["%s Stacks Function"] = "%s Funcin de acumulaciones"
	L["%s stores around %s KB of data"] = "%s almacena alrededor de %s KB de datos"
	L["%s Texture"] = "%s Textura"
	L["%s Texture Function"] = "%s Funcin de textura"
	L["%s total auras"] = "%s auras en total"
	L["%s Trigger Function"] = "%s Funcin de activador"
	L["%s Untrigger Function"] = "%s Funcin de no-activador"
	L["%s X offset by %d"] = "%s desplazamiento X por %d"
	L["%s Y offset by %d"] = "%s desplazamiento Y por %d"
	L["%s Zoom: %d%%"] = "%s Zoom: %d%%"
	L["%s, Border"] = "%s, Borde"
	L["%s, Offset: %0.2f;%0.2f"] = "%s, Desplazamiento: %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, desplazamiento: %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s, Iniciar animacin"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000textura personalizada|r con |cFFFF0000%s|r modo de mezcla%s%s"
	L["(Right click to rename)"] = "(Clic derecho para cambiar el nombre)"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02xColor personalizado|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999Los activadores que rastreen varias unidades se activarn por defecto aunque no se encuentren unidades afectadas sin que se aplique un ajuste de Recuento de unidades o Recuento de coincidencias.|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000Nota:|r Esto establece la descripcin solo en '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000Nota:|r Esto establece la URL en todas las auras seleccionadas"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000Nota:|r Esto establece la URL en este grupo y todos sus miembros."
	L["|cFFFF0000Automatic|r length"] = "Longitud |cFFFF0000Automtica|r"
	L["|cFFFF0000default|r texture"] = "textura |cFFFF0000predeterminada|r"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000desaturado|r"
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000Nota:|r La unidad '%s' no es una unidad rastreable."
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000Nota:|r La unidad '%s' requiere que las cvars de objetivos flexibles estn habilitadas."
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anclas:|r anclado |cFFFF0000%s|r al |cFFFF0000%s|r del marco"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anclas:|r anclado |cFFFF0000%s|r al |cFFFF0000%s|r del marco con compensacin |cFFFF0000%s/%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anclas:|r anclado al |cFFFF0000%s|r del marco"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anclas:|r anclado al |cFFFF0000%s|r del marco con compensacin |cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00Opciones adicionales:|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00Extra:|r %s y %s %s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00Marcas de fuente:|r |cFFFF0000%s|r y |c%sColor|r de sombra con desplazamiento |cFFFF0000%s/%s|r%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00Marcas de fuente:|r |cFFFF0000%s|r y |c%sColor|r de sombra con desplazamiento |cFFFF0000%s/%s|r%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cffffcc00Opciones de formato|r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = " |cff00ff00Jugador|r, |cff00ff00Objetivo|r, |cff00ff00Enfoque|r y |cff00ff00Mascota|r corresponden directamente a esos ID de unidad individuales.  |cff00ff00Unidad especfica|r te permite proporcionar un ID de unidad vlido especfico para observar. |cffff0000Nota|r: El juego no activar eventos para todos los ID de unidad vlidos, lo que har que este activador no pueda rastrear algunos.  |cffffff00Grupo|r, |cffffff00Banda|r, |cffffff00Jefe|r, |cffffff00Arena|r y |cffffff00Placa de nombre|r pueden coincidir con mltiples ID de unidad correspondientes.  |cffffff00Grupo inteligente|r se ajusta a tu tipo de grupo actual, haciendo coincidir solo el \"jugador\" cuando ests solo, las unidades de \"grupo\" (incluido el \"jugador\") en un grupo o las unidades de \"banda\" en una banda.  |cffffff00Objetivos mltiples|r intenta utilizar los eventos del registro de combate, en lugar del ID de unidad, para rastrear las unidades afectadas. |cffff0000Nota|r: Sin una relacin directa con los ID de unidad reales, los resultados pueden variar. |cffffff00*|r Los ajustes de unidades amarillas puede coincidir con varias unidades y estar activa de forma predeterminada incluso cuando no se encuentren unidades afectadas sin un ajuste de recuento de unidades o recuento de coincidencias."
	L["A 20x20 pixels icon"] = "Un icono de 20x20 pxeles"
	L["A 32x32 pixels icon"] = "Un icono de 32x32 pxeles"
	L["A 40x40 pixels icon"] = "Un icono de 40x40 pxeles"
	L["A 48x48 pixels icon"] = "Un icono de 48x48 pxeles"
	L["A 64x64 pixels icon"] = "Un icono de 64x64 pxeles"
	L["A group that dynamically controls the positioning of its children"] = "Un grupo que controla dinmicamente la posicin de sus hijos"
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = "Un temporizador se mostrar automticamente de acuerdo con la configuracin predeterminada de la interfaz (anulada por algunos addons). Activa esta opcin si quieres que el temporizador est oculto, o cuando utilices un texto de WeakAuras para mostrar el temporizador."
	L["A Unit ID (e.g., party1)."] = "Una ID de unidad (ej., party1)."
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = "Informacin y filtros del aura activa"
	L["Actual Spec"] = "Especializacin actual"
	L["Add %s"] = "Aadir %s"
	L["Add a new display"] = "Aadir una nueva aura"
	L["Add Condition"] = "Aadir condicin"
	L["Add Entry"] = "Aadir entrada"
	L["Add Extra Elements"] = "Aadir elementos extra"
	L["Add Option"] = "Aadir opcin"
	L["Add Overlay"] = "Aadir superposicin"
	L["Add Property Change"] = "Aadir cambio de propiedad"
	L["Add Snippet"] = "Aadir snippet"
	L["Add Sub Option"] = "Aadir opcin secundaria"
	L["Add to group %s"] = "Aadir al grupo %s"
	L["Add to new Dynamic Group"] = "Aadir al nuevo grupo dinmico"
	L["Add to new Group"] = "Aadir al nuevo grupo"
	L["Add Trigger"] = "Aadir activador"
	L["Additional Events"] = "Eventos adicionales"
	L["Advanced"] = "Avanzado"
	L["Affected Unit Filters and Info"] = "Informacin y filtros de las unidades afectadas"
	L["Align"] = "Alinear"
	L["Alignment"] = "Alineamiento"
	L["All maintainers of the libraries we use, especially:"] = "Todos los responsables del mantenimiento de las bibliotecas que utilizamos, especialmente:"
	L["All of"] = "Todo"
	L["Allow Full Rotation"] = "Permitir rotacin completa"
	L["Anchor"] = "Ancla"
	L["Anchor Mode"] = "Modo de anclaje"
	L["Anchor Point"] = "Punto de anclaje"
	L["Anchored To"] = "Anclado a"
	L["And "] = "y"
	L["and"] = "y"
	L["and %s"] = "y %s"
	L["and aligned left"] = "y alineado a la izquierda"
	L["and aligned right"] = "y alineado a la derecha"
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "Y nuestros Patreons, usuarios regulares de Discord y suscriptores, y amigos del addon:"
	L["and rotated left"] = "y girado a la izquierda"
	L["and rotated right"] = "y girado a la derecha"
	L["and with width |cFFFF0000%s|r and %s"] = "y con anchura |cFFFF0000%s|r y %s"
	L["Angle"] = "ngulo"
	L["Angle Between Auras"] = "Anglo entre auras"
	L["Animate"] = "Animar"
	L["Animated Expand and Collapse"] = "Ampliar y contraer animado"
	L["Animates progress changes"] = "Anima los cambios de progreso"
	L["Animation End"] = "Fin de la animacin"
	L["Animation Mode"] = "Modo de animacin"
	L["Animation relative duration description"] = [=[Duracin de la animacin relativa a la duracin del aura, expresado en fracciones (1/2), porcentaje (50%),  o decimales (0.5).
|cFFFF0000Nota:|r si el aura no tiene progreso (por ejemplo, si no tiene un activador basado en tiempo, si el aura no tiene duracin, etc.), la animacin no correr.

|cFF4444FFPor Ejemplo:|r
Si la duracin de la animacin es |cFF00CC0010%|r, y el disparador del aura es un beneficio que dura 20 segundos, la animacin de entrada se mostrar por 2 segundos.
Si la duracin de la animacin es |cFF00CC0010%|r, y el disparador del aura es un beneficio sin tiempo asignado, la animacin de entrada se ignorar."
]=]
	L["Animation Sequence"] = "Secuencia de Animacin"
	L["Animation Start"] = "Inicio de la animacin"
	L["Any of"] = "Cualquiera de"
	L["Apply Template"] = "Aplicar plantilla"
	L["Arcane Orb"] = "Orbe arcano"
	L["Area"] = "rea"
	L["At a position a bit left of Left HUD position."] = "En una posicin un poco a la izquierda de la posicin izquierda del HUD."
	L["At a position a bit left of Right HUD position"] = "En una posicin un poco a la izquierda de la posicin derecha del HUD"
	L["At the same position as Blizzard's spell alert"] = "En la misma posicin que la alerta de hechizo de Blizzard"
	L["Attach to Foreground"] = "Adjuntar al primer plano"
	L[ [=[Aura is
Off Screen]=] ] = "Aura est fuera de la pantalla"
	L["Aura Name Pattern"] = "Patrn del nombre del aura"
	L["Aura Order"] = "Orden de auras"
	L["Aura received from: %s"] = "Aura recibida de: %s"
	L["Aura: '%s'"] = "Aura: '%s'"
	L["Auto-Clone (Show All Matches)"] = "Autoclonar (mostrar todas las coincidencias)"
	L["Automatic length"] = "Longitud automtica"
	L["Backdrop Color"] = "Color de fondo"
	L["Backdrop in Front"] = "Fondo delante"
	L["Backdrop Style"] = "Estilo de fondo"
	L["Background Inner"] = "Fondo interior"
	L["Background Offset"] = "Desplazamiento del Fondo"
	L["Background Texture"] = "Textura del Fondo"
	L["Bar Alpha"] = "Transparencia de la barra"
	L["Bar Color Settings"] = "Configuracin de color de barra"
	L["Big Icon"] = "Icono grande"
	L["Blend Mode"] = "Modo de mezcla"
	L["Blue Rune"] = "Runa azul"
	L["Blue Sparkle Orb"] = "Orbe de brillo azul"
	L["Border %s"] = "Borde %s"
	L["Border Anchor"] = "Ancla del borde"
	L["Border Color"] = "Color de borde"
	L["Border in Front"] = "Borde en frente"
	L["Border Inset"] = "Borde del recuadro"
	L["Border Offset"] = "Desplazamiento de Borde"
	L["Border Settings"] = "Configuracin de bordes"
	L["Border Size"] = "Tamao del borde"
	L["Border Style"] = "Estilo de borde"
	L["Bracket Matching"] = "Coincidencia de soportes"
	L["Browse Wago, the largest collection of auras."] = "Explora Wago, la mayor coleccin de auras."
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "Por defecto, esto muestra la informacin del disparador seleccionado a travs de informacin dinmica. La informacin de un disparador especfico puede mostrarse mediante, por ejemplo, %2.p."
	L["Can be a UID (e.g., party1)."] = "Puede ser un UID (por ejemplo, party1)."
	L["Can set to 0 if Columns * Width equal File Width"] = "Puede ponerse a 0 si Columnas * Anchura es igual a Anchura de fila"
	L["Can set to 0 if Rows * Height equal File Height"] = "Puede ponerse a 0 si Filas * Altura es igual a Altura de fila"
	L["Case Insensitive"] = "Insensible a maysculas/minsculas"
	L["Cast by a Player Character"] = "Lanzado por un personaje de jugador"
	L["Categories to Update"] = "Categoras a actualizar"
	L["Changelog"] = "Registro de cambios"
	L["Chat with WeakAuras experts on our Discord server."] = "Chatea con los expertos de WeakAuras en nuestro servidor Discord."
	L["Check On..."] = "Chequear..."
	L["Check out our wiki for a large collection of examples and snippets."] = "Consulta nuestra wiki para ver una amplia coleccin de ejemplos y snippets."
	L["Children:"] = "Hijo:"
	L["Choose"] = "Escoger"
	L["Circular Texture %s"] = "Textura circular de %s"
	L["Clear Debug Logs"] = "Borrar registros de depuracin"
	L["Clear Saved Data"] = "Borrar datos guardados"
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	L["Clip Overlays"] = "Superposiciones recortadas"
	L["Clipped by Foreground"] = "Recortado por el primer plano"
	L["Close"] = "Cerrar"
	L["Code Editor"] = "Editor de cdigo"
	L["Collapse"] = "Contraer"
	L["Collapse all loaded displays"] = "Contraer todas las auras"
	L["Collapse all non-loaded displays"] = "Contraer todas las auras no cargadas"
	L["Collapse all pending Import"] = "Contraer todas las importaciones pendientes"
	L["Collapsible Group"] = "Grupo contrable"
	L["color"] = "color"
	L["Column Height"] = "Altura de columna"
	L["Column Space"] = "Espacio de columna"
	L["Columns"] = "Columnas"
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "COMBAT_LOG_EVENT_UNFILTERED sin filtro puede provocar cadas de frames en entornos de bandas."
	L["Combinations"] = "Combinaciones"
	L["Combine Matches Per Unit"] = "Combinar encuentros por unidad"
	L["Common Text"] = "Texto comn"
	L["Compare against the number of units affected."] = "Comparar con el nmero de unidades afectadas."
	L["Compatibility Options"] = "Opciones de compatibilidad"
	L["Compress"] = "Comprimir"
	L["Configure what options appear on this panel."] = "Configura qu opciones aparecen en este panel."
	L["Constant Factor"] = "Factor Constante"
	L["Control-click to select multiple displays"] = "Control clic para seleccionar varias visualizaciones"
	L["Controls the positioning and configuration of multiple displays at the same time"] = "Controla la posicin y configuracin de varias auras a la vez"
	L["Convert to..."] = "Convertir a..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "Los nmeros de reutilizacin pueden ser aadidos por WoW. Puedes configurarlos en los ajustes del juego."
	L["Copy"] = "Copiar"
	L["Copy settings..."] = "Copiar configuracin..."
	L["Copy to all auras"] = "Copiar a todas las auras"
	L["Could not parse '%s'. Expected a table."] = "No se ha podido procesar '%s'. Se esperaba una tabla."
	L["Counts the number of matches over all units."] = "Cuenta el nmero de coincidencias en todas las unidades."
	L["Counts the number of matches per unit."] = "Cuenta el nmero de coincidencias por unidad."
	L["Create a Copy"] = "Crear una copia"
	L["Creating buttons: "] = "Crear pulsadores: "
	L["Creating options: "] = "Crear opciones: "
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "Personalizado - Te permite definir una funcin Lua personalizada que devuelve una lista de valores en cadena. %c1 ser reemplazado por el primer valor devuelto, %c2 por el segundo, etc."
	L["Custom Code"] = "Cdigo Personalizado"
	L["Custom Code Viewer"] = "Visor de cdigo personalizado"
	L["Custom Frames"] = "Marcos personalizados"
	L["Custom Functions"] = "Funciones personalizadas"
	L["Custom Init"] = "Inicializacin personalizada"
	L["Custom Load"] = "Carga personalizada"
	L["Custom Options"] = "Opciones personalizadas"
	L["Custom Text Update Throttle"] = "Limitador de actualizacin de texto personalizado"
	L["Custom Trigger"] = "Activador personalizado"
	L["Custom trigger event tooltip"] = "Informacin sobre eventos de activador personalizado"
	L["Custom trigger status tooltip"] = "Informacin sobre el estado del activador personalizado"
	L["Custom trigger Update Throttle"] = "Limitador de actualizacin de disparador personalizado"
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "Activador personalizado: ignorar errores de Lua en el evento OPCIONES"
	L["Custom Trigger: Send fake events instead of STATUS event"] = "Activador personalizado: enviar eventos falsos en lugar del evento STATUS"
	L["Custom Unload"] = "Descarga personalizada"
	L["Custom Untrigger"] = "No-activador personalizado"
	L["Debug Log"] = "Registro de depuracin"
	L["Debug Log:"] = "Registro de depuracin:"
	L["Default"] = "Por defecto"
	L["Default Color"] = "Color por defecto"
	L["Delay"] = "Retardo"
	L["Delete"] = "Eliminar"
	L["Delete all"] = "Eliminar todo"
	L["Delete children and group"] = "Eliminar grupo e hijos"
	L["Delete Entry"] = "Eliminar entrada"
	L["Deleting auras: "] = "Eliminando auras:"
	L["Description Text"] = "Texto de descripcin"
	L["Determines how many entries can be in the table."] = "Determina cuntas entradas puede haber en la tabla."
	L["Differences"] = "Diferencias"
	L["Disallow Entry Reordering"] = "No permitir la reordenacin de entradas"
	L["Discord"] = "Discord"
	L["Display Name"] = "Nombre de visualizacin"
	L["Display Text"] = "Mostrar Texto"
	L["Displays a text, works best in combination with other displays"] = "Muestra un texto, funciona mejor en combinacin con otras visualizaciones"
	L["Distribute Horizontally"] = "Distribucin Horizontal"
	L["Distribute Vertically"] = "Distribucin Vertical"
	L["Do not group this display"] = "No agrupa esta visualizacin"
	L["Do you want to enable updates for this aura"] = "Quieres habilitar actualizaciones para esta aura?"
	L["Do you want to ignore updates for this aura"] = "Quieres ignorar actualizaciones para esta aura?"
	L["Documentation"] = "Documentacin"
	L["Done"] = "Hecho"
	L["Drag to move"] = "Arrastra para mover"
	L["Duplicate"] = "Duplicar"
	L["Duplicate All"] = "Duplicar todo"
	L["Duration (s)"] = "Duracin (s)"
	L["Duration Info"] = "Informacin de Duracin"
	L["Dynamic Duration"] = "Duracin dinmica"
	L["Dynamic Group"] = "Grupo dinmico"
	L["Dynamic Group Settings"] = "Configuracin de grupos dinmicos"
	L["Dynamic Information"] = "Informacin dinmica"
	L["Dynamic information from first active trigger"] = "Informacin dinmica del primer activador activo"
	L["Dynamic information from Trigger %i"] = "Informacin dinmica del activador %i"
	L["Dynamic Text Replacements"] = "Reemplazos de texto dinmico"
	L["Ease Strength"] = "Fuerza"
	L["Ease type"] = "Tipo"
	L["eliding"] = "omitiendo"
	L["Else If"] = "Si ms"
	L["Else If %s"] = "Ms si %s"
	L["Empty Base Region"] = "Regin base vaca"
	L["Enable \"Edge\" part of the overlay"] = "Activar la zona \"Borde\" de la superposicin"
	L["Enable \"swipe\" part of the overlay"] = "Activar la funcin \"barrido\" de la superposicin"
	L["Enable Debug Log"] = "Activar registro de depuracin"
	L["Enable Debug Logging"] = "Activar el registro de depuracin"
	L["Enable Gradient"] = "Activar degradado"
	L["Enable Swipe"] = "Activar barrido"
	L["Enable the \"Swipe\" radial overlay"] = "Activar la superposicin radial de \"barrido\""
	L["Enabled"] = "Activado"
	L["End Angle"] = "ngulo final"
	L["End of %s"] = "Fin de %s"
	L["Enemy nameplate(s) found"] = "Placa(s) de enemigo(s) encontrada(s)"
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "Escribe un ID de hechizo. Puedes usar el addon idTip para averiguar los IDs de los hechizos."
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = "Introduce un nombre de aura, un nombre de aura parcial o un ID de hechizo. Un ID de hechizo coincidir con cualquier hechizo que tenga el mismo nombre."
	L["Enter Author Mode"] = "Acceder al modo autor"
	L["Enter in a value for the tick's placement."] = "Introduce un valor para la colocacin del tic."
	L["Enter static or relative values with %"] = "Ingrese valores estticos o relativos con %"
	L["Enter User Mode"] = "Acceder al modo usuario"
	L["Enter user mode."] = "Accede al modo usuario."
	L["Entry %i"] = "Entrada %i"
	L["Entry limit"] = "Lmite de entrada"
	L["Entry Name Source"] = "Fuente del nombre de entrada"
	L["Event Type"] = "Tipo de Evento"
	L["Everything"] = "Todo"
	L["Exact Item Match"] = "Coincidencia exacta de objeto"
	L["Exact Spell Match"] = "Coincidencia exacta de hechizo"
	L["Expand"] = "Ampliar"
	L["Expand all loaded displays"] = "Ampliar todas las auras"
	L["Expand all non-loaded displays"] = "Ampliar todas las auras no cargadas"
	L["Expand all pending Import"] = "Ampliar todas las importaciones pendientes"
	L["Expansion is disabled because this group has no children"] = "La expansin est desactivada porque este grupo no tiene hijos"
	L["Export debug table..."] = "Exportar tabla de depuracin..."
	L["Export..."] = "Exportar..."
	L["Exporting"] = "Exportando"
	L["External"] = "Externo"
	L["Extra Height"] = "Altura extra"
	L["Extra Width"] = "Anchura extra"
	L["Fade"] = "Apagar"
	L["Fadeout Sound"] = "Sonido de desvanecimiento"
	L["Fadeout Time (seconds)"] = "Tiempo de desvanecimiento (segundos)"
	L["Fetch Affected/Unaffected Names and Units"] = "Obtener nombres y unidades afectados / no afectados"
	L["Fetch Raid Mark Information"] = "Obtener informacin sobre la marca de banda"
	L["Fetch Role Information"] = "Obtener informacin del rol"
	L["Fetch Tooltip Information"] = "Obtener informacin del tooltip"
	L["File Height"] = "Altura de archivo"
	L["File Width"] = "Anchura de archivo"
	L["Filter based on the spell Name string."] = "Filtro basado en la cadena del nombre del hechizo."
	L["Filter by Arena Spec"] = "Filtrar por especializacin de arena"
	L["Filter by Class"] = "Filtrar por clase"
	L["Filter by Group Role"] = "Filtrar por rol de grupo"
	L["Filter by Hostility"] = "Filtrar por hostilidad"
	L["Filter by Npc ID"] = "Filtrar por ID de PNJ"
	L["Filter by Raid Role"] = "Filtrar por rol de banda"
	L["Filter by Specialization"] = "Filtrar por especializacin"
	L["Filter by Unit Name"] = "Filtrar por nombre de unidad"
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = "Formatos de filtro: 'Nombre', 'Nombre-Reino', '-Reino'. Admite varias entradas, separadas por comas Puedes utilizar \\ para escapar -."
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = "Filtrar solo los perjuicios/beneficios de tipo clasificable como Sangrado mediante LibDispel"
	L["Find Auras"] = "Encontrar auras"
	L["Finish"] = "Finalizar"
	L["Finishing..."] = "Finalizando..."
	L["Fire Orb"] = "Orbe de fuego"
	L["Flat Framelevels"] = "Niveles de marco plano"
	L["Foreground Texture"] = "Textura Frontal"
	L["Format for %s"] = "Formato para %s"
	L["Found a Bug?"] = "Has encontrado un error?"
	L["Frame"] = "Marco"
	L["Frame Count"] = "Recuento de fotogramas"
	L["Frame Height"] = "Altura de marco"
	L["Frame Rate"] = "Cuadros por segundo"
	L["Frame Strata"] = "Estrato del marco"
	L["Frame Width"] = "Anchura de marco"
	L["Full Bar"] = "Barra llena"
	L["Full Circle"] = "Crculo completo"
	L["Global Conditions"] = "Condiciones globales"
	L["Glow %s"] = "Resplandor %s"
	L["Glow Action"] = "Accin de resplandor"
	L["Glow Anchor"] = "Ancla de resplandor"
	L["Glow Color"] = "Color del resplandor"
	L["Glow Frame Type"] = "Tipo de marco de resplandor"
	L["Glow Type"] = "Tipo de resplandor"
	L["Green Rune"] = "Runa verde"
	L["Grid direction"] = "Direccin de la rejilla"
	L["Group (verb)"] = "Grupo (verbo)"
	L["Group Alpha"] = "Transparencia del grupo"
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = "Agrupar y anclar cada aura por marco. - Placas de nombre: adjuntar a placas por unidad. - Marcos de unidad: adjuntar a botones de marco de unidad por unidad. - Marcos personalizados: elige a qu marco debe anclarse cada regin."
	L["Group aura count description"] = [=[La cantidad de miembros del grupo o banda que deben estar afectados por las auras indicadas para la activacin.
Si el nmero introducido es un entero (ej. 5), la cantidad de miembros del grupo o banda que deben estar afectados ser absoluta.
Si el nmero introducido es una fraccin (1/2), decimal (0.5) o porcentaje (50%%), se interpretar como que la cantidad de miembros del grupo o banda que deben estar afectados es una fraccin del total.

|cFF4444FFPor ejemplo:|r
Con |cFF00CC00> 0|r se activar cuando cualquier miembro del grupo o banda est afectado.
Con |cFF00CC00= 100%%|r se activar cuando todos los miembros del grupo o banda estn afectados.
Con |cFF00CC00!= 2|r se activar cuando el nmero de miembros del grupo o banda afectados no sea 2.
Con |cFF00CC00<= 0.8|r se activar cuando menos del 80%% del grupo o banda est afectado (4 de 5 miembros en grupos, 8 de 10  20 de 25 en bandas).
Con |cFF00CC00> 1/2|r se activar cuando ms de la mitad de miembros del grupo o banda estn afectados.
Con |cFF00CC00>= 0|r se activar siempre.]=]
	L["Group by Frame"] = "Agrupar por marco"
	L["Group Description"] = "Descripcin del grupo"
	L["Group Icon"] = "Icono de grupo"
	L["Group key"] = "Clave de grupo"
	L["Group Options"] = "Opciones de grupo"
	L["Group player(s) found"] = "Jugador(es) de grupo encontrado(s)"
	L["Group Role"] = "Rol de grupo"
	L["Group Scale"] = "Escala de grupo"
	L["Group Settings"] = "Configuracin de grupo"
	L["Hawk"] = "Halcn"
	L["Help"] = "Ayuda"
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	L["Hide Background"] = "Ocultar fondo"
	L["Hide Glows applied by this aura"] = "Ocultar resplandor aplicado por esta aura"
	L["Hide on"] = "Ocultar en"
	L["Hide this group's children"] = "Ocultar los hijos de este grupo"
	L["Highlights"] = "Resaltados"
	L["Horizontal Align"] = "Alineado Horizontal"
	L["Horizontal Bar"] = "Barra horizontal"
	L["Huge Icon"] = "Icono enorme"
	L["Hybrid Position"] = "Posicin de hbrido"
	L["Hybrid Sort Mode"] = "Modo de orden hbrido"
	L["Icon - The icon associated with the display"] = "Icono - El icono asociado con la visualizacin"
	L["Icon Info"] = "Informacin del Icono"
	L["Icon Inset"] = "Interior del Icono"
	L["Icon Picker"] = "Selector de iconos"
	L["Icon Position"] = "Posicin del icono"
	L["Icon Settings"] = "Configuracin de icono"
	L["Icon Source"] = "Fuente del icono"
	L["If"] = "Si"
	L["If %s"] = "Si %s"
	L["If checked, then the combo box in the User settings will be sorted."] = "Si est marcada, entonces la lista desplegable en la configuracin de usuario se ordenar."
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "Si est marcada, el usuario ver un cuadro de edicin de varias lneas. Esto es til para introducir grandes cantidades de texto."
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "Si est marcada, este grupo no se fusionar con otro grupo al seleccionar varias auras."
	L["If checked, then this option group can be temporarily collapsed by the user."] = "Si est marcada, el usuario puede contraer temporalmente este grupo de opciones."
	L["If checked, then this option group will start collapsed."] = "Si est marcada, este grupo de opciones comenzar colapsado."
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "Si est marcada, este separador incluir texto. De lo contrario, ser solo una lnea horizontal."
	L["If checked, then this space will span across multiple lines."] = "Si est marcada, este espacio abarcar varias lneas."
	L["If unchecked, then a default color will be used (usually yellow)"] = "Si no est marcada, se utilizar un color por defecto (normalmente amarillo)"
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "Si no est marcada, este espacio ocupar toda la lnea en la que se encuentre en Modo Usuario."
	L["Ignore out of casting range"] = "Ignorar afuera de alcance"
	L["Ignore out of checking range"] = "Ignorar fuera de rango de comprobacin"
	L["Ignore Wago updates"] = "Ignorar actualizaciones de Wago"
	L["Ignored"] = "Ignorar"
	L["Ignored Aura Name"] = "Nombre de aura ignorado"
	L["Ignored Exact Spell ID(s)"] = "ID de hechizo exacto ignorado"
	L["Ignored Name(s)"] = "Nombres ignorados"
	L["Ignored Spell ID"] = "ID de hechizo ignorado"
	L["Import"] = "Importar"
	L["Import / Export"] = "Importar / Exportar"
	L["Import a display from an encoded string"] = "Importa un aura desde un texto cifrado"
	L["Import as Copy"] = "Importar como copia"
	L["Import has no UID, cannot be matched to existing auras."] = "La importacin no tiene UID y no se puede comparar con auras existentes."
	L["Importing"] = "Importacin"
	L["Importing %s"] = "Importando %s"
	L["Importing a group with %s child auras."] = "Importando un grupo con %s auras hijas."
	L["Importing a stand-alone aura."] = "Importar un aura independiente."
	L["Importing...."] = "Importando...."
	L["Incompatible changes to group region types detected"] = "Se detectaron cambios incompatibles en los tipos de regiones del grupo"
	L["Incompatible changes to group structure detected"] = "Se detectaron cambios incompatibles en la estructura del grupo"
	L["Indent Size"] = "Tamao de sangra"
	L["Inner"] = "Interior"
	L["Insert text replacement codes to make text dynamic."] = "Insertar cdigos de reemplazo de texto para hacer el texto dinmico."
	L["Invalid Item ID"] = "ID de objeto no vlido"
	L["Invalid Item Name/ID/Link"] = "Nombre de objeto/ID/enlace no vlidos"
	L["Invalid Spell ID"] = "ID de hechizo no vlido"
	L["Invalid Spell Name/ID/Link"] = "Nombre de hechizo/ID/enlace no vlido"
	L["Invalid target aura"] = "Aura objetivo no vlida"
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "Tipo no vlido para '%s'. Se esperaba 'bool', 'number', 'select', 'string', 'timer' o 'elapsedTimer'."
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "Tipo no vlido para la propiedad '%s' en '%s'. Se esperaba '%s'."
	L["Inverse Slant"] = "Invertir inclinacin"
	L["Invert the direction of progress"] = "Invertir la direccin del progreso"
	L["Is Boss Debuff"] = "Es perjuicio de jefe"
	L["Is Stealable"] = "Se puede robar"
	L["Is Unit"] = "Es unidad"
	L["Justify"] = "Justificar"
	L["Keep Aspect Ratio"] = "Mantener relacin de aspecto"
	L["Keep your Wago imports up to date with the Companion App."] = "Mantn tus importaciones de Wago actualizadas con la Companion App."
	L["Large Input"] = "Entrada grande"
	L["Leaf"] = "Hoja"
	L["Left 2 HUD position"] = "Posicin de HUD izquierda 2"
	L["Left HUD position"] = "Posicin de HUD izquierda"
	L["Length of |cFFFF0000%s|r"] = "Longitud de |cFFFF0000%s|r"
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = "Lmite"
	L["Line"] = "Lnea"
	L["Linear Texture %s"] = "Textura lineal de %s"
	L["Linked aura: "] = "Aura vinculada:"
	L["Linked Auras"] = "Auras vinculadas"
	L["Load"] = "Cargar"
	L["Loaded"] = "Cargado"
	L["Loaded/Standby"] = "Cargado/en espera"
	L["Lock Positions"] = "Bloquear posiciones"
	L["Low Mana"] = "Man bajo"
	L["Magnetically Align"] = "Alineacin magntica"
	L["Main"] = "Principal"
	L["Manual with %i/%i"] = "Manual con %i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "Coincide con la altura de una barra horizontal o la anchura de una barra vertical."
	L["Max"] = "Mx."
	L["Max Length"] = "Longitud mx."
	L["Maximum"] = "Mximo"
	L["Media Type"] = "Tipo de media"
	L["Medium Icon"] = "Icono medio"
	L["Min"] = "Mn."
	L["Minimum"] = "Mnimo"
	L["Model %s"] = "Modelo %s"
	L["Model Picker"] = "Selector de modelo"
	L["Model Settings"] = "Configuracin de modelo"
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths no se pudo cargar, el addon es %s"
	L["Move Above Group"] = "Mover por encima del grupo"
	L["Move Below Group"] = "Mover debajo del grupo"
	L["Move Down"] = "Mover abajo"
	L["Move Entry Down"] = "Mover entrada hacia abajo"
	L["Move Entry Up"] = "Mover entrada hacia arriba"
	L["Move Into Above Group"] = "Mover al grupo superior"
	L["Move Into Below Group"] = "Mover al grupo inferior"
	L["Move this display down in its group's order"] = "Mueva esta visualizacin hacia abajo en el orden de su grupo"
	L["Move this display up in its group's order"] = "Mueva esta visualizacin hacia arriba en el orden de su grupo"
	L["Move Up"] = "Mover arriba"
	L["Moving auras: "] = "Auras en movimiento:"
	L["Multiple Displays"] = "Mltiples auras"
	L["Multiselect ignored tooltip"] = [=[
|cFFFF0000Ignorado|r - |cFF777777nico|r - |cFF777777Mltiple|r
sta opcin no ser usada al determinar cundo se mostrar el aura]=]
	L["Multiselect multiple tooltip"] = [=[
|cFF777777Ignorado|r - |cFF777777nico|r - |cFF00FF00Mltiple|r
Cualquier combinacin de valores es posible.]=]
	L["Multiselect single tooltip"] = [=[
|cFF777777Ignorado|r - |cFF00FF00nico|r - |cFF777777Mltiple|r
Slo un valor coincidente puede ser escogido.]=]
	L["Must be a power of 2"] = "Debe ser una potencia de 2"
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "Nombre - El nombre de la visualizacin (usualmente un nombre de aura), o el ID de la visualizacin si no hay un nombre dinmico"
	L["Name Info"] = "Informacin del Nombre"
	L["Name Pattern Match"] = "Coincidencia de patrn de nombre"
	L["Name:"] = "Nombre:"
	L["Negator"] = "Negador"
	L["New Aura"] = "Nueva aura"
	L["New Template"] = "Nueva plantilla"
	L["New Value"] = "Nuevo valor"
	L["No Children"] = "Sin dependientes"
	L["No Logs saved."] = "No hay registros guardados."
	L["Not a table"] = "No es una tabla"
	L["Not all children have the same value for this option"] = "No todos los hijos contienen la misma configuracin."
	L["Not Loaded"] = "No cargado"
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "Nota: los mensajes automticos para DECIR y GRITAR estn bloqueados fuera de las instancias."
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "Nota: Esta fuente de progreso no proporciona un valor/duracin total. Se debe establecer un valor/duracin total mediante \"Establecer progreso mximo\"."
	L["Number of Entries"] = "Nmero de entradas"
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3"
	L["OFF"] = "DESACTIVO"
	L["Offer a guided way to create auras for your character"] = "Ofrece una forma guiada de crear auras para tu personaje"
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "Compensado por |cFFFF0000%s|r/|cFFFF0000%s|r"
	L["Offset by 1px"] = "Desplazamiento de 1px"
	L["Okay"] = "Aceptar"
	L["ON"] = "ACTIVO"
	L["On Hide"] = "Ocultar"
	L["On Show"] = "Mostrar"
	L["Only Match auras cast by a player (not an npc)"] = "Coincidir solo con auras lanzadas por un jugador (no un pnj)"
	L["Only match auras cast by people other than the player or their pet"] = "Coincidir solo con auras lanzadas por personas que no sean el jugador o su mascota."
	L["Only match auras cast by the player or their pet"] = "Coincidir solo con auras lanzadas por el jugador o su mascota"
	L["Operator"] = "Operador"
	L["Option %i"] = "Opcin %i"
	L["Option key"] = "Clave de opcin"
	L["Option Type"] = "Tipo de opcin"
	L["Options will open after combat ends."] = "Las opciones se abrirn una vez finalizado el combate."
	L["or"] = "o"
	L["or %s"] = "o %s"
	L["Orange Rune"] = "Runa naranja"
	L["Our translators (too many to name)"] = "Nuestros traductores (demasiados para nombrar)"
	L["Outer"] = "Exterior"
	L["Overflow"] = "Desbordamiento"
	L["Overlay %s Info"] = "Informacin de superposicin %s"
	L["Overlays"] = "Superposiciones"
	L["Own Only"] = "Solo mos"
	L["Paste Action Settings"] = "Pegar configuracin de accin"
	L["Paste Animations Settings"] = "Pegar configuracin de animacin"
	L["Paste Author Options Settings"] = "Pegar configuracin de opciones del autor"
	L["Paste Condition Settings"] = "Pegar configuracin de condiciones"
	L["Paste Custom Configuration"] = "Pegar ajustes personalizados"
	L["Paste Display Settings"] = "Pegar configuracin de visualizacin"
	L["Paste Group Settings"] = "Pegar configuracin de grupo"
	L["Paste Load Settings"] = "Pegar configuracin de carga"
	L["Paste Settings"] = "Pegar configuracin"
	L["Paste text below"] = "Pega el texto a continuacin"
	L["Paste Trigger Settings"] = "Pegar configuracin del activador"
	L["Places a tick on the bar"] = "Coloca una marca en la barra"
	L["Play Sound"] = "Reproducir sonido"
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	L["Portrait Zoom"] = "Zoom del retrato"
	L["Position and Size Settings"] = "Configuracin de posicin y tamao"
	L["Preferred Match"] = "Coincidencia preferida"
	L["Premade Auras"] = "Auras prediseadas"
	L["Premade Snippets"] = "Snippets prefabricados"
	L["Preparing auras: "] = "Preparando auras:"
	L["Press Ctrl+C to copy"] = "Pulsa Ctrl+C para copiar"
	L["Press Ctrl+C to copy the URL"] = "Pulsa Ctrl+C para copiar la URL"
	L["Prevent Merging"] = "Evitar la fusin"
	L["Progress - The remaining time of a timer, or a non-timer value"] = "Progreso - El tiempo restante de un temporizador, o un valor que no es de temporizador"
	L["Progress Bar"] = "Barra de progreso"
	L["Progress Bar Settings"] = "Configuracin de la barra de progreso"
	L["Progress Settings"] = "Configuracin de progreso"
	L["Progress Texture"] = "Textura de progreso"
	L["Progress Texture Settings"] = "Configuracin de textura de progreso"
	L["Purple Rune"] = "Runa morada"
	L["Put this display in a group"] = "Pon esta visualizacin en un grupo."
	L["Range in yards"] = "Rango en yardas"
	L["Ready for Install"] = "Listo para instalar"
	L["Ready for Update"] = "Listo para actualizar"
	L["Re-center X"] = "Re-centrar X"
	L["Re-center Y"] = "Re-centrar Y"
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "ACTIVADOR recproco: # solicitudes sern ignoradas."
	L["Redo"] = "Rehacer"
	L["Regions of type \"%s\" are not supported."] = "Las regiones del tipo \"%s\" no son compatibles."
	L["Remove"] = "Eliminar"
	L["Remove All Sounds"] = "Eliminar todos los sonidos"
	L["Remove All Text To Speech"] = "Eliminar todo el texto a voz"
	L["Remove this display from its group"] = "Elimina esta visualizacin de su grupo."
	L["Remove this property"] = "Eliminar esta propiedad"
	L["Rename"] = "Renombrar"
	L["Repeat After"] = "Repetir despus"
	L["Repeat every"] = "Repetir cada"
	L["Report bugs on our issue tracker."] = "Informa de los errores en nuestro rastreador de problemas."
	L["Require unit from trigger"] = "Requiere unidad del activador"
	L["Required for Activation"] = "Necesario para la activacin"
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "Requiere LibSpecialization, es decir, una versin actualizada de WeakAuras."
	L["Reset all options to their default values."] = "Restablece todas las opciones a sus valores por defecto."
	L["Reset Entry"] = "Restablecer entrada"
	L["Reset to Defaults"] = "Restablecer valores"
	L["Right 2 HUD position"] = "Posicin de HUD derecha 2"
	L["Right HUD position"] = "Posicin de HUD derecha"
	L["Right-click for more options"] = "Clic derecho para ms opciones"
	L["Rotate"] = "Rotacin"
	L["Rotate In"] = "Rotar"
	L["Rotate Out"] = "Rotar"
	L["Rotate Text"] = "Rotar Texto"
	L["Rotation Mode"] = "Modo de rotacin"
	L["Row Space"] = "Espacio de fila"
	L["Row Width"] = "Anchura de fila"
	L["Rows"] = "Filas"
	L["Run on..."] = "Ejecutar por..."
	L["Same"] = "Igual"
	L["Same texture as Foreground"] = "Misma textura que primer plano"
	L["Saved Data"] = "Datos guardados"
	L["Scale Factor"] = "Factor de escala"
	L["Search API"] = "API de bsqueda"
	L["Select Talent"] = "Seleccionar talento"
	L["Select the auras you always want to be listed first"] = "Selecciona las auras que quieres que siempre sean listadas primero"
	L["Selected Frame"] = "Marco seleccionado"
	L["Send To"] = "Envar A"
	L["Separator Text"] = "Texto del separador"
	L["Separator text"] = "Texto del separador"
	L["Set Maximum Progress"] = "Establecer progreso mximo"
	L["Set Minimum Progress"] = "Establecer progreso mnimo"
	L["Set Parent to Anchor"] = "Establecer padre a la ancla"
	L["Set Thumbnail Icon"] = "Establecer icono de miniatura"
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "Establece el marco anclado como el padre del aura, lo que hace que el aura herede atributos como la visibilidad y la escala."
	L["Settings"] = "Configuracin"
	L["Shadow Color"] = "Color de sombras"
	L["Shadow X Offset"] = "Desplazamiento de sombras X"
	L["Shadow Y Offset"] = "Desplazamiento de sombras Y"
	L["Shift-click to create chat link"] = "Mays clic para crear enlace de chat"
	L["Show \"Edge\""] = "Mostrar \"borde\""
	L["Show \"Swipe\""] = "Mostrar \"barrido\""
	L["Show and Clone Settings"] = "Mostrar y clonar configuracin"
	L["Show Border"] = "Mostrar borde"
	L["Show Circular Texture"] = "Mostrar textura circular"
	L["Show Debug Logs"] = "Mostrar registro de depuracin"
	L["Show Glow"] = "Mostrar resplandor"
	L["Show Icon"] = "Mostrar icono"
	L["Show If Unit Does Not Exist"] = "Mostrar si unidad no existe"
	L["Show Linear Texture"] = "Mostrar textura lineal"
	L["Show Matches for"] = "Mostrar coincidencias para"
	L["Show Matches for Units"] = "Mostrar coincidencias para unidades"
	L["Show Model"] = "Mostrar modelo"
	L["Show model of unit "] = "Mostrar modelo de la unidad"
	L["Show Sound Setting"] = "Mostrar configuracin de sonido"
	L["Show Spark"] = "Mostrar chispa"
	L["Show Stop Motion"] = "Mostrar stop motion"
	L["Show Text"] = "Mostrar texto"
	L["Show Text To Speech Setting"] = "Mostrar configuracin de texto a voz"
	L["Show Texture"] = "Mostrar textura"
	L["Show this group's children"] = "Mostrar hijos de este grupo"
	L["Show Tick"] = "Mostrar tic"
	L["Shows a 3D model from the game files"] = "Muestra un modelo 3D directamente de los ficheros de WoW"
	L["Shows a border"] = "Muestra un borde"
	L["Shows a Circular Progress Texture"] = "Muestra una textura de progreso circular"
	L["Shows a custom texture"] = "Muestra una textura"
	L["Shows a glow"] = "Muestra un resplandor"
	L["Shows a Linear Progress Texture"] = "Muestra una textura de progreso lineal"
	L["Shows a model"] = "Muestra un modelo"
	L["Shows a progress bar with name, timer, and icon"] = "Barra de progreso con nombre, temporizador e icono"
	L["Shows a spell icon with an optional cooldown overlay"] = "Muestra un icono de hechizo con una superposicin opcional del cooldown"
	L["Shows a Stop Motion"] = "Muestra una stop motion"
	L["Shows a stop motion texture"] = "Muestra una textura en stop motion"
	L["Shows a Texture"] = "Muestra una textura"
	L["Shows a texture that changes based on duration"] = "Muestra una textura que cambia con el tiempo"
	L["Shows nothing, except sub elements"] = "No muestra nada, excepto los subelementos"
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Muestra una o varias lneas de texto, que pueden incluir informacin dinmica como el progreso o las acumulaciones."
	L["Size"] = "Tamao"
	L["Slant Amount"] = "Cantidad inclinada"
	L["Slant Mode"] = "Modo inclinado"
	L["Slanted"] = "Inclinado"
	L["Slide"] = "Arrastrar"
	L["Slide In"] = "Arrastrar Dentro"
	L["Slide Out"] = "Arrastrar"
	L["Slider Step Size"] = "Tamao de paso del control deslizante"
	L["Small Icon"] = "Icono pequeo"
	L["Smooth Progress"] = "Progreso fluido"
	L["Snippets"] = "Snippets"
	L["Soft Max"] = "Mx. flexible"
	L["Soft Min"] = "Mn. flexible"
	L["Sort"] = "Ordenar"
	L["Sound Channel"] = "Canal de Sonido"
	L["Sound File Path"] = "Ruta al Fichero de Sonido"
	L["Sound Kit ID"] = "ID del kit de sonido"
	L["Space Horizontally"] = "Espacio Horizontal"
	L["Space Vertically"] = "Espacio Vertical"
	L["Spark Settings"] = "Configuracin de chispa"
	L["Spark Texture"] = "Textura de chispa"
	L["Specific Currency ID"] = "ID de moneda especfica"
	L["Spell Selection Filters"] = "Filtros de seleccin de hechizo"
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = "Informacin de Acumulaciones"
	L["Stacks - The number of stacks of an aura (usually)"] = "Acumulaciones - El nmero de acumulaciones de un aura (usualmente)"
	L["Standby"] = "En espera"
	L["Star"] = "Estrella"
	L["Start"] = "Empezar"
	L["Start Angle"] = "Iniciar ngulo"
	L["Start Collapsed"] = "Iniciar colapsado"
	L["Start of %s"] = "Inicio de %s"
	L["Step Size"] = "Tamao de paso"
	L["Stop Motion %s"] = "Stop motion de %"
	L["Stop Motion Settings"] = "Configuracin de Stop Motion"
	L["Stop Sound"] = "Detener sonido"
	L["Stretched by Foreground"] = "Estirado por primer plano"
	L["Sub Elements"] = "Subelementos"
	L["Sub Option %i"] = "Subopcin %i"
	L["Subevent"] = "Subevento"
	L["Subevent Suffix"] = "Sufijo de subevento"
	L["Swipe Overlay Settings"] = "Configuracin de superposicin de barrido"
	L["Templates could not be loaded, the addon is %s"] = "No se pudieron cargar las plantillas, el addon es %s"
	L["Temporary Group"] = "Grupo Temporal"
	L["Text %s"] = "Texto %s"
	L["Text Color"] = "Color del Texto"
	L["Text Settings"] = "Configuracin de texto"
	L["Texture %s"] = "Textura de %s"
	L["Texture Info"] = "Informacin de textura"
	L["Texture Selection Mode"] = "Modo de seleccin de textura"
	L["Texture Settings"] = "Configuracin de textura"
	L["Texture Wrap"] = "Envoltura de textura"
	L["Texture X Offset"] = "Desplazmiento X de textura"
	L["Texture Y Offset"] = "Desplazmiento Y de textura"
	L["Thanks"] = "Gracias"
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "El addon ElvUI est activado. Podra agregar nmeros de tiempo de reutilizacin al barrido. Puedes configurarlos en la configuracin de ElvUI."
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "El addon OmniCC est activado. Podra agregar nmeros de tiempo de reutilizacin al barrido. Puedes configurarlos en la configuracin de OmniCC."
	L["The duration of the animation in seconds."] = "Duracin de la animacin (en segundos)."
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = [=[La duracin de la animacin en segundos. La animacin de finalizacin no comienza a reproducirse hasta que la visualizacin normalmente estara oculta.
]=]
	L["The group and all direct children will share the same base frame level."] = "El grupo y todos los hijos directos compartirn el mismo nivel de marco base."
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "El nmero de disparador es opcional. Cuando no se especifica un nmero de disparador, se usar el disparador seleccionado a travs de informacin dinmica."
	L["The type of trigger"] = "El tipo de activador"
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "La versin del addon WeakAuras Options %s no coincide con la versin de WeakAuras %s. Si actualizaste el addon mientras el juego estaba en ejecucin, intenta reiniciar World of Warcraft. De lo contrario, intenta reinstalar WeakAuras."
	L["Then "] = "Entonces"
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "Hay varios cdigos especiales disponibles para hacer que este texto sea dinmico. Haz clic para ver una lista con todos los cdigos de texto dinmico."
	L["This adds %raidMark as text replacements."] = "Esto agrega %raidMark como reemplazos de texto."
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "Esto agrega %role, %roleIcon como reemplazos de texto. No hace nada si la unidad no es miembro del grupo."
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "Esto agrega %tooltip, %tooltip1, %tooltip2, %tooltip3 y %tooltip4 como reemplazos de texto y tambin permite filtrar segn el contenido/valores de tooltip."
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = "Esta aura contiene un cdigo Lua personalizado. Asegrate de poder confiar en la persona que lo envi!"
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "Esta aura est marcada como una actualizacin de una aura '%s', pero no se puede usar para actualizar esa aura. Esto suele suceder si se saca una aura de un grupo."
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "Esta aura est marcada como una actualizacin de una aura '%s', pero no se puede usar para actualizar esa aura. Esto suele suceder si se saca una aura de un grupo."
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = "Esta aura fue creada con una versin diferente (%s) de World of Warcraft. Puede que no funcione correctamente!"
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = "Esta aura fue creada con una versin ms nueva de WeakAuras. Actualiza tu versin de WeakAuras o espera la prxima versin antes de instalar esta aura."
	L["This display is currently loaded"] = "Esta visualizacin est actualmente cargada."
	L["This display is not currently loaded"] = "Esta visualizacin no est actualmente cargada."
	L["This display is on standby, it will be loaded when needed."] = "Esta visualizacin est en espera, se cargar cuando sea necesario."
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = [=[Esto permite la recopilacin de registros de depuracin. El cdigo personalizado puede agregar informacin de depuracin al registro a travs de la funcin DebugPrint.
]=]
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "Esta es una versin modificada de tu aura, |cff9900FF%s.|r"
	L["This is a modified version of your group: |cff9900FF%s|r"] = "Esta es una versin modificada de tu grupo, |cff9900FF%s.|r"
	L["This region of type \"%s\" is not supported."] = "Esta regin de tipo \"%s\" no es compatible."
	L["This setting controls what widget is generated in user mode."] = "Este ajuste controla qu widget se genera en el modo de usuario."
	L["Thumbnail Icon"] = "Icono de miniatura"
	L["Tick %s"] = "Tic %s"
	L["Tick Area %s"] = "rea de marcado de %s"
	L["Tick Center %s"] = "Centro de marcado de %s"
	L["Tick Mode"] = "Modo de tic"
	L["Tick Placement"] = "Posicin de tic"
	L["Time in"] = "Contar En"
	L["Tiny Icon"] = "Icono miniatura"
	L["To Frame's"] = "Al marco"
	L["To Group's"] = "Al grupo"
	L["To Personal Ressource Display's"] = "A los recursos del aura personal"
	L["To Region's"] = "A la regin"
	L["To Screen's"] = "A la pantalla"
	L["Toggle the visibility of all loaded displays"] = "Alterar la visibilidad de todas las auras cargadas"
	L["Toggle the visibility of all non-loaded displays"] = "Alterar la visibilidad de todas las auras no cargadas"
	L["Toggle the visibility of this display"] = "Alterar la visibilidad de esta aura"
	L["Tooltip Content"] = "Contenido de la descripcin emergente"
	L["Tooltip on Mouseover"] = "Tooltip al pasar el ratn"
	L["Tooltip Pattern Match"] = "Coincidencia de patrn de tooltip"
	L["Tooltip Text"] = "Texto de tooltip"
	L["Tooltip Value"] = "Valor de tooltip"
	L["Tooltip Value #"] = "Valor # de tooltip"
	L["Top HUD position"] = "Posicin superior de la visualizacin (HUD)"
	L["Total"] = "Total"
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = "Total - La duracin mxima de un temporizador, o un valor mximo que no sea de temporizador"
	L["Total Angle"] = "ngulo total"
	L["Total Time"] = "Tiempo total"
	L["Trigger %i: %s"] = "Activador %i:%s"
	L["Trigger Combination"] = "Combinacin de activadores"
	L["Type 'select' for '%s' requires a values member'"] = "Tipo 'select' para '%s' requiere un miembro de valores'"
	L["Undo"] = "Deshacer"
	L["Ungroup"] = "Desagrupar"
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "La unidad %s no es una unidad vlida para RegisterUnitEvent"
	L["Unit Count"] = "Recuento de unidad"
	L["Unknown"] = "Desconocido"
	L["Unknown Encounter's Spell Id"] = "ID de hechizo de encuentro desconocido"
	L["Unknown property '%s' found in '%s'"] = "Propiedad desconocida '%s' encontrada en '%s'"
	L["Unknown Spell"] = "Hechizo desconocido"
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Ignorar animaciones de inicio y final: la animacin principal se repetir hasta que el aura se oculte."
	L["Update"] = "Actualizar"
	L["Update Auras"] = "Actualizar auras"
	L["Update Custom Text On..."] = "Actualizar Texto Personalizado En..."
	L["URL"] = "URL"
	L["Url: %s"] = "URL: %s"
	L["Use Display Info Id"] = "Utilizar ID de informacin de la visualizacin"
	L["Use SetTransform"] = "Utilizar SetTransform"
	L["Used in Auras:"] = "Utilizado en auras:"
	L["Used in auras:"] = "Utilizado en auras:"
	L["Uses Texture Coordinates to rotate the texture."] = "Utiliza coordenadas de textura para rotar la textura."
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "Utiliza UnitIsVisible() para comprobar si el cliente del juego ha cargado un objeto para esta unidad. Esta distancia es de unos 100 metros. Esto se encuesta cada segundo."
	L["Value"] = "Valor"
	L["Value %i"] = "Valor %i"
	L["Values are in normalized rgba format."] = "Los valores estn en formato rgba normalizado."
	L["Values/Remaining Time above this value are displayed as full progress."] = "Los valores/tiempo restante por encima de este valor se muestran como progreso completo."
	L["Values/Remaining Time below this value are displayed as zero progress."] = "Los valores/tiempo restante por debajo de este valor se muestran como sin progreso."
	L["Values:"] = "Valores:"
	L["Version: "] = "Versin:"
	L["Version: %s"] = "Versin: %s"
	L["Vertical Align"] = "Alineado Vertical"
	L["Vertical Bar"] = "Barra vertical"
	L["View"] = "Ver"
	L["View custom code"] = "Ver cdigo personalizado"
	L["Voice Settings"] = "Configuracin de voz"
	L["We thank"] = "Agradecemos a"
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s en WoW %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	L["What do you want to do?"] = "Qu es lo que quieres hacer?"
	L["Whole Area"] = "rea completa"
	L["wrapping"] = "envolviendo"
	L["X Offset"] = "Desplazamiento X"
	L["X Rotation"] = "Rotacin X"
	L["X Scale"] = "X Escala"
	L["x-Offset"] = "Desplazamiento x"
	L["Y Offset"] = "Desplazamiento Y"
	L["Y Rotation"] = "Rotacin Y"
	L["Y Scale"] = "Y Escala"
	L["Yellow Rune"] = "Runa amarilla"
	L["y-Offset"] = "Desplazamiento y"
	L["You already have this group/aura. Importing will create a duplicate."] = "Ya tienes este grupo/aura. La importacin crear un duplicado."
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "Ests a punto de eliminar aura(s) %d. |cFFFF0000Esto no se puede deshacer!|r Te gustaras continuar?"
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "Ests a punto de eliminar un activador. |cFFFF0000Esto no se puede deshacer!|r Te gustara continuar?"
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "Puedes agregar aqu una lista de valores de estado separados por comas en los que (cuando se modifican) WeakAuras tambin debera ejecutar el cdigo anclaje. WeakAuras siempre ejecutar el cdigo de orden personalizado si incluye \"cambiado\" en esta lista, o cuando se agrega, se elimina, o se reordena una regin"
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "Puedes agregar aqu una lista de valores de estado separados por comas en los que (cuando se modifican) WeakAuras tambin debera ejecutar el cdigo crecimiento. WeakAuras siempre ejecutar el cdigo de orden personalizado si incluye \"cambiado\" en esta lista, o cuando se agrega, se elimina, o se reordena una regin"
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "Puedes agregar aqu una lista de valores de estado separados por comas en los que (cuando se modifican) WeakAuras tambin debera ejecutar el cdigo de orden. WeakAuras siempre ejecutar el cdigo de orden personalizado si incluye \"cambiado\" en esta lista, o cuando se agrega o se elimina una regin"
	L["Your Saved Snippets"] = "Tus snippets guardados"
	L["Z Offset"] = "Desplazamiento Z"
	L["Z Rotation"] = "Rotacin Z"
	L["Zoom In"] = "Acercar"
	L["Zoom Out"] = "Alejar"


=== END OF FILE: WeakAurasOptions/Locales/esMX.lua ===


=== FILE: WeakAurasOptions/Locales/frFR.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "frFR" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = "et  |cFFFF0000mirrored|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- Ne supprimez pas ce commentaire, il fait partie de cette aura :"
	L[" rotated |cFFFF0000%s|r degrees"] = "degrs de |cFFFF0000%s|r  rotation"
	L["% - To show a percent sign"] = "% - Pour afficher un signe de pourcentage"
	L["% of Progress"] = "% de progression"
	L["%d |4aura:auras; added"] = "%d |4aura:auras; ajoute(s)"
	L["%d |4aura:auras; deleted"] = "%d |4aura:auras; supprime(s)"
	L["%d |4aura:auras; modified"] = "%d |4aura:auras; modifie(s)"
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; avec mtadonnes modifies"
	L["%d displays loaded"] = "%d affichages chargs"
	L["%d displays not loaded"] = "%d affichages non charg"
	L["%d displays on standby"] = "%d affichages en attente"
	L["%i auras selected"] = "%i auras slectionnes"
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i. Dclencheur"
	L["%s - Alpha Animation"] = "%s - Opacit de l'animation"
	L["%s - Color Animation"] = "%s - Couleur de l'animation"
	L["%s - Condition Custom Chat %s"] = "%s - Condition personnalise du chat %s"
	L["%s - Condition Custom Check %s"] = "%s - Condition vrifie du chat %s"
	L["%s - Condition Custom Code %s"] = "%s - Code de condition personnalis %s"
	L["%s - Custom Anchor"] = "%s - Ancre personnalise"
	L["%s - Custom Grow"] = "%s - Surbrillance personnalise"
	L["%s - Custom Sort"] = "%s - Sort personnalis"
	L["%s - Custom Text"] = "%s - Texte personnalis"
	L["%s - Finish"] = "%s - Terminer"
	L["%s - Finish Action"] = "%s - Termine l'action"
	L["%s - Finish Custom Text"] = "%s - Terminer le texte personnalis"
	L["%s - Init Action"] = "%s - Initialiser l'action"
	L["%s - Main"] = "%s - Principal"
	L["%s - OnLoad"] = "%s - Au chargement"
	L["%s - OnUnload"] = "%s - Au dchargement"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - L'option #%i est actuellement attribue  la touche %s. Veuillez choisir une touche diffrente."
	L["%s - Rotate Animation"] = "%s - Rotation de l'animation"
	L["%s - Scale Animation"] = "%s - Animation de l'chelle"
	L["%s - Start"] = "%s - Dmarrer"
	L["%s - Start Action"] = "%s - Dmarrer une action"
	L["%s - Start Custom Text"] = "%s - Dmarrer un texte personnalis"
	L["%s - Translate Animation"] = "%s - Traduire l'animation"
	L["%s - Trigger Logic"] = "%s - Logique du dclencheur"
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, Lignes : %d, Frquence : %0.2f, Longueur : %d, paisseur : %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, Particules : %d, Frquence : %0.2f, chelle : %0.2f"
	L["%s %u. Overlay Function"] = "%s %u. Fonction de superposition"
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s Opacit : %d%%"
	L["%s Color"] = "%s Couleur"
	L["%s Custom Variables"] = "%s Variables personnalises"
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s Opacit par dfaut, Zoom, Marge de licne, Rapport daspect"
	L["%s Duration Function"] = "%s Dure de la fonction"
	L["%s Icon Function"] = "%s Fonction de licne"
	L["%s Inset: %d%%"] = "%s Insrer : %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s nest pas un sous-vnement valide pour COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s Conserver les proportions"
	L["%s Name Function"] = "%s Nom de la fonction"
	--[[Translation missing --]]
	L["%s Stacks Function"] = "%s Stacks Function"
	L["%s stores around %s KB of data"] = "%s stocke environ %s Ko de donnes"
	L["%s Texture"] = "%s texture"
	L["%s Texture Function"] = "%s Texture de la fonction"
	L["%s total auras"] = "%s auras au total"
	L["%s Trigger Function"] = "%s Fonction de dclenchement"
	L["%s Untrigger Function"] = "%s Fonction dannulation du dclencheur"
	L["%s X offset by %d"] = "%s Dcalage horizontal de %d"
	L["%s Y offset by %d"] = "%s Dcalage vertical de %d"
	L["%s Zoom: %d%%"] = "%s Zoom: %d%%"
	L["%s, Border"] = "%s, Bordure"
	L["%s, Offset: %0.2f;%0.2f"] = "%s, Dcaler: %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, dcaler: %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s, Dmarrer lanimation"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000custom|r texture avec |cFFFF0000%s|r mode fusionn%s%s"
	L["(Right click to rename)"] = "(Clic-Droit pour renommer)"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02xCouleur personnalise|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999Les dclencheurs suivant plusieurs units seront actifs par dfaut mme si aucune unit affecte nest trouve, sauf si un paramtre de nombre dunits ou de correspondances est appliqu.|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000Note:|r Ceci dfinit la description uniquement sur '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000Note:|r Ceci dfinit l'URL sur toutes les auras slectionnes"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000Note:|r Ceci dfinit l'URL sur ce groupe et tous ses membres."
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000Automatic|r longueur"
	L["|cFFFF0000default|r texture"] = "|cFFFF0000default|r texture"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000desaturated|r"
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000Note:|r Cette unit '%s' n'est pas une unit traable."
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000Remarque:|r Lunit %s ncessite que les cvars de ciblage souple soient actives."
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00Ancrages :|r Ancr |cFFFF0000%s|r au cadre de |cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Ancrages :|r Ancr |cFFFF0000%s|r au cadre de ... |cFFFF0000%s|r avec un dcalage de |cFFFF0000%s/%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00Ancrages :|r Ancr au cadre de |cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Ancrages :|r Ancr au cadre de ... |cFFFF0000%s|r avec un dcalage de |cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00Options supplmentaires :|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00Extra:|r %s et %s %s"
	--[[Translation missing --]]
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"
	--[[Translation missing --]]
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cffffcc00Options de formatage|r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = " |cff00ff00Joueur|r, |cff00ff00Cible|r, |cff00ff00Focalisation|r et |cff00ff00Familier|r correspondent directement  ces identifiants dunit (unitIDs) individuels.  |cff00ff00Unit spcifique|r permet dindiquer un identifiant dunit valide  surveiller. |cffff0000Remarque|r : Le jeu ne dclenche pas dvnements pour tous les identifiants dunit valides, ce qui rend certains non dtectables par ce dclencheur.  |cffffff00Groupe|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arne|r et |cffffff00Plaque de nom|r peuvent correspondre  plusieurs identifiants dunit associs.  |cffffff00Groupe intelligent|r sadapte  votre type de groupe actuel : il correspond uniquement au \"joueur\" en solo, aux units \"groupe\" (y compris \"joueur\") en groupe, ou aux units \"raid\" en raid.  |cffffff00Cibles multiples|r tente dutiliser les vnements du journal de combat (Combat Log), plutt que les unitIDs, pour suivre les units affectes. |cffff0000Remarque|r : En labsence de lien direct avec des unitIDs rels, les rsultats peuvent varier. |cffffff00\\*|r Les paramtres dunit en jaune peuvent correspondre  plusieurs units et seront actifs par dfaut mme si aucune unit affecte nest dtecte, sauf si un paramtre de nombre dunits ou de correspondance est dfini."
	L["A 20x20 pixels icon"] = "Une icne de 20x20 pixels"
	L["A 32x32 pixels icon"] = "Une icne de 32x32 pixels"
	L["A 40x40 pixels icon"] = "Une icne de 40x40 pixels"
	L["A 48x48 pixels icon"] = "Une icne de 48x48 pixels"
	L["A 64x64 pixels icon"] = "Une icne de 64x64 pixels"
	L["A group that dynamically controls the positioning of its children"] = "Un groupe qui contrle dynamiquement le positionnement de ses enfants"
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = "Une minuterie sera automatiquement affiche selon les paramtres d'interface par dfaut (remplacs par certains addons). Activez ce paramtre si vous souhaitez que le minuteur soit masqu, ou si vous utilisez plutt un texte WeakAuras pour afficher le minuteur."
	L["A Unit ID (e.g., party1)."] = "Un ID d'unit (par exemple, groupe1)."
	L["Ace: Funkeh, Nevcairiel"] = "Ace : Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = "Filtres et infos des auras actives"
	L["Actual Spec"] = "Spcialisation actuelle"
	L["Add %s"] = "Ajouter %s"
	L["Add a new display"] = "Ajouter un nouvel affichage"
	L["Add Condition"] = "Ajouter une Condition"
	L["Add Entry"] = "Ajouter une entre"
	L["Add Extra Elements"] = "Ajouter des lments supplmentaires"
	L["Add Option"] = "Ajouter une option"
	L["Add Overlay"] = "Ajouter un Overlay"
	L["Add Property Change"] = "Ajouter un Changement de Proprit"
	L["Add Snippet"] = "Ajouter un extrait"
	L["Add Sub Option"] = "Ajouter une sous-option"
	L["Add to group %s"] = "Ajouter au groupe %s"
	L["Add to new Dynamic Group"] = "Ajouter  un nouveau groupe dynamique"
	L["Add to new Group"] = "Ajouter  un nouveau groupe"
	L["Add Trigger"] = "Ajouter un dclencheur"
	L["Additional Events"] = "vnements supplmentaires"
	L["Advanced"] = "Avanc"
	--[[Translation missing --]]
	L["Affected Unit Filters and Info"] = "Affected Unit Filters and Info"
	L["Align"] = "Aligner"
	L["Alignment"] = "Alignement"
	L["All maintainers of the libraries we use, especially:"] = "Tous les mainteneurs des bibliothques que nous utilisons, en particulier :"
	L["All of"] = "Tous vos"
	L["Allow Full Rotation"] = "Autoriser la rotation complte"
	L["Anchor"] = "Ancrage"
	L["Anchor Mode"] = "Mode dancrage"
	L["Anchor Point"] = "Point d'ancrage"
	L["Anchored To"] = "Ancr "
	L["And "] = "Et"
	L["and"] = "et"
	L["and %s"] = "et %s"
	L["and aligned left"] = "et align  gauche"
	L["and aligned right"] = "et align  droite"
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "Et nos Patreon, habitus de Discord, abonns et amis de laddon :"
	L["and rotated left"] = "et tourn vers la gauche"
	L["and rotated right"] = "et tourn vers la droite"
	L["and with width |cFFFF0000%s|r and %s"] = "et avec une largeur de |cFFFF0000%s|r et %s"
	L["Angle"] = "Angle"
	L["Angle Between Auras"] = "Angle entre les auras"
	L["Animate"] = "Animer"
	L["Animated Expand and Collapse"] = "Expansion et rduction anims"
	L["Animates progress changes"] = "Animer les changement de progression"
	L["Animation End"] = "Fin de l'animation"
	L["Animation Mode"] = "Mode danimation"
	L["Animation relative duration description"] = [=[La dure de l'animation par rapport  la dure du graphique, exprime en fraction (1/2), pourcentage (50%), ou dcimal (0.5).
|cFFFF0000Note :|r si un graphique n'a pas de progression (dclencheur d'vnement sans dure dfinie, aura sans dure, etc), l'animation ne jouera pas.

|cFF4444FFPar exemple :|r
Si la dure de l'animation est dfinie  |cFF00CC0010%|r, et le dclencheur du graphique est une amlioration qui dure 20 secondes, l'animation de dbut jouera pendant 2 secondes.
Si la dure de l'animation est dfinie  |cFF00CC0010%|r, et le dclencheur du graphique n'a pas de dure dfinie, aucune d'animation de dbut ne jouera (mais elle jouerait si vous aviez spcifi une dure en secondes).
]=]
	L["Animation Sequence"] = "Squence d'animation"
	L["Animation Start"] = "Dmarrer l'animation"
	L["Any of"] = "Un de"
	L["Apply Template"] = "Appliquer le modle"
	L["Arcane Orb"] = "Orbe d'arcane"
	L["Area"] = "Zone"
	L["At a position a bit left of Left HUD position."] = "Une position  gauche de la Position ATH Gauche."
	L["At a position a bit left of Right HUD position"] = "Une position  droite de la Position ATH Droite."
	L["At the same position as Blizzard's spell alert"] = " la mme position que l'alerte de sort de Blizzard"
	L["Attach to Foreground"] = "Attacher au premier plan"
	L[ [=[Aura is
Off Screen]=] ] = "Laura est hors cran"
	L["Aura Name Pattern"] = "Modle de Nom de l'Aura"
	L["Aura Order"] = "Ordre des auras"
	L["Aura received from: %s"] = "Aura reue de : %s"
	L["Aura: '%s'"] = "Aura : '%s'"
	L["Auto-Clone (Show All Matches)"] = "Clonage Automatique (Afficher tous les rsultats)"
	L["Automatic length"] = "Longueur automatique"
	L["Backdrop Color"] = "Couleur de Fond"
	L["Backdrop in Front"] = "Fond Devant"
	L["Backdrop Style"] = "Style de Fond"
	--[[Translation missing --]]
	L["Background Inner"] = "Background Inner"
	L["Background Offset"] = "Dcalage du Fond "
	L["Background Texture"] = "Texture d'arrire plan"
	L["Bar Alpha"] = "Opacit de la barre"
	L["Bar Color Settings"] = "Paramtres de la barre de couleur"
	L["Big Icon"] = "Grande icne"
	L["Blend Mode"] = "Mode du fusion"
	L["Blue Rune"] = "Rune bleue"
	L["Blue Sparkle Orb"] = "Orbe ptillant bleu"
	L["Border %s"] = "Encadrement %s"
	L["Border Anchor"] = "Ancrage de l'encadrement"
	L["Border Color"] = "Couleur de l'encadrement"
	L["Border in Front"] = "Bordure Devant"
	L["Border Inset"] = "Encart Fond"
	L["Border Offset"] = "Dcalage Bordure"
	L["Border Settings"] = "Paramtres de l'encadrement"
	L["Border Size"] = "Taille de l'encadrement"
	L["Border Style"] = "Style d'encadrement"
	L["Bracket Matching"] = "Crochet Correspondant"
	L["Browse Wago, the largest collection of auras."] = "Parcourez Wago, la plus grande collection d'auras."
	--[[Translation missing --]]
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."
	L["Can be a UID (e.g., party1)."] = "Peut tre un UID (par exemple, groupe1)."
	--[[Translation missing --]]
	L["Can set to 0 if Columns * Width equal File Width"] = "Can set to 0 if Columns * Width equal File Width"
	--[[Translation missing --]]
	L["Can set to 0 if Rows * Height equal File Height"] = "Can set to 0 if Rows * Height equal File Height"
	--[[Translation missing --]]
	L["Case Insensitive"] = "Case Insensitive"
	--[[Translation missing --]]
	L["Cast by a Player Character"] = "Cast by a Player Character"
	--[[Translation missing --]]
	L["Categories to Update"] = "Categories to Update"
	--[[Translation missing --]]
	L["Changelog"] = "Changelog"
	L["Chat with WeakAuras experts on our Discord server."] = "Discutez avec des experts de WeakAuras sur notre serveur Discord."
	L["Check On..."] = "Vrifier sur..."
	L["Check out our wiki for a large collection of examples and snippets."] = "Consultez notre wiki pour trouver une grande collection d'exemples et d'extraits."
	L["Children:"] = "Enfant :"
	L["Choose"] = "Choisir"
	--[[Translation missing --]]
	L["Circular Texture %s"] = "Circular Texture %s"
	--[[Translation missing --]]
	L["Clear Debug Logs"] = "Clear Debug Logs"
	--[[Translation missing --]]
	L["Clear Saved Data"] = "Clear Saved Data"
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	L["Clip Overlays"] = "Superposition de l'attache "
	--[[Translation missing --]]
	L["Clipped by Foreground"] = "Clipped by Foreground"
	L["Close"] = "Fermer"
	--[[Translation missing --]]
	L["Code Editor"] = "Code Editor"
	L["Collapse"] = "Rduire"
	L["Collapse all loaded displays"] = "Rduire tous les affichages chargs"
	L["Collapse all non-loaded displays"] = "Rduire tous les affichage non-chargs"
	--[[Translation missing --]]
	L["Collapse all pending Import"] = "Collapse all pending Import"
	--[[Translation missing --]]
	L["Collapsible Group"] = "Collapsible Group"
	L["color"] = "couleur"
	L["Column Height"] = "Hauteur de colonne"
	L["Column Space"] = "Espace de colonne"
	L["Columns"] = "Colonnes"
	--[[Translation missing --]]
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."
	L["Combinations"] = "Combinaisons"
	L["Combine Matches Per Unit"] = "Combiner toutes les Correspondances Par Unit"
	L["Common Text"] = "Texte commun"
	L["Compare against the number of units affected."] = "Comparer contre le nombre d'units affectes."
	L["Compatibility Options"] = "Options de compatibilit"
	L["Compress"] = "Compresser"
	L["Configure what options appear on this panel."] = "Configurez les options qui apparaissent sur ce panneau."
	L["Constant Factor"] = "Facteur constant"
	L["Control-click to select multiple displays"] = "Ctrl-Clic pour slectionner plusieurs affichages"
	L["Controls the positioning and configuration of multiple displays at the same time"] = "Contrle la position et la configuration de plusieurs affichages en mme temps"
	L["Convert to..."] = "Convertir en..."
	--[[Translation missing --]]
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "Cooldown Numbers might be added by WoW. You can configure these in the game settings."
	L["Copy"] = "Copier"
	L["Copy settings..."] = "Copier les paramtres..."
	L["Copy to all auras"] = "Copier toutes les auras"
	--[[Translation missing --]]
	L["Could not parse '%s'. Expected a table."] = "Could not parse '%s'. Expected a table."
	L["Counts the number of matches over all units."] = "Comptes de tout le nombre de correspondances sur toutes les units."
	--[[Translation missing --]]
	L["Counts the number of matches per unit."] = "Counts the number of matches per unit."
	--[[Translation missing --]]
	L["Create a Copy"] = "Create a Copy"
	L["Creating buttons: "] = "Cration de boutons :"
	L["Creating options: "] = "Cration d'options :"
	--[[Translation missing --]]
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."
	L["Custom Code"] = "Code personnalis"
	--[[Translation missing --]]
	L["Custom Code Viewer"] = "Custom Code Viewer"
	L["Custom Frames"] = "Cadres personnaliss"
	--[[Translation missing --]]
	L["Custom Functions"] = "Custom Functions"
	--[[Translation missing --]]
	L["Custom Init"] = "Custom Init"
	--[[Translation missing --]]
	L["Custom Load"] = "Custom Load"
	L["Custom Options"] = "Options personnalises"
	--[[Translation missing --]]
	L["Custom Text Update Throttle"] = "Custom Text Update Throttle"
	L["Custom Trigger"] = "Dclencheur personnalis"
	L["Custom trigger event tooltip"] = [=[
Choisissez quels vnements peuvent activer le dclencheur.
Plusieurs vnements peuvent tre spcifis avec des virgules ou des espaces.

|cFF4444FFPar exemple:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED
]=]
	L["Custom trigger status tooltip"] = [=[
Choisissez quels vnements peuvent activer le dclencheur.
Comme c'est un dclencheur de type statut, les vnements spcifis peuvent tre appels par WeakAuras sans les arguments attendus.
Plusieurs vnements peuvent tre spcifis avec des virgules ou des espaces.

|cFF4444FFPar exemple:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED
]=]
	--[[Translation missing --]]
	L["Custom trigger Update Throttle"] = "Custom trigger Update Throttle"
	--[[Translation missing --]]
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "Custom Trigger: Ignore Lua Errors on OPTIONS event"
	--[[Translation missing --]]
	L["Custom Trigger: Send fake events instead of STATUS event"] = "Custom Trigger: Send fake events instead of STATUS event"
	--[[Translation missing --]]
	L["Custom Unload"] = "Custom Unload"
	L["Custom Untrigger"] = "Dsactivation personnalise"
	--[[Translation missing --]]
	L["Debug Log"] = "Debug Log"
	--[[Translation missing --]]
	L["Debug Log:"] = "Debug Log:"
	L["Default"] = "Par dfaut"
	L["Default Color"] = "Couleur par dfaut"
	--[[Translation missing --]]
	L["Delay"] = "Delay"
	L["Delete"] = "Supprimer"
	L["Delete all"] = "Supprimer tout"
	L["Delete children and group"] = "Supprimer enfants et groupe"
	L["Delete Entry"] = "Supprimer l'entre"
	--[[Translation missing --]]
	L["Deleting auras: "] = "Deleting auras: "
	L["Description Text"] = "Texte de Description"
	--[[Translation missing --]]
	L["Determines how many entries can be in the table."] = "Determines how many entries can be in the table."
	L["Differences"] = "Diffrences"
	--[[Translation missing --]]
	L["Disallow Entry Reordering"] = "Disallow Entry Reordering"
	--[[Translation missing --]]
	L["Discord"] = "Discord"
	L["Display Name"] = "Nom de l'affichage"
	L["Display Text"] = "Afficher le texte"
	L["Displays a text, works best in combination with other displays"] = "Affiche du texte, fonctionne mieux en combinaison avec d'autres affichages."
	L["Distribute Horizontally"] = "Distribuer horizontalement"
	L["Distribute Vertically"] = "Distribuer verticalement"
	L["Do not group this display"] = "Ne pas grouper cet affichage"
	--[[Translation missing --]]
	L["Do you want to enable updates for this aura"] = "Do you want to enable updates for this aura"
	--[[Translation missing --]]
	L["Do you want to ignore updates for this aura"] = "Do you want to ignore updates for this aura"
	L["Documentation"] = "Documentation"
	L["Done"] = "Termin"
	L["Drag to move"] = "Glisser pour dplacer"
	L["Duplicate"] = "Doubler"
	L["Duplicate All"] = "Doubler Tout"
	L["Duration (s)"] = "Dure (s)"
	L["Duration Info"] = "Info de dure"
	L["Dynamic Duration"] = "Dure Dynamique"
	L["Dynamic Group"] = "Groupe Dynamique"
	L["Dynamic Group Settings"] = "Paramtres des groupes dynamiques"
	L["Dynamic Information"] = "Information Dynamique"
	L["Dynamic information from first active trigger"] = "Information dynamique depuis le premier dclencheur"
	L["Dynamic information from Trigger %i"] = "Information dynamique du Dclencheur %i"
	--[[Translation missing --]]
	L["Dynamic Text Replacements"] = "Dynamic Text Replacements"
	--[[Translation missing --]]
	L["Ease Strength"] = "Ease Strength"
	--[[Translation missing --]]
	L["Ease type"] = "Ease type"
	--[[Translation missing --]]
	L["eliding"] = "eliding"
	--[[Translation missing --]]
	L["Else If"] = "Else If"
	--[[Translation missing --]]
	L["Else If %s"] = "Else If %s"
	--[[Translation missing --]]
	L["Empty Base Region"] = "Empty Base Region"
	--[[Translation missing --]]
	L["Enable \"Edge\" part of the overlay"] = "Enable \"Edge\" part of the overlay"
	L["Enable \"swipe\" part of the overlay"] = "Activer la partie \"balayage\" de la superposition"
	--[[Translation missing --]]
	L["Enable Debug Log"] = "Enable Debug Log"
	--[[Translation missing --]]
	L["Enable Debug Logging"] = "Enable Debug Logging"
	--[[Translation missing --]]
	L["Enable Gradient"] = "Enable Gradient"
	L["Enable Swipe"] = "Activer le balayage"
	L["Enable the \"Swipe\" radial overlay"] = "Activer la superposition radiale du \"balayage\""
	L["Enabled"] = "Activ"
	L["End Angle"] = "Angle de fin"
	L["End of %s"] = "Fin de %s"
	--[[Translation missing --]]
	L["Enemy nameplate(s) found"] = "Enemy nameplate(s) found"
	--[[Translation missing --]]
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "Enter a Spell ID. You can use the addon idTip to determine spell ids."
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = "Saisissez un nom d'aura, un nom d'aura partiel ou un ID de sort. L'ID d'un sort correspondra  tous les sorts portant le mme nom."
	L["Enter Author Mode"] = "Entrer en mode auteur"
	--[[Translation missing --]]
	L["Enter in a value for the tick's placement."] = "Enter in a value for the tick's placement."
	--[[Translation missing --]]
	L["Enter static or relative values with %"] = "Enter static or relative values with %"
	L["Enter User Mode"] = "Entrer en mode utilisateur"
	L["Enter user mode."] = "Entrer en mode utilisateur"
	--[[Translation missing --]]
	L["Entry %i"] = "Entry %i"
	--[[Translation missing --]]
	L["Entry limit"] = "Entry limit"
	--[[Translation missing --]]
	L["Entry Name Source"] = "Entry Name Source"
	L["Event Type"] = "Type d'vnement"
	L["Everything"] = "Tous"
	L["Exact Item Match"] = "Correspondance exacte de l'objet"
	L["Exact Spell Match"] = "Correspondance exacte du sort"
	L["Expand"] = "Agrandir"
	L["Expand all loaded displays"] = "Agrandir tous affichages chargs"
	L["Expand all non-loaded displays"] = "Agrandir tous affichage non-chargs"
	--[[Translation missing --]]
	L["Expand all pending Import"] = "Expand all pending Import"
	L["Expansion is disabled because this group has no children"] = "L'expansion est dsactive car ce groupe n'a pas d'enfants"
	--[[Translation missing --]]
	L["Export debug table..."] = "Export debug table..."
	--[[Translation missing --]]
	L["Export..."] = "Export..."
	--[[Translation missing --]]
	L["Exporting"] = "Exporting"
	L["External"] = "Externe"
	--[[Translation missing --]]
	L["Extra Height"] = "Extra Height"
	--[[Translation missing --]]
	L["Extra Width"] = "Extra Width"
	L["Fade"] = "Fondu"
	--[[Translation missing --]]
	L["Fadeout Sound"] = "Fadeout Sound"
	--[[Translation missing --]]
	L["Fadeout Time (seconds)"] = "Fadeout Time (seconds)"
	--[[Translation missing --]]
	L["Fetch Affected/Unaffected Names and Units"] = "Fetch Affected/Unaffected Names and Units"
	--[[Translation missing --]]
	L["Fetch Raid Mark Information"] = "Fetch Raid Mark Information"
	--[[Translation missing --]]
	L["Fetch Role Information"] = "Fetch Role Information"
	--[[Translation missing --]]
	L["Fetch Tooltip Information"] = "Fetch Tooltip Information"
	--[[Translation missing --]]
	L["File Height"] = "File Height"
	--[[Translation missing --]]
	L["File Width"] = "File Width"
	--[[Translation missing --]]
	L["Filter based on the spell Name string."] = "Filter based on the spell Name string."
	--[[Translation missing --]]
	L["Filter by Arena Spec"] = "Filter by Arena Spec"
	L["Filter by Class"] = "Filtrer par Classe"
	L["Filter by Group Role"] = "Filtrer par rle de groupe"
	--[[Translation missing --]]
	L["Filter by Hostility"] = "Filter by Hostility"
	--[[Translation missing --]]
	L["Filter by Npc ID"] = "Filter by Npc ID"
	L["Filter by Raid Role"] = "Filtrer par rle de raid"
	--[[Translation missing --]]
	L["Filter by Specialization"] = "Filter by Specialization"
	--[[Translation missing --]]
	L["Filter by Unit Name"] = "Filter by Unit Name"
	--[[Translation missing --]]
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
	--[[Translation missing --]]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=]
	--[[Translation missing --]]
	L["Find Auras"] = "Find Auras"
	L["Finish"] = "Finir"
	--[[Translation missing --]]
	L["Finishing..."] = "Finishing..."
	L["Fire Orb"] = "Orbe de feu"
	--[[Translation missing --]]
	L["Flat Framelevels"] = "Flat Framelevels"
	L["Foreground Texture"] = "Texture premier-plan"
	L["Format for %s"] = "Format pour %s"
	L["Found a Bug?"] = "Vous avez dcouvert un bug ?"
	L["Frame"] = "Cadre"
	--[[Translation missing --]]
	L["Frame Count"] = "Frame Count"
	--[[Translation missing --]]
	L["Frame Height"] = "Frame Height"
	--[[Translation missing --]]
	L["Frame Rate"] = "Frame Rate"
	L["Frame Strata"] = "Strate du cadre"
	--[[Translation missing --]]
	L["Frame Width"] = "Frame Width"
	--[[Translation missing --]]
	L["Full Bar"] = "Full Bar"
	L["Full Circle"] = "Cercle Complet"
	L["Global Conditions"] = "Conditions globales"
	L["Glow %s"] = "Faire briller %s"
	L["Glow Action"] = "Action de la brillance"
	L["Glow Anchor"] = "Ancre de la brillance"
	L["Glow Color"] = "Couleur de la brillance"
	L["Glow Frame Type"] = "Type de cadre brillant"
	L["Glow Type"] = "Type de la brillance"
	L["Green Rune"] = "Rune verte"
	L["Grid direction"] = "Direction de la grille"
	L["Group (verb)"] = "Groupe (verbe)"
	--[[Translation missing --]]
	L["Group Alpha"] = "Group Alpha"
	--[[Translation missing --]]
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=]
	L["Group aura count description"] = [=[Le nombre de membres du %s qui doivent tre affects par une ou plusieurs des auras slectionnes pour que l'affichage soit dclench.
Si le nombre entr est un entier (ex. 5), le nombre de membres du raid affects sera compar au nombre entr.
Si le nombre entr est decimal (ex. 0.5), une fraction (ex. 1/2), ou un pourcentage (ex. 50%%), alors cette fraction du %s doit tre affecte.

|cFF4444FFPar exemple :|r
|cFF00CC00> 0|r se dclenchera quand n'importe quel membre du %s est affect
|cFF00CC00= 100%%|r se dclenchera quand tous les membres du %s sont affects
|cFF00CC00!= 2|r se dclenchera quand le nombre de membres du %s affects est diffrent de 2
|cFF00CC00<= 0.8|r se dclenchera quand moins de 80%% du %s est affect (4 des 5 membres du groupe, 8 des 10 ou 20 des 25 membres du raid )
|cFF00CC00> 1/2|r se dclenchera quand plus de la moiti du %s est affect
|cFF00CC00>= 0|r se dclenchera toujours, quoi qu'il arrive
]=]
	--[[Translation missing --]]
	L["Group by Frame"] = "Group by Frame"
	L["Group Description"] = "Description du groupe"
	L["Group Icon"] = "Icne du groupe"
	--[[Translation missing --]]
	L["Group key"] = "Group key"
	L["Group Options"] = "Options du groupe"
	--[[Translation missing --]]
	L["Group player(s) found"] = "Group player(s) found"
	L["Group Role"] = "Rle du groupe"
	L["Group Scale"] = "chelle du Groupe"
	L["Group Settings"] = "Paramtres du groupe"
	L["Hawk"] = "Faucon"
	L["Help"] = "Aide"
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	--[[Translation missing --]]
	L["Hide Background"] = "Hide Background"
	L["Hide Glows applied by this aura"] = "Cacher les brillances appliques par cette aura"
	L["Hide on"] = "Cacher "
	L["Hide this group's children"] = "Cacher les enfants de ce groupe"
	--[[Translation missing --]]
	L["Highlights"] = "Highlights"
	L["Horizontal Align"] = "Aligner horizontalement"
	L["Horizontal Bar"] = "Barre horizontale"
	L["Huge Icon"] = "norme icne"
	L["Hybrid Position"] = "Position hybride"
	L["Hybrid Sort Mode"] = "Mode de tri hybride"
	--[[Translation missing --]]
	L["Icon - The icon associated with the display"] = "Icon - The icon associated with the display"
	L["Icon Info"] = "Info d'icne"
	L["Icon Inset"] = "Objet insr"
	--[[Translation missing --]]
	L["Icon Picker"] = "Icon Picker"
	L["Icon Position"] = "Position de l'icne"
	L["Icon Settings"] = "Paramtres de l'icne"
	--[[Translation missing --]]
	L["Icon Source"] = "Icon Source"
	L["If"] = "Si"
	--[[Translation missing --]]
	L["If %s"] = "If %s"
	--[[Translation missing --]]
	L["If checked, then the combo box in the User settings will be sorted."] = "If checked, then the combo box in the User settings will be sorted."
	--[[Translation missing --]]
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."
	--[[Translation missing --]]
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "If checked, then this group will not merge with other group when selecting multiple auras."
	--[[Translation missing --]]
	L["If checked, then this option group can be temporarily collapsed by the user."] = "If checked, then this option group can be temporarily collapsed by the user."
	--[[Translation missing --]]
	L["If checked, then this option group will start collapsed."] = "If checked, then this option group will start collapsed."
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = [=[
Si cette case est coche, ce sparateur inclura du texte. Sinon, ce sera juste une ligne horizontale]=]
	L["If checked, then this space will span across multiple lines."] = "Si cette case est coche, cet espace s'tendra sur plusieurs lignes."
	L["If unchecked, then a default color will be used (usually yellow)"] = "Si cette case n'est pas coche, une couleur par dfaut sera utilise (gnralement jaune)"
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "Si cette case n'est pas coche, cet espace remplira toute la ligne sur laquelle il se trouve en mode utilisateur."
	--[[Translation missing --]]
	L["Ignore out of casting range"] = "Ignore out of casting range"
	L["Ignore out of checking range"] = "Ignorer hors de la plage de vrification"
	--[[Translation missing --]]
	L["Ignore Wago updates"] = "Ignore Wago updates"
	L["Ignored"] = "Ignor"
	L["Ignored Aura Name"] = "Ignorer par nom d'aura"
	L["Ignored Exact Spell ID(s)"] = "Ignorer par correspondance exacte de l'ID du/des sort(s)"
	L["Ignored Name(s)"] = "Ignorer par nom(s)"
	L["Ignored Spell ID"] = "Ignorer par ID de sort"
	L["Import"] = "Importer"
	--[[Translation missing --]]
	L["Import / Export"] = "Import / Export"
	L["Import a display from an encoded string"] = "Importer un graphique d'un texte encod"
	--[[Translation missing --]]
	L["Import as Copy"] = "Import as Copy"
	--[[Translation missing --]]
	L["Import has no UID, cannot be matched to existing auras."] = "Import has no UID, cannot be matched to existing auras."
	--[[Translation missing --]]
	L["Importing"] = "Importing"
	--[[Translation missing --]]
	L["Importing %s"] = "Importing %s"
	--[[Translation missing --]]
	L["Importing a group with %s child auras."] = "Importing a group with %s child auras."
	--[[Translation missing --]]
	L["Importing a stand-alone aura."] = "Importing a stand-alone aura."
	--[[Translation missing --]]
	L["Importing...."] = "Importing...."
	--[[Translation missing --]]
	L["Incompatible changes to group region types detected"] = "Incompatible changes to group region types detected"
	--[[Translation missing --]]
	L["Incompatible changes to group structure detected"] = "Incompatible changes to group structure detected"
	--[[Translation missing --]]
	L["Indent Size"] = "Indent Size"
	L["Inner"] = "Intrieur"
	--[[Translation missing --]]
	L["Insert text replacement codes to make text dynamic."] = "Insert text replacement codes to make text dynamic."
	--[[Translation missing --]]
	L["Invalid Item ID"] = "Invalid Item ID"
	L["Invalid Item Name/ID/Link"] = "Nom d'objet / ID / lien invalide"
	L["Invalid Spell ID"] = "ID de sort invalide"
	L["Invalid Spell Name/ID/Link"] = "Nom du sort / ID / lien invalide"
	--[[Translation missing --]]
	L["Invalid target aura"] = "Invalid target aura"
	--[[Translation missing --]]
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "Type non valide pour la proprit '%s' dans '%s'. Attendu '%s'."
	L["Inverse Slant"] = "Inclinaison inverse"
	--[[Translation missing --]]
	L["Invert the direction of progress"] = "Invert the direction of progress"
	--[[Translation missing --]]
	L["Is Boss Debuff"] = "Is Boss Debuff"
	L["Is Stealable"] = "Est subtilisable "
	--[[Translation missing --]]
	L["Is Unit"] = "Is Unit"
	L["Justify"] = "Justification"
	L["Keep Aspect Ratio"] = "Conserver les Proportions"
	L["Keep your Wago imports up to date with the Companion App."] = "Gardez vos importations Wago  jour avec l'application Companion."
	--[[Translation missing --]]
	L["Large Input"] = "Large Input"
	L["Leaf"] = "Feuille"
	L["Left 2 HUD position"] = "Position ATH Gauche 2"
	L["Left HUD position"] = "Position ATH Gauche"
	--[[Translation missing --]]
	L["Length of |cFFFF0000%s|r"] = "Length of |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	--[[Translation missing --]]
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	--[[Translation missing --]]
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	--[[Translation missing --]]
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	--[[Translation missing --]]
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	--[[Translation missing --]]
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = "Limite"
	--[[Translation missing --]]
	L["Line"] = "Line"
	--[[Translation missing --]]
	L["Linear Texture %s"] = "Linear Texture %s"
	--[[Translation missing --]]
	L["Linked aura: "] = "Linked aura: "
	--[[Translation missing --]]
	L["Linked Auras"] = "Linked Auras"
	L["Load"] = "Chargement"
	L["Loaded"] = "Charg"
	--[[Translation missing --]]
	L["Loaded/Standby"] = "Loaded/Standby"
	L["Lock Positions"] = "Verrouiller les positions"
	L["Low Mana"] = "Mana bas"
	L["Magnetically Align"] = "Alignement magntique"
	L["Main"] = "Principal"
	--[[Translation missing --]]
	L["Manual with %i/%i"] = "Manual with %i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "Correspond au paramtre de hauteur d'une barre horizontale ou de largeur pour une barre verticale."
	L["Max"] = "Max"
	L["Max Length"] = "Longueur max"
	--[[Translation missing --]]
	L["Maximum"] = "Maximum"
	--[[Translation missing --]]
	L["Media Type"] = "Media Type"
	L["Medium Icon"] = "Icne moyenne"
	L["Min"] = "Min (minutes?)"
	--[[Translation missing --]]
	L["Minimum"] = "Minimum"
	L["Model %s"] = "Modle %s"
	--[[Translation missing --]]
	L["Model Picker"] = "Model Picker"
	L["Model Settings"] = "Paramtres du modle"
	--[[Translation missing --]]
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths could not be loaded, the addon is %s"
	L["Move Above Group"] = "Dplacer au dessus du groupe"
	L["Move Below Group"] = "Dplacer en dessous du grouoe"
	L["Move Down"] = "Dplacer vers le bas"
	L["Move Entry Down"] = "Dplacer l'entre vers le bas"
	L["Move Entry Up"] = "Dplacer l'entre vers le haut"
	--[[Translation missing --]]
	L["Move Into Above Group"] = "Move Into Above Group"
	--[[Translation missing --]]
	L["Move Into Below Group"] = "Move Into Below Group"
	L["Move this display down in its group's order"] = "Dplacer cet affichage vers le bas dans l'ordre de son groupe"
	L["Move this display up in its group's order"] = "Dplacer cet affichage vers le haut dans l'ordre de son groupe"
	L["Move Up"] = "Dplacer vers le haut"
	--[[Translation missing --]]
	L["Moving auras: "] = "Moving auras: "
	L["Multiple Displays"] = "Affichages multiples"
	L["Multiselect ignored tooltip"] = "Infobulle ignore de la slection multiple"
	L["Multiselect multiple tooltip"] = [=[
|cFF777777Ignor|r - |cFF777777Unique|r - |cFF00FF00Multiple|r
Plusieurs valeurs peuvent tre choisies]=]
	L["Multiselect single tooltip"] = [=[
|cFF777777Ignor|r - |cFF00FF00Unique|r - |cFF777777Multiple|r
Seule une unique valeur peut tre choisie]=]
	--[[Translation missing --]]
	L["Must be a power of 2"] = "Must be a power of 2"
	--[[Translation missing --]]
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"
	L["Name Info"] = "Info du nom"
	L["Name Pattern Match"] = "Correspondance de modle de nom"
	L["Name:"] = "Nom:"
	L["Negator"] = "Pas"
	L["New Aura"] = "Nouvelle aura"
	--[[Translation missing --]]
	L["New Template"] = "New Template"
	L["New Value"] = "Nouvelle Valeur"
	L["No Children"] = "Aucun enfant"
	--[[Translation missing --]]
	L["No Logs saved."] = "No Logs saved."
	L["Not a table"] = "N'est pas une table"
	L["Not all children have the same value for this option"] = "Tous les enfants n'ont pas la mme valeur pour cette option"
	L["Not Loaded"] = "Non charg"
	--[[Translation missing --]]
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "Note: Automated Messages to SAY and YELL are blocked outside of Instances."
	--[[Translation missing --]]
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""
	L["Number of Entries"] = "Nombre d'entres"
	--[[Translation missing --]]
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=]
	--[[Translation missing --]]
	L["OFF"] = "OFF"
	--[[Translation missing --]]
	L["Offer a guided way to create auras for your character"] = "Offer a guided way to create auras for your character"
	--[[Translation missing --]]
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"
	L["Offset by 1px"] = "Dcalage de 1px"
	L["Okay"] = "Okay"
	--[[Translation missing --]]
	L["ON"] = "ON"
	L["On Hide"] = "Au masquage"
	L["On Show"] = "A l'affichage"
	--[[Translation missing --]]
	L["Only Match auras cast by a player (not an npc)"] = "Only Match auras cast by a player (not an npc)"
	--[[Translation missing --]]
	L["Only match auras cast by people other than the player or their pet"] = "Only match auras cast by people other than the player or their pet"
	--[[Translation missing --]]
	L["Only match auras cast by the player or their pet"] = "Only match auras cast by the player or their pet"
	L["Operator"] = "Oprateur"
	L["Option %i"] = "Option %i"
	L["Option key"] = "Clef de l'option"
	L["Option Type"] = "Type d'option"
	L["Options will open after combat ends."] = "Les options s'ouvriront aprs la fin du combat."
	L["or"] = "ou"
	--[[Translation missing --]]
	L["or %s"] = "or %s"
	L["Orange Rune"] = "Rune orange"
	--[[Translation missing --]]
	L["Our translators (too many to name)"] = "Our translators (too many to name)"
	L["Outer"] = "Extrieur"
	L["Overflow"] = "Dbordement"
	L["Overlay %s Info"] = "%s Infos en Superposition"
	L["Overlays"] = "Superpositions"
	L["Own Only"] = "Le mien uniquement"
	L["Paste Action Settings"] = "Coller les paramtres d'actions"
	L["Paste Animations Settings"] = "Coller les paramtres d'animations"
	L["Paste Author Options Settings"] = "Coller les paramtres des options de l'auteur"
	L["Paste Condition Settings"] = "Coller les paramtres de conditions"
	L["Paste Custom Configuration"] = "Coller les Options personnalises"
	L["Paste Display Settings"] = "Coller les paramtres d'affichage"
	L["Paste Group Settings"] = "Coller les paramtres du groupe"
	L["Paste Load Settings"] = "Coller les paramtres de chargement"
	L["Paste Settings"] = "Coller les paramtres"
	L["Paste text below"] = "Coller le texte ci-dessous"
	L["Paste Trigger Settings"] = "Coller les paramtres de dclencheurs"
	--[[Translation missing --]]
	L["Places a tick on the bar"] = "Places a tick on the bar"
	L["Play Sound"] = "Jouer un son"
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	L["Portrait Zoom"] = "Zoom Portrait"
	--[[Translation missing --]]
	L["Position and Size Settings"] = "Position and Size Settings"
	--[[Translation missing --]]
	L["Preferred Match"] = "Preferred Match"
	--[[Translation missing --]]
	L["Premade Auras"] = "Premade Auras"
	--[[Translation missing --]]
	L["Premade Snippets"] = "Premade Snippets"
	--[[Translation missing --]]
	L["Preparing auras: "] = "Preparing auras: "
	L["Press Ctrl+C to copy"] = "Appuyer sur Ctrl+C pour copier"
	L["Press Ctrl+C to copy the URL"] = "Appuyer sur Ctrl+C pour copier l'URL"
	--[[Translation missing --]]
	L["Prevent Merging"] = "Prevent Merging"
	--[[Translation missing --]]
	L["Progress - The remaining time of a timer, or a non-timer value"] = "Progress - The remaining time of a timer, or a non-timer value"
	L["Progress Bar"] = "Barre de progression"
	L["Progress Bar Settings"] = "Paramtres de la barre de progression"
	--[[Translation missing --]]
	L["Progress Settings"] = "Progress Settings"
	L["Progress Texture"] = "Texture de progression"
	L["Progress Texture Settings"] = "Paramtres de la texture de progression"
	L["Purple Rune"] = "Rune violette"
	L["Put this display in a group"] = "Placer cet affichage dans un groupe"
	--[[Translation missing --]]
	L["Range in yards"] = "Range in yards"
	--[[Translation missing --]]
	L["Ready for Install"] = "Ready for Install"
	--[[Translation missing --]]
	L["Ready for Update"] = "Ready for Update"
	L["Re-center X"] = "Re-centrer X"
	L["Re-center Y"] = "Rec-entrer Y"
	--[[Translation missing --]]
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "Reciprocal TRIGGER:# requests will be ignored!"
	--[[Translation missing --]]
	L["Redo"] = "Redo"
	L["Regions of type \"%s\" are not supported."] = "Les rgions de type \"%s\" ne sont pas prises en charge."
	L["Remove"] = "Retirer"
	--[[Translation missing --]]
	L["Remove All Sounds"] = "Remove All Sounds"
	--[[Translation missing --]]
	L["Remove All Text To Speech"] = "Remove All Text To Speech"
	L["Remove this display from its group"] = "Retirer cet affichage de son groupe"
	L["Remove this property"] = "Retirer cette proprit"
	L["Rename"] = "Renommer"
	L["Repeat After"] = "Rpter Aprs"
	L["Repeat every"] = "Rpter tous les"
	L["Report bugs on our issue tracker."] = "Signalez les bugs sur notre systme de suivi des problmes."
	--[[Translation missing --]]
	L["Require unit from trigger"] = "Require unit from trigger"
	L["Required for Activation"] = "Requis pour l'activation"
	--[[Translation missing --]]
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"
	L["Reset all options to their default values."] = "Rinitialiser toutes les options  leurs valeurs par dfaut."
	--[[Translation missing --]]
	L["Reset Entry"] = "Reset Entry"
	L["Reset to Defaults"] = "Rinitialiser les paramtres par dfaut"
	L["Right 2 HUD position"] = "Position ATH Droite 2"
	L["Right HUD position"] = "Position ATH Droite"
	L["Right-click for more options"] = "Clic-Droit pour plus d'options"
	L["Rotate"] = "Tourner"
	L["Rotate In"] = "Rotation entrante"
	L["Rotate Out"] = "Rotation sortante"
	L["Rotate Text"] = "Tourner le texte"
	L["Rotation Mode"] = "Mode de rotation"
	--[[Translation missing --]]
	L["Row Space"] = "Row Space"
	--[[Translation missing --]]
	L["Row Width"] = "Row Width"
	L["Rows"] = "Lignes"
	--[[Translation missing --]]
	L["Run on..."] = "Run on..."
	L["Same"] = "Le mme"
	--[[Translation missing --]]
	L["Same texture as Foreground"] = "Same texture as Foreground"
	--[[Translation missing --]]
	L["Saved Data"] = "Saved Data"
	--[[Translation missing --]]
	L["Scale Factor"] = "Scale Factor"
	--[[Translation missing --]]
	L["Search API"] = "Search API"
	--[[Translation missing --]]
	L["Select Talent"] = "Select Talent"
	L["Select the auras you always want to be listed first"] = "Choisissez les auras que vous voulez toujours voir apparatre en premier dans la liste"
	--[[Translation missing --]]
	L["Selected Frame"] = "Selected Frame"
	L["Send To"] = "Envoyer vers"
	L["Separator Text"] = "Texte Sparateur"
	L["Separator text"] = "texte sparateur"
	--[[Translation missing --]]
	L["Set Maximum Progress"] = "Set Maximum Progress"
	--[[Translation missing --]]
	L["Set Minimum Progress"] = "Set Minimum Progress"
	L["Set Parent to Anchor"] = "Dfinir Parent  l'Ancrage"
	L["Set Thumbnail Icon"] = "Dfinir la miniature"
	--[[Translation missing --]]
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."
	L["Settings"] = "Paramtres"
	--[[Translation missing --]]
	L["Shadow Color"] = "Shadow Color"
	L["Shadow X Offset"] = "Dcalage X de l'ombre"
	L["Shadow Y Offset"] = "Dcalage Y de l'ombre"
	L["Shift-click to create chat link"] = "Maj-Clic pour crer un lien de discussion"
	L["Show \"Edge\""] = "Afficher le \"Bord\""
	L["Show \"Swipe\""] = "Afficher le \"Balayage\""
	--[[Translation missing --]]
	L["Show and Clone Settings"] = "Show and Clone Settings"
	L["Show Border"] = "Afficher l'encadrement"
	--[[Translation missing --]]
	L["Show Circular Texture"] = "Show Circular Texture"
	--[[Translation missing --]]
	L["Show Debug Logs"] = "Show Debug Logs"
	L["Show Glow"] = "Brillance"
	L["Show Icon"] = "Afficher l'icne"
	--[[Translation missing --]]
	L["Show If Unit Does Not Exist"] = "Show If Unit Does Not Exist"
	--[[Translation missing --]]
	L["Show Linear Texture"] = "Show Linear Texture"
	--[[Translation missing --]]
	L["Show Matches for"] = "Show Matches for"
	--[[Translation missing --]]
	L["Show Matches for Units"] = "Show Matches for Units"
	--[[Translation missing --]]
	L["Show Model"] = "Show Model"
	L["Show model of unit "] = "Montrer le modle de l'unit"
	--[[Translation missing --]]
	L["Show Sound Setting"] = "Show Sound Setting"
	L["Show Spark"] = "Afficher l'tincelle"
	--[[Translation missing --]]
	L["Show Stop Motion"] = "Show Stop Motion"
	L["Show Text"] = "Afficher Texte"
	--[[Translation missing --]]
	L["Show Text To Speech Setting"] = "Show Text To Speech Setting"
	--[[Translation missing --]]
	L["Show Texture"] = "Show Texture"
	L["Show this group's children"] = "Afficher les enfants de ce groupe"
	--[[Translation missing --]]
	L["Show Tick"] = "Show Tick"
	L["Shows a 3D model from the game files"] = "Affiche un modle 3D tir du jeu"
	L["Shows a border"] = "Affiche un encadrement"
	--[[Translation missing --]]
	L["Shows a Circular Progress Texture"] = "Shows a Circular Progress Texture"
	L["Shows a custom texture"] = "Affiche une texture personnalise"
	L["Shows a glow"] = "Afficher les brillantes"
	--[[Translation missing --]]
	L["Shows a Linear Progress Texture"] = "Shows a Linear Progress Texture"
	L["Shows a model"] = "Affiche un modle"
	L["Shows a progress bar with name, timer, and icon"] = "Affiche une barre de progression avec nom, temps, et icne"
	L["Shows a spell icon with an optional cooldown overlay"] = "Affiche une icne de sort avec optionnellement la dure ou le temps de recharge intgr"
	--[[Translation missing --]]
	L["Shows a Stop Motion"] = "Shows a Stop Motion"
	--[[Translation missing --]]
	L["Shows a stop motion texture"] = "Shows a stop motion texture"
	--[[Translation missing --]]
	L["Shows a Texture"] = "Shows a Texture"
	L["Shows a texture that changes based on duration"] = "Affiche une texture qui change selon la dure"
	--[[Translation missing --]]
	L["Shows nothing, except sub elements"] = "Shows nothing, except sub elements"
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Affiche une ligne de texte ou plus, qui peut inclure des infos dynamiques telles que progression ou piles."
	L["Size"] = "Taille"
	--[[Translation missing --]]
	L["Slant Amount"] = "Slant Amount"
	--[[Translation missing --]]
	L["Slant Mode"] = "Slant Mode"
	L["Slanted"] = "Inclin"
	L["Slide"] = "Glisser"
	L["Slide In"] = "Glisser entrant"
	L["Slide Out"] = "Glisser sortant"
	--[[Translation missing --]]
	L["Slider Step Size"] = "Slider Step Size"
	L["Small Icon"] = "Petite icne"
	L["Smooth Progress"] = "Progrs Doux"
	--[[Translation missing --]]
	L["Snippets"] = "Snippets"
	--[[Translation missing --]]
	L["Soft Max"] = "Soft Max"
	--[[Translation missing --]]
	L["Soft Min"] = "Soft Min"
	L["Sort"] = "Trier"
	L["Sound Channel"] = "Canal sonore"
	L["Sound File Path"] = "Chemin fichier son"
	L["Sound Kit ID"] = "ID Kit Son"
	L["Space Horizontally"] = "Espacer horizontalement"
	L["Space Vertically"] = "Espacer verticalement"
	L["Spark Settings"] = "Paramtres de l'tincelle"
	L["Spark Texture"] = "Texture de l'tincelle"
	--[[Translation missing --]]
	L["Specific Currency ID"] = "Specific Currency ID"
	--[[Translation missing --]]
	L["Spell Selection Filters"] = "Spell Selection Filters"
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = "Info de Piles"
	--[[Translation missing --]]
	L["Stacks - The number of stacks of an aura (usually)"] = "Stacks - The number of stacks of an aura (usually)"
	--[[Translation missing --]]
	L["Standby"] = "Standby"
	L["Star"] = "toile"
	L["Start"] = "Dbut"
	L["Start Angle"] = "Angle de dpart"
	--[[Translation missing --]]
	L["Start Collapsed"] = "Start Collapsed"
	--[[Translation missing --]]
	L["Start of %s"] = "Start of %s"
	--[[Translation missing --]]
	L["Step Size"] = "Step Size"
	--[[Translation missing --]]
	L["Stop Motion %s"] = "Stop Motion %s"
	--[[Translation missing --]]
	L["Stop Motion Settings"] = "Stop Motion Settings"
	L["Stop Sound"] = "Arrter le son"
	--[[Translation missing --]]
	L["Stretched by Foreground"] = "Stretched by Foreground"
	--[[Translation missing --]]
	L["Sub Elements"] = "Sub Elements"
	--[[Translation missing --]]
	L["Sub Option %i"] = "Sub Option %i"
	--[[Translation missing --]]
	L["Subevent"] = "Subevent"
	--[[Translation missing --]]
	L["Subevent Suffix"] = "Subevent Suffix"
	L["Swipe Overlay Settings"] = "Paramtres de la superposition des balayages"
	--[[Translation missing --]]
	L["Templates could not be loaded, the addon is %s"] = "Templates could not be loaded, the addon is %s"
	L["Temporary Group"] = "Groupe temporaire"
	L["Text %s"] = "Texte %s"
	L["Text Color"] = "Couleur Texte"
	L["Text Settings"] = "Paramtres du texte"
	--[[Translation missing --]]
	L["Texture %s"] = "Texture %s"
	L["Texture Info"] = "Info Texture"
	--[[Translation missing --]]
	L["Texture Selection Mode"] = "Texture Selection Mode"
	L["Texture Settings"] = "Paramtres de la texture"
	L["Texture Wrap"] = "Enveloppe de texture"
	--[[Translation missing --]]
	L["Texture X Offset"] = "Texture X Offset"
	--[[Translation missing --]]
	L["Texture Y Offset"] = "Texture Y Offset"
	--[[Translation missing --]]
	L["Thanks"] = "Thanks"
	--[[Translation missing --]]
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"
	--[[Translation missing --]]
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"
	L["The duration of the animation in seconds."] = "La dure de l'animation en secondes."
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = "La dure de l'animation en secondes. L'animation de fin ne commence qu'aprs le moment o l'affichage est normalement cach."
	--[[Translation missing --]]
	L["The group and all direct children will share the same base frame level."] = "The group and all direct children will share the same base frame level."
	--[[Translation missing --]]
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."
	L["The type of trigger"] = "Le type de dclencheur"
	--[[Translation missing --]]
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"
	L["Then "] = "Alors"
	--[[Translation missing --]]
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."
	--[[Translation missing --]]
	L["This adds %raidMark as text replacements."] = "This adds %raidMark as text replacements."
	--[[Translation missing --]]
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."
	--[[Translation missing --]]
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."
	--[[Translation missing --]]
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=]
	--[[Translation missing --]]
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=]
	--[[Translation missing --]]
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=]
	L["This display is currently loaded"] = "Cet affichage est actuellement charg"
	L["This display is not currently loaded"] = "Cet affichage n'est pas charg"
	--[[Translation missing --]]
	L["This display is on standby, it will be loaded when needed."] = "This display is on standby, it will be loaded when needed."
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "Cela permet de collecter les journaux de dbogage. Un code personnalis peut ajouter des informations de dbogage au journal grce  la fonction DebugPrint."
	--[[Translation missing --]]
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "This is a modified version of your aura, |cff9900FF%s.|r"
	--[[Translation missing --]]
	L["This is a modified version of your group: |cff9900FF%s|r"] = "This is a modified version of your group: |cff9900FF%s|r"
	L["This region of type \"%s\" is not supported."] = "Cette rgion de type \"%s\" n'est pas supporte."
	L["This setting controls what widget is generated in user mode."] = "Ce paramtre contrle le widget gnr en mode utilisateur."
	--[[Translation missing --]]
	L["Thumbnail Icon"] = "Thumbnail Icon"
	L["Tick %s"] = "Coche %s"
	--[[Translation missing --]]
	L["Tick Area %s"] = "Tick Area %s"
	--[[Translation missing --]]
	L["Tick Center %s"] = "Tick Center %s"
	--[[Translation missing --]]
	L["Tick Mode"] = "Tick Mode"
	--[[Translation missing --]]
	L["Tick Placement"] = "Tick Placement"
	L["Time in"] = "Temps entrant"
	L["Tiny Icon"] = "Trs petite icne"
	L["To Frame's"] = "Au cadre de"
	--[[Translation missing --]]
	L["To Group's"] = "To Group's"
	L["To Personal Ressource Display's"] = " ... du cadre des Res. Perso"
	--[[Translation missing --]]
	L["To Region's"] = "To Region's"
	L["To Screen's"] = " ... de l'cran"
	L["Toggle the visibility of all loaded displays"] = "Change la visibilit de tous les affichages chargs"
	L["Toggle the visibility of all non-loaded displays"] = "Change la visibilit de tous les affichages non-chargs"
	L["Toggle the visibility of this display"] = "Activer/Dsactiver la visibilit de cet affichage"
	L["Tooltip Content"] = "Contenu de l'info-bulle"
	L["Tooltip on Mouseover"] = "Info-bulle  la souris"
	L["Tooltip Pattern Match"] = "Correspondance de modle de l'info-bulle"
	L["Tooltip Text"] = "Texte de l'Info-bulle."
	L["Tooltip Value"] = "Valeur de l'info-bulle"
	L["Tooltip Value #"] = "Valeur de l'info-bulle #"
	L["Top HUD position"] = "Position ATH Haute"
	--[[Translation missing --]]
	L["Total"] = "Total"
	--[[Translation missing --]]
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = "Total - The maximum duration of a timer, or a maximum non-timer value"
	--[[Translation missing --]]
	L["Total Angle"] = "Total Angle"
	--[[Translation missing --]]
	L["Total Time"] = "Total Time"
	--[[Translation missing --]]
	L["Trigger %i: %s"] = "Trigger %i: %s"
	--[[Translation missing --]]
	L["Trigger Combination"] = "Trigger Combination"
	--[[Translation missing --]]
	L["Type 'select' for '%s' requires a values member'"] = "Type 'select' for '%s' requires a values member'"
	--[[Translation missing --]]
	L["Undo"] = "Undo"
	L["Ungroup"] = "Dissocier"
	--[[Translation missing --]]
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "Unit %s is not a valid unit for RegisterUnitEvent"
	L["Unit Count"] = "Nombre d'unit"
	--[[Translation missing --]]
	L["Unknown"] = "Unknown"
	--[[Translation missing --]]
	L["Unknown Encounter's Spell Id"] = "Unknown Encounter's Spell Id"
	--[[Translation missing --]]
	L["Unknown property '%s' found in '%s'"] = "Unknown property '%s' found in '%s'"
	--[[Translation missing --]]
	L["Unknown Spell"] = "Unknown Spell"
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Contrairement aux animations de dbut et de fin, l'animation principale bouclera tant que l'affichage est visible."
	--[[Translation missing --]]
	L["Update"] = "Update"
	L["Update Auras"] = "Mettre  jour les auras"
	L["Update Custom Text On..."] = "Mettre  jour le texte personnalis sur..."
	L["URL"] = "URL"
	--[[Translation missing --]]
	L["Url: %s"] = "Url: %s"
	L["Use Display Info Id"] = "Utiliser les informations d'identifiant de l'affichage"
	L["Use SetTransform"] = "Utiliser SetTransform"
	L["Used in Auras:"] = "Utilis(e) dans les Auras:"
	L["Used in auras:"] = "Utilis dans les auras:"
	--[[Translation missing --]]
	L["Uses Texture Coordinates to rotate the texture."] = "Uses Texture Coordinates to rotate the texture."
	--[[Translation missing --]]
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."
	--[[Translation missing --]]
	L["Value"] = "Value"
	L["Value %i"] = "Valeur %i"
	L["Values are in normalized rgba format."] = "Les valeurs sont normalises dans le format rvba"
	--[[Translation missing --]]
	L["Values/Remaining Time above this value are displayed as full progress."] = "Values/Remaining Time above this value are displayed as full progress."
	--[[Translation missing --]]
	L["Values/Remaining Time below this value are displayed as zero progress."] = "Values/Remaining Time below this value are displayed as zero progress."
	L["Values:"] = "Valeurs:"
	L["Version: "] = "Version: "
	--[[Translation missing --]]
	L["Version: %s"] = "Version: %s"
	L["Vertical Align"] = "Aligner verticalement"
	L["Vertical Bar"] = "Barre verticale"
	L["View"] = "Vue"
	L["View custom code"] = "Afficher le code personnalis"
	--[[Translation missing --]]
	L["Voice Settings"] = "Voice Settings"
	--[[Translation missing --]]
	L["We thank"] = "We thank"
	--[[Translation missing --]]
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s on WoW %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	--[[Translation missing --]]
	L["What do you want to do?"] = "What do you want to do?"
	--[[Translation missing --]]
	L["Whole Area"] = "Whole Area"
	--[[Translation missing --]]
	L["wrapping"] = "wrapping"
	L["X Offset"] = "Dcalage X"
	L["X Rotation"] = "Rotation X"
	L["X Scale"] = "Echelle X"
	L["x-Offset"] = "x-Dcalage"
	L["Y Offset"] = "Dcalage Y"
	L["Y Rotation"] = "Rotation Y"
	L["Y Scale"] = "Echelle Y"
	L["Yellow Rune"] = "Rune jaune"
	L["y-Offset"] = "y-Dcalage"
	--[[Translation missing --]]
	L["You already have this group/aura. Importing will create a duplicate."] = "You already have this group/aura. Importing will create a duplicate."
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "Vous tes sur le point de supprimer %d aura(s). |cFFFF0000Cela ne peut pas tre annul !|r Voulez-vous continuer ?"
	--[[Translation missing --]]
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."
	--[[Translation missing --]]
	L["Your Saved Snippets"] = "Your Saved Snippets"
	L["Z Offset"] = "Dcalage Z"
	L["Z Rotation"] = "Rotation Z"
	L["Zoom In"] = "Zoom avant"
	L["Zoom Out"] = "Zoom arrire"


=== END OF FILE: WeakAurasOptions/Locales/frFR.lua ===


=== FILE: WeakAurasOptions/Locales/itIT.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "itIT" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = "e |cFFFF0000mirrored|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- Non rimuovere questo commento, fa parte di quest'aura:"
	L[" rotated |cFFFF0000%s|r degrees"] = "ruotato |cFFFF0000%s|r gradi"
	--[[Translation missing --]]
	L["% - To show a percent sign"] = "% - To show a percent sign"
	L["% of Progress"] = "% di Progresso"
	L["%d |4aura:auras; added"] = "%d |4aura:auras; aggiunto"
	L["%d |4aura:auras; deleted"] = "%d |4aura:auras; cancellato"
	L["%d |4aura:auras; modified"] = "%d |4aura:auras; modificata"
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; con dati meta modificati"
	L["%d displays loaded"] = "%d display caricato"
	L["%d displays not loaded"] = "%d display non caricato"
	L["%d displays on standby"] = "%d display in standby"
	L["%i auras selected"] = "%i aure selezionate"
	--[[Translation missing --]]
	L["%i."] = "%i."
	--[[Translation missing --]]
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i. Attivazione "
	L["%s - Alpha Animation"] = "%s - Animazione Alfabeto "
	L["%s - Color Animation"] = "%s - Colore Animazione "
	L["%s - Condition Custom Chat %s"] = "%s - Condizioni Chat Personalizzata %s"
	L["%s - Condition Custom Check %s"] = "%s - Verifica Personalizzata delle Condizioni %s"
	L["%s - Condition Custom Code %s"] = "%s - Condizione Codice Personalizzato %s"
	L["%s - Custom Anchor"] = "%s - Ancoraggio Personalizzato"
	L["%s - Custom Grow"] = "%s - Crescita Personalizzata"
	L["%s - Custom Sort"] = "%s - Ordinamento Personalizzato"
	L["%s - Custom Text"] = "%s - Testo Personalizzato"
	L["%s - Finish"] = "%s - Termina"
	L["%s - Finish Action"] = "%s - Termina l'Azione"
	L["%s - Finish Custom Text"] = "%s - Termina il Testo Personalizzato"
	L["%s - Init Action"] = "%s - Azione di Inizializzazione"
	L["%s - Main"] = "%s - Principale"
	--[[Translation missing --]]
	L["%s - OnLoad"] = "%s - OnLoad"
	--[[Translation missing --]]
	L["%s - OnUnload"] = "%s - OnUnload"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - L'opzione #%i ha la chiave %s. Scegli una chiave di opzione diversa."
	L["%s - Rotate Animation"] = "%s - Ruota Animazione"
	L["%s - Scale Animation"] = "%s - Scala Animazione"
	L["%s - Start"] = "%s - Avvia"
	L["%s - Start Action"] = "%s - Avvia Azione"
	L["%s - Start Custom Text"] = "%s - Avvia Testo Personalizzato"
	L["%s - Translate Animation"] = "%s - Traduci Animazione"
	L["%s - Trigger Logic"] = "%s - Logica di Attivazione"
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, Linee: %d, Frequenza: %0.2f, Lunghezza: %d, Spessore: %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, Particelle: %d, Frequenza: %0.2f, Scala: %0.2f"
	L["%s %u. Overlay Function"] = "%s %u. Funzione di Sovrapposizione"
	--[[Translation missing --]]
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s Alfabeto: %d%%"
	L["%s Color"] = "%s Colore"
	L["%s Custom Variables"] = "%s Variabili Personalizzate"
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s Alfabeto Predefinito, Zoom, Icona inserita, Proporzioni"
	L["%s Duration Function"] = "Funzione Durata %s"
	L["%s Icon Function"] = "Funzione Icona %s"
	L["%s Inset: %d%%"] = "%s Inserire: %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s non  un evento secondario valido per COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s Mantieni Proporzioni"
	L["%s Name Function"] = "%s Nome Funzione"
	L["%s Stacks Function"] = "%s Funzione Accumuli"
	L["%s stores around %s KB of data"] = "%s memorizza circa %s KB di dati"
	L["%s Texture"] = "%s Texture"
	L["%s Texture Function"] = "%s Funzione della Texture"
	L["%s total auras"] = "%s aure totali"
	L["%s Trigger Function"] = "Funzione di Attivazione %s"
	L["%s Untrigger Function"] = "%s Annulla Funzione di Attivazione"
	L["%s X offset by %d"] = "%s X deviazione di %d"
	L["%s Y offset by %d"] = "%s Y deviazione di %d"
	L["%s Zoom: %d%%"] = "%s Zoom: %d%%"
	L["%s, Border"] = "%s, Bordo"
	L["%s, Offset: %0.2f;%0.2f"] = "%s, Deviazione: %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, deviazione: %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s, Avvia l'animazione"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000custom|r texture con |cFFFF0000%s|r modalit di fusione%s%s"
	L["(Right click to rename)"] = "(Tasto destro per rinominare)"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02xColore Personalizzato|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999Attivazioni che tracciano pi unit verranno attivati per impostazione predefinita anche quando non viene trovata alcuna unit interessata senza l'applicazione di un'impostazione Conteggio unit o Conteggio corrispondenze.|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000Note:|r Imposta la descrizione solo su '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000Note:|r Imposta l'URL su tutte le aure selezionate"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000Note:|r Imposta l'URL di questo gruppo e di tutti i suoi membri."
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000Automatic|r lunghezza"
	--[[Translation missing --]]
	L["|cFFFF0000default|r texture"] = "|cFFFF0000default|r texture"
	--[[Translation missing --]]
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000desaturated|r "
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000Note:|r L'unit '%s' non  un'unit tracciabile."
	--[[Translation missing --]]
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Ancoraggio |cFFFF0000%s|r ai frame |cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Ancoraggio |cFFFF0000%s|r ai frame |cFFFF0000%s|r con deviazione |cFFFF0000%s/%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Ancoraggio ai frame |cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Ancoraggio ai frame |cFFFF0000%s|r con deviazione |cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00Opzioni Extra:|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00Extra:|r %s e %s %s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r e ombra |c%sColor|r con deviazione |cFFFF0000%s/%s|r%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r e ombra |c%sColor|r con deviazione |cFFFF0000%s/%s|r%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cffffcc00Opzioni Formato|r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = " |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r e |cff00ff00Pet|r corrispondono direttamente a quei singoli unitID.   |cff00ff00Unit specifica|r consente di fornire uno specifico ID unit valido da guardare.  |cffff0000Nota|r: il gioco non attiver eventi per tutti gli unitID validi, rendendone alcuni non tracciabili da questa attivazione.   |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r e |cffffff00Nameplate|r possono corrispondere a pi ID unit corrispondenti.   |cffffff00Smart Group|r si adatta al tipo di gruppo corrente, abbinando solo il \"giocatore\" in modalit solista, le unit \"party\" (incluso il \"giocatore\") in un party o le unit \"raid\" in un raid.   |cffffff00Multi-target|r tenta di utilizzare gli eventi del registro di combattimento, anzich l'ID unit, per tenere traccia delle unit interessate.  |cffff0000Nota|r: senza una relazione diretta con gli ID unit effettivi, i risultati possono variare.  |cffffff00*|r Giallo Le impostazioni delle unit possono corrispondere a pi unit e verranno attivate per impostazione predefinita anche quando non viene trovata alcuna unit interessata senza un'impostazione Conteggio unit o Conteggio corrispondenze."
	L["A 20x20 pixels icon"] = "Un' icona 20x20 pixel"
	L["A 32x32 pixels icon"] = "Un'icona 32x32 pixel"
	L["A 40x40 pixels icon"] = "Un'icona 40x40 pixel"
	L["A 48x48 pixels icon"] = "Un'icona 48x48 pixel"
	L["A 64x64 pixels icon"] = "Un'icona 64x64 pixel"
	L["A group that dynamically controls the positioning of its children"] = "Un gruppo che controlla dinamicamente la posizione dei propri figli"
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = "Un timer verr automaticamente visualizzato in base alle impostazioni dell'interfaccia predefinite (sostituite da alcuni componenti aggiuntivi). Abilita questa impostazione se vuoi che questo timer sia nascosto o quando usi un testo WeakAuras per visualizzare il timer"
	L["A Unit ID (e.g., party1)."] = "Un Unit ID (p.es., party1)"
	--[[Translation missing --]]
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = "Filtri e informazioni sull'aura attiva"
	L["Actual Spec"] = "Attuale Spec"
	L["Add %s"] = "Aggiungi %s"
	L["Add a new display"] = "Aggiungi un nuovo display"
	L["Add Condition"] = "Aggiungi Condizione"
	L["Add Entry"] = "Aggiungi Iscrizione "
	L["Add Extra Elements"] = "Aggiungi Elementi Extra"
	L["Add Option"] = "Aggiungi Opzione"
	L["Add Overlay"] = "Aggiungi Overlay"
	L["Add Property Change"] = "Aggiungi Cambio Caratteristica"
	L["Add Snippet"] = "Aggiungi Frammento "
	L["Add Sub Option"] = "Aggiungi opzione secondaria"
	L["Add to group %s"] = "Aggiungi al gruppo %s"
	L["Add to new Dynamic Group"] = "Aggiungi ad un nuovo Gruppo Dinamico"
	L["Add to new Group"] = "Aggiungi ad un nuoco Gruppo"
	L["Add Trigger"] = "Aggiungi attivazione "
	L["Additional Events"] = "Eventi Addizionali"
	L["Advanced"] = "Avanzate"
	L["Affected Unit Filters and Info"] = "Filtri e informazioni sulle unit interessate"
	L["Align"] = "Allinea"
	L["Alignment"] = "Allineamento"
	--[[Translation missing --]]
	L["All maintainers of the libraries we use, especially:"] = "All maintainers of the libraries we use, especially:"
	L["All of"] = "Tutto di"
	L["Allow Full Rotation"] = "Consenti rotazione completa"
	L["Anchor"] = "Ancora"
	--[[Translation missing --]]
	L["Anchor Mode"] = "Anchor Mode"
	L["Anchor Point"] = "Punto di ancoraggio"
	L["Anchored To"] = "Ancorato a"
	L["And "] = "E"
	L["and"] = "e"
	L["and %s"] = "e %s"
	L["and aligned left"] = "e allineato a sinistra"
	L["and aligned right"] = "e allineato a destra"
	--[[Translation missing --]]
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"
	L["and rotated left"] = "e ruotato a sinistra"
	L["and rotated right"] = "e ruotato a destra"
	L["and with width |cFFFF0000%s|r and %s"] = "e con larghezza |cFFFF0000%s|r e %s"
	L["Angle"] = "Angolo"
	L["Angle Between Auras"] = "Angolo tra le aure"
	L["Animate"] = "Animato"
	L["Animated Expand and Collapse"] = "Espansione e Compressione Animata"
	L["Animates progress changes"] = "Anima i cambi di avanzamento"
	L["Animation End"] = "Fine Animazione"
	L["Animation Mode"] = "Modalit Animazione"
	L["Animation relative duration description"] = "Descrizione della durata relativa dell'animazione"
	L["Animation Sequence"] = "Sequenza di Animazione"
	L["Animation Start"] = "Start Animazione "
	L["Any of"] = "Qualsiasi tra"
	L["Apply Template"] = "Applica Template"
	L["Arcane Orb"] = "Globo Arcano"
	--[[Translation missing --]]
	L["Area"] = "Area"
	L["At a position a bit left of Left HUD position."] = "In una posizione un po' a sinistra della posizione dell'HUD sinistro."
	L["At a position a bit left of Right HUD position"] = "In una posizione un po' a sinistra della posizione dell'HUD destro."
	L["At the same position as Blizzard's spell alert"] = "Nella stessa posizione dell'avviso magia della Blizzard"
	--[[Translation missing --]]
	L["Attach to Foreground"] = "Attach to Foreground"
	L[ [=[Aura is
Off Screen]=] ] = "L'aura  fuori dallo schermo"
	L["Aura Name Pattern"] = "Schema del Nome Aura"
	L["Aura Order"] = "Ordine dell'Aura"
	L["Aura received from: %s"] = "Aura ricevuta da: %s"
	--[[Translation missing --]]
	L["Aura: '%s'"] = "Aura: '%s'"
	L["Auto-Clone (Show All Matches)"] = "Auto-Clona (Mostra tutte le corrispondenze)"
	L["Automatic length"] = "Lunghezza automatica"
	L["Backdrop Color"] = "Colore Fondale"
	L["Backdrop in Front"] = "Fondale d'avanti"
	L["Backdrop Style"] = "Stile Fondale"
	L["Background Inner"] = "Sfondo interno"
	L["Background Offset"] = "Deviazione Sfondo"
	L["Background Texture"] = "Texture dello Sfondo"
	L["Bar Alpha"] = "Alfa della Barra"
	L["Bar Color Settings"] = "Impostazioni Colore Barra"
	L["Big Icon"] = "Icone Grandi"
	L["Blend Mode"] = "Modalit di Fusione"
	L["Blue Rune"] = "Runa Blu"
	L["Blue Sparkle Orb"] = "Sfera Luccicante Blu"
	L["Border %s"] = "Bordo %s"
	L["Border Anchor"] = "Ancora Bordo"
	L["Border Color"] = "Colore Bordo"
	L["Border in Front"] = "Bordi davanti"
	L["Border Inset"] = "Offset del Bordo"
	L["Border Offset"] = "Offset del Bordo"
	L["Border Settings"] = "Imbostazioni Bordo"
	L["Border Size"] = "Dimensioni Bordo"
	L["Border Style"] = "Stile Bordo"
	L["Bracket Matching"] = "Corrispondenza Parentesi"
	L["Browse Wago, the largest collection of auras."] = "Sfoglia Wago, la pi grande collezione di aure."
	--[[Translation missing --]]
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."
	L["Can be a UID (e.g., party1)."] = "Pu essere un UID (ad esempio, party1)."
	L["Can set to 0 if Columns * Width equal File Width"] = "Pu essere impostato su 0 se Colonne * Larghezza  uguale alla Larghezza file"
	L["Can set to 0 if Rows * Height equal File Height"] = "Pu essere impostato su 0 se Righe * Altezza  uguale all'altezza del file"
	--[[Translation missing --]]
	L["Case Insensitive"] = "Case Insensitive"
	L["Cast by a Player Character"] = "Cast da un personaggio giocante"
	L["Categories to Update"] = "Categorie da aggiornare"
	--[[Translation missing --]]
	L["Changelog"] = "Changelog"
	L["Chat with WeakAuras experts on our Discord server."] = "Chatta con gli esperti WeakAuras sul nostro server Discord."
	L["Check On..."] = "Controllare..."
	L["Check out our wiki for a large collection of examples and snippets."] = "Controlla la nostra wiki per un'ampia raccolta di esempi e frammenti."
	L["Children:"] = "Bambini:"
	L["Choose"] = "Scegliere"
	--[[Translation missing --]]
	L["Circular Texture %s"] = "Circular Texture %s"
	L["Clear Debug Logs"] = "Cancella registri di debug"
	L["Clear Saved Data"] = "Cancella dati salvati"
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	L["Clip Overlays"] = "Sovrapposizioni di clip"
	--[[Translation missing --]]
	L["Clipped by Foreground"] = "Clipped by Foreground"
	L["Close"] = "Chiudi"
	L["Code Editor"] = "Editore di codice"
	L["Collapse"] = "Comprimi"
	L["Collapse all loaded displays"] = "Comprimi tutti i display caricati"
	L["Collapse all non-loaded displays"] = "Comprimi tutti i display non caricati"
	L["Collapse all pending Import"] = "Comprimi tutto in attesa di importazione"
	L["Collapsible Group"] = "Comprimi Gruppo"
	L["color"] = "Colore"
	L["Column Height"] = "Altezza Colonna"
	L["Column Space"] = "Spazio colonna"
	L["Columns"] = "Colonne"
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "COMBAT_LOG_EVENT_UNFILTERED senza filtro pu attivare cadute di frame nell'ambiente raid."
	L["Combinations"] = "Combinazioni"
	L["Combine Matches Per Unit"] = "Combina partite per unit"
	L["Common Text"] = "Testo Comune"
	L["Compare against the number of units affected."] = "Confrontare con il numero di unit interessate."
	L["Compatibility Options"] = "Opzioni di compatibilit"
	L["Compress"] = "Comprimi"
	L["Configure what options appear on this panel."] = "Configura quali opzioni appaiono in questo pannello."
	L["Constant Factor"] = "Fattore Costante"
	L["Control-click to select multiple displays"] = "Fare clic tenendo premuto il tasto Control per selezionare pi display"
	L["Controls the positioning and configuration of multiple displays at the same time"] = "Controlla il posizionamento e la configurazione di pi display contemporaneamente"
	L["Convert to..."] = "Converti in..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "I numeri di Cooldown potrebbero essere aggiunti da WoW. Puoi configurarli nelle impostazioni del gioco."
	L["Copy"] = "Copia"
	L["Copy settings..."] = "Copia impostazioni..."
	L["Copy to all auras"] = "Copia in tutte le aure"
	--[[Translation missing --]]
	L["Could not parse '%s'. Expected a table."] = "Could not parse '%s'. Expected a table."
	L["Counts the number of matches over all units."] = "Conta il numero di corrispondenze su tutte le unit."
	L["Counts the number of matches per unit."] = "Conta il numero di corrispondenze per unit."
	L["Create a Copy"] = "Crea una copia"
	L["Creating buttons: "] = "Crea bottoni:"
	L["Creating options: "] = "Crea opzioni:"
	--[[Translation missing --]]
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."
	--[[Translation missing --]]
	L["Custom Code"] = "Custom Code"
	--[[Translation missing --]]
	L["Custom Code Viewer"] = "Custom Code Viewer"
	--[[Translation missing --]]
	L["Custom Frames"] = "Custom Frames"
	--[[Translation missing --]]
	L["Custom Functions"] = "Custom Functions"
	--[[Translation missing --]]
	L["Custom Init"] = "Custom Init"
	--[[Translation missing --]]
	L["Custom Load"] = "Custom Load"
	--[[Translation missing --]]
	L["Custom Options"] = "Custom Options"
	--[[Translation missing --]]
	L["Custom Text Update Throttle"] = "Custom Text Update Throttle"
	--[[Translation missing --]]
	L["Custom Trigger"] = "Custom Trigger"
	--[[Translation missing --]]
	L["Custom trigger event tooltip"] = [=[Choose which events cause the custom trigger to be checked. Multiple events can be specified using commas or spaces.
 "UNIT" events can use colons to define which unitIDs will be registered. In addition to UnitIDs Unit types can be used, they include "nameplate", "group", "raid", "party", "arena", "boss".
 "CLEU" can be used instead of COMBAT_LOG_EVENT_UNFILTERED and colons can be used to separate specific "subEvents" you want to receive.
 The keyword "TRIGGER" can be used, with colons separating trigger numbers, to have the custom trigger get updated when the specified trigger(s) update.

|cFF4444FFFor example:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1
]=]
	--[[Translation missing --]]
	L["Custom trigger status tooltip"] = [=[Choose which events cause the custom trigger to be checked. Multiple events can be specified using commas or spaces.

 "UNIT" events can use colons to define which unitIDs will be registered. In addition to UnitIDs Unit types can be used, they include "nameplate", "group", "raid", "party", "arena", "boss".
 "CLEU" can be used instead of COMBAT_LOG_EVENT_UNFILTERED and colons can be used to separate specific "subEvents" you want to receive.
 The keyword "TRIGGER" can be used, with colons separating trigger numbers, to have the custom trigger get updated when the specified trigger(s) update.

Since this is a status-type trigger, the specified events may be called by WeakAuras without the expected arguments.

|cFF4444FFFor example:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1
]=]
	--[[Translation missing --]]
	L["Custom trigger Update Throttle"] = "Custom trigger Update Throttle"
	--[[Translation missing --]]
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "Custom Trigger: Ignore Lua Errors on OPTIONS event"
	--[[Translation missing --]]
	L["Custom Trigger: Send fake events instead of STATUS event"] = "Custom Trigger: Send fake events instead of STATUS event"
	--[[Translation missing --]]
	L["Custom Unload"] = "Custom Unload"
	--[[Translation missing --]]
	L["Custom Untrigger"] = "Custom Untrigger"
	--[[Translation missing --]]
	L["Debug Log"] = "Debug Log"
	--[[Translation missing --]]
	L["Debug Log:"] = "Debug Log:"
	--[[Translation missing --]]
	L["Default"] = "Default"
	--[[Translation missing --]]
	L["Default Color"] = "Default Color"
	--[[Translation missing --]]
	L["Delay"] = "Delay"
	--[[Translation missing --]]
	L["Delete"] = "Delete"
	--[[Translation missing --]]
	L["Delete all"] = "Delete all"
	--[[Translation missing --]]
	L["Delete children and group"] = "Delete children and group"
	--[[Translation missing --]]
	L["Delete Entry"] = "Delete Entry"
	--[[Translation missing --]]
	L["Deleting auras: "] = "Deleting auras: "
	--[[Translation missing --]]
	L["Description Text"] = "Description Text"
	--[[Translation missing --]]
	L["Determines how many entries can be in the table."] = "Determines how many entries can be in the table."
	--[[Translation missing --]]
	L["Differences"] = "Differences"
	--[[Translation missing --]]
	L["Disallow Entry Reordering"] = "Disallow Entry Reordering"
	--[[Translation missing --]]
	L["Discord"] = "Discord"
	--[[Translation missing --]]
	L["Display Name"] = "Display Name"
	--[[Translation missing --]]
	L["Display Text"] = "Display Text"
	--[[Translation missing --]]
	L["Displays a text, works best in combination with other displays"] = "Displays a text, works best in combination with other displays"
	--[[Translation missing --]]
	L["Distribute Horizontally"] = "Distribute Horizontally"
	--[[Translation missing --]]
	L["Distribute Vertically"] = "Distribute Vertically"
	--[[Translation missing --]]
	L["Do not group this display"] = "Do not group this display"
	--[[Translation missing --]]
	L["Do you want to enable updates for this aura"] = "Do you want to enable updates for this aura"
	--[[Translation missing --]]
	L["Do you want to ignore updates for this aura"] = "Do you want to ignore updates for this aura"
	--[[Translation missing --]]
	L["Documentation"] = "Documentation"
	--[[Translation missing --]]
	L["Done"] = "Done"
	--[[Translation missing --]]
	L["Drag to move"] = "Drag to move"
	--[[Translation missing --]]
	L["Duplicate"] = "Duplicate"
	--[[Translation missing --]]
	L["Duplicate All"] = "Duplicate All"
	--[[Translation missing --]]
	L["Duration (s)"] = "Duration (s)"
	--[[Translation missing --]]
	L["Duration Info"] = "Duration Info"
	--[[Translation missing --]]
	L["Dynamic Duration"] = "Dynamic Duration"
	--[[Translation missing --]]
	L["Dynamic Group"] = "Dynamic Group"
	--[[Translation missing --]]
	L["Dynamic Group Settings"] = "Dynamic Group Settings"
	--[[Translation missing --]]
	L["Dynamic Information"] = "Dynamic Information"
	--[[Translation missing --]]
	L["Dynamic information from first active trigger"] = "Dynamic information from first active trigger"
	--[[Translation missing --]]
	L["Dynamic information from Trigger %i"] = "Dynamic information from Trigger %i"
	--[[Translation missing --]]
	L["Dynamic Text Replacements"] = "Dynamic Text Replacements"
	--[[Translation missing --]]
	L["Ease Strength"] = "Ease Strength"
	--[[Translation missing --]]
	L["Ease type"] = "Ease type"
	--[[Translation missing --]]
	L["eliding"] = "eliding"
	--[[Translation missing --]]
	L["Else If"] = "Else If"
	--[[Translation missing --]]
	L["Else If %s"] = "Else If %s"
	--[[Translation missing --]]
	L["Empty Base Region"] = "Empty Base Region"
	--[[Translation missing --]]
	L["Enable \"Edge\" part of the overlay"] = "Enable \"Edge\" part of the overlay"
	--[[Translation missing --]]
	L["Enable \"swipe\" part of the overlay"] = "Enable \"swipe\" part of the overlay"
	--[[Translation missing --]]
	L["Enable Debug Log"] = "Enable Debug Log"
	--[[Translation missing --]]
	L["Enable Debug Logging"] = "Enable Debug Logging"
	--[[Translation missing --]]
	L["Enable Gradient"] = "Enable Gradient"
	--[[Translation missing --]]
	L["Enable Swipe"] = "Enable Swipe"
	--[[Translation missing --]]
	L["Enable the \"Swipe\" radial overlay"] = "Enable the \"Swipe\" radial overlay"
	--[[Translation missing --]]
	L["Enabled"] = "Enabled"
	--[[Translation missing --]]
	L["End Angle"] = "End Angle"
	--[[Translation missing --]]
	L["End of %s"] = "End of %s"
	--[[Translation missing --]]
	L["Enemy nameplate(s) found"] = "Enemy nameplate(s) found"
	--[[Translation missing --]]
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "Enter a Spell ID. You can use the addon idTip to determine spell ids."
	--[[Translation missing --]]
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = "Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."
	--[[Translation missing --]]
	L["Enter Author Mode"] = "Enter Author Mode"
	--[[Translation missing --]]
	L["Enter in a value for the tick's placement."] = "Enter in a value for the tick's placement."
	--[[Translation missing --]]
	L["Enter static or relative values with %"] = "Enter static or relative values with %"
	--[[Translation missing --]]
	L["Enter User Mode"] = "Enter User Mode"
	--[[Translation missing --]]
	L["Enter user mode."] = "Enter user mode."
	--[[Translation missing --]]
	L["Entry %i"] = "Entry %i"
	--[[Translation missing --]]
	L["Entry limit"] = "Entry limit"
	--[[Translation missing --]]
	L["Entry Name Source"] = "Entry Name Source"
	L["Event Type"] = "Tipo di Evento"
	--[[Translation missing --]]
	L["Everything"] = "Everything"
	--[[Translation missing --]]
	L["Exact Item Match"] = "Exact Item Match"
	--[[Translation missing --]]
	L["Exact Spell Match"] = "Exact Spell Match"
	--[[Translation missing --]]
	L["Expand"] = "Expand"
	--[[Translation missing --]]
	L["Expand all loaded displays"] = "Expand all loaded displays"
	--[[Translation missing --]]
	L["Expand all non-loaded displays"] = "Expand all non-loaded displays"
	--[[Translation missing --]]
	L["Expand all pending Import"] = "Expand all pending Import"
	--[[Translation missing --]]
	L["Expansion is disabled because this group has no children"] = "Expansion is disabled because this group has no children"
	--[[Translation missing --]]
	L["Export debug table..."] = "Export debug table..."
	--[[Translation missing --]]
	L["Export..."] = "Export..."
	--[[Translation missing --]]
	L["Exporting"] = "Exporting"
	--[[Translation missing --]]
	L["External"] = "External"
	--[[Translation missing --]]
	L["Extra Height"] = "Extra Height"
	--[[Translation missing --]]
	L["Extra Width"] = "Extra Width"
	--[[Translation missing --]]
	L["Fade"] = "Fade"
	--[[Translation missing --]]
	L["Fadeout Sound"] = "Fadeout Sound"
	--[[Translation missing --]]
	L["Fadeout Time (seconds)"] = "Fadeout Time (seconds)"
	--[[Translation missing --]]
	L["Fetch Affected/Unaffected Names and Units"] = "Fetch Affected/Unaffected Names and Units"
	--[[Translation missing --]]
	L["Fetch Raid Mark Information"] = "Fetch Raid Mark Information"
	--[[Translation missing --]]
	L["Fetch Role Information"] = "Fetch Role Information"
	--[[Translation missing --]]
	L["Fetch Tooltip Information"] = "Fetch Tooltip Information"
	--[[Translation missing --]]
	L["File Height"] = "File Height"
	--[[Translation missing --]]
	L["File Width"] = "File Width"
	--[[Translation missing --]]
	L["Filter based on the spell Name string."] = "Filter based on the spell Name string."
	--[[Translation missing --]]
	L["Filter by Arena Spec"] = "Filter by Arena Spec"
	--[[Translation missing --]]
	L["Filter by Class"] = "Filter by Class"
	--[[Translation missing --]]
	L["Filter by Group Role"] = "Filter by Group Role"
	--[[Translation missing --]]
	L["Filter by Hostility"] = "Filter by Hostility"
	--[[Translation missing --]]
	L["Filter by Npc ID"] = "Filter by Npc ID"
	--[[Translation missing --]]
	L["Filter by Raid Role"] = "Filter by Raid Role"
	--[[Translation missing --]]
	L["Filter by Specialization"] = "Filter by Specialization"
	--[[Translation missing --]]
	L["Filter by Unit Name"] = "Filter by Unit Name"
	--[[Translation missing --]]
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
	--[[Translation missing --]]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=]
	--[[Translation missing --]]
	L["Find Auras"] = "Find Auras"
	--[[Translation missing --]]
	L["Finish"] = "Finish"
	--[[Translation missing --]]
	L["Finishing..."] = "Finishing..."
	--[[Translation missing --]]
	L["Fire Orb"] = "Fire Orb"
	--[[Translation missing --]]
	L["Flat Framelevels"] = "Flat Framelevels"
	--[[Translation missing --]]
	L["Foreground Texture"] = "Foreground Texture"
	--[[Translation missing --]]
	L["Format for %s"] = "Format for %s"
	--[[Translation missing --]]
	L["Found a Bug?"] = "Found a Bug?"
	--[[Translation missing --]]
	L["Frame"] = "Frame"
	--[[Translation missing --]]
	L["Frame Count"] = "Frame Count"
	--[[Translation missing --]]
	L["Frame Height"] = "Frame Height"
	--[[Translation missing --]]
	L["Frame Rate"] = "Frame Rate"
	--[[Translation missing --]]
	L["Frame Strata"] = "Frame Strata"
	--[[Translation missing --]]
	L["Frame Width"] = "Frame Width"
	--[[Translation missing --]]
	L["Full Bar"] = "Full Bar"
	--[[Translation missing --]]
	L["Full Circle"] = "Full Circle"
	--[[Translation missing --]]
	L["Global Conditions"] = "Global Conditions"
	--[[Translation missing --]]
	L["Glow %s"] = "Glow %s"
	--[[Translation missing --]]
	L["Glow Action"] = "Glow Action"
	--[[Translation missing --]]
	L["Glow Anchor"] = "Glow Anchor"
	--[[Translation missing --]]
	L["Glow Color"] = "Glow Color"
	--[[Translation missing --]]
	L["Glow Frame Type"] = "Glow Frame Type"
	--[[Translation missing --]]
	L["Glow Type"] = "Glow Type"
	--[[Translation missing --]]
	L["Green Rune"] = "Green Rune"
	--[[Translation missing --]]
	L["Grid direction"] = "Grid direction"
	--[[Translation missing --]]
	L["Group (verb)"] = "Group"
	--[[Translation missing --]]
	L["Group Alpha"] = "Group Alpha"
	--[[Translation missing --]]
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=]
	--[[Translation missing --]]
	L["Group aura count description"] = [=[The amount of units of type '%s' which must be affected by one or more of the given auras for the display to trigger.
If the entered number is a whole number (e.g. 5), the number of affected units will be compared with the entered number.
If the entered number is a decimal (e.g. 0.5), fraction (e.g. 1/2), or percentage (e.g. 50%%), then that fraction of the %s must be affected.

|cFF4444FFFor example:|r
|cFF00CC00> 0|r will trigger when any unit of type '%s' is affected
|cFF00CC00= 100%%|r will trigger when every unit of type '%s' is affected
|cFF00CC00!= 2|r will trigger when the number of units of type '%s' affected is not exactly 2
|cFF00CC00<= 0.8|r will trigger when less than 80%% of the units of type '%s' is affected (4 of 5 party members, 8 of 10 or 20 of 25 raid members)
|cFF00CC00> 1/2|r will trigger when more than half of the units of type '%s' is affected
]=]
	--[[Translation missing --]]
	L["Group by Frame"] = "Group by Frame"
	--[[Translation missing --]]
	L["Group Description"] = "Group Description"
	--[[Translation missing --]]
	L["Group Icon"] = "Group Icon"
	--[[Translation missing --]]
	L["Group key"] = "Group key"
	--[[Translation missing --]]
	L["Group Options"] = "Group Options"
	--[[Translation missing --]]
	L["Group player(s) found"] = "Group player(s) found"
	--[[Translation missing --]]
	L["Group Role"] = "Group Role"
	--[[Translation missing --]]
	L["Group Scale"] = "Group Scale"
	--[[Translation missing --]]
	L["Group Settings"] = "Group Settings"
	--[[Translation missing --]]
	L["Hawk"] = "Hawk"
	--[[Translation missing --]]
	L["Help"] = "Help"
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	--[[Translation missing --]]
	L["Hide Background"] = "Hide Background"
	--[[Translation missing --]]
	L["Hide Glows applied by this aura"] = "Hide Glows applied by this aura"
	--[[Translation missing --]]
	L["Hide on"] = "Hide on"
	--[[Translation missing --]]
	L["Hide this group's children"] = "Hide this group's children"
	--[[Translation missing --]]
	L["Highlights"] = "Highlights"
	--[[Translation missing --]]
	L["Horizontal Align"] = "Horizontal Align"
	--[[Translation missing --]]
	L["Horizontal Bar"] = "Horizontal Bar"
	--[[Translation missing --]]
	L["Huge Icon"] = "Huge Icon"
	--[[Translation missing --]]
	L["Hybrid Position"] = "Hybrid Position"
	--[[Translation missing --]]
	L["Hybrid Sort Mode"] = "Hybrid Sort Mode"
	--[[Translation missing --]]
	L["Icon - The icon associated with the display"] = "Icon - The icon associated with the display"
	--[[Translation missing --]]
	L["Icon Info"] = "Icon Info"
	--[[Translation missing --]]
	L["Icon Inset"] = "Icon Inset"
	--[[Translation missing --]]
	L["Icon Picker"] = "Icon Picker"
	--[[Translation missing --]]
	L["Icon Position"] = "Icon Position"
	--[[Translation missing --]]
	L["Icon Settings"] = "Icon Settings"
	--[[Translation missing --]]
	L["Icon Source"] = "Icon Source"
	--[[Translation missing --]]
	L["If"] = "If"
	--[[Translation missing --]]
	L["If %s"] = "If %s"
	--[[Translation missing --]]
	L["If checked, then the combo box in the User settings will be sorted."] = "If checked, then the combo box in the User settings will be sorted."
	--[[Translation missing --]]
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."
	--[[Translation missing --]]
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "If checked, then this group will not merge with other group when selecting multiple auras."
	--[[Translation missing --]]
	L["If checked, then this option group can be temporarily collapsed by the user."] = "If checked, then this option group can be temporarily collapsed by the user."
	--[[Translation missing --]]
	L["If checked, then this option group will start collapsed."] = "If checked, then this option group will start collapsed."
	--[[Translation missing --]]
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "If checked, then this separator will include text. Otherwise, it will be just a horizontal line."
	--[[Translation missing --]]
	L["If checked, then this space will span across multiple lines."] = "If checked, then this space will span across multiple lines."
	--[[Translation missing --]]
	L["If unchecked, then a default color will be used (usually yellow)"] = "If unchecked, then a default color will be used (usually yellow)"
	--[[Translation missing --]]
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "If unchecked, then this space will fill the entire line it is on in User Mode."
	--[[Translation missing --]]
	L["Ignore out of casting range"] = "Ignore out of casting range"
	--[[Translation missing --]]
	L["Ignore out of checking range"] = "Ignore out of checking range"
	--[[Translation missing --]]
	L["Ignore Wago updates"] = "Ignore Wago updates"
	--[[Translation missing --]]
	L["Ignored"] = "Ignored"
	--[[Translation missing --]]
	L["Ignored Aura Name"] = "Ignored Aura Name"
	--[[Translation missing --]]
	L["Ignored Exact Spell ID(s)"] = "Ignored Exact Spell ID(s)"
	--[[Translation missing --]]
	L["Ignored Name(s)"] = "Ignored Name(s)"
	--[[Translation missing --]]
	L["Ignored Spell ID"] = "Ignored Spell ID"
	--[[Translation missing --]]
	L["Import"] = "Import"
	--[[Translation missing --]]
	L["Import / Export"] = "Import / Export"
	--[[Translation missing --]]
	L["Import a display from an encoded string"] = "Import a display from an encoded string"
	--[[Translation missing --]]
	L["Import as Copy"] = "Import as Copy"
	--[[Translation missing --]]
	L["Import has no UID, cannot be matched to existing auras."] = "Import has no UID, cannot be matched to existing auras."
	--[[Translation missing --]]
	L["Importing"] = "Importing"
	--[[Translation missing --]]
	L["Importing %s"] = "Importing %s"
	--[[Translation missing --]]
	L["Importing a group with %s child auras."] = "Importing a group with %s child auras."
	--[[Translation missing --]]
	L["Importing a stand-alone aura."] = "Importing a stand-alone aura."
	--[[Translation missing --]]
	L["Importing...."] = "Importing...."
	--[[Translation missing --]]
	L["Incompatible changes to group region types detected"] = "Incompatible changes to group region types detected"
	--[[Translation missing --]]
	L["Incompatible changes to group structure detected"] = "Incompatible changes to group structure detected"
	--[[Translation missing --]]
	L["Indent Size"] = "Indent Size"
	--[[Translation missing --]]
	L["Inner"] = "Inner"
	--[[Translation missing --]]
	L["Insert text replacement codes to make text dynamic."] = "Insert text replacement codes to make text dynamic."
	--[[Translation missing --]]
	L["Invalid Item ID"] = "Invalid Item ID"
	--[[Translation missing --]]
	L["Invalid Item Name/ID/Link"] = "Invalid Item Name/ID/Link"
	--[[Translation missing --]]
	L["Invalid Spell ID"] = "Invalid Spell ID"
	--[[Translation missing --]]
	L["Invalid Spell Name/ID/Link"] = "Invalid Spell Name/ID/Link"
	--[[Translation missing --]]
	L["Invalid target aura"] = "Invalid target aura"
	--[[Translation missing --]]
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."
	--[[Translation missing --]]
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "Invalid type for property '%s' in '%s'. Expected '%s'"
	--[[Translation missing --]]
	L["Inverse Slant"] = "Inverse Slant"
	--[[Translation missing --]]
	L["Invert the direction of progress"] = "Invert the direction of progress"
	--[[Translation missing --]]
	L["Is Boss Debuff"] = "Is Boss Debuff"
	--[[Translation missing --]]
	L["Is Stealable"] = "Is Stealable"
	--[[Translation missing --]]
	L["Is Unit"] = "Is Unit"
	--[[Translation missing --]]
	L["Justify"] = "Justify"
	--[[Translation missing --]]
	L["Keep Aspect Ratio"] = "Keep Aspect Ratio"
	--[[Translation missing --]]
	L["Keep your Wago imports up to date with the Companion App."] = "Keep your Wago imports up to date with the Companion App."
	--[[Translation missing --]]
	L["Large Input"] = "Large Input"
	--[[Translation missing --]]
	L["Leaf"] = "Leaf"
	--[[Translation missing --]]
	L["Left 2 HUD position"] = "Left 2 HUD position"
	--[[Translation missing --]]
	L["Left HUD position"] = "Left HUD position"
	--[[Translation missing --]]
	L["Length of |cFFFF0000%s|r"] = "Length of |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	--[[Translation missing --]]
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	--[[Translation missing --]]
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	--[[Translation missing --]]
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	--[[Translation missing --]]
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	--[[Translation missing --]]
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	--[[Translation missing --]]
	L["Limit"] = "Limit"
	--[[Translation missing --]]
	L["Line"] = "Line"
	--[[Translation missing --]]
	L["Linear Texture %s"] = "Linear Texture %s"
	--[[Translation missing --]]
	L["Linked aura: "] = "Linked aura: "
	--[[Translation missing --]]
	L["Linked Auras"] = "Linked Auras"
	--[[Translation missing --]]
	L["Load"] = "Load"
	--[[Translation missing --]]
	L["Loaded"] = "Loaded"
	--[[Translation missing --]]
	L["Loaded/Standby"] = "Loaded/Standby"
	--[[Translation missing --]]
	L["Lock Positions"] = "Lock Positions"
	--[[Translation missing --]]
	L["Low Mana"] = "Low Mana"
	--[[Translation missing --]]
	L["Magnetically Align"] = "Magnetically Align"
	--[[Translation missing --]]
	L["Main"] = "Main"
	--[[Translation missing --]]
	L["Manual with %i/%i"] = "Manual with %i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	--[[Translation missing --]]
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "Matches the height setting of a horizontal bar or width for a vertical bar."
	--[[Translation missing --]]
	L["Max"] = "Max"
	--[[Translation missing --]]
	L["Max Length"] = "Max Length"
	--[[Translation missing --]]
	L["Maximum"] = "Maximum"
	--[[Translation missing --]]
	L["Media Type"] = "Media Type"
	--[[Translation missing --]]
	L["Medium Icon"] = "Medium Icon"
	--[[Translation missing --]]
	L["Min"] = "Min"
	--[[Translation missing --]]
	L["Minimum"] = "Minimum"
	--[[Translation missing --]]
	L["Model %s"] = "Model %s"
	--[[Translation missing --]]
	L["Model Picker"] = "Model Picker"
	--[[Translation missing --]]
	L["Model Settings"] = "Model Settings"
	--[[Translation missing --]]
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths could not be loaded, the addon is %s"
	--[[Translation missing --]]
	L["Move Above Group"] = "Move Above Group"
	--[[Translation missing --]]
	L["Move Below Group"] = "Move Below Group"
	--[[Translation missing --]]
	L["Move Down"] = "Move Down"
	--[[Translation missing --]]
	L["Move Entry Down"] = "Move Entry Down"
	--[[Translation missing --]]
	L["Move Entry Up"] = "Move Entry Up"
	--[[Translation missing --]]
	L["Move Into Above Group"] = "Move Into Above Group"
	--[[Translation missing --]]
	L["Move Into Below Group"] = "Move Into Below Group"
	--[[Translation missing --]]
	L["Move this display down in its group's order"] = "Move this display down in its group's order"
	--[[Translation missing --]]
	L["Move this display up in its group's order"] = "Move this display up in its group's order"
	--[[Translation missing --]]
	L["Move Up"] = "Move Up"
	--[[Translation missing --]]
	L["Moving auras: "] = "Moving auras: "
	--[[Translation missing --]]
	L["Multiple Displays"] = "Multiple Displays"
	--[[Translation missing --]]
	L["Multiselect ignored tooltip"] = [=[|cFFFF0000Ignored|r - |cFF777777Single|r - |cFF777777Multiple|r
This option will not be used to determine when this display should load]=]
	--[[Translation missing --]]
	L["Multiselect multiple tooltip"] = [=[|cFF777777Ignored|r - |cFF777777Single|r - |cFF00FF00Multiple|r
Any number of matching values can be picked]=]
	--[[Translation missing --]]
	L["Multiselect single tooltip"] = [=[|cFF777777Ignored|r - |cFF00FF00Single|r - |cFF777777Multiple|r
Only a single matching value can be picked]=]
	--[[Translation missing --]]
	L["Must be a power of 2"] = "Must be a power of 2"
	--[[Translation missing --]]
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"
	--[[Translation missing --]]
	L["Name Info"] = "Name Info"
	--[[Translation missing --]]
	L["Name Pattern Match"] = "Name Pattern Match"
	--[[Translation missing --]]
	L["Name:"] = "Name:"
	--[[Translation missing --]]
	L["Negator"] = "Not"
	--[[Translation missing --]]
	L["New Aura"] = "New Aura"
	--[[Translation missing --]]
	L["New Template"] = "New Template"
	--[[Translation missing --]]
	L["New Value"] = "New Value"
	--[[Translation missing --]]
	L["No Children"] = "No Children"
	--[[Translation missing --]]
	L["No Logs saved."] = "No Logs saved."
	--[[Translation missing --]]
	L["Not a table"] = "Not a table"
	--[[Translation missing --]]
	L["Not all children have the same value for this option"] = "Not all children have the same value for this option"
	--[[Translation missing --]]
	L["Not Loaded"] = "Not Loaded"
	--[[Translation missing --]]
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "Note: Automated Messages to SAY and YELL are blocked outside of Instances."
	--[[Translation missing --]]
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""
	--[[Translation missing --]]
	L["Number of Entries"] = "Number of Entries"
	--[[Translation missing --]]
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=]
	--[[Translation missing --]]
	L["OFF"] = "OFF"
	--[[Translation missing --]]
	L["Offer a guided way to create auras for your character"] = "Offer a guided way to create auras for your character"
	--[[Translation missing --]]
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"
	--[[Translation missing --]]
	L["Offset by 1px"] = "Offset by 1px"
	--[[Translation missing --]]
	L["Okay"] = "Okay"
	--[[Translation missing --]]
	L["ON"] = "ON"
	--[[Translation missing --]]
	L["On Hide"] = "On Hide"
	--[[Translation missing --]]
	L["On Show"] = "On Show"
	--[[Translation missing --]]
	L["Only Match auras cast by a player (not an npc)"] = "Only Match auras cast by a player (not an npc)"
	--[[Translation missing --]]
	L["Only match auras cast by people other than the player or their pet"] = "Only match auras cast by people other than the player or their pet"
	--[[Translation missing --]]
	L["Only match auras cast by the player or their pet"] = "Only match auras cast by the player or their pet"
	--[[Translation missing --]]
	L["Operator"] = "Operator"
	--[[Translation missing --]]
	L["Option %i"] = "Option %i"
	--[[Translation missing --]]
	L["Option key"] = "Option key"
	--[[Translation missing --]]
	L["Option Type"] = "Option Type"
	--[[Translation missing --]]
	L["Options will open after combat ends."] = "Options will open after combat ends."
	--[[Translation missing --]]
	L["or"] = "or"
	--[[Translation missing --]]
	L["or %s"] = "or %s"
	--[[Translation missing --]]
	L["Orange Rune"] = "Orange Rune"
	--[[Translation missing --]]
	L["Our translators (too many to name)"] = "Our translators (too many to name)"
	--[[Translation missing --]]
	L["Outer"] = "Outer"
	--[[Translation missing --]]
	L["Overflow"] = "Overflow"
	--[[Translation missing --]]
	L["Overlay %s Info"] = "Overlay %s Info"
	--[[Translation missing --]]
	L["Overlays"] = "Overlays"
	--[[Translation missing --]]
	L["Own Only"] = "Own Only"
	--[[Translation missing --]]
	L["Paste Action Settings"] = "Paste Action Settings"
	--[[Translation missing --]]
	L["Paste Animations Settings"] = "Paste Animations Settings"
	--[[Translation missing --]]
	L["Paste Author Options Settings"] = "Paste Author Options Settings"
	--[[Translation missing --]]
	L["Paste Condition Settings"] = "Paste Condition Settings"
	--[[Translation missing --]]
	L["Paste Custom Configuration"] = "Paste Custom Configuration"
	--[[Translation missing --]]
	L["Paste Display Settings"] = "Paste Display Settings"
	--[[Translation missing --]]
	L["Paste Group Settings"] = "Paste Group Settings"
	--[[Translation missing --]]
	L["Paste Load Settings"] = "Paste Load Settings"
	--[[Translation missing --]]
	L["Paste Settings"] = "Paste Settings"
	--[[Translation missing --]]
	L["Paste text below"] = "Paste text below"
	--[[Translation missing --]]
	L["Paste Trigger Settings"] = "Paste Trigger Settings"
	--[[Translation missing --]]
	L["Places a tick on the bar"] = "Places a tick on the bar"
	--[[Translation missing --]]
	L["Play Sound"] = "Play Sound"
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	--[[Translation missing --]]
	L["Portrait Zoom"] = "Portrait Zoom"
	--[[Translation missing --]]
	L["Position and Size Settings"] = "Position and Size Settings"
	--[[Translation missing --]]
	L["Preferred Match"] = "Preferred Match"
	--[[Translation missing --]]
	L["Premade Auras"] = "Premade Auras"
	--[[Translation missing --]]
	L["Premade Snippets"] = "Premade Snippets"
	--[[Translation missing --]]
	L["Preparing auras: "] = "Preparing auras: "
	--[[Translation missing --]]
	L["Press Ctrl+C to copy"] = "Press Ctrl+C to copy"
	--[[Translation missing --]]
	L["Press Ctrl+C to copy the URL"] = "Press Ctrl+C to copy the URL"
	--[[Translation missing --]]
	L["Prevent Merging"] = "Prevent Merging"
	--[[Translation missing --]]
	L["Progress - The remaining time of a timer, or a non-timer value"] = "Progress - The remaining time of a timer, or a non-timer value"
	--[[Translation missing --]]
	L["Progress Bar"] = "Progress Bar"
	--[[Translation missing --]]
	L["Progress Bar Settings"] = "Progress Bar Settings"
	--[[Translation missing --]]
	L["Progress Settings"] = "Progress Settings"
	--[[Translation missing --]]
	L["Progress Texture"] = "Progress Texture"
	--[[Translation missing --]]
	L["Progress Texture Settings"] = "Progress Texture Settings"
	--[[Translation missing --]]
	L["Purple Rune"] = "Purple Rune"
	--[[Translation missing --]]
	L["Put this display in a group"] = "Put this display in a group"
	--[[Translation missing --]]
	L["Range in yards"] = "Range in yards"
	--[[Translation missing --]]
	L["Ready for Install"] = "Ready for Install"
	--[[Translation missing --]]
	L["Ready for Update"] = "Ready for Update"
	--[[Translation missing --]]
	L["Re-center X"] = "Re-center X"
	--[[Translation missing --]]
	L["Re-center Y"] = "Re-center Y"
	--[[Translation missing --]]
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "Reciprocal TRIGGER:# requests will be ignored!"
	--[[Translation missing --]]
	L["Redo"] = "Redo"
	--[[Translation missing --]]
	L["Regions of type \"%s\" are not supported."] = "Regions of type \"%s\" are not supported."
	--[[Translation missing --]]
	L["Remove"] = "Remove"
	--[[Translation missing --]]
	L["Remove All Sounds"] = "Remove All Sounds"
	--[[Translation missing --]]
	L["Remove All Text To Speech"] = "Remove All Text To Speech"
	--[[Translation missing --]]
	L["Remove this display from its group"] = "Remove this display from its group"
	--[[Translation missing --]]
	L["Remove this property"] = "Remove this property"
	--[[Translation missing --]]
	L["Rename"] = "Rename"
	--[[Translation missing --]]
	L["Repeat After"] = "Repeat After"
	--[[Translation missing --]]
	L["Repeat every"] = "Repeat every"
	--[[Translation missing --]]
	L["Report bugs on our issue tracker."] = "Report bugs on our issue tracker."
	--[[Translation missing --]]
	L["Require unit from trigger"] = "Require unit from trigger"
	--[[Translation missing --]]
	L["Required for Activation"] = "Required for Activation"
	--[[Translation missing --]]
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"
	--[[Translation missing --]]
	L["Reset all options to their default values."] = "Reset all options to their default values."
	--[[Translation missing --]]
	L["Reset Entry"] = "Reset Entry"
	--[[Translation missing --]]
	L["Reset to Defaults"] = "Reset to Defaults"
	--[[Translation missing --]]
	L["Right 2 HUD position"] = "Right 2 HUD position"
	--[[Translation missing --]]
	L["Right HUD position"] = "Right HUD position"
	--[[Translation missing --]]
	L["Right-click for more options"] = "Right-click for more options"
	--[[Translation missing --]]
	L["Rotate"] = "Rotate"
	--[[Translation missing --]]
	L["Rotate In"] = "Rotate In"
	--[[Translation missing --]]
	L["Rotate Out"] = "Rotate Out"
	--[[Translation missing --]]
	L["Rotate Text"] = "Rotate Text"
	--[[Translation missing --]]
	L["Rotation Mode"] = "Rotation Mode"
	--[[Translation missing --]]
	L["Row Space"] = "Row Space"
	--[[Translation missing --]]
	L["Row Width"] = "Row Width"
	--[[Translation missing --]]
	L["Rows"] = "Rows"
	--[[Translation missing --]]
	L["Run on..."] = "Run on..."
	--[[Translation missing --]]
	L["Same"] = "Same"
	--[[Translation missing --]]
	L["Same texture as Foreground"] = "Same texture as Foreground"
	--[[Translation missing --]]
	L["Saved Data"] = "Saved Data"
	--[[Translation missing --]]
	L["Scale Factor"] = "Scale Factor"
	--[[Translation missing --]]
	L["Search API"] = "Search API"
	--[[Translation missing --]]
	L["Select Talent"] = "Select Talent"
	--[[Translation missing --]]
	L["Select the auras you always want to be listed first"] = "Select the auras you always want to be listed first"
	--[[Translation missing --]]
	L["Selected Frame"] = "Selected Frame"
	--[[Translation missing --]]
	L["Send To"] = "Send To"
	--[[Translation missing --]]
	L["Separator Text"] = "Separator Text"
	--[[Translation missing --]]
	L["Separator text"] = "Separator text"
	--[[Translation missing --]]
	L["Set Maximum Progress"] = "Set Maximum Progress"
	--[[Translation missing --]]
	L["Set Minimum Progress"] = "Set Minimum Progress"
	--[[Translation missing --]]
	L["Set Parent to Anchor"] = "Set Parent to Anchor"
	--[[Translation missing --]]
	L["Set Thumbnail Icon"] = "Set Thumbnail Icon"
	--[[Translation missing --]]
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."
	--[[Translation missing --]]
	L["Settings"] = "Settings"
	--[[Translation missing --]]
	L["Shadow Color"] = "Shadow Color"
	--[[Translation missing --]]
	L["Shadow X Offset"] = "Shadow X Offset"
	--[[Translation missing --]]
	L["Shadow Y Offset"] = "Shadow Y Offset"
	--[[Translation missing --]]
	L["Shift-click to create chat link"] = "Shift-click to create a |cFF8800FF[Chat Link]"
	--[[Translation missing --]]
	L["Show \"Edge\""] = "Show \"Edge\""
	--[[Translation missing --]]
	L["Show \"Swipe\""] = "Show \"Swipe\""
	--[[Translation missing --]]
	L["Show and Clone Settings"] = "Show and Clone Settings"
	--[[Translation missing --]]
	L["Show Border"] = "Show Border"
	--[[Translation missing --]]
	L["Show Circular Texture"] = "Show Circular Texture"
	--[[Translation missing --]]
	L["Show Debug Logs"] = "Show Debug Logs"
	--[[Translation missing --]]
	L["Show Glow"] = "Show Glow"
	--[[Translation missing --]]
	L["Show Icon"] = "Show Icon"
	--[[Translation missing --]]
	L["Show If Unit Does Not Exist"] = "Show If Unit Does Not Exist"
	--[[Translation missing --]]
	L["Show Linear Texture"] = "Show Linear Texture"
	--[[Translation missing --]]
	L["Show Matches for"] = "Show Matches for"
	--[[Translation missing --]]
	L["Show Matches for Units"] = "Show Matches for Units"
	--[[Translation missing --]]
	L["Show Model"] = "Show Model"
	--[[Translation missing --]]
	L["Show model of unit "] = "Show model of unit "
	--[[Translation missing --]]
	L["Show Sound Setting"] = "Show Sound Setting"
	--[[Translation missing --]]
	L["Show Spark"] = "Show Spark"
	--[[Translation missing --]]
	L["Show Stop Motion"] = "Show Stop Motion"
	--[[Translation missing --]]
	L["Show Text"] = "Show Text"
	--[[Translation missing --]]
	L["Show Text To Speech Setting"] = "Show Text To Speech Setting"
	--[[Translation missing --]]
	L["Show Texture"] = "Show Texture"
	--[[Translation missing --]]
	L["Show this group's children"] = "Show this group's children"
	--[[Translation missing --]]
	L["Show Tick"] = "Show Tick"
	--[[Translation missing --]]
	L["Shows a 3D model from the game files"] = "Shows a 3D model from the game files"
	--[[Translation missing --]]
	L["Shows a border"] = "Shows a border"
	--[[Translation missing --]]
	L["Shows a Circular Progress Texture"] = "Shows a Circular Progress Texture"
	--[[Translation missing --]]
	L["Shows a custom texture"] = "Shows a custom texture"
	--[[Translation missing --]]
	L["Shows a glow"] = "Shows a glow"
	--[[Translation missing --]]
	L["Shows a Linear Progress Texture"] = "Shows a Linear Progress Texture"
	--[[Translation missing --]]
	L["Shows a model"] = "Shows a model"
	--[[Translation missing --]]
	L["Shows a progress bar with name, timer, and icon"] = "Shows a progress bar with name, timer, and icon"
	--[[Translation missing --]]
	L["Shows a spell icon with an optional cooldown overlay"] = "Shows a spell icon with an optional cooldown overlay"
	--[[Translation missing --]]
	L["Shows a Stop Motion"] = "Shows a Stop Motion"
	--[[Translation missing --]]
	L["Shows a stop motion texture"] = "Shows a stop motion texture"
	--[[Translation missing --]]
	L["Shows a Texture"] = "Shows a Texture"
	--[[Translation missing --]]
	L["Shows a texture that changes based on duration"] = "Shows a texture that changes based on duration"
	--[[Translation missing --]]
	L["Shows nothing, except sub elements"] = "Shows nothing, except sub elements"
	--[[Translation missing --]]
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Shows one or more lines of text, which can include dynamic information such as progress or stacks"
	--[[Translation missing --]]
	L["Size"] = "Size"
	--[[Translation missing --]]
	L["Slant Amount"] = "Slant Amount"
	--[[Translation missing --]]
	L["Slant Mode"] = "Slant Mode"
	--[[Translation missing --]]
	L["Slanted"] = "Slanted"
	--[[Translation missing --]]
	L["Slide"] = "Slide"
	--[[Translation missing --]]
	L["Slide In"] = "Slide In"
	--[[Translation missing --]]
	L["Slide Out"] = "Slide Out"
	--[[Translation missing --]]
	L["Slider Step Size"] = "Slider Step Size"
	--[[Translation missing --]]
	L["Small Icon"] = "Small Icon"
	--[[Translation missing --]]
	L["Smooth Progress"] = "Smooth Progress"
	--[[Translation missing --]]
	L["Snippets"] = "Snippets"
	--[[Translation missing --]]
	L["Soft Max"] = "Soft Max"
	--[[Translation missing --]]
	L["Soft Min"] = "Soft Min"
	--[[Translation missing --]]
	L["Sort"] = "Sort"
	--[[Translation missing --]]
	L["Sound Channel"] = "Sound Channel"
	--[[Translation missing --]]
	L["Sound File Path"] = "Sound File Path"
	--[[Translation missing --]]
	L["Sound Kit ID"] = "Sound Kit ID"
	--[[Translation missing --]]
	L["Space Horizontally"] = "Space Horizontally"
	--[[Translation missing --]]
	L["Space Vertically"] = "Space Vertically"
	--[[Translation missing --]]
	L["Spark Settings"] = "Spark Settings"
	--[[Translation missing --]]
	L["Spark Texture"] = "Spark Texture"
	--[[Translation missing --]]
	L["Specific Currency ID"] = "Specific Currency ID"
	--[[Translation missing --]]
	L["Spell Selection Filters"] = "Spell Selection Filters"
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	--[[Translation missing --]]
	L["Stack Info"] = "Stack Info"
	--[[Translation missing --]]
	L["Stacks - The number of stacks of an aura (usually)"] = "Stacks - The number of stacks of an aura (usually)"
	--[[Translation missing --]]
	L["Standby"] = "Standby"
	--[[Translation missing --]]
	L["Star"] = "Star"
	--[[Translation missing --]]
	L["Start"] = "Start"
	--[[Translation missing --]]
	L["Start Angle"] = "Start Angle"
	--[[Translation missing --]]
	L["Start Collapsed"] = "Start Collapsed"
	--[[Translation missing --]]
	L["Start of %s"] = "Start of %s"
	--[[Translation missing --]]
	L["Step Size"] = "Step Size"
	--[[Translation missing --]]
	L["Stop Motion %s"] = "Stop Motion %s"
	--[[Translation missing --]]
	L["Stop Motion Settings"] = "Stop Motion Settings"
	--[[Translation missing --]]
	L["Stop Sound"] = "Stop Sound"
	--[[Translation missing --]]
	L["Stretched by Foreground"] = "Stretched by Foreground"
	--[[Translation missing --]]
	L["Sub Elements"] = "Sub Elements"
	--[[Translation missing --]]
	L["Sub Option %i"] = "Sub Option %i"
	--[[Translation missing --]]
	L["Subevent"] = "Subevent"
	--[[Translation missing --]]
	L["Subevent Suffix"] = "Subevent Suffix"
	--[[Translation missing --]]
	L["Swipe Overlay Settings"] = "Swipe Overlay Settings"
	--[[Translation missing --]]
	L["Templates could not be loaded, the addon is %s"] = "Templates could not be loaded, the addon is %s"
	--[[Translation missing --]]
	L["Temporary Group"] = "Temporary Group"
	--[[Translation missing --]]
	L["Text %s"] = "Text %s"
	--[[Translation missing --]]
	L["Text Color"] = "Text Color"
	--[[Translation missing --]]
	L["Text Settings"] = "Text Settings"
	--[[Translation missing --]]
	L["Texture %s"] = "Texture %s"
	--[[Translation missing --]]
	L["Texture Info"] = "Texture Info"
	--[[Translation missing --]]
	L["Texture Selection Mode"] = "Texture Selection Mode"
	--[[Translation missing --]]
	L["Texture Settings"] = "Texture Settings"
	--[[Translation missing --]]
	L["Texture Wrap"] = "Texture Wrap"
	--[[Translation missing --]]
	L["Texture X Offset"] = "Texture X Offset"
	--[[Translation missing --]]
	L["Texture Y Offset"] = "Texture Y Offset"
	--[[Translation missing --]]
	L["Thanks"] = "Thanks"
	--[[Translation missing --]]
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"
	--[[Translation missing --]]
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"
	--[[Translation missing --]]
	L["The duration of the animation in seconds."] = "The duration of the animation in seconds."
	--[[Translation missing --]]
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = "The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."
	--[[Translation missing --]]
	L["The group and all direct children will share the same base frame level."] = "The group and all direct children will share the same base frame level."
	--[[Translation missing --]]
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."
	--[[Translation missing --]]
	L["The type of trigger"] = "The type of trigger"
	--[[Translation missing --]]
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"
	--[[Translation missing --]]
	L["Then "] = "Then "
	--[[Translation missing --]]
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."
	--[[Translation missing --]]
	L["This adds %raidMark as text replacements."] = "This adds %raidMark as text replacements."
	--[[Translation missing --]]
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."
	--[[Translation missing --]]
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."
	--[[Translation missing --]]
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=]
	--[[Translation missing --]]
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=]
	--[[Translation missing --]]
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=]
	--[[Translation missing --]]
	L["This display is currently loaded"] = "This display is currently loaded"
	--[[Translation missing --]]
	L["This display is not currently loaded"] = "This display is not currently loaded"
	--[[Translation missing --]]
	L["This display is on standby, it will be loaded when needed."] = "This display is on standby, it will be loaded when needed."
	--[[Translation missing --]]
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."
	--[[Translation missing --]]
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "This is a modified version of your aura, |cff9900FF%s.|r"
	--[[Translation missing --]]
	L["This is a modified version of your group: |cff9900FF%s|r"] = "This is a modified version of your group: |cff9900FF%s|r"
	--[[Translation missing --]]
	L["This region of type \"%s\" is not supported."] = "This region of type \"%s\" is not supported."
	--[[Translation missing --]]
	L["This setting controls what widget is generated in user mode."] = "This setting controls what widget is generated in user mode."
	--[[Translation missing --]]
	L["Thumbnail Icon"] = "Thumbnail Icon"
	--[[Translation missing --]]
	L["Tick %s"] = "Tick %s"
	--[[Translation missing --]]
	L["Tick Area %s"] = "Tick Area %s"
	--[[Translation missing --]]
	L["Tick Center %s"] = "Tick Center %s"
	--[[Translation missing --]]
	L["Tick Mode"] = "Tick Mode"
	--[[Translation missing --]]
	L["Tick Placement"] = "Tick Placement"
	--[[Translation missing --]]
	L["Time in"] = "Time in"
	--[[Translation missing --]]
	L["Tiny Icon"] = "Tiny Icon"
	--[[Translation missing --]]
	L["To Frame's"] = "To Frame's"
	--[[Translation missing --]]
	L["To Group's"] = "To Group's"
	--[[Translation missing --]]
	L["To Personal Ressource Display's"] = "To Personal Ressource Display's"
	--[[Translation missing --]]
	L["To Region's"] = "To Region's"
	--[[Translation missing --]]
	L["To Screen's"] = "To Screen's"
	--[[Translation missing --]]
	L["Toggle the visibility of all loaded displays"] = "Toggle the visibility of all loaded displays"
	--[[Translation missing --]]
	L["Toggle the visibility of all non-loaded displays"] = "Toggle the visibility of all non-loaded displays"
	--[[Translation missing --]]
	L["Toggle the visibility of this display"] = "Toggle the visibility of this display"
	--[[Translation missing --]]
	L["Tooltip Content"] = "Tooltip Content"
	--[[Translation missing --]]
	L["Tooltip on Mouseover"] = "Tooltip on Mouseover"
	--[[Translation missing --]]
	L["Tooltip Pattern Match"] = "Tooltip Pattern Match"
	--[[Translation missing --]]
	L["Tooltip Text"] = "Tooltip Text"
	--[[Translation missing --]]
	L["Tooltip Value"] = "Tooltip Value"
	--[[Translation missing --]]
	L["Tooltip Value #"] = "Tooltip Value #"
	--[[Translation missing --]]
	L["Top HUD position"] = "Top HUD position"
	--[[Translation missing --]]
	L["Total"] = "Total"
	--[[Translation missing --]]
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = "Total - The maximum duration of a timer, or a maximum non-timer value"
	--[[Translation missing --]]
	L["Total Angle"] = "Total Angle"
	--[[Translation missing --]]
	L["Total Time"] = "Total Time"
	--[[Translation missing --]]
	L["Trigger %i: %s"] = "Trigger %i: %s"
	--[[Translation missing --]]
	L["Trigger Combination"] = "Trigger Combination"
	--[[Translation missing --]]
	L["Type 'select' for '%s' requires a values member'"] = "Type 'select' for '%s' requires a values member'"
	--[[Translation missing --]]
	L["Undo"] = "Undo"
	--[[Translation missing --]]
	L["Ungroup"] = "Ungroup"
	--[[Translation missing --]]
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "Unit %s is not a valid unit for RegisterUnitEvent"
	--[[Translation missing --]]
	L["Unit Count"] = "Unit Count"
	--[[Translation missing --]]
	L["Unknown"] = "Unknown"
	--[[Translation missing --]]
	L["Unknown Encounter's Spell Id"] = "Unknown Encounter's Spell Id"
	--[[Translation missing --]]
	L["Unknown property '%s' found in '%s'"] = "Unknown property '%s' found in '%s'"
	--[[Translation missing --]]
	L["Unknown Spell"] = "Unknown Spell"
	--[[Translation missing --]]
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."
	--[[Translation missing --]]
	L["Update"] = "Update"
	--[[Translation missing --]]
	L["Update Auras"] = "Update Auras"
	--[[Translation missing --]]
	L["Update Custom Text On..."] = "Update Custom Text On..."
	--[[Translation missing --]]
	L["URL"] = "URL"
	--[[Translation missing --]]
	L["Url: %s"] = "Url: %s"
	--[[Translation missing --]]
	L["Use Display Info Id"] = "Use Display Info Id"
	--[[Translation missing --]]
	L["Use SetTransform"] = "Use SetTransform"
	--[[Translation missing --]]
	L["Used in Auras:"] = "Used in Auras:"
	--[[Translation missing --]]
	L["Used in auras:"] = "Used in auras:"
	--[[Translation missing --]]
	L["Uses Texture Coordinates to rotate the texture."] = "Uses Texture Coordinates to rotate the texture."
	--[[Translation missing --]]
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."
	--[[Translation missing --]]
	L["Value"] = "Value"
	--[[Translation missing --]]
	L["Value %i"] = "Value %i"
	--[[Translation missing --]]
	L["Values are in normalized rgba format."] = "Values are in normalized rgba format."
	--[[Translation missing --]]
	L["Values/Remaining Time above this value are displayed as full progress."] = "Values/Remaining Time above this value are displayed as full progress."
	--[[Translation missing --]]
	L["Values/Remaining Time below this value are displayed as zero progress."] = "Values/Remaining Time below this value are displayed as zero progress."
	--[[Translation missing --]]
	L["Values:"] = "Values:"
	--[[Translation missing --]]
	L["Version: "] = "Version: "
	--[[Translation missing --]]
	L["Version: %s"] = "Version: %s"
	--[[Translation missing --]]
	L["Vertical Align"] = "Vertical Align"
	--[[Translation missing --]]
	L["Vertical Bar"] = "Vertical Bar"
	--[[Translation missing --]]
	L["View"] = "View"
	--[[Translation missing --]]
	L["View custom code"] = "View custom code"
	--[[Translation missing --]]
	L["Voice Settings"] = "Voice Settings"
	--[[Translation missing --]]
	L["We thank"] = "We thank"
	--[[Translation missing --]]
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s on WoW %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	--[[Translation missing --]]
	L["What do you want to do?"] = "What do you want to do?"
	--[[Translation missing --]]
	L["Whole Area"] = "Whole Area"
	--[[Translation missing --]]
	L["wrapping"] = "wrapping"
	--[[Translation missing --]]
	L["X Offset"] = "X Offset"
	--[[Translation missing --]]
	L["X Rotation"] = "X Rotation"
	--[[Translation missing --]]
	L["X Scale"] = "X Scale"
	--[[Translation missing --]]
	L["x-Offset"] = "x-Offset"
	--[[Translation missing --]]
	L["Y Offset"] = "Y Offset"
	--[[Translation missing --]]
	L["Y Rotation"] = "Y Rotation"
	--[[Translation missing --]]
	L["Y Scale"] = "Y Scale"
	--[[Translation missing --]]
	L["Yellow Rune"] = "Yellow Rune"
	--[[Translation missing --]]
	L["y-Offset"] = "y-Offset"
	--[[Translation missing --]]
	L["You already have this group/aura. Importing will create a duplicate."] = "You already have this group/aura. Importing will create a duplicate."
	--[[Translation missing --]]
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"
	--[[Translation missing --]]
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."
	--[[Translation missing --]]
	L["Your Saved Snippets"] = "Your Saved Snippets"
	--[[Translation missing --]]
	L["Z Offset"] = "Z Offset"
	--[[Translation missing --]]
	L["Z Rotation"] = "Z Rotation"
	--[[Translation missing --]]
	L["Zoom In"] = "Zoom In"
	--[[Translation missing --]]
	L["Zoom Out"] = "Zoom Out"


=== END OF FILE: WeakAurasOptions/Locales/itIT.lua ===


=== FILE: WeakAurasOptions/Locales/koKR.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "koKR" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = " |cFFFF0000 |r"
	L["-- Do not remove this comment, it is part of this aura: "] = "--    ,   :"
	L[" rotated |cFFFF0000%s|r degrees"] = "|cFFFF0000%s|r "
	L["% - To show a percent sign"] = "% -   "
	L["% of Progress"] = " %"
	L["%d |4aura:auras; added"] = "%d  "
	L["%d |4aura:auras; deleted"] = "%d  "
	L["%d |4aura:auras; modified"] = "%d  "
	L["%d |4aura:auras; with meta data modified"] = "%d     "
	L["%d displays loaded"] = " %d "
	L["%d displays not loaded"] = " %d  "
	L["%d displays on standby"] = " %d  "
	L["%i auras selected"] = "%i  "
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i.  "
	L["%s - Alpha Animation"] = "%s -  "
	L["%s - Color Animation"] = "%s -  "
	L["%s - Condition Custom Chat %s"] = "%s -     %s"
	L["%s - Condition Custom Check %s"] = "%s -     %s"
	L["%s - Condition Custom Code %s"] = "%s -     %s"
	L["%s - Custom Anchor"] = "%s -   "
	L["%s - Custom Grow"] = "%s -    "
	L["%s - Custom Sort"] = "%s -   "
	L["%s - Custom Text"] = "%s -   "
	L["%s - Finish"] = "%s - "
	L["%s - Finish Action"] = "%s -  "
	L["%s - Finish Custom Text"] = "%s -    "
	L["%s - Init Action"] = "%s -  "
	L["%s - Main"] = "%s - "
	L["%s - OnLoad"] = "%s -  "
	L["%s - OnUnload"] = "%s -  "
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - #%i  %s  .    ."
	L["%s - Rotate Animation"] = "%s -  "
	L["%s - Scale Animation"] = "%s -  "
	L["%s - Start"] = "%s - "
	L["%s - Start Action"] = "%s -  "
	L["%s - Start Custom Text"] = "%s -    "
	L["%s - Translate Animation"] = "%s -  "
	L["%s - Trigger Logic"] = "%s -   "
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, : %d, : %0.2f, : %d, : %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s,  : %d, : %0.2f, : %0.2f"
	L["%s %u. Overlay Function"] = "%s %u.  "
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s : %d%%"
	L["%s Color"] = "%s "
	L["%s Custom Variables"] = "%s   "
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s  , ,  , "
	L["%s Duration Function"] = "%s  "
	L["%s Icon Function"] = "%s  "
	L["%s Inset: %d%%"] = "%s : %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s|1;; COMBAT_LOG_EVENT_UNFILTERED   ."
	L["%s Keep Aspect Ratio"] = "%s  "
	L["%s Name Function"] = "%s  "
	L["%s Stacks Function"] = "%s   "
	L["%s stores around %s KB of data"] = "%s|1;;  %s KB  "
	L["%s Texture"] = "%s "
	L["%s Texture Function"] = "%s  "
	L["%s total auras"] = " %s "
	L["%s Trigger Function"] = "%s   "
	L["%s Untrigger Function"] = "%s   "
	L["%s X offset by %d"] = "%s %d X  "
	L["%s Y offset by %d"] = "%s %d Y  "
	L["%s Zoom: %d%%"] = "%s : %d%%"
	L["%s, Border"] = "%s, "
	L["%s, Offset: %0.2f;%0.2f"] = "%s,  : %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s,  : %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s,  "
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000 |r  |cFFFF0000%s|r  %s%s"
	L["(Right click to rename)"] = "(  )"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02x  |r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999               ,        .|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000:|r '%s'  "
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000:|r    URL "
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000:|r       URL ."
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000|r  "
	L["|cFFFF0000default|r texture"] = "|cFFFF0000|r "
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000|r"
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000:|r '%s'    ."
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000:|r '%s'     cvar   ."
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00:|r |cFFFF0000%s|r|1;;  |cFFFF0000%s|r "
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00:|r |cFFFF0000%s|r|1;;  |cFFFF0000%s|r |cFFFF0000%s/%s|r    "
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00:|r  |cFFFF0000%s|r "
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00:|r  |cFFFF0000%s|r |cFFFF0000%s/%s|r    "
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00 :|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00:|r %s  %s %s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00 :|r |cFFFF0000%s|r   |c%s|r,   |cFFFF0000%s/%s|r%s%s "
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00 :|r |cFFFF0000%s|r   |c%s|r,   |cFFFF0000%s/%s|r%s%s%s "
	L["|cffffcc00Format Options|r"] = "|cffffcc00 |r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = [=[ |cff00ff00|r, |cff00ff00|r, |cff00ff00 |r  |cff00ff00|r  ID  .

 |cff00ff00  |r  ID    .

|cffff0000|r:   ID      ID     .

 |cffffff00|r, |cffffff00|r, |cffffff00|r, |cffffff00|r  |cffffff00|r  ID   .

 |cffffff00 |r        "player",   "party"  ("player" ),   "raid"  .

 |cffffff00 |r      ID       .

|cffff0000|r:  ID         .


|cffffff00*|r                   ,        .]=]
	L["A 20x20 pixels icon"] = "20x20  "
	L["A 32x32 pixels icon"] = "32x32  "
	L["A 40x40 pixels icon"] = "40x40  "
	L["A 48x48 pixels icon"] = "48x48  "
	L["A 64x64 pixels icon"] = "64x64  "
	L["A group that dynamically controls the positioning of its children"] = "     "
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = "   (    )   .    WeakAuras       ."
	L["A Unit ID (e.g., party1)."] = " ID. (party1 )"
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = "    "
	L["Actual Spec"] = " "
	L["Add %s"] = "%s "
	L["Add a new display"] = "  "
	L["Add Condition"] = " "
	L["Add Entry"] = " "
	L["Add Extra Elements"] = "  "
	L["Add Option"] = " "
	L["Add Overlay"] = " "
	L["Add Property Change"] = "  "
	L["Add Snippet"] = " "
	L["Add Sub Option"] = "  "
	L["Add to group %s"] = "%s  "
	L["Add to new Dynamic Group"] = "   "
	L["Add to new Group"] = "  "
	L["Add Trigger"] = "  "
	L["Additional Events"] = " "
	L["Advanced"] = " "
	L["Affected Unit Filters and Info"] = "     "
	L["Align"] = ""
	L["Alignment"] = ""
	L["All maintainers of the libraries we use, especially:"] = "       :"
	L["All of"] = " "
	L["Allow Full Rotation"] = "  "
	L["Anchor"] = " "
	L["Anchor Mode"] = " "
	L["Anchor Point"] = " "
	L["Anchored To"] = " :"
	L["And "] = "And"
	L["and"] = ""
	L["and %s"] = "and %s"
	L["and aligned left"] = ",  "
	L["and aligned right"] = ",  "
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "  Patreon, Discord      :"
	L["and rotated left"] = ",  "
	L["and rotated right"] = ",  "
	L["and with width |cFFFF0000%s|r and %s"] = ",  |cFFFF0000%s|r, %s"
	L["Angle"] = ""
	L["Angle Between Auras"] = "  "
	L["Animate"] = ""
	L["Animated Expand and Collapse"] = " /  "
	L["Animates progress changes"] = "    "
	L["Animation End"] = "  "
	L["Animation Mode"] = " "
	L["Animation relative duration description"] = [=[
     ,  (1/2),  (50%),   (0.5) .
|cFFFF0000:|r     (-   ,   , ),   .

|cFF4444FF:|r
  |cFF00CC0010%|r ,    20    ,   2  .
  |cFF00CC0010%|r ,        ,     (  )."
]=]
	L["Animation Sequence"] = " "
	L["Animation Start"] = "  "
	L["Any of"] = " "
	L["Apply Template"] = " "
	L["Arcane Orb"] = " "
	L["Area"] = ""
	L["At a position a bit left of Left HUD position."] = " HUD    ."
	L["At a position a bit left of Right HUD position"] = " HUD    "
	L["At the same position as Blizzard's spell alert"] = "    "
	L["Attach to Foreground"] = " "
	L[ [=[Aura is
Off Screen]=] ] = "   "
	L["Aura Name Pattern"] = "  "
	L["Aura Order"] = " "
	L["Aura received from: %s"] = " : %s"
	L["Aura: '%s'"] = ": '%s'"
	L["Auto-Clone (Show All Matches)"] = "  (  )"
	L["Automatic length"] = "  "
	L["Backdrop Color"] = " "
	L["Backdrop in Front"] = " "
	L["Backdrop Style"] = " "
	L["Background Inner"] = " "
	L["Background Offset"] = "  "
	L["Background Texture"] = " "
	L["Bar Alpha"] = " "
	L["Bar Color Settings"] = "  "
	L["Big Icon"] = " "
	L["Blend Mode"] = " "
	L["Blue Rune"] = " "
	L["Blue Sparkle Orb"] = "  "
	L["Border %s"] = " %s"
	L["Border Anchor"] = " "
	L["Border Color"] = ""
	L["Border in Front"] = " "
	L["Border Inset"] = " "
	L["Border Offset"] = "  "
	L["Border Settings"] = " "
	L["Border Size"] = " "
	L["Border Style"] = " "
	L["Bracket Matching"] = " "
	L["Browse Wago, the largest collection of auras."] = "      Wago ."
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "        .      %2.p     ."
	L["Can be a UID (e.g., party1)."] = "UID . (: party1)"
	L["Can set to 0 if Columns * Width equal File Width"] = " *     0  "
	L["Can set to 0 if Rows * Height equal File Height"] = " *     0  "
	L["Case Insensitive"] = "  "
	L["Cast by a Player Character"] = "  "
	L["Categories to Update"] = " "
	L["Changelog"] = " "
	L["Chat with WeakAuras experts on our Discord server."] = " Discord  WeakAuras    ."
	L["Check On..."] = "  ..."
	L["Check out our wiki for a large collection of examples and snippets."] = "    ."
	L["Children:"] = " :"
	L["Choose"] = ""
	L["Circular Texture %s"] = "  %s"
	L["Clear Debug Logs"] = "  "
	L["Clear Saved Data"] = "  "
	L["Click to replace the name with %s."] = "  %s|1;; ."
	L["Clip Overlays"] = " "
	L["Clipped by Foreground"] = "  "
	L["Close"] = ""
	L["Code Editor"] = " "
	L["Collapse"] = ""
	L["Collapse all loaded displays"] = "    "
	L["Collapse all non-loaded displays"] = "    "
	L["Collapse all pending Import"] = "    "
	L["Collapsible Group"] = "   "
	L["color"] = ""
	L["Column Height"] = " "
	L["Column Space"] = " "
	L["Columns"] = ""
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "  COMBAT_LOG_EVENT_UNFILTERED        ."
	L["Combinations"] = ""
	L["Combine Matches Per Unit"] = "   "
	L["Common Text"] = "  "
	L["Compare against the number of units affected."] = "    ."
	L["Compatibility Options"] = " "
	L["Compress"] = ""
	L["Configure what options appear on this panel."] = "    ."
	L["Constant Factor"] = " "
	L["Control-click to select multiple displays"] = "Ctrl+   "
	L["Controls the positioning and configuration of multiple displays at the same time"] = "     "
	L["Convert to..."] = "..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "WoW   .     ."
	L["Copy"] = ""
	L["Copy settings..."] = " ..."
	L["Copy to all auras"] = "  "
	L["Could not parse '%s'. Expected a table."] = "'%s'   .  ."
	L["Counts the number of matches over all units."] = "    ."
	L["Counts the number of matches per unit."] = "   ."
	L["Create a Copy"] = " "
	L["Creating buttons: "] = "  :"
	L["Creating options: "] = " :"
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "  -      Lua    . %c1   , %c2     ."
	L["Custom Code"] = "  "
	L["Custom Code Viewer"] = "   "
	L["Custom Frames"] = "  "
	L["Custom Functions"] = "  "
	L["Custom Init"] = "   "
	L["Custom Load"] = "  "
	L["Custom Options"] = "  "
	L["Custom Text Update Throttle"] = "    "
	L["Custom Trigger"] = "   "
	L["Custom trigger event tooltip"] = [=[       .       .

 "UNIT"      ID   .
"nameplate", "group", "raid", "party", "arena", "boss"    ID   .
 "CLEU" COMBAT_LOG_EVENT UNFILTERED       ""     .
 "TRIGGER"                  .

|cFF4444FF:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1]=]
	L["Custom trigger status tooltip"] = [=[       .       .

 "UNIT"      ID   .
"nameplate", "group", "raid", "party", "arena", "boss"    ID   .
 "CLEU" COMBAT_LOG_EVENT UNFILTERED       ""     .
 "TRIGGER"                  .

   (Status)      WeakAuras    .

|cFF4444FF:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1]=]
	L["Custom trigger Update Throttle"] = "     "
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "   : OPTIONS  Lua  "
	L["Custom Trigger: Send fake events instead of STATUS event"] = "   : STATUS     "
	L["Custom Unload"] = "  "
	L["Custom Untrigger"] = "   "
	L["Debug Log"] = " "
	L["Debug Log:"] = " :"
	L["Default"] = ""
	L["Default Color"] = " "
	L["Delay"] = " "
	L["Delete"] = ""
	L["Delete all"] = " "
	L["Delete children and group"] = "   "
	L["Delete Entry"] = " "
	L["Deleting auras: "] = "  : "
	L["Description Text"] = " "
	L["Determines how many entries can be in the table."] = "       ."
	L["Differences"] = ""
	L["Disallow Entry Reordering"] = "  "
	L["Discord"] = "Discord"
	L["Display Name"] = " "
	L["Display Text"] = " "
	L["Displays a text, works best in combination with other displays"] = " .       ."
	L["Distribute Horizontally"] = "  "
	L["Distribute Vertically"] = "  "
	L["Do not group this display"] = "    "
	L["Do you want to enable updates for this aura"] = "    ?"
	L["Do you want to ignore updates for this aura"] = "     "
	L["Documentation"] = " "
	L["Done"] = ""
	L["Drag to move"] = " "
	L["Duplicate"] = ""
	L["Duplicate All"] = " "
	L["Duration (s)"] = " ()"
	L["Duration Info"] = " "
	L["Dynamic Duration"] = " "
	L["Dynamic Group"] = " "
	L["Dynamic Group Settings"] = "  "
	L["Dynamic Information"] = " "
	L["Dynamic information from first active trigger"] = "     "
	L["Dynamic information from Trigger %i"] = "  %i  "
	L["Dynamic Text Replacements"] = "   "
	L["Ease Strength"] = " "
	L["Ease type"] = " "
	L["eliding"] = ""
	L["Else If"] = "Else If"
	L["Else If %s"] = "Else If %s"
	L["Empty Base Region"] = "   (Region)"
	L["Enable \"Edge\" part of the overlay"] = " \"\"  "
	L["Enable \"swipe\" part of the overlay"] = " \" \"  "
	L["Enable Debug Log"] = "  "
	L["Enable Debug Logging"] = "  "
	L["Enable Gradient"] = " "
	L["Enable Swipe"] = "  "
	L["Enable the \"Swipe\" radial overlay"] = "\" \"   "
	L["Enabled"] = ""
	L["End Angle"] = " "
	L["End of %s"] = "%s "
	L["Enemy nameplate(s) found"] = "  "
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = " ID .  ID  idTip    ."
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = " ,      ID .  ID     ."
	L["Enter Author Mode"] = "  "
	L["Enter in a value for the tick's placement."] = "   ."
	L["Enter static or relative values with %"] = "       "
	L["Enter User Mode"] = "  "
	L["Enter user mode."] = "  ."
	L["Entry %i"] = " %i"
	L["Entry limit"] = "  "
	L["Entry Name Source"] = "  "
	L["Event Type"] = " "
	L["Everything"] = ""
	L["Exact Item Match"] = "  "
	L["Exact Spell Match"] = "  "
	L["Expand"] = ""
	L["Expand all loaded displays"] = "    "
	L["Expand all non-loaded displays"] = "     "
	L["Expand all pending Import"] = "     "
	L["Expansion is disabled because this group has no children"] = "        "
	L["Export debug table..."] = "  ..."
	L["Export..."] = "..."
	L["Exporting"] = ""
	L["External"] = " "
	L["Extra Height"] = " "
	L["Extra Width"] = " "
	L["Fade"] = ""
	L["Fadeout Sound"] = "  "
	L["Fadeout Time (seconds)"] = "  ()"
	L["Fetch Affected/Unaffected Names and Units"] = " /     "
	L["Fetch Raid Mark Information"] = "   "
	L["Fetch Role Information"] = "  "
	L["Fetch Tooltip Information"] = "  "
	L["File Height"] = " "
	L["File Width"] = " "
	L["Filter based on the spell Name string."] = "   ."
	L["Filter by Arena Spec"] = "  "
	L["Filter by Class"] = " "
	L["Filter by Group Role"] = "  "
	L["Filter by Hostility"] = "/ "
	L["Filter by Npc ID"] = "NPC ID "
	L["Filter by Raid Role"] = "  "
	L["Filter by Specialization"] = " "
	L["Filter by Unit Name"] = "  "
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[ : '', '-', '-'.   ,    .
-  \      .]=]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = [=[     / 
 LibDispel  ]=]
	L["Find Auras"] = " "
	L["Finish"] = ""
	L["Finishing..."] = "..."
	L["Fire Orb"] = " "
	L["Flat Framelevels"] = " "
	L["Foreground Texture"] = " "
	L["Format for %s"] = "%s "
	L["Found a Bug?"] = " ?"
	L["Frame"] = ""
	L["Frame Count"] = " "
	L["Frame Height"] = " "
	L["Frame Rate"] = " "
	L["Frame Strata"] = " "
	L["Frame Width"] = " "
	L["Full Bar"] = " "
	L["Full Circle"] = "  "
	L["Global Conditions"] = " "
	L["Glow %s"] = " %s"
	L["Glow Action"] = " "
	L["Glow Anchor"] = " "
	L["Glow Color"] = "  "
	L["Glow Frame Type"] = "  "
	L["Glow Type"] = "  "
	L["Green Rune"] = " "
	L["Grid direction"] = " "
	L["Group (verb)"] = " "
	L["Group Alpha"] = " "
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[      .

- :    .
- :      .
-   :   (region)   .]=]
	L["Group aura count description"] = [=[     1    '%s'   .
  5          .
  0.5  1/2   50%%   %s     .

|cFF4444FF:|r
|cFF00CC00> 0|r '%s'      
|cFF00CC00= 100%%|r '%s'      
|cFF00CC00!= 2|r '%s'   2     
|cFF00CC00<= 0.8|r '%s'   80%%     ( 5  4,  10  8  25  20)
|cFF00CC00> 1/2|r '%s'      ]=]
	L["Group by Frame"] = "  "
	L["Group Description"] = " "
	L["Group Icon"] = " "
	L["Group key"] = " "
	L["Group Options"] = " "
	L["Group player(s) found"] = " () "
	L["Group Role"] = " "
	L["Group Scale"] = " "
	L["Group Settings"] = " "
	L["Hawk"] = ""
	L["Help"] = ""
	L["Hide After"] = " "
	L["Hide Background"] = " "
	L["Hide Glows applied by this aura"] = "      "
	L["Hide on"] = ""
	L["Hide this group's children"] = "    "
	L["Highlights"] = ""
	L["Horizontal Align"] = " "
	L["Horizontal Bar"] = "  "
	L["Huge Icon"] = "  "
	L["Hybrid Position"] = " "
	L["Hybrid Sort Mode"] = "  "
	L["Icon - The icon associated with the display"] = " -    "
	L["Icon Info"] = " "
	L["Icon Inset"] = " "
	L["Icon Picker"] = " "
	L["Icon Position"] = " "
	L["Icon Settings"] = " "
	L["Icon Source"] = " "
	L["If"] = "If"
	L["If %s"] = "If %s"
	L["If checked, then the combo box in the User settings will be sorted."] = "     ."
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "     .     ."
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "         ."
	L["If checked, then this option group can be temporarily collapsed by the user."] = "           ."
	L["If checked, then this option group will start collapsed."] = "      ."
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "    .      ."
	L["If checked, then this space will span across multiple lines."] = "       ."
	L["If unchecked, then a default color will be used (usually yellow)"] = "     ( )"
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "         ."
	L["Ignore out of casting range"] = "   "
	L["Ignore out of checking range"] = "   "
	L["Ignore Wago updates"] = "Wago  "
	L["Ignored"] = ""
	L["Ignored Aura Name"] = "  "
	L["Ignored Exact Spell ID(s)"] = "  ID  ( )"
	L["Ignored Name(s)"] = "  ( )"
	L["Ignored Spell ID"] = "  ID"
	L["Import"] = ""
	L["Import / Export"] = " / "
	L["Import a display from an encoded string"] = "   "
	L["Import as Copy"] = " "
	L["Import has no UID, cannot be matched to existing auras."] = " UID      ."
	L["Importing"] = ""
	L["Importing %s"] = "%s "
	L["Importing a group with %s child auras."] = "%s      ."
	L["Importing a stand-alone aura."] = "   ."
	L["Importing...."] = " ...."
	L["Incompatible changes to group region types detected"] = "  (region)     "
	L["Incompatible changes to group structure detected"] = "     "
	L["Indent Size"] = " "
	L["Inner"] = ""
	L["Insert text replacement codes to make text dynamic."] = "      ."
	L["Invalid Item ID"] = "  ID"
	L["Invalid Item Name/ID/Link"] = "  /ID/"
	L["Invalid Spell ID"] = "  ID"
	L["Invalid Spell Name/ID/Link"] = "  /ID/"
	L["Invalid target aura"] = "   "
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "'%s'   . 'bool', 'number', 'select', 'string', 'timer'  'elapsedTimer' ."
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "'%2$s' '%1$s'   . '%3$s'|1;; "
	L["Inverse Slant"] = " "
	L["Invert the direction of progress"] = "  "
	L["Is Boss Debuff"] = " "
	L["Is Stealable"] = " "
	L["Is Unit"] = ""
	L["Justify"] = ""
	L["Keep Aspect Ratio"] = " "
	L["Keep your Wago imports up to date with the Companion App."] = "Companion  Wago    ."
	L["Large Input"] = " "
	L["Leaf"] = ""
	L["Left 2 HUD position"] = " 2 HUD "
	L["Left HUD position"] = " HUD "
	L["Length of |cFFFF0000%s|r"] = "|cFFFF0000%s|r "
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = ""
	L["Line"] = ""
	L["Linear Texture %s"] = "  %s"
	L["Linked aura: "] = " : "
	L["Linked Auras"] = " "
	L["Load"] = ""
	L["Loaded"] = ""
	L["Loaded/Standby"] = "/ "
	L["Lock Positions"] = " "
	L["Low Mana"] = " "
	L["Magnetically Align"] = " "
	L["Main"] = ""
	L["Manual with %i/%i"] = " %i/%i"
	L["Matches %s spells"] = "%s  "
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "        ."
	L["Max"] = ""
	L["Max Length"] = " "
	L["Maximum"] = ""
	L["Media Type"] = " "
	L["Medium Icon"] = " "
	L["Min"] = ""
	L["Minimum"] = ""
	L["Model %s"] = " %s"
	L["Model Picker"] = " "
	L["Model Settings"] = " "
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths   .  %s."
	L["Move Above Group"] = "  "
	L["Move Below Group"] = "  "
	L["Move Down"] = " "
	L["Move Entry Down"] = "  "
	L["Move Entry Up"] = "  "
	L["Move Into Above Group"] = "  "
	L["Move Into Below Group"] = "  "
	L["Move this display down in its group's order"] = "      "
	L["Move this display up in its group's order"] = "      "
	L["Move Up"] = " "
	L["Moving auras: "] = " : "
	L["Multiple Displays"] = " "
	L["Multiselect ignored tooltip"] = [=[
|cFFFF0000|r - |cFF777777|r - |cFF777777|r
       ]=]
	L["Multiselect multiple tooltip"] = [=[
|cFF777777|r - |cFF777777|r - |cFF00FF00|r
     ]=]
	L["Multiselect single tooltip"] = [=[
|cFF777777|r - |cFF00FF00|r - |cFF777777|r
     ]=]
	L["Must be a power of 2"] = "2  "
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = " -    (  )    ID "
	L["Name Info"] = " "
	L["Name Pattern Match"] = "  "
	L["Name:"] = ":"
	L["Negator"] = "Not"
	L["New Aura"] = " "
	L["New Template"] = " "
	L["New Value"] = " "
	L["No Children"] = "  "
	L["No Logs saved."] = "  ."
	L["Not a table"] = " "
	L["Not all children have the same value for this option"] = "        "
	L["Not Loaded"] = " "
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = ":         ."
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = ":     /   .  /  \"  \"     "
	L["Number of Entries"] = " "
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[       
    
       

:
2 5 6 : 2, 5, 6
2 6: 2-6
2 : /2
2  3 : 2/3
2 11   3 : 2-11/3]=]
	L["OFF"] = ""
	L["Offer a guided way to create auras for your character"] = "         "
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "|cFFFF0000%s|r/|cFFFF0000%s|r  "
	L["Offset by 1px"] = "1px "
	L["Okay"] = ""
	L["ON"] = ""
	L["On Hide"] = " "
	L["On Show"] = " "
	L["Only Match auras cast by a player (not an npc)"] = "(NPC )    "
	L["Only match auras cast by people other than the player or their pet"] = "         "
	L["Only match auras cast by the player or their pet"] = "      "
	L["Operator"] = ""
	L["Option %i"] = " %i"
	L["Option key"] = " "
	L["Option Type"] = " "
	L["Options will open after combat ends."] = "     ."
	L["or"] = ""
	L["or %s"] = "or %s"
	L["Orange Rune"] = " "
	L["Our translators (too many to name)"] = "  (    )"
	L["Outer"] = ""
	L["Overflow"] = "  "
	L["Overlay %s Info"] = "%s  "
	L["Overlays"] = ""
	L["Own Only"] = " "
	L["Paste Action Settings"] = "  "
	L["Paste Animations Settings"] = "  "
	L["Paste Author Options Settings"] = "   "
	L["Paste Condition Settings"] = "  "
	L["Paste Custom Configuration"] = "   "
	L["Paste Display Settings"] = "  "
	L["Paste Group Settings"] = "  "
	L["Paste Load Settings"] = "  "
	L["Paste Settings"] = " "
	L["Paste text below"] = "   "
	L["Paste Trigger Settings"] = "   "
	L["Places a tick on the bar"] = "  "
	L["Play Sound"] = " "
	L["Player Spells found:"] = "  :"
	L["Portrait Zoom"] = " "
	L["Position and Size Settings"] = "   "
	L["Preferred Match"] = "  "
	L["Premade Auras"] = "  "
	L["Premade Snippets"] = "  "
	L["Preparing auras: "] = " :"
	L["Press Ctrl+C to copy"] = " Ctrl+C "
	L["Press Ctrl+C to copy the URL"] = "URL  Ctrl+C "
	L["Prevent Merging"] = " "
	L["Progress - The remaining time of a timer, or a non-timer value"] = " -        "
	L["Progress Bar"] = " "
	L["Progress Bar Settings"] = "  "
	L["Progress Settings"] = " "
	L["Progress Texture"] = " "
	L["Progress Texture Settings"] = "  "
	L["Purple Rune"] = " "
	L["Put this display in a group"] = "   "
	L["Range in yards"] = "  "
	L["Ready for Install"] = " "
	L["Ready for Update"] = " "
	L["Re-center X"] = " X "
	L["Re-center Y"] = " Y "
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "    #  !"
	L["Redo"] = " "
	L["Regions of type \"%s\" are not supported."] = "\"%s\"   (Region)  ."
	L["Remove"] = ""
	L["Remove All Sounds"] = "   "
	L["Remove All Text To Speech"] = "    "
	L["Remove this display from its group"] = "   "
	L["Remove this property"] = "  "
	L["Rename"] = " "
	L["Repeat After"] = " "
	L["Repeat every"] = " "
	L["Report bugs on our issue tracker."] = "    ."
	L["Require unit from trigger"] = "   "
	L["Required for Activation"] = "  "
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "LibSpecialization , WeakAuras    ."
	L["Reset all options to their default values."] = "   ."
	L["Reset Entry"] = " "
	L["Reset to Defaults"] = " "
	L["Right 2 HUD position"] = " 2 HUD "
	L["Right HUD position"] = " HUD "
	L["Right-click for more options"] = "   "
	L["Rotate"] = ""
	L["Rotate In"] = " "
	L["Rotate Out"] = " "
	L["Rotate Text"] = " "
	L["Rotation Mode"] = " "
	L["Row Space"] = " "
	L["Row Width"] = " "
	L["Rows"] = ""
	L["Run on..."] = " ..."
	L["Same"] = " "
	L["Same texture as Foreground"] = "  "
	L["Saved Data"] = " "
	L["Scale Factor"] = " "
	L["Search API"] = "API "
	L["Select Talent"] = " "
	L["Select the auras you always want to be listed first"] = "    "
	L["Selected Frame"] = " "
	L["Send To"] = "..."
	L["Separator Text"] = " "
	L["Separator text"] = " "
	L["Set Maximum Progress"] = "  "
	L["Set Minimum Progress"] = "  "
	L["Set Parent to Anchor"] = "  "
	L["Set Thumbnail Icon"] = "  "
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "           ."
	L["Settings"] = ""
	L["Shadow Color"] = ""
	L["Shadow X Offset"] = " X  "
	L["Shadow Y Offset"] = " Y  "
	L["Shift-click to create chat link"] = "Shift+   "
	L["Show \"Edge\""] = "\"\" "
	L["Show \"Swipe\""] = "\" \"  "
	L["Show and Clone Settings"] = "   "
	L["Show Border"] = " "
	L["Show Circular Texture"] = "  "
	L["Show Debug Logs"] = "  "
	L["Show Glow"] = " "
	L["Show Icon"] = " "
	L["Show If Unit Does Not Exist"] = "  "
	L["Show Linear Texture"] = "  "
	L["Show Matches for"] = " "
	L["Show Matches for Units"] = "   "
	L["Show Model"] = " "
	L["Show model of unit "] = "  "
	L["Show Sound Setting"] = "  "
	L["Show Spark"] = " "
	L["Show Stop Motion"] = "  "
	L["Show Text"] = " "
	L["Show Text To Speech Setting"] = "    "
	L["Show Texture"] = " "
	L["Show this group's children"] = "    "
	L["Show Tick"] = " "
	L["Shows a 3D model from the game files"] = "  3D  "
	L["Shows a border"] = " "
	L["Shows a Circular Progress Texture"] = "    "
	L["Shows a custom texture"] = "    "
	L["Shows a glow"] = " "
	L["Shows a Linear Progress Texture"] = "   "
	L["Shows a model"] = " "
	L["Shows a progress bar with name, timer, and icon"] = ", ,     "
	L["Shows a spell icon with an optional cooldown overlay"] = "       "
	L["Shows a Stop Motion"] = "  "
	L["Shows a stop motion texture"] = "   "
	L["Shows a Texture"] = " "
	L["Shows a texture that changes based on duration"] = "    "
	L["Shows nothing, except sub elements"] = "     "
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "          "
	L["Size"] = ""
	L["Slant Amount"] = " "
	L["Slant Mode"] = " "
	L["Slanted"] = ""
	L["Slide"] = ""
	L["Slide In"] = " "
	L["Slide Out"] = " "
	L["Slider Step Size"] = "  "
	L["Small Icon"] = " "
	L["Smooth Progress"] = " "
	L["Snippets"] = ""
	L["Soft Max"] = "  "
	L["Soft Min"] = "  "
	L["Sort"] = ""
	L["Sound Channel"] = " "
	L["Sound File Path"] = "  "
	L["Sound Kit ID"] = " Kit ID"
	L["Space Horizontally"] = " "
	L["Space Vertically"] = " "
	L["Spark Settings"] = " "
	L["Spark Texture"] = " "
	L["Specific Currency ID"] = " ID "
	L["Spell Selection Filters"] = "  "
	L["Spells found:"] = " :"
	L["Stack Info"] = " "
	L["Stacks - The number of stacks of an aura (usually)"] = " -    ()"
	L["Standby"] = " "
	L["Star"] = ""
	L["Start"] = ""
	L["Start Angle"] = " "
	L["Start Collapsed"] = "  "
	L["Start of %s"] = "%s "
	L["Step Size"] = " "
	L["Stop Motion %s"] = "  %s"
	L["Stop Motion Settings"] = "  "
	L["Stop Sound"] = "  "
	L["Stretched by Foreground"] = "  "
	L["Sub Elements"] = "  "
	L["Sub Option %i"] = "  %i"
	L["Subevent"] = ""
	L["Subevent Suffix"] = " "
	L["Swipe Overlay Settings"] = "   "
	L["Templates could not be loaded, the addon is %s"] = "   .  %s."
	L["Temporary Group"] = " "
	L["Text %s"] = " %s"
	L["Text Color"] = ""
	L["Text Settings"] = " "
	L["Texture %s"] = " %s"
	L["Texture Info"] = " "
	L["Texture Selection Mode"] = "  "
	L["Texture Settings"] = " "
	L["Texture Wrap"] = "  "
	L["Texture X Offset"] = " X  "
	L["Texture Y Offset"] = " Y  "
	L["Thanks"] = " "
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "ElvUI         .   ElvUI    "
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "OmniCC         .   OmniCC    "
	L["The duration of the animation in seconds."] = "  ()"
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = "  .         ."
	L["The group and all direct children will share the same base frame level."] = "          ."
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "    .            ."
	L["The type of trigger"] = "  "
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "WeakAuras Options  %s  WeakAuras %s   .             .   WeakAuras    ."
	L["Then "] = "Then"
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "         .      ."
	L["This adds %raidMark as text replacements."] = "      %raidMark ."
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "      %role, %roleIcon .     ."
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "      %tooltip, %tooltip1, %tooltip2, %tooltip3, %tooltip4   /     ."
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = "    Lua   .    !"
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "  '%s'       .        ."
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "  '%s'       .        ."
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = "       (%s) .     !"
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = "     WeakAuras . WeakAuras         ."
	L["This display is currently loaded"] = "   "
	L["This display is not currently loaded"] = "   "
	L["This display is on standby, it will be loaded when needed."] = "   .   ."
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "     .    DebugPrint        ."
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "    : |cff9900FF%s|r"
	L["This is a modified version of your group: |cff9900FF%s|r"] = "    : |cff9900FF%s|r"
	L["This region of type \"%s\" is not supported."] = " \"%s\"   (region)  ."
	L["This setting controls what widget is generated in user mode."] = "      ."
	L["Thumbnail Icon"] = " "
	L["Tick %s"] = " %s"
	L["Tick Area %s"] = "  %s"
	L["Tick Center %s"] = "  %s"
	L["Tick Mode"] = " "
	L["Tick Placement"] = " "
	L["Time in"] = " "
	L["Tiny Icon"] = "  "
	L["To Frame's"] = " "
	L["To Group's"] = " "
	L["To Personal Ressource Display's"] = "    "
	L["To Region's"] = " (Region) "
	L["To Screen's"] = " "
	L["Toggle the visibility of all loaded displays"] = "    "
	L["Toggle the visibility of all non-loaded displays"] = "     "
	L["Toggle the visibility of this display"] = "   "
	L["Tooltip Content"] = " "
	L["Tooltip on Mouseover"] = "    "
	L["Tooltip Pattern Match"] = "  "
	L["Tooltip Text"] = " "
	L["Tooltip Value"] = " "
	L["Tooltip Value #"] = "  #"
	L["Top HUD position"] = " HUD "
	L["Total"] = " "
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = " -         "
	L["Total Angle"] = " "
	L["Total Time"] = " "
	L["Trigger %i: %s"] = "  %i: %s"
	L["Trigger Combination"] = "  "
	L["Type 'select' for '%s' requires a values member'"] = "'%s' 'select'     "
	L["Undo"] = " "
	L["Ungroup"] = " "
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "%s  RegisterUnitEvent  ."
	L["Unit Count"] = " "
	L["Unknown"] = "  "
	L["Unknown Encounter's Spell Id"] = "     ID"
	L["Unknown property '%s' found in '%s'"] = "'%2$s'     '%1$s'|1;; "
	L["Unknown Spell"] = "   "
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "           ."
	L["Update"] = ""
	L["Update Auras"] = ""
	L["Update Custom Text On..."] = "    ..."
	L["URL"] = "URL"
	L["Url: %s"] = "URL: %s"
	L["Use Display Info Id"] = "  ID "
	L["Use SetTransform"] = "SetTransform "
	L["Used in Auras:"] = "  :"
	L["Used in auras:"] = "  :"
	L["Uses Texture Coordinates to rotate the texture."] = "   ."
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "UnitIsVisible()        .    100 .   ."
	L["Value"] = ""
	L["Value %i"] = " %i"
	L["Values are in normalized rgba format."] = "  rgba ."
	L["Values/Remaining Time above this value are displayed as full progress."] = "/         ."
	L["Values/Remaining Time below this value are displayed as zero progress."] = "/       0 ."
	L["Values:"] = ":"
	L["Version: "] = ":"
	L["Version: %s"] = ": %s"
	L["Vertical Align"] = " "
	L["Vertical Bar"] = "  "
	L["View"] = ""
	L["View custom code"] = "   "
	L["Voice Settings"] = "  "
	L["We thank"] = ""
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s (WoW %s)"
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras     ID  .  ID    ."
	L["What do you want to do?"] = " ?"
	L["Whole Area"] = " "
	L["wrapping"] = ""
	L["X Offset"] = "X  "
	L["X Rotation"] = "X "
	L["X Scale"] = "X "
	L["x-Offset"] = "x- "
	L["Y Offset"] = "Y  "
	L["Y Rotation"] = "Y "
	L["Y Scale"] = "Y "
	L["Yellow Rune"] = " "
	L["y-Offset"] = "y- "
	L["You already have this group/aura. Importing will create a duplicate."] = "  / .   ."
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = " %d  . |cFFFF0000   !|r ?"
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "    . |cFFFF0000   !|r ?"
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = "    Lua     . |cFFFF0000          !|r ?"
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = " State          (  ) WeakAuras     .     'changed'     (region) , ,    WeakAuras      ."
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = " State          (  ) WeakAuras     .     'changed'     (region) , ,    WeakAuras       ."
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = " State          (  ) WeakAuras    .     'changed'     (region) , ,    WeakAuras      ."
	L["Your Saved Snippets"] = " "
	L["Z Offset"] = "Z  "
	L["Z Rotation"] = "Z "
	L["Zoom In"] = ""
	L["Zoom Out"] = ""


=== END OF FILE: WeakAurasOptions/Locales/koKR.lua ===


=== FILE: WeakAurasOptions/Locales/ptBR.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "ptBR" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = "e |cFFFF0000mirrored|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- No remova este comentrio, ele faz parte desta aura:"
	--[[Translation missing --]]
	L[" rotated |cFFFF0000%s|r degrees"] = " rotated |cFFFF0000%s|r degrees"
	--[[Translation missing --]]
	L["% - To show a percent sign"] = "% - To show a percent sign"
	L["% of Progress"] = "% do progresso"
	--[[Translation missing --]]
	L["%d |4aura:auras; added"] = "%d |4aura:auras; added"
	--[[Translation missing --]]
	L["%d |4aura:auras; deleted"] = "%d |4aura:auras; deleted"
	--[[Translation missing --]]
	L["%d |4aura:auras; modified"] = "%d |4aura:auras; modified"
	--[[Translation missing --]]
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; with meta data modified"
	--[[Translation missing --]]
	L["%d displays loaded"] = "%d displays loaded"
	--[[Translation missing --]]
	L["%d displays not loaded"] = "%d displays not loaded"
	--[[Translation missing --]]
	L["%d displays on standby"] = "%d displays on standby"
	L["%i auras selected"] = "%i auras selecionadas"
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	--[[Translation missing --]]
	L["%s - %i. Trigger"] = "%s - %i. Trigger"
	--[[Translation missing --]]
	L["%s - Alpha Animation"] = "%s - Alpha Animation"
	--[[Translation missing --]]
	L["%s - Color Animation"] = "%s - Color Animation"
	--[[Translation missing --]]
	L["%s - Condition Custom Chat %s"] = "%s - Condition Custom Chat %s"
	--[[Translation missing --]]
	L["%s - Condition Custom Check %s"] = "%s - Condition Custom Check %s"
	--[[Translation missing --]]
	L["%s - Condition Custom Code %s"] = "%s - Condition Custom Code %s"
	--[[Translation missing --]]
	L["%s - Custom Anchor"] = "%s - Custom Anchor"
	--[[Translation missing --]]
	L["%s - Custom Grow"] = "%s - Custom Grow"
	--[[Translation missing --]]
	L["%s - Custom Sort"] = "%s - Custom Sort"
	--[[Translation missing --]]
	L["%s - Custom Text"] = "%s - Custom Text"
	--[[Translation missing --]]
	L["%s - Finish"] = "%s - Finish"
	--[[Translation missing --]]
	L["%s - Finish Action"] = "%s - Finish Action"
	--[[Translation missing --]]
	L["%s - Finish Custom Text"] = "%s - Finish Custom Text"
	--[[Translation missing --]]
	L["%s - Init Action"] = "%s - Init Action"
	--[[Translation missing --]]
	L["%s - Main"] = "%s - Main"
	--[[Translation missing --]]
	L["%s - OnLoad"] = "%s - OnLoad"
	--[[Translation missing --]]
	L["%s - OnUnload"] = "%s - OnUnload"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - Option #%i possui a chave %s. Por favor, selecione uma opo diferente de chave."
	--[[Translation missing --]]
	L["%s - Rotate Animation"] = "%s - Rotate Animation"
	--[[Translation missing --]]
	L["%s - Scale Animation"] = "%s - Scale Animation"
	--[[Translation missing --]]
	L["%s - Start"] = "%s - Start"
	--[[Translation missing --]]
	L["%s - Start Action"] = "%s - Start Action"
	--[[Translation missing --]]
	L["%s - Start Custom Text"] = "%s - Start Custom Text"
	--[[Translation missing --]]
	L["%s - Translate Animation"] = "%s - Translate Animation"
	--[[Translation missing --]]
	L["%s - Trigger Logic"] = "%s - Trigger Logic"
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, Linhas: %d, Frequncia: %0.2f, Comprimento: %d, Espessura: %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, Partculas: %d, Frequncia: %0.2f, Escala: %0.2f"
	--[[Translation missing --]]
	L["%s %u. Overlay Function"] = "%s %u. Overlay Function"
	--[[Translation missing --]]
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s Transparncia: %d%%"
	L["%s Color"] = "%s Cor"
	--[[Translation missing --]]
	L["%s Custom Variables"] = "%s Custom Variables"
	--[[Translation missing --]]
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"
	--[[Translation missing --]]
	L["%s Duration Function"] = "%s Duration Function"
	--[[Translation missing --]]
	L["%s Icon Function"] = "%s Icon Function"
	--[[Translation missing --]]
	L["%s Inset: %d%%"] = "%s Inset: %d%%"
	--[[Translation missing --]]
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s Manter Proporo"
	--[[Translation missing --]]
	L["%s Name Function"] = "%s Name Function"
	--[[Translation missing --]]
	L["%s Stacks Function"] = "%s Stacks Function"
	--[[Translation missing --]]
	L["%s stores around %s KB of data"] = "%s stores around %s KB of data"
	L["%s Texture"] = "%s Textura"
	--[[Translation missing --]]
	L["%s Texture Function"] = "%s Texture Function"
	L["%s total auras"] = "%s auras totais"
	--[[Translation missing --]]
	L["%s Trigger Function"] = "%s Trigger Function"
	--[[Translation missing --]]
	L["%s Untrigger Function"] = "%s Untrigger Function"
	--[[Translation missing --]]
	L["%s X offset by %d"] = "%s X offset by %d"
	--[[Translation missing --]]
	L["%s Y offset by %d"] = "%s Y offset by %d"
	L["%s Zoom: %d%%"] = "%s Zoom: %d%%"
	L["%s, Border"] = "%s, Borda"
	L["%s, Offset: %0.2f;%0.2f"] = "%s, Posicionamento: %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, posicionamento: %0.2f;%0.2f"
	--[[Translation missing --]]
	L["%s, Start Animation"] = "%s, Start Animation"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000custom|r textura com |cFFFF0000%s|r modo de mistura%s%s"
	L["(Right click to rename)"] = "(Clique com o boto direito para renomear)"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02xCor personalizada|r"
	--[[Translation missing --]]
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000Note:|r Isso define a descrio apenas em '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000Note:|r Isso define o URL em todas as auras selecionadas"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000Note:|r Isso define a URL neste grupo e todos os seus membros."
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000Automtico|r comprimento"
	L["|cFFFF0000default|r texture"] = "|cFFFF0000padro|r textura"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000dessaturado|r"
	--[[Translation missing --]]
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000Note:|r The unit '%s' is not a trackable unit."
	--[[Translation missing --]]
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00Opes Extra:|r"
	--[[Translation missing --]]
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00Extra:|r %s and %s %s"
	--[[Translation missing --]]
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"
	--[[Translation missing --]]
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"
	--[[Translation missing --]]
	L["|cffffcc00Format Options|r"] = "|cffffcc00Format Options|r"
	--[[Translation missing --]]
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=]
	L["A 20x20 pixels icon"] = "Um cone de 20x20 pixels"
	L["A 32x32 pixels icon"] = "Um cone de 32x32 pixels"
	L["A 40x40 pixels icon"] = "Um cone de 40x40 pixels"
	L["A 48x48 pixels icon"] = "Um cone de 48x48 pixels"
	L["A 64x64 pixels icon"] = "Um cone de 64x64 pixels"
	L["A group that dynamically controls the positioning of its children"] = "Um grupo que controla dinamicamente o posicionamentos dos seus elementos"
	--[[Translation missing --]]
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=]
	L["A Unit ID (e.g., party1)."] = "O ID de uma unidade (por exemplo, grupo1)."
	--[[Translation missing --]]
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	--[[Translation missing --]]
	L["Active Aura Filters and Info"] = "Active Aura Filters and Info"
	--[[Translation missing --]]
	L["Actual Spec"] = "Actual Spec"
	L["Add %s"] = "Adicionar %s"
	L["Add a new display"] = "Adicionar um novo display"
	L["Add Condition"] = "Adicionar condio"
	L["Add Entry"] = "Adicionar entrada"
	L["Add Extra Elements"] = "Adicionar elementos extras"
	L["Add Option"] = "Adicionar Opo"
	L["Add Overlay"] = "Adicionar sobreposio"
	L["Add Property Change"] = "Adicionar mudana de propriedade"
	--[[Translation missing --]]
	L["Add Snippet"] = "Add Snippet"
	--[[Translation missing --]]
	L["Add Sub Option"] = "Add Sub Option"
	L["Add to group %s"] = "Adicionar ao grupo %s"
	L["Add to new Dynamic Group"] = "Adicionar a um novo Grupo Dinmico"
	L["Add to new Group"] = "Adicionar a um novo Grupo"
	L["Add Trigger"] = "Adicionar gatilho"
	L["Additional Events"] = "Eventos adicionais"
	L["Advanced"] = "Avanado"
	--[[Translation missing --]]
	L["Affected Unit Filters and Info"] = "Affected Unit Filters and Info"
	L["Align"] = "Alinhar"
	L["Alignment"] = "Alinhamento"
	--[[Translation missing --]]
	L["All maintainers of the libraries we use, especially:"] = "All maintainers of the libraries we use, especially:"
	L["All of"] = "Todos"
	--[[Translation missing --]]
	L["Allow Full Rotation"] = "Allow Full Rotation"
	L["Anchor"] = "ncora"
	--[[Translation missing --]]
	L["Anchor Mode"] = "Anchor Mode"
	L["Anchor Point"] = "Ponto da ncora"
	L["Anchored To"] = "Ancorado a"
	L["And "] = "E"
	--[[Translation missing --]]
	L["and"] = "and"
	--[[Translation missing --]]
	L["and %s"] = "and %s"
	L["and aligned left"] = "e alinhado  esquerda"
	L["and aligned right"] = "e alinhado  direita"
	--[[Translation missing --]]
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"
	L["and rotated left"] = "e girado para a esquerda"
	L["and rotated right"] = "e girado para a direita"
	L["and with width |cFFFF0000%s|r and %s"] = "e com largura |cFFFF0000%s|r e %s"
	L["Angle"] = "ngulo"
	--[[Translation missing --]]
	L["Angle Between Auras"] = "Angle Between Auras"
	L["Animate"] = "Animar"
	L["Animated Expand and Collapse"] = "Animao expande e esvai"
	L["Animates progress changes"] = "Anima mudanas no progresso"
	L["Animation End"] = "Fim da animao"
	L["Animation Mode"] = "Modo de Animao"
	L["Animation relative duration description"] = [=[A durao da animao relativa ao tempo de durao do display, expresso como frao (1/2), porcentagem (50%), ou decimal. (0.5)
|cFFFF0000Nota:|r se um display no tiver progresso (o gatilho  no-temporal,  aura sem durao, etc), a animao no ir tocar.

|cFF4444FFFou Exemplo:|r
Se a durao da animao estiver setada para |cFF00CC0010%|r, e o display do gatilho for um benefcio que dure 20 segundos, o come da animao tocar por 2 segundos.
Se a durao da animao estiver setada para |cFF00C0010%|r, e o gatilho do display for um benefcio que no tem durao, nenhum come de animao ir tocar (no entanto, tocaria se voce especificasse uma durao em segundos)."
WeakAuras  Opes  Opes ]=]
	L["Animation Sequence"] = "Sequncia da animao"
	L["Animation Start"] = "Comeo de Animao"
	L["Any of"] = "Qualquer"
	L["Apply Template"] = "Aplicar Modelo"
	L["Arcane Orb"] = "Orbe Arcano"
	--[[Translation missing --]]
	L["Area"] = "Area"
	L["At a position a bit left of Left HUD position."] = "Em uma posio um pouco  esquerda da posio do HUD esquerdo."
	L["At a position a bit left of Right HUD position"] = "Em uma posio um pouco  esquerda da posio direita do HUD."
	L["At the same position as Blizzard's spell alert"] = "Na mesma posio do alerta de feitio da Blizzard"
	--[[Translation missing --]]
	L["Attach to Foreground"] = "Attach to Foreground"
	L[ [=[Aura is
Off Screen]=] ] = "Aura est fora da tela"
	L["Aura Name Pattern"] = "Padro de nome da aura"
	--[[Translation missing --]]
	L["Aura Order"] = "Aura Order"
	--[[Translation missing --]]
	L["Aura received from: %s"] = "Aura received from: %s"
	--[[Translation missing --]]
	L["Aura: '%s'"] = "Aura: '%s'"
	--[[Translation missing --]]
	L["Auto-Clone (Show All Matches)"] = "Auto-Clone (Show All Matches)"
	L["Automatic length"] = "Comprimento Automtico"
	--[[Translation missing --]]
	L["Backdrop Color"] = "Backdrop Color"
	--[[Translation missing --]]
	L["Backdrop in Front"] = "Backdrop in Front"
	--[[Translation missing --]]
	L["Backdrop Style"] = "Backdrop Style"
	L["Background Inner"] = "Plano de Fundo Interno"
	L["Background Offset"] = "Posicionamento do Fundo"
	L["Background Texture"] = "Textura do fundo"
	L["Bar Alpha"] = "Transparncia da barra"
	L["Bar Color Settings"] = "Configuraes de Cor da Barra"
	L["Big Icon"] = "cone Grande"
	L["Blend Mode"] = "Modo de mistura"
	L["Blue Rune"] = "Runa Azul"
	L["Blue Sparkle Orb"] = "Orbe Cintilante Azul"
	L["Border %s"] = "Borda %s"
	L["Border Anchor"] = "ncora da Borda"
	L["Border Color"] = "Cor da Borda"
	L["Border in Front"] = "Borda na Frente"
	L["Border Inset"] = "Intercalao da Borda"
	L["Border Offset"] = "Posicionamento da Borda"
	L["Border Settings"] = "Configuraes da Borda"
	L["Border Size"] = "Tamanho da Borda"
	L["Border Style"] = "Estilo da Borda"
	--[[Translation missing --]]
	L["Bracket Matching"] = "Bracket Matching"
	L["Browse Wago, the largest collection of auras."] = "Acesse Wago, a maior coleo de auras."
	--[[Translation missing --]]
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."
	L["Can be a UID (e.g., party1)."] = "Pode ser um UNID (por exemplo, grupo1)."
	--[[Translation missing --]]
	L["Can set to 0 if Columns * Width equal File Width"] = "Can set to 0 if Columns * Width equal File Width"
	--[[Translation missing --]]
	L["Can set to 0 if Rows * Height equal File Height"] = "Can set to 0 if Rows * Height equal File Height"
	--[[Translation missing --]]
	L["Case Insensitive"] = "Case Insensitive"
	--[[Translation missing --]]
	L["Cast by a Player Character"] = "Cast by a Player Character"
	--[[Translation missing --]]
	L["Categories to Update"] = "Categories to Update"
	--[[Translation missing --]]
	L["Changelog"] = "Changelog"
	L["Chat with WeakAuras experts on our Discord server."] = "Converso com especialistas do WeakAuras no nosso servidor do Discord."
	L["Check On..."] = "Verificar..."
	L["Check out our wiki for a large collection of examples and snippets."] = "Confira nosso wiki para uma grande coleo de exemplos e fragmentos."
	L["Children:"] = "Criana:"
	L["Choose"] = "Escolher"
	--[[Translation missing --]]
	L["Circular Texture %s"] = "Circular Texture %s"
	--[[Translation missing --]]
	L["Clear Debug Logs"] = "Clear Debug Logs"
	--[[Translation missing --]]
	L["Clear Saved Data"] = "Clear Saved Data"
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	--[[Translation missing --]]
	L["Clip Overlays"] = "Clip Overlays"
	--[[Translation missing --]]
	L["Clipped by Foreground"] = "Clipped by Foreground"
	L["Close"] = "Fechar"
	--[[Translation missing --]]
	L["Code Editor"] = "Code Editor"
	L["Collapse"] = "Encolher"
	--[[Translation missing --]]
	L["Collapse all loaded displays"] = "Collapse all loaded displays"
	--[[Translation missing --]]
	L["Collapse all non-loaded displays"] = "Collapse all non-loaded displays"
	--[[Translation missing --]]
	L["Collapse all pending Import"] = "Collapse all pending Import"
	--[[Translation missing --]]
	L["Collapsible Group"] = "Collapsible Group"
	L["color"] = "cor"
	--[[Translation missing --]]
	L["Column Height"] = "Column Height"
	--[[Translation missing --]]
	L["Column Space"] = "Column Space"
	--[[Translation missing --]]
	L["Columns"] = "Columns"
	--[[Translation missing --]]
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = "COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."
	L["Combinations"] = "Combinaes"
	--[[Translation missing --]]
	L["Combine Matches Per Unit"] = "Combine Matches Per Unit"
	--[[Translation missing --]]
	L["Common Text"] = "Common Text"
	--[[Translation missing --]]
	L["Compare against the number of units affected."] = "Compare against the number of units affected."
	--[[Translation missing --]]
	L["Compatibility Options"] = "Compatibility Options"
	L["Compress"] = "Comprimir"
	L["Configure what options appear on this panel."] = "Configure quais opes aparecem neste painel."
	L["Constant Factor"] = "Fator constante"
	--[[Translation missing --]]
	L["Control-click to select multiple displays"] = "Control-click to select multiple displays"
	L["Controls the positioning and configuration of multiple displays at the same time"] = "Controla o posicionamento e a configurao de mltiplos displays ao mesmo tempo"
	L["Convert to..."] = "Converter para..."
	--[[Translation missing --]]
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "Cooldown Numbers might be added by WoW. You can configure these in the game settings."
	--[[Translation missing --]]
	L["Copy"] = "Copy"
	L["Copy settings..."] = "Copiar configuraes"
	--[[Translation missing --]]
	L["Copy to all auras"] = "Copy to all auras"
	--[[Translation missing --]]
	L["Could not parse '%s'. Expected a table."] = "Could not parse '%s'. Expected a table."
	--[[Translation missing --]]
	L["Counts the number of matches over all units."] = "Counts the number of matches over all units."
	--[[Translation missing --]]
	L["Counts the number of matches per unit."] = "Counts the number of matches per unit."
	--[[Translation missing --]]
	L["Create a Copy"] = "Create a Copy"
	L["Creating buttons: "] = "Criando botes:"
	L["Creating options: "] = "Criando opes:"
	--[[Translation missing --]]
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = "Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."
	L["Custom Code"] = "Cdigo personalizado"
	--[[Translation missing --]]
	L["Custom Code Viewer"] = "Custom Code Viewer"
	--[[Translation missing --]]
	L["Custom Frames"] = "Custom Frames"
	--[[Translation missing --]]
	L["Custom Functions"] = "Custom Functions"
	--[[Translation missing --]]
	L["Custom Init"] = "Custom Init"
	--[[Translation missing --]]
	L["Custom Load"] = "Custom Load"
	--[[Translation missing --]]
	L["Custom Options"] = "Custom Options"
	--[[Translation missing --]]
	L["Custom Text Update Throttle"] = "Custom Text Update Throttle"
	L["Custom Trigger"] = "Gatilho personalizado"
	--[[Translation missing --]]
	L["Custom trigger event tooltip"] = [=[Choose which events cause the custom trigger to be checked. Multiple events can be specified using commas or spaces.
 "UNIT" events can use colons to define which unitIDs will be registered. In addition to UnitIDs Unit types can be used, they include "nameplate", "group", "raid", "party", "arena", "boss".
 "CLEU" can be used instead of COMBAT_LOG_EVENT_UNFILTERED and colons can be used to separate specific "subEvents" you want to receive.
 The keyword "TRIGGER" can be used, with colons separating trigger numbers, to have the custom trigger get updated when the specified trigger(s) update.

|cFF4444FFFor example:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1
]=]
	--[[Translation missing --]]
	L["Custom trigger status tooltip"] = [=[Choose which events cause the custom trigger to be checked. Multiple events can be specified using commas or spaces.

 "UNIT" events can use colons to define which unitIDs will be registered. In addition to UnitIDs Unit types can be used, they include "nameplate", "group", "raid", "party", "arena", "boss".
 "CLEU" can be used instead of COMBAT_LOG_EVENT_UNFILTERED and colons can be used to separate specific "subEvents" you want to receive.
 The keyword "TRIGGER" can be used, with colons separating trigger numbers, to have the custom trigger get updated when the specified trigger(s) update.

Since this is a status-type trigger, the specified events may be called by WeakAuras without the expected arguments.

|cFF4444FFFor example:|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1
]=]
	--[[Translation missing --]]
	L["Custom trigger Update Throttle"] = "Custom trigger Update Throttle"
	--[[Translation missing --]]
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = "Custom Trigger: Ignore Lua Errors on OPTIONS event"
	--[[Translation missing --]]
	L["Custom Trigger: Send fake events instead of STATUS event"] = "Custom Trigger: Send fake events instead of STATUS event"
	--[[Translation missing --]]
	L["Custom Unload"] = "Custom Unload"
	--[[Translation missing --]]
	L["Custom Untrigger"] = "Custom Untrigger"
	--[[Translation missing --]]
	L["Debug Log"] = "Debug Log"
	--[[Translation missing --]]
	L["Debug Log:"] = "Debug Log:"
	L["Default"] = "Padro"
	--[[Translation missing --]]
	L["Default Color"] = "Default Color"
	--[[Translation missing --]]
	L["Delay"] = "Delay"
	L["Delete"] = "Apagar"
	L["Delete all"] = "Apagar tudo"
	--[[Translation missing --]]
	L["Delete children and group"] = "Delete children and group"
	--[[Translation missing --]]
	L["Delete Entry"] = "Delete Entry"
	--[[Translation missing --]]
	L["Deleting auras: "] = "Deleting auras: "
	L["Description Text"] = "Texto Descritivo"
	--[[Translation missing --]]
	L["Determines how many entries can be in the table."] = "Determines how many entries can be in the table."
	L["Differences"] = "Diferenas"
	--[[Translation missing --]]
	L["Disallow Entry Reordering"] = "Disallow Entry Reordering"
	--[[Translation missing --]]
	L["Discord"] = "Discord"
	--[[Translation missing --]]
	L["Display Name"] = "Display Name"
	L["Display Text"] = "Texto do mostrurio"
	--[[Translation missing --]]
	L["Displays a text, works best in combination with other displays"] = "Displays a text, works best in combination with other displays"
	L["Distribute Horizontally"] = "Distribuir horizontalmente"
	L["Distribute Vertically"] = "Distribuir verticalmente"
	--[[Translation missing --]]
	L["Do not group this display"] = "Do not group this display"
	--[[Translation missing --]]
	L["Do you want to enable updates for this aura"] = "Do you want to enable updates for this aura"
	--[[Translation missing --]]
	L["Do you want to ignore updates for this aura"] = "Do you want to ignore updates for this aura"
	L["Documentation"] = "Documentao"
	--[[Translation missing --]]
	L["Done"] = "Done"
	L["Drag to move"] = "Arraste para mover"
	L["Duplicate"] = "Duplicar"
	--[[Translation missing --]]
	L["Duplicate All"] = "Duplicate All"
	L["Duration (s)"] = "Durao"
	L["Duration Info"] = "Informao da durao"
	--[[Translation missing --]]
	L["Dynamic Duration"] = "Dynamic Duration"
	L["Dynamic Group"] = "Grupo dinmico"
	--[[Translation missing --]]
	L["Dynamic Group Settings"] = "Dynamic Group Settings"
	--[[Translation missing --]]
	L["Dynamic Information"] = "Dynamic Information"
	--[[Translation missing --]]
	L["Dynamic information from first active trigger"] = "Dynamic information from first active trigger"
	--[[Translation missing --]]
	L["Dynamic information from Trigger %i"] = "Dynamic information from Trigger %i"
	--[[Translation missing --]]
	L["Dynamic Text Replacements"] = "Dynamic Text Replacements"
	--[[Translation missing --]]
	L["Ease Strength"] = "Ease Strength"
	--[[Translation missing --]]
	L["Ease type"] = "Ease type"
	--[[Translation missing --]]
	L["eliding"] = "eliding"
	--[[Translation missing --]]
	L["Else If"] = "Else If"
	--[[Translation missing --]]
	L["Else If %s"] = "Else If %s"
	--[[Translation missing --]]
	L["Empty Base Region"] = "Empty Base Region"
	--[[Translation missing --]]
	L["Enable \"Edge\" part of the overlay"] = "Enable \"Edge\" part of the overlay"
	--[[Translation missing --]]
	L["Enable \"swipe\" part of the overlay"] = "Enable \"swipe\" part of the overlay"
	--[[Translation missing --]]
	L["Enable Debug Log"] = "Enable Debug Log"
	--[[Translation missing --]]
	L["Enable Debug Logging"] = "Enable Debug Logging"
	--[[Translation missing --]]
	L["Enable Gradient"] = "Enable Gradient"
	--[[Translation missing --]]
	L["Enable Swipe"] = "Enable Swipe"
	--[[Translation missing --]]
	L["Enable the \"Swipe\" radial overlay"] = "Enable the \"Swipe\" radial overlay"
	L["Enabled"] = "Habilitado"
	--[[Translation missing --]]
	L["End Angle"] = "End Angle"
	--[[Translation missing --]]
	L["End of %s"] = "End of %s"
	--[[Translation missing --]]
	L["Enemy nameplate(s) found"] = "Enemy nameplate(s) found"
	--[[Translation missing --]]
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "Enter a Spell ID. You can use the addon idTip to determine spell ids."
	--[[Translation missing --]]
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = "Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."
	L["Enter Author Mode"] = "Entrar no Modo de Autor"
	--[[Translation missing --]]
	L["Enter in a value for the tick's placement."] = "Enter in a value for the tick's placement."
	--[[Translation missing --]]
	L["Enter static or relative values with %"] = "Enter static or relative values with %"
	--[[Translation missing --]]
	L["Enter User Mode"] = "Enter User Mode"
	--[[Translation missing --]]
	L["Enter user mode."] = "Enter user mode."
	--[[Translation missing --]]
	L["Entry %i"] = "Entry %i"
	--[[Translation missing --]]
	L["Entry limit"] = "Entry limit"
	--[[Translation missing --]]
	L["Entry Name Source"] = "Entry Name Source"
	L["Event Type"] = "Tipo de evento"
	L["Everything"] = "Tudo"
	--[[Translation missing --]]
	L["Exact Item Match"] = "Exact Item Match"
	--[[Translation missing --]]
	L["Exact Spell Match"] = "Exact Spell Match"
	L["Expand"] = "Expandir"
	L["Expand all loaded displays"] = "Expandir todos os mostrurios carregados"
	L["Expand all non-loaded displays"] = "Expandir todos os mostrurios no carregados"
	--[[Translation missing --]]
	L["Expand all pending Import"] = "Expand all pending Import"
	--[[Translation missing --]]
	L["Expansion is disabled because this group has no children"] = "Expansion is disabled because this group has no children"
	--[[Translation missing --]]
	L["Export debug table..."] = "Export debug table..."
	--[[Translation missing --]]
	L["Export..."] = "Export..."
	--[[Translation missing --]]
	L["Exporting"] = "Exporting"
	L["External"] = "Externo"
	--[[Translation missing --]]
	L["Extra Height"] = "Extra Height"
	--[[Translation missing --]]
	L["Extra Width"] = "Extra Width"
	L["Fade"] = "Sumir"
	--[[Translation missing --]]
	L["Fadeout Sound"] = "Fadeout Sound"
	--[[Translation missing --]]
	L["Fadeout Time (seconds)"] = "Fadeout Time (seconds)"
	--[[Translation missing --]]
	L["Fetch Affected/Unaffected Names and Units"] = "Fetch Affected/Unaffected Names and Units"
	--[[Translation missing --]]
	L["Fetch Raid Mark Information"] = "Fetch Raid Mark Information"
	--[[Translation missing --]]
	L["Fetch Role Information"] = "Fetch Role Information"
	--[[Translation missing --]]
	L["Fetch Tooltip Information"] = "Fetch Tooltip Information"
	--[[Translation missing --]]
	L["File Height"] = "File Height"
	--[[Translation missing --]]
	L["File Width"] = "File Width"
	--[[Translation missing --]]
	L["Filter based on the spell Name string."] = "Filter based on the spell Name string."
	--[[Translation missing --]]
	L["Filter by Arena Spec"] = "Filter by Arena Spec"
	--[[Translation missing --]]
	L["Filter by Class"] = "Filter by Class"
	--[[Translation missing --]]
	L["Filter by Group Role"] = "Filter by Group Role"
	--[[Translation missing --]]
	L["Filter by Hostility"] = "Filter by Hostility"
	--[[Translation missing --]]
	L["Filter by Npc ID"] = "Filter by Npc ID"
	--[[Translation missing --]]
	L["Filter by Raid Role"] = "Filter by Raid Role"
	--[[Translation missing --]]
	L["Filter by Specialization"] = "Filter by Specialization"
	--[[Translation missing --]]
	L["Filter by Unit Name"] = "Filter by Unit Name"
	--[[Translation missing --]]
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
	--[[Translation missing --]]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=]
	L["Find Auras"] = "Buscar Auras"
	L["Finish"] = "Finalizar"
	--[[Translation missing --]]
	L["Finishing..."] = "Finishing..."
	--[[Translation missing --]]
	L["Fire Orb"] = "Fire Orb"
	--[[Translation missing --]]
	L["Flat Framelevels"] = "Flat Framelevels"
	L["Foreground Texture"] = "Textura do primeiro plano"
	--[[Translation missing --]]
	L["Format for %s"] = "Format for %s"
	L["Found a Bug?"] = "Encontrou um Bug?"
	L["Frame"] = "Quadro"
	--[[Translation missing --]]
	L["Frame Count"] = "Frame Count"
	--[[Translation missing --]]
	L["Frame Height"] = "Frame Height"
	--[[Translation missing --]]
	L["Frame Rate"] = "Frame Rate"
	L["Frame Strata"] = "Camada do quadro"
	--[[Translation missing --]]
	L["Frame Width"] = "Frame Width"
	--[[Translation missing --]]
	L["Full Bar"] = "Full Bar"
	--[[Translation missing --]]
	L["Full Circle"] = "Full Circle"
	L["Global Conditions"] = "Condies Globais"
	--[[Translation missing --]]
	L["Glow %s"] = "Glow %s"
	L["Glow Action"] = "Ao incandescente"
	--[[Translation missing --]]
	L["Glow Anchor"] = "Glow Anchor"
	--[[Translation missing --]]
	L["Glow Color"] = "Glow Color"
	--[[Translation missing --]]
	L["Glow Frame Type"] = "Glow Frame Type"
	--[[Translation missing --]]
	L["Glow Type"] = "Glow Type"
	--[[Translation missing --]]
	L["Green Rune"] = "Green Rune"
	--[[Translation missing --]]
	L["Grid direction"] = "Grid direction"
	--[[Translation missing --]]
	L["Group (verb)"] = "Group"
	--[[Translation missing --]]
	L["Group Alpha"] = "Group Alpha"
	--[[Translation missing --]]
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=]
	--[[Translation missing --]]
	L["Group aura count description"] = [=[The amount of units of type '%s' which must be affected by one or more of the given auras for the display to trigger.
If the entered number is a whole number (e.g. 5), the number of affected units will be compared with the entered number.
If the entered number is a decimal (e.g. 0.5), fraction (e.g. 1/2), or percentage (e.g. 50%%), then that fraction of the %s must be affected.

|cFF4444FFFor example:|r
|cFF00CC00> 0|r will trigger when any unit of type '%s' is affected
|cFF00CC00= 100%%|r will trigger when every unit of type '%s' is affected
|cFF00CC00!= 2|r will trigger when the number of units of type '%s' affected is not exactly 2
|cFF00CC00<= 0.8|r will trigger when less than 80%% of the units of type '%s' is affected (4 of 5 party members, 8 of 10 or 20 of 25 raid members)
|cFF00CC00> 1/2|r will trigger when more than half of the units of type '%s' is affected
]=]
	--[[Translation missing --]]
	L["Group by Frame"] = "Group by Frame"
	--[[Translation missing --]]
	L["Group Description"] = "Group Description"
	L["Group Icon"] = "cone do Grupo"
	L["Group key"] = "Chave do grupo"
	--[[Translation missing --]]
	L["Group Options"] = "Group Options"
	--[[Translation missing --]]
	L["Group player(s) found"] = "Group player(s) found"
	--[[Translation missing --]]
	L["Group Role"] = "Group Role"
	--[[Translation missing --]]
	L["Group Scale"] = "Group Scale"
	--[[Translation missing --]]
	L["Group Settings"] = "Group Settings"
	--[[Translation missing --]]
	L["Hawk"] = "Hawk"
	L["Help"] = "Ajuda"
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	--[[Translation missing --]]
	L["Hide Background"] = "Hide Background"
	--[[Translation missing --]]
	L["Hide Glows applied by this aura"] = "Hide Glows applied by this aura"
	--[[Translation missing --]]
	L["Hide on"] = "Hide on"
	--[[Translation missing --]]
	L["Hide this group's children"] = "Hide this group's children"
	--[[Translation missing --]]
	L["Highlights"] = "Highlights"
	L["Horizontal Align"] = "Alinhamento horizontal"
	L["Horizontal Bar"] = "Barra Horizontal"
	--[[Translation missing --]]
	L["Huge Icon"] = "Huge Icon"
	--[[Translation missing --]]
	L["Hybrid Position"] = "Hybrid Position"
	--[[Translation missing --]]
	L["Hybrid Sort Mode"] = "Hybrid Sort Mode"
	--[[Translation missing --]]
	L["Icon - The icon associated with the display"] = "Icon - The icon associated with the display"
	L["Icon Info"] = "Informao do cone"
	--[[Translation missing --]]
	L["Icon Inset"] = "Icon Inset"
	--[[Translation missing --]]
	L["Icon Picker"] = "Icon Picker"
	--[[Translation missing --]]
	L["Icon Position"] = "Icon Position"
	--[[Translation missing --]]
	L["Icon Settings"] = "Icon Settings"
	L["Icon Source"] = "Fonte do cone"
	L["If"] = "Se"
	--[[Translation missing --]]
	L["If %s"] = "If %s"
	--[[Translation missing --]]
	L["If checked, then the combo box in the User settings will be sorted."] = "If checked, then the combo box in the User settings will be sorted."
	--[[Translation missing --]]
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."
	--[[Translation missing --]]
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "If checked, then this group will not merge with other group when selecting multiple auras."
	--[[Translation missing --]]
	L["If checked, then this option group can be temporarily collapsed by the user."] = "If checked, then this option group can be temporarily collapsed by the user."
	--[[Translation missing --]]
	L["If checked, then this option group will start collapsed."] = "If checked, then this option group will start collapsed."
	--[[Translation missing --]]
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "If checked, then this separator will include text. Otherwise, it will be just a horizontal line."
	--[[Translation missing --]]
	L["If checked, then this space will span across multiple lines."] = "If checked, then this space will span across multiple lines."
	--[[Translation missing --]]
	L["If unchecked, then a default color will be used (usually yellow)"] = "If unchecked, then a default color will be used (usually yellow)"
	--[[Translation missing --]]
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "If unchecked, then this space will fill the entire line it is on in User Mode."
	--[[Translation missing --]]
	L["Ignore out of casting range"] = "Ignore out of casting range"
	--[[Translation missing --]]
	L["Ignore out of checking range"] = "Ignore out of checking range"
	--[[Translation missing --]]
	L["Ignore Wago updates"] = "Ignore Wago updates"
	L["Ignored"] = "Ignorado"
	--[[Translation missing --]]
	L["Ignored Aura Name"] = "Ignored Aura Name"
	--[[Translation missing --]]
	L["Ignored Exact Spell ID(s)"] = "Ignored Exact Spell ID(s)"
	--[[Translation missing --]]
	L["Ignored Name(s)"] = "Ignored Name(s)"
	--[[Translation missing --]]
	L["Ignored Spell ID"] = "Ignored Spell ID"
	L["Import"] = "Importar"
	--[[Translation missing --]]
	L["Import / Export"] = "Import / Export"
	L["Import a display from an encoded string"] = "Importar um display de um string codificado"
	--[[Translation missing --]]
	L["Import as Copy"] = "Import as Copy"
	--[[Translation missing --]]
	L["Import has no UID, cannot be matched to existing auras."] = "Import has no UID, cannot be matched to existing auras."
	--[[Translation missing --]]
	L["Importing"] = "Importing"
	--[[Translation missing --]]
	L["Importing %s"] = "Importing %s"
	--[[Translation missing --]]
	L["Importing a group with %s child auras."] = "Importing a group with %s child auras."
	--[[Translation missing --]]
	L["Importing a stand-alone aura."] = "Importing a stand-alone aura."
	--[[Translation missing --]]
	L["Importing...."] = "Importing...."
	--[[Translation missing --]]
	L["Incompatible changes to group region types detected"] = "Incompatible changes to group region types detected"
	--[[Translation missing --]]
	L["Incompatible changes to group structure detected"] = "Incompatible changes to group structure detected"
	--[[Translation missing --]]
	L["Indent Size"] = "Indent Size"
	--[[Translation missing --]]
	L["Inner"] = "Inner"
	--[[Translation missing --]]
	L["Insert text replacement codes to make text dynamic."] = "Insert text replacement codes to make text dynamic."
	--[[Translation missing --]]
	L["Invalid Item ID"] = "Invalid Item ID"
	--[[Translation missing --]]
	L["Invalid Item Name/ID/Link"] = "Invalid Item Name/ID/Link"
	--[[Translation missing --]]
	L["Invalid Spell ID"] = "Invalid Spell ID"
	--[[Translation missing --]]
	L["Invalid Spell Name/ID/Link"] = "Invalid Spell Name/ID/Link"
	--[[Translation missing --]]
	L["Invalid target aura"] = "Invalid target aura"
	--[[Translation missing --]]
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."
	--[[Translation missing --]]
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "Invalid type for property '%s' in '%s'. Expected '%s'"
	--[[Translation missing --]]
	L["Inverse Slant"] = "Inverse Slant"
	--[[Translation missing --]]
	L["Invert the direction of progress"] = "Invert the direction of progress"
	L["Is Boss Debuff"] = " Debuff de Chefe"
	L["Is Stealable"] = " Roubvel"
	--[[Translation missing --]]
	L["Is Unit"] = "Is Unit"
	L["Justify"] = "Justificar"
	--[[Translation missing --]]
	L["Keep Aspect Ratio"] = "Keep Aspect Ratio"
	--[[Translation missing --]]
	L["Keep your Wago imports up to date with the Companion App."] = "Keep your Wago imports up to date with the Companion App."
	--[[Translation missing --]]
	L["Large Input"] = "Large Input"
	--[[Translation missing --]]
	L["Leaf"] = "Leaf"
	--[[Translation missing --]]
	L["Left 2 HUD position"] = "Left 2 HUD position"
	--[[Translation missing --]]
	L["Left HUD position"] = "Left HUD position"
	--[[Translation missing --]]
	L["Length of |cFFFF0000%s|r"] = "Length of |cFFFF0000%s|r"
	--[[Translation missing --]]
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	--[[Translation missing --]]
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	--[[Translation missing --]]
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	--[[Translation missing --]]
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	--[[Translation missing --]]
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	--[[Translation missing --]]
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	--[[Translation missing --]]
	L["Limit"] = "Limit"
	--[[Translation missing --]]
	L["Line"] = "Line"
	--[[Translation missing --]]
	L["Linear Texture %s"] = "Linear Texture %s"
	--[[Translation missing --]]
	L["Linked aura: "] = "Linked aura: "
	--[[Translation missing --]]
	L["Linked Auras"] = "Linked Auras"
	--[[Translation missing --]]
	L["Load"] = "Load"
	L["Loaded"] = "Carregado"
	--[[Translation missing --]]
	L["Loaded/Standby"] = "Loaded/Standby"
	L["Lock Positions"] = "Travar Posies"
	--[[Translation missing --]]
	L["Low Mana"] = "Low Mana"
	L["Magnetically Align"] = "Alinhar Magneticamente"
	L["Main"] = "Principal"
	--[[Translation missing --]]
	L["Manual with %i/%i"] = "Manual with %i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	--[[Translation missing --]]
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "Matches the height setting of a horizontal bar or width for a vertical bar."
	--[[Translation missing --]]
	L["Max"] = "Max"
	--[[Translation missing --]]
	L["Max Length"] = "Max Length"
	--[[Translation missing --]]
	L["Maximum"] = "Maximum"
	--[[Translation missing --]]
	L["Media Type"] = "Media Type"
	--[[Translation missing --]]
	L["Medium Icon"] = "Medium Icon"
	--[[Translation missing --]]
	L["Min"] = "Min"
	--[[Translation missing --]]
	L["Minimum"] = "Minimum"
	--[[Translation missing --]]
	L["Model %s"] = "Model %s"
	--[[Translation missing --]]
	L["Model Picker"] = "Model Picker"
	--[[Translation missing --]]
	L["Model Settings"] = "Model Settings"
	--[[Translation missing --]]
	L["ModelPaths could not be loaded, the addon is %s"] = "ModelPaths could not be loaded, the addon is %s"
	--[[Translation missing --]]
	L["Move Above Group"] = "Move Above Group"
	--[[Translation missing --]]
	L["Move Below Group"] = "Move Below Group"
	--[[Translation missing --]]
	L["Move Down"] = "Move Down"
	--[[Translation missing --]]
	L["Move Entry Down"] = "Move Entry Down"
	--[[Translation missing --]]
	L["Move Entry Up"] = "Move Entry Up"
	--[[Translation missing --]]
	L["Move Into Above Group"] = "Move Into Above Group"
	--[[Translation missing --]]
	L["Move Into Below Group"] = "Move Into Below Group"
	--[[Translation missing --]]
	L["Move this display down in its group's order"] = "Move this display down in its group's order"
	--[[Translation missing --]]
	L["Move this display up in its group's order"] = "Move this display up in its group's order"
	--[[Translation missing --]]
	L["Move Up"] = "Move Up"
	--[[Translation missing --]]
	L["Moving auras: "] = "Moving auras: "
	L["Multiple Displays"] = "Mltiplos displays"
	--[[Translation missing --]]
	L["Multiselect ignored tooltip"] = [=[|cFFFF0000Ignored|r - |cFF777777Single|r - |cFF777777Multiple|r
This option will not be used to determine when this display should load]=]
	--[[Translation missing --]]
	L["Multiselect multiple tooltip"] = [=[|cFF777777Ignored|r - |cFF777777Single|r - |cFF00FF00Multiple|r
Any number of matching values can be picked]=]
	--[[Translation missing --]]
	L["Multiselect single tooltip"] = [=[|cFF777777Ignored|r - |cFF00FF00Single|r - |cFF777777Multiple|r
Only a single matching value can be picked]=]
	--[[Translation missing --]]
	L["Must be a power of 2"] = "Must be a power of 2"
	--[[Translation missing --]]
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"
	L["Name Info"] = "Informao do Nome"
	--[[Translation missing --]]
	L["Name Pattern Match"] = "Name Pattern Match"
	L["Name:"] = "Nome:"
	L["Negator"] = "Negador"
	L["New Aura"] = "Nova Aura"
	--[[Translation missing --]]
	L["New Template"] = "New Template"
	--[[Translation missing --]]
	L["New Value"] = "New Value"
	--[[Translation missing --]]
	L["No Children"] = "No Children"
	--[[Translation missing --]]
	L["No Logs saved."] = "No Logs saved."
	--[[Translation missing --]]
	L["Not a table"] = "Not a table"
	--[[Translation missing --]]
	L["Not all children have the same value for this option"] = "Not all children have the same value for this option"
	L["Not Loaded"] = "No Carregado"
	--[[Translation missing --]]
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "Note: Automated Messages to SAY and YELL are blocked outside of Instances."
	--[[Translation missing --]]
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""
	--[[Translation missing --]]
	L["Number of Entries"] = "Number of Entries"
	--[[Translation missing --]]
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=]
	--[[Translation missing --]]
	L["OFF"] = "OFF"
	L["Offer a guided way to create auras for your character"] = "Oferece uma maneira guiada de criar auras para seu personagem"
	--[[Translation missing --]]
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"
	--[[Translation missing --]]
	L["Offset by 1px"] = "Offset by 1px"
	L["Okay"] = "Okay"
	--[[Translation missing --]]
	L["ON"] = "ON"
	L["On Hide"] = "Quando sumir"
	L["On Show"] = "Quando mostrar"
	--[[Translation missing --]]
	L["Only Match auras cast by a player (not an npc)"] = "Only Match auras cast by a player (not an npc)"
	--[[Translation missing --]]
	L["Only match auras cast by people other than the player or their pet"] = "Only match auras cast by people other than the player or their pet"
	--[[Translation missing --]]
	L["Only match auras cast by the player or their pet"] = "Only match auras cast by the player or their pet"
	L["Operator"] = "Operador"
	--[[Translation missing --]]
	L["Option %i"] = "Option %i"
	--[[Translation missing --]]
	L["Option key"] = "Option key"
	--[[Translation missing --]]
	L["Option Type"] = "Option Type"
	--[[Translation missing --]]
	L["Options will open after combat ends."] = "Options will open after combat ends."
	L["or"] = "ou"
	--[[Translation missing --]]
	L["or %s"] = "or %s"
	--[[Translation missing --]]
	L["Orange Rune"] = "Orange Rune"
	--[[Translation missing --]]
	L["Our translators (too many to name)"] = "Our translators (too many to name)"
	--[[Translation missing --]]
	L["Outer"] = "Outer"
	--[[Translation missing --]]
	L["Overflow"] = "Overflow"
	--[[Translation missing --]]
	L["Overlay %s Info"] = "Overlay %s Info"
	--[[Translation missing --]]
	L["Overlays"] = "Overlays"
	L["Own Only"] = "Apenas meu"
	--[[Translation missing --]]
	L["Paste Action Settings"] = "Paste Action Settings"
	--[[Translation missing --]]
	L["Paste Animations Settings"] = "Paste Animations Settings"
	--[[Translation missing --]]
	L["Paste Author Options Settings"] = "Paste Author Options Settings"
	--[[Translation missing --]]
	L["Paste Condition Settings"] = "Paste Condition Settings"
	--[[Translation missing --]]
	L["Paste Custom Configuration"] = "Paste Custom Configuration"
	--[[Translation missing --]]
	L["Paste Display Settings"] = "Paste Display Settings"
	--[[Translation missing --]]
	L["Paste Group Settings"] = "Paste Group Settings"
	--[[Translation missing --]]
	L["Paste Load Settings"] = "Paste Load Settings"
	--[[Translation missing --]]
	L["Paste Settings"] = "Paste Settings"
	L["Paste text below"] = "Cole o texto abaixo"
	--[[Translation missing --]]
	L["Paste Trigger Settings"] = "Paste Trigger Settings"
	--[[Translation missing --]]
	L["Places a tick on the bar"] = "Places a tick on the bar"
	L["Play Sound"] = "Reproduzir Som"
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	--[[Translation missing --]]
	L["Portrait Zoom"] = "Portrait Zoom"
	--[[Translation missing --]]
	L["Position and Size Settings"] = "Position and Size Settings"
	--[[Translation missing --]]
	L["Preferred Match"] = "Preferred Match"
	--[[Translation missing --]]
	L["Premade Auras"] = "Premade Auras"
	--[[Translation missing --]]
	L["Premade Snippets"] = "Premade Snippets"
	--[[Translation missing --]]
	L["Preparing auras: "] = "Preparing auras: "
	--[[Translation missing --]]
	L["Press Ctrl+C to copy"] = "Press Ctrl+C to copy"
	--[[Translation missing --]]
	L["Press Ctrl+C to copy the URL"] = "Press Ctrl+C to copy the URL"
	--[[Translation missing --]]
	L["Prevent Merging"] = "Prevent Merging"
	--[[Translation missing --]]
	L["Progress - The remaining time of a timer, or a non-timer value"] = "Progress - The remaining time of a timer, or a non-timer value"
	L["Progress Bar"] = "Barra de Progresso"
	--[[Translation missing --]]
	L["Progress Bar Settings"] = "Progress Bar Settings"
	--[[Translation missing --]]
	L["Progress Settings"] = "Progress Settings"
	L["Progress Texture"] = "Textura de Progresso"
	--[[Translation missing --]]
	L["Progress Texture Settings"] = "Progress Texture Settings"
	--[[Translation missing --]]
	L["Purple Rune"] = "Purple Rune"
	--[[Translation missing --]]
	L["Put this display in a group"] = "Put this display in a group"
	--[[Translation missing --]]
	L["Range in yards"] = "Range in yards"
	--[[Translation missing --]]
	L["Ready for Install"] = "Ready for Install"
	--[[Translation missing --]]
	L["Ready for Update"] = "Ready for Update"
	L["Re-center X"] = "Recentralizar X"
	L["Re-center Y"] = "Recentralizar Y"
	--[[Translation missing --]]
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "Reciprocal TRIGGER:# requests will be ignored!"
	--[[Translation missing --]]
	L["Redo"] = "Redo"
	--[[Translation missing --]]
	L["Regions of type \"%s\" are not supported."] = "Regions of type \"%s\" are not supported."
	L["Remove"] = "Remover"
	--[[Translation missing --]]
	L["Remove All Sounds"] = "Remove All Sounds"
	--[[Translation missing --]]
	L["Remove All Text To Speech"] = "Remove All Text To Speech"
	--[[Translation missing --]]
	L["Remove this display from its group"] = "Remove this display from its group"
	L["Remove this property"] = "Remover esta propriedade"
	L["Rename"] = "Renomear"
	--[[Translation missing --]]
	L["Repeat After"] = "Repeat After"
	--[[Translation missing --]]
	L["Repeat every"] = "Repeat every"
	--[[Translation missing --]]
	L["Report bugs on our issue tracker."] = "Report bugs on our issue tracker."
	--[[Translation missing --]]
	L["Require unit from trigger"] = "Require unit from trigger"
	L["Required for Activation"] = "Requerido para Ativar"
	--[[Translation missing --]]
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"
	--[[Translation missing --]]
	L["Reset all options to their default values."] = "Reset all options to their default values."
	--[[Translation missing --]]
	L["Reset Entry"] = "Reset Entry"
	L["Reset to Defaults"] = "Redefinir para os padres"
	--[[Translation missing --]]
	L["Right 2 HUD position"] = "Right 2 HUD position"
	--[[Translation missing --]]
	L["Right HUD position"] = "Right HUD position"
	L["Right-click for more options"] = "Clique-direito para mais opes"
	L["Rotate"] = "Girar"
	L["Rotate In"] = "Girar para dentro"
	L["Rotate Out"] = "Girar para fora"
	L["Rotate Text"] = "Girar o texto"
	--[[Translation missing --]]
	L["Rotation Mode"] = "Rotation Mode"
	--[[Translation missing --]]
	L["Row Space"] = "Row Space"
	--[[Translation missing --]]
	L["Row Width"] = "Row Width"
	--[[Translation missing --]]
	L["Rows"] = "Rows"
	--[[Translation missing --]]
	L["Run on..."] = "Run on..."
	L["Same"] = "Mesmo"
	--[[Translation missing --]]
	L["Same texture as Foreground"] = "Same texture as Foreground"
	--[[Translation missing --]]
	L["Saved Data"] = "Saved Data"
	--[[Translation missing --]]
	L["Scale Factor"] = "Scale Factor"
	--[[Translation missing --]]
	L["Search API"] = "Search API"
	--[[Translation missing --]]
	L["Select Talent"] = "Select Talent"
	--[[Translation missing --]]
	L["Select the auras you always want to be listed first"] = "Select the auras you always want to be listed first"
	--[[Translation missing --]]
	L["Selected Frame"] = "Selected Frame"
	L["Send To"] = "Enviar para"
	--[[Translation missing --]]
	L["Separator Text"] = "Separator Text"
	--[[Translation missing --]]
	L["Separator text"] = "Separator text"
	--[[Translation missing --]]
	L["Set Maximum Progress"] = "Set Maximum Progress"
	--[[Translation missing --]]
	L["Set Minimum Progress"] = "Set Minimum Progress"
	--[[Translation missing --]]
	L["Set Parent to Anchor"] = "Set Parent to Anchor"
	--[[Translation missing --]]
	L["Set Thumbnail Icon"] = "Set Thumbnail Icon"
	--[[Translation missing --]]
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."
	L["Settings"] = "Configuraes"
	--[[Translation missing --]]
	L["Shadow Color"] = "Shadow Color"
	--[[Translation missing --]]
	L["Shadow X Offset"] = "Shadow X Offset"
	--[[Translation missing --]]
	L["Shadow Y Offset"] = "Shadow Y Offset"
	--[[Translation missing --]]
	L["Shift-click to create chat link"] = "Shift-click to create a |cFF8800FF[Chat Link]"
	--[[Translation missing --]]
	L["Show \"Edge\""] = "Show \"Edge\""
	--[[Translation missing --]]
	L["Show \"Swipe\""] = "Show \"Swipe\""
	--[[Translation missing --]]
	L["Show and Clone Settings"] = "Show and Clone Settings"
	--[[Translation missing --]]
	L["Show Border"] = "Show Border"
	--[[Translation missing --]]
	L["Show Circular Texture"] = "Show Circular Texture"
	--[[Translation missing --]]
	L["Show Debug Logs"] = "Show Debug Logs"
	--[[Translation missing --]]
	L["Show Glow"] = "Show Glow"
	L["Show Icon"] = "Mostrar cone"
	--[[Translation missing --]]
	L["Show If Unit Does Not Exist"] = "Show If Unit Does Not Exist"
	--[[Translation missing --]]
	L["Show Linear Texture"] = "Show Linear Texture"
	--[[Translation missing --]]
	L["Show Matches for"] = "Show Matches for"
	--[[Translation missing --]]
	L["Show Matches for Units"] = "Show Matches for Units"
	--[[Translation missing --]]
	L["Show Model"] = "Show Model"
	--[[Translation missing --]]
	L["Show model of unit "] = "Show model of unit "
	--[[Translation missing --]]
	L["Show Sound Setting"] = "Show Sound Setting"
	--[[Translation missing --]]
	L["Show Spark"] = "Show Spark"
	--[[Translation missing --]]
	L["Show Stop Motion"] = "Show Stop Motion"
	L["Show Text"] = "Mostrar Texto"
	--[[Translation missing --]]
	L["Show Text To Speech Setting"] = "Show Text To Speech Setting"
	--[[Translation missing --]]
	L["Show Texture"] = "Show Texture"
	--[[Translation missing --]]
	L["Show this group's children"] = "Show this group's children"
	--[[Translation missing --]]
	L["Show Tick"] = "Show Tick"
	L["Shows a 3D model from the game files"] = "Mostrar um modelo 3D dos arquivos do jogo"
	--[[Translation missing --]]
	L["Shows a border"] = "Shows a border"
	--[[Translation missing --]]
	L["Shows a Circular Progress Texture"] = "Shows a Circular Progress Texture"
	L["Shows a custom texture"] = "Mostrar uma textura personalizada"
	--[[Translation missing --]]
	L["Shows a glow"] = "Shows a glow"
	--[[Translation missing --]]
	L["Shows a Linear Progress Texture"] = "Shows a Linear Progress Texture"
	--[[Translation missing --]]
	L["Shows a model"] = "Shows a model"
	L["Shows a progress bar with name, timer, and icon"] = "Mostrar uma barra de progresso com nome, temporizador e cone"
	L["Shows a spell icon with an optional cooldown overlay"] = "Mostrar um cone de feitio com o opcional do tempo de recarga sobreposto"
	--[[Translation missing --]]
	L["Shows a Stop Motion"] = "Shows a Stop Motion"
	L["Shows a stop motion texture"] = "Mostra uma textura de stop motion"
	--[[Translation missing --]]
	L["Shows a Texture"] = "Shows a Texture"
	L["Shows a texture that changes based on duration"] = "Mostrar uma textura que muda com base na durao"
	--[[Translation missing --]]
	L["Shows nothing, except sub elements"] = "Shows nothing, except sub elements"
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "Mostra uma ou mais linhas de texto, que podem incluir informaes dinmicas tal como progresso ou quantidades"
	L["Size"] = "Tamanho"
	--[[Translation missing --]]
	L["Slant Amount"] = "Slant Amount"
	--[[Translation missing --]]
	L["Slant Mode"] = "Slant Mode"
	--[[Translation missing --]]
	L["Slanted"] = "Slanted"
	L["Slide"] = "Deslizar"
	L["Slide In"] = "Deslizar para dentro"
	L["Slide Out"] = "Deslizar para fora"
	--[[Translation missing --]]
	L["Slider Step Size"] = "Slider Step Size"
	--[[Translation missing --]]
	L["Small Icon"] = "Small Icon"
	--[[Translation missing --]]
	L["Smooth Progress"] = "Smooth Progress"
	--[[Translation missing --]]
	L["Snippets"] = "Snippets"
	--[[Translation missing --]]
	L["Soft Max"] = "Soft Max"
	--[[Translation missing --]]
	L["Soft Min"] = "Soft Min"
	L["Sort"] = "Ordenar"
	L["Sound Channel"] = "Canal de som"
	L["Sound File Path"] = "Caminho do arquivo de som"
	--[[Translation missing --]]
	L["Sound Kit ID"] = "Sound Kit ID"
	L["Space Horizontally"] = "Espao horizontal"
	L["Space Vertically"] = "Espaar Verticalmente"
	--[[Translation missing --]]
	L["Spark Settings"] = "Spark Settings"
	--[[Translation missing --]]
	L["Spark Texture"] = "Spark Texture"
	--[[Translation missing --]]
	L["Specific Currency ID"] = "Specific Currency ID"
	--[[Translation missing --]]
	L["Spell Selection Filters"] = "Spell Selection Filters"
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = "Informao do Monte"
	--[[Translation missing --]]
	L["Stacks - The number of stacks of an aura (usually)"] = "Stacks - The number of stacks of an aura (usually)"
	--[[Translation missing --]]
	L["Standby"] = "Standby"
	--[[Translation missing --]]
	L["Star"] = "Star"
	L["Start"] = "Incio"
	--[[Translation missing --]]
	L["Start Angle"] = "Start Angle"
	--[[Translation missing --]]
	L["Start Collapsed"] = "Start Collapsed"
	--[[Translation missing --]]
	L["Start of %s"] = "Start of %s"
	--[[Translation missing --]]
	L["Step Size"] = "Step Size"
	--[[Translation missing --]]
	L["Stop Motion %s"] = "Stop Motion %s"
	L["Stop Motion Settings"] = "Configuraes de Stop Motion"
	L["Stop Sound"] = "Parar Som"
	--[[Translation missing --]]
	L["Stretched by Foreground"] = "Stretched by Foreground"
	--[[Translation missing --]]
	L["Sub Elements"] = "Sub Elements"
	--[[Translation missing --]]
	L["Sub Option %i"] = "Sub Option %i"
	--[[Translation missing --]]
	L["Subevent"] = "Subevent"
	--[[Translation missing --]]
	L["Subevent Suffix"] = "Subevent Suffix"
	--[[Translation missing --]]
	L["Swipe Overlay Settings"] = "Swipe Overlay Settings"
	--[[Translation missing --]]
	L["Templates could not be loaded, the addon is %s"] = "Templates could not be loaded, the addon is %s"
	L["Temporary Group"] = "Grupo temporrio"
	L["Text %s"] = "Texto %s"
	L["Text Color"] = "Cor do texto"
	--[[Translation missing --]]
	L["Text Settings"] = "Text Settings"
	--[[Translation missing --]]
	L["Texture %s"] = "Texture %s"
	--[[Translation missing --]]
	L["Texture Info"] = "Texture Info"
	--[[Translation missing --]]
	L["Texture Selection Mode"] = "Texture Selection Mode"
	L["Texture Settings"] = "Configuraes da Textura"
	--[[Translation missing --]]
	L["Texture Wrap"] = "Texture Wrap"
	--[[Translation missing --]]
	L["Texture X Offset"] = "Texture X Offset"
	--[[Translation missing --]]
	L["Texture Y Offset"] = "Texture Y Offset"
	--[[Translation missing --]]
	L["Thanks"] = "Thanks"
	--[[Translation missing --]]
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"
	--[[Translation missing --]]
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"
	--[[Translation missing --]]
	L["The duration of the animation in seconds."] = "The duration of the animation in seconds."
	--[[Translation missing --]]
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = "The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."
	--[[Translation missing --]]
	L["The group and all direct children will share the same base frame level."] = "The group and all direct children will share the same base frame level."
	--[[Translation missing --]]
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."
	--[[Translation missing --]]
	L["The type of trigger"] = "The type of trigger"
	--[[Translation missing --]]
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"
	L["Then "] = "Ento"
	--[[Translation missing --]]
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."
	--[[Translation missing --]]
	L["This adds %raidMark as text replacements."] = "This adds %raidMark as text replacements."
	--[[Translation missing --]]
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."
	--[[Translation missing --]]
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."
	--[[Translation missing --]]
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=]
	--[[Translation missing --]]
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."
	--[[Translation missing --]]
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=]
	--[[Translation missing --]]
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=]
	--[[Translation missing --]]
	L["This display is currently loaded"] = "This display is currently loaded"
	--[[Translation missing --]]
	L["This display is not currently loaded"] = "This display is not currently loaded"
	--[[Translation missing --]]
	L["This display is on standby, it will be loaded when needed."] = "This display is on standby, it will be loaded when needed."
	--[[Translation missing --]]
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."
	--[[Translation missing --]]
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "This is a modified version of your aura, |cff9900FF%s.|r"
	--[[Translation missing --]]
	L["This is a modified version of your group: |cff9900FF%s|r"] = "This is a modified version of your group: |cff9900FF%s|r"
	--[[Translation missing --]]
	L["This region of type \"%s\" is not supported."] = "This region of type \"%s\" is not supported."
	--[[Translation missing --]]
	L["This setting controls what widget is generated in user mode."] = "This setting controls what widget is generated in user mode."
	--[[Translation missing --]]
	L["Thumbnail Icon"] = "Thumbnail Icon"
	--[[Translation missing --]]
	L["Tick %s"] = "Tick %s"
	--[[Translation missing --]]
	L["Tick Area %s"] = "Tick Area %s"
	--[[Translation missing --]]
	L["Tick Center %s"] = "Tick Center %s"
	--[[Translation missing --]]
	L["Tick Mode"] = "Tick Mode"
	--[[Translation missing --]]
	L["Tick Placement"] = "Tick Placement"
	--[[Translation missing --]]
	L["Time in"] = "Time in"
	--[[Translation missing --]]
	L["Tiny Icon"] = "Tiny Icon"
	--[[Translation missing --]]
	L["To Frame's"] = "To Frame's"
	--[[Translation missing --]]
	L["To Group's"] = "To Group's"
	--[[Translation missing --]]
	L["To Personal Ressource Display's"] = "To Personal Ressource Display's"
	--[[Translation missing --]]
	L["To Region's"] = "To Region's"
	--[[Translation missing --]]
	L["To Screen's"] = "To Screen's"
	--[[Translation missing --]]
	L["Toggle the visibility of all loaded displays"] = "Toggle the visibility of all loaded displays"
	--[[Translation missing --]]
	L["Toggle the visibility of all non-loaded displays"] = "Toggle the visibility of all non-loaded displays"
	--[[Translation missing --]]
	L["Toggle the visibility of this display"] = "Toggle the visibility of this display"
	--[[Translation missing --]]
	L["Tooltip Content"] = "Tooltip Content"
	--[[Translation missing --]]
	L["Tooltip on Mouseover"] = "Tooltip on Mouseover"
	--[[Translation missing --]]
	L["Tooltip Pattern Match"] = "Tooltip Pattern Match"
	--[[Translation missing --]]
	L["Tooltip Text"] = "Tooltip Text"
	--[[Translation missing --]]
	L["Tooltip Value"] = "Tooltip Value"
	--[[Translation missing --]]
	L["Tooltip Value #"] = "Tooltip Value #"
	--[[Translation missing --]]
	L["Top HUD position"] = "Top HUD position"
	--[[Translation missing --]]
	L["Total"] = "Total"
	--[[Translation missing --]]
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = "Total - The maximum duration of a timer, or a maximum non-timer value"
	--[[Translation missing --]]
	L["Total Angle"] = "Total Angle"
	L["Total Time"] = "Tempo Total"
	--[[Translation missing --]]
	L["Trigger %i: %s"] = "Trigger %i: %s"
	--[[Translation missing --]]
	L["Trigger Combination"] = "Trigger Combination"
	--[[Translation missing --]]
	L["Type 'select' for '%s' requires a values member'"] = "Type 'select' for '%s' requires a values member'"
	--[[Translation missing --]]
	L["Undo"] = "Undo"
	--[[Translation missing --]]
	L["Ungroup"] = "Ungroup"
	--[[Translation missing --]]
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "Unit %s is not a valid unit for RegisterUnitEvent"
	--[[Translation missing --]]
	L["Unit Count"] = "Unit Count"
	--[[Translation missing --]]
	L["Unknown"] = "Unknown"
	--[[Translation missing --]]
	L["Unknown Encounter's Spell Id"] = "Unknown Encounter's Spell Id"
	--[[Translation missing --]]
	L["Unknown property '%s' found in '%s'"] = "Unknown property '%s' found in '%s'"
	--[[Translation missing --]]
	L["Unknown Spell"] = "Unknown Spell"
	--[[Translation missing --]]
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."
	--[[Translation missing --]]
	L["Update"] = "Update"
	L["Update Auras"] = "Atualizar Auras"
	--[[Translation missing --]]
	L["Update Custom Text On..."] = "Update Custom Text On..."
	--[[Translation missing --]]
	L["URL"] = "URL"
	--[[Translation missing --]]
	L["Url: %s"] = "Url: %s"
	--[[Translation missing --]]
	L["Use Display Info Id"] = "Use Display Info Id"
	--[[Translation missing --]]
	L["Use SetTransform"] = "Use SetTransform"
	--[[Translation missing --]]
	L["Used in Auras:"] = "Used in Auras:"
	--[[Translation missing --]]
	L["Used in auras:"] = "Used in auras:"
	--[[Translation missing --]]
	L["Uses Texture Coordinates to rotate the texture."] = "Uses Texture Coordinates to rotate the texture."
	--[[Translation missing --]]
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."
	--[[Translation missing --]]
	L["Value"] = "Value"
	--[[Translation missing --]]
	L["Value %i"] = "Value %i"
	--[[Translation missing --]]
	L["Values are in normalized rgba format."] = "Values are in normalized rgba format."
	--[[Translation missing --]]
	L["Values/Remaining Time above this value are displayed as full progress."] = "Values/Remaining Time above this value are displayed as full progress."
	--[[Translation missing --]]
	L["Values/Remaining Time below this value are displayed as zero progress."] = "Values/Remaining Time below this value are displayed as zero progress."
	--[[Translation missing --]]
	L["Values:"] = "Values:"
	--[[Translation missing --]]
	L["Version: "] = "Version: "
	--[[Translation missing --]]
	L["Version: %s"] = "Version: %s"
	--[[Translation missing --]]
	L["Vertical Align"] = "Vertical Align"
	--[[Translation missing --]]
	L["Vertical Bar"] = "Vertical Bar"
	--[[Translation missing --]]
	L["View"] = "View"
	--[[Translation missing --]]
	L["View custom code"] = "View custom code"
	--[[Translation missing --]]
	L["Voice Settings"] = "Voice Settings"
	--[[Translation missing --]]
	L["We thank"] = "We thank"
	--[[Translation missing --]]
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s on WoW %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	--[[Translation missing --]]
	L["What do you want to do?"] = "What do you want to do?"
	--[[Translation missing --]]
	L["Whole Area"] = "Whole Area"
	--[[Translation missing --]]
	L["wrapping"] = "wrapping"
	L["X Offset"] = "X Posicionamento"
	--[[Translation missing --]]
	L["X Rotation"] = "X Rotation"
	--[[Translation missing --]]
	L["X Scale"] = "X Scale"
	--[[Translation missing --]]
	L["x-Offset"] = "x-Offset"
	L["Y Offset"] = "Y Posicionamento"
	--[[Translation missing --]]
	L["Y Rotation"] = "Y Rotation"
	--[[Translation missing --]]
	L["Y Scale"] = "Y Scale"
	--[[Translation missing --]]
	L["Yellow Rune"] = "Yellow Rune"
	--[[Translation missing --]]
	L["y-Offset"] = "y-Offset"
	--[[Translation missing --]]
	L["You already have this group/aura. Importing will create a duplicate."] = "You already have this group/aura. Importing will create a duplicate."
	--[[Translation missing --]]
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"
	--[[Translation missing --]]
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=]
	--[[Translation missing --]]
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."
	--[[Translation missing --]]
	L["Your Saved Snippets"] = "Your Saved Snippets"
	L["Z Offset"] = "Z Posicionamento"
	--[[Translation missing --]]
	L["Z Rotation"] = "Z Rotation"
	--[[Translation missing --]]
	L["Zoom In"] = "Zoom In"
	--[[Translation missing --]]
	L["Zoom Out"] = "Zoom Out"


=== END OF FILE: WeakAurasOptions/Locales/ptBR.lua ===


=== FILE: WeakAurasOptions/Locales/ruRU.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "ruRU" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = " |cFFFF0000|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "--    !      "
	L[" rotated |cFFFF0000%s|r degrees"] = ";  %.4g"
	L["% - To show a percent sign"] = "%    "
	L["% of Progress"] = "% "
	L["%d |4aura:auras; added"] = "%d |4 : : ;"
	L["%d |4aura:auras; deleted"] = "%d |4 : : ;"
	L["%d |4aura:auras; modified"] = "%d |4 : : ;"
	L["%d |4aura:auras; with meta data modified"] = "%d |4:;   "
	L["%d displays loaded"] = "%d  "
	L["%d displays not loaded"] = "%d   "
	L["%d displays on standby"] = "%d    "
	L["%i auras selected"] = "%i |4 : : ;"
	L["%i."] = "%i."
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s -  %i."
	L["%s - Alpha Animation"] = "%s  "
	L["%s - Color Animation"] = "%s  "
	L["%s - Condition Custom Chat %s"] = "%s - .    %s"
	L["%s - Condition Custom Check %s"] = "%s - .   %s"
	L["%s - Condition Custom Code %s"] = "%s - .   %s"
	L["%s - Custom Anchor"] = "%s - "
	L["%s - Custom Grow"] = "%s -   "
	L["%s - Custom Sort"] = "%s -   "
	L["%s - Custom Text"] = "%s -  "
	L["%s - Finish"] = "%s - "
	L["%s - Finish Action"] = "%s -   "
	L["%s - Finish Custom Text"] = "%s -     "
	L["%s - Init Action"] = "%s -   "
	L["%s - Main"] = "%s - "
	--[[Translation missing --]]
	L["%s - OnLoad"] = "%s - OnLoad"
	--[[Translation missing --]]
	L["%s - OnUnload"] = "%s - OnUnload"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s   #%i   %s. ,    ."
	L["%s - Rotate Animation"] = "%s  "
	L["%s - Scale Animation"] = "%s  "
	L["%s - Start"] = "%s - "
	L["%s - Start Action"] = "%s -   "
	L["%s - Start Custom Text"] = "%s -     "
	L["%s - Translate Animation"] = "%s  "
	L["%s - Trigger Logic"] = "%s -  "
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s; : %d; : %0.2f; : %d; : %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s; : %d; : %0.2f; : %0.2f"
	L["%s %u. Overlay Function"] = "%s %u.  "
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s  %d%%"
	L["%s Color"] = "%s "
	L["%s Custom Variables"] = "%s  "
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s   , ,  ,  "
	L["%s Duration Function"] = "%s  "
	L["%s Icon Function"] = "%s  "
	L["%s Inset: %d%%"] = "%s  %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s       COMBAT_LOG_EVENT_UNFILTERED"
	L["%s Keep Aspect Ratio"] = "%s   "
	L["%s Name Function"] = "%s  "
	L["%s Stacks Function"] = "%s  "
	L["%s stores around %s KB of data"] = "%s   %s  ."
	L["%s Texture"] = "%s "
	L["%s Texture Function"] = "%s  "
	L["%s total auras"] = " %s |4::;"
	L["%s Trigger Function"] = "%s  "
	L["%s Untrigger Function"] = "%s  "
	L["%s X offset by %d"] = "%s   X  %d"
	L["%s Y offset by %d"] = "%s   Y  %d"
	L["%s Zoom: %d%%"] = "%s : %d%%"
	L["%s, Border"] = "%s, "
	L["%s, Offset: %0.2f;%0.2f"] = "%s, : (%0.2f;%0.2f)"
	L["%s, offset: %0.2f;%0.2f"] = "%s, : (%0.2f;%0.2f)"
	L["%s, Start Animation"] = "%s;  "
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = " %s;   |cFFE6CC80%s|r%s%s"
	L["(Right click to rename)"] = "(,  )"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02x |r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cFF999999   \" \"  \" \" ,   ,    ,          .|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFFFCC00.|r      '%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFFFCC00.|r  URL-    "
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFFFCC00.|r  URL-       "
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000|r "
	L["|cFFFF0000default|r texture"] = " |cFFFF0000 |r"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000|r"
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFFCC00.|r  |cFFE6CC80%s|r  ."
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFFCC00.|r      (soft target unit)     (CVar)."
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFFFCC00.|r     |cFFE6CC80%s|r      |cFFE6CC80%s|r"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFFFCC00.|r     |cFFE6CC80%s|r      |cFFE6CC80%s|r   (%s, %s)"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFFFCC00.|r       |cFFE6CC80%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFFFCC00.|r       |cFFE6CC80%s|r   (%s, %s)"
	L["|cFFffcc00Extra Options:|r"] = "|cFFFFCC00 :|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFFFCC00 :|r %s; %s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFFFCC00 :|r |cFFE6CC80%s|r;  |c%sO|r    (%s, %s);%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFFFCC00 :|r |cFFE6CC80%s|r;  |c%sO|r    (%s, %s);%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cFFFFCC00 |r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = " |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r  |cff00ff00Pet|r     unitID.  |cff00ff00Specific Unit|r     unitID  . |cffff0000|r:         unitID,         .  |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r  |cffffff00Nameplate|r     unitID.  |cffffff00Smart Group|r      ,   \"player\"   , \"party\"  ( \"player\")    \"raid\"   .  |cffffff00Multi-target|r    Combat Log,   unitID,    . |cffff0000|r:      unitID   . |cffffff00*|r   Unit         ,         Unit Count  Match Count."
	L["A 20x20 pixels icon"] = " 2020 "
	L["A 32x32 pixels icon"] = " 3232 "
	L["A 40x40 pixels icon"] = " 4040 "
	L["A 48x48 pixels icon"] = " 4848 "
	L["A 64x64 pixels icon"] = " 6464 "
	L["A group that dynamically controls the positioning of its children"] = ",     "
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = [=[         (  ).

  ,          WeakAuras   .]=]
	L["A Unit ID (e.g., party1)."] = [=[   (UID, Unit ID).
: party4, raid7, arena3, boss2, nameplate6, target, focus, pet  .]=]
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = "    "
	L["Actual Spec"] = " "
	L["Add %s"] = " %s"
	L["Add a new display"] = "  "
	L["Add Condition"] = " "
	L["Add Entry"] = " "
	L["Add Extra Elements"] = "  "
	L["Add Option"] = " "
	L["Add Overlay"] = " "
	L["Add Property Change"] = " "
	L["Add Snippet"] = "  "
	L["Add Sub Option"] = " . "
	L["Add to group %s"] = "   %s"
	L["Add to new Dynamic Group"] = "    "
	L["Add to new Group"] = "   "
	L["Add Trigger"] = " "
	L["Additional Events"] = " "
	L["Advanced"] = " "
	L["Affected Unit Filters and Info"] = "     "
	L["Align"] = ""
	L["Alignment"] = ""
	L["All maintainers of the libraries we use, especially:"] = "  ,   , :"
	L["All of"] = " ( )"
	L["Allow Full Rotation"] = "  "
	L["Anchor"] = ""
	L["Anchor Mode"] = " "
	L["Anchor Point"] = " "
	L["Anchored To"] = " "
	L["And "] = " "
	L["and"] = ""
	L["and %s"] = " %s"
	L["and aligned left"] = "   ;"
	L["and aligned right"] = "   ;"
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "  Patreons,   Discord,    :"
	L["and rotated left"] = "  ;"
	L["and rotated right"] = "  ;"
	L["and with width |cFFFF0000%s|r and %s"] = "  %s; %s"
	L["Angle"] = ""
	L["Angle Between Auras"] = "  "
	L["Animate"] = ""
	L["Animated Expand and Collapse"] = "   "
	L["Animates progress changes"] = "     "
	L["Animation End"] = " "
	L["Animation Mode"] = " "
	L["Animation relative duration description"] = [=[    ,     (1/2)   (0.5) ,  (50%).

|cFFFF0000:|r      (  ,      . .),     .

|cFF4444FF:|r
     |cFF00CC0010%|r    -    20 ,       2 .
     |cFF00CC0010%|r    -   ,      (  ,       ).]=]
	L["Animation Sequence"] = " "
	L["Animation Start"] = " "
	L["Any of"] = " ( )"
	L["Apply Template"] = " "
	L["Arcane Orb"] = " "
	L["Area"] = ""
	L["At a position a bit left of Left HUD position."] = "    HUD"
	L["At a position a bit left of Right HUD position"] = "    HUD"
	L["At the same position as Blizzard's spell alert"] = "   ,      Blizzard"
	L["Attach to Foreground"] = "   "
	L[ [=[Aura is
Off Screen]=] ] = [=[ 
 ]=]
	L["Aura Name Pattern"] = "  "
	L["Aura Order"] = " "
	L["Aura received from: %s"] = "  : %s"
	L["Aura: '%s'"] = ": %s"
	L["Auto-Clone (Show All Matches)"] = "   ()"
	L["Automatic length"] = " "
	L["Backdrop Color"] = " "
	L["Backdrop in Front"] = " "
	L["Backdrop Style"] = " "
	L["Background Inner"] = "  (. .)"
	L["Background Offset"] = "  "
	L["Background Texture"] = "  "
	L["Bar Alpha"] = " "
	L["Bar Color Settings"] = "  "
	L["Big Icon"] = " "
	L["Blend Mode"] = " "
	L["Blue Rune"] = " "
	L["Blue Sparkle Orb"] = "  "
	L["Border %s"] = " %s"
	L["Border Anchor"] = " "
	L["Border Color"] = " "
	L["Border in Front"] = " "
	L["Border Inset"] = " "
	L["Border Offset"] = " "
	L["Border Settings"] = " "
	L["Border Size"] = " "
	L["Border Style"] = " "
	L["Bracket Matching"] = " "
	L["Browse Wago, the largest collection of auras."] = " Wago -     ."
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "      ,    .      , , , %2.p."
	L["Can be a UID (e.g., party1)."] = [=[   (UID, Unit ID).
: party4, raid7, arena3, boss2, nameplate6, target, focus, pet  .]=]
	L["Can set to 0 if Columns * Width equal File Width"] = "  0   ,        (. .         )"
	L["Can set to 0 if Rows * Height equal File Height"] = "  0   ,        (. .         )"
	L["Case Insensitive"] = "  "
	L["Cast by a Player Character"] = " "
	L["Categories to Update"] = "  "
	L["Changelog"] = " "
	L["Chat with WeakAuras experts on our Discord server."] = "   WeakAuras    Discord."
	L["Check On..."] = "..."
	L["Check out our wiki for a large collection of examples and snippets."] = "   -       ."
	L["Children:"] = ":"
	L["Choose"] = ""
	L["Circular Texture %s"] = "  %s"
	L["Clear Debug Logs"] = " "
	L["Clear Saved Data"] = " "
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	L["Clip Overlays"] = " "
	--[[Translation missing --]]
	L["Clipped by Foreground"] = "Clipped by Foreground"
	L["Close"] = ""
	L["Code Editor"] = " "
	L["Collapse"] = ""
	L["Collapse all loaded displays"] = "   "
	L["Collapse all non-loaded displays"] = "   "
	L["Collapse all pending Import"] = "  ,  "
	L["Collapsible Group"] = " "
	L["color"] = ""
	L["Column Height"] = " "
	L["Column Space"] = "  "
	L["Columns"] = ""
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = " COMBAT_LOG_EVENT_UNFILTERED         ."
	L["Combinations"] = ""
	L["Combine Matches Per Unit"] = "    "
	L["Common Text"] = "  "
	L["Compare against the number of units affected."] = "   ,    ."
	L["Compatibility Options"] = " "
	L["Compress"] = ""
	L["Configure what options appear on this panel."] = "   ,           ."
	L["Constant Factor"] = " "
	L["Control-click to select multiple displays"] = "Ctrl-    "
	L["Controls the positioning and configuration of multiple displays at the same time"] = "      "
	L["Convert to..."] = "  ..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "     .       ."
	L["Copy"] = ""
	L["Copy settings..."] = "   ..."
	L["Copy to all auras"] = "   "
	L["Could not parse '%s'. Expected a table."] = "    %s.  ."
	L["Counts the number of matches over all units."] = "      ."
	L["Counts the number of matches per unit."] = "      ."
	L["Create a Copy"] = " "
	L["Creating buttons: "] = " : "
	L["Creating options: "] = " : "
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = " -     Lua,     . %c1      , %c2     ."
	L["Custom Code"] = " "
	L["Custom Code Viewer"] = "  "
	L["Custom Frames"] = " "
	--[[Translation missing --]]
	L["Custom Functions"] = "Custom Functions"
	--[[Translation missing --]]
	L["Custom Init"] = "Custom Init"
	--[[Translation missing --]]
	L["Custom Load"] = "Custom Load"
	L["Custom Options"] = " "
	--[[Translation missing --]]
	L["Custom Text Update Throttle"] = "Custom Text Update Throttle"
	L["Custom Trigger"] = " "
	L["Custom trigger event tooltip"] = [=[ ,      .        .

|cFF4444FF:|r
UNIT_POWER  UNIT_AURA, PLAYER_TARGET_CHANGED]=]
	L["Custom trigger status tooltip"] = [=[ ,      .        .
   ,      WeakAuras   .

|cFF4444FF:|r
UNIT_POWER  UNIT_AURA, PLAYER_TARGET_CHANGED]=]
	--[[Translation missing --]]
	L["Custom trigger Update Throttle"] = "Custom trigger Update Throttle"
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = " :   Lua   OPTIONS"
	L["Custom Trigger: Send fake events instead of STATUS event"] = " :      STATUS"
	--[[Translation missing --]]
	L["Custom Unload"] = "Custom Unload"
	L["Custom Untrigger"] = " "
	L["Debug Log"] = " "
	L["Debug Log:"] = " :"
	L["Default"] = " "
	L["Default Color"] = "  "
	L["Delay"] = ""
	L["Delete"] = ""
	L["Delete all"] = " "
	L["Delete children and group"] = "   "
	L["Delete Entry"] = " "
	L["Deleting auras: "] = " : "
	L["Description Text"] = " "
	L["Determines how many entries can be in the table."] = ",      ."
	L["Differences"] = ""
	L["Disallow Entry Reordering"] = "   "
	L["Discord"] = "Discord"
	L["Display Name"] = " "
	L["Display Text"] = " "
	L["Displays a text, works best in combination with other displays"] = " ,        "
	L["Distribute Horizontally"] = "  "
	L["Distribute Vertically"] = "  "
	L["Do not group this display"] = "   "
	L["Do you want to enable updates for this aura"] = "    "
	L["Do you want to ignore updates for this aura"] = "    "
	L["Documentation"] = ""
	L["Done"] = ""
	L["Drag to move"] = "  "
	L["Duplicate"] = ""
	L["Duplicate All"] = " "
	L["Duration (s)"] = ""
	L["Duration Info"] = "  "
	L["Dynamic Duration"] = " "
	L["Dynamic Group"] = " "
	L["Dynamic Group Settings"] = "  "
	L["Dynamic Information"] = " "
	L["Dynamic information from first active trigger"] = "     "
	L["Dynamic information from Trigger %i"] = "    %i"
	L["Dynamic Text Replacements"] = "  "
	L["Ease Strength"] = "  "
	L["Ease type"] = "   "
	L["eliding"] = "   "
	L["Else If"] = " "
	L["Else If %s"] = ",  %s"
	--[[Translation missing --]]
	L["Empty Base Region"] = "Empty Base Region"
	L["Enable \"Edge\" part of the overlay"] = "   "
	L["Enable \"swipe\" part of the overlay"] = "   "
	L["Enable Debug Log"] = " "
	L["Enable Debug Logging"] = "   "
	L["Enable Gradient"] = " "
	L["Enable Swipe"] = " "
	L["Enable the \"Swipe\" radial overlay"] = "   "
	L["Enabled"] = ""
	L["End Angle"] = " "
	L["End of %s"] = "  \"%s\""
	L["Enemy nameplate(s) found"] = "  "
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = " ID .       idTip."
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = [=[  ,     ID .

 ID    ( )  ,         ,   ID.

       "ID "]=]
	L["Enter Author Mode"] = " "
	L["Enter in a value for the tick's placement."] = " ,   "
	L["Enter static or relative values with %"] = "       %"
	L["Enter User Mode"] = " "
	L["Enter user mode."] = "   ,      ,   ."
	L["Entry %i"] = " %i"
	L["Entry limit"] = " "
	L["Entry Name Source"] = "  "
	L["Event Type"] = " "
	L["Everything"] = " "
	L["Exact Item Match"] = " "
	L["Exact Spell Match"] = " "
	L["Expand"] = ""
	L["Expand all loaded displays"] = "   "
	L["Expand all non-loaded displays"] = "   "
	L["Expand all pending Import"] = "  ,  "
	L["Expansion is disabled because this group has no children"] = " ,       "
	L["Export debug table..."] = "     ..."
	L["Export..."] = " ..."
	L["Exporting"] = ""
	L["External"] = " "
	L["Extra Height"] = " "
	L["Extra Width"] = " "
	L["Fade"] = ""
	L["Fadeout Sound"] = " "
	L["Fadeout Time (seconds)"] = "  ( )"
	L["Fetch Affected/Unaffected Names and Units"] = "    .  . "
	L["Fetch Raid Mark Information"] = "    "
	L["Fetch Role Information"] = "    "
	L["Fetch Tooltip Information"] = "   "
	L["File Height"] = " "
	L["File Width"] = " "
	L["Filter based on the spell Name string."] = "     "
	L["Filter by Arena Spec"] = "    "
	L["Filter by Class"] = "  "
	L["Filter by Group Role"] = "   "
	L["Filter by Hostility"] = "  "
	L["Filter by Npc ID"] = "  ID NPC"
	L["Filter by Raid Role"] = "    "
	L["Filter by Specialization"] = "  "
	L["Filter by Unit Name"] = "   "
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[ : , - , - .

   ,  .     ,      \]=]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = "     ()    LibDispel"
	L["Find Auras"] = " "
	L["Finish"] = ""
	L["Finishing..."] = "..."
	L["Fire Orb"] = " "
	L["Flat Framelevels"] = "  "
	L["Foreground Texture"] = "  "
	L["Format for %s"] = " %s"
	L["Found a Bug?"] = " ?"
	L["Frame"] = ""
	L["Frame Count"] = " "
	L["Frame Height"] = " "
	L["Frame Rate"] = "  "
	L["Frame Strata"] = " "
	L["Frame Width"] = " "
	--[[Translation missing --]]
	L["Full Bar"] = "Full Bar"
	L["Full Circle"] = " "
	L["Global Conditions"] = " "
	L["Glow %s"] = " %s"
	L["Glow Action"] = ""
	L["Glow Anchor"] = " "
	L["Glow Color"] = ""
	L["Glow Frame Type"] = " "
	L["Glow Type"] = " "
	L["Green Rune"] = " "
	L["Grid direction"] = "  "
	L["Group (verb)"] = ""
	L["Group Alpha"] = " "
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = "      . -  :       . -  :        . -  : ,       ."
	L["Group aura count description"] = [=[    (|cFFE6CC80%s|r),          ,   .

    (10),   ,   ,     .

   (1/2)   (0.5) ,  (50%%),             .

|cFF4444FF:|r
|cFF00CC00> 0|r - ,      
|cFF00CC00= 100%%|r - ,      
|cFF00CC00!= 2|r - ,         2
|cFF00CC00<= 0.8|r - ,     80%%     (4  5, 7  10)
|cFF00CC00> 1/2|r - ,      (5  5, 6  10)]=]
	L["Group by Frame"] = "  "
	L["Group Description"] = " "
	L["Group Icon"] = " "
	L["Group key"] = " "
	L["Group Options"] = " "
	L["Group player(s) found"] = "   "
	L["Group Role"] = " "
	L["Group Scale"] = " "
	L["Group Settings"] = " "
	L["Hawk"] = ""
	L["Help"] = ""
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	L["Hide Background"] = "  "
	L["Hide Glows applied by this aura"] = " ,   "
	L["Hide on"] = " "
	L["Hide this group's children"] = "   "
	L["Highlights"] = " "
	L["Horizontal Align"] = "  "
	L["Horizontal Bar"] = " "
	L["Huge Icon"] = " "
	L["Hybrid Position"] = " "
	L["Hybrid Sort Mode"] = "  "
	L["Icon - The icon associated with the display"] = "  ,   "
	L["Icon Info"] = "  "
	L["Icon Inset"] = " "
	L["Icon Picker"] = "  "
	L["Icon Position"] = " "
	L["Icon Settings"] = " "
	L["Icon Source"] = " "
	L["If"] = ""
	L["If %s"] = " %s"
	L["If checked, then the combo box in the User settings will be sorted."] = "  ,       ."
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = "  ,       .        ."
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = "  ,            ."
	L["If checked, then this option group can be temporarily collapsed by the user."] = "  ,         ."
	L["If checked, then this option group will start collapsed."] = "  ,        ."
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = "  ,     ,   .   ,      ."
	L["If checked, then this space will span across multiple lines."] = "  ,       ."
	L["If unchecked, then a default color will be used (usually yellow)"] = "   ,       ()"
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = "   ,       ,    ."
	L["Ignore out of casting range"] = "     "
	L["Ignore out of checking range"] = "     "
	L["Ignore Wago updates"] = "  Wago"
	L["Ignored"] = " "
	L["Ignored Aura Name"] = "  "
	L["Ignored Exact Spell ID(s)"] = " ID "
	L["Ignored Name(s)"] = " "
	L["Ignored Spell ID"] = " ID "
	L["Import"] = ""
	L["Import / Export"] = " / "
	L["Import a display from an encoded string"] = "    "
	L["Import as Copy"] = ""
	L["Import has no UID, cannot be matched to existing auras."] = "     (UID).      ."
	L["Importing"] = ""
	L["Importing %s"] = " %s"
	L["Importing a group with %s child auras."] = "   %s |4::;."
	L["Importing a stand-alone aura."] = "  ."
	L["Importing...."] = " ..."
	L["Incompatible changes to group region types detected"] = "      ."
	L["Incompatible changes to group structure detected"] = "     ."
	L["Indent Size"] = " "
	L["Inner"] = ""
	L["Insert text replacement codes to make text dynamic."] = "   ,    ."
	L["Invalid Item ID"] = " ID"
	L["Invalid Item Name/ID/Link"] = " ,   ID"
	L["Invalid Spell ID"] = " ID"
	L["Invalid Spell Name/ID/Link"] = " ,   ID"
	L["Invalid target aura"] = "  "
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "   %s.  bool, number, select, string, timer  elapsedTimer."
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "   %s   %s.  %s."
	L["Inverse Slant"] = "  "
	L["Invert the direction of progress"] = "  "
	L["Is Boss Debuff"] = " "
	L["Is Stealable"] = "  "
	L["Is Unit"] = "  "
	L["Justify"] = ""
	L["Keep Aspect Ratio"] = " "
	L["Keep your Wago imports up to date with the Companion App."] = "    Wago       Companion."
	L["Large Input"] = "  "
	L["Leaf"] = ""
	L["Left 2 HUD position"] = " 2-  HUD"
	L["Left HUD position"] = "  HUD"
	L["Length of |cFFFF0000%s|r"] = " %s"
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = ""
	L["Line"] = ""
	L["Linear Texture %s"] = "  %s"
	L["Linked aura: "] = " : "
	--[[Translation missing --]]
	L["Linked Auras"] = "Linked Auras"
	L["Load"] = ""
	L["Loaded"] = ""
	L["Loaded/Standby"] = "/"
	L["Lock Positions"] = " "
	L["Low Mana"] = " "
	L["Magnetically Align"] = "  "
	L["Main"] = ""
	L["Manual with %i/%i"] = "  %i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = "         "
	L["Max"] = ". "
	L["Max Length"] = " "
	L["Maximum"] = ""
	L["Media Type"] = " "
	L["Medium Icon"] = " "
	L["Min"] = ". "
	L["Minimum"] = ""
	L["Model %s"] = " %s"
	L["Model Picker"] = "  "
	L["Model Settings"] = " "
	L["ModelPaths could not be loaded, the addon is %s"] = "   WeakAuras Model Paths.  - %s"
	L["Move Above Group"] = "  "
	L["Move Below Group"] = "  "
	L["Move Down"] = " "
	L["Move Entry Down"] = "  "
	L["Move Entry Up"] = "  "
	L["Move Into Above Group"] = "   "
	L["Move Into Below Group"] = "   "
	L["Move this display down in its group's order"] = "      "
	L["Move this display up in its group's order"] = "      "
	L["Move Up"] = " "
	L["Moving auras: "] = " : "
	L["Multiple Displays"] = " "
	L["Multiselect ignored tooltip"] = [=[
|cFFFF0000|r - |cFF777777|r - |cFF777777|r
     ,      (    )]=]
	L["Multiselect multiple tooltip"] = [=[
|cFF777777|r - |cFF777777|r - |cFF00FF00|r
     ]=]
	L["Multiselect single tooltip"] = [=[
|cFF777777|r - |cFF00FF00|r - |cFF777777|r
     ]=]
	L["Must be a power of 2"] = "     "
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = "    (  )  ID ,    "
	L["Name Info"] = "  "
	L["Name Pattern Match"] = "   "
	L["Name:"] = ""
	L["Negator"] = ""
	L["New Aura"] = " "
	L["New Template"] = " "
	L["New Value"] = " "
	L["No Children"] = " "
	L["No Logs saved."] = " "
	L["Not a table"] = " "
	L["Not all children have the same value for this option"] = "        "
	L["Not Loaded"] = " "
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = "|cFFFFCC00.|r   (instances)          ."
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = ":       /.  /     \"  \"."
	L["Number of Entries"] = " "
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = "  ,    .    .    ,    . : 2-, 5-  6- : 2, 5, 6; 2-  6-: 2-6;  2 : /2;  3 ,   2-: 2/3;  3 ,   2-   11-: 2-11/3."
	L["OFF"] = "."
	L["Offer a guided way to create auras for your character"] = "       "
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = ";  (%.4g, %.4g)"
	L["Offset by 1px"] = "  1 "
	L["Okay"] = ""
	L["ON"] = "."
	L["On Hide"] = " "
	L["On Show"] = " "
	L["Only Match auras cast by a player (not an npc)"] = "  - ,   NPC"
	L["Only match auras cast by people other than the player or their pet"] = ",   ,      "
	L["Only match auras cast by the player or their pet"] = ",      "
	L["Operator"] = ""
	L["Option %i"] = " %i"
	L["Option key"] = " "
	L["Option Type"] = " "
	L["Options will open after combat ends."] = "    ."
	L["or"] = ""
	L["or %s"] = " %s"
	L["Orange Rune"] = " "
	L["Our translators (too many to name)"] = "  ( ,  )"
	L["Outer"] = ""
	L["Overflow"] = ""
	L["Overlay %s Info"] = "   %s"
	L["Overlays"] = " "
	L["Own Only"] = " "
	L["Paste Action Settings"] = "  "
	L["Paste Animations Settings"] = "  "
	L["Paste Author Options Settings"] = "  "
	L["Paste Condition Settings"] = "  "
	L["Paste Custom Configuration"] = "  "
	L["Paste Display Settings"] = "  "
	L["Paste Group Settings"] = "  "
	L["Paste Load Settings"] = "  "
	L["Paste Settings"] = " "
	L["Paste text below"] = "  "
	L["Paste Trigger Settings"] = "  "
	L["Places a tick on the bar"] = "  ()  "
	L["Play Sound"] = " "
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	L["Portrait Zoom"] = " "
	L["Position and Size Settings"] = "   "
	L["Preferred Match"] = " "
	L["Premade Auras"] = " "
	L["Premade Snippets"] = "  "
	L["Preparing auras: "] = " : "
	L["Press Ctrl+C to copy"] = " Ctrl+C,  "
	L["Press Ctrl+C to copy the URL"] = " Ctrl+C,   URL-"
	L["Prevent Merging"] = "  "
	L["Progress - The remaining time of a timer, or a non-timer value"] = " -     ,    "
	L["Progress Bar"] = " "
	L["Progress Bar Settings"] = "  "
	L["Progress Settings"] = " "
	L["Progress Texture"] = " "
	L["Progress Texture Settings"] = "  "
	L["Purple Rune"] = " "
	L["Put this display in a group"] = "    "
	L["Range in yards"] = ""
	L["Ready for Install"] = "  "
	L["Ready for Update"] = "  "
	L["Re-center X"] = "  X"
	L["Re-center Y"] = "  Y"
	L["Reciprocal TRIGGER:# requests will be ignored!"] = " TRIGGER:#   !"
	--[[Translation missing --]]
	L["Redo"] = "Redo"
	L["Regions of type \"%s\" are not supported."] = "  \"%s\"  ."
	L["Remove"] = ""
	L["Remove All Sounds"] = "  "
	L["Remove All Text To Speech"] = "    "
	L["Remove this display from its group"] = "    "
	L["Remove this property"] = "  "
	L["Rename"] = ""
	L["Repeat After"] = " "
	L["Repeat every"] = " "
	L["Report bugs on our issue tracker."] = "     -."
	L["Require unit from trigger"] = "   "
	L["Required for Activation"] = "  "
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = " LibSpecialization, ..   WeakAuras"
	L["Reset all options to their default values."] = "     ,  ."
	L["Reset Entry"] = " "
	L["Reset to Defaults"] = " "
	L["Right 2 HUD position"] = " 2-  HUD"
	L["Right HUD position"] = "  HUD"
	L["Right-click for more options"] = ",    "
	L["Rotate"] = ""
	L["Rotate In"] = [=[ 
( )]=]
	L["Rotate Out"] = [=[ 
( )]=]
	L["Rotate Text"] = " "
	L["Rotation Mode"] = " "
	L["Row Space"] = "  "
	L["Row Width"] = " "
	L["Rows"] = ""
	L["Run on..."] = " ..."
	L["Same"] = " "
	L["Same texture as Foreground"] = "  ,     "
	L["Saved Data"] = " "
	--[[Translation missing --]]
	L["Scale Factor"] = "Scale Factor"
	L["Search API"] = "API "
	L["Select Talent"] = " "
	L["Select the auras you always want to be listed first"] = "    "
	L["Selected Frame"] = " "
	L["Send To"] = ""
	L["Separator Text"] = " "
	L["Separator text"] = " "
	L["Set Maximum Progress"] = "  "
	L["Set Minimum Progress"] = "  "
	L["Set Parent to Anchor"] = " "
	L["Set Thumbnail Icon"] = "  "
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = "        .      ,    "
	L["Settings"] = ""
	L["Shadow Color"] = " "
	L["Shadow X Offset"] = "   X"
	L["Shadow Y Offset"] = "   Y"
	L["Shift-click to create chat link"] = "Shift+    "
	L["Show \"Edge\""] = "  Edge"
	L["Show \"Swipe\""] = "  Swipe"
	L["Show and Clone Settings"] = "   "
	L["Show Border"] = " "
	L["Show Circular Texture"] = "  "
	L["Show Debug Logs"] = " "
	L["Show Glow"] = " "
	L["Show Icon"] = " "
	L["Show If Unit Does Not Exist"] = "   "
	L["Show Linear Texture"] = "  "
	L["Show Matches for"] = "   "
	L["Show Matches for Units"] = "   "
	L["Show Model"] = " "
	L["Show model of unit "] = "  "
	L["Show Sound Setting"] = "  "
	L["Show Spark"] = " "
	L["Show Stop Motion"] = " -"
	L["Show Text"] = " "
	L["Show Text To Speech Setting"] = "     "
	L["Show Texture"] = " "
	L["Show this group's children"] = "   "
	L["Show Tick"] = " "
	L["Shows a 3D model from the game files"] = " 3D    "
	L["Shows a border"] = " "
	--[[Translation missing --]]
	L["Shows a Circular Progress Texture"] = "Shows a Circular Progress Texture"
	L["Shows a custom texture"] = "  "
	L["Shows a glow"] = " "
	--[[Translation missing --]]
	L["Shows a Linear Progress Texture"] = "Shows a Linear Progress Texture"
	L["Shows a model"] = " 3D "
	L["Shows a progress bar with name, timer, and icon"] = "    ,   "
	L["Shows a spell icon with an optional cooldown overlay"] = "       ()"
	--[[Translation missing --]]
	L["Shows a Stop Motion"] = "Shows a Stop Motion"
	L["Shows a stop motion texture"] = "  ,     ,    "
	L["Shows a Texture"] = " "
	L["Shows a texture that changes based on duration"] = " ,     "
	--[[Translation missing --]]
	L["Shows nothing, except sub elements"] = "Shows nothing, except sub elements"
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = "     ,            "
	L["Size"] = ""
	L["Slant Amount"] = " "
	L["Slant Mode"] = " "
	L["Slanted"] = " "
	L["Slide"] = ""
	L["Slide In"] = ""
	L["Slide Out"] = ""
	L["Slider Step Size"] = "  "
	L["Small Icon"] = " "
	L["Smooth Progress"] = " "
	L["Snippets"] = " "
	L["Soft Max"] = ".  "
	L["Soft Min"] = ".  "
	L["Sort"] = ""
	L["Sound Channel"] = " "
	L["Sound File Path"] = "   "
	L["Sound Kit ID"] = "ID   (. ru.wowhead.com/sounds)"
	L["Space Horizontally"] = "  "
	L["Space Vertically"] = "  "
	L["Spark Settings"] = " "
	L["Spark Texture"] = " "
	L["Specific Currency ID"] = "ID "
	L["Spell Selection Filters"] = "  "
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = "  "
	L["Stacks - The number of stacks of an aura (usually)"] = " -    ()"
	L["Standby"] = ""
	L["Star"] = ""
	L["Start"] = ""
	L["Start Angle"] = " "
	L["Start Collapsed"] = ""
	L["Start of %s"] = "  \"%s\""
	L["Step Size"] = " "
	L["Stop Motion %s"] = "- %s"
	L["Stop Motion Settings"] = "  Stop motion"
	L["Stop Sound"] = "  "
	--[[Translation missing --]]
	L["Stretched by Foreground"] = "Stretched by Foreground"
	L["Sub Elements"] = " "
	L["Sub Option %i"] = "  %i"
	L["Subevent"] = ""
	L["Subevent Suffix"] = " "
	L["Swipe Overlay Settings"] = "  ()"
	L["Templates could not be loaded, the addon is %s"] = "   WeakAuras Templates.  - %s"
	L["Temporary Group"] = " "
	L["Text %s"] = " %s"
	L["Text Color"] = " "
	L["Text Settings"] = " "
	L["Texture %s"] = " %s"
	L["Texture Info"] = "  "
	L["Texture Selection Mode"] = "  "
	L["Texture Settings"] = " "
	L["Texture Wrap"] = " "
	L["Texture X Offset"] = "   X"
	L["Texture Y Offset"] = "   Y"
	L["Thanks"] = ""
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "  ElvUI.        .      ElvUI."
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "  OmniCC.        .      OmniCC."
	L["The duration of the animation in seconds."] = "   ."
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = [=[   .
    ,        (  ).]=]
	L["The group and all direct children will share the same base frame level."] = "               ."
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = "   .     ,   ,    ."
	L["The type of trigger"] = " "
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = " %s  WeakAuras Options    %s WeakAuras.       ,   World of Warcraft.      WeakAuras"
	L["Then "] = " "
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = "      . ,       ."
	L["This adds %raidMark as text replacements."] = "  %raidMark     ."
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = "  %role, %roleIcon     .   ,        ."
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = "  %tooltip, %tooltip1, %tooltip2, %tooltip3  %tooltip4     .          ."
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = [=[    Lua.
,     ,   !]=]
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "      '%s',        .   ,     ."
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "      '%s',       .   ,     ."
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = [=[      World of Warcraft (%s).
   !]=]
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[      WeakAuras.
   ,         WeakAuras.]=]
	L["This display is currently loaded"] = "  "
	L["This display is not currently loaded"] = "   "
	L["This display is on standby, it will be loaded when needed."] = "     ,     ."
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "   .   DebugPrint         ."
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "     |cFF9900FF%s|r"
	L["This is a modified version of your group: |cff9900FF%s|r"] = "      |cFF9900FF%s|r"
	L["This region of type \"%s\" is not supported."] = "  \"%s\"  ."
	L["This setting controls what widget is generated in user mode."] = " ,     ()       ."
	L["Thumbnail Icon"] = " "
	L["Tick %s"] = " %s"
	--[[Translation missing --]]
	L["Tick Area %s"] = "Tick Area %s"
	--[[Translation missing --]]
	L["Tick Center %s"] = "Tick Center %s"
	L["Tick Mode"] = " "
	L["Tick Placement"] = ""
	L["Time in"] = ""
	L["Tiny Icon"] = " "
	L["To Frame's"] = " "
	L["To Group's"] = " "
	L["To Personal Ressource Display's"] = "   "
	--[[Translation missing --]]
	L["To Region's"] = "To Region's"
	L["To Screen's"] = " "
	L["Toggle the visibility of all loaded displays"] = "    "
	L["Toggle the visibility of all non-loaded displays"] = "    "
	L["Toggle the visibility of this display"] = "   "
	L["Tooltip Content"] = " "
	L["Tooltip on Mouseover"] = "   "
	L["Tooltip Pattern Match"] = "   "
	L["Tooltip Text"] = " "
	L["Tooltip Value"] = "   "
	L["Tooltip Value #"] = " "
	L["Top HUD position"] = "  HUD"
	L["Total"] = ""
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = " -         "
	L["Total Angle"] = " "
	L["Total Time"] = " "
	L["Trigger %i: %s"] = " %i: %s"
	L["Trigger Combination"] = " "
	L["Type 'select' for '%s' requires a values member'"] = "  %s  select   values."
	--[[Translation missing --]]
	L["Undo"] = "Undo"
	L["Ungroup"] = ""
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "%s       RegisterUnitEvent"
	L["Unit Count"] = " "
	L["Unknown"] = ""
	--[[Translation missing --]]
	L["Unknown Encounter's Spell Id"] = "Unknown Encounter's Spell Id"
	L["Unknown property '%s' found in '%s'"] = "  %s   %s."
	L["Unknown Spell"] = " "
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = "      ,         ."
	L["Update"] = ""
	L["Update Auras"] = " "
	L["Update Custom Text On..."] = " ,    , "
	L["URL"] = "URL-"
	L["Url: %s"] = "URL-: %s"
	L["Use Display Info Id"] = " ID  "
	L["Use SetTransform"] = " . SetTransform"
	L["Used in Auras:"] = "  :"
	L["Used in auras:"] = "  :"
	L["Uses Texture Coordinates to rotate the texture."] = "     ."
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "  UnitIsVisible  ,        (  ).  ,      .   100 .    ."
	L["Value"] = ""
	L["Value %i"] = " %i"
	L["Values are in normalized rgba format."] = "     RGBA ( 0  1)."
	L["Values/Remaining Time above this value are displayed as full progress."] = "/        ."
	L["Values/Remaining Time below this value are displayed as zero progress."] = "/        ."
	L["Values:"] = ":"
	L["Version: "] = ": "
	L["Version: %s"] = ": %s"
	L["Vertical Align"] = "  "
	L["Vertical Bar"] = " "
	L["View"] = ""
	L["View custom code"] = " "
	--[[Translation missing --]]
	L["Voice Settings"] = "Voice Settings"
	L["We thank"] = " "
	L["WeakAuras %s on WoW %s"] = "WeakAuras: %s. : %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	L["What do you want to do?"] = "   ?"
	L["Whole Area"] = " "
	L["wrapping"] = "   "
	L["X Offset"] = "  X"
	L["X Rotation"] = "  X"
	L["X Scale"] = "  X"
	L["x-Offset"] = "  X"
	L["Y Offset"] = "  Y"
	L["Y Rotation"] = "  Y"
	L["Y Scale"] = "  Y"
	L["Yellow Rune"] = " "
	L["y-Offset"] = "  Y"
	L["You already have this group/aura. Importing will create a duplicate."] = "     .     ."
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = [=[   %d |4::;.
|cFFFF0000  !|r ?]=]
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = [=[   .
|cFFFF0000  !|r ?]=]
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "      ,  ,    WeakAuras    . WeakAuras     ,    ''   ,     ,   ."
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "      ,  ,    WeakAuras    . WeakAuras     ,    ''   ,     ,   ."
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "      ,  ,    WeakAuras    . WeakAuras     ,    ''   ,       ."
	L["Your Saved Snippets"] = "  "
	L["Z Offset"] = "  Z"
	L["Z Rotation"] = "  Z"
	L["Zoom In"] = ""
	L["Zoom Out"] = ""


=== END OF FILE: WeakAurasOptions/Locales/ruRU.lua ===


=== FILE: WeakAurasOptions/Locales/zhCN.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "zhCN" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = "|cFFFF0000|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- "
	L[" rotated |cFFFF0000%s|r degrees"] = "|cFFFF0000%s|r"
	L["% - To show a percent sign"] = "% - "
	L["% of Progress"] = "%"
	L["%d |4aura:auras; added"] = "%d"
	L["%d |4aura:auras; deleted"] = "%d"
	L["%d |4aura:auras; modified"] = "%d"
	L["%d |4aura:auras; with meta data modified"] = "%d"
	L["%d displays loaded"] = "%d"
	L["%d displays not loaded"] = "%d"
	L["%d displays on standby"] = "%d"
	L["%i auras selected"] = "%i"
	L["%i."] = "%i"
	L["%i. %s"] = "%i. %s"
	L["%s - %i. Trigger"] = "%s - %i. "
	L["%s - Alpha Animation"] = "%s - "
	L["%s - Color Animation"] = "%s - "
	L["%s - Condition Custom Chat %s"] = "%s -  %s"
	L["%s - Condition Custom Check %s"] = "%s -  %s"
	L["%s - Condition Custom Code %s"] = "%s -  %s"
	L["%s - Custom Anchor"] = "%s - "
	L["%s - Custom Grow"] = "%s - "
	L["%s - Custom Sort"] = "%s - "
	L["%s - Custom Text"] = "%s - "
	L["%s - Finish"] = "%s - "
	L["%s - Finish Action"] = "%s - "
	L["%s - Finish Custom Text"] = "%s - "
	L["%s - Init Action"] = "%s - "
	L["%s - Main"] = "%s - "
	L["%s - OnLoad"] = "%s - "
	L["%s - OnUnload"] = "%s - "
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s - #%i%s"
	L["%s - Rotate Animation"] = "%s - "
	L["%s - Scale Animation"] = "%s - "
	L["%s - Start"] = "%s - "
	L["%s - Start Action"] = "%s - "
	L["%s - Start Custom Text"] = "%s - "
	L["%s - Translate Animation"] = "%s - "
	L["%s - Trigger Logic"] = "%s - "
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s%d%0.2f%d%d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s%d%0.2f%0.2f"
	L["%s %u. Overlay Function"] = "%s %u. "
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s %d%%"
	L["%s Color"] = "%s "
	L["%s Custom Variables"] = "%s "
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s "
	L["%s Duration Function"] = "%s "
	L["%s Icon Function"] = "%s "
	L["%s Inset: %d%%"] = "%s %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s  COMBAT_LOG_EVENT_UNFILTERED "
	L["%s Keep Aspect Ratio"] = "%s "
	L["%s Name Function"] = "%s "
	L["%s Stacks Function"] = "%s "
	L["%s stores around %s KB of data"] = "%s%s KB"
	L["%s Texture"] = "%s "
	L["%s Texture Function"] = "%s "
	L["%s total auras"] = "%s"
	L["%s Trigger Function"] = "%s "
	L["%s Untrigger Function"] = "%s "
	L["%s X offset by %d"] = "%s X  %d"
	L["%s Y offset by %d"] = "%s Y  %d"
	L["%s Zoom: %d%%"] = "%s %d%%"
	L["%s, Border"] = "%s"
	L["%s, Offset: %0.2f;%0.2f"] = "%s%0.2f; %0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s%0.2f; %0.2f"
	L["%s, Start Animation"] = "%s"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000|r|cFFFF0000%s|r%s%s"
	L["(Right click to rename)"] = ""
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02x|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000|r'%s'"
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000|rURL"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000|rURL"
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000|r"
	L["|cFFFF0000default|r texture"] = "|cFFFF0000|r"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000|r"
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000|r '%s' "
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000|r'%s'CVar"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00|r|cFFFF0000%s|r|cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00|r|cFFFF0000%s|r|cFFFF0000%s|r|cFFFF0000%s/%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00|r|cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00|r|cFFFF0000%s|r|cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00|r%s  %s %s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00|r|cFFFF0000%s|r|c%s|r|cFFFF0000%s/%s|r%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00|r|cFFFF0000%s|r|c%s|r|cFFFF0000%s/%s|r%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cffffcc00|r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = [=[ |cff00ff00|r|cff00ff00|r|cff00ff00|r|cff00ff00|rID
 |cff00ff00|rID
|cffff0000|rID
 |cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|rID
 |cffffff00|r""""""""
 |cffffff00|rID
|cffff0000|rID

|cffffff00*|r]=]
	L["A 20x20 pixels icon"] = "20x20"
	L["A 32x32 pixels icon"] = "32x32"
	L["A 40x40 pixels icon"] = "40x40"
	L["A 48x48 pixels icon"] = "48x48"
	L["A 64x64 pixels icon"] = "64x64"
	L["A group that dynamically controls the positioning of its children"] = ""
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = "WeakAuras"
	L["A Unit ID (e.g., party1)."] = " ID party1"
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = ""
	L["Actual Spec"] = ""
	L["Add %s"] = " %s"
	L["Add a new display"] = ""
	L["Add Condition"] = ""
	L["Add Entry"] = ""
	L["Add Extra Elements"] = ""
	L["Add Option"] = ""
	L["Add Overlay"] = ""
	L["Add Property Change"] = ""
	L["Add Snippet"] = ""
	L["Add Sub Option"] = ""
	L["Add to group %s"] = "s"
	L["Add to new Dynamic Group"] = ""
	L["Add to new Group"] = ""
	L["Add Trigger"] = ""
	L["Additional Events"] = ""
	L["Advanced"] = ""
	L["Affected Unit Filters and Info"] = ""
	L["Align"] = ""
	L["Alignment"] = ""
	L["All maintainers of the libraries we use, especially:"] = ""
	L["All of"] = ""
	L["Allow Full Rotation"] = ""
	L["Anchor"] = ""
	L["Anchor Mode"] = ""
	L["Anchor Point"] = ""
	L["Anchored To"] = ""
	L["And "] = ""
	L["and"] = ""
	L["and %s"] = " %s"
	L["and aligned left"] = ""
	L["and aligned right"] = ""
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = " Patreon  Discord "
	L["and rotated left"] = ""
	L["and rotated right"] = ""
	L["and with width |cFFFF0000%s|r and %s"] = "|cFFFF0000%s|r %s"
	L["Angle"] = ""
	L["Angle Between Auras"] = ""
	L["Animate"] = ""
	L["Animated Expand and Collapse"] = ""
	L["Animates progress changes"] = ""
	L["Animation End"] = ""
	L["Animation Mode"] = ""
	L["Animation relative duration description"] = [=[ (1/2)(50)(0.5)
|cFFFF0000|r 
|cFF4444FF|r
 |cFF00CC0010%|r202
 |cFF00CC0010%|r.]=]
	L["Animation Sequence"] = ""
	L["Animation Start"] = ""
	L["Any of"] = ""
	L["Apply Template"] = ""
	L["Arcane Orb"] = ""
	L["Area"] = ""
	L["At a position a bit left of Left HUD position."] = "HUD"
	L["At a position a bit left of Right HUD position"] = "HUD"
	L["At the same position as Blizzard's spell alert"] = ""
	L["Attach to Foreground"] = ""
	L[ [=[Aura is
Off Screen]=] ] = ""
	L["Aura Name Pattern"] = ""
	L["Aura Order"] = ""
	L["Aura received from: %s"] = "%s"
	L["Aura: '%s'"] = "'%s'"
	L["Auto-Clone (Show All Matches)"] = ""
	L["Automatic length"] = ""
	L["Backdrop Color"] = ""
	L["Backdrop in Front"] = ""
	L["Backdrop Style"] = " "
	L["Background Inner"] = ""
	L["Background Offset"] = ""
	L["Background Texture"] = ""
	L["Bar Alpha"] = ""
	L["Bar Color Settings"] = ""
	L["Big Icon"] = ""
	L["Blend Mode"] = ""
	L["Blue Rune"] = ""
	L["Blue Sparkle Orb"] = ""
	L["Border %s"] = " %s"
	L["Border Anchor"] = ""
	L["Border Color"] = ""
	L["Border in Front"] = ""
	L["Border Inset"] = ""
	L["Border Offset"] = ""
	L["Border Settings"] = ""
	L["Border Size"] = " "
	L["Border Style"] = ""
	L["Bracket Matching"] = ""
	L["Browse Wago, the largest collection of auras."] = "Wago"
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = " %2.p "
	L["Can be a UID (e.g., party1)."] = " IDparty1"
	L["Can set to 0 if Columns * Width equal File Width"] = "x=0"
	L["Can set to 0 if Rows * Height equal File Height"] = "x=0"
	L["Case Insensitive"] = ""
	L["Cast by a Player Character"] = ""
	L["Categories to Update"] = ""
	L["Changelog"] = ""
	L["Chat with WeakAuras experts on our Discord server."] = "DiscordWeakAuras"
	L["Check On..."] = "..."
	L["Check out our wiki for a large collection of examples and snippets."] = "Wiki"
	L["Children:"] = ""
	L["Choose"] = ""
	L["Circular Texture %s"] = "%s"
	L["Clear Debug Logs"] = ""
	L["Clear Saved Data"] = ""
	--[[Translation missing --]]
	L["Click to replace the name with %s."] = "Click to replace the name with %s."
	L["Clip Overlays"] = ""
	L["Clipped by Foreground"] = ""
	L["Close"] = ""
	L["Code Editor"] = ""
	L["Collapse"] = ""
	L["Collapse all loaded displays"] = ""
	L["Collapse all non-loaded displays"] = ""
	L["Collapse all pending Import"] = ""
	L["Collapsible Group"] = ""
	L["color"] = ""
	L["Column Height"] = ""
	L["Column Space"] = ""
	L["Columns"] = ""
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = " COMBAT_LOG_EVENT_UNFILTERED "
	L["Combinations"] = ""
	L["Combine Matches Per Unit"] = ""
	L["Common Text"] = ""
	L["Compare against the number of units affected."] = ""
	L["Compatibility Options"] = ""
	L["Compress"] = ""
	L["Configure what options appear on this panel."] = ""
	L["Constant Factor"] = ""
	L["Control-click to select multiple displays"] = " Control "
	L["Controls the positioning and configuration of multiple displays at the same time"] = ""
	L["Convert to..."] = "..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "WoW"
	L["Copy"] = ""
	L["Copy settings..."] = ""
	L["Copy to all auras"] = ""
	L["Could not parse '%s'. Expected a table."] = "'%s' table"
	L["Counts the number of matches over all units."] = ""
	L["Counts the number of matches per unit."] = ""
	L["Create a Copy"] = ""
	L["Creating buttons: "] = ":"
	L["Creating options: "] = ":"
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = " -  Lua c1 c2 "
	L["Custom Code"] = ""
	L["Custom Code Viewer"] = ""
	L["Custom Frames"] = ""
	L["Custom Functions"] = ""
	L["Custom Init"] = ""
	L["Custom Load"] = ""
	L["Custom Options"] = ""
	--[[Translation missing --]]
	L["Custom Text Update Throttle"] = "Custom Text Update Throttle"
	L["Custom Trigger"] = ""
	L["Custom trigger event tooltip"] = [=[
 "UNIT"  unitID "nameplate", "group", "raid", "part", "arena"  "boss"
 "COMBAT_LOG_EVENT_UNFILTERED"  "CLEU"
  "TRIGGER" 

|cFF4444FF|r
UNIT_POWER_UPDATE:player, UNIT_AURA:nameplate:group PLAYER_TARGET_CHANGED CLEU:SPELL_CAST_SUCCESS TRIGGER:3:1

]=]
	L["Custom trigger status tooltip"] = [=[
,   WeakAuras , .
,

|cFF4444FF|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED]=]
	--[[Translation missing --]]
	L["Custom trigger Update Throttle"] = "Custom trigger Update Throttle"
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = " OPTIONS Lua"
	L["Custom Trigger: Send fake events instead of STATUS event"] = " STATUS "
	L["Custom Unload"] = ""
	L["Custom Untrigger"] = ""
	L["Debug Log"] = ""
	L["Debug Log:"] = ""
	L["Default"] = ""
	L["Default Color"] = ""
	L["Delay"] = ""
	L["Delete"] = ""
	L["Delete all"] = ""
	L["Delete children and group"] = ""
	L["Delete Entry"] = ""
	L["Deleting auras: "] = ""
	L["Description Text"] = ""
	L["Determines how many entries can be in the table."] = ""
	L["Differences"] = ""
	L["Disallow Entry Reordering"] = ""
	L["Discord"] = "Discord"
	L["Display Name"] = ""
	L["Display Text"] = ""
	L["Displays a text, works best in combination with other displays"] = ""
	L["Distribute Horizontally"] = ""
	L["Distribute Vertically"] = ""
	L["Do not group this display"] = ""
	L["Do you want to enable updates for this aura"] = ""
	L["Do you want to ignore updates for this aura"] = ""
	L["Documentation"] = ""
	L["Done"] = ""
	L["Drag to move"] = ""
	L["Duplicate"] = ""
	L["Duplicate All"] = ""
	L["Duration (s)"] = ""
	L["Duration Info"] = ""
	L["Dynamic Duration"] = ""
	L["Dynamic Group"] = ""
	L["Dynamic Group Settings"] = ""
	L["Dynamic Information"] = ""
	L["Dynamic information from first active trigger"] = ""
	L["Dynamic information from Trigger %i"] = "%i"
	L["Dynamic Text Replacements"] = ""
	L["Ease Strength"] = ""
	L["Ease type"] = ""
	L["eliding"] = ""
	L["Else If"] = ""
	L["Else If %s"] = " %s"
	L["Empty Base Region"] = ""
	L["Enable \"Edge\" part of the overlay"] = "\"\""
	L["Enable \"swipe\" part of the overlay"] = "\"\""
	L["Enable Debug Log"] = ""
	L["Enable Debug Logging"] = ""
	L["Enable Gradient"] = ""
	L["Enable Swipe"] = ""
	L["Enable the \"Swipe\" radial overlay"] = ""
	L["Enabled"] = ""
	L["End Angle"] = ""
	L["End of %s"] = "%s "
	L["Enemy nameplate(s) found"] = ""
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = " IDidTip ID"
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = " ID ID"
	L["Enter Author Mode"] = ""
	L["Enter in a value for the tick's placement."] = ""
	L["Enter static or relative values with %"] = "'%'"
	L["Enter User Mode"] = ""
	L["Enter user mode."] = ""
	L["Entry %i"] = " %i"
	L["Entry limit"] = ""
	L["Entry Name Source"] = ""
	L["Event Type"] = ""
	L["Everything"] = ""
	L["Exact Item Match"] = ""
	L["Exact Spell Match"] = ""
	L["Expand"] = ""
	L["Expand all loaded displays"] = ""
	L["Expand all non-loaded displays"] = ""
	L["Expand all pending Import"] = ""
	L["Expansion is disabled because this group has no children"] = ""
	L["Export debug table..."] = "..."
	L["Export..."] = "..."
	L["Exporting"] = ""
	L["External"] = ""
	L["Extra Height"] = ""
	L["Extra Width"] = ""
	L["Fade"] = ""
	L["Fadeout Sound"] = ""
	L["Fadeout Time (seconds)"] = ""
	L["Fetch Affected/Unaffected Names and Units"] = "/"
	L["Fetch Raid Mark Information"] = ""
	L["Fetch Role Information"] = ""
	L["Fetch Tooltip Information"] = ""
	L["File Height"] = ""
	L["File Width"] = ""
	L["Filter based on the spell Name string."] = ""
	L["Filter by Arena Spec"] = ""
	L["Filter by Class"] = ""
	L["Filter by Group Role"] = ""
	L["Filter by Hostility"] = ""
	L["Filter by Npc ID"] = "NPC ID"
	L["Filter by Raid Role"] = ""
	L["Filter by Specialization"] = ""
	L["Filter by Unit Name"] = ""
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=['''-''-'


 \  - ]=]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = "/ LibDispel"
	L["Find Auras"] = ""
	L["Finish"] = ""
	L["Finishing..."] = ""
	L["Fire Orb"] = ""
	L["Flat Framelevels"] = ""
	L["Foreground Texture"] = ""
	L["Format for %s"] = "%s "
	L["Found a Bug?"] = ""
	L["Frame"] = ""
	L["Frame Count"] = ""
	L["Frame Height"] = ""
	L["Frame Rate"] = ""
	L["Frame Strata"] = ""
	L["Frame Width"] = ""
	L["Full Bar"] = ""
	L["Full Circle"] = ""
	L["Global Conditions"] = ""
	L["Glow %s"] = " %s"
	L["Glow Action"] = ""
	L["Glow Anchor"] = ""
	L["Glow Color"] = ""
	L["Glow Frame Type"] = ""
	L["Glow Type"] = ""
	L["Green Rune"] = ""
	L["Grid direction"] = ""
	L["Group (verb)"] = ""
	L["Group Alpha"] = ""
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[

- 
- 
- ]=]
	L["Group aura count description"] = [=[
5
0.51/250%%
|cFF4444FF|r
|cFF00CC00 0|r  
|cFF00CC00 100%%|r 
|cFF00CC00 2|r 2
|cFF00CC00 0.8|r 80%%
|cFF00CC00 1/2|r 
|cFF00CC00 0|r ]=]
	L["Group by Frame"] = ""
	L["Group Description"] = ""
	L["Group Icon"] = ""
	L["Group key"] = ""
	L["Group Options"] = ""
	L["Group player(s) found"] = ""
	L["Group Role"] = ""
	L["Group Scale"] = ""
	L["Group Settings"] = ""
	L["Hawk"] = ""
	L["Help"] = ""
	--[[Translation missing --]]
	L["Hide After"] = "Hide After"
	L["Hide Background"] = ""
	L["Hide Glows applied by this aura"] = ""
	L["Hide on"] = ""
	L["Hide this group's children"] = ""
	L["Highlights"] = ""
	L["Horizontal Align"] = ""
	L["Horizontal Bar"] = ""
	L["Huge Icon"] = ""
	L["Hybrid Position"] = ""
	L["Hybrid Sort Mode"] = ""
	L["Icon - The icon associated with the display"] = " - "
	L["Icon Info"] = ""
	L["Icon Inset"] = ""
	L["Icon Picker"] = ""
	L["Icon Position"] = ""
	L["Icon Settings"] = ""
	L["Icon Source"] = ""
	L["If"] = ""
	L["If %s"] = " %s"
	L["If checked, then the combo box in the User settings will be sorted."] = ""
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = ""
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = ""
	L["If checked, then this option group can be temporarily collapsed by the user."] = ""
	L["If checked, then this option group will start collapsed."] = ""
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = ""
	L["If checked, then this space will span across multiple lines."] = ""
	L["If unchecked, then a default color will be used (usually yellow)"] = ""
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = ""
	L["Ignore out of casting range"] = ""
	L["Ignore out of checking range"] = ""
	L["Ignore Wago updates"] = "Wago"
	L["Ignored"] = ""
	L["Ignored Aura Name"] = ""
	L["Ignored Exact Spell ID(s)"] = " ID"
	L["Ignored Name(s)"] = ""
	L["Ignored Spell ID"] = " ID"
	L["Import"] = ""
	L["Import / Export"] = " / "
	L["Import a display from an encoded string"] = ""
	L["Import as Copy"] = ""
	L["Import has no UID, cannot be matched to existing auras."] = "UID"
	L["Importing"] = ""
	L["Importing %s"] = "%s"
	L["Importing a group with %s child auras."] = "%s"
	L["Importing a stand-alone aura."] = ""
	L["Importing...."] = "...."
	L["Incompatible changes to group region types detected"] = ""
	L["Incompatible changes to group structure detected"] = ""
	L["Indent Size"] = ""
	L["Inner"] = ""
	L["Insert text replacement codes to make text dynamic."] = ""
	L["Invalid Item ID"] = " ID"
	L["Invalid Item Name/ID/Link"] = "/ID/"
	L["Invalid Spell ID"] = " ID"
	L["Invalid Spell Name/ID/Link"] = "/ID/"
	L["Invalid target aura"] = ""
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "'%s''bool''number''select''string''timer''elapsedTimer'"
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = "'%2$s''%1$s''%3$s'"
	L["Inverse Slant"] = ""
	L["Invert the direction of progress"] = ""
	L["Is Boss Debuff"] = ""
	L["Is Stealable"] = ""
	L["Is Unit"] = ""
	L["Justify"] = ""
	L["Keep Aspect Ratio"] = ""
	L["Keep your Wago imports up to date with the Companion App."] = "CompanionWago"
	L["Large Input"] = ""
	L["Leaf"] = ""
	L["Left 2 HUD position"] = " HUD "
	L["Left HUD position"] = " HUD "
	L["Length of |cFFFF0000%s|r"] = "|cFFFF0000%s|r"
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = ""
	L["Line"] = ""
	L["Linear Texture %s"] = "%s"
	L["Linked aura: "] = ""
	L["Linked Auras"] = ""
	L["Load"] = ""
	L["Loaded"] = ""
	L["Loaded/Standby"] = "/"
	L["Lock Positions"] = ""
	L["Low Mana"] = ""
	L["Magnetically Align"] = ""
	L["Main"] = ""
	L["Manual with %i/%i"] = "%i/%i"
	--[[Translation missing --]]
	L["Matches %s spells"] = "Matches %s spells"
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = ""
	L["Max"] = ""
	L["Max Length"] = ""
	L["Maximum"] = ""
	L["Media Type"] = ""
	L["Medium Icon"] = ""
	L["Min"] = ""
	L["Minimum"] = ""
	L["Model %s"] = " %s"
	L["Model Picker"] = ""
	L["Model Settings"] = ""
	L["ModelPaths could not be loaded, the addon is %s"] = "Model Paths%s"
	L["Move Above Group"] = ""
	L["Move Below Group"] = ""
	L["Move Down"] = ""
	L["Move Entry Down"] = ""
	L["Move Entry Up"] = ""
	L["Move Into Above Group"] = ""
	L["Move Into Below Group"] = ""
	L["Move this display down in its group's order"] = ""
	L["Move this display up in its group's order"] = ""
	L["Move Up"] = ""
	L["Moving auras: "] = ""
	L["Multiple Displays"] = ""
	L["Multiselect ignored tooltip"] = [=[|cFFFF0000|r - |cFF777777|r - |cFF777777|r
]=]
	L["Multiselect multiple tooltip"] = [=[|cFFFF0000|r - |cFF777777|r - |cFF777777|r
]=]
	L["Multiselect single tooltip"] = [=[|cFFFF0000|r - |cFF777777|r - |cFF777777|r
]=]
	L["Must be a power of 2"] = "2"
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = " -  ID"
	L["Name Info"] = ""
	L["Name Pattern Match"] = ""
	L["Name:"] = ""
	L["Negator"] = ""
	L["New Aura"] = ""
	L["New Template"] = ""
	L["New Value"] = ""
	L["No Children"] = ""
	L["No Logs saved."] = ""
	L["Not a table"] = " table"
	L["Not all children have the same value for this option"] = ""
	L["Not Loaded"] = ""
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = ""
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "/"
	L["Number of Entries"] = ""
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[




2, 5, 6
2-6
/2
2/3
2-11/3]=]
	L["OFF"] = ""
	L["Offer a guided way to create auras for your character"] = ""
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = "|cFFFF0000%s|r/|cFFFF0000%s|r"
	L["Offset by 1px"] = "1px"
	L["Okay"] = ""
	L["ON"] = ""
	L["On Hide"] = ""
	L["On Show"] = ""
	L["Only Match auras cast by a player (not an npc)"] = "NPC"
	L["Only match auras cast by people other than the player or their pet"] = ""
	L["Only match auras cast by the player or their pet"] = ""
	L["Operator"] = ""
	L["Option %i"] = " %i"
	L["Option key"] = ""
	L["Option Type"] = ""
	L["Options will open after combat ends."] = ""
	L["or"] = ""
	L["or %s"] = " %s"
	L["Orange Rune"] = ""
	L["Our translators (too many to name)"] = ""
	L["Outer"] = ""
	L["Overflow"] = ""
	L["Overlay %s Info"] = " %s "
	L["Overlays"] = ""
	L["Own Only"] = ""
	L["Paste Action Settings"] = ""
	L["Paste Animations Settings"] = ""
	L["Paste Author Options Settings"] = ""
	L["Paste Condition Settings"] = ""
	L["Paste Custom Configuration"] = ""
	L["Paste Display Settings"] = ""
	L["Paste Group Settings"] = ""
	L["Paste Load Settings"] = ""
	L["Paste Settings"] = ""
	L["Paste text below"] = ""
	L["Paste Trigger Settings"] = ""
	L["Places a tick on the bar"] = ""
	L["Play Sound"] = ""
	--[[Translation missing --]]
	L["Player Spells found:"] = "Player Spells found:"
	L["Portrait Zoom"] = ""
	L["Position and Size Settings"] = ""
	L["Preferred Match"] = ""
	L["Premade Auras"] = ""
	L["Premade Snippets"] = ""
	L["Preparing auras: "] = ""
	L["Press Ctrl+C to copy"] = " Ctrl+C "
	L["Press Ctrl+C to copy the URL"] = " Ctrl+C  URL"
	L["Prevent Merging"] = ""
	L["Progress - The remaining time of a timer, or a non-timer value"] = " - "
	L["Progress Bar"] = ""
	L["Progress Bar Settings"] = ""
	L["Progress Settings"] = ""
	L["Progress Texture"] = ""
	L["Progress Texture Settings"] = ""
	L["Purple Rune"] = ""
	L["Put this display in a group"] = ""
	L["Range in yards"] = ""
	L["Ready for Install"] = ""
	L["Ready for Update"] = ""
	L["Re-center X"] = " X "
	L["Re-center Y"] = " Y "
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "TRIGGER:#"
	--[[Translation missing --]]
	L["Redo"] = "Redo"
	L["Regions of type \"%s\" are not supported."] = "%s "
	L["Remove"] = ""
	L["Remove All Sounds"] = ""
	L["Remove All Text To Speech"] = ""
	L["Remove this display from its group"] = ""
	L["Remove this property"] = ""
	L["Rename"] = ""
	L["Repeat After"] = ""
	L["Repeat every"] = ""
	L["Report bugs on our issue tracker."] = ""
	L["Require unit from trigger"] = ""
	L["Required for Activation"] = ""
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = "LibSpecializationWeakAuras"
	L["Reset all options to their default values."] = ""
	L["Reset Entry"] = ""
	L["Reset to Defaults"] = ""
	L["Right 2 HUD position"] = " HUD "
	L["Right HUD position"] = " HUD "
	L["Right-click for more options"] = ""
	L["Rotate"] = ""
	L["Rotate In"] = ""
	L["Rotate Out"] = ""
	L["Rotate Text"] = ""
	L["Rotation Mode"] = ""
	L["Row Space"] = ""
	L["Row Width"] = ""
	L["Rows"] = ""
	L["Run on..."] = "..."
	L["Same"] = ""
	L["Same texture as Foreground"] = ""
	L["Saved Data"] = ""
	L["Scale Factor"] = ""
	L["Search API"] = "API"
	L["Select Talent"] = ""
	L["Select the auras you always want to be listed first"] = ""
	L["Selected Frame"] = ""
	L["Send To"] = ""
	L["Separator Text"] = ""
	L["Separator text"] = ""
	L["Set Maximum Progress"] = ""
	L["Set Minimum Progress"] = ""
	L["Set Parent to Anchor"] = ""
	L["Set Thumbnail Icon"] = ""
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = ""
	L["Settings"] = ""
	L["Shadow Color"] = ""
	L["Shadow X Offset"] = " X "
	L["Shadow Y Offset"] = " Y "
	L["Shift-click to create chat link"] = " Shift "
	L["Show \"Edge\""] = "\"\""
	L["Show \"Swipe\""] = "\"\""
	L["Show and Clone Settings"] = ""
	L["Show Border"] = ""
	L["Show Circular Texture"] = ""
	L["Show Debug Logs"] = ""
	L["Show Glow"] = ""
	L["Show Icon"] = ""
	L["Show If Unit Does Not Exist"] = ""
	L["Show Linear Texture"] = ""
	L["Show Matches for"] = ""
	L["Show Matches for Units"] = ""
	L["Show Model"] = ""
	L["Show model of unit "] = ""
	L["Show Sound Setting"] = ""
	L["Show Spark"] = ""
	L["Show Stop Motion"] = ""
	L["Show Text"] = ""
	L["Show Text To Speech Setting"] = ""
	L["Show Texture"] = ""
	L["Show this group's children"] = ""
	L["Show Tick"] = ""
	L["Shows a 3D model from the game files"] = "3D"
	L["Shows a border"] = ""
	L["Shows a Circular Progress Texture"] = ""
	L["Shows a custom texture"] = ""
	L["Shows a glow"] = ""
	L["Shows a Linear Progress Texture"] = ""
	L["Shows a model"] = ""
	L["Shows a progress bar with name, timer, and icon"] = ""
	L["Shows a spell icon with an optional cooldown overlay"] = ""
	L["Shows a Stop Motion"] = ""
	L["Shows a stop motion texture"] = ""
	L["Shows a Texture"] = ""
	L["Shows a texture that changes based on duration"] = ""
	L["Shows nothing, except sub elements"] = ""
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = ""
	L["Size"] = ""
	L["Slant Amount"] = ""
	L["Slant Mode"] = ""
	L["Slanted"] = ""
	L["Slide"] = ""
	L["Slide In"] = ""
	L["Slide Out"] = ""
	L["Slider Step Size"] = ""
	L["Small Icon"] = ""
	L["Smooth Progress"] = ""
	L["Snippets"] = ""
	L["Soft Max"] = ""
	L["Soft Min"] = ""
	L["Sort"] = ""
	L["Sound Channel"] = ""
	L["Sound File Path"] = ""
	L["Sound Kit ID"] = " ID"
	L["Space Horizontally"] = ""
	L["Space Vertically"] = ""
	L["Spark Settings"] = ""
	L["Spark Texture"] = ""
	L["Specific Currency ID"] = "ID"
	L["Spell Selection Filters"] = ""
	--[[Translation missing --]]
	L["Spells found:"] = "Spells found:"
	L["Stack Info"] = ""
	L["Stacks - The number of stacks of an aura (usually)"] = " - "
	L["Standby"] = ""
	L["Star"] = ""
	L["Start"] = ""
	L["Start Angle"] = ""
	L["Start Collapsed"] = ""
	L["Start of %s"] = "%s "
	L["Step Size"] = ""
	L["Stop Motion %s"] = "%s"
	L["Stop Motion Settings"] = ""
	L["Stop Sound"] = ""
	--[[Translation missing --]]
	L["Stretched by Foreground"] = "Stretched by Foreground"
	L["Sub Elements"] = ""
	L["Sub Option %i"] = " %i"
	L["Subevent"] = ""
	L["Subevent Suffix"] = ""
	L["Swipe Overlay Settings"] = ""
	L["Templates could not be loaded, the addon is %s"] = "Templates%s"
	L["Temporary Group"] = ""
	L["Text %s"] = " %s"
	L["Text Color"] = ""
	L["Text Settings"] = ""
	L["Texture %s"] = "%s"
	L["Texture Info"] = ""
	L["Texture Selection Mode"] = ""
	L["Texture Settings"] = ""
	L["Texture Wrap"] = ""
	L["Texture X Offset"] = " X "
	L["Texture Y Offset"] = " Y "
	L["Thanks"] = ""
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "ElvUIElvUI"
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = "OmniCCOmniCC"
	L["The duration of the animation in seconds."] = ""
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = ""
	L["The group and all direct children will share the same base frame level."] = ""
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = ""
	L["The type of trigger"] = ""
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "WeakAuras  %s  WeakAuras  %s  WeakAuras"
	L["Then "] = ""
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = ""
	L["This adds %raidMark as text replacements."] = " %raidMark "
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = " %role, %roleIcon "
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = " %tooltip, %tooltip1, %tooltip2, %tooltip3, %tooltip4 /"
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = "Lua"
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = "%s"
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = "%s"
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = "%s"
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[WeakAuras
WeakAuras]=]
	L["This display is currently loaded"] = ""
	L["This display is not currently loaded"] = ""
	L["This display is on standby, it will be loaded when needed."] = ""
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = "DebugPrint"
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "|cff9900FF%s.|r"
	L["This is a modified version of your group: |cff9900FF%s|r"] = "|cff9900FF%s|r"
	L["This region of type \"%s\" is not supported."] = "\"%s\""
	L["This setting controls what widget is generated in user mode."] = ""
	L["Thumbnail Icon"] = ""
	L["Tick %s"] = " %s"
	L["Tick Area %s"] = "%s"
	L["Tick Center %s"] = "%s"
	L["Tick Mode"] = ""
	L["Tick Placement"] = ""
	L["Time in"] = ""
	L["Tiny Icon"] = ""
	L["To Frame's"] = ""
	L["To Group's"] = ""
	L["To Personal Ressource Display's"] = ""
	L["To Region's"] = ""
	L["To Screen's"] = ""
	L["Toggle the visibility of all loaded displays"] = ""
	L["Toggle the visibility of all non-loaded displays"] = ""
	L["Toggle the visibility of this display"] = ""
	L["Tooltip Content"] = ""
	L["Tooltip on Mouseover"] = ""
	L["Tooltip Pattern Match"] = ""
	L["Tooltip Text"] = ""
	L["Tooltip Value"] = ""
	L["Tooltip Value #"] = " #"
	L["Top HUD position"] = " HUD "
	L["Total"] = ""
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = " - "
	L["Total Angle"] = ""
	L["Total Time"] = ""
	L["Trigger %i: %s"] = "%i%s"
	L["Trigger Combination"] = ""
	L["Type 'select' for '%s' requires a values member'"] = "'%s''select''values'"
	--[[Translation missing --]]
	L["Undo"] = "Undo"
	L["Ungroup"] = ""
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = " %s  RegisterUnitEvent "
	L["Unit Count"] = ""
	L["Unknown"] = ""
	L["Unknown Encounter's Spell Id"] = "Id"
	L["Unknown property '%s' found in '%s'"] = "'%2$s''%1$s'"
	L["Unknown Spell"] = ""
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = ""
	L["Update"] = ""
	L["Update Auras"] = ""
	L["Update Custom Text On..."] = ""
	L["URL"] = "URL"
	L["Url: %s"] = "URL%s"
	L["Use Display Info Id"] = " ID"
	L["Use SetTransform"] = " SetTransform "
	L["Used in Auras:"] = ""
	L["Used in auras:"] = ""
	L["Uses Texture Coordinates to rotate the texture."] = ""
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = "UnitIsVisible()100"
	L["Value"] = ""
	L["Value %i"] = " %i"
	L["Values are in normalized rgba format."] = " RGBA "
	L["Values/Remaining Time above this value are displayed as full progress."] = "/"
	L["Values/Remaining Time below this value are displayed as zero progress."] = "/"
	L["Values:"] = ""
	L["Version: "] = ""
	L["Version: %s"] = "%s"
	L["Vertical Align"] = ""
	L["Vertical Bar"] = ""
	L["View"] = ""
	L["View custom code"] = ""
	--[[Translation missing --]]
	L["Voice Settings"] = "Voice Settings"
	L["We thank"] = ""
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s + WoW %s"
	--[[Translation missing --]]
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."
	L["What do you want to do?"] = ""
	L["Whole Area"] = ""
	L["wrapping"] = ""
	L["X Offset"] = "X "
	L["X Rotation"] = "X"
	L["X Scale"] = ""
	L["x-Offset"] = "X"
	L["Y Offset"] = "Y "
	L["Y Rotation"] = "Y"
	L["Y Scale"] = ""
	L["Yellow Rune"] = ""
	L["y-Offset"] = "Y"
	L["You already have this group/aura. Importing will create a duplicate."] = "/"
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = " %d |cFFFF0000|r?"
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = "|cFFFF0000|r"
	--[[Translation missing --]]
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[WeakAuras 

 'changed'WeakAuras ]=]
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = [=[WeakAuras 

 'changed'WeakAuras ]=]
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = [=[WeakAuras 

 'changed'WeakAuras ]=]
	L["Your Saved Snippets"] = ""
	L["Z Offset"] = "Z "
	L["Z Rotation"] = "Z"
	L["Zoom In"] = ""
	L["Zoom Out"] = ""


=== END OF FILE: WeakAurasOptions/Locales/zhCN.lua ===


=== FILE: WeakAurasOptions/Locales/zhTW.lua ===
if not WeakAuras.IsLibsOK() then return end

if (GAME_LOCALE or GetLocale()) ~= "zhTW" then
  return
end

local L = WeakAuras.L

-- WeakAuras/Options
	L[" and |cFFFF0000mirrored|r"] = " |cFFFF0000|r"
	L["-- Do not remove this comment, it is part of this aura: "] = "-- : "
	L[" rotated |cFFFF0000%s|r degrees"] = " |cFFFF0000%s|r "
	L["% - To show a percent sign"] = "% - "
	L["% of Progress"] = "%"
	L["%d |4aura:auras; added"] = "%d ; "
	L["%d |4aura:auras; deleted"] = "%d ; "
	L["%d |4aura:auras; modified"] = "%d ; "
	L["%d |4aura:auras; with meta data modified"] = "%d |4aura:auras; "
	L["%d displays loaded"] = "%d "
	L["%d displays not loaded"] = "%d "
	L["%d displays on standby"] = "%d "
	L["%i auras selected"] = " %i "
	L["%i."] = "%i"
	L["%i. %s"] = "%i%s"
	L["%s - %i. Trigger"] = "%s - %i. "
	L["%s - Alpha Animation"] = "%s - "
	L["%s - Color Animation"] = "%s - "
	L["%s - Condition Custom Chat %s"] = "%s -  %s"
	L["%s - Condition Custom Check %s"] = "%s -  %s"
	L["%s - Condition Custom Code %s"] = "%s -  %s"
	L["%s - Custom Anchor"] = "%s - "
	L["%s - Custom Grow"] = "%s - "
	L["%s - Custom Sort"] = "%s - "
	L["%s - Custom Text"] = "%s - "
	L["%s - Finish"] = "%s - "
	L["%s - Finish Action"] = "%s - "
	L["%s - Finish Custom Text"] = "%s - "
	L["%s - Init Action"] = "%s - "
	L["%s - Main"] = "%s - "
	L["%s - OnLoad"] = "%s - OnLoad"
	L["%s - OnUnload"] = "%s - OnUnload"
	L["%s - Option #%i has the key %s. Please choose a different option key."] = "%s -  #%i  key %s key"
	L["%s - Rotate Animation"] = "%s - "
	L["%s - Scale Animation"] = "%s - "
	L["%s - Start"] = "%s - "
	L["%s - Start Action"] = "%s - "
	L["%s - Start Custom Text"] = "%s - "
	L["%s - Translate Animation"] = "%s - "
	L["%s - Trigger Logic"] = "%s - "
	L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"] = "%s %s, : %d, : %0.2f, : %d, : %d"
	L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"] = "%s %s, : %d, : %0.2f, : %0.2f"
	L["%s %u. Overlay Function"] = "%s %u"
	L["%s (%s)"] = "%s (%s)"
	L["%s Alpha: %d%%"] = "%s: %d%%"
	L["%s Color"] = "%s "
	L["%s Custom Variables"] = "%s "
	L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"] = "%s, , , "
	L["%s Duration Function"] = "%s "
	L["%s Icon Function"] = "%s "
	L["%s Inset: %d%%"] = "%s: %d%%"
	L["%s is not a valid SubEvent for COMBAT_LOG_EVENT_UNFILTERED"] = "%s  COMBAT_LOG_EVENT_UNFILTERED  SubEvent"
	L["%s Keep Aspect Ratio"] = "%s"
	L["%s Name Function"] = "%s "
	L["%s Stacks Function"] = "%s "
	L["%s stores around %s KB of data"] = "%s  %s KB "
	L["%s Texture"] = "%s "
	L["%s Texture Function"] = "%s "
	L["%s total auras"] = " %s "
	L["%s Trigger Function"] = "%s "
	L["%s Untrigger Function"] = "%s "
	L["%s X offset by %d"] = "%s  %d"
	L["%s Y offset by %d"] = "%s  %d"
	L["%s Zoom: %d%%"] = "%s: %d%%"
	L["%s, Border"] = "%s, "
	L["%s, Offset: %0.2f;%0.2f"] = "%s, : %0.2f;%0.2f"
	L["%s, offset: %0.2f;%0.2f"] = "%s, : %0.2f;%0.2f"
	L["%s, Start Animation"] = "%s"
	L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"] = "%s|cFFFF0000|r|cFFFF0000%s|r%s%s"
	L["(Right click to rename)"] = "()"
	L["|c%02x%02x%02x%02xCustom Color|r"] = "|c%02x%02x%02x%02x|r"
	L["|cff999999Triggers tracking multiple units will default to being active even while no affected units are found without a Unit Count or Match Count setting applied.|r"] = "|cff999999|r"
	L["|cFFE0E000Note:|r This sets the description only on '%s'"] = "|cFFE0E000:|r  '%s' "
	L["|cFFE0E000Note:|r This sets the URL on all selected auras"] = "|cFFE0E000:|r  URL"
	L["|cFFE0E000Note:|r This sets the URL on this group and all its members."] = "|cFFE0E000:|r  URL"
	L["|cFFFF0000Automatic|r length"] = "|cFFFF0000|r"
	L["|cFFFF0000default|r texture"] = "|cFFFF0000|r"
	L["|cFFFF0000desaturated|r "] = "|cFFFF0000|r "
	L["|cFFFF0000Note:|r The unit '%s' is not a trackable unit."] = "|cFFFF0000:|r  '%s' "
	L["|cFFFF0000Note:|r The unit '%s' requires soft target cvars to be enabled."] = "|cFFFF0000:|r  '%s'  CVar "
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"] = "|cFFffcc00:|r |cFFFF0000%s|r|cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00:|r |cFFFF0000%s|r|cFFFF0000%s|r|cFFFF0000%s/%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"] = "|cFFffcc00:|r |cFFFF0000%s|r"
	L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"] = "|cFFffcc00:|r |cFFFF0000%s|r|cFFFF0000%s/%s|r"
	L["|cFFffcc00Extra Options:|r"] = "|cFFffcc00:|r"
	L["|cFFffcc00Extra:|r %s and %s %s"] = "|cFFffcc00:|r %s%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"] = "|cFFffcc00:|r |cFFFF0000%s|r|c%s|r|cFFFF0000%s/%s|r%s%s"
	L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"] = "|cFFffcc00:|r |cFFFF0000%s|r|c%s|r|cFFFF0000%s/%s|r%s%s%s"
	L["|cffffcc00Format Options|r"] = "|cffffcc00|r"
	L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.
 |cffffff00Multi-target|r attempts to use the Combat Log events, rather than unitID, to track affected units.
|cffff0000Note|r: Without a direct relationship to actual unitIDs, results may vary.

|cffffff00*|r Yellow Unit settings can match multiple units and will default to being active even while no affected units are found without a Unit Count or Match Count setting.]=] ] = "|cff00ff00|r|cff00ff00|r|cff00ff00|r|cff00ff00|rID |cff00ff00|rID|cffff0000|rID|cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|rID|cffffff00|r |cffffff00rIDcffff0000|rID |cffffff00*|r"
	L["A 20x20 pixels icon"] = "20x20 "
	L["A 32x32 pixels icon"] = "32x32 "
	L["A 40x40 pixels icon"] = "40x40 "
	L["A 48x48 pixels icon"] = "48x48 "
	L["A 64x64 pixels icon"] = "64x64 "
	L["A group that dynamically controls the positioning of its children"] = ""
	L[ [=[A timer will automatically be displayed according to default Interface Settings (overridden by some addons).
Enable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer]=] ] = " ()  WeakAuras  "
	L["A Unit ID (e.g., party1)."] = " ID ( party1)"
	L["Ace: Funkeh, Nevcairiel"] = "Ace: Funkeh, Nevcairiel"
	L["Active Aura Filters and Info"] = ""
	L["Actual Spec"] = ""
	L["Add %s"] = "%s"
	L["Add a new display"] = ""
	L["Add Condition"] = ""
	L["Add Entry"] = ""
	L["Add Extra Elements"] = ""
	L["Add Option"] = ""
	L["Add Overlay"] = ""
	L["Add Property Change"] = ""
	L["Add Snippet"] = ""
	L["Add Sub Option"] = ""
	L["Add to group %s"] = " %s"
	L["Add to new Dynamic Group"] = ""
	L["Add to new Group"] = ""
	L["Add Trigger"] = ""
	L["Additional Events"] = ""
	L["Advanced"] = ""
	L["Affected Unit Filters and Info"] = ""
	L["Align"] = ""
	L["Alignment"] = ""
	L["All maintainers of the libraries we use, especially:"] = ""
	L["All of"] = ""
	L["Allow Full Rotation"] = ""
	L["Anchor"] = ""
	L["Anchor Mode"] = ""
	L["Anchor Point"] = ""
	L["Anchored To"] = ""
	L["And "] = " "
	L["and"] = ""
	L["and %s"] = " %s"
	L["and aligned left"] = ""
	L["and aligned right"] = ""
	L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] = "Discord"
	L["and rotated left"] = ""
	L["and rotated right"] = ""
	L["and with width |cFFFF0000%s|r and %s"] = " |cFFFF0000%s|r  %s"
	L["Angle"] = ""
	L["Angle Between Auras"] = ""
	L["Animate"] = ""
	L["Animated Expand and Collapse"] = ""
	L["Animates progress changes"] = ""
	L["Animation End"] = ""
	L["Animation Mode"] = ""
	L["Animation relative duration description"] = [=[ (1/2) (50%)  (0.5) 
|cFFFF0000:|r  (...)

|cFF4444FF:|r
 |cFF00CC0010%|r 20  2 
 |cFF00CC0010%|r ()]=]
	L["Animation Sequence"] = ""
	L["Animation Start"] = ""
	L["Any of"] = ""
	L["Apply Template"] = ""
	L["Arcane Orb"] = ""
	L["Area"] = ""
	L["At a position a bit left of Left HUD position."] = " HUD "
	L["At a position a bit left of Right HUD position"] = " HUD "
	L["At the same position as Blizzard's spell alert"] = ""
	L["Attach to Foreground"] = ""
	L[ [=[Aura is
Off Screen]=] ] = [=[
]=]
	L["Aura Name Pattern"] = " (Pattern)"
	L["Aura Order"] = ""
	L["Aura received from: %s"] = ": %s"
	L["Aura: '%s'"] = ": '%s'"
	L["Auto-Clone (Show All Matches)"] = " ()"
	L["Automatic length"] = ""
	L["Backdrop Color"] = ""
	L["Backdrop in Front"] = ""
	L["Backdrop Style"] = ""
	L["Background Inner"] = ""
	L["Background Offset"] = ""
	L["Background Texture"] = ""
	L["Bar Alpha"] = ""
	L["Bar Color Settings"] = ""
	L["Big Icon"] = ""
	L["Blend Mode"] = ""
	L["Blue Rune"] = ""
	L["Blue Sparkle Orb"] = ""
	L["Border %s"] = " %s"
	L["Border Anchor"] = ""
	L["Border Color"] = ""
	L["Border in Front"] = ""
	L["Border Inset"] = ""
	L["Border Offset"] = ""
	L["Border Settings"] = ""
	L["Border Size"] = ""
	L["Border Style"] = ""
	L["Bracket Matching"] = ""
	L["Browse Wago, the largest collection of auras."] = " Wago "
	L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."] = "%2.p"
	L["Can be a UID (e.g., party1)."] = " ID ( party1) "
	L["Can set to 0 if Columns * Width equal File Width"] = "0*"
	L["Can set to 0 if Rows * Height equal File Height"] = "0*"
	L["Case Insensitive"] = ""
	L["Cast by a Player Character"] = ""
	L["Categories to Update"] = ""
	L["Changelog"] = ""
	L["Chat with WeakAuras experts on our Discord server."] = " Discord  WeakAuras "
	L["Check On..."] = "..."
	L["Check out our wiki for a large collection of examples and snippets."] = " wiki"
	L["Children:"] = ":"
	L["Choose"] = ""
	L["Circular Texture %s"] = " %s"
	L["Clear Debug Logs"] = ""
	L["Clear Saved Data"] = ""
	L["Click to replace the name with %s."] = " %s"
	L["Clip Overlays"] = ""
	L["Clipped by Foreground"] = ""
	L["Close"] = ""
	L["Code Editor"] = ""
	L["Collapse"] = ""
	L["Collapse all loaded displays"] = ""
	L["Collapse all non-loaded displays"] = ""
	L["Collapse all pending Import"] = ""
	L["Collapsible Group"] = ""
	L["color"] = ""
	L["Column Height"] = ""
	L["Column Space"] = ""
	L["Columns"] = ""
	L["COMBAT_LOG_EVENT_UNFILTERED with no filter can trigger frame drops in raid environment."] = " COMBAT_LOG_EVENT_UNFILTERED "
	L["Combinations"] = ""
	L["Combine Matches Per Unit"] = ""
	L["Common Text"] = ""
	L["Compare against the number of units affected."] = ""
	L["Compatibility Options"] = ""
	L["Compress"] = ""
	L["Configure what options appear on this panel."] = ""
	L["Constant Factor"] = ""
	L["Control-click to select multiple displays"] = " Ctrl "
	L["Controls the positioning and configuration of multiple displays at the same time"] = ""
	L["Convert to..."] = "..."
	L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."] = "WoW "
	L["Copy"] = ""
	L["Copy settings..."] = "..."
	L["Copy to all auras"] = ""
	L["Could not parse '%s'. Expected a table."] = " '%s' table"
	L["Counts the number of matches over all units."] = ""
	L["Counts the number of matches per unit."] = ""
	L["Create a Copy"] = ""
	L["Creating buttons: "] = ": "
	L["Creating options: "] = ": "
	L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."] = " -  Lua %c1 %c2 "
	L["Custom Code"] = ""
	L["Custom Code Viewer"] = ""
	L["Custom Frames"] = ""
	L["Custom Functions"] = ""
	L["Custom Init"] = ""
	L["Custom Load"] = ""
	L["Custom Options"] = ""
	L["Custom Text Update Throttle"] = ""
	L["Custom Trigger"] = ""
	L["Custom trigger event tooltip"] = [=[


|cFF4444FF:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED]=]
	L["Custom trigger status tooltip"] = [=[
 WeakAuras 


|cFF4444FF:|r
UNIT_POWER, UNIT_AURA PLAYER_TARGET_CHANGED]=]
	L["Custom trigger Update Throttle"] = ""
	L["Custom Trigger: Ignore Lua Errors on OPTIONS event"] = ":  OPTIONS  Lua "
	L["Custom Trigger: Send fake events instead of STATUS event"] = ":  STATUS "
	L["Custom Unload"] = ""
	L["Custom Untrigger"] = ""
	L["Debug Log"] = ""
	L["Debug Log:"] = ""
	L["Default"] = ""
	L["Default Color"] = ""
	L["Delay"] = ""
	L["Delete"] = ""
	L["Delete all"] = ""
	L["Delete children and group"] = ""
	L["Delete Entry"] = ""
	L["Deleting auras: "] = ": "
	L["Description Text"] = ""
	L["Determines how many entries can be in the table."] = ""
	L["Differences"] = ""
	L["Disallow Entry Reordering"] = ""
	L["Discord"] = "Discord"
	L["Display Name"] = ""
	L["Display Text"] = ""
	L["Displays a text, works best in combination with other displays"] = ""
	L["Distribute Horizontally"] = ""
	L["Distribute Vertically"] = ""
	L["Do not group this display"] = ""
	L["Do you want to enable updates for this aura"] = ""
	L["Do you want to ignore updates for this aura"] = ""
	L["Documentation"] = ""
	L["Done"] = ""
	L["Drag to move"] = ""
	L["Duplicate"] = ""
	L["Duplicate All"] = ""
	L["Duration (s)"] = " ()"
	L["Duration Info"] = ""
	L["Dynamic Duration"] = ""
	L["Dynamic Group"] = ""
	L["Dynamic Group Settings"] = ""
	L["Dynamic Information"] = ""
	L["Dynamic information from first active trigger"] = ""
	L["Dynamic information from Trigger %i"] = " %i "
	L["Dynamic Text Replacements"] = ""
	L["Ease Strength"] = ""
	L["Ease type"] = ""
	L["eliding"] = ""
	L["Else If"] = "(Else If) "
	L["Else If %s"] = " %s"
	L["Empty Base Region"] = ""
	L["Enable \"Edge\" part of the overlay"] = " \"\" "
	L["Enable \"swipe\" part of the overlay"] = " \"\" "
	L["Enable Debug Log"] = ""
	L["Enable Debug Logging"] = ""
	L["Enable Gradient"] = ""
	L["Enable Swipe"] = ""
	L["Enable the \"Swipe\" radial overlay"] = " \"\" "
	L["Enabled"] = ""
	L["End Angle"] = ""
	L["End of %s"] = "%s "
	L["Enemy nameplate(s) found"] = ""
	L["Enter a Spell ID. You can use the addon idTip to determine spell ids."] = "ID idTip ID"
	L["Enter an Aura Name, partial Aura Name, or Spell ID. A Spell ID will match any spells with the same name."] = " ID ID "
	L["Enter Author Mode"] = ""
	L["Enter in a value for the tick's placement."] = ""
	L["Enter static or relative values with %"] = " %"
	L["Enter User Mode"] = ""
	L["Enter user mode."] = ""
	L["Entry %i"] = " %i"
	L["Entry limit"] = ""
	L["Entry Name Source"] = ""
	L["Event Type"] = ""
	L["Everything"] = ""
	L["Exact Item Match"] = ""
	L["Exact Spell Match"] = ""
	L["Expand"] = ""
	L["Expand all loaded displays"] = ""
	L["Expand all non-loaded displays"] = ""
	L["Expand all pending Import"] = ""
	L["Expansion is disabled because this group has no children"] = ""
	L["Export debug table..."] = "..."
	L["Export..."] = "..."
	L["Exporting"] = ""
	L["External"] = ""
	L["Extra Height"] = ""
	L["Extra Width"] = ""
	L["Fade"] = ""
	L["Fadeout Sound"] = ""
	L["Fadeout Time (seconds)"] = " ()"
	L["Fetch Affected/Unaffected Names and Units"] = "/"
	L["Fetch Raid Mark Information"] = ""
	L["Fetch Role Information"] = ""
	L["Fetch Tooltip Information"] = ""
	L["File Height"] = ""
	L["File Width"] = ""
	L["Filter based on the spell Name string."] = ""
	L["Filter by Arena Spec"] = ""
	L["Filter by Class"] = ""
	L["Filter by Group Role"] = ""
	L["Filter by Hostility"] = ""
	L["Filter by Npc ID"] = " NPC ID "
	L["Filter by Raid Role"] = ""
	L["Filter by Specialization"] = ""
	L["Filter by Unit Name"] = ""
	L[ [=[Filter formats: 'Name', 'Name-Realm', '-Realm'.

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[: '''-''-'


 -  \]=]
	L[ [=[Filter to only dispellable de/buffs of the given type(s)
Bleed classification via LibDispel]=] ] = " LibDispel /"
	L["Find Auras"] = ""
	L["Finish"] = ""
	L["Finishing..."] = "..."
	L["Fire Orb"] = ""
	L["Flat Framelevels"] = ""
	L["Foreground Texture"] = ""
	L["Format for %s"] = "%s "
	L["Found a Bug?"] = " Bug?"
	L["Frame"] = ""
	L["Frame Count"] = ""
	L["Frame Height"] = ""
	L["Frame Rate"] = ""
	L["Frame Strata"] = ""
	L["Frame Width"] = ""
	L["Full Bar"] = ""
	L["Full Circle"] = ""
	L["Global Conditions"] = ""
	L["Glow %s"] = " %s"
	L["Glow Action"] = ""
	L["Glow Anchor"] = ""
	L["Glow Color"] = ""
	L["Glow Frame Type"] = ""
	L["Glow Type"] = ""
	L["Green Rune"] = ""
	L["Grid direction"] = ""
	L["Group (verb)"] = ""
	L["Group Alpha"] = ""
	L[ [=[Group and anchor each auras by frame.

- Nameplates: attach to nameplates per unit.
- Unit Frames: attach to unit frame buttons per unit.
- Custom Frames: choose which frame each region should be anchored to.]=] ] = [=[
- : 
- : 
- ]=]
	L["Group aura count description"] = [=[ %s 
 ( 5)
 ( 0.5) ( 1/2)  ( 50%%) %s 

|cFF4444FF:|r
|cFF00CC00> 0|r  %s 
|cFF00CC00= 100%%|r  %s 
|cFF00CC00!= 2|r  %s  2 
|cFF00CC00<= 0.8|r  %s  80%%  (541082520)
|cFF00CC00> 1/2|r  %s 
|cFF00CC00>= 0|r ]=]
	L["Group by Frame"] = ""
	L["Group Description"] = ""
	L["Group Icon"] = ""
	L["Group key"] = " key"
	L["Group Options"] = ""
	L["Group player(s) found"] = ""
	L["Group Role"] = ""
	L["Group Scale"] = ""
	L["Group Settings"] = ""
	L["Hawk"] = ""
	L["Help"] = ""
	L["Hide After"] = ""
	L["Hide Background"] = ""
	L["Hide Glows applied by this aura"] = ""
	L["Hide on"] = ""
	L["Hide this group's children"] = ""
	L["Highlights"] = ""
	L["Horizontal Align"] = ""
	L["Horizontal Bar"] = ""
	L["Huge Icon"] = ""
	L["Hybrid Position"] = ""
	L["Hybrid Sort Mode"] = ""
	L["Icon - The icon associated with the display"] = " - "
	L["Icon Info"] = ""
	L["Icon Inset"] = ""
	L["Icon Picker"] = ""
	L["Icon Position"] = ""
	L["Icon Settings"] = ""
	L["Icon Source"] = ""
	L["If"] = "(if) "
	L["If %s"] = " %s"
	L["If checked, then the combo box in the User settings will be sorted."] = ""
	L["If checked, then the user will see a multi line edit box. This is useful for inputting large amounts of text."] = ""
	L["If checked, then this group will not merge with other group when selecting multiple auras."] = ""
	L["If checked, then this option group can be temporarily collapsed by the user."] = ""
	L["If checked, then this option group will start collapsed."] = ""
	L["If checked, then this separator will include text. Otherwise, it will be just a horizontal line."] = ""
	L["If checked, then this space will span across multiple lines."] = ""
	L["If unchecked, then a default color will be used (usually yellow)"] = " ()"
	L["If unchecked, then this space will fill the entire line it is on in User Mode."] = ""
	L["Ignore out of casting range"] = ""
	L["Ignore out of checking range"] = ""
	L["Ignore Wago updates"] = " Wago "
	L["Ignored"] = ""
	L["Ignored Aura Name"] = ""
	L["Ignored Exact Spell ID(s)"] = " ID"
	L["Ignored Name(s)"] = ""
	L["Ignored Spell ID"] = " ID"
	L["Import"] = ""
	L["Import / Export"] = " / "
	L["Import a display from an encoded string"] = ""
	L["Import as Copy"] = ""
	L["Import has no UID, cannot be matched to existing auras."] = "UID"
	L["Importing"] = ""
	L["Importing %s"] = " %s"
	L["Importing a group with %s child auras."] = " %s "
	L["Importing a stand-alone aura."] = ""
	L["Importing...."] = "..."
	L["Incompatible changes to group region types detected"] = ""
	L["Incompatible changes to group structure detected"] = ""
	L["Indent Size"] = ""
	L["Inner"] = ""
	L["Insert text replacement codes to make text dynamic."] = ""
	L["Invalid Item ID"] = " ID"
	L["Invalid Item Name/ID/Link"] = "/ID/"
	L["Invalid Spell ID"] = " ID"
	L["Invalid Spell Name/ID/Link"] = "/ID/"
	L["Invalid target aura"] = ""
	L["Invalid type for '%s'. Expected 'bool', 'number', 'select', 'string', 'timer' or 'elapsedTimer'."] = "'%s'   'bool', 'number', 'select', 'string', 'timer'  'elapsedTimer'"
	L["Invalid type for property '%s' in '%s'. Expected '%s'"] = " '%s'  ( '%s')  '%s'"
	L["Inverse Slant"] = ""
	L["Invert the direction of progress"] = ""
	L["Is Boss Debuff"] = ""
	L["Is Stealable"] = ""
	L["Is Unit"] = ""
	L["Justify"] = ""
	L["Keep Aspect Ratio"] = ""
	L["Keep your Wago imports up to date with the Companion App."] = " Companion App  Wago "
	L["Large Input"] = ""
	L["Leaf"] = ""
	L["Left 2 HUD position"] = "2 HUD "
	L["Left HUD position"] = " HUD "
	L["Length of |cFFFF0000%s|r"] = "|cFFFF0000%s|r"
	L["LibCompress: Galmok"] = "LibCompress: Galmok"
	L["LibCustomGlow: Dooez"] = "LibCustomGlow: Dooez"
	L["LibDeflate: Yoursafety"] = "LibDeflate: Yoursafety"
	L["LibDispel: Simpy"] = "LibDispel: Simpy"
	L["LibSerialize: Sanjo"] = "LibSerialize: Sanjo"
	L["LibSpecialization: Funkeh"] = "LibSpecialization: Funkeh"
	L["Limit"] = ""
	L["Line"] = ""
	L["Linear Texture %s"] = " %s"
	L["Linked aura: "] = ": "
	L["Linked Auras"] = ""
	L["Load"] = ""
	L["Loaded"] = ""
	L["Loaded/Standby"] = "/"
	L["Lock Positions"] = ""
	L["Low Mana"] = ""
	L["Magnetically Align"] = ""
	L["Main"] = ""
	L["Manual with %i/%i"] = " %i/%i "
	L["Matches %s spells"] = " %s "
	L["Matches the height setting of a horizontal bar or width for a vertical bar."] = ""
	L["Max"] = ""
	L["Max Length"] = ""
	L["Maximum"] = ""
	L["Media Type"] = ""
	L["Medium Icon"] = ""
	L["Min"] = ""
	L["Minimum"] = ""
	L["Model %s"] = " %s"
	L["Model Picker"] = ""
	L["Model Settings"] = ""
	L["ModelPaths could not be loaded, the addon is %s"] = " %s"
	L["Move Above Group"] = ""
	L["Move Below Group"] = ""
	L["Move Down"] = ""
	L["Move Entry Down"] = ""
	L["Move Entry Up"] = ""
	L["Move Into Above Group"] = ""
	L["Move Into Below Group"] = ""
	L["Move this display down in its group's order"] = ""
	L["Move this display up in its group's order"] = ""
	L["Move Up"] = ""
	L["Moving auras: "] = ": "
	L["Multiple Displays"] = ""
	L["Multiselect ignored tooltip"] = [=[|cFFFF0000|r - |cFF777777|r - |cFF777777|r
]=]
	L["Multiselect multiple tooltip"] = [=[|cFF777777|r - |cFF777777|r - |cFF00FF00|r
]=]
	L["Multiselect single tooltip"] = [=[|cFF777777|r - |cFF00FF00|r - |cFF777777|r
]=]
	L["Must be a power of 2"] = "2"
	L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"] = " -  ID"
	L["Name Info"] = ""
	L["Name Pattern Match"] = ""
	L["Name:"] = ":"
	L["Negator"] = ""
	L["New Aura"] = ""
	L["New Template"] = ""
	L["New Value"] = ""
	L["No Children"] = ""
	L["No Logs saved."] = ""
	L["Not a table"] = " table"
	L["Not all children have the same value for this option"] = ""
	L["Not Loaded"] = ""
	L["Note: Automated Messages to SAY and YELL are blocked outside of Instances."] = ":  ''  '' "
	L["Note: This progress source does not provide a total value/duration. A total value/duration must be set via \"Set Maximum Progress\""] = "//"
	L["Number of Entries"] = ""
	L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3]=] ] = [=[




2, 5, 6
2-6
/2
2/3
2-11/3]=]
	L["OFF"] = ""
	L["Offer a guided way to create auras for your character"] = ""
	L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"] = " |cFFFF0000%s|r/|cFFFF0000%s|r"
	L["Offset by 1px"] = " 1px"
	L["Okay"] = ""
	L["ON"] = ""
	L["On Hide"] = ""
	L["On Show"] = ""
	L["Only Match auras cast by a player (not an npc)"] = " ( NPC) "
	L["Only match auras cast by people other than the player or their pet"] = ""
	L["Only match auras cast by the player or their pet"] = ""
	L["Operator"] = ""
	L["Option %i"] = " %i"
	L["Option key"] = " key"
	L["Option Type"] = ""
	L["Options will open after combat ends."] = ""
	L["or"] = ""
	L["or %s"] = " %s"
	L["Orange Rune"] = ""
	L["Our translators (too many to name)"] = ""
	L["Outer"] = ""
	L["Overflow"] = ""
	L["Overlay %s Info"] = " %s "
	L["Overlays"] = ""
	L["Own Only"] = ""
	L["Paste Action Settings"] = ""
	L["Paste Animations Settings"] = ""
	L["Paste Author Options Settings"] = ""
	L["Paste Condition Settings"] = ""
	L["Paste Custom Configuration"] = ""
	L["Paste Display Settings"] = ""
	L["Paste Group Settings"] = ""
	L["Paste Load Settings"] = ""
	L["Paste Settings"] = ""
	L["Paste text below"] = ""
	L["Paste Trigger Settings"] = ""
	L["Places a tick on the bar"] = ""
	L["Play Sound"] = ""
	L["Player Spells found:"] = ""
	L["Portrait Zoom"] = ""
	L["Position and Size Settings"] = ""
	L["Preferred Match"] = ""
	L["Premade Auras"] = ""
	L["Premade Snippets"] = ""
	L["Preparing auras: "] = ": "
	L["Press Ctrl+C to copy"] = " Ctrl+C "
	L["Press Ctrl+C to copy the URL"] = " Ctrl+C  URL"
	L["Prevent Merging"] = ""
	L["Progress - The remaining time of a timer, or a non-timer value"] = " - "
	L["Progress Bar"] = ""
	L["Progress Bar Settings"] = ""
	L["Progress Settings"] = ""
	L["Progress Texture"] = ""
	L["Progress Texture Settings"] = ""
	L["Purple Rune"] = ""
	L["Put this display in a group"] = ""
	L["Range in yards"] = ""
	L["Ready for Install"] = ""
	L["Ready for Update"] = ""
	L["Re-center X"] = ""
	L["Re-center Y"] = ""
	L["Reciprocal TRIGGER:# requests will be ignored!"] = "# "
	L["Redo"] = ""
	L["Regions of type \"%s\" are not supported."] = " \"%s\""
	L["Remove"] = ""
	L["Remove All Sounds"] = ""
	L["Remove All Text To Speech"] = ""
	L["Remove this display from its group"] = ""
	L["Remove this property"] = ""
	L["Rename"] = ""
	L["Repeat After"] = ""
	L["Repeat every"] = ""
	L["Report bugs on our issue tracker."] = " bug"
	L["Require unit from trigger"] = ""
	L["Required for Activation"] = ""
	L["Requires LibSpecialization, that is e.g. a up-to date WeakAuras version"] = " LibSpecialization WeakAuras "
	L["Reset all options to their default values."] = ""
	L["Reset Entry"] = ""
	L["Reset to Defaults"] = ""
	L["Right 2 HUD position"] = "2 HUD "
	L["Right HUD position"] = " HUD "
	L["Right-click for more options"] = ""
	L["Rotate"] = ""
	L["Rotate In"] = ""
	L["Rotate Out"] = ""
	L["Rotate Text"] = ""
	L["Rotation Mode"] = ""
	L["Row Space"] = ""
	L["Row Width"] = ""
	L["Rows"] = ""
	L["Run on..."] = "..."
	L["Same"] = ""
	L["Same texture as Foreground"] = ""
	L["Saved Data"] = ""
	L["Scale Factor"] = ""
	L["Search API"] = "API"
	L["Select Talent"] = ""
	L["Select the auras you always want to be listed first"] = ""
	L["Selected Frame"] = ""
	L["Send To"] = ""
	L["Separator Text"] = ""
	L["Separator text"] = ""
	L["Set Maximum Progress"] = ""
	L["Set Minimum Progress"] = ""
	L["Set Parent to Anchor"] = ""
	L["Set Thumbnail Icon"] = ""
	L["Sets the anchored frame as the aura's parent, causing the aura to inherit attributes such as visibility and scale."] = ""
	L["Settings"] = ""
	L["Shadow Color"] = ""
	L["Shadow X Offset"] = ""
	L["Shadow Y Offset"] = ""
	L["Shift-click to create chat link"] = "Shift- |cFF8800FF[]"
	L["Show \"Edge\""] = "\"\""
	L["Show \"Swipe\""] = " \"\""
	L["Show and Clone Settings"] = ""
	L["Show Border"] = ""
	L["Show Circular Texture"] = ""
	L["Show Debug Logs"] = ""
	L["Show Glow"] = ""
	L["Show Icon"] = ""
	L["Show If Unit Does Not Exist"] = ""
	L["Show Linear Texture"] = ""
	L["Show Matches for"] = ""
	L["Show Matches for Units"] = ""
	L["Show Model"] = ""
	L["Show model of unit "] = ""
	L["Show Sound Setting"] = ""
	L["Show Spark"] = ""
	L["Show Stop Motion"] = ""
	L["Show Text"] = ""
	L["Show Text To Speech Setting"] = ""
	L["Show Texture"] = ""
	L["Show this group's children"] = ""
	L["Show Tick"] = ""
	L["Shows a 3D model from the game files"] = "3D"
	L["Shows a border"] = ""
	L["Shows a Circular Progress Texture"] = ""
	L["Shows a custom texture"] = ""
	L["Shows a glow"] = ""
	L["Shows a Linear Progress Texture"] = ""
	L["Shows a model"] = ""
	L["Shows a progress bar with name, timer, and icon"] = ""
	L["Shows a spell icon with an optional cooldown overlay"] = ""
	L["Shows a Stop Motion"] = ""
	L["Shows a stop motion texture"] = ""
	L["Shows a Texture"] = ""
	L["Shows a texture that changes based on duration"] = ""
	L["Shows nothing, except sub elements"] = ""
	L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"] = " ()"
	L["Size"] = ""
	L["Slant Amount"] = ""
	L["Slant Mode"] = ""
	L["Slanted"] = ""
	L["Slide"] = ""
	L["Slide In"] = ""
	L["Slide Out"] = ""
	L["Slider Step Size"] = ""
	L["Small Icon"] = ""
	L["Smooth Progress"] = ""
	L["Snippets"] = ""
	L["Soft Max"] = ""
	L["Soft Min"] = ""
	L["Sort"] = ""
	L["Sound Channel"] = ""
	L["Sound File Path"] = ""
	L["Sound Kit ID"] = "Sound Kit ID"
	L["Space Horizontally"] = ""
	L["Space Vertically"] = ""
	L["Spark Settings"] = ""
	L["Spark Texture"] = ""
	L["Specific Currency ID"] = "ID"
	L["Spell Selection Filters"] = ""
	L["Spells found:"] = ""
	L["Stack Info"] = ""
	L["Stacks - The number of stacks of an aura (usually)"] = " - "
	L["Standby"] = ""
	L["Star"] = ""
	L["Start"] = ""
	L["Start Angle"] = ""
	L["Start Collapsed"] = ""
	L["Start of %s"] = "%s "
	L["Step Size"] = ""
	L["Stop Motion %s"] = " %s"
	L["Stop Motion Settings"] = ""
	L["Stop Sound"] = ""
	L["Stretched by Foreground"] = ""
	L["Sub Elements"] = ""
	L["Sub Option %i"] = " %i"
	L["Subevent"] = ""
	L["Subevent Suffix"] = ""
	L["Swipe Overlay Settings"] = ""
	L["Templates could not be loaded, the addon is %s"] = " %s"
	L["Temporary Group"] = ""
	L["Text %s"] = " %s"
	L["Text Color"] = ""
	L["Text Settings"] = ""
	L["Texture %s"] = " %s"
	L["Texture Info"] = ""
	L["Texture Selection Mode"] = ""
	L["Texture Settings"] = ""
	L["Texture Wrap"] = ""
	L["Texture X Offset"] = ""
	L["Texture Y Offset"] = ""
	L["Thanks"] = ""
	L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"] = "ElvUI  ElvUI "
	L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"] = " OmniCC  OmniCC "
	L["The duration of the animation in seconds."] = "()"
	L["The duration of the animation in seconds. The finish animation does not start playing until after the display would normally be hidden."] = " ()"
	L["The group and all direct children will share the same base frame level."] = ""
	L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."] = ""
	L["The type of trigger"] = ""
	L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"] = "WeakAuras  %s  WeakAuras  %s  WeakAuras"
	L["Then "] = "(then)  "
	L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."] = ""
	L["This adds %raidMark as text replacements."] = " %raidMark "
	L["This adds %role, %roleIcon as text replacements. Does nothing if the unit is not a group member."] = " %role%roleIcon "
	L["This adds %tooltip, %tooltip1, %tooltip2, %tooltip3 and %tooltip4 as text replacements and also allows filtering based on the tooltip content/values."] = " %tooltip, %tooltip1, %tooltip2, %tooltip3  %tooltip4 /"
	L[ [=[This aura contains custom Lua code.
Make sure you can trust the person who sent it!]=] ] = " Lua !"
	L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."] = " '%s'"
	L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."] = " '%s'"
	L[ [=[This aura was created with a different version (%s) of World of Warcraft.
It might not work correctly!]=] ] = " (%s) !"
	L[ [=[This aura was created with a newer version of WeakAuras.
Upgrade your version of WeakAuras or wait for next release before installing this aura.]=] ] = [=[ WeakAuras 
 WeakAuras ]=]
	L["This display is currently loaded"] = ""
	L["This display is not currently loaded"] = ""
	L["This display is on standby, it will be loaded when needed."] = ""
	L["This enables the collection of debug logs. Custom code can add debug information to the log through the function DebugPrint."] = " DebugPrint "
	L["This is a modified version of your aura, |cff9900FF%s.|r"] = "|cff9900FF%s|r"
	L["This is a modified version of your group: |cff9900FF%s|r"] = "|cff9900FF%s|r"
	L["This region of type \"%s\" is not supported."] = " \"%s\""
	L["This setting controls what widget is generated in user mode."] = ""
	L["Thumbnail Icon"] = ""
	L["Tick %s"] = " %s"
	L["Tick Area %s"] = " %s"
	L["Tick Center %s"] = " %s"
	L["Tick Mode"] = ""
	L["Tick Placement"] = ""
	L["Time in"] = ""
	L["Tiny Icon"] = ""
	L["To Frame's"] = ""
	L["To Group's"] = ""
	L["To Personal Ressource Display's"] = ""
	L["To Region's"] = ""
	L["To Screen's"] = ""
	L["Toggle the visibility of all loaded displays"] = ""
	L["Toggle the visibility of all non-loaded displays"] = ""
	L["Toggle the visibility of this display"] = ""
	L["Tooltip Content"] = ""
	L["Tooltip on Mouseover"] = ""
	L["Tooltip Pattern Match"] = " (Pattern)"
	L["Tooltip Text"] = ""
	L["Tooltip Value"] = ""
	L["Tooltip Value #"] = " #"
	L["Top HUD position"] = " HUD "
	L["Total"] = ""
	L["Total - The maximum duration of a timer, or a maximum non-timer value"] = " - "
	L["Total Angle"] = ""
	L["Total Time"] = ""
	L["Trigger %i: %s"] = " %i: %s"
	L["Trigger Combination"] = ""
	L["Type 'select' for '%s' requires a values member'"] = "'%s'  'select'  values member"
	L["Undo"] = ""
	L["Ungroup"] = ""
	L["Unit %s is not a valid unit for RegisterUnitEvent"] = "%s  RegisterUnitEvent "
	L["Unit Count"] = ""
	L["Unknown"] = ""
	L["Unknown Encounter's Spell Id"] = " ID"
	L["Unknown property '%s' found in '%s'"] = " '%s' '%s'"
	L["Unknown Spell"] = ""
	L["Unlike the start or finish animations, the main animation will loop over and over until the display is hidden."] = ""
	L["Update"] = ""
	L["Update Auras"] = ""
	L["Update Custom Text On..."] = "..."
	L["URL"] = "URL"
	L["Url: %s"] = "%s"
	L["Use Display Info Id"] = " ID"
	L["Use SetTransform"] = " SetTransform"
	L["Used in Auras:"] = ":"
	L["Used in auras:"] = ":"
	L["Uses Texture Coordinates to rotate the texture."] = ""
	L["Uses UnitIsVisible() to check if game client has loaded a object for this unit. This distance is around 100 yards. This is polled every second."] = " UnitIsVisible()  100"
	L["Value"] = ""
	L["Value %i"] = " %i"
	L["Values are in normalized rgba format."] = " rgba  "
	L["Values/Remaining Time above this value are displayed as full progress."] = "/"
	L["Values/Remaining Time below this value are displayed as zero progress."] = "/"
	L["Values:"] = ":"
	L["Version: "] = ": "
	L["Version: %s"] = "%s"
	L["Vertical Align"] = ""
	L["Vertical Bar"] = ""
	L["View"] = ""
	L["View custom code"] = ""
	L["Voice Settings"] = ""
	L["We thank"] = ""
	L["WeakAuras %s on WoW %s"] = "WeakAuras %s  WoW %s"
	L["WeakAuras recommends using spell ids instead of names. Spell ids are automatically localized."] = "WeakAuras IDID"
	L["What do you want to do?"] = "?"
	L["Whole Area"] = ""
	L["wrapping"] = ""
	L["X Offset"] = ""
	L["X Rotation"] = ""
	L["X Scale"] = ""
	L["x-Offset"] = ""
	L["Y Offset"] = ""
	L["Y Rotation"] = ""
	L["Y Scale"] = ""
	L["Yellow Rune"] = ""
	L["y-Offset"] = ""
	L["You already have this group/aura. Importing will create a duplicate."] = "/"
	L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"] = " %d |cFFFF0000!|r ?"
	L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"] = " |cFFFF0000!|r ?"
	L[ [=[You are about to Import an Aura with custom Lua code on a Hardcore server.

|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r

Would you like to continue?]=] ] = " Lua |cFFFF0000!|r ?"
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.

WeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "WeakAuras  (Anchor Code) 'changed'WeakAuras "
	L[ [=[You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.

WeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered.]=] ] = "() WeakAuras  ''WeakAuras "
	L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."] = "() WeakAuras  ''WeakAuras "
	L["Your Saved Snippets"] = ""
	L["Z Offset"] = "Z"
	L["Z Rotation"] = "Z"
	L["Zoom In"] = ""
	L["Zoom Out"] = ""


=== END OF FILE: WeakAurasOptions/Locales/zhTW.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/CodeReview.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")
local SharedMedia = LibStub("LibSharedMedia-3.0")
local IndentationLib = IndentationLib

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local codeReview

local tableColor = "|c00ff3333"
local arithmeticColor = "|c00ff3333"
local relationColor = "|c00ff3333"
local logicColor = "|c004444ff"

local colorScheme = {
  [IndentationLib.tokens.TOKEN_SPECIAL] = "|c00ff3333",
  [IndentationLib.tokens.TOKEN_KEYWORD] = "|c004444ff",
  [IndentationLib.tokens.TOKEN_COMMENT_SHORT] = "|c0000aa00",
  [IndentationLib.tokens.TOKEN_COMMENT_LONG] = "|c0000aa00",
  [IndentationLib.tokens.TOKEN_NUMBER] = "|c00ff9900",
  [IndentationLib.tokens.TOKEN_STRING] = "|c00999999",
  -- ellipsis, curly braces, table access
  ["..."] = tableColor,
  ["{"] = tableColor,
  ["}"] = tableColor,
  ["["] = tableColor,
  ["]"] = tableColor,
  -- arithmetic operators
  ["+"] = arithmeticColor,
  ["-"] = arithmeticColor,
  ["/"] = arithmeticColor,
  ["*"] = arithmeticColor,
  [".."] = arithmeticColor,
  -- relational operators
  ["=="] = relationColor,
  ["<"] = relationColor,
  ["<="] = relationColor,
  [">"] = relationColor,
  [">="] = relationColor,
  ["~="] = relationColor,
  -- logical operators
  ["and"] = logicColor,
  ["or"] = logicColor,
  ["not"] = logicColor,
  -- misc
  [0] = "|r",
}

local function ConstructCodeReview(frame)
  local group = AceGUI:Create("WeakAurasInlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -63);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 46);
  group.frame:Hide();
  group:SetLayout("flow");

  local codeTree = AceGUI:Create("TreeGroup");
  codeTree:SetTreeWidth(300, false)
  codeTree:SetFullWidth(true)
  codeTree:SetFullHeight(true)
  codeTree:SetLayout("flow")
  codeTree.dragger:Hide()
  codeTree.border:SetBackdrop(nil)
  codeTree.content:SetAllPoints()
  group.codeTree = codeTree;
  group:AddChild(codeTree);

  local codebox = AceGUI:Create("MultiLineEditBox");
  codebox:SetLabel("");
  codebox:DisableButton(true)
  codebox:SetFullWidth(true)
  codebox:SetFullHeight(true)
  codeTree:AddChild(codebox)

  IndentationLib.enable(codebox.editBox, colorScheme, 4);
  local fontPath = SharedMedia:Fetch("font", "Fira Mono Medium");
  if(fontPath) then
    codebox.editBox:SetFont(fontPath, 12, "");
  end
  group.codebox = codebox;

  codeTree:SetCallback("OnGroupSelected", function(self, event, value)
    for _, v in pairs(group.data) do
      if (v.value == value) then
        codebox:SetText(v.code);
      end
    end
  end);

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  cancel:SetScript("OnClick", function() group:Close() end);
  cancel:SetPoint("BOTTOMRIGHT", -20, -24);
  cancel:SetHeight(20);
  cancel:SetWidth(100);
  cancel:SetText(L["Okay"]);

  function group.Open(self, data)
    if frame.window == "codereview" then
      return
    end

    local _, firstEntry = next(data)
    self.data = data;
    self.codeTree:SetTree(data);
    self.codeTree:SelectByValue(firstEntry.value)

    frame.window = "codereview";
    frame:UpdateFrameVisible()
  end

  function group.Close()
    frame.window = "update";
    frame:UpdateFrameVisible()
  end

  return group
end

function OptionsPrivate.CodeReview(frame)
  codeReview = codeReview or ConstructCodeReview(frame)
  return codeReview
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/CodeReview.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/DebugLogFrame.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- WoW APIs
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local debugLog

local function ConstructDebugLog(frame)
  local group = AceGUI:Create("WeakAurasInlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -63);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 46);
  group.frame:Hide();
  group:SetLayout("flow");

  local copyLabel = AceGUI:Create("Label")
  copyLabel:SetFontObject(GameFontNormal)
  copyLabel:SetFullWidth(true)
  copyLabel:SetText(L["Press Ctrl+C to copy"])
  group:AddChild(copyLabel)

  local input = AceGUI:Create("MultiLineEditBox");
  input:DisableButton(true)
  input.frame:SetClipsChildren(true);
  input.editBox:SetScript("OnEscapePressed", function() group:Close(); end);
  input.editBox:SetScript("OnMouseUp", function() input.editBox:HighlightText(); end);
  input:SetFullWidth(true)
  input:SetFullHeight(true)
  group:AddChild(input);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", function() group:Close() end);
  close:SetPoint("BOTTOMRIGHT", -20, -24)
  close:SetFrameLevel(close:GetFrameLevel() + 1)
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Close"])

  function group.Open(self, text)
    frame.window = "debuglog";
    frame:UpdateFrameVisible()
    input.editBox:SetScript("OnTextChanged", function() input:SetText(text); input.editBox:HighlightText(); end);
    input.editBox:SetScript("OnMouseUp", function() input.editBox:HighlightText(); end);
    input:SetLabel("");
    input.button:Hide();
    input:SetText(text);
    input.editBox:HighlightText();
    input:SetFocus()

    group:DoLayout()
  end

  function group.Close(self)
    input:ClearFocus();
    frame.window = "default";
    frame:UpdateFrameVisible()
  end

  return group
end

function OptionsPrivate.DebugLog(frame, noConstruct)
  debugLog = debugLog or (not noConstruct and ConstructDebugLog(frame))
  return debugLog
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/DebugLogFrame.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/FrameChooser.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local pairs = pairs

-- WoW APIs
local CreateFrame, IsMouseButtonDown, SetCursor, GetMouseFocus, MouseIsOver, ResetCursor
  = CreateFrame, IsMouseButtonDown, SetCursor, GetMouseFocus, MouseIsOver, ResetCursor

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local frameChooserFrame
local frameChooserBox

local oldFocus
local oldFocusName

-- if frame doesn't have a name, try to use the key from it's parent
local function recurseGetName(frame)
  local name = frame.GetName and frame:GetName() or nil
  if name then
     return name
  end
  local parent = frame.GetParent and frame:GetParent()
  if parent then
     for key, child in pairs(parent) do
        if child == frame then
           return (recurseGetName(parent) or "") .. "." .. key
        end
     end
  end
end

function OptionsPrivate.StartFrameChooser(data, path)
  local frame = OptionsPrivate.Private.OptionsFrame();
  if not(frameChooserFrame) then
    frameChooserFrame = CreateFrame("Frame");
    frameChooserBox = CreateFrame("Frame", nil, frameChooserFrame, "BackdropTemplate");
    frameChooserBox:SetFrameStrata("TOOLTIP");
    frameChooserBox:SetBackdrop({
      edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
      edgeSize = 12,
      insets = {left = 0, right = 0, top = 0, bottom = 0}
    });
    frameChooserBox:SetBackdropBorderColor(0, 1, 0);
    frameChooserBox:Hide();
  end
  local givenValue = OptionsPrivate.Private.ValueFromPath(data, path);

  frameChooserFrame:SetScript("OnUpdate", function()
    if(IsMouseButtonDown("RightButton")) then
      OptionsPrivate.Private.ValueToPath(data, path, givenValue);
      OptionsPrivate.StopFrameChooser(data);
      WeakAuras.FillOptions()
    elseif(IsMouseButtonDown("LeftButton") and oldFocusName) then
      OptionsPrivate.StopFrameChooser(data);
    else
      SetCursor("CAST_CURSOR");

      local focus
      if GetMouseFocus then
        focus = GetMouseFocus()
      elseif GetMouseFoci then
        local foci = GetMouseFoci()
        focus = foci[1] or nil
      end
      local focusName;

      if(focus) then
        focusName = recurseGetName(focus)
        if(focusName == "WorldFrame" or not focusName) then
          focusName = nil;
          local focusIsGroup = false;
          for id, regionData in pairs(OptionsPrivate.Private.regions) do
            if(regionData.region and regionData.region:IsVisible() and MouseIsOver(regionData.region)) then
              local isGroup = regionData.regionType == "group" or regionData.regionType == "dynamicgroup";
              if (not focusName or (not isGroup and focusIsGroup)) then
                focus = regionData.region;
                focusName = "WeakAuras:"..id;
                focusIsGroup = focusIsGroup;
              end
            end
          end
        end

        if(focus ~= oldFocus) then
          if(focusName) then
            frameChooserBox:ClearAllPoints();
            frameChooserBox:SetPoint("bottomleft", focus, "bottomleft", -4, -4);
            frameChooserBox:SetPoint("topright", focus, "topright", 4, 4);
            frameChooserBox:Show();
          end

          if(focusName ~= oldFocusName) then
            OptionsPrivate.Private.ValueToPath(data, path, focusName);
            oldFocusName = focusName;
            WeakAuras.FillOptions()
          end
          oldFocus = focus;
        end
      end

      if not(focusName) then
        frameChooserBox:Hide();
      end
    end
  end);
end

function OptionsPrivate.StopFrameChooser(data)
  if(frameChooserFrame) then
    frameChooserFrame:SetScript("OnUpdate", nil);
    frameChooserBox:Hide();
  end
  ResetCursor();
  WeakAuras.Add(data);
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/FrameChooser.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/IconPicker.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local pairs  = pairs

-- WoW APIs
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local iconPicker

local spellCache = WeakAuras.spellCache

local function ConstructIconPicker(frame)
  local group = AceGUI:Create("InlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 46);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -50);
  group.frame:Hide();
  group:SetLayout("fill");

  local scroll = AceGUI:Create("ScrollFrame");
  scroll:SetLayout("flow");
  scroll.frame:SetClipsChildren(true);
  group:AddChild(scroll);

  local function iconPickerFill(subname, doSort)
    scroll:ReleaseChildren();

    local usedIcons = {};
    local AddButton = function(name, icon)
      local button = AceGUI:Create("WeakAurasIconButton");
      button:SetName(name);
      button:SetTexture(icon);
      button:SetClick(function()
        group:Pick(icon);
      end);
      scroll:AddChild(button);

      usedIcons[icon] = true;
    end

    -- Work around special numbers such as inf and nan
    if (tonumber(subname)) then
      local spellId = tonumber(subname);
      if (abs(spellId) < math.huge and tostring(spellId) ~= "nan") then
        local name, _, icon = OptionsPrivate.Private.ExecEnv.GetSpellInfo(spellId)
        if name and icon then
          AddButton(name, icon)
        end
        return;
      end
    end

    if subname then
      subname = subname:lower();
    end



    local num = 0;
    if(subname and subname ~= "") then
      for name, icons in pairs(spellCache.Get()) do
        if(name:lower():find(subname, 1, true)) then
          if icons.spells then
            for spell, icon in icons.spells:gmatch("(%d+)=(%d+)") do
              local iconId = tonumber(icon)
              if (not usedIcons[iconId]) then
                AddButton(name, iconId)
                num = num + 1;
                if(num >= 500) then
                  break;
                end
              end
            end
          elseif icons.achievements then
            for _, icon in icons.achievements:gmatch("(%d+)=(%d+)") do
              local iconId = tonumber(icon)
              if (not usedIcons[iconId]) then
                AddButton(name, iconId)
                num = num + 1;
                if(num >= 500) then
                  break;
                end
              end
            end
          end
        end

        if(num >= 500) then
          break;
        end
      end
    end
  end

  local input = CreateFrame("EditBox", "WeakAurasFilterInput", group.frame, "SearchBoxTemplate")
  input:SetScript("OnTextChanged", function(self)
    SearchBoxTemplate_OnTextChanged(self)
    iconPickerFill(input:GetText(), false)
  end);
  input:SetScript("OnEnterPressed", function(...) iconPickerFill(input:GetText(), true); end);
  input:SetScript("OnEscapePressed", function(...) input:SetText(""); iconPickerFill(input:GetText(), true); end);
  input:SetWidth(200);
  input:SetHeight(15);
  input:SetFont(STANDARD_TEXT_FONT, 10, "")
  input:SetPoint("BOTTOMRIGHT", group.frame, "TOPRIGHT", -3, -10);

  local icon = AceGUI:Create("WeakAurasIconButton");
  icon.frame:Disable();
  icon.frame:SetParent(group.frame);
  icon.frame:SetPoint("BOTTOMLEFT", group.frame, "TOPLEFT", 44, -15);
  icon:SetHeight(36)
  icon:SetWidth(36)

  local iconLabel = input:CreateFontString(nil, "OVERLAY", "GameFontNormalHuge");
  iconLabel:SetNonSpaceWrap("true");
  iconLabel:SetJustifyH("LEFT");
  iconLabel:SetPoint("LEFT", icon.frame, "RIGHT", 5, 0);
  iconLabel:SetPoint("RIGHT", input, "LEFT", -50, 0);

  function group.Pick(self, texturePath)
    local valueToPath = OptionsPrivate.Private.ValueToPath
    if self.groupIcon then
      valueToPath(self.baseObject, self.paths[self.baseObject.id], texturePath)
      WeakAuras.Add(self.baseObject)
      WeakAuras.ClearAndUpdateOptions(self.baseObject.id)
      WeakAuras.UpdateThumbnail(self.baseObject)
    else
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(self.baseObject) do
        valueToPath(child, self.paths[child.id], texturePath)
        WeakAuras.Add(child)
        WeakAuras.ClearAndUpdateOptions(child.id)
        WeakAuras.UpdateThumbnail(child);
      end
    end
    local success = icon:SetTexture(texturePath) and texturePath;
    if(success) then
      iconLabel:SetText(texturePath);
    else
      iconLabel:SetText();
    end
  end

  function group.Open(self, baseObject, paths, groupIcon)
    local valueFromPath = OptionsPrivate.Private.ValueFromPath
    self.baseObject = baseObject
    self.paths = paths
    self.groupIcon = groupIcon
    if groupIcon then
      local value = valueFromPath(self.baseObject, paths[self.baseObject.id])
      self.givenPath = value
    else
      self.givenPath = {};
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(baseObject) do
        if child and paths[child.id] then
          local value = valueFromPath(child, paths[child.id])
          self.givenPath[child.id] = value or "";
        end
      end
    end
    -- group:Pick(self.givenPath);
    frame.window = "icon";
    frame:UpdateFrameVisible()
    input:SetText("");
  end

  function group.Close()
    frame.window = "default";
    frame:UpdateFrameVisible()
    WeakAuras.FillOptions()
  end

  function group.CancelClose()
    local valueToPath = OptionsPrivate.Private.ValueToPath
    if group.groupIcon then
      valueToPath(group.baseObject, group.paths[group.baseObject.id], group.givenPath)
      WeakAuras.Add(group.baseObject)
      WeakAuras.ClearAndUpdateOptions(group.baseObject.id)
      WeakAuras.UpdateThumbnail(group.baseObject)
    else
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(group.baseObject) do
        if (group.givenPath[child.id]) then
          valueToPath(child, group.paths[child.id], group.givenPath[child.id])
          WeakAuras.Add(child);
          WeakAuras.ClearAndUpdateOptions(child.id)
          WeakAuras.UpdateThumbnail(child);
        end
      end
    end

    group.Close();
  end

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  cancel:SetScript("OnClick", group.CancelClose);
  cancel:SetPoint("BOTTOMRIGHT", -20, -24)
  cancel:SetHeight(20);
  cancel:SetWidth(100);
  cancel:SetText(L["Cancel"]);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", group.Close);
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0);
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Okay"]);

  return group
end

function OptionsPrivate.IconPicker(frame, noConstruct)
  iconPicker = iconPicker or (not noConstruct and ConstructIconPicker(frame))
  return iconPicker
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/IconPicker.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/ImportExport.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- WoW APIs
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local importexport

local function ConstructImportExport(frame)
  local group = AceGUI:Create("WeakAurasInlineGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 16, -63);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -16, 46);
  group.frame:Hide();
  group:SetLayout("flow");

  local input = AceGUI:Create("MultiLineEditBox");
  input:DisableButton(true)
  input.frame:SetClipsChildren(true);
  input:SetFullWidth(true)
  input:SetFullHeight(true)
  group:AddChild(input);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", function() group:Close() end);
  close:SetPoint("BOTTOMRIGHT", -20, -24);
  close:SetFrameLevel(close:GetFrameLevel() + 1)
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Close"])

  function group.Open(self, mode, id)
    if(frame.window == "texture") then
      local texturepicker = OptionsPrivate.TexturePicker(frame, true)
      if texturepicker then
        texturepicker:CancelClose();
      end
    elseif(frame.window == "icon") then
      local iconpicker = OptionsPrivate.IconPicker(frame, true)
      if iconpicker then
        iconpicker:CancelClose();
      end
    elseif(frame.window == "model") then
      local modelpicker = OptionsPrivate.ModelPicker(frame, true)
      if modelpicker then
        modelpicker:CancelClose();
      end
    end
    frame.window = "importexport";
    frame:UpdateFrameVisible()
    if(mode == "export" or mode == "table") then
      OptionsPrivate.SetTitle(L["Exporting"])
      if(id) then
        local displayStr;
        if(mode == "export") then
          displayStr = OptionsPrivate.Private.DisplayToString(id, true);
        elseif(mode == "table") then
          displayStr = OptionsPrivate.Private.DataToString(id, true);
        end
        --input.editBox:SetMaxBytes(nil); Dragonflight doesn't accept nil
        input.editBox:SetScript("OnEscapePressed", function()
          group:Close();
        end);
        input.editBox:SetScript("OnTextChanged", function()
          input:SetText(displayStr); input.editBox:HighlightText();
        end);
        input.editBox:SetScript("OnMouseUp", function()
          input.editBox:HighlightText();
        end);
        input:SetLabel(id.." - "..#displayStr);
        input.button:Hide();
        input:SetText(displayStr);
        input.editBox:HighlightText();
        input:SetFocus();
      end
    elseif(mode == "import") then
      OptionsPrivate.SetTitle(L["Importing"])
      input.editBox:SetScript("OnTextChanged", function(self)
        local pasted = self:GetText()
        pasted = pasted:match("^%s*(.-)%s*$")
        if #pasted > 20 then
          WeakAuras.Import(pasted)
        end
      end)
      input.editBox:SetText("");
      input.editBox:SetScript("OnEscapePressed", function() group:Close(); end);
      input.editBox:SetScript("OnMouseUp", nil);
      input:SetLabel(L["Paste text below"]);
      input:SetFocus();
    end
    group:DoLayout()
  end

  function group.Close()
    input:ClearFocus();
    frame.window = "default";
    frame:UpdateFrameVisible()
  end

  return group
end

function OptionsPrivate.ImportExport(frame, noConstruct)
  importexport = importexport or (not noConstruct and ConstructImportExport(frame))
  return importexport
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/ImportExport.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/ModelPicker.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local rad = rad

-- WoW APIs
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local modelPicker

local function GetAll(baseObject, path, property, default)
  local valueFromPath = OptionsPrivate.Private.ValueFromPath
  if not property then
    return default
  end

  local result = default
  local first = true
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(baseObject) do
    local childObject = valueFromPath(child, path)
    if childObject and childObject[property] then
      if first then
        result = childObject[property]
        first = false
      else
        if result ~= childObject[property] then
          return default
        end
      end
    end
  end
  return result
end

local function ConstructModelPicker(frame)
  local function RecurseSetFilter(tree, filter)
    for k, v in ipairs(tree) do
      if v.children == nil and v.text then
        v.visible = not filter or filter == "" or v.text:find(filter, 1, true) ~= nil
      else
        RecurseSetFilter(v.children, filter)
      end
    end
  end

  local group = AceGUI:Create("SimpleGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 87);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -63);
  group.frame:Hide();
  group:SetLayout("flow");

  local filterInput = CreateFrame("EditBox", "WeakAurasFilterInput", group.frame, "SearchBoxTemplate")
  filterInput:SetScript("OnTextChanged", function(self)
    SearchBoxTemplate_OnTextChanged(self)
    local filterText = filterInput:GetText()
    RecurseSetFilter(group.modelTree.tree, filterText)
    group.modelTree.filter = filterText ~= nil and filterText ~= ""
    group.modelTree:RefreshTree()
  end)
  filterInput:SetHeight(15)
  filterInput:SetPoint("BOTTOMRIGHT", group.frame, "TOPRIGHT", -3, 5)
  filterInput:SetWidth(200)
  filterInput:SetFont(STANDARD_TEXT_FONT, 10, "")
  group.frame.filterInput = filterInput

  -- Old X Y Z controls
  local modelPickerZ = AceGUI:Create("Slider");
  modelPickerZ:SetSliderValues(-20, 20, 0.05);
  modelPickerZ:SetLabel(L["Z Offset"]);
  modelPickerZ.frame:SetParent(group.frame);
  modelPickerZ:SetCallback("OnValueChanged", function()
    group:Pick(nil, modelPickerZ:GetValue());
  end);

  local modelPickerX = AceGUI:Create("Slider");
  modelPickerX:SetSliderValues(-20, 20, 0.05);
  modelPickerX:SetLabel(L["X Offset"]);
  modelPickerX.frame:SetParent(group.frame);
  modelPickerX:SetCallback("OnValueChanged", function()
    group:Pick(nil, nil, modelPickerX:GetValue());
  end);

  local modelPickerY = AceGUI:Create("Slider");
  modelPickerY:SetSliderValues(-20, 20, 0.05);
  modelPickerY:SetLabel(L["Y Offset"]);
  modelPickerY.frame:SetParent(group.frame);
  modelPickerY:SetCallback("OnValueChanged", function()
    group:Pick(nil, nil, nil, modelPickerY:GetValue());
  end);

  local modelPickerRotation = AceGUI:Create("Slider");
  modelPickerRotation:SetSliderValues(0, 360, 0.05);
  modelPickerRotation:SetLabel(L["Rotation"]);
  modelPickerRotation.frame:SetParent(group.frame);
  modelPickerRotation:SetCallback("OnValueChanged", function()
    group:Pick(nil, nil, nil, nil, modelPickerRotation:GetValue());
  end);

  -- New TX TY TZ, RX, RY, RZ, US controls
  local modelPickerTX = AceGUI:Create("Slider");
  modelPickerTX:SetSliderValues(-1000, 1000, 1);
  modelPickerTX:SetLabel(L["X Offset"]);
  modelPickerTX.frame:SetParent(group.frame);
  modelPickerTX:SetCallback("OnValueChanged", function()
    group:PickSt(nil, modelPickerTX:GetValue());
  end);

  local modelPickerTY = AceGUI:Create("Slider");
  modelPickerTY:SetSliderValues(-1000, 1000, 1);
  modelPickerTY:SetLabel(L["Y Offset"]);
  modelPickerTY.frame:SetParent(group.frame);
  modelPickerTY:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, modelPickerTY:GetValue());
  end);

  local modelPickerTZ = AceGUI:Create("Slider");
  modelPickerTZ:SetSliderValues(-1000, 1000, 1);
  modelPickerTZ:SetLabel(L["Z Offset"]);
  modelPickerTZ.frame:SetParent(group.frame);
  modelPickerTZ:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, modelPickerTZ:GetValue());
  end);

  local modelPickerRX = AceGUI:Create("Slider");
  modelPickerRX:SetSliderValues(0, 360, 1);
  modelPickerRX:SetLabel(L["X Rotation"]);
  modelPickerRX.frame:SetParent(group.frame);
  modelPickerRX:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, modelPickerRX:GetValue());
  end);

  local modelPickerRY = AceGUI:Create("Slider");
  modelPickerRY:SetSliderValues(0, 360, 1);
  modelPickerRY:SetLabel(L["Y Rotation"]);
  modelPickerRY.frame:SetParent(group.frame);
  modelPickerRY:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, nil, modelPickerRY:GetValue());
  end);

  local modelPickerRZ = AceGUI:Create("Slider");
  modelPickerRZ:SetSliderValues(0, 360, 1);
  modelPickerRZ:SetLabel(L["Z Rotation"]);
  modelPickerRZ.frame:SetParent(group.frame);
  modelPickerRZ:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, nil, nil, modelPickerRZ:GetValue());
  end);

  local modelPickerUS = AceGUI:Create("Slider");
  modelPickerUS:SetSliderValues(5, 1000, 1);
  modelPickerUS:SetLabel(L["Scale"]);
  modelPickerUS.frame:SetParent(group.frame);
  modelPickerUS:SetCallback("OnValueChanged", function()
    group:PickSt(nil, nil, nil, nil, nil, nil, nil, modelPickerUS:GetValue());
  end);

  local modelTree = AceGUI:Create("WeakAurasTreeGroup");
  group.modelTree = modelTree;
  group.frame:SetScript("OnSizeChanged", function()
    local frameWidth = frame:GetWidth();
    local sliderWidth = (frameWidth - 50) / 4;
    local narrowSliderWidth = (frameWidth - 50) / 7;

    modelTree:SetTreeWidth(frameWidth - 370);

    modelPickerZ.frame:SetPoint("bottomleft", frame, "bottomleft", 15, 43);
    modelPickerZ.frame:SetPoint("bottomright", frame, "bottomleft", 15 + sliderWidth, 43);

    modelPickerX.frame:SetPoint("bottomleft", frame, "bottomleft", 25 + sliderWidth, 43);
    modelPickerX.frame:SetPoint("bottomright", frame, "bottomleft", 25 + (2 * sliderWidth), 43);

    modelPickerY.frame:SetPoint("bottomleft", frame, "bottomleft", 35 + (2 * sliderWidth), 43);
    modelPickerY.frame:SetPoint("bottomright", frame, "bottomleft", 35 + (3 * sliderWidth), 43);

    modelPickerRotation.frame:SetPoint("bottomleft", frame, "bottomleft", 45 + (3 * sliderWidth), 43);
    modelPickerRotation.frame:SetPoint("bottomright", frame, "bottomleft", 45 + (4 * sliderWidth), 43);

    -- New controls
    modelPickerTX.frame:SetPoint("bottomleft", frame, "bottomleft", 15, 43);
    modelPickerTX.frame:SetPoint("bottomright", frame, "bottomleft", 15 + narrowSliderWidth, 43);

    modelPickerTY.frame:SetPoint("bottomleft", frame, "bottomleft", 20 + narrowSliderWidth, 43);
    modelPickerTY.frame:SetPoint("bottomright", frame, "bottomleft", 20 + (2 * narrowSliderWidth), 43);

    modelPickerTZ.frame:SetPoint("bottomleft", frame, "bottomleft", 25 + (2 * narrowSliderWidth), 43);
    modelPickerTZ.frame:SetPoint("bottomright", frame, "bottomleft", 25 + (3 * narrowSliderWidth), 43);

    modelPickerRX.frame:SetPoint("bottomleft", frame, "bottomleft", 30 + (3 * narrowSliderWidth), 43);
    modelPickerRX.frame:SetPoint("bottomright", frame, "bottomleft", 30 + (4 * narrowSliderWidth), 43);

    modelPickerRY.frame:SetPoint("bottomleft", frame, "bottomleft", 35 + (4 * narrowSliderWidth), 43);
    modelPickerRY.frame:SetPoint("bottomright", frame, "bottomleft", 35 + (5 * narrowSliderWidth), 43);

    modelPickerRZ.frame:SetPoint("bottomleft", frame, "bottomleft", 40 + (5 * narrowSliderWidth), 43);
    modelPickerRZ.frame:SetPoint("bottomright", frame, "bottomleft", 40 + (6 * narrowSliderWidth), 43);

    modelPickerUS.frame:SetPoint("bottomleft", frame, "bottomleft", 45 + (6 * narrowSliderWidth), 43);
    modelPickerUS.frame:SetPoint("bottomright", frame, "bottomleft", 45 + (7 * narrowSliderWidth), 43);

  end);
  group:SetLayout("fill");
  modelTree:SetTree(WeakAuras.ModelPaths);
  modelTree:SetCallback("OnGroupSelected", function(self, event, value, fileId)
    local path = string.gsub(value, "\001", "/");
    if(string.lower(string.sub(path, -3, -1)) == ".m2") then
      if (group.selectedValues.api) then
        group:PickSt(fileId);
      else
        group:Pick(fileId);
      end
    end
  end);
  group:AddChild(modelTree);

  local model = CreateFrame("PlayerModel", nil, group.content);
  model.SetTransformFixed = OptionsPrivate.Private.ModelSetTransformFixed
  model:SetAllPoints(modelTree.content);
  model:SetFrameStrata("FULLSCREEN");
  group.model = model;

  local startX, rotation
  local function OnUpdateScript()
    local uiScale, x = UIParent:GetEffectiveScale(), GetCursorPosition()
    local screenW, screenH = GetScreenWidth(), GetScreenHeight()
    local diffX = startX/uiScale - x/uiScale
    rotation = (rotation + 180 / screenW * diffX) % 360
    model:SetFacing(rad(rotation))
  end
  model:EnableMouse()
  model:SetScript("OnMouseDown", function(self)
    if not group.selectedValues.api then
      startX = GetCursorPosition()
      rotation = group.selectedValues.rotation or 0
      self:SetScript("OnUpdate", OnUpdateScript)
    end
  end)
  model:SetScript("OnMouseUp", function(self)
    if not group.selectedValues.api then
      self:SetScript("OnUpdate", nil)
      group:Pick(nil, nil, nil, nil, rotation)
    end
  end)

  local function SetStOnObject(object, model_fileId, model_tx, model_ty, model_tz, model_rx, model_ry, model_rz, model_us)
    if model_fileId then
      object.model_fileId = model_fileId
    end
    if model_tx then
      object.model_st_tx = model_tx
    end
    if model_ty then
      object.model_st_ty = model_ty
    end
    if model_tz then
      object.model_st_tz = model_tz
    end
    if model_rx then
      object.model_st_rx = model_rx
    end
    if model_ry then
      object.model_st_ry = model_ry
    end
    if model_rz then
      object.model_st_rz = model_rz
    end
    if model_us then
      object.model_st_us = model_us
    end
  end

  function group.PickSt(self, model_fileId, model_tx, model_ty, model_tz, model_rx, model_ry, model_rz, model_us)
    local valueFromPath = OptionsPrivate.Private.ValueFromPath
    self.selectedValues.model_fileId = model_fileId or self.selectedValues.model_fileId
    self.selectedValues.model_st_tx = model_tx or self.selectedValues.model_st_tx
    self.selectedValues.model_st_ty = model_ty or self.selectedValues.model_st_ty
    self.selectedValues.model_st_tz = model_tz or self.selectedValues.model_st_tz

    self.selectedValues.model_st_rx = model_rx or self.selectedValues.model_st_rx;
    self.selectedValues.model_st_ry = model_ry or self.selectedValues.model_st_ry;
    self.selectedValues.model_st_rz = model_rz or self.selectedValues.model_st_rz;

    self.selectedValues.model_st_us = model_us or self.selectedValues.model_st_us;

    WeakAuras.SetModel(self.model, nil, self.selectedValues.model_fileId)
    self.model:SetTransformFixed(self.selectedValues.model_st_tx / 1000, self.selectedValues.model_st_ty / 1000, self.selectedValues.model_st_tz / 1000,
      rad(self.selectedValues.model_st_rx), rad(self.selectedValues.model_st_ry), rad(self.selectedValues.model_st_rz),
      self.selectedValues.model_st_us / 1000);

    for child in OptionsPrivate.Private.TraverseLeafsOrAura(self.baseObject) do
      local object = valueFromPath(child, self.path)
      if(object) then
        SetStOnObject(object, model_fileId, model_tx, model_ty, model_tz, model_rx, model_ry, model_rz, model_us)
        WeakAuras.Add(child);
        WeakAuras.UpdateThumbnail(child);
      end
    end
  end

  local function SetOnObject(object, model_fileId, model_z, model_x, model_y, rotation)
    if model_fileId then
      object.model_fileId = model_fileId
    end
    if model_z then
      object.model_z = model_z
    end
    if model_x then
      object.model_x = model_x
    end
    if model_y then
      object.model_y = model_y
    end
    if rotation then
      object.rotation = rotation
    end
  end

  function group.Pick(self, model_fileId, model_z, model_x, model_y, rotation)
    local valueFromPath = OptionsPrivate.Private.ValueFromPath

    self.selectedValues.model_fileId = model_fileId or self.selectedValues.model_fileId
    self.selectedValues.model_x = model_x or self.selectedValues.model_x
    self.selectedValues.model_y = model_y or self.selectedValues.model_y
    self.selectedValues.model_z = model_z or self.selectedValues.model_z
    self.selectedValues.rotation = rotation or self.selectedValues.rotation

    WeakAuras.SetModel(self.model, nil, self.selectedValues.model_fileId)

    self.model:ClearTransform();
    self.model:SetPosition(self.selectedValues.model_z, self.selectedValues.model_x, self.selectedValues.model_y);
    self.model:SetFacing(rad(self.selectedValues.rotation));

    for child in OptionsPrivate.Private.TraverseLeafsOrAura(self.baseObject) do
      local object = valueFromPath(child, self.path)
      if(object) then
        SetOnObject(object, model_fileId, model_z, model_x, model_y, rotation)
        WeakAuras.Add(child)
        WeakAuras.UpdateThumbnail(child)
      end
    end
  end

  function group.Open(self, baseObject, path)
    local valueFromPath = OptionsPrivate.Private.ValueFromPath

    self.baseObject = baseObject
    self.path = path
    self.selectedValues = {}

    self.selectedValues.model_fileId = GetAll(baseObject, path, "model_fileId", "122968")

    WeakAuras.SetModel(self.model, nil, self.selectedValues.model_fileId)

    self.selectedValues.api = GetAll(baseObject, path, "api", false)
    self.selectedValues.model_st_tx = GetAll(baseObject, path, "model_st_tx", 0)
    self.selectedValues.model_st_ty = GetAll(baseObject, path, "model_st_ty", 0)
    self.selectedValues.model_st_tz = GetAll(baseObject, path, "model_st_tz", 0)

    self.selectedValues.model_st_rx = GetAll(baseObject, path, "model_st_rx", 0)
    self.selectedValues.model_st_ry = GetAll(baseObject, path, "model_st_ry", 0)
    self.selectedValues.model_st_rz = GetAll(baseObject, path, "model_st_rz", 0)

    self.selectedValues.model_st_us = GetAll(baseObject, path, "model_st_us", 0)

    self.selectedValues.model_x = GetAll(baseObject, path, "model_x", 0)
    self.selectedValues.model_y = GetAll(baseObject, path, "model_y", 0)
    self.selectedValues.model_z = GetAll(baseObject, path, "model_z", 0)
    self.selectedValues.rotation = GetAll(baseObject, path, "rotation", 0)


    if (self.selectedValues.api) then
      self.model:SetTransformFixed(self.selectedValues.model_st_tx / 1000, self.selectedValues.model_st_ty / 1000, self.selectedValues.model_st_tz / 1000,
        rad(self.selectedValues.model_st_rx), rad(self.selectedValues.model_st_ry), rad(self.selectedValues.model_st_rz),
        self.selectedValues.model_st_us / 1000);

      modelPickerTX:SetValue(self.selectedValues.model_st_tx);
      modelPickerTX.editbox:SetText(("%.2f"):format(self.selectedValues.model_st_tx));

      modelPickerTY:SetValue(self.selectedValues.model_st_ty);
      modelPickerTY.editbox:SetText(("%.2f"):format(self.selectedValues.model_st_ty));
      modelPickerTZ:SetValue(self.selectedValues.model_st_tz);
      modelPickerTZ.editbox:SetText(("%.2f"):format(self.selectedValues.model_st_tz));

      modelPickerRX:SetValue(self.selectedValues.model_st_rx);
      modelPickerRX.editbox:SetText(("%.2f"):format(self.selectedValues.model_st_rx));
      modelPickerRY:SetValue(self.selectedValues.model_st_ry);
      modelPickerRY.editbox:SetText(("%.2f"):format(self.selectedValues.model_st_ry));
      modelPickerRZ:SetValue(self.selectedValues.model_st_rz);
      modelPickerRZ.editbox:SetText(("%.2f"):format(self.selectedValues.model_st_rz));

      modelPickerUS:SetValue(self.selectedValues.model_st_us);
      modelPickerUS.editbox:SetText(("%.2f"):format(self.selectedValues.model_st_us));

      modelPickerZ.frame:Hide();
      modelPickerY.frame:Hide();
      modelPickerX.frame:Hide();
      modelPickerRotation.frame:Hide();

      modelPickerTX.frame:Show();
      modelPickerTY.frame:Show();
      modelPickerTZ.frame:Show();
      modelPickerRX.frame:Show();
      modelPickerRY.frame:Show();
      modelPickerRZ.frame:Show();
      modelPickerUS.frame:Show();
    else
      self.model:ClearTransform();
      self.model:SetPosition(self.selectedValues.model_z, self.selectedValues.model_x, self.selectedValues.model_y);
      self.model:SetFacing(rad(self.selectedValues.rotation));
      modelPickerZ:SetValue(self.selectedValues.model_z);
      modelPickerZ.editbox:SetText(("%.2f"):format(self.selectedValues.model_z));
      modelPickerX:SetValue(self.selectedValues.model_x);
      modelPickerX.editbox:SetText(("%.2f"):format(self.selectedValues.model_x));
      modelPickerY:SetValue(self.selectedValues.model_y);
      modelPickerY.editbox:SetText(("%.2f"):format(self.selectedValues.model_y));
      modelPickerRotation:SetValue(self.selectedValues.rotation);
      modelPickerRotation.editbox:SetText(("%.2f"):format(self.selectedValues.rotation));

      modelPickerZ.frame:Show();
      modelPickerY.frame:Show();
      modelPickerX.frame:Show();
      modelPickerRotation.frame:Show();

      modelPickerTX.frame:Hide();
      modelPickerTY.frame:Hide();
      modelPickerTZ.frame:Hide();
      modelPickerRX.frame:Hide();
      modelPickerRY.frame:Hide();
      modelPickerRZ.frame:Hide();
      modelPickerUS.frame:Hide();
    end

    if(baseObject.controlledChildren) then
      self.givenModelId = {};
      self.givenApi = {};
      self.givenZ = {};
      self.givenX = {};
      self.givenY = {};
      self.givenRotation = {};
      self.givenTX = {};
      self.givenTY = {};
      self.givenTZ = {};
      self.givenRX = {};
      self.givenRY = {};
      self.givenRZ = {};
      self.givenUS = {};
      for child in OptionsPrivate.Private.TraverseLeafs(baseObject) do
        local childId = child.id
        local object = valueFromPath(child, path)
        if(object) then
          self.givenModelId[childId] = object.model_fileId;
          self.givenApi[childId] = object.api
          if object.api then
            self.givenTX[childId] = object.model_st_tx;
            self.givenTY[childId] = object.model_st_ty;
            self.givenTZ[childId] = object.model_st_tz;
            self.givenRX[childId] = object.model_st_rx;
            self.givenRY[childId] = object.model_st_ry;
            self.givenRZ[childId] = object.model_st_rz;
            self.givenUS[childId] = object.model_st_us;
          else
            self.givenZ[childId] = object.model_z;
            self.givenX[childId] = object.model_x;
            self.givenY[childId] = object.model_y;
            self.givenRotation[childId] = object.rotation;
          end
        end
      end
    else
      local object = valueFromPath(baseObject, path)

      self.givenModelId = object.model_fileId;
      self.givenApi = object.api

      if object.api then
        self.givenTX = object.model_st_tx;
        self.givenTY = object.model_st_ty;
        self.givenTZ = object.model_st_tz;
        self.givenRX = object.model_st_rx;
        self.givenRY = object.model_st_ry;
        self.givenRZ = object.model_st_rz;
        self.givenUS = object.model_st_us;
      else
        self.givenZ = object.model_z;
        self.givenX = object.model_x;
        self.givenY = object.model_y;
        self.givenRotation = object.rotation;
      end
    end
    frame.window = "model";
    frame:UpdateFrameVisible()
  end

  function group.Close()
    frame.window = "default"
    frame:UpdateFrameVisible()
    WeakAuras.FillOptions()
  end

  function group.CancelClose()
    local valueFromPath = OptionsPrivate.Private.ValueFromPath
    if(group.baseObject.controlledChildren) then
      for child in OptionsPrivate.Private.TraverseLeafs(group.baseObject) do
        local childId = child.id
        local object = valueFromPath(child, group.path)
        if(object) then
          object.model_fileId = group.givenModelId[childId];
          object.api = group.givenApi[childId];
          if (object.api) then
            object.model_st_tx = group.givenTX[childId];
            object.model_st_ty = group.givenTY[childId];
            object.model_st_tz = group.givenTZ[childId];
            object.model_st_rx = group.givenRX[childId];
            object.model_st_ry = group.givenRY[childId];
            object.model_st_rz = group.givenRZ[childId];
            object.model_st_us = group.givenUS[childId];
          else
            object.model_z = group.givenZ[childId];
            object.model_x = group.givenX[childId];
            object.model_y = group.givenY[childId];
            object.rotation = group.givenRotation[childId];
          end
          WeakAuras.Add(child);
          WeakAuras.UpdateThumbnail(child);
        end
      end
    else
      local object = valueFromPath(group.baseObject, group.path)

      if(object) then
        object.model_fileId = group.givenModelId
        object.api = group.givenApi
        if (object.api) then
          object.model_st_tx = group.givenTX
          object.model_st_ty = group.givenTY
          object.model_st_tz = group.givenTZ
          object.model_st_rx = group.givenRX
          object.model_st_ry = group.givenRY
          object.model_st_rz = group.givenRZ
          object.model_st_us = group.givenUS
        else
          object.model_z = group.givenZ
          object.model_x = group.givenX
          object.model_y = group.givenY
          object.rotation = group.givenRotation
        end
        WeakAuras.Add(group.baseObject);
        WeakAuras.UpdateThumbnail(group.baseObject);
      end
    end
    group.Close();
  end

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  cancel:SetScript("OnClick", group.CancelClose);
  cancel:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -27, 20);
  cancel:SetHeight(20);
  cancel:SetWidth(100);
  cancel:SetText(L["Cancel"]);

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  close:SetScript("OnClick", group.Close);
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0);
  close:SetHeight(20);
  close:SetWidth(100);
  close:SetText(L["Okay"]);

  return group
end

function OptionsPrivate.ModelPicker(frame, noConstruct)
  modelPicker = modelPicker or (not noConstruct and ConstructModelPicker(frame))
  return modelPicker
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/ModelPicker.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/MoverSizer.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local createCenterLines = true --- Creates only the middle lines
local showNormalLines = false -- Show all alignment lines all the time
local highlightColor = { 1, 1, 0 } -- The color of lines that are we are currently aligned too
local gridHighlightColor = { 0.3, 1, 0.3}
local normalColor = { 0.3, 0.3, 0.6, } -- The color of lines if they aren't matched if showNormalLines is enabled
local gridColor = { 0.3, 0.6, 0.3 } -- The color of grid lines, if they aren't matched and enabled

-- Lua APIs
local pairs = pairs

-- WoW APIs
local IsShiftKeyDown, CreateFrame =  IsShiftKeyDown, CreateFrame

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local moversizer
local mover

local MAGNETIC_ALIGNMENT = 10
local function distance(num1, num2)
  return abs(num2 - num1)
end

local function EnsureTexture(self, texture)
  if texture then
    return texture
  else
    local ret = self:CreateTexture()
    ret:SetTexture("Interface\\GLUES\\CharacterSelect\\Glues-AddOn-Icons.blp")
    ret:SetWidth(16)
    ret:SetHeight(16)
    ret:SetTexCoord(0, 0.25, 0, 1)
    ret:SetVertexColor(1, 1, 1, 0.25)
    return ret
  end
end

local function moveOnePxl(direction)
  if mover and mover.moving then
    local data = mover.moving.data
    local physicalWidth, physicalHeight = GetPhysicalScreenSize();
    local oneX = GetScreenWidth() / physicalWidth
    local oneY = GetScreenHeight() / physicalHeight
    if data then
      if direction == "top" then
        data.yOffset = data.yOffset + oneY
      elseif direction == "bottom" then
        data.yOffset = data.yOffset - oneY
      elseif direction == "left" then
        data.xOffset = data.xOffset - oneX
      elseif direction == "right" then
        data.xOffset = data.xOffset + oneX
      end
      WeakAuras.Add(data, true)
      WeakAuras.UpdateThumbnail(data)
      OptionsPrivate.ResetMoverSizer()
      OptionsPrivate.Private.AddParents(data)
      WeakAuras.FillOptions()
    end
  end
end

local function ConstructMover(frame)
  local topAndBottom = CreateFrame("Frame", nil, frame)
  topAndBottom:SetClampedToScreen(true)
  topAndBottom:SetSize(25, 45)
  topAndBottom:SetPoint("LEFT", frame, "RIGHT", 1, 0)
  local top = CreateFrame("Button", nil, topAndBottom)
  top:SetSize(25, 25)
  top:SetPoint("TOP", topAndBottom)
  top:SetFrameStrata("BACKGROUND")
  local bottom = CreateFrame("Button", nil, topAndBottom)
  bottom:SetSize(25, 25)
  bottom:SetPoint("BOTTOM", topAndBottom)
  bottom:SetFrameStrata("BACKGROUND")

  local leftAndRight = CreateFrame("Frame", nil, frame)
  leftAndRight:SetClampedToScreen(true)
  leftAndRight:SetSize(45, 25)
  leftAndRight:SetPoint("TOP", frame, "BOTTOM", 0, 1)
  local left = CreateFrame("Button", nil, leftAndRight)
  left:SetSize(25, 25)
  left:SetPoint("LEFT", leftAndRight)
  left:SetFrameStrata("BACKGROUND")
  local right = CreateFrame("Button", nil, leftAndRight)
  right:SetSize(25, 25)
  right:SetPoint("RIGHT", leftAndRight)
  right:SetFrameStrata("BACKGROUND")

  top:SetNormalTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-up.blp")
  top:SetHighlightTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-highlight.blp")
  top:SetPushedTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-down.blp")
  top:SetScript("OnClick", function() moveOnePxl("top") end)

  bottom:SetNormalTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-up.blp")
  bottom:GetNormalTexture():SetTexCoord(0, 1, 1, 0)
  bottom:SetHighlightTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-highlight.blp")
  bottom:GetHighlightTexture():SetTexCoord(0, 1, 1, 0)
  bottom:SetPushedTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-down.blp")
  bottom:GetPushedTexture():SetTexCoord(0, 1, 1, 0)
  bottom:SetScript("OnClick", function() moveOnePxl("bottom") end)

  left:SetNormalTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-up.blp")
  left:GetNormalTexture():SetRotation(math.pi/2)
  left:SetHighlightTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-highlight.blp")
  left:GetHighlightTexture():SetRotation(math.pi/2)
  left:SetPushedTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-down.blp")
  left:GetPushedTexture():SetRotation(math.pi/2)
  left:SetScript("OnClick", function() moveOnePxl("left") end)

  right:SetNormalTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-up.blp")
  right:GetNormalTexture():SetRotation(-math.pi/2)
  right:SetHighlightTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-highlight.blp")
  right:GetHighlightTexture():SetRotation(-math.pi/2)
  right:SetPushedTexture("interface\\buttons\\ui-scrollbar-scrollupbutton-down.blp")
  right:GetPushedTexture():SetRotation(-math.pi/2)
  right:SetScript("OnClick", function() moveOnePxl("right") end)

  local arrow = CreateFrame("Frame", nil, frame)
  arrow:SetClampedToScreen(true)
  arrow:SetSize(196, 196)
  arrow:SetPoint("CENTER", frame, "CENTER")
  arrow:SetFrameStrata("HIGH")
  local arrowTexture = arrow:CreateTexture()
  arrowTexture:SetTexture("Interface\\Addons\\WeakAuras\\Media\\Textures\\offscreen.tga")
  arrowTexture:SetSize(128, 128)
  arrowTexture:SetPoint("CENTER", arrow, "CENTER")
  arrowTexture:SetVertexColor(0.8, 0.8, 0.2)
  arrowTexture:Hide()
  local offscreenText = arrow:CreateFontString(nil, "OVERLAY")
  offscreenText:SetFont(STANDARD_TEXT_FONT, 14, "THICKOUTLINE");
  offscreenText:SetText(L["Aura is\nOff Screen"])
  offscreenText:Hide()
  offscreenText:SetPoint("CENTER", arrow, "CENTER")

  return arrowTexture, offscreenText
end

local function ConstructSizer(frame)
  -- topright, bottomright, bottomleft, topleft

  local topright = CreateFrame("Frame", nil, frame)
  topright:EnableMouse()
  topright:SetWidth(16)
  topright:SetHeight(16)
  topright:SetPoint("TOPRIGHT", frame, "TOPRIGHT")

  local texTR1 = topright:CreateTexture(nil, "OVERLAY")
  texTR1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texTR1:SetBlendMode("ADD")
  texTR1:SetTexCoord(0.5, 0, 0, 0, 0.5, 1, 0, 1)
  texTR1:SetPoint("TOPRIGHT", topright, "TOPRIGHT", -3, -3)
  texTR1:SetPoint("BOTTOMLEFT", topright, "BOTTOM")

  local texTR2 = topright:CreateTexture(nil, "OVERLAY")
  texTR2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texTR2:SetBlendMode("ADD")
  texTR2:SetTexCoord(0, 0, 0, 1, 0.5, 0, 0.5, 1)
  texTR2:SetPoint("TOPRIGHT", texTR1, "TOPLEFT")
  texTR2:SetPoint("BOTTOMLEFT", topright, "LEFT")

  topright.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texTR1:Show()
    texTR2:Show()
  end
  topright.Clear = function()
    texTR1:Hide()
    texTR2:Hide()
  end

  local bottomright = CreateFrame("Frame", nil, frame)
  bottomright:EnableMouse()
  bottomright:SetWidth(16)
  bottomright:SetHeight(16)
  bottomright:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT")

  local texBR1 = bottomright:CreateTexture(nil, "OVERLAY")
  texBR1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texBR1:SetBlendMode("ADD")
  texBR1:SetTexCoord(1, 0, 0.5, 0, 1, 1, 0.5, 1)
  texBR1:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMRIGHT", -3, 3)
  texBR1:SetPoint("TOPLEFT", bottomright, "TOP")

  local texBR2 = bottomright:CreateTexture(nil, "OVERLAY")
  texBR2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texBR2:SetBlendMode("ADD")
  texBR2:SetTexCoord(0, 0, 0, 1, 0.5, 0, 0.5, 1)
  texBR2:SetPoint("BOTTOMRIGHT", texBR1, "BOTTOMLEFT")
  texBR2:SetPoint("TOPLEFT", bottomright, "LEFT")

  bottomright.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texBR1:Show()
    texBR2:Show()
  end
  bottomright.Clear = function()
    texBR1:Hide()
    texBR2:Hide()
  end

  local bottomleft = CreateFrame("Frame", nil, frame)
  bottomleft:EnableMouse()
  bottomleft:SetSize(16, 16)
  bottomleft:SetHeight(16)
  bottomleft:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT")

  local texBL1 = bottomleft:CreateTexture(nil, "OVERLAY")
  texBL1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texBL1:SetBlendMode("ADD")
  texBL1:SetTexCoord(1, 0, 0.5, 0, 1, 1, 0.5, 1)
  texBL1:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMLEFT", 3, 3)
  texBL1:SetPoint("TOPRIGHT", bottomleft, "TOP")

  local texBL2 = bottomleft:CreateTexture(nil, "OVERLAY")
  texBL2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texBL2:SetBlendMode("ADD")
  texBL2:SetTexCoord(0.5, 0, 0.5, 1, 1, 0, 1, 1)
  texBL2:SetPoint("BOTTOMLEFT", texBL1, "BOTTOMRIGHT")
  texBL2:SetPoint("TOPRIGHT", bottomleft, "RIGHT")

  bottomleft.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texBL1:Show()
    texBL2:Show()
  end
  bottomleft.Clear = function()
    texBL1:Hide()
    texBL2:Hide()
  end

  local topleft = CreateFrame("Frame", nil, frame)
  topleft:EnableMouse()
  topleft:SetWidth(16)
  topleft:SetHeight(16)
  topleft:SetPoint("TOPLEFT", frame, "TOPLEFT")

  local texTL1 = topleft:CreateTexture(nil, "OVERLAY")
  texTL1:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texTL1:SetBlendMode("ADD")
  texTL1:SetTexCoord(0.5, 0, 0, 0, 0.5, 1, 0, 1)
  texTL1:SetPoint("TOPLEFT", topleft, "TOPLEFT", 3, -3)
  texTL1:SetPoint("BOTTOMRIGHT", topleft, "BOTTOM")

  local texTL2 = topleft:CreateTexture(nil, "OVERLAY")
  texTL2:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texTL2:SetBlendMode("ADD")
  texTL2:SetTexCoord(0.5, 0, 0.5, 1, 1, 0, 1, 1)
  texTL2:SetPoint("TOPLEFT", texTL1, "TOPRIGHT")
  texTL2:SetPoint("BOTTOMRIGHT", topleft, "RIGHT")

  topleft.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texTL1:Show()
    texTL2:Show()
  end
  topleft.Clear = function()
    texTL1:Hide()
    texTL2:Hide()
  end

  -- top, right, bottom, left

  local top = CreateFrame("Frame", nil, frame)
  top:EnableMouse()
  top:SetHeight(8)
  top:SetPoint("TOPRIGHT", topright, "TOPLEFT")
  top:SetPoint("TOPLEFT", topleft, "TOPRIGHT")

  local texT = top:CreateTexture(nil, "OVERLAY")
  texT:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texT:SetBlendMode("ADD")
  texT:SetPoint("TOPRIGHT", topright, "TOPRIGHT", -3, -3)
  texT:SetPoint("BOTTOMLEFT", topleft, "LEFT", 3, 0)

  top.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texT:Show()
  end
  top.Clear = function()
    texT:Hide()
  end

  local right = CreateFrame("Frame", nil, frame)
  right:EnableMouse()
  right:SetWidth(8)
  right:SetPoint("BOTTOMRIGHT", bottomright, "TOPRIGHT")
  right:SetPoint("TOPRIGHT", topright, "BOTTOMRIGHT")

  local texR = right:CreateTexture(nil, "OVERLAY")
  texR:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texR:SetBlendMode("ADD")
  texR:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMRIGHT", -3, 3)
  texR:SetPoint("TOPLEFT", topright, "TOP", 0, -3)

  right.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texR:Show()
  end
  right.Clear = function()
    texR:Hide()
  end

  local bottom = CreateFrame("Frame", nil, frame)
  bottom:EnableMouse()
  bottom:SetHeight(8)
  bottom:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMRIGHT")
  bottom:SetPoint("BOTTOMRIGHT", bottomright, "BOTTOMLEFT")

  local texB = bottom:CreateTexture(nil, "OVERLAY")
  texB:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texB:SetBlendMode("ADD")
  texB:SetTexCoord(1, 0, 0, 0, 1, 1, 0, 1)
  texB:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMLEFT", 3, 3)
  texB:SetPoint("TOPRIGHT", bottomright, "RIGHT", -3, 0)

  bottom.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texB:Show()
  end
  bottom.Clear = function()
    texB:Hide()
  end

  local left = CreateFrame("Frame", nil, frame)
  left:EnableMouse()
  left:SetWidth(8)
  left:SetPoint("TOPLEFT", topleft, "BOTTOMLEFT")
  left:SetPoint("BOTTOMLEFT", bottomleft, "TOPLEFT")

  local texL = left:CreateTexture(nil, "OVERLAY")
  texL:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
  texL:SetBlendMode("ADD")
  texL:SetTexCoord(1, 0, 0, 0, 1, 1, 0, 1)
  texL:SetPoint("BOTTOMLEFT", bottomleft, "BOTTOMLEFT", 3, 3)
  texL:SetPoint("TOPRIGHT", topleft, "TOP", 0, -3)

  left.Highlight = function()
    if WeakAurasOptionsSaved.lockPositions then
      return
    end
    texL:Show()
  end
  left.Clear = function()
    texL:Hide()
  end

  -- return in cw order
  return top, topright, right, bottomright, bottom, bottomleft, left, topleft
end

--- @class AlignmentLineReference
--- @field id auraId
--- @field side "LEFT"|"RIGHT"|"TOP"|"BOTTOM"|"CENTERX"|"CENTERY" The side the reference
--- @field pos1 number The bottom position for vertical or the left position for horizontal lines
--- @field pos2 number The top position for vertical or the right position for horizontal lines

--- @class AlignmentLine
--- @field SetStartPoint fun(self: AlignmentLine, relativePoint: AnchorPoint, relativeTo: Region, offsetX: number?, offsetY: number?)
--- @field SetEndPoint fun(self: AlignmentLine, relativePoint: AnchorPoint, relativeTo: Region, offsetX: number?, offsetY: number?)
--- @field SetThickness fun(self: AlignmentLine, thickness: number)
--- @field SetHighlighted fun(self: AlignmentLine, highlight: boolean)

--- @class LineObjectPool
--- @field Acquire fun(self: LineObjectPool): AlignmentLine
--- @field Release fun(self: LineObjectPool, line: AlignmentLine)

--- @class LineInformation
--- @field position number
--- @field delta number
--- @field gridLine boolean
--- @field references AlignmentLineReference[]
--- @field highlightTextures Texture[]
--- @field line AlignmentLine?
--- @field SetStartPoint fun(self: LineInformation, relativePoint: AnchorPoint, relativeTo: Region, offsetX: number?, offsetY: number?)
--- @field SetEndPoint fun(self: LineInformation, relativePoint: AnchorPoint, relativeTo: Region, offsetX: number?, offsetY: number?)
--- @field SetThickness fun(self: LineInformation, thickness: number)
--- @field SetHighlighted fun(self: LineInformation, highlight: boolean)
--- @field Hide fun(self: LineInformation)
--- @field Show fun(self: LineInformation)
--- @field UpdateColor fun(self: LineInformation)
--- @field UpdateHighlight fun(self: LineInformation)
--- @field AcquireLine fun(self: LineInformation)
--- @field ReleaseLine fun(self: LineInformation)
--- @field Release fun(self: LineInformation)
--- @field Score fun(self: LineInformation, positions: table<"LEFT"|"RIGHT"|"TOP"|"BOTTOM"|"CENTERX"|"CENTERY", number>): number

--- @class AlignmentLines
local AlignmentLines = CreateFrame("Frame", nil, UIParent) --[[@as AlignmentLines]]
AlignmentLines:SetAllPoints(UIParent)
AlignmentLines:SetFrameStrata("BACKGROUND")

local HighlightFrame = CreateFrame("Frame", nil, UIParent)
HighlightFrame:SetAllPoints(UIParent)
HighlightFrame:SetFrameStrata("TOOLTIP")

--- @type LineObjectPool
AlignmentLines.linePool = CreateObjectPool(
  function(self)
    return AlignmentLines:CreateLine()
  end,
  function(self, line)
    line:Hide()
  end)

HighlightFrame.texturePool = CreateObjectPool(
  function(self)
    local tex = HighlightFrame:CreateTexture()
    tex:SetTexture("Interface\\BUTTONS\\UI-Listbox-Highlight.blp")
    tex:SetVertexColor(1, 1, 1, 0.3)
    return tex
  end,
  function(self, texture)
    texture:Hide()
    texture:ClearAllPoints()
  end)

--- @type fun(side: "LEFT"|"RIGHT"|"BOTTOM"|"TOP"|"CENTERX"|"CENTERY"): "LEFT"|"RIGHT"|"BOTTOM"|"TOP"|"CENTERX"|"CENTERY"
local function MirrorSide(side)
  if side == "LEFT" then
    return "RIGHT"
  elseif side == "RIGHT" then
    return "LEFT"
  elseif side == "TOP" then
    return "BOTTOM"
  elseif side == "BOTTOM" then
    return "TOP"
  else -- "CENTERX" or "CENTERY"
    return side
  end
end

--- @type fun(side: "LEFT"|"RIGHT"|"BOTTOM"|"TOP"|"CENTERX"|"CENTERY"): "LEFT"|"RIGHT"|"BOTTOM"|"TOP"|"CENTERX"|"CENTERY"|nil
local function Pos1Side(side)
  if side == "LEFT" or side == "RIGHT" or side == "CENTERX" then
    return "BOTTOM"
  elseif side == "TOP" or side == "BOTTOM" or side == "CENTERY" then
    return "LEFT"
  end
end

--- @type fun(side: "LEFT"|"RIGHT"|"BOTTOM"|"TOP"|"CENTERX"|"CENTERY"): "LEFT"|"RIGHT"|"BOTTOM"|"TOP"|"CENTERX"|"CENTERY"|nil
local function Pos2Side(side)
  if side == "LEFT" or side == "RIGHT" or side == "CENTERX" then
    return "TOP"
  elseif side == "TOP" or side == "BOTTOM" or side == "CENTERY" then
    return "RIGHT"
  end
end

--- @class LineInformation
local LineInformationFuncs = {
  SetStartPoint = function(self, relativePoint, relativeTo, offsetX, offsetY)
    self.startPoint = {relativePoint, relativeTo, offsetX, offsetY}
    if self.line then
      self.line:SetStartPoint(relativePoint, relativeTo, offsetX, offsetY)
    end
  end,
  SetEndPoint = function(self, relativePoint, relativeTo, offsetX, offsetY)
    self.endPoint = {relativePoint, relativeTo, offsetX, offsetY}
    if self.line then
      self.line:SetEndPoint(relativePoint, relativeTo, offsetX, offsetY)
    end
  end,
  SetThickness = function(self, thickness)
    self.thickness = thickness
    if self.line then
      self.line:SetThickness(thickness)
    end
  end,
  Show = function(self)
    if not self.line then
      self:AcquireLine()
    end
    self:UpdateColor()
    self.line:SetStartPoint(unpack(self.startPoint))
    self.line:SetEndPoint(unpack(self.endPoint))
    self.line:SetThickness(self.thickness)
    self.line:Show()
  end,
  SetHighlighted = function(self, highlight)
    if self.highlight == highlight then
      return
    end

    local needLine = highlight or showNormalLines
    self.highlight = highlight

    if needLine and not self.line then
      self:Show()
    elseif not needLine and self.line then
      self:ReleaseLine()
    end
    self:UpdateColor()
    self:UpdateHighlight()
  end,
  UpdateColor = function(self)
    if not self.line then
      return
    end

    if self.highlight then
      if self.gridLine then
        self.line:SetColorTexture(unpack(gridHighlightColor))
      else
        self.line:SetColorTexture(unpack(highlightColor))
      end
    else
      if self.gridLine then
        self.line:SetColorTexture(unpack(gridColor))
      else
        self.line:SetColorTexture(unpack(normalColor))
      end
    end
  end,
  UpdateHighlight = function(self)
    if self.highlight then
      for _, data in ipairs(self.references) do
        local region = WeakAuras.GetRegion(data.id)
        local texture = HighlightFrame.texturePool:Acquire()
        texture:SetAllPoints(region)
        texture:SetDrawLayer("ARTWORK", 7)
        texture:Show()
        tinsert(self.highlightTextures, texture)
      end
    else
      for _, texture in ipairs(self.highlightTextures) do
        HighlightFrame.texturePool:Release(texture)
      end
      wipe(self.highlightTextures)
    end
  end,
  AcquireLine = function(self)
    if not self.line then
      self.line = AlignmentLines.linePool:Acquire()
    end
  end,
  ReleaseLine = function(self)
    if self.line then
      AlignmentLines.linePool:Release(self.line)
      self.line = nil
    end
  end,
  Release = function(self)
    -- Clears any aura highlights
    self:SetHighlighted(false)
    self:ReleaseLine()
  end,
  AddReference = function(self, id, side, pos1, pos2)
    tinsert(self.references, {id = id, side = side, pos1 = pos1, pos2 = pos2})
  end,
  --- @type fun(self: LineInformation, positions: table<"LEFT"|"RIGHT"|"BOTTOM"|"TOP"|"CENTERX"|"CENTERY", number>) : number
  Score = function(self, positions)
    if self.gridLine then
      return 0 -- Prefer aura lines
    else
      local score = -1

      for _, ref in ipairs(self.references) do
        -- The line is within MAGNETIC_ALIGNMENT, otherwise we wouldn't be asked to score it
        -- This compares whether the line is for the same "side",
        -- by checking the distance to that side
        local auraPos = positions[ref.side]
        local mirrorPos = positions[MirrorSide(ref.side)]
        if auraPos then
          local dist = distance(auraPos, self.position)
          if dist < MAGNETIC_ALIGNMENT then
            -- Same side: 100 as a base, meaning these lines are heavily preferred to lines
            -- for other sides
            score = max(score, 100 + (MAGNETIC_ALIGNMENT - dist))
          elseif mirrorPos then
            dist = distance(mirrorPos, self.position)
            score = max(score, 10 + (MAGNETIC_ALIGNMENT - dist))
          end

          -- Now check how far away the reference is on the orthogonal direction
          -- Add up to 80 points for being near a reference
          local auraPos1 = positions[Pos1Side(ref.side)]
          local auraPos2 = positions[Pos2Side(ref.side)]
          if auraPos1 and auraPos2 then
            local minDistanceOrth = min(distance(auraPos1, ref.pos1), distance(auraPos2, ref.pos2))
            if minDistanceOrth < 10 * MAGNETIC_ALIGNMENT then
              score = score + 8 * (10 * MAGNETIC_ALIGNMENT - minDistanceOrth)
            end
          end
        end
      end
      return score
    end
  end,

}

--- @type fun(position: number, gridLine: boolean): LineInformation
local function CreateLineInformation(position, gridLine)
  local line = {}
  for k, f in pairs(LineInformationFuncs) do
    line[k] = f
  end
  line.position = position
  line.gridLine = gridLine
  line.references = {}
  line.highlightTextures = {}
  line.highlight = nil
  return line
end

--- @type table<number, LineInformation>
AlignmentLines.horizontalLines = {}
--- @type table<number, LineInformation>
AlignmentLines.verticalLines = {}

--- @type fun(input: number): number
local function RoundSmallDifference(input)
  local r = Round(input)
  if (abs(r - input) < 0.1) then
    return r
  end
  return input
end

--- @type fun(input: number): number
local function AlignToPixelX(virX)
  local physicalWidth, physicalHeight = GetPhysicalScreenSize();
  local virtualWidth = GetScreenWidth()
  local phyX = virX * physicalWidth / virtualWidth
  return Round(10 * Round(phyX) * virtualWidth / physicalWidth) / 10
end

--- @type fun(input: number): number
local function AlignToPixelY(virY)
  local physicalWidth, physicalHeight = GetPhysicalScreenSize();
  local virtualHeight = GetScreenHeight()
  local phyY = virY * physicalHeight / virtualHeight
  return Round(10 * Round(phyY) * virtualHeight / physicalHeight) / 10
end

---@param self AlignmentLines
---@param sizerPoint AnchorPoint?
AlignmentLines.CreateMiddleLines = function(self, sizerPoint)
  if not createCenterLines then
    return
  end

  local midX, midY = UIParent:GetCenter()
  midX = RoundSmallDifference(midX)
  midY = RoundSmallDifference(midY)
  if not sizerPoint or sizerPoint:find("LEFT", 1) or sizerPoint:find("RIGHT", 1) then
    local line = CreateLineInformation(midX, true)
    line:SetStartPoint("TOPLEFT", UIParent, midX, 0)
    line:SetEndPoint("BOTTOMLEFT", UIParent, midX, 0)
    line:SetThickness(2)
    self.verticalLines[midX] = line
  end

  if not sizerPoint or sizerPoint:find("BOTTOM") or sizerPoint:find("TOP") then
    local line = CreateLineInformation(midY, true)
    line:SetStartPoint("BOTTOMLEFT", UIParent, 0, midY)
    line:SetEndPoint("BOTTOMRIGHT", UIParent, 0, midY)
    line:SetThickness(2)
    self.horizontalLines[midY] = line
  end
end

--- @type fun(self: AlignmentLines, data: auraData, sizerPoint: AnchorPoint?): LineInformation, LineInformation
AlignmentLines.CreateLineInformation = function(self, data, sizerPoint)
  local addVertical = not sizerPoint or sizerPoint:find("LEFT", 1) or sizerPoint:find("RIGHT", 1)
  local addHorizontal = not sizerPoint or sizerPoint:find("BOTTOM", 1) or sizerPoint:find("TOP", 1)

  --- @type LineInformation, LineInformation
  local horizontalLines, verticalLines = {}, {}
  --- @type table<auraId, boolean>
  local skipIds = {}
  for child in OptionsPrivate.Private.TraverseAll(data) do
    skipIds[child.id] = true
  end

  for id, v in pairs(OptionsPrivate.displayButtons) do
    local region = WeakAuras.GetRegion(v.data.id)
    if not skipIds[id]
       and v.view.visibility >= 1
       and region and not region:IsAnchoringRestricted()
       and v.data.regionType ~= "group"
       and v.data.regionType ~= "dynamicgroup"
    then
      local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale()
      local left = region:GetLeft()
      left = left and AlignToPixelX(left * scale) or nil
      local right = region:GetRight()
      right = right and AlignToPixelX(right * scale) or nil
      local top = region:GetTop()
      top = top and AlignToPixelY(top * scale) or nil
      local bottom = region:GetBottom()
      bottom = bottom and AlignToPixelY(bottom * scale) or nil
      local centerX, centerY = region:GetCenter()
      centerX = centerX and AlignToPixelX(centerX * scale) or nil
      centerY = centerY and AlignToPixelY(centerY * scale) or nil

      if not IsControlKeyDown() then
        if addVertical then
          if left and bottom and top then
            local leftLine = CreateLineInformation(left, false)
            leftLine:AddReference(id, "LEFT", bottom, top)
            tinsert(verticalLines, leftLine)
          end

          if right and bottom and top then
            local rightLine = CreateLineInformation(right, false)
            rightLine:AddReference(id, "RIGHT", bottom, top)
            tinsert(verticalLines, rightLine)
          end
        end
        if addHorizontal then
          if top and left and right then
            local topLine = CreateLineInformation(top, false)
            topLine:AddReference(id, "TOP", left, right)
            tinsert(horizontalLines, topLine)
          end

          if bottom and left and right then
            local bottomLine = CreateLineInformation(bottom, false)
            bottomLine:AddReference(id, "BOTTOM", left, right)
            tinsert(horizontalLines, bottomLine)
          end
        end
      else
        if addVertical then
          if centerX and bottom and top then
            local xLine = CreateLineInformation(centerX, false)
            xLine:AddReference(id, "CENTERX", bottom, top)
            tinsert(verticalLines, xLine)
          end
        end
        if addHorizontal then
          if centerY and left and right then
            local yLine = CreateLineInformation(centerY, false)
            yLine:AddReference(id, "CENTERY", left, right)
            tinsert(horizontalLines, yLine)
          end
        end
      end
    end
  end

  table.sort(verticalLines, function(a, b) return a.position < b.position end)
  table.sort(horizontalLines, function(a, b) return a.position < b.position end)

  return self:MergeLineInformation(verticalLines), self:MergeLineInformation(horizontalLines)
end

--- @type fun(self: AlignmentLines, lines: LineInformation): LineInformation
AlignmentLines.MergeLineInformation = function(self, lines)
  local startIndex
  local startPos
  -- Add a line at infinity at the end, this makes the loop easier
  tinsert(lines, {position = math.huge})

  --- @type LineInformation
  local result = {}
  for index, line in ipairs(lines) do
    if not startPos then
      startPos = line.position
      startIndex = index
    else
      if (line.position - startPos) >= 1 then
        if startIndex then
          -- This line is too far away from the last lines to merge,
          -- So merge from startIndex to index - 1
          local lineToInsert = lines[startIndex]
          local positionSum = lineToInsert.position
          for i = startIndex + 1, index - 1 do
            local lineToMerge = lines[i]
            positionSum = positionSum + lineToMerge.position
            tinsert(lineToInsert.references, lineToMerge.references[1])
          end
          lineToInsert.position = positionSum / (index - startIndex)
          tinsert(result, lineToInsert)
          -- Now start a potential new merge from this line
          startPos = line.position
          startIndex = index
        end
      else
        -- Will be merged later
      end
    end
  end
  -- And remove the infinity line at the end
  lines[#lines] = nil

  return result
end

---@param self AlignmentLines
AlignmentLines.CleanUpLines = function(self)
  for _, line in pairs(self.horizontalLines) do
    line:Release()
  end

  for _, line in pairs(self.verticalLines) do
    line:Release()
  end

  wipe(self.horizontalLines)
  wipe(self.verticalLines)
end

---@param self AlignmentLines
---@param data auraData
---@param sizerPoint AnchorPoint?
AlignmentLines.CreateLines = function(self, data, sizerPoint)
  self:CleanUpLines()

  local align = (WeakAurasOptionsSaved.magnetAlign and not IsShiftKeyDown())
                    or (not WeakAurasOptionsSaved.magnetAlign and IsShiftKeyDown())
  if align then
    self:CreateMiddleLines()

    local auraVerticalLinesInfo, auraHorizontalLinesInfo = self:CreateLineInformation(data, sizerPoint)

    for _, lineInfo in ipairs(auraVerticalLinesInfo) do
      local x = lineInfo.position
      if self.verticalLines[floor(x)] or self.verticalLines[ceil(x)] then
        -- Grid lines are always on integer values
        -- Ignore a grid line that is close enough is already there
      else
        lineInfo:SetStartPoint("TOPLEFT", UIParent, x, 0)
        lineInfo:SetEndPoint("BOTTOMLEFT", UIParent, x, 0)
        lineInfo:SetThickness(2)
        self.verticalLines[x] = lineInfo
      end
    end

    for _, lineInfo in ipairs(auraHorizontalLinesInfo) do
      local y = lineInfo.position
      if self.horizontalLines[floor(y)] or self.horizontalLines[ceil(y)] then
        -- Grid lines are always on integer values
        -- Ignore a grid line that is close enough is already there
      else
        lineInfo:SetStartPoint("BOTTOMLEFT", UIParent, 0, y)
        lineInfo:SetEndPoint("BOTTOMRIGHT", UIParent, 0, y)
        lineInfo:SetThickness(2)
        self.horizontalLines[y] = lineInfo
      end
    end
  end
end

---@param lines AlignmentLine[]
---@param positions table<"LEFT"|"RIGHT"|"TOP"|"BOTTOM"|"CENTERX"|"CENTERY", number>
---       The positions of the aura, that are used to score lines
---@param auraSize number?
---       The size of the aura, this is used to highlight additional lines that exactly
---       auraSize away
---@return number? -- The delta
local function SelectLines(lines, positions, auraSize)
  if #lines == 0 then
    -- Nothing to do
  elseif #lines == 1 then
    lines[1]:SetHighlighted(true)
    return lines[1].delta
  else
    --- @type number
    local bestScore = -1
    --- @type AlignmentLine?
    local bestLine = nil
    for _, line in ipairs(lines) do
      local lineScore = line:Score(positions)
      if lineScore > bestScore then
        bestScore = lineScore
        bestLine = line
      end
    end

    for _, line in ipairs(lines) do
      if line == bestLine then
        line:SetHighlighted(true)
      elseif bestLine then
        local diffBetweenLines = distance(line.position, bestLine.position)
        if auraSize and distance(diffBetweenLines, auraSize) < 1 then
          -- Other line is the as far away as the aura is wide
          line:SetHighlighted(true)
        else
          line:SetHighlighted(false)
        end
      else
        line:SetHighlighted(false)
      end
    end
    return bestLine and bestLine.delta
  end
end

AlignmentLines.ShowLinesFor = function(self, ctrlKey, region, sizePoint)
  local align = (WeakAurasOptionsSaved.magnetAlign and not IsShiftKeyDown())
                    or (not WeakAurasOptionsSaved.magnetAlign and IsShiftKeyDown())
  if not align then
    return
  end

  local scale = region:GetEffectiveScale() / UIParent:GetScale()

  local centerX, centerY = region:GetCenter()
  centerX, centerY = centerX * scale, centerY * scale
  local left, right = region:GetLeft() * scale, region:GetRight() * scale
  local top, bottom = region:GetTop() * scale, region:GetBottom() * scale

  if region.regionType == "group" then
    left = left + region.blx * scale
    right = right + region.trx * scale
    bottom = bottom + region.bly * scale
    top = top + region.try * scale
    centerX = (left + right) / 2
    centerY = (bottom + top) / 2
  end

  local positions = {
    LEFT = left,
    RIGHT = right,
    TOP = top,
    BOTTOM = bottom,
    CENTERX = centerX,
    CENTERY = centerY
  }

  local verticalPotentials = {}
  local horizontalPotentials = {}
  if sizePoint then
    local sizeX = sizePoint:find("LEFT", 1) and left or right
    local sizeY = sizePoint:find("TOP", 1) and top or bottom

    for pos, line in pairs(self.verticalLines) do
      if distance(sizeX, pos) < MAGNETIC_ALIGNMENT then
        line.delta = pos - sizeX
        tinsert(verticalPotentials, line)
      else
        line:SetHighlighted(false)
      end
    end

    for pos, line in pairs(self.horizontalLines) do
      if distance(sizeY, pos) < MAGNETIC_ALIGNMENT then
        line.delta = pos - sizeY
        tinsert(horizontalPotentials, line)
      else
        line:SetHighlighted(false)
      end
    end

    mover.verticalDelta = SelectLines(verticalPotentials, positions)
    mover.horizontalDelta = SelectLines(horizontalPotentials, positions)
  else
    if ctrlKey then
      for pos, line in pairs(self.verticalLines) do
        if distance(centerX, pos) < MAGNETIC_ALIGNMENT then
          line.delta = pos - centerX
          tinsert(verticalPotentials, line)
        else
          line:SetHighlighted(false)
        end
      end

      for pos, line in pairs(self.horizontalLines) do
        if distance(centerY, pos) < MAGNETIC_ALIGNMENT then
          line.delta = pos - centerY
          tinsert(horizontalPotentials, line)
        else
          line:SetHighlighted(false)
        end
      end
      mover.verticalDelta = SelectLines(verticalPotentials, positions)
      mover.horizontalDelta = SelectLines(horizontalPotentials, positions)
    else
      for pos, line in pairs(self.verticalLines) do
        if distance(left, pos) < MAGNETIC_ALIGNMENT then
          line.delta = pos - left
          tinsert(verticalPotentials, line)
        elseif distance(right, pos) < MAGNETIC_ALIGNMENT then
          line.delta = pos - right
          tinsert(verticalPotentials, line)
        else
          line:SetHighlighted(false)
        end
      end

      for pos, line in pairs(self.horizontalLines) do
        if distance(bottom, pos) < MAGNETIC_ALIGNMENT then
          line.delta = pos - bottom
          tinsert(horizontalPotentials, line)
        elseif distance(top, pos) < MAGNETIC_ALIGNMENT then
          line.delta = pos - top
          tinsert(horizontalPotentials, line)
        else
          line:SetHighlighted(false)
        end
      end

      local auraWidth = right - left
      local auraHeight = top - bottom
      mover.verticalDelta = SelectLines(verticalPotentials, positions, auraWidth)
      mover.horizontalDelta = SelectLines(horizontalPotentials, positions, auraHeight)
    end
  end
end

local function ConstructMoverSizer(parent)
  local frame = CreateFrame("Frame", nil, parent, "BackdropTemplate")
  frame:SetBackdrop({
    edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
    edgeSize = 12,
    insets = {left = 0, right = 0, top = 0, bottom = 0}
  })
  frame:EnableMouse()

  frame.top, frame.topright, frame.right, frame.bottomright, frame.bottom, frame.bottomleft, frame.left, frame.topleft
  = ConstructSizer(frame)

  frame.arrowTexture, frame.offscreenText = ConstructMover(frame)

  frame.top.Clear()
  frame.topright.Clear()
  frame.right.Clear()
  frame.bottomright.Clear()
  frame.bottom.Clear()
  frame.bottomleft.Clear()
  frame.left.Clear()
  frame.topleft.Clear()

  local mover = CreateFrame("Frame", nil, frame)
  mover:EnableMouse()
  mover.moving = {}
  mover.interims = {}
  mover.selfPointIcon = mover:CreateTexture()
  mover.selfPointIcon:SetTexture("Interface\\GLUES\\CharacterSelect\\Glues-AddOn-Icons.blp")
  mover.selfPointIcon:SetWidth(16)
  mover.selfPointIcon:SetHeight(16)
  mover.selfPointIcon:SetTexCoord(0, 0.25, 0, 1)
  mover.anchorPointIcon = mover:CreateTexture()
  mover.anchorPointIcon:SetTexture("Interface\\GLUES\\CharacterSelect\\Glues-AddOn-Icons.blp")
  mover.anchorPointIcon:SetWidth(16)
  mover.anchorPointIcon:SetHeight(16)
  mover.anchorPointIcon:SetTexCoord(0, 0.25, 0, 1)

  local moverText = mover:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  mover.text = moverText
  moverText:Hide()

  local sizerText = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  frame.text = sizerText
  sizerText:Hide()

  frame.ScaleCorners = function(self, width, height)
    local limit = math.min(width, height) + 16
    local size = 16
    if limit <= 40 then
      size = limit * (2/5)
    end
    frame.bottomleft:SetWidth(size)
    frame.bottomleft:SetHeight(size)
    frame.bottomright:SetWidth(size)
    frame.bottomright:SetHeight(size)
    frame.topright:SetWidth(size)
    frame.topright:SetHeight(size)
    frame.topleft:SetWidth(size)
    frame.topleft:SetHeight(size)
  end

  frame.ReAnchor = function(self)
    if mover.moving.region then
      self:AnchorPoints(mover.moving.region, mover.moving.data)
    end
  end

  frame.AnchorPoints = function(self, region, data)
    local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale()
    if data.regionType == "group" then
      mover:SetWidth((region.trx - region.blx) * scale)
      mover:SetHeight((region.try - region.bly) * scale)
    else
      mover:SetWidth(region:GetWidth() * scale)
      mover:SetHeight(region:GetHeight() * scale)
    end
  end

  frame.GetCurrentId = function(self)
    return self.currentId
  end

  frame.SizingSetData = function(self, data, width, height, alignDeltaX, alignDeltaY, scale)
    alignDeltaX = alignDeltaX or 0
    alignDeltaY = alignDeltaY or 0

    local deltaWidth = width - data.width
    local deltaHeight = height - data.height

    local auraSelfPoint = data.selfPoint
    local moverSizePoint = mover.sizePoint

    local parent = data.parent
    if parent then
      local parentData = WeakAuras.GetData(parent)
      if parentData == "dynamicgroup" then
        -- If the aura is in a dynamic group then we don't want to set xOffset/yOffset at all.
        -- These settings ensure that
        auraSelfPoint = "TOPRIGHT"
        moverSizePoint = "BOTTOMLEFT"
      end
    end

    if auraSelfPoint:find("LEFT", 1) then
      if moverSizePoint:find("LEFT", 1) then
        data.xOffset = data.xOffset - deltaWidth + alignDeltaX / scale
        data.width = width - alignDeltaX / scale
      elseif moverSizePoint:find("RIGHT", 1) then
        data.width = width + alignDeltaX / scale
      end
    elseif auraSelfPoint:find("RIGHT", 1) then
      if moverSizePoint:find("LEFT", 1) then
        data.width = width - alignDeltaX / scale
      elseif moverSizePoint:find("RIGHT", 1) then
        data.xOffset = data.xOffset + deltaWidth + alignDeltaX / scale
        data.width = width + alignDeltaX / scale
      end
    else -- CENTER
      if moverSizePoint:find("LEFT", 1) then
        data.xOffset = data.xOffset - deltaWidth / 2 + alignDeltaX / 2 / scale
        data.width = width - alignDeltaX / scale
      else
        data.xOffset = data.xOffset + deltaWidth / 2 + alignDeltaX / 2 / scale
        data.width = width + alignDeltaX / scale
      end
    end

    if auraSelfPoint:find("BOTTOM", 1) then
      if moverSizePoint:find("BOTTOM", 1) then
        data.yOffset = data.yOffset - deltaHeight + alignDeltaY / scale
        data.height = height - alignDeltaY / scale
      elseif moverSizePoint:find("TOP", 1) then
        data.height = height + alignDeltaY / scale
      end
    elseif auraSelfPoint:find("TOP", 1) then
      if moverSizePoint:find("BOTTOM", 1) then
        data.height = height - alignDeltaY / scale
      elseif moverSizePoint:find("TOP", 1) then
        data.yOffset = data.yOffset + deltaHeight + alignDeltaY / scale
        data.height = height + alignDeltaY / scale
      end
    else -- CENTER
      if moverSizePoint:find("BOTTOM", 1) then
        data.yOffset = data.yOffset - deltaHeight / 2 + alignDeltaY / 2 / scale
        data.height = height - alignDeltaY / scale
      else
        data.yOffset = data.yOffset + deltaHeight / 2 + alignDeltaY / 2 / scale
        data.height = height + alignDeltaY / scale
      end
    end
  end

  frame.SetToRegion = function(self, region, data)
    frame.currentId = data.id
    local scale = region:GetEffectiveScale() / UIParent:GetEffectiveScale()
    mover.moving.region = region
    mover.moving.data = data
    mover.onUpdate(mover, 0)
    local ok, selfPoint, anchor, anchorPoint, xOff, yOff = pcall(region.GetPoint, region, 1)
    if not ok then
      return
    end
    self:Show()

    mover.selfPoint, mover.anchor, mover.anchorPoint = selfPoint, anchor, anchorPoint

    xOff = xOff or 0
    yOff = yOff or 0
    mover:ClearAllPoints()
    frame:ClearAllPoints()
    if data.regionType == "group" then
      local blx, bly, trx, try = region:GetBoundingRect()
      mover:SetWidth((trx - blx) * scale)
      mover:SetHeight((try - bly) * scale)

      mover:SetPoint("BOTTOMLEFT", mover.anchor or UIParent, mover.anchorPoint or "CENTER",
                     (xOff + region.blx) * scale, (yOff + region.bly) * scale)
    else
      mover:SetWidth(region:GetWidth() * scale)
      mover:SetHeight(region:GetHeight() * scale)
      mover:SetPoint(mover.selfPoint or "CENTER", mover.anchor or UIParent, mover.anchorPoint or "CENTER",
                     xOff * scale, yOff * scale)
    end
    frame:SetPoint("BOTTOMLEFT", mover, "BOTTOMLEFT", -8, -8)
    frame:SetPoint("TOPRIGHT", mover, "TOPRIGHT", 8, 8)
    frame:ScaleCorners(region:GetWidth(), region:GetHeight())
    local regionStrata = region:GetFrameStrata()
    if regionStrata then
      local strata = math.min(tIndexOf(OptionsPrivate.Private.frame_strata_types, regionStrata) + 1, 9)
      frame:SetFrameStrata(OptionsPrivate.Private.frame_strata_types[strata])
      mover:SetFrameStrata(OptionsPrivate.Private.frame_strata_types[strata])
      frame:SetFrameLevel(region:GetFrameLevel() + 1)
      mover:SetFrameLevel(region:GetFrameLevel() + 1)
    end

    local db = OptionsPrivate.savedVars.db
    mover.startMoving = function()
      if WeakAurasOptionsSaved.lockPositions then
        return
      end
      OptionsPrivate.Private.CancelAnimation(region, true, true, true, true, true)
      mover:ClearAllPoints()
      if data.regionType == "group" then
        mover:SetPoint("BOTTOMLEFT", region, mover.anchorPoint, region.blx * scale, region.bly * scale)
      else
        mover:SetPoint(mover.selfPoint, region, mover.selfPoint)
      end
      region:StartMoving()
      mover.isMoving = true
      mover.onUpdate(mover, 0)
      mover.text:Show()
      -- build list of alignment coordinates
      AlignmentLines:CreateLines(mover.moving.data)
      AlignmentLines:Show()
      HighlightFrame:Show()
    end

    mover.doneMoving = function(self, event, key)
      if event == "MODIFIER_STATE_CHANGED" then
        if key == "LCTRL" or key == "RCTRL" or key == "LSHIFT" or key == "RSHIFT" then
          AlignmentLines:CleanUpLines()
          AlignmentLines:CreateLines(mover.moving.data, mover.sizePoint)
          AlignmentLines:Show()
          HighlightFrame:Show()
        end
        return
      end

      if not mover.isMoving then
        return
      end
      region:StopMovingOrSizing()
      mover.isMoving = false
      mover.text:Hide()
      AlignmentLines:CleanUpLines()
      AlignmentLines:Hide()
      HighlightFrame:Hide()

      local align = (WeakAurasOptionsSaved.magnetAlign and not IsShiftKeyDown())
                    or (not WeakAurasOptionsSaved.magnetAlign and IsShiftKeyDown())

      local xDelta = 0
      local yDelta = 0
      if align then
        xDelta = mover.verticalDelta or 0
        yDelta = mover.horizontalDelta or 0
      end

      if data.xOffset and data.yOffset then
        local selfX, selfY = mover.selfPointIcon:GetCenter()
        local anchorX, anchorY = mover.anchorPointIcon:GetCenter()
        local dX = selfX - anchorX
        local dY = selfY - anchorY
        data.xOffset = dX / scale + xDelta / scale
        data.yOffset = dY / scale + yDelta / scale
      end
      region:ResetPosition()
      WeakAuras.Add(data)
      OptionsPrivate.Private.AddParents(data)
      WeakAuras.UpdateThumbnail(data)

      local xOff, yOff
      mover.selfPoint, mover.anchor, mover.anchorPoint, xOff, yOff = region:GetPoint(1)
      xOff = xOff or 0
      yOff = yOff or 0
      mover:ClearAllPoints()
      if data.regionType == "group" then
        mover:SetWidth((region.trx - region.blx) * scale)
        mover:SetHeight((region.try - region.bly) * scale)
        mover:SetPoint("BOTTOMLEFT", mover.anchor, mover.anchorPoint,
                       (xOff + region.blx) * scale, (yOff + region.bly) * scale)
      else
        mover:SetWidth(region:GetWidth() * scale)
        mover:SetHeight(region:GetHeight() * scale)
        mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, xOff * scale, yOff * scale)
      end
      frame.text:Hide()
      frame:SetScript("OnUpdate", nil)

      WeakAuras.FillOptions()
      OptionsPrivate.Private.Animate("display", data.uid, "main", data.animation.main,
                                     OptionsPrivate.Private.EnsureRegion(data.id), false, nil, true)
    end

    if data.parent and db.displays[data.parent] and db.displays[data.parent].regionType == "dynamicgroup" then
      mover:SetScript("OnMouseDown", nil)
      mover:SetScript("OnMouseUp", nil)
      mover:SetScript("OnEvent", nil)
      mover:SetScript("OnHide", nil)
    else
      mover:SetScript("OnMouseDown", mover.startMoving)
      mover:SetScript("OnMouseUp", mover.doneMoving)
      mover:SetScript("OnEvent", mover.doneMoving)
      mover:SetScript("OnHide", mover.doneMoving)
    end

    if region:IsResizable() then
      frame.startSizing = function(point)
        if WeakAurasOptionsSaved.lockPositions then
          return
        end
        mover.isMoving = true
        OptionsPrivate.Private.CancelAnimation(region, true, true, true, true, true)
        region:StartSizing(point)
        frame.text:ClearAllPoints()
        frame.text:SetPoint("CENTER", frame, "CENTER", 0, -15)
        frame.text:Show()
        mover:ClearAllPoints()
        mover:SetAllPoints(region)
        frame:SetScript("OnUpdate", function()
          frame.text:SetText(("(%.2f, %.2f)"):format(region:GetWidth(), region:GetHeight()))
          if data.width and data.height then
            frame:SizingSetData(data, region:GetWidth(), region:GetHeight(), 0, 0, scale)
          end
          region:ResetPosition()
          WeakAuras.Add(data, true)
          frame:ScaleCorners(region:GetWidth(), region:GetHeight())
          WeakAuras.FillOptions()
        end)

        AlignmentLines:CreateLines(mover.moving.data, point)
        AlignmentLines:Show()
        HighlightFrame:Show()
        mover.sizePoint = point
      end

      frame.doneSizing = function()
        if not mover.sizePoint then
          return
        end
        mover.isMoving = false
        region:StopMovingOrSizing()

        AlignmentLines:CleanUpLines()
        AlignmentLines:Hide()
        HighlightFrame:Hide()

        local width = region:GetWidth()
        local height = region:GetHeight()

        local align = (WeakAurasOptionsSaved.magnetAlign and not IsShiftKeyDown())
                      or (not WeakAurasOptionsSaved.magnetAlign and IsShiftKeyDown())

        local deltaX = 0
        local deltaY = 0
        if align then
          deltaX = mover.verticalDelta or 0
          deltaY = mover.horizontalDelta or 0
        end

        frame:SizingSetData(data, width, height, deltaX, deltaY, scale)

        region:ResetPosition()
        WeakAuras.Add(data, true)
        OptionsPrivate.Private.AddParents(data)
        WeakAuras.UpdateThumbnail(data)

        frame:ScaleCorners(region:GetWidth(), region:GetHeight())
        local xOff, yOff
        mover.selfPoint, mover.anchor, mover.anchorPoint, xOff, yOff = region:GetPoint(1)
        xOff = xOff or 0
        yOff = yOff or 0
        mover:ClearAllPoints()
        if data.regionType == "group" then
          mover:SetWidth((region.trx - region.blx) * scale)
          mover:SetHeight((region.try - region.bly) * scale)
          mover:SetPoint("BOTTOMLEFT", mover.anchor, mover.anchorPoint,
                         (xOff + region.blx) * scale,
                         (yOff + region.bly) * scale)
        else
          mover:SetWidth(region:GetWidth() * scale)
          mover:SetHeight(region:GetHeight() * scale)
          mover:SetPoint(mover.selfPoint, mover.anchor, mover.anchorPoint, xOff * scale, yOff * scale)
        end
        frame.text:Hide()
        frame:SetScript("OnUpdate", nil)
        WeakAuras.FillOptions()
        OptionsPrivate.Private.Animate("display", data.uid, "main", data.animation.main,
                                       OptionsPrivate.Private.EnsureRegion(data.id), false, nil, true)
        mover.sizePoint = nil
      end

      frame.bottomleft:SetScript("OnMouseDown", function() frame.startSizing("BOTTOMLEFT") end)
      frame.bottomleft:SetScript("OnMouseUp", function() frame.doneSizing("BOTTOMLEFT") end)
      frame.bottomleft:SetScript("OnEnter", frame.bottomleft.Highlight)
      frame.bottomleft:SetScript("OnLeave", frame.bottomleft.Clear)
      frame.bottom:SetScript("OnMouseDown", function() frame.startSizing("BOTTOM") end)
      frame.bottom:SetScript("OnMouseUp", function() frame.doneSizing("BOTTOM") end)
      frame.bottom:SetScript("OnEnter", frame.bottom.Highlight)
      frame.bottom:SetScript("OnLeave", frame.bottom.Clear)
      frame.bottomright:SetScript("OnMouseDown", function() frame.startSizing("BOTTOMRIGHT") end)
      frame.bottomright:SetScript("OnMouseUp", function() frame.doneSizing("BOTTOMRIGHT") end)
      frame.bottomright:SetScript("OnEnter", frame.bottomright.Highlight)
      frame.bottomright:SetScript("OnLeave", frame.bottomright.Clear)
      frame.right:SetScript("OnMouseDown", function() frame.startSizing("RIGHT") end)
      frame.right:SetScript("OnMouseUp", function() frame.doneSizing("RIGHT") end)
      frame.right:SetScript("OnEnter", frame.right.Highlight)
      frame.right:SetScript("OnLeave", frame.right.Clear)
      frame.topright:SetScript("OnMouseDown", function() frame.startSizing("TOPRIGHT") end)
      frame.topright:SetScript("OnMouseUp", function() frame.doneSizing("TOPRIGHT") end)
      frame.topright:SetScript("OnEnter", frame.topright.Highlight)
      frame.topright:SetScript("OnLeave", frame.topright.Clear)
      frame.top:SetScript("OnMouseDown", function() frame.startSizing("TOP") end)
      frame.top:SetScript("OnMouseUp", function() frame.doneSizing("TOP") end)
      frame.top:SetScript("OnEnter", frame.top.Highlight)
      frame.top:SetScript("OnLeave", frame.top.Clear)
      frame.topleft:SetScript("OnMouseDown", function() frame.startSizing("TOPLEFT") end)
      frame.topleft:SetScript("OnMouseUp", function() frame.doneSizing("TOPLEFT") end)
      frame.topleft:SetScript("OnEnter", frame.topleft.Highlight)
      frame.topleft:SetScript("OnLeave", frame.topleft.Clear)
      frame.left:SetScript("OnMouseDown", function() frame.startSizing("LEFT") end)
      frame.left:SetScript("OnMouseUp", function() frame.doneSizing("LEFT") end)
      frame.left:SetScript("OnEnter", frame.left.Highlight)
      frame.left:SetScript("OnLeave", frame.left.Clear)

      frame.bottomleft:Show()
      frame.bottom:Show()
      frame.bottomright:Show()
      frame.right:Show()
      frame.topright:Show()
      frame.top:Show()
      frame.topleft:Show()
      frame.left:Show()
    else
      frame.bottomleft:Hide()
      frame.bottom:Hide()
      frame.bottomright:Hide()
      frame.right:Hide()
      frame.topright:Hide()
      frame.top:Hide()
      frame.topleft:Hide()
      frame.left:Hide()
    end
    frame:Show()
  end

  mover.onUpdate = function(self, elaps)
    if not IsShiftKeyDown() then
      self.goalAlpha = 1
    else
      self.goalAlpha = 0.1
    end

    if self.currentAlpha ~= self.goalAlpha then
      self.currentAlpha = self.currentAlpha or self:GetAlpha()
      local newAlpha = (self.currentAlpha < self.goalAlpha) and self.currentAlpha + (elaps * 4) or self.currentAlpha - (elaps * 4)
      newAlpha = (newAlpha > 1 and 1) or (newAlpha < 0.1 and 0.1) or newAlpha
      mover:SetAlpha(newAlpha)
      frame:SetAlpha(newAlpha)
      self.currentAlpha = newAlpha
    end

    local db = OptionsPrivate.savedVars.db
    local region = self.moving.region
    local data = self.moving.data
    if not self.isMoving then
      local ok, selfPoint, anchor, anchorPoint = pcall(region.GetPoint, region, 1)
      if not ok then
        self:Hide()
        return
      end
      self.selfPoint, self.anchor, self.anchorPoint = selfPoint, anchor, anchorPoint
    end
    self.selfPointIcon:ClearAllPoints()
    self.selfPointIcon:SetPoint("CENTER", region, self.selfPoint)
    local selfX, selfY = self.selfPointIcon:GetCenter()
    selfX, selfY = selfX or 0, selfY or 0
    self.anchorPointIcon:ClearAllPoints()
    self.anchorPointIcon:SetPoint("CENTER", self.anchor, self.anchorPoint)
    local anchorX, anchorY = self.anchorPointIcon:GetCenter()
    anchorX, anchorY = anchorX or 0, anchorY or 0
    if data.parent and db.displays[data.parent] and db.displays[data.parent].regionType == "dynamicgroup" then
      self.selfPointIcon:Hide()
      self.anchorPointIcon:Hide()
    else
      self.selfPointIcon:Show()
      self.anchorPointIcon:Show()
    end

    local dX = selfX - anchorX
    local dY = selfY - anchorY
    local distance = sqrt(dX^2 + dY^2)
    local angle = atan2(dY, dX)

    local numInterim = floor(distance/40)

    for _, texture in pairs(self.interims) do
      texture:Hide()
    end
    for i = 1, numInterim  do
      local x = (distance - (i * 40)) * cos(angle)
      local y = (distance - (i * 40)) * sin(angle)
      self.interims[i] = EnsureTexture(self, self.interims[i])
      self.interims[i]:ClearAllPoints()
      self.interims[i]:SetPoint("CENTER", self.anchorPointIcon, "CENTER", x, y)
      self.interims[i]:Show()
    end

    frame.arrowTexture:Hide()
    frame.offscreenText:Hide()

    -- Check if the center is offscreen
    -- How many pixels of the aura need to be visible
    local margin = 30
    local x, y = mover:GetCenter()
    if x and y then
      if mover:GetRight() < margin or mover:GetLeft() + margin > GetScreenWidth() or mover:GetTop() < 20 or mover:GetBottom() + margin > GetScreenHeight() then
        local arrowX, arrowY = frame.arrowTexture:GetCenter()
        local arrowAngle = atan2(y - arrowY, x - arrowX)
        frame.offscreenText:Show()
        frame.arrowTexture:Show()
        frame.arrowTexture:SetRotation( (arrowAngle - 90) / 180 * math.pi)
      end
    end

    local regionScale = self.moving.region:GetScale()
    self.text:SetText(("(%.2f, %.2f)"):format(dX*1/regionScale, dY*1/regionScale))
    local midX = (distance / 2) * cos(angle)
    local midY = (distance / 2) * sin(angle)
    self.text:SetPoint("CENTER", self.anchorPointIcon, "CENTER", midX, midY)
    local left, right, top, bottom = frame:GetLeft(), frame:GetRight(), frame:GetTop(), frame:GetBottom()
    if (midX > 0 and (self.text:GetRight() or 0) > (left or 0))
    or (midX < 0 and (self.text:GetLeft() or 0) < (right or 0))
    then
      if midY > 0 and (self.text:GetTop() or 0) > (top or 0) then
        midY = midY - ((self.text:GetTop() or 0) - (bottom or 0))
      elseif midY < 0 and (self.text:GetBottom() or 0) < (top or 0) then
        midY = midY + ((top or 0) - (self.text:GetBottom() or 0))
      end
    end
    self.text:SetPoint("CENTER", self.anchorPointIcon, "CENTER", midX, midY)
    if self.isMoving then
      AlignmentLines:ShowLinesFor(IsControlKeyDown(), region, mover.sizePoint)
    end
  end

  frame.OptionsOpened = function()
    mover:Show()
    mover:RegisterEvent("MODIFIER_STATE_CHANGED")
    mover:SetScript("OnUpdate", mover.onUpdate)
    AlignmentLines:Show()
    HighlightFrame:Show()
  end

  frame.OptionsClosed = function()
    if frame.doneSizing then
      frame.doneSizing()
    end
    if mover.doneMoving then
      mover.doneMoving()
    end
    mover:UnregisterEvent("MODIFIER_STATE_CHANGED")
    mover:SetScript("OnUpdate", nil)
    mover:Hide()
    AlignmentLines:Hide()
    HighlightFrame:Hide()
  end

  return frame, mover
end

function OptionsPrivate.MoverSizer(parent)
  if not moversizer or not mover then
    moversizer, mover = ConstructMoverSizer(parent)
  end
  return moversizer, mover
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/MoverSizer.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/OptionsFrame.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local tinsert, tremove, wipe = table.insert, table.remove, wipe
local pairs, type, error = pairs, type, error
local _G = _G

-- WoW APIs
local GetScreenWidth, GetScreenHeight, CreateFrame, UnitName
  = GetScreenWidth, GetScreenHeight, CreateFrame, UnitName

local AceGUI = LibStub("AceGUI-3.0")
local AceConfigDialog = LibStub("AceConfigDialog-3.0")
local AceConfigRegistry = LibStub("AceConfigRegistry-3.0")
local LibDD = LibStub:GetLibrary("LibUIDropDownMenu-4.0")
local SharedMedia = LibStub("LibSharedMedia-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local displayButtons = OptionsPrivate.displayButtons
local tempGroup = OptionsPrivate.tempGroup
local aceOptions = {}

local function CreateFrameSizer(frame, callback, position)
  callback = callback or (function() end)

  local left, right, top, bottom, xOffset1, yOffset1, xOffset2, yOffset2
  if position == "BOTTOMLEFT" then
    left, right, top, bottom = 1, 0, 0, 1
    xOffset1, yOffset1 = 1, 1
    xOffset2, yOffset2 = 0, 0
  elseif position == "BOTTOMRIGHT" then
    left, right, top, bottom = 0, 1, 0, 1
    xOffset1, yOffset1 = 0, 1
    xOffset2, yOffset2 = -1, 0
  elseif position == "TOPLEFT" then
    left, right, top, bottom = 1, 0, 1, 0
    xOffset1, yOffset1 = 1, 0
    xOffset2, yOffset2 = 0, -1
  elseif position == "TOPRIGHT" then
    left, right, top, bottom = 0, 1, 1, 0
    xOffset1, yOffset1 = 0, 0
    xOffset2, yOffset2 = -1, -1
  end

  local handle = CreateFrame("Button", nil, frame)
  handle:SetPoint(position, frame)
  handle:SetSize(25, 25)
  handle:EnableMouse()

  handle:SetScript("OnMouseDown", function()
    frame:StartSizing(position)
  end)

  handle:SetScript("OnMouseUp", function()
    frame:StopMovingOrSizing()
    callback()
  end)

  local normal = handle:CreateTexture(nil, "OVERLAY")
  normal:SetTexture("Interface\\ChatFrame\\UI-ChatIM-SizeGrabber-Up")
  normal:SetTexCoord(left, right, top, bottom)
  normal:SetPoint("BOTTOMLEFT", handle, xOffset1, yOffset1)
  normal:SetPoint("TOPRIGHT", handle, xOffset2, yOffset2)
  handle:SetNormalTexture(normal)

  local pushed = handle:CreateTexture(nil, "OVERLAY")
  pushed:SetTexture("Interface\\ChatFrame\\UI-ChatIM-SizeGrabber-Down")
  pushed:SetTexCoord(left, right, top, bottom)
  pushed:SetPoint("BOTTOMLEFT", handle, xOffset1, yOffset1)
  pushed:SetPoint("TOPRIGHT", handle, xOffset2, yOffset2)
  handle:SetPushedTexture(pushed)

  local highlight = handle:CreateTexture(nil, "OVERLAY")
  highlight:SetTexture("Interface\\ChatFrame\\UI-ChatIM-SizeGrabber-Highlight")
  highlight:SetTexCoord(left, right, top, bottom)
  highlight:SetPoint("BOTTOMLEFT", handle, xOffset1, yOffset1)
  highlight:SetPoint("TOPRIGHT", handle, xOffset2, yOffset2)
  handle:SetHighlightTexture(highlight)

  return handle
end

local defaultWidth = 830
local defaultHeight = 665
local minWidth = 750
local minHeight = 240



function OptionsPrivate.CreateFrame()
  LibDD:Create_UIDropDownMenu("WeakAuras_DropDownMenu", nil)
  local frame
  local db = OptionsPrivate.savedVars.db
  local odb = OptionsPrivate.savedVars.odb

  frame = CreateFrame("Frame", "WeakAurasOptions", UIParent, "PortraitFrameTemplate")
  local color = CreateColorFromHexString("ff1f1e21") -- PANEL_BACKGROUND_COLOR
  local r, g, b = color:GetRGB()
  frame.Bg:SetColorTexture(r, g, b, 0.8)
  frame.Bg.colorTexture = {r, g, b, 0.8}

  function OptionsPrivate.SetTitle(title)
    local text = "WeakAuras " .. WeakAuras.versionString
    if title and title ~= "" then
      text = ("%s - %s"):format(text, title)
    end
    WeakAurasOptionsTitleText:SetText(text)
  end

  tinsert(UISpecialFrames, frame:GetName())
  frame:EnableMouse(true)
  frame:SetMovable(true)
  frame:SetResizable(true)
  frame:SetResizeBounds(minWidth, minHeight)
  frame:SetFrameStrata("DIALOG")
  -- Workaround classic issue

  local serverTime = C_DateAndTime.GetServerTimeLocal()
  if serverTime >= 1748736000 -- June 1.
     and serverTime <= 1751328000 -- July 1.
  then
    WeakAurasOptionsPortrait:SetTexture([[Interface\AddOns\WeakAuras\Media\Textures\logo_256_round_pride.tga]])
  else
    WeakAurasOptionsPortrait:SetTexture([[Interface\AddOns\WeakAuras\Media\Textures\logo_256_round.tga]])
  end

  frame.window = "default"

  local xOffset, yOffset

  if db.frame then
    -- Convert from old settings to new
    odb.frame = db.frame
    if odb.frame.xOffset and odb.frame.yOffset then
      odb.frame.xOffset = odb.frame.xOffset + GetScreenWidth() - (odb.frame.width or defaultWidth) / 2
      odb.frame.yOffset = odb.frame.yOffset + GetScreenHeight()
    end
    db.frame = nil
  end

  if odb.frame then
    xOffset, yOffset = odb.frame.xOffset, odb.frame.yOffset
  end

  if not (xOffset and yOffset) then
    xOffset = GetScreenWidth() / 2
    yOffset = GetScreenHeight() - defaultHeight / 2
  end

  frame:SetPoint("TOP", UIParent, "BOTTOMLEFT", xOffset, yOffset)
  frame:Hide()

  frame:SetScript("OnHide", function()
    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()

    OptionsPrivate.Private.ClearFakeStates()

    for id, data in pairs(OptionsPrivate.Private.regions) do
      if data.region then
        data.region:Collapse()
        data.region:OptionsClosed()
        if OptionsPrivate.Private.clones[id] then
          for _, cloneRegion in pairs(OptionsPrivate.Private.clones[id]) do
            cloneRegion:Collapse()
            cloneRegion:OptionsClosed()
          end
        end
      end
    end

    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
    OptionsPrivate.Private.Resume()

    if OptionsPrivate.Private.mouseFrame then
      OptionsPrivate.Private.mouseFrame:OptionsClosed()
    end

    if OptionsPrivate.Private.personalRessourceDisplayFrame then
      OptionsPrivate.Private.personalRessourceDisplayFrame:OptionsClosed()
    end

    if frame.dynamicTextCodesFrame  then
      frame.dynamicTextCodesFrame:Hide()
    end

    if frame.moversizer then
      frame.moversizer:OptionsClosed()
    end
  end)

  local width, height

  if odb.frame then
    width, height = odb.frame.width, odb.frame.height
  end

  if not (width and height) then
    width, height = defaultWidth, defaultHeight
  end

  width = max(width, minWidth)
  height = max(height, minHeight)
  frame:SetWidth(width)
  frame:SetHeight(height)


  OptionsPrivate.SetTitle()

  local function commitWindowChanges()
    if not frame.minimized then
      local xOffset = frame:GetRight()-(frame:GetWidth()/2)
      local yOffset = frame:GetTop()
      odb.frame = odb.frame or {}
      odb.frame.xOffset = xOffset
      odb.frame.yOffset = yOffset
      odb.frame.width = frame:GetWidth()
      odb.frame.height = frame:GetHeight()
    end
  end

  if not frame.TitleContainer then
    frame.TitleContainer = CreateFrame("Frame", nil, frame)
    frame.TitleContainer:SetAllPoints(frame.TitleBg)
  end

  frame.TitleContainer:SetScript("OnMouseDown", function()
    frame:StartMoving()
  end)
  frame.TitleContainer:SetScript("OnMouseUp", function()
    frame:StopMovingOrSizing()
    commitWindowChanges()
  end)


  frame.bottomRightResizer = CreateFrameSizer(frame, commitWindowChanges, "BOTTOMRIGHT")

  frame.UpdateFrameVisible = function(self)
    self.tipPopup:Hide()
    if self.minimized then
      WeakAurasOptionsTitleText:Hide()
      self.buttonsContainer.frame:Hide()
      for _, fn in ipairs({"TexturePicker", "IconPicker", "ModelPicker", "ImportExport", "TextEditor", "CodeReview", "UpdateFrame", "DebugLog"}) do
        local obj = OptionsPrivate[fn](self, true)
        if obj then
          obj.frame:Hide()
        end
      end
      if self.newView then
        self.newView.frame:Hide()
      end
      self.container.frame:Hide()

      self.loadProgress:Hide()
      self.toolbarContainer:Hide()
      self.filterInput:Hide();
      self.tipFrame:Hide()
      self:HideTip()
      self.bottomRightResizer:Hide()
      self.dynamicTextCodesFrame:Hide()
    else
      WeakAurasOptionsTitleText:Show()
      self.bottomRightResizer:Show()
      if self.window == "default" then
        OptionsPrivate.SetTitle()
        self.buttonsContainer.frame:Show()
        self.container.frame:Show()
        self:ShowTip()
      else
        self.buttonsContainer.frame:Hide()
        self.container.frame:Hide()
        self.dynamicTextCodesFrame:Hide()
        self:HideTip()
      end
      local widgets = {
        { window = "texture",      title = L["Texture Picker"],       fn = "TexturePicker" },
        { window = "icon",         title = L["Icon Picker"],          fn = "IconPicker" },
        { window = "model",        title = L["Model Picker"],         fn = "ModelPicker" },
        { window = "importexport", title = L["Import / Export"],      fn = "ImportExport" },
        { window = "texteditor",   title = L["Code Editor"],          fn = "TextEditor" },
        { window = "codereview",   title = L["Custom Code Viewer"],   fn = "CodeReview" },
        { window = "debuglog",     title = L["Debug Log"],            fn = "DebugLog" },
        { window = "update",       title = L["Update"],               fn = "UpdateFrame" },
      }

      for _, widget in ipairs(widgets) do
        local obj = OptionsPrivate[widget.fn](self, true)
        if self.window == widget.window then
          OptionsPrivate.SetTitle(widget.title)
          if obj then
            obj.frame:Show()
          end
        else
          if obj then
            obj.frame:Hide()
          end
        end
      end

      if self.window == "newView" then
        OptionsPrivate.SetTitle(L["New Template"])
        self.newView.frame:Show()
      else
        if self.newView then
          self.newView.frame:Hide()
        end
      end
      if self.window == "default" then
        if self.loadProgessVisible then
          self.loadProgress:Show()
          self.toolbarContainer:Hide()
          self.filterInput:Hide();
        else
          self.loadProgress:Hide()
          self.toolbarContainer:Show()
          self.filterInput:Show();
          --self.filterInputClear:Show();
        end
      else
        self.loadProgress:Hide()
        self.toolbarContainer:Hide()
        self.filterInput:Hide();
      end
    end
  end



  local minimizebutton = CreateFrame("Button", nil, frame, "MaximizeMinimizeButtonFrameTemplate")
  minimizebutton:SetFrameLevel(frame.TitleContainer:GetFrameLevel() + 1)
  minimizebutton:SetPoint("RIGHT", frame.CloseButton, "LEFT", WeakAuras.IsClassicOrCataOrMists() and 10 or 0, 0)
  minimizebutton:SetOnMaximizedCallback(function()
    frame.minimized = false
    local right, top = frame:GetRight(), frame:GetTop()
    frame:ClearAllPoints()
    frame:SetPoint("TOPRIGHT", UIParent, "BOTTOMLEFT", right, top)
    frame:SetHeight(odb.frame and odb.frame.height or defaultHeight)
    frame:SetWidth(odb.frame and odb.frame.width or defaultWidth)
    frame.buttonsScroll:DoLayout()
    frame:UpdateFrameVisible()
  end)
  minimizebutton:SetOnMinimizedCallback(function()
    commitWindowChanges()
    frame.minimized = true
    local right, top = frame:GetRight(), frame:GetTop()
    frame:ClearAllPoints()
    frame:SetPoint("TOPRIGHT", UIParent, "BOTTOMLEFT", right, top)
    frame:SetHeight(75)
    frame:SetWidth(160)
    frame:UpdateFrameVisible()
  end)

  local tipFrame = CreateFrame("Frame", nil, frame)
  tipFrame:SetPoint("TOPLEFT", frame, "BOTTOMLEFT", 17, 30)
  tipFrame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 10)
  tipFrame:Hide()
  frame.tipFrame = tipFrame

  local tipPopup = CreateFrame("Frame", nil, frame, "BackdropTemplate")
  tipPopup:SetFrameStrata("FULLSCREEN")
  tipPopup:SetBackdrop({
    bgFile = "Interface\\Tooltips\\UI-Tooltip-Background",
    edgeFile = "Interface\\Tooltips\\UI-Tooltip-Border",
    tile = true,
    tileSize = 16,
    edgeSize = 16,
    insets = { left = 4, right = 4, top = 4, bottom = 4 }
  })
  tipPopup:SetBackdropColor(0, 0, 0, 0.8)
  --tipPopup:SetHeight(100)
  tipPopup:Hide()
  frame.tipPopup = tipPopup

  local tipPopupTitle = tipPopup:CreateFontString(nil, "BACKGROUND", "GameFontNormalLarge")
  tipPopupTitle:SetPoint("TOPLEFT", tipPopup, "TOPLEFT", 10, -10)
  tipPopupTitle:SetPoint("TOPRIGHT", tipPopup, "TOPRIGHT", -10, -10)
  tipPopupTitle:SetJustifyH("LEFT")
  tipPopupTitle:SetJustifyV("TOP")

  local tipPopupLabel = tipPopup:CreateFontString(nil, "BACKGROUND", "GameFontWhite")
  local fontPath = SharedMedia:Fetch("font", "Fira Sans Medium")
  if (fontPath) then
    tipPopupLabel:SetFont(fontPath, 12)
  end
  tipPopupLabel:SetPoint("TOPLEFT", tipPopupTitle, "BOTTOMLEFT", 0, -6)
  tipPopupLabel:SetPoint("TOPRIGHT", tipPopupTitle, "BOTTOMRIGHT", 0, -6)
  tipPopupLabel:SetJustifyH("LEFT")
  tipPopupLabel:SetJustifyV("TOP")

  local tipPopupLabelCJ = tipPopup:CreateFontString(nil, "BACKGROUND", "GameFontWhite")
  tipPopupLabelCJ:SetFont("Fonts\\ARKai_T.ttf", 12)
  tipPopupLabelCJ:SetPoint("TOPLEFT", tipPopupLabel, "BOTTOMLEFT", 0, 0)
  tipPopupLabelCJ:SetPoint("TOPRIGHT", tipPopupLabel, "BOTTOMRIGHT", 0, 0)
  tipPopupLabelCJ:SetJustifyH("LEFT")
  tipPopupLabelCJ:SetJustifyV("TOP")

  local tipPopupLabelK = tipPopup:CreateFontString(nil, "BACKGROUND", "GameFontWhite")
  tipPopupLabelK:SetFont("Fonts\\K_Pagetext.TTF", 12)
  tipPopupLabelK:SetPoint("TOPLEFT", tipPopupLabelCJ, "BOTTOMLEFT", 0, 0)
  tipPopupLabelK:SetPoint("TOPRIGHT", tipPopupLabelCJ, "BOTTOMRIGHT", 0, 0)
  tipPopupLabelK:SetJustifyH("LEFT")
  tipPopupLabelK:SetJustifyV("TOP")

  local urlWidget = CreateFrame("EditBox", nil, tipPopup, "InputBoxTemplate")
  urlWidget:SetFont(STANDARD_TEXT_FONT, 12, "")
  urlWidget:SetPoint("TOPLEFT", tipPopupLabelK, "BOTTOMLEFT", 6, 0)
  urlWidget:SetPoint("TOPRIGHT", tipPopupLabelK, "BOTTOMRIGHT", 0, 0)
  urlWidget:SetScript("OnChar", function() urlWidget:SetText(urlWidget.text); urlWidget:HighlightText(); end);
  urlWidget:SetScript("OnMouseUp", function() urlWidget:HighlightText(); end);
  urlWidget:SetScript("OnEscapePressed", function() tipPopup:Hide() end)
  urlWidget:SetHeight(34)

  local tipPopupCtrlC = tipPopup:CreateFontString(nil, "BACKGROUND", "GameFontWhite")
  tipPopupCtrlC:SetPoint("TOPLEFT", urlWidget, "BOTTOMLEFT", -6, 0)
  tipPopupCtrlC:SetPoint("TOPRIGHT", urlWidget, "BOTTOMRIGHT", 0, 0)
  tipPopupCtrlC:SetJustifyH("LEFT")
  tipPopupCtrlC:SetJustifyV("TOP")
  tipPopupCtrlC:SetText(L["Press Ctrl+C to copy the URL"])

  --- @type fun(referenceWidget: frame, title: string, texture: string, url: string, description: string, descriptionCJ: string?, descriptionK: string?, rightAligned: boolean?, width: number?)
  local function ToggleTip(referenceWidget, url, title, description, descriptionCJ, descriptionK, rightAligned, width)
    width = width or 400
    if tipPopup:IsVisible() and urlWidget.text == url then
      tipPopup:Hide()
      return
    end
    urlWidget.text = url
    urlWidget:SetText(url)
    tipPopupTitle:SetText(title)
    tipPopupLabel:SetText(description)
    tipPopupLabelCJ:SetText(descriptionCJ)
    tipPopupLabelK:SetText(descriptionK)
    urlWidget:HighlightText()

    tipPopup:ClearAllPoints();
    if rightAligned then
      tipPopup:SetPoint("BOTTOMRIGHT", referenceWidget, "TOPRIGHT", 6, 4)
    else
      tipPopup:SetPoint("BOTTOMLEFT", referenceWidget, "TOPLEFT", -6, 4)
    end

    tipPopup:SetWidth(width)
    tipPopup:Show()
    tipPopup:SetHeight(26 + tipPopupTitle:GetHeight() + tipPopupLabel:GetHeight() + tipPopupLabelCJ:GetHeight() + tipPopupLabelK:GetHeight()
                       + urlWidget:GetHeight() + tipPopupCtrlC:GetHeight())
    -- This does somehow fix an issue where the first popup after a game restart doesn't show up.
    -- This isn't reproducable after a simple ui reload, so no idea what goes wrong, but with this line here,
    -- it seems to work.
    tipPopupLabel:GetRect()
    tipPopupLabelCJ:GetRect()
    tipPopupLabelK:GetRect()
  end

  OptionsPrivate.ToggleTip = ToggleTip

  --- @type fun(title: string, texture: string, url: string, description: string, descriptionCJ: string?, descriptionK: string?, rightAligned: boolean?, width: number?)
  local addFooter = function(title, texture, url, description, descriptionCJ, descriptionK, rightAligned, width)
    local button = AceGUI:Create("WeakAurasToolbarButton")
    button:SetSmallFont(true)
    button:SetText(title)
    button:SetTexture(texture)
    button:SetCallback("OnClick", function()
      ToggleTip(button.frame, url, title, description, descriptionCJ, descriptionK, rightAligned, width)
    end)
    button.frame:Show()
    return button.frame
  end

  local function lineWrapDiscordList(list)
    local patreonLines = {}
    local lineLength = 0
    local currentLine = {}
    for _, patreon in ipairs(list) do
      if lineLength + #patreon + 2 > 130 then
        tinsert(patreonLines, table.concat(currentLine, ", ") .. ", ")
        currentLine = {}
        tinsert(currentLine, patreon)
        lineLength = #patreon + 2
      else
        lineLength = lineLength + #patreon + 2
        tinsert(currentLine, patreon)
      end
    end
    if #currentLine > 0 then
      tinsert(patreonLines, table.concat(currentLine, ", "))
    end
    return table.concat(patreonLines, "\n")
  end

  local thanksList = L["We thank"] .. "\n"
                     .. L["All maintainers of the libraries we use, especially:"] .. "\n"
                     .. " " .. L["Ace: Funkeh, Nevcairiel"] .. "\n"
                     .. " " .. L["LibCompress: Galmok"]  .. "\n"
                     .. " " .. L["LibCustomGlow: Dooez"] .. "\n"
                     .. " " .. L["LibDeflate: Yoursafety"] .. "\n"
                     .. " " .. L["LibDispel: Simpy"] .. "\n"
                     .. " " .. L["LibSerialize: Sanjo"] .. "\n"
                     .. " " .. L["LibSpecialization: Funkeh"] .. "\n"
                     .. " " .. L["Our translators (too many to name)"] .. "\n"
                     .. " " .. L["And our Patreons, Discord Regulars and Subscribers, and Friends of the Addon:"] .. "\n"

  thanksList = thanksList .. lineWrapDiscordList(OptionsPrivate.Private.DiscordList)

  local footerSpacing = 4
  local thanksListCJ = lineWrapDiscordList(OptionsPrivate.Private.DiscordListCJ)
  local thanksListK = lineWrapDiscordList(OptionsPrivate.Private.DiscordListK)

  local discordButton = addFooter(L["Discord"], [[Interface\AddOns\WeakAuras\Media\Textures\discord.tga]], "https://discord.gg/weakauras",
            L["Chat with WeakAuras experts on our Discord server."])
  discordButton:SetParent(tipFrame)
  discordButton:SetPoint("LEFT", tipFrame, "LEFT")

  local documentationButton = addFooter(L["Documentation"], [[Interface\AddOns\WeakAuras\Media\Textures\GitHub.tga]], "https://github.com/WeakAuras/WeakAuras2/wiki",
            L["Check out our wiki for a large collection of examples and snippets."])
  documentationButton:SetParent(tipFrame)
  documentationButton:SetPoint("LEFT", discordButton, "RIGHT", footerSpacing, 0)

  local thanksButton = addFooter(L["Thanks"], [[Interface\AddOns\WeakAuras\Media\Textures\waheart.tga]],
                                 "https://www.patreon.com/WeakAuras", thanksList, thanksListCJ, thanksListK, nil, 800)
  thanksButton:SetParent(tipFrame)
  thanksButton:SetPoint("LEFT", documentationButton, "RIGHT", footerSpacing, 0)

  if OptionsPrivate.changelog then
    local changelog
    if OptionsPrivate.changelog.highlightText then
      changelog = L["Highlights"] .. "\n" .. OptionsPrivate.changelog.highlightText
    else
      changelog = OptionsPrivate.changelog.commitText
    end

    local changelogButton = addFooter(L["Changelog"], "", OptionsPrivate.changelog.fullChangeLogUrl,
                                      changelog, nil, nil, false, 800)
    changelogButton:SetParent(tipFrame)
    changelogButton:SetPoint("LEFT", thanksButton, "RIGHT", footerSpacing, 0)
  end

  local reportbugButton = addFooter(L["Found a Bug?"], [[Interface\AddOns\WeakAuras\Media\Textures\bug_report.tga]], "https://github.com/WeakAuras/WeakAuras2/issues/new?template=bug_report.yml",
            L["Report bugs on our issue tracker."], nil, nil, true)
  reportbugButton:SetParent(tipFrame)
  reportbugButton:SetPoint("RIGHT", tipFrame, "RIGHT")

  local wagoButton = addFooter(L["Find Auras"], [[Interface\AddOns\WeakAuras\Media\Textures\wago.tga]], "https://wago.io",
            L["Browse Wago, the largest collection of auras."], nil, nil, true)
  wagoButton:SetParent(tipFrame)
  wagoButton:SetPoint("RIGHT", reportbugButton, "LEFT", -footerSpacing, 0)

  local companionButton
  if not OptionsPrivate.Private.CompanionData.slugs then
    companionButton = addFooter(L["Update Auras"], [[Interface\AddOns\WeakAuras\Media\Textures\wagoupdate_refresh.tga]], "https://weakauras.wtf",
            L["Keep your Wago imports up to date with the Companion App."])
    companionButton:SetParent(tipFrame)
    companionButton:SetPoint("RIGHT", wagoButton, "LEFT", -footerSpacing, 0)
  end

  frame.ShowTip = function(self)
    self.tipFrame:Show()
    self.buttonsContainer.frame:SetPoint("BOTTOMLEFT", self, "BOTTOMLEFT", 17, 30)
    self.container.frame:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -17, 28)
  end

  frame.HideTip = function(self)
    self.tipFrame:Hide()
    self.buttonsContainer.frame:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT", 17, 12)
    self.container.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 10)
  end

  -- Right Side Container
  local container = AceGUI:Create("InlineGroup")
  container.frame:SetParent(frame)
  container.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 10)
  container.frame:SetPoint("TOPLEFT", frame, "TOPRIGHT", -63 - WeakAuras.normalWidth * 340, 0)
  container.frame:Show()
  container.frame:SetClipsChildren(true)
  container.titletext:Hide()
  -- Hide the border
  container.content:GetParent():SetBackdrop(nil)
  container.content:SetPoint("TOPLEFT", 0, -28)
  container.content:SetPoint("BOTTOMRIGHT", 0, 0)
  frame.container = container
  frame.moversizer, frame.mover = OptionsPrivate.MoverSizer(frame)

  -- filter line
  local filterInput = CreateFrame("EditBox", "WeakAurasFilterInput", frame, "SearchBoxTemplate")
  filterInput:SetScript("OnTextChanged", function(self)
    SearchBoxTemplate_OnTextChanged(self)
    OptionsPrivate.SortDisplayButtons(filterInput:GetText())
  end)
  filterInput:SetHeight(15)
  filterInput:SetPoint("TOP", frame, "TOP", 0, -65)
  filterInput:SetPoint("LEFT", frame, "LEFT", 24, 0)
  filterInput:SetPoint("RIGHT", container.frame, "LEFT", -2, 0)
  filterInput:SetFont(STANDARD_TEXT_FONT, 10, "")
  frame.filterInput = filterInput
  filterInput:Hide()

  -- Left Side Container
  local buttonsContainer = AceGUI:Create("InlineGroup")
  buttonsContainer:SetWidth(170)
  buttonsContainer.frame:SetParent(frame)
  buttonsContainer.frame:SetPoint("BOTTOMLEFT", frame, "BOTTOMLEFT", 17, 12)
  buttonsContainer.frame:SetPoint("TOP", frame, "TOP", 0, -67)
  buttonsContainer.frame:SetPoint("RIGHT", container.frame, "LEFT", -17)
  buttonsContainer.frame:Show()
  frame.buttonsContainer = buttonsContainer

  -- Toolbar
  local toolbarContainer = CreateFrame("Frame", nil, buttonsContainer.frame)
  toolbarContainer:SetParent(buttonsContainer.frame)
  -- toolbarContainer:Hide()
  toolbarContainer:SetPoint("TOPLEFT", buttonsContainer.frame, "TOPLEFT", 30, 30)
  toolbarContainer:SetPoint("BOTTOMRIGHT", buttonsContainer.frame, "TOPRIGHT", 0, 0)

  local undo = AceGUI:Create("WeakAurasToolbarButton")
  undo:SetText(L["Undo"])
  undo:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\upleft")
  undo:SetCallback("OnClick", function()
    OptionsPrivate.Private.TimeMachine:StepBackward()
    frame:FillOptions()
  end)
  undo.frame:SetParent(toolbarContainer)
  undo.frame:SetShown(OptionsPrivate.Private.Features:Enabled("undo"))
  undo:SetPoint("LEFT")
  undo.frame:SetCollapsesLayout(true)

  local redo = AceGUI:Create("WeakAurasToolbarButton")
  redo:SetText(L["Redo"])
  redo:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\upright")
  redo:SetCallback("OnClick", function()
    OptionsPrivate.Private.TimeMachine:StepForward()
    frame:FillOptions()
  end)
  redo.frame:SetParent(toolbarContainer)
  redo.frame:SetShown(OptionsPrivate.Private.Features:Enabled("undo"))
  redo:SetPoint("LEFT", undo.frame, "RIGHT", 10, 0)
  redo.frame:SetEnabled(OptionsPrivate.Private.TimeMachine:DescribeNext() ~= nil)
  redo.frame:SetCollapsesLayout(true)
  OptionsPrivate.Private.Features:Subscribe("undo",
    function()
      undo.frame:Show()
      redo.frame:Show()
    end,
    function()
      undo.frame:Hide()
      redo.frame:Hide()
    end
  )

  local tmControls = {
    undo = undo,
    redo = redo,
  }

  function tmControls:Step()
    -- slightly annoying workaround
    -- Buttons behave in a strange way if they are disabled inside of the OnClick handler
    -- where the pushed texture refuses to vanish until the button is enabled & user clicks it again
    -- so, just disable the button after next frame draw, so it's imperceptible to the user but we're not in the OnClick handler
    C_Timer.After(0, function()
      self.undo:SetDisabled(OptionsPrivate.Private.TimeMachine:DescribePrevious() == nil)
      self.redo:SetDisabled(OptionsPrivate.Private.TimeMachine:DescribeNext() == nil)
    end)
  end
  tmControls:Step()
  OptionsPrivate.Private.TimeMachine.sub:AddSubscriber("Step", tmControls)

  local newButton = AceGUI:Create("WeakAurasToolbarButton")
  newButton:SetText(L["New Aura"])
  newButton:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\newaura")
  newButton.frame:SetParent(toolbarContainer)
  newButton.frame:Show()
  newButton:SetPoint("LEFT", redo.frame, "RIGHT", 10, 0)
  frame.toolbarContainer = toolbarContainer

  newButton:SetCallback("OnClick", function()
    frame:NewAura()
  end)

  local importButton = AceGUI:Create("WeakAurasToolbarButton")
  importButton:SetText(L["Import"])
  importButton:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\importsmall")
  importButton:SetCallback("OnClick", OptionsPrivate.ImportFromString)
  importButton.frame:SetParent(toolbarContainer)
  importButton.frame:Show()
  importButton:SetPoint("LEFT", newButton.frame, "RIGHT", 10, 0)

  local lockButton = AceGUI:Create("WeakAurasToolbarButton")
  lockButton:SetText(L["Lock Positions"])
  lockButton:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\lockPosition")
  lockButton:SetCallback("OnClick", function(self)
    if WeakAurasOptionsSaved.lockPositions then
      lockButton:SetStrongHighlight(false)
      lockButton:UnlockHighlight()
      WeakAurasOptionsSaved.lockPositions = false
    else
      lockButton:SetStrongHighlight(true)
      lockButton:LockHighlight()
      WeakAurasOptionsSaved.lockPositions = true
    end
  end)
  if WeakAurasOptionsSaved.lockPositions then
    lockButton:LockHighlight()
  end
  lockButton.frame:SetParent(toolbarContainer)
  lockButton.frame:Show()
  lockButton:SetPoint("LEFT", importButton.frame, "RIGHT", 10, 0)

  local magnetButton = AceGUI:Create("WeakAurasToolbarButton")
  magnetButton:SetText(L["Magnetically Align"])
  magnetButton:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\magnetic")
  magnetButton:SetCallback("OnClick", function(self)
    if WeakAurasOptionsSaved.magnetAlign then
      magnetButton:SetStrongHighlight(false)
      magnetButton:UnlockHighlight()
      WeakAurasOptionsSaved.magnetAlign = false
    else
      magnetButton:SetStrongHighlight(true)
      magnetButton:LockHighlight()
      WeakAurasOptionsSaved.magnetAlign = true
    end
  end)

  if WeakAurasOptionsSaved.magnetAlign then
    magnetButton:LockHighlight()
  end
  magnetButton.frame:SetParent(toolbarContainer)
  magnetButton.frame:Show()
  magnetButton:SetPoint("LEFT", lockButton.frame, "RIGHT", 10, 0)


  local loadProgress = frame:CreateFontString(nil, "OVERLAY", "GameFontNormal")
  loadProgress:SetPoint("TOP", buttonsContainer.frame, "TOP", 0, -4)
  loadProgress:SetText(L["Creating options: "].."0/0")
  frame.loadProgress = loadProgress

  frame.SetLoadProgressVisible = function(self, visible)
    self.loadProgessVisible = visible
    self:UpdateFrameVisible()
  end

  local buttonsScroll = AceGUI:Create("ScrollFrame")
  buttonsScroll:SetLayout("ButtonsScrollLayout")
  buttonsScroll.width = "fill"
  buttonsScroll.height = "fill"
  buttonsContainer:SetLayout("fill")
  buttonsContainer:AddChild(buttonsScroll)
  buttonsScroll.DeleteChild = function(self, delete)
    for index, widget in ipairs(buttonsScroll.children) do
      if widget == delete then
        tremove(buttonsScroll.children, index)
      end
    end
    delete:OnRelease()
    buttonsScroll:DoLayout()
  end
  frame.buttonsScroll = buttonsScroll

  function buttonsScroll:GetScrollPos()
    local status = self.status or self.localstatus
    return status.offset, status.offset + self.scrollframe:GetHeight()
  end

  -- override SetScroll to make children visible as needed
  local oldSetScroll = buttonsScroll.SetScroll
  buttonsScroll.SetScroll = function(self, value)
    oldSetScroll(self, value)
    self.LayoutFunc(self.content, self.children, true)
  end

  function buttonsScroll:SetScrollPos(top, bottom)
    local status = self.status or self.localstatus
    local viewheight = self.scrollframe:GetHeight()
    local height = self.content:GetHeight()
    local move

    local viewtop = -1 * status.offset
    local viewbottom = -1 * (status.offset + viewheight)
    if top > viewtop then
      move = top - viewtop
    elseif bottom < viewbottom then
      move = bottom - viewbottom
    else
      move = 0
    end

    status.offset = status.offset - move

    self.content:ClearAllPoints()
    self.content:SetPoint("TOPLEFT", 0, status.offset)
    self.content:SetPoint("TOPRIGHT", 0, status.offset)

    status.scrollvalue = status.offset / ((height - viewheight) / 1000.0)
  end

  -- Ready to Install section
  local pendingInstallButton = AceGUI:Create("WeakAurasLoadedHeaderButton")
  pendingInstallButton:SetText(L["Ready for Install"])
  pendingInstallButton:Disable()
  pendingInstallButton:EnableExpand()
  pendingInstallButton.frame.view:Hide()
  if odb.pendingImportCollapse then
    pendingInstallButton:Collapse()
  else
    pendingInstallButton:Expand()
  end
  pendingInstallButton:SetOnExpandCollapse(function()
    if pendingInstallButton:GetExpanded() then
      odb.pendingImportCollapse = nil
    else
      odb.pendingImportCollapse = true
    end
    OptionsPrivate.SortDisplayButtons()
  end)
  pendingInstallButton:SetExpandDescription(L["Expand all pending Import"])
  pendingInstallButton:SetCollapseDescription(L["Collapse all pending Import"])
  frame.pendingInstallButton = pendingInstallButton

  -- Ready for update section
  local pendingUpdateButton = AceGUI:Create("WeakAurasLoadedHeaderButton")
  pendingUpdateButton:SetText(L["Ready for Update"])
  pendingUpdateButton:Disable()
  pendingUpdateButton:EnableExpand()
  pendingUpdateButton.frame.view:Hide()
  if odb.pendingUpdateCollapse then
    pendingUpdateButton:Collapse()
  else
    pendingUpdateButton:Expand()
  end
  pendingUpdateButton:SetOnExpandCollapse(function()
    if pendingUpdateButton:GetExpanded() then
      odb.pendingUpdateCollapse = nil
    else
      odb.pendingUpdateCollapse = true
    end
    OptionsPrivate.SortDisplayButtons()
  end)
  pendingUpdateButton:SetExpandDescription(L["Expand all pending Import"])
  pendingUpdateButton:SetCollapseDescription(L["Collapse all pending Import"])
  frame.pendingUpdateButton = pendingUpdateButton

  -- Loaded section
  local loadedButton = AceGUI:Create("WeakAurasLoadedHeaderButton")
  loadedButton:SetText(L["Loaded/Standby"])
  loadedButton:Disable()
  loadedButton:EnableExpand()
  if odb.loadedCollapse then
    loadedButton:Collapse()
  else
    loadedButton:Expand()
  end
  loadedButton:SetOnExpandCollapse(function()
    if loadedButton:GetExpanded() then
      odb.loadedCollapse = nil
    else
      odb.loadedCollapse = true
    end
    OptionsPrivate.SortDisplayButtons()
  end)
  loadedButton:SetExpandDescription(L["Expand all loaded displays"])
  loadedButton:SetCollapseDescription(L["Collapse all loaded displays"])
  loadedButton:SetViewClick(function()
    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()

    if loadedButton.view.visibility == 2 then
      for _, child in ipairs(loadedButton.childButtons) do
        if child:IsLoaded() then
          child:PriorityHide(2)
        end
      end
      loadedButton:PriorityHide(2)
    else
      for _, child in ipairs(loadedButton.childButtons) do
        if child:IsLoaded() then
          child:PriorityShow(2)
        end
      end
      loadedButton:PriorityShow(2)
    end
    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
  end)
  loadedButton.RecheckVisibility = function(self)
    local none, all = true, true
    for _, child in ipairs(loadedButton.childButtons) do
      if child:GetVisibility() ~= 2 then
        all = false
      end
      if child:GetVisibility() ~= 0 then
        none = false
      end
    end
    local newVisibility
    if all then
      newVisibility = 2
    elseif none then
      newVisibility = 0
    else
      newVisibility = 1
    end
    if newVisibility ~= self.view.visibility then
      self.view.visibility = newVisibility
      self:UpdateViewTexture()
    end
  end
  loadedButton:SetViewDescription(L["Toggle the visibility of all loaded displays"])
  loadedButton.childButtons = {}
  frame.loadedButton = loadedButton

  -- Not Loaded section
  local unloadedButton = AceGUI:Create("WeakAurasLoadedHeaderButton")
  unloadedButton:SetText(L["Not Loaded"])
  unloadedButton:Disable()
  unloadedButton:EnableExpand()
  if odb.unloadedCollapse then
    unloadedButton:Collapse()
  else
    unloadedButton:Expand()
  end
  unloadedButton:SetOnExpandCollapse(function()
    if unloadedButton:GetExpanded() then
      odb.unloadedCollapse = nil
    else
      odb.unloadedCollapse = true
    end
    OptionsPrivate.SortDisplayButtons()
  end)
  unloadedButton:SetExpandDescription(L["Expand all non-loaded displays"])
  unloadedButton:SetCollapseDescription(L["Collapse all non-loaded displays"])
  unloadedButton:SetViewClick(function()
    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
    if unloadedButton.view.visibility == 2 then
      for _, child in ipairs(unloadedButton.childButtons) do
        child:PriorityHide(2)
      end
      unloadedButton:PriorityHide(2)
    else
      for _, child in ipairs(unloadedButton.childButtons) do
        child:PriorityShow(2)
      end
      unloadedButton:PriorityShow(2)
    end
    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
  end)
  unloadedButton.RecheckVisibility = function(self)
    local none, all = true, true
    for _, child in ipairs(unloadedButton.childButtons) do
      if child:GetVisibility() ~= 2 then
        all = false
      end
      if child:GetVisibility() ~= 0 then
        none = false
      end
    end
    local newVisibility
    if all then
      newVisibility = 2
    elseif none then
      newVisibility = 0
    else
      newVisibility = 1
    end
    if newVisibility ~= self.view.visibility then
      self.view.visibility = newVisibility
      self:UpdateViewTexture()
    end
  end
  unloadedButton:SetViewDescription(L["Toggle the visibility of all non-loaded displays"])
  unloadedButton.childButtons = {}
  frame.unloadedButton = unloadedButton

  -- Sidebar used for Dynamic Text Replacements
  local sidegroup = AceGUI:Create("WeakAurasInlineGroup")
  sidegroup.frame:SetParent(frame)
  sidegroup.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -63);
  sidegroup.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 46);
  sidegroup.frame:Show()
  sidegroup:SetLayout("flow")

  local dynamicTextCodesFrame = CreateFrame("Frame", "WeakAurasTextReplacements", sidegroup.frame, "PortraitFrameTemplate")
  dynamicTextCodesFrame.Bg:SetColorTexture(unpack(frame.Bg.colorTexture))
  ButtonFrameTemplate_HidePortrait(dynamicTextCodesFrame)
  dynamicTextCodesFrame:SetPoint("TOPLEFT", sidegroup.frame, "TOPRIGHT", 20, 0)
  dynamicTextCodesFrame:SetPoint("BOTTOMLEFT", sidegroup.frame, "BOTTOMRIGHT", 20, 0)
  dynamicTextCodesFrame:SetWidth(250)
  dynamicTextCodesFrame:SetScript("OnHide", function()
    OptionsPrivate.currentDynamicTextInput = nil
  end)
  frame.dynamicTextCodesFrame = dynamicTextCodesFrame

  local dynamicTextCodesFrameTitle
  if dynamicTextCodesFrame.TitleContainer and dynamicTextCodesFrame.TitleContainer.TitleText then
    dynamicTextCodesFrameTitle = dynamicTextCodesFrame.TitleContainer.TitleText
  elseif dynamicTextCodesFrame.TitleText then
    dynamicTextCodesFrameTitle = dynamicTextCodesFrame.TitleText
  end
  if dynamicTextCodesFrameTitle then
    dynamicTextCodesFrameTitle:SetText("Dynamic Text Replacements")
    dynamicTextCodesFrameTitle:SetJustifyH("CENTER")
    dynamicTextCodesFrameTitle:SetPoint("LEFT", dynamicTextCodesFrame, "TOPLEFT")
    dynamicTextCodesFrameTitle:SetPoint("RIGHT", dynamicTextCodesFrame, "TOPRIGHT", -10, 0)
  end

  local dynamicTextCodesLabel = AceGUI:Create("Label")
  dynamicTextCodesLabel:SetText(L["Insert text replacement codes to make text dynamic."])
  dynamicTextCodesLabel:SetFontObject(GameFontNormal)
  dynamicTextCodesLabel:SetPoint("TOP", dynamicTextCodesFrame, "TOP", 0, -35)
  dynamicTextCodesLabel:SetFontObject(GameFontNormalSmall2)
  dynamicTextCodesLabel.frame:SetParent(dynamicTextCodesFrame)
  dynamicTextCodesLabel.frame:Show()

  local dynamicTextCodesScrollContainer = AceGUI:Create("SimpleGroup")
  dynamicTextCodesScrollContainer.frame:SetParent(dynamicTextCodesFrame)
  dynamicTextCodesScrollContainer.frame:SetPoint("TOP", dynamicTextCodesLabel.frame, "BOTTOM", 0, -15)
  dynamicTextCodesScrollContainer.frame:SetPoint("LEFT", dynamicTextCodesFrame, "LEFT", 15, 0)
  dynamicTextCodesScrollContainer.frame:SetPoint("BOTTOMRIGHT", dynamicTextCodesFrame, "BOTTOMRIGHT", -15, 5)
  dynamicTextCodesScrollContainer:SetFullWidth(true)
  dynamicTextCodesScrollContainer:SetFullHeight(true)
  dynamicTextCodesScrollContainer:SetLayout("Fill")


  local dynamicTextCodesScrollList = AceGUI:Create("ScrollFrame")
  dynamicTextCodesScrollList:SetLayout("List")
  dynamicTextCodesScrollList:SetPoint("TOPLEFT", dynamicTextCodesScrollContainer.frame, "TOPLEFT")
  dynamicTextCodesScrollList:SetPoint("BOTTOMRIGHT", dynamicTextCodesScrollContainer.frame, "BOTTOMRIGHT")
  dynamicTextCodesScrollList.frame:SetParent(dynamicTextCodesFrame)
  dynamicTextCodesScrollList:FixScroll()
  dynamicTextCodesScrollList.scrollframe:SetScript(
    "OnScrollRangeChanged",
    function(frame)
      frame.obj:DoLayout()
    end
  )

  dynamicTextCodesScrollList.scrollframe:SetScript(
    "OnSizeChanged",
    function(frame)
      if frame.obj.scrollBarShown then
        frame.obj.content.width = frame.obj.content.original_width - 10
        frame.obj.scrollframe:SetPoint("BOTTOMRIGHT", -10, 0)
      end
    end
  )


  dynamicTextCodesFrame.scrollList = dynamicTextCodesScrollList
  dynamicTextCodesFrame.label = dynamicTextCodesLabel
  dynamicTextCodesFrame:Hide()

  function OptionsPrivate.ToggleTextReplacements(data, widget, event)
    -- If the text edit has focus when the user clicks on the button, we'll get two events:
    -- a) The OnEditFocusLost
    -- b) The ToggleButton OnClick event
    -- Since we want to hide the text replacement window in that case,
    -- ignore the ToggleButton if it is directly after the  OnEditFocusLost
    local currentTime = GetTime()
    if event == "ToggleButton"
      and dynamicTextCodesFrame.lastCaller
      and dynamicTextCodesFrame.lastCaller.event == "OnEditFocusLost"
      and currentTime - dynamicTextCodesFrame.lastCaller.time < 0.2
    then
      return
    end

    dynamicTextCodesFrame.lastCaller = {
      event = event,
      time = currentTime,
    }

    if event == "OnEnterPressed" then
      dynamicTextCodesFrame:Hide()
    elseif event == "OnEditFocusGained" or not dynamicTextCodesFrame:IsShown() then
      dynamicTextCodesFrame:Show()
      if OptionsPrivate.currentDynamicTextInput ~= widget then
        OptionsPrivate.UpdateTextReplacements(dynamicTextCodesFrame, data)
      end
      OptionsPrivate.currentDynamicTextInput = widget
    elseif not dynamicTextCodesFrame:IsMouseOver() then -- Prevents hiding when clicking inside the frame
      dynamicTextCodesFrame:Hide()
    end
  end

  frame.ClearOptions = function(self, id)
    aceOptions[id] = nil
    OptionsPrivate.commonOptionsCache:Clear()
    if type(id) == "string" then
      local data = WeakAuras.GetData(id)
      if data and data.parent then
        frame:ClearOptions(data.parent)
      end
      for child in OptionsPrivate.Private.TraverseAllChildren(tempGroup) do
        if (id == child.id) then
          frame:ClearOptions(tempGroup.id)
        end
      end
    end
  end

  frame.ReloadOptions = function(self)
    if self.pickedDisplay then
      self:ClearAndUpdateOptions(self.pickedDisplay, true)
      self:FillOptions()
    end
  end

  frame.ClearAndUpdateOptions = function(self, id, clearChildren)
    frame:ClearOptions(id)

    if clearChildren then
      local data
      if type(id) == "string" then
        data = WeakAuras.GetData(id)
      elseif self.pickedDisplay then
        data = tempGroup
      end

      for child in OptionsPrivate.Private.TraverseAllChildren(data) do
        frame:ClearOptions(child.id)
      end
    end
    if (type(self.pickedDisplay) == "string" and self.pickedDisplay == id)
       or (type(self.pickedDisplay) == "table" and id == tempGroup.id)
    then
      frame:UpdateOptions()
    end
  end

  frame.UpdateOptions = function(self)
    if not self.pickedDisplay then
      return
    end
    OptionsPrivate.commonOptionsCache:Clear()
    self.selectedTab = self.selectedTab or "region"
    local data
    if type(self.pickedDisplay) == "string" then
      data = WeakAuras.GetData(frame.pickedDisplay)
    elseif self.pickedDisplay then
      data = tempGroup
    end

    if not data.controlledChildren or data == tempGroup then
      if self.selectedTab == "group" then
        self.selectedTab = "region"
      end
    end

    local optionTable = self:EnsureOptions(data, self.selectedTab)
    if optionTable then
      AceConfigRegistry:RegisterOptionsTable("WeakAuras", optionTable, true)
    end
  end

  frame.EnsureOptions = function(self, data, tab)
    local id = data.id
    aceOptions[id] = aceOptions[id] or {}
    if not aceOptions[id][tab] then
      local optionsGenerator =
      {
        group = OptionsPrivate.GetGroupOptions,
        region =  OptionsPrivate.GetDisplayOptions,
        trigger = OptionsPrivate.GetTriggerOptions,
        conditions = OptionsPrivate.GetConditionOptions,
        load = OptionsPrivate.GetLoadOptions,
        action = OptionsPrivate.GetActionOptions,
        animation = OptionsPrivate.GetAnimationOptions,
        authorOptions = OptionsPrivate.GetAuthorOptions,
        information = OptionsPrivate.GetInformationOptions,
      }
      if optionsGenerator[tab] then
        aceOptions[id][tab] = optionsGenerator[tab](data)
      end
    end
    return aceOptions[id][tab]
  end

  -- This function refills the options pane
  -- This is ONLY necessary if AceOptions doesn't know that it should do
  -- that automatically. That is any change that goes through the AceOptions
  -- doesn't need to call this
  -- Any changes to the options that go around that, e.g. drag/drop, group,
  -- texture pick, etc should call this
  frame.FillOptions = function(self)
    if not self.pickedDisplay then
      return
    end

    OptionsPrivate.commonOptionsCache:Clear()

    frame:UpdateOptions()

    local data
    if type(self.pickedDisplay) == "string" then
      data = WeakAuras.GetData(frame.pickedDisplay)
    elseif self.pickedDisplay then
      data = tempGroup
    end

    local tabsWidget

    container.frame:SetPoint("TOPLEFT", frame, "TOPRIGHT", -63 - WeakAuras.normalWidth * 340, -10)
    container:ReleaseChildren()
    container:SetLayout("Fill")
    tabsWidget = AceGUI:Create("TabGroup")

    local tabs = {
      { value = "region", text = L["Display"]},
      { value = "trigger", text = L["Trigger"]},
      { value = "conditions", text = L["Conditions"]},
      { value = "action", text = L["Actions"]},
      { value = "animation", text = L["Animations"]},
      { value = "load", text = L["Load"]},
      { value = "authorOptions", text = L["Custom Options"]},
      { value = "information", text = L["Information"]},
    }
    -- Check if group and not the temp group
    if data.controlledChildren and type(data.id) == "string" then
      tinsert(tabs, 1, { value = "group", text = L["Group"]})
    end

    tabsWidget:SetTabs(tabs)
    tabsWidget:SelectTab(self.selectedTab)
    tabsWidget:SetLayout("Fill")
    container:AddChild(tabsWidget)

    local group = AceGUI:Create("WeakAurasInlineGroup")
    tabsWidget:AddChild(group)

    tabsWidget:SetCallback("OnGroupSelected", function(self, event, tab)
        frame.selectedTab = tab
        frame:FillOptions()
      end)

    AceConfigDialog:Open("WeakAuras", group)
    tabsWidget:SetTitle("")

    if data.controlledChildren and #data.controlledChildren == 0 then
      WeakAurasOptions:NewAura()
    end

    if frame.dynamicTextCodesFrame then
      frame.dynamicTextCodesFrame:Hide()
    end
  end

  frame.ClearPick = function(self, id)
    local index = nil
    for i, childId in pairs(tempGroup.controlledChildren) do
      if childId == id then
        index = i
        break
      end
    end

    tremove(tempGroup.controlledChildren, index)
    displayButtons[id]:ClearPick()

    -- Clear trigger expand state
    OptionsPrivate.ClearTriggerExpandState()

    self:ClearOptions(tempGroup.id)
    self:FillOptions()
  end

  frame.OnRename = function(self, uid, oldid, newid)
    if type(frame.pickedDisplay) == "string" and frame.pickedDisplay == oldid then
      frame.pickedDisplay = newid
    else
      for i, childId in pairs(tempGroup.controlledChildren) do
        if (childId == newid) then
          tempGroup.controlledChildren[i] = newid
        end
      end
    end
  end

  frame.ClearPicks = function(self, noHide)
    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
    for id, button in pairs(displayButtons) do
      button:ClearPick(true)
      if not noHide then
        button:PriorityHide(1)
      end
    end
    if not noHide then
      for id, button in pairs(displayButtons) do
        if button.data.controlledChildren then
          button:RecheckVisibility()
        end
      end
    end

    frame.pickedDisplay = nil
    frame.pickedOption = nil
    wipe(tempGroup.controlledChildren)
    loadedButton:ClearPick(noHide)
    unloadedButton:ClearPick(noHide)
    container:ReleaseChildren()
    self.moversizer:Hide()

    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)

    -- Clear trigger expand state
    OptionsPrivate.ClearTriggerExpandState()
  end

  frame.GetTargetAura = function(self)
    if self.pickedDisplay then
      if type(self.pickedDisplay) == "table" and tempGroup.controlledChildren and tempGroup.controlledChildren[1] then
        return tempGroup.controlledChildren[1]
      elseif type(self.pickedDisplay) == "string" then
        return self.pickedDisplay
      end
    end
    return nil
  end

  frame.NewAura = function(self)
    local targetId
    local targetIsDynamicGroup

    if self.pickedDisplay then
      if type(self.pickedDisplay) == "table" and tempGroup.controlledChildren and tempGroup.controlledChildren[1] then
        targetId = tempGroup.controlledChildren[1]
        WeakAuras.PickDisplay(targetId)
      elseif type(self.pickedDisplay) == "string" then
        targetId = self.pickedDisplay
      else
        self:ClearPicks()
      end
    end

    if targetId then
      local pickedButton = OptionsPrivate.GetDisplayButton(targetId)
      if pickedButton.data.controlledChildren then
        targetIsDynamicGroup = pickedButton.data.regionType == "dynamicgroup"
      else
        local parent = pickedButton.data.parent
        local parentData = parent and WeakAuras.GetData(parent)
        targetIsDynamicGroup = parentData and parentData.regionType == "dynamicgroup"
      end
    end
    self.dynamicTextCodesFrame:Hide()
    self.moversizer:Hide()
    self.pickedOption = "New"

    container:ReleaseChildren()
    container.frame:SetPoint("TOPLEFT", frame, "TOPRIGHT", -63 - WeakAuras.normalWidth * 340, 0)
    container:SetLayout("fill")
    local border = AceGUI:Create("InlineGroup")
    border:SetLayout("Fill")
    container:AddChild(border)

    local containerScroll = AceGUI:Create("ScrollFrame")
    containerScroll:SetLayout("flow")
    border:AddChild(containerScroll)

    if C_AddOns.GetAddOnEnableState("WeakAurasTemplates") ~= Enum.AddOnEnableState.None then
      local simpleLabel = AceGUI:Create("Label")
      simpleLabel:SetFont(STANDARD_TEXT_FONT, 24, "OUTLINE")
      simpleLabel:SetColor(NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b)
      simpleLabel:SetText(L["Simple"])
      simpleLabel:SetFullWidth(true)
      containerScroll:AddChild(simpleLabel)

      local button = AceGUI:Create("WeakAurasNewButton")
      button:SetTitle(L["Premade Auras"])
      button:SetDescription(L["Offer a guided way to create auras for your character"])
      button:SetIcon("Interface\\Icons\\Inv_misc_book_09")
      button:SetClick(function()
        OptionsPrivate.OpenTriggerTemplate(nil, self:GetTargetAura())
      end)
      containerScroll:AddChild(button)

      local spacer1Label = AceGUI:Create("Label")
      spacer1Label:SetText("")
      containerScroll:AddChild(spacer1Label)

      local advancedLabel = AceGUI:Create("Label")
      advancedLabel:SetFont(STANDARD_TEXT_FONT, 24, "OUTLINE")
      advancedLabel:SetColor(NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b)
      advancedLabel:SetText(L["Advanced"])
      advancedLabel:SetFullWidth(true)
      containerScroll:AddChild(advancedLabel)
    end

    local regionTypesSorted = {}
    for regionType, regionData in pairs(OptionsPrivate.Private.regionOptions) do
      tinsert(regionTypesSorted, regionType)
    end

    -- Sort group + dynamic group first, then the others alphabetically
    table.sort(regionTypesSorted, function(a, b)
      if (a == "group") then
        return true
      end

      if (b == "group") then
        return false
      end

      if (a == "dynamicgroup") then
        return true
      end
      if (b == "dynamicgroup") then
        return false
      end

      return OptionsPrivate.Private.regionOptions[a].displayName < OptionsPrivate.Private.regionOptions[b].displayName
    end)

    for index, regionType in ipairs(regionTypesSorted) do
      if (targetIsDynamicGroup and (regionType == "group" or regionType == "dynamicgroup")) then
        -- Dynamic groups can't contain group/dynamic groups
      else
        local regionData = OptionsPrivate.Private.regionOptions[regionType]
        local button = AceGUI:Create("WeakAurasNewButton")
        button:SetTitle(regionData.displayName)
        if(type(regionData.icon) == "string" or type(regionData.icon) == "table") then
          button:SetIcon(regionData.icon)
        end
        button:SetDescription(regionData.description)
        button:SetClick(function()
          WeakAuras.NewAura(nil, regionType, self:GetTargetAura())
        end)
        containerScroll:AddChild(button)
      end
    end

    local spacer2Label = AceGUI:Create("Label")
    spacer2Label:SetText("")
    containerScroll:AddChild(spacer2Label)

    local externalLabel = AceGUI:Create("Label")
    externalLabel:SetFont(STANDARD_TEXT_FONT, 24, "OUTLINE")
    externalLabel:SetColor(NORMAL_FONT_COLOR.r, NORMAL_FONT_COLOR.g, NORMAL_FONT_COLOR.b)
    externalLabel:SetText(L["External"])
    externalLabel:SetFullWidth(true)
    containerScroll:AddChild(externalLabel)

    local spacer3Label = AceGUI:Create("Label")
    spacer3Label:SetText("")
    containerScroll:AddChild(spacer3Label)

    -- Import
    local importButton = AceGUI:Create("WeakAurasNewButton")
    importButton:SetTitle(L["Import"])

    local data = {
      outline = false,
      color = {1, 1, 1, 1},
      justify = "CENTER",
      font = "Friz Quadrata TT",
      fontSize = 8,
      displayText = [[
        b4vmErLxtfM
        xu5fDEn1CEn
        vmUmJyZ4hyY
        DtnEnvBEnfz
        EnfzErLxtjx
        zNL2BUrvEWv
        MxtfwDYfMyH
        jNxtLgzEnLt
        LDNx051u25L
        tXmdmY4fDE5
      ]]
    }

    if not frame.importThumbnail then
      local thumbnail = OptionsPrivate.Private.regionOptions["text"].createThumbnail(UIParent)
      OptionsPrivate.Private.regionOptions["text"].modifyThumbnail(UIParent, thumbnail, data)
      thumbnail.mask:SetPoint("BOTTOMLEFT", thumbnail, "BOTTOMLEFT", 3, 3)
      thumbnail.mask:SetPoint("TOPRIGHT", thumbnail, "TOPRIGHT", -3, -3)
      frame.importThumbnail = thumbnail
    end

    importButton:SetIcon(frame.importThumbnail)
    importButton:SetDescription(L["Import a display from an encoded string"])
    importButton:SetClick(OptionsPrivate.ImportFromString)
    containerScroll:AddChild(importButton)
  end

  local function ExpandParents(data)
    if data.parent then
      if not displayButtons[data.parent]:GetExpanded() then
        displayButtons[data.parent]:Expand()
      end
      local parentData = WeakAuras.GetData(data.parent)
      ExpandParents(parentData)
    end
  end

  frame.PickDisplay = function(self, id, tab, noHide)
    local data = WeakAuras.GetData(id)

    -- Always expand even if already picked
    ExpandParents(data)

    if OptionsPrivate.Private.loaded[id] ~= nil then
      -- Under loaded
      if not loadedButton:GetExpanded() then
        loadedButton:Expand()
      end
    else
      -- Under Unloaded
      if not unloadedButton:GetExpanded() then
        unloadedButton:Expand()
      end
    end

    if self.pickedDisplay == id and (self.pickedDisplay == tab or tab == nil) then
      return
    end

    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()

    self:ClearPicks(noHide)

    displayButtons[id]:Pick()
    self.pickedDisplay = id


    if tab then
      self.selectedTab = tab
    end
    self:FillOptions()
    WeakAuras.SetMoverSizer(id)

    local _, _, _, _, yOffset = displayButtons[id].frame:GetPoint(1)
    if not yOffset then
      yOffset = displayButtons[id].frame.yOffset
    end
    if yOffset then
      self.buttonsScroll:SetScrollPos(yOffset, yOffset - 32)
    end

    for child in OptionsPrivate.Private.TraverseAllChildren(data) do
      displayButtons[child.id]:PriorityShow(1)
    end
    displayButtons[data.id]:RecheckParentVisibility()

    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
  end

  frame.CenterOnPicked = function(self)
    if self.pickedDisplay then
      local centerId = type(self.pickedDisplay) == "string" and self.pickedDisplay or self.pickedDisplay.controlledChildren[1]

      if displayButtons[centerId] then
        local _, _, _, _, yOffset = displayButtons[centerId].frame:GetPoint(1)
        if not yOffset then
          yOffset = displayButtons[centerId].frame.yOffset
        end
        if yOffset then
          self.buttonsScroll:SetScrollPos(yOffset, yOffset - 32)
        end
      end
    end
  end

  frame.PickDisplayMultiple = function(self, id)
    if not self.pickedDisplay then
      self:PickDisplay(id)
    else
      local wasGroup = false
      if type(self.pickedDisplay) == "string" then
        if WeakAuras.GetData(self.pickedDisplay).controlledChildren or WeakAuras.GetData(id).controlledChildren then
          wasGroup = true
        elseif not OptionsPrivate.IsDisplayPicked(id) then
          tinsert(tempGroup.controlledChildren, self.pickedDisplay)
        end
      end
      if wasGroup then
        self:PickDisplay(id)
      elseif not OptionsPrivate.IsDisplayPicked(id) then
        self.pickedDisplay = tempGroup
        displayButtons[id]:Pick()
        tinsert(tempGroup.controlledChildren, id)
        OptionsPrivate.ClearOptions(tempGroup.id)
        self:FillOptions()
      end
    end
  end

  frame.PickDisplayBatch = function(self, batchSelection)
    local alreadySelected = {}
    for child in OptionsPrivate.Private.TraverseAllChildren(tempGroup) do
      alreadySelected[child.id] = true
    end

    for _, id in ipairs(batchSelection) do
      if not alreadySelected[id] then
        displayButtons[id]:Pick()
        tinsert(tempGroup.controlledChildren, id)
      end
    end
    frame:ClearOptions(tempGroup.id)
    self.pickedDisplay = tempGroup
    self:FillOptions()
  end

  frame.GetPickedDisplay = function(self)
    if type(self.pickedDisplay) == "string" then
      return WeakAuras.GetData(self.pickedDisplay)
    end
    return self.pickedDisplay
  end

  frame:SetClampedToScreen(true)
  local w, h = frame:GetSize()
  local left, right, top, bottom = w/2,-w/2, 0, h-25
  frame:SetClampRectInsets(left, right, top, bottom)

  return frame
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/OptionsFrame.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/TextEditor.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local pairs, type, ipairs = pairs, type, ipairs
local gsub = gsub

-- WoW APIs
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")
local SharedMedia = LibStub("LibSharedMedia-3.0")
local LibDD = LibStub:GetLibrary("LibUIDropDownMenu-4.0")
local LAAC = LibStub("LibAPIAutoComplete-1.0")

local IndentationLib = IndentationLib

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local textEditor

local editor_themes = {
  ["Standard"] = {
    ["Table"] = "|c00ff3333",
    ["Arithmetic"] = "|c00ff3333",
    ["Relational"] = "|c00ff3333",
    ["Logical"] = "|c004444ff",
    ["Special"] = "|c00ff3333",
    ["Keyword"] = "|c004444ff",
    ["Comment"] = "|c0000aa00",
    ["Number"] = "|c00ff9900",
    ["String"] = "|c00999999"
  },
  ["Monokai"] = {
    ["Table"] = "|c00ffffff",
    ["Arithmetic"] = "|c00f92672",
    ["Relational"] = "|c00ff3333",
    ["Logical"] = "|c00f92672",
    ["Special"] = "|c0066d9ef",
    ["Keyword"] = "|c00f92672",
    ["Comment"] = "|c0075715e",
    ["Number"] = "|c00ae81ff",
    ["String"] = "|c00e6db74"
  },
  ["Obsidian"] = {
    ["Table"] = "|c00AFC0E5",
    ["Arithmetic"] = "|c00E0E2E4",
    ["Relational"] = "|c00B3B689",
    ["Logical"] = "|c0093C763",
    ["Special"] = "|c00AFC0E5",
    ["Keyword"] = "|c0093C763",
    ["Comment"] = "|c0066747B",
    ["Number"] = "|c00FFCD22",
    ["String"] = "|c00EC7600"
  }
}

if not WeakAurasSaved.editor_tab_spaces then WeakAurasSaved.editor_tab_spaces = 4 end
if not WeakAurasSaved.editor_font_size then WeakAurasSaved.editor_font_size = 12 end -- set default font size if missing
local color_scheme = {[0] = "|r"}
local function set_scheme()
  if not WeakAurasSaved.editor_theme then
    WeakAurasSaved.editor_theme = "Monokai"
  end
  local theme = editor_themes[WeakAurasSaved.editor_theme]
  color_scheme[IndentationLib.tokens.TOKEN_SPECIAL] = theme["Special"]
  color_scheme[IndentationLib.tokens.TOKEN_KEYWORD] = theme["Keyword"]
  color_scheme[IndentationLib.tokens.TOKEN_COMMENT_SHORT] = theme["Comment"]
  color_scheme[IndentationLib.tokens.TOKEN_COMMENT_LONG] = theme["Comment"]
  color_scheme[IndentationLib.tokens.TOKEN_NUMBER] = theme["Number"]
  color_scheme[IndentationLib.tokens.TOKEN_STRING] = theme["String"]

  color_scheme["..."] = theme["Table"]
  color_scheme["{"] = theme["Table"]
  color_scheme["}"] = theme["Table"]
  color_scheme["["] = theme["Table"]
  color_scheme["]"] = theme["Table"]

  color_scheme["+"] = theme["Arithmetic"]
  color_scheme["-"] = theme["Arithmetic"]
  color_scheme["/"] = theme["Arithmetic"]
  color_scheme["*"] = theme["Arithmetic"]
  color_scheme[".."] = theme["Arithmetic"]

  color_scheme["=="] = theme["Relational"]
  color_scheme["<"] = theme["Relational"]
  color_scheme["<="] = theme["Relational"]
  color_scheme[">"] = theme["Relational"]
  color_scheme[">="] = theme["Relational"]
  color_scheme["~="] = theme["Relational"]

  color_scheme["and"] = theme["Logical"]
  color_scheme["or"] = theme["Logical"]
  color_scheme["not"] = theme["Logical"]
end

-- Define the premade snippets
local premadeSnippets = {
  {
    name = "Basic function",
    snippet = [=[
function()

    return
end]=]
  },
  {
    name = "Custom Activation",
    snippet = [=[
function(trigger)
    return trigger[1] and (trigger[2] or trigger[3])
end]=]
  },
  {
    name = "Trigger: CLEU",
    snippet = [=[
function(event, timestamp, subEvent, hideCaster, sourceGUID, sourceName, sourceFlags, sourceRaidFlags, destGUID, destName, destFlags, destRaidFlags, ...)

    return
end]=]
  },
  {
    name = "Simple throttle",
    snippet = [=[
if not aura_env.last or aura_env.last < GetTime() - 1 then
    aura_env.last = GetTime()

end]=]
  },
  {
    name = "Trigger State Updater",
    snippet = [=[
function(allstates, event, ...)
    allstates:Update("", {
        progressType = "static"||"timed",
        value = ,
        total = ,
        duration = ,
        expirationTime = ,
        autoHide = true,
        name = ,
        icon = ,
        stacks = ,
        index = ,
    })
    -- allstates:Remove("")
    -- allstates:RemoveAll()
end]=]
  },
}

local function ConstructTextEditor(frame)
  local group = AceGUI:Create("WeakAurasInlineGroup")
  group.frame:SetParent(frame)
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -63);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 46);
  group.frame:Hide()
  group:SetLayout("flow")

  local editor = AceGUI:Create("MultiLineEditBox")
  editor.editBox.group = group
  editor:SetFullWidth(true)
  editor:SetFullHeight(true)
  editor:DisableButton(true)
  local fontPath = SharedMedia:Fetch("font", "Fira Mono Medium")
  if (fontPath) then
    editor.editBox:SetFont(fontPath, WeakAurasSaved.editor_font_size, "")
  end
  group:AddChild(editor)
  editor.frame:SetClipsChildren(true)

  local originalOnCursorChanged = editor.editBox:GetScript("OnCursorChanged")
  editor.editBox:SetScript("OnCursorChanged", function(self, ...)
    -- WORKAROUND the editbox sends spurious OnCursorChanged events if its resized
    -- That makes AceGUI scroll the editbox to make the cursor visible, leading to unintended
    -- movements. Prevent all of that by checking if the edit box has focus, as otherwise the cursor
    -- is invisible, and we don't care about making it visible
    if not self:HasFocus() then
      return
    end
    originalOnCursorChanged(self, ...)
  end)

  -- The indention lib overrides GetText, but for the line number
  -- display we ned the original, so save it here.
  local originalGetText = editor.editBox.GetText
  local originalSetText = editor.editBox.SetText
  set_scheme()
  LAAC:enable(editor.editBox)
  IndentationLib.enable(editor.editBox, color_scheme, WeakAurasSaved.editor_tab_spaces)

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate")
  cancel:SetScript(
    "OnClick",
    function()
      group:CancelClose()
    end
  )
  cancel:SetPoint("BOTTOMRIGHT", -20, -24)
  cancel:SetFrameLevel(cancel:GetFrameLevel() + 1)
  cancel:SetHeight(20)
  cancel:SetWidth(100)
  cancel:SetText(L["Cancel"])

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate")
  close:SetScript(
    "OnClick",
    function()
      group:Close()
    end
  )
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0)
  close:SetFrameLevel(close:GetFrameLevel() + 1)
  close:SetHeight(20)
  close:SetWidth(100)
  close:SetText(L["Done"])

  local settings_frame = CreateFrame("Button", "WASettingsButton", close, "UIPanelButtonTemplate")
  settings_frame:SetPoint("RIGHT", close, "LEFT", -10, 0)
  settings_frame:SetHeight(20)
  settings_frame:SetWidth(100)
  settings_frame:SetText(L["Settings"])
  settings_frame:RegisterForClicks("LeftButtonUp")

  local helpButton = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate")
  helpButton:SetPoint("BOTTOMLEFT", 0, -24)
  helpButton:SetFrameLevel(cancel:GetFrameLevel() + 1)
  helpButton:SetHeight(20)
  helpButton:SetWidth(100)
  helpButton:SetText(L["Help"])

  local dropdown = LibDD:Create_UIDropDownMenu("SettingsMenuFrame", settings_frame)


  local function settings_dropdown_initialize(frame, level, menu)
    if level == 1 then
      for k, v in pairs(editor_themes) do
        local item = {
          text = k,
          isNotRadio = false,
          checked = function()
            return WeakAurasSaved.editor_theme == k
          end,
          func = function()
            WeakAurasSaved.editor_theme = k
            set_scheme()
            editor.editBox:SetText(editor.editBox:GetText())
          end
        }
        LibDD:UIDropDownMenu_AddButton(item, level)
      end
      LibDD:UIDropDownMenu_AddButton(
        {
          text = L["Bracket Matching"],
          isNotRadio = true,
          checked = function()
            return WeakAurasSaved.editor_bracket_matching
          end,
          func = function()
            WeakAurasSaved.editor_bracket_matching = not WeakAurasSaved.editor_bracket_matching
          end
        },
      level)
      LibDD:UIDropDownMenu_AddButton(
        {
          text = L["Indent Size"],
          hasArrow = true,
          notCheckable = true,
          menuList = "spaces"
        },
      level)
      LibDD:UIDropDownMenu_AddButton(
        {
          text = WeakAuras.newFeatureString .. L["Font Size"],
          hasArrow = true,
          notCheckable = true,
          menuList = "sizes"
        },
      level)
    elseif menu == "spaces" then
      local spaces = {2,4}
      for _, i in pairs(spaces) do
        LibDD:UIDropDownMenu_AddButton(
          {
            text = i,
            isNotRadio = false,
            checked = function()
              return WeakAurasSaved.editor_tab_spaces == i
            end,
            func = function()
              WeakAurasSaved.editor_tab_spaces = i
              IndentationLib.enable(editor.editBox, color_scheme, WeakAurasSaved.editor_tab_spaces)
              editor.editBox:SetText(editor.editBox:GetText().."\n")
              IndentationLib.indentEditbox(editor.editBox)
            end
          },
        level)
      end
    elseif menu == "sizes" then
      local sizes = {10, 12, 14, 16}
      for _, i in pairs(sizes) do
        LibDD:UIDropDownMenu_AddButton(
          {
            text = i,
            isNotRadio = false,
            checked = function()
              return WeakAurasSaved.editor_font_size == i
            end,
            func = function()
              WeakAurasSaved.editor_font_size = i
              editor.editBox:SetFont(fontPath, WeakAurasSaved.editor_font_size, "")
            end
          },
        level)
      end
    end
  end
  LibDD:UIDropDownMenu_Initialize(dropdown, settings_dropdown_initialize, "MENU")

  settings_frame:SetScript(
    "OnClick",
    function(self, button, down)
      LibDD:ToggleDropDownMenu(1, nil, dropdown, settings_frame, 0, 0)
    end
  )

  -- Make Snippets button (top right, near the line number)
  local snippetsButton = CreateFrame("Button", "WASnippetsButton", group.frame, "UIPanelButtonTemplate")
  snippetsButton:SetPoint("BOTTOMRIGHT", editor.frame, "TOPRIGHT", -20, -10)
  snippetsButton:SetFrameLevel(group.frame:GetFrameLevel() + 2)
  snippetsButton:SetHeight(20)
  snippetsButton:SetWidth(100)
  snippetsButton:SetText(L["Snippets"])
  snippetsButton:RegisterForClicks("LeftButtonUp")

  -- Get the saved snippets from SavedVars
  WeakAurasOptionsSaved.savedSnippets = WeakAurasOptionsSaved.savedSnippets or {}
  local savedSnippets = WeakAurasOptionsSaved.savedSnippets

  -- function to build snippet selection list
  local function UpdateSnippets(frame)
    -- release first before rebuilding
    frame:ReleaseChildren()
    table.sort(
      savedSnippets,
      function(a, b)
        return a.name < b.name
      end
    )

    local heading1 = AceGUI:Create("Heading")
    heading1:SetText(L["Premade Snippets"])
    heading1:SetRelativeWidth(0.7)
    frame:AddChild(heading1)

    -- Iterate premade snippets and make buttons for them
    for order, snippet in ipairs(premadeSnippets) do
      local button = AceGUI:Create("WeakAurasSnippetButton")
      button:SetTitle(snippet.name)
      button:SetDescription(snippet.snippet)
      button:SetCallback(
        "OnClick",
        function()
          editor.editBox:Insert(snippet.snippet)
          editor:SetFocus()
        end
      )
      button:SetRelativeWidth(1)
      frame:AddChild(button)
    end

    local heading2 = AceGUI:Create("Heading")
    heading2:SetText(L["Your Saved Snippets"])
    heading2:SetRelativeWidth(1)
    frame:AddChild(heading2)

    -- iterate saved snippets and make buttons
    for order, snippet in ipairs(savedSnippets) do
      local button = AceGUI:Create("WeakAurasSnippetButton")
      local snippetInsert = gsub(snippet.snippet, "|", "||")
      button:SetTitle(snippet.name)
      button:SetDescription(snippetInsert)
      button:SetEditable(true)
      button:SetRelativeWidth(1)
      button:SetNew(snippet.new)
      snippet.new = false
      button:SetCallback(
        "OnClick",
        function()
          editor.editBox:Insert(snippetInsert)
          editor:SetFocus()
        end
      )
      button.deleteButton:SetScript(
        "OnClick",
        function()
          table.remove(savedSnippets, order)
          UpdateSnippets(frame)
        end
      )
      button:SetCallback(
        "OnEnterPressed",
        function()
          local newName = button.renameEditBox:GetText()
          if newName and #newName > 0 then
            local found = false
            for _, snippet in ipairs(savedSnippets) do
              if snippet.name == newName then
                found = true
                break
              end
            end
            if not found then
              savedSnippets[order].name = newName
              UpdateSnippets(frame)
            end
          end
        end
      )
      frame:AddChild(button)
    end
  end

  local apiSearchFrame

  -- Make sidebar for snippets
  local snippetsFrame = CreateFrame("Frame", "WeakAurasSnippets", group.frame, "PortraitFrameTemplate")
  ButtonFrameTemplate_HidePortrait(snippetsFrame)
  snippetsFrame:SetPoint("TOPLEFT", group.frame, "TOPRIGHT", 20, 0)
  snippetsFrame:SetPoint("BOTTOMLEFT", group.frame, "BOTTOMRIGHT", 20, 0)
  snippetsFrame:SetWidth(250)
  if snippetsFrame.Bg then
    local color = CreateColorFromHexString("ff1f1e21") -- PANEL_BACKGROUND_COLOR
    local r, g, b = color:GetRGB()
    snippetsFrame.Bg:SetColorTexture(r, g, b, 0.8)
  end

  -- Add button to save new snippet
  local AddSnippetButton = CreateFrame("Button", nil, snippetsFrame, "UIPanelButtonTemplate")
  AddSnippetButton:SetPoint("TOPLEFT", snippetsFrame, "TOPLEFT", 13, -25)
  AddSnippetButton:SetPoint("TOPRIGHT", snippetsFrame, "TOPRIGHT", -13, -25)
  AddSnippetButton:SetHeight(20)
  AddSnippetButton:SetText(L["Add Snippet"])
  AddSnippetButton:RegisterForClicks("LeftButtonUp")

  -- house the buttons in a scroll frame
  -- All AceGUI from this point, so that buttons can be released and reused
  local snippetsScrollContainer = AceGUI:Create("SimpleGroup")
  snippetsScrollContainer:SetFullWidth(true)
  snippetsScrollContainer:SetFullHeight(true)
  snippetsScrollContainer:SetLayout("Fill")
  snippetsScrollContainer.frame:SetParent(snippetsFrame)
  snippetsScrollContainer.frame:SetPoint("TOPLEFT", snippetsFrame, "TOPLEFT", 17, -50)
  snippetsScrollContainer.frame:SetPoint("BOTTOMRIGHT", snippetsFrame, "BOTTOMRIGHT", -10, 10)
  local snippetsScroll = AceGUI:Create("ScrollFrame")
  snippetsScroll:SetLayout("List")
  snippetsScrollContainer:AddChild(snippetsScroll)
  snippetsScroll:FixScroll(true)
  snippetsScroll.scrollframe:SetScript(
    "OnScrollRangeChanged",
    function(frame)
      frame.obj:DoLayout()
    end
  )

  snippetsFrame:Hide()

  -- Toggle the side bar on click
  snippetsButton:SetScript(
    "OnClick",
    function(self, button, down)
      if not snippetsFrame:IsShown() then
        snippetsFrame:Show()
        if apiSearchFrame and apiSearchFrame:IsShown() then
          apiSearchFrame:Hide()
        end
        UpdateSnippets(snippetsScroll)
      else
        snippetsFrame:Hide()
      end
    end
  )

  AddSnippetButton:SetScript(
    "OnClick",
    function(self)
      local snippet = editor.editBox:GetText()
      if snippet and #snippet > 0 then
        local baseName, name, index = "New Snippet", "New Snippet", 0
        local snippetExists = function(name)
          for _, snippet in ipairs(savedSnippets) do
            if snippet.name == name then
              return true
            end
          end
        end
        while snippetExists(name) do
          index = index + 1
          name = format("%s %d", baseName, index)
        end
        table.insert(savedSnippets, {name = name, snippet = snippet, new = true})
        UpdateSnippets(snippetsScroll)
        end
      end
  )

  -- Make ApiSearch button
  local apiSearchButton = CreateFrame("Button", "WAAPISearchButton", group.frame, "UIPanelButtonTemplate")
  apiSearchButton:SetPoint("BOTTOMRIGHT", editor.frame, "TOPRIGHT", -20, 15)
  apiSearchButton:SetFrameLevel(group.frame:GetFrameLevel() + 2)
  apiSearchButton:SetHeight(20)
  apiSearchButton:SetWidth(100)
  apiSearchButton:SetText(L["Search API"])
  apiSearchButton:RegisterForClicks("LeftButtonUp")

  -- Make sidebar for apiSearch
  apiSearchFrame = CreateFrame("Frame", "WeakAurasAPISearchFrame", group.frame, "PortraitFrameTemplate")
  ButtonFrameTemplate_HidePortrait(apiSearchFrame)
  apiSearchFrame:SetWidth(350)
  if apiSearchFrame.Bg then
    local color = CreateColorFromHexString("ff1f1e21") -- PANEL_BACKGROUND_COLOR
    local r, g, b = color:GetRGB()
    apiSearchFrame.Bg:SetColorTexture(r, g, b, 0.8)
  end

  local makeAPISearch
  local APISearchTextChangeDelay = 0.3
  local APISearchCTimer

  -- filter line
  local filterInput = CreateFrame("EditBox", "WeakAurasAPISearchFilterInput", apiSearchFrame, "SearchBoxTemplate")
  filterInput:SetScript("OnTextChanged", function(self)
    SearchBoxTemplate_OnTextChanged(self)
    if APISearchCTimer then
      APISearchCTimer:Cancel()
    end
    APISearchCTimer = C_Timer.NewTimer(
      APISearchTextChangeDelay,
      function()
        makeAPISearch(filterInput:GetText())
      end
    )
  end)
  filterInput:SetHeight(15)
  filterInput:SetPoint("TOPLEFT", apiSearchFrame, "TOPLEFT", 17, -30)
  filterInput:SetPoint("TOPRIGHT", apiSearchFrame, "TOPRIGHT", -10, -30)
  filterInput:SetFont(STANDARD_TEXT_FONT, 10, "")

  local apiSearchScrollContainer = AceGUI:Create("SimpleGroup")
  apiSearchScrollContainer:SetFullWidth(true)
  apiSearchScrollContainer:SetFullHeight(true)
  apiSearchScrollContainer:SetLayout("Fill")
  apiSearchScrollContainer.frame:SetParent(apiSearchFrame)
  apiSearchScrollContainer.frame:SetPoint("TOPLEFT", apiSearchFrame, "TOPLEFT", 17, -50)
  apiSearchScrollContainer.frame:SetPoint("BOTTOMRIGHT", apiSearchFrame, "BOTTOMRIGHT", -10, 10)

  local apiSearchScroll = AceGUI:Create("ScrollFrame")
  apiSearchScroll:SetLayout("List")
  apiSearchScrollContainer:AddChild(apiSearchScroll)
  apiSearchScroll:FixScroll(true)
  apiSearchScroll.scrollframe:SetScript(
    "OnScrollRangeChanged",
    function(frame)
      frame.obj:DoLayout()
    end
  )

  local snippetOnClickCallback = function(self)
    if self.isSystem then
      filterInput:SetText(self.name)
    else
      self.editor.editBox:Insert(self.name)
      self.editor:SetFocus()
    end
  end

  local function loadBlizzardAPIDocumentation()
    local apiAddonName = "Blizzard_APIDocumentation"
    local _, loaded = C_AddOns.IsAddOnLoaded(apiAddonName)
    if not loaded then
      C_AddOns.LoadAddOn(apiAddonName)
    end
    if #APIDocumentation.systems == 0 then
      APIDocumentation_LoadUI()
    end
  end

  local function addLine(results, apiInfo)
    local name
    if apiInfo.Type == "System" then
      name = apiInfo.Namespace
    elseif apiInfo.Type == "Function" then
      name = apiInfo:GetFullName()
    elseif apiInfo.Type == "Event" then
      name = apiInfo.LiteralName
    end
    table.insert(results, { name = name, apiInfo = apiInfo })
  end

  local function APIListSystems()
    local results = {}
    for i, systemInfo in ipairs(APIDocumentation.systems) do
      if systemInfo.Namespace and #systemInfo.Functions > 0 then
        addLine(results, systemInfo)
      end
    end
    table.sort(results, function(a, b)
      return a.name < b.name
    end)
    return results
  end

  local function APISearch(word)
    local lowerWord = word:lower()
    local results = {}

    -- if search match name of namespace, show all functions & events for the namespace, and also show all other functions & events matching the search
    -- if search is composed with name of a namespace and a word separated by a dot, show matching function for matching namespace

    local nsName, rest = lowerWord:match("^([%w%_]+)(.*)")
    local funcName = rest and rest:match("^%.([%w%_]+)")

    for _, systemInfo in ipairs(APIDocumentation.systems) do
      -- search for namespaceName or namespaceName.functionName
      local systemMatch = nsName and #nsName >= 4
        and systemInfo.Namespace and systemInfo.Namespace:lower():match(nsName)

      for _, apiInfo in ipairs(systemInfo.Functions) do
        if systemMatch then
          if funcName then
            if apiInfo:MatchesSearchString(funcName) then
              addLine(results, apiInfo)
            end
          else
            addLine(results, apiInfo)
          end
        else
          if apiInfo:MatchesSearchString(lowerWord) then
            addLine(results, apiInfo)
          end
        end
      end

      if systemMatch and rest == "" then
        for _, apiInfo in ipairs(systemInfo.Events) do
          addLine(results, apiInfo)
        end
      else
        for _, apiInfo in ipairs(systemInfo.Events) do
          if apiInfo:MatchesSearchString(lowerWord) then
            addLine(results, apiInfo)
          end
        end
      end
    end

    return results
  end

  local lastSearch = nil
  makeAPISearch = function(apiToSearchFor)
    loadBlizzardAPIDocumentation()
    local results
    if not apiToSearchFor or #apiToSearchFor < 4 then
      if lastSearch == "" then return end
      results = APIListSystems()
      lastSearch = ""
    else
      if lastSearch == apiToSearchFor then return end
      results = APISearch(apiToSearchFor)
      lastSearch = apiToSearchFor
    end
    apiSearchScroll:ReleaseChildren()
    for _, element in ipairs(results) do
      local apiInfo = element.apiInfo
      if apiInfo then
        local button = AceGUI:Create("WeakAurasSnippetButton")
        button:SetTitle(element.name)
        button:SetEditable(false)
        button:SetHeight(20)
        button:SetRelativeWidth(1)
        if apiInfo.Type ~= "System" and apiInfo.GetDetailedOutputLines then
          local desc = table.concat(apiInfo:GetDetailedOutputLines(), "\n")
          button:SetDescription(desc)
        else
          button:SetDescription()
        end
        button.name = element.name
        button.editor = editor
        button.isSystem = apiInfo.Type == "System"
        button:SetCallback("OnClick", snippetOnClickCallback)
        apiSearchScroll:AddChild(button)
      end
    end
  end

  apiSearchFrame:Hide()

  -- Toggle the side bar on click
  apiSearchButton:SetScript(
    "OnClick",
    function()
      if apiSearchFrame:IsShown() then
        apiSearchFrame:Hide()
      else
        apiSearchFrame:Show()
        apiSearchFrame:ClearAllPoints()
        apiSearchFrame:SetPoint("TOPLEFT", group.frame, "TOPRIGHT", 20, 0)
        apiSearchFrame:SetPoint("BOTTOMLEFT", group.frame, "BOTTOMRIGHT", 20, 0)
        filterInput:SetFocus()
        if snippetsFrame and snippetsFrame:IsShown() then
          snippetsFrame:Hide()
        end
      end
    end
  )

  editor.editBox.timeMachine = {}
  editor.editBox.timeMachinePos = 1
  local TimeMachineMaximumRollback = 10

  editor.editBox:HookScript(
    "OnKeyDown",
    function(self, key)
      -- CTRL + S saves and closes
      if IsControlKeyDown() and key == "S" then
        group:Close()
      elseif key == "Z" and IsControlKeyDown() then
        self:SetPropagateKeyboardInput(false)
        if self.timeMachine[self.timeMachinePos + 1] then
          self.timeMachinePos = self.timeMachinePos + 1
          self.skipOnTextChanged = true
          originalSetText(self, self.timeMachine[self.timeMachinePos][1])
          self:SetCursorPosition(self.timeMachine[self.timeMachinePos][2])
        end
      elseif key == "Y" and IsControlKeyDown() then
        self:SetPropagateKeyboardInput(false)
        if self.timeMachine[self.timeMachinePos - 1] then
          self.timeMachinePos = self.timeMachinePos - 1
          self.skipOnTextChanged = true
          originalSetText(self, self.timeMachine[self.timeMachinePos][1])
          self:SetCursorPosition(self.timeMachine[self.timeMachinePos][2])
        end
      end
    end
  )

  editor.editBox:HookScript(
    "OnTextChanged",
    function(self, userInput)
      local str = editor.editBox:GetText()
      if not str or str:trim() == "" or editor.combinedText == true then
        self.group.editorError:SetText("")
      else
        local func, errorString
        if (self.group.enclose) then
          func, errorString = OptionsPrivate.Private.LoadFunction("return function() " .. str .. "\n end", self.group.data.id, true)
        else
          func, errorString = OptionsPrivate.Private.LoadFunction("return " .. str, self.group.data.id, true)
        end
        if not errorString and self.group.validator then
          errorString = self.group.validator(func)
        end
        if errorString then
          if self.url then
            helpButton:Show()
          end
          self.group.editorError:Show()
          self.group.editorError:SetText(errorString)
        else
          self.group.editorError:SetText("")
        end
      end

      if not userInput then return end
      if self.skipOnTextChanged then
        self.skipOnTextChanged = false
        return
      end
      local cursorPosition = self:GetCursorPosition()
      local text = originalGetText(self)
      if IndentationLib then
        text, cursorPosition = IndentationLib.stripWowColorsWithPos(text, cursorPosition)
      end
      if self.timeMachine[1] and text == self.timeMachine[1][1] then
        return
      end
      -- if cursor is not at position 1, remove elements before cursor
      for i = 2, self.timeMachinePos do
        table.remove(self.timeMachine, 1)
      end
      -- insert current text
      table.insert(self.timeMachine, 1, {text, cursorPosition - 1})
      -- timeMachine is limited to a number of TimeMachineMaximumRollback elements
      for i = #self.timeMachine, TimeMachineMaximumRollback + 1, -1 do
        table.remove(self.timeMachine, i)
      end
      self.timeMachinePos = 1
    end
  )

  -- bracket matching
  editor.editBox:HookScript(
    "OnChar",
    function(_, char)
      if not IsControlKeyDown() and WeakAurasSaved.editor_bracket_matching then
        if char == "(" then
          editor.editBox:Insert(")")
          editor.editBox:SetCursorPosition(editor.editBox:GetCursorPosition() - 1)
        elseif char == "{" then
          editor.editBox:Insert("}")
          editor.editBox:SetCursorPosition(editor.editBox:GetCursorPosition() - 1)
        elseif char == "[" then
          editor.editBox:Insert("]")
          editor.editBox:SetCursorPosition(editor.editBox:GetCursorPosition() - 1)
        end
      end
    end
  )

  local editorError = group.frame:CreateFontString(nil, "OVERLAY")
  editorError:SetFont(STANDARD_TEXT_FONT, 12, "")
  editorError:SetJustifyH("LEFT")
  editorError:SetJustifyV("TOP")
  editorError:SetTextColor(1, 0, 0)
  editorError:SetPoint("LEFT", helpButton, "RIGHT", 0, 4)
  editorError:SetPoint("RIGHT", settings_frame, "LEFT")
  group.editorError = editorError

  local editorLine = CreateFrame("EditBox", nil, group.frame, "InputBoxTemplate")
  -- Set script on enter pressed..
  editorLine:SetPoint("RIGHT", snippetsButton, "LEFT", -10, 0)
  editorLine:SetFont(STANDARD_TEXT_FONT, 10, "")
  editorLine:SetJustifyH("RIGHT")
  editorLine:SetWidth(30)
  editorLine:SetHeight(20)
  editorLine:SetNumeric(true)
  editorLine:SetTextInsets(0, 5, 0, 0)
  editorLine:SetAutoFocus(false)

  local editorLineText = group.frame:CreateFontString(nil, "OVERLAY")
  editorLineText:SetFont(STANDARD_TEXT_FONT, 10)
  editorLineText:SetTextColor(1, 1, 1)
  editorLineText:SetText(L["Line"])
  editorLineText:SetPoint("RIGHT", editorLine, "LEFT", -8, 0)

  helpButton:SetScript("OnClick", function()
    OptionsPrivate.ToggleTip(helpButton, group.url, L["Help"], "")
  end)

  local oldOnCursorChanged = editor.editBox:GetScript("OnCursorChanged")
  editor.editBox:SetScript(
    "OnCursorChanged",
    function(...)
      oldOnCursorChanged(...)
      local cursorPosition = editor.editBox:GetCursorPosition()
      local next = -1
      local line = 0
      while (next and cursorPosition >= next) do
        next = originalGetText(editor.editBox):find("[\n]", next + 1)
        line = line + 1
      end
      editorLine:SetNumber(line)
    end
  )

  editorLine:SetScript(
    "OnEnterPressed",
    function()
      local newLine = editorLine:GetNumber()
      local newPosition = 0
      while (newLine > 1 and newPosition) do
        newPosition = originalGetText(editor.editBox):find("[\n]", newPosition + 1)
        newLine = newLine - 1
      end

      if (newPosition) then
        editor.editBox:SetCursorPosition(newPosition)
        editor.editBox:SetFocus()
      end
    end
  )

  function group.Open(self, data, path, enclose, multipath, reloadOptions, setOnParent, url, validator)
    self.data = data
    self.path = path
    self.multipath = multipath
    self.reloadOptions = reloadOptions
    self.setOnParent = setOnParent
    self.url = url
    self.enclose = enclose
    self.validator = validator
    if url then
      helpButton:Show()
    else
      helpButton:Hide()
    end
    if (frame.window == "texture") then
      local texturepicker = OptionsPrivate.TexturePicker(frame, true)
      if texturepicker then
        texturepicker:CancelClose()
      end
    elseif (frame.window == "icon") then
      local iconpicker = OptionsPrivate.IconPicker(frame, true)
      if iconpicker then
        iconpicker:CancelClose()
      end
    end
    frame.window = "texteditor"
    frame:UpdateFrameVisible()
    local title = (type(data.id) == "string" and data.id or L["Temporary Group"]) .. " -"
    if (not multipath) then
      for index, field in pairs(path) do
        if (type(field) == "number") then
          field = "Trigger " .. field
        end
        title = title .. " " .. field:sub(1, 1):upper() .. field:sub(2)
      end
    end
    editor:SetLabel(title)
    editor.editBox.timeMachine = {}
    editor.editBox.timeMachinePos = 1
    editor.editBox:SetScript(
      "OnEscapePressed",
      function()
        -- catch it so that escape doesn't default to losing focus (after which another escape would close config)
      end
    )

    if setOnParent then
      editor:SetText(OptionsPrivate.Private.ValueFromPath(data, path) or "")
    else
      local singleText
      local sameTexts = true
      local combinedText = ""
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
        local text
        if multipath then
          text = path[child.id] and OptionsPrivate.Private.ValueFromPath(child, path[child.id])
        else
          text = OptionsPrivate.Private.ValueFromPath(child, path)
        end
        if text then
          if not (singleText) then
            singleText = text
          else
            if singleText ~= text then
              sameTexts = false
            end
          end
          if combinedText ~= "" then
            combinedText = combinedText .. "\n\n"
          end

          combinedText =
            combinedText .. L["-- Do not remove this comment, it is part of this aura: "] .. child.id .. "\n"
          combinedText = combinedText .. (text or "")
        end
      end
      if (sameTexts) then
        editor:SetText(singleText or "")
        editor.combinedText = false
      else
        editor:SetText(combinedText)
        editor.combinedText = true
      end
    end
    editor:SetFocus()
  end

  function group.CancelClose(self)
    editor:ClearFocus()
    frame:HideTip()
    frame.window = "default"
    frame:UpdateFrameVisible()
  end

  local function extractTexts(input)
    local texts = {}

    local currentPos, id, startIdLine, startId, endId, endIdLine
    while (true) do
      startIdLine, startId =
        string.find(input, L["-- Do not remove this comment, it is part of this aura: "], currentPos, true)
      if (not startId) then
        break
      end

      endId, endIdLine = string.find(input, "\n", startId, true)
      if (not endId) then
        break
      end

      if (currentPos) then
        local trimmedPosition = startIdLine - 1
        while (string.sub(input, trimmedPosition, trimmedPosition) == "\n") do
          trimmedPosition = trimmedPosition - 1
        end

        texts[id] = string.sub(input, currentPos, trimmedPosition)
      end

      id = string.sub(input, startId + 1, endId - 1)

      currentPos = endIdLine + 1
    end

    if (id) then
      texts[id] = string.sub(input, currentPos, string.len(input))
    end

    return texts
  end

  function group.Close(self)
    if self.setOnParent then
      OptionsPrivate.Private.ValueToPath(self.data, self.path, editor:GetText())
      WeakAuras.Add(self.data)
    else
      local textById = editor.combinedText and extractTexts(editor:GetText())
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(self.data) do
        local text = editor.combinedText and (textById[child.id] or "") or editor:GetText()
        OptionsPrivate.Private.ValueToPath(child, self.multipath and self.path[child.id] or self.path, text)
        WeakAuras.Add(child)
        OptionsPrivate.ClearOptions(child.id)
      end
    end

    WeakAuras.ClearAndUpdateOptions(self.data.id)

    editor:ClearFocus()

    frame.window = "default"
    frame:UpdateFrameVisible()
    WeakAuras.FillOptions()
  end

  return group
end

function OptionsPrivate.TextEditor(frame, noConstruct)
  textEditor = textEditor or (not noConstruct and ConstructTextEditor(frame))
  return textEditor
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/TextEditor.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/TexturePicker.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)
local GetAtlasInfo = C_Texture and  C_Texture.GetAtlasInfo or GetAtlasInfo

-- Lua APIs
local wipe = wipe
local pairs, next, type = pairs, next, type

-- WoW APIs
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local function CompareValues(a, b)
  if type(a) ~= type(b) then
    return false
  end
  if type(a) == "table" then
    for k, v in pairs(a) do
      if v ~= b[k] then
        return false
      end
    end

    for k, v in pairs(b) do
      if v ~= a[k] then
        return false
      end
    end

    return true
  else
    return a == b
  end
end

local function GetAll(baseObject, paths, property, default)
  local valueFromPath = OptionsPrivate.Private.ValueFromPath
  if not property then
    return default
  end

  local result = default
  local first = true
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(baseObject) do
    local childObject = valueFromPath(child, paths[child.id])
    if childObject and childObject[property] then
      if first then
        result = childObject[property]
        first = false
      else
        if not CompareValues(result, childObject[property]) then
          return default
        end
      end
    end
  end
  return result
end

local function SetAll(baseObject, paths, property, value, width, height, adjustSize)
  local valueFromPath = OptionsPrivate.Private.ValueFromPath
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(baseObject) do
    local object = valueFromPath(child, paths[child.id])
      if object then
        object[property] = value
        if adjustSize and width and height then
          child.width = width
          child.height = height
        end
        WeakAuras.Add(child)
        WeakAuras.ClearAndUpdateOptions(child.id)
        WeakAuras.UpdateThumbnail(child)
      end
  end
end

local texturePicker

local function ConstructTexturePicker(frame)
  local group = AceGUI:Create("SimpleGroup");
  group.frame:SetParent(frame);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -17, 46);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 17, -50);
  group.frame:Hide();
  group.children = {};
  group.categories = {};
  group.textureWidgets = {}

  local dropdown = AceGUI:Create("DropdownGroup");
  dropdown:SetLayout("fill");
  dropdown.width = "fill";
  dropdown:SetHeight(390);
  group:SetLayout("fill");
  group:AddChild(dropdown);
  dropdown.list = {};
  dropdown:SetGroupList(dropdown.list);

  local scroll = AceGUI:Create("WeakAurasScrollArea");
  scroll:SetWidth(540);
  dropdown:AddChild(scroll);

  local function UpdateShownWidgets()
    -- Acquires/Releases widgets based on the scroll position
    for _, widget in ipairs(group.textureWidgets) do
      widget.frame:Hide()
      widget:Release()
    end
    wipe(group.textureWidgets)
    local viewportWidth, viewportHeight = scroll:GetViewportSize()

    local texturesPerRow = floor(viewportWidth / 128)
    local topRow = floor(scroll:GetContentOffset() / 128)
    local bottomRow = topRow + ceil(viewportHeight / 128)

    local first = topRow * texturesPerRow + 1
    local last = first + (bottomRow - topRow + 1) * texturesPerRow - 1

    for i = first, last do
      local data = group.selectedGroupSorted[i]
      if data then
        local texturePath, textureName = data[1], data[2]
        local textureWidget = AceGUI:Create("WeakAurasTextureButton");
        tinsert(group.textureWidgets, textureWidget)
        if (group.SetTextureFunc) then
          group.SetTextureFunc(textureWidget, texturePath, textureName);
        else
          textureWidget:SetTexture(texturePath, textureName);
          local d = group.textureData;
          textureWidget:ChangeTexture(d.r, d.g, d.b, d.a, d.texRotation, d.auraRotation, d.mirror, d.blendMode)
        end
        if group.selectedTextures[texturePath] then
          textureWidget:Pick()
        end
        textureWidget:SetClick(function()
          group:Pick(texturePath);
        end);

        local index = i - 1 -- Math is easier if we start counting at 0
        local textureY = floor(index / texturesPerRow) * -128
        local textureX = (index % texturesPerRow) * 128

        textureWidget.frame:Show()
        textureWidget.frame:SetParent(scroll.content)
        textureWidget.frame:SetPoint("TOPLEFT", textureX, textureY)
      end
    end
  end

  scroll:SetCallback("ContentScrolled", function(self)
    UpdateShownWidgets()
  end)

  local function texturePickerGroupSelected(widget, event, uniquevalue, filter)
    group.selectedGroupSorted = {}
    if filter then
      filter = filter:lower()
    end
    local category = group.textures[uniquevalue]
    local cat = type(category) == "function" and category() or category
    for texturePath, textureName in pairs(cat) do
      if filter == nil or filter == "" or textureName:lower():find(filter, 1, true) then
        tinsert(group.selectedGroupSorted, {texturePath, textureName})
      end
    end

    table.sort(group.selectedGroupSorted, function(a, b)
      local aPath, bPath = a[1], b[1]
      local aNum, bNum = tonumber(aPath:match("%d+")), tonumber(bPath:match("%d+"));
      local aNonNumber, bNonNumber = aPath:match("[^%d]+"), bPath:match("[^%d]+")
      if(aNum and bNum and aNonNumber == bNonNumber) then
        return aNum < bNum;
      else
        return aPath < bPath;
        end
    end)

    local viewportWidth = scroll:GetViewportSize()
    local texturesPerRow = floor(viewportWidth / 128)
    if texturesPerRow == 0 then
      texturesPerRow = 1
    end
    local totalHeight = ceil(#group.selectedGroupSorted / texturesPerRow) * 128
    scroll:SetContentHeight(totalHeight)

    UpdateShownWidgets()
  end

  local input = CreateFrame("EditBox", nil, group.frame, "SearchBoxTemplate");
  input:SetScript("OnTextChanged", function(self, ...)
    SearchBoxTemplate_OnTextChanged(self)
    local status = dropdown.status or dropdown.localstatus
    texturePickerGroupSelected(nil, nil, status.selected, input:GetText())
  end);
  input:SetScript("OnEnterPressed", function(...)
    local status = dropdown.status or dropdown.localstatus
    texturePickerGroupSelected(nil, nil, status.selected, input:GetText())
  end);
  input:SetScript("OnEscapePressed", function(...)
    input:SetText("");
    local status = dropdown.status or dropdown.localstatus
    texturePickerGroupSelected(nil, nil, status.selected, input:GetText())
  end);
  input:SetWidth(200);
  input:SetHeight(15);
  input:SetPoint("TOPRIGHT", group.frame, "TOPRIGHT", -3, -10);

  dropdown:SetCallback("OnGroupSelected", function(widget, event, uniquevalue)
    texturePickerGroupSelected(widget, event, uniquevalue, input:GetText())
  end)

  function group.UpdateList(self)
    dropdown.dropdown.pullout:Close()
    wipe(dropdown.list);
    for categoryName, category in pairs(self.textures) do
      local match = false;
      local cat = type(category) == "function" and category() or category
      for texturePath, textureName in pairs(cat) do
        if(self.selectedTextures[texturePath]) then
          match = true;
          break;
        end
      end
      dropdown.list[categoryName] = (match and "|cFF80A0FF" or "")..categoryName;
    end
    dropdown:SetGroupList(dropdown.list);
  end

  function group.Pick(self, texturePath)
    local pickedwidget;
    for index, widget in ipairs(group.textureWidgets) do
      widget:ClearPick();
      if(widget:GetTexturePath() == texturePath) then
        pickedwidget = widget;
      end
    end
    local width, height, flipbookInfo
    if(pickedwidget) then
      pickedwidget:Pick();
      if not pickedwidget.texture.IsStopMotion then
        local atlasInfo = GetAtlasInfo(pickedwidget.texture.path)
        if atlasInfo then
          width = atlasInfo.width
          height = atlasInfo.height
        end
      else
        flipbookInfo = OptionsPrivate.GetFlipbookTileSize(pickedwidget.texture.path)
        if flipbookInfo then
          width = flipbookInfo.tileWidth
          height = flipbookInfo.tileHeight
        end
      end
    end

    wipe(group.selectedTextures)
    group.selectedTextures[texturePath] = true

    SetAll(self.baseObject, self.paths, self.properties.texture, texturePath, width, height, self.adjustSize)

    group:UpdateList();
    local status = dropdown.status or dropdown.localstatus
    dropdown.dropdown:SetText(dropdown.list[status.selected]);
  end

  function group.Open(self, baseObject, paths, properties, textures, SetTextureFunc, adjustSize)
    local valueFromPath = OptionsPrivate.Private.ValueFromPath
    self.baseObject = baseObject
    self.paths = paths
    self.properties = properties
    self.textures = textures;
    self.SetTextureFunc = SetTextureFunc
    self.givenPath = {};
    self.selectedTextures = {}
    self.adjustSize = adjustSize

    for child in OptionsPrivate.Private.TraverseLeafsOrAura(baseObject) do
      local object = valueFromPath(child, paths[child.id])
      if object and object[properties.texture] then
        local texture = object[properties.texture]
        self.givenPath[child.id] = texture
        self.selectedTextures[texture] = true
      else
        self.givenPath[child.id] = ""
      end
    end

    local colorAll = GetAll(baseObject, paths, properties.color, {1, 1, 1, 1});
    self.textureData = {
      r = colorAll[1] or 1,
      g = colorAll[2] or 1,
      b = colorAll[3] or 1,
      a = colorAll[4] or 1,
      auraRotation = GetAll(baseObject, paths, properties.auraRotation, 0),
      texRotation = GetAll(baseObject, paths, properties.rotation, 0),
      mirror = GetAll(baseObject, paths, properties.mirror, false),
      blendMode = GetAll(baseObject, paths, properties.blendMode, "ADD")
    }

    frame.window = "texture";
    frame:UpdateFrameVisible()
    group:UpdateList()
    local picked = false;
    for categoryName, category in pairs(self.textures) do
      if not(picked) then
        local cat = type(category) == "function" and category() or category
        for texturePath, textureName in pairs(cat) do
          if(self.selectedTextures[texturePath]) then
            dropdown:SetGroup(categoryName);
            picked = true;
            break;
          end
        end
      end
    end
    if not(picked) then
      local categoryName = next(self.textures)
      if(categoryName) then
        dropdown:SetGroup(categoryName);
      end
    end
    UpdateShownWidgets()
  end

  function group.Close()
    frame.window = "default";
    frame:UpdateFrameVisible()
    WeakAuras.FillOptions()
  end

  function group.CancelClose()
    local valueFromPath = OptionsPrivate.Private.ValueFromPath
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(group.baseObject) do
      local childObject = valueFromPath(child, group.paths[child.id])
      if childObject then
        childObject[group.properties.texture] = group.givenPath[child.id]
        WeakAuras.Add(child);
        WeakAuras.UpdateThumbnail(child);
      end
    end
    group.Close();
  end

  local cancel = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate")
  cancel:SetScript("OnClick", group.CancelClose)
  cancel:SetPoint("BOTTOMRIGHT", -20, -24)
  cancel:SetSize(100, 20)
  cancel:SetText(L["Cancel"])

  local close = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate")
  close:SetScript("OnClick", group.Close)
  close:SetPoint("RIGHT", cancel, "LEFT", -10, 0)
  close:SetSize(100, 20)
  close:SetText(L["Okay"])

  return group
end

function OptionsPrivate.TexturePicker(frame, noConstruct)
  texturePicker = texturePicker or (not noConstruct and ConstructTexturePicker(frame))
  return texturePicker
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/TexturePicker.lua ===


=== FILE: WeakAurasOptions/OptionsFrames/Update.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local AceGUI = LibStub("AceGUI-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

-- Scam Check
local function notEmptyString(str)
  return str and str ~= "" and string.find(str, "%S")
end

local function addCode(codes, text, code, ...)
  -- The 4th parameter is a "check" if the code is active
  -- The following line let's distinguish between addCode(a, b, c, nil) and addCode(a, b, c)
  -- If the 4th parameter is nil, then we want to return
  if (select("#", ...) > 0) then
    if not select(1, ...) then
      return
    end
  end

  if code and notEmptyString(code) then
    local t = {};
    t.text = text;
    t.value = text
    t.code = code
    tinsert(codes, t);
  end
end

local function checkTrigger(codes, id, trigger, untrigger)
  if not trigger or trigger.type ~= "custom" then return end;

  addCode(codes, L["%s Trigger Function"]:format(id), trigger.custom)

  if trigger.custom_type == "stateupdate" then
    addCode(codes, L["%s Custom Variables"]:format(id), trigger.customVariables, trigger.custom_type == "stateupdate")
  else
    addCode(codes, L["%s Untrigger Function"]:format(id), untrigger and untrigger.custom)
    addCode(codes, L["%s Duration Function"]:format(id), trigger.customDuration)
    addCode(codes, L["%s Name Function"]:format(id), trigger.customName)
    addCode(codes, L["%s Icon Function"]:format(id), trigger.customIcon)
    addCode(codes, L["%s Texture Function"]:format(id),trigger.customTexture)
    addCode(codes, L["%s Stacks Function"]:format(id), trigger.customStacks)
    for i = 1, 7 do
      local property = "customOverlay" .. i;
      addCode(codes, L["%s %u. Overlay Function"]:format(id, i), trigger[property])
    end
  end
end

local function checkAnimation(codes, id, a)
  if not a or a.type ~= "custom" then return end
  addCode(codes, L["%s - Alpha Animation"]:format(id), a.alphaFunc, a.alphaType == "custom" and a.use_alpha)
  addCode(codes, L["%s - Translate Animation"]:format(id), a.translateFunc, a.translateType == "custom" and a.use_translate)
  addCode(codes, L["%s - Scale Animation"]:format(id), a.scaleFunc, a.scaleType == "custom" and a.use_scale)
  addCode(codes, L["%s - Rotate Animation"]:format(id), a.rotateFunc, a.rotateType == "custom" and a.use_rotate)
  addCode(codes, L["%s - Color Animation"]:format(id), a.colorFunc, a.colorType == "custom" and a.use_color)
end

local function scamCheck(codes, data)
  for i, v in ipairs(data.triggers) do
    checkTrigger(codes, L["%s - %i. Trigger"]:format(data.id, i), v.trigger, v.untrigger);
  end

  addCode(codes,  L["%s - Trigger Logic"]:format(data.id), data.triggers.customTriggerLogic, data.triggers.disjunctive == "custom");
  addCode(codes, L["%s - Custom Text"]:format(data.id), data.customText)
  addCode(codes, L["%s - Custom Anchor"]:format(data.id), data.customAnchor, data.anchorFrameType == "CUSTOM")

  if (data.actions) then
    if data.actions.init then
      addCode(codes, L["%s - Init Action"]:format(data.id), data.actions.init.custom, data.actions.init.do_custom)
      addCode(codes, L["%s - OnLoad"]:format(data.id), data.actions.init.customOnLoad, data.actions.init.do_custom_load)
      addCode(codes, L["%s - OnUnload"]:format(data.id), data.actions.init.customOnUnload, data.actions.init.do_custom_unload)
    end

    if data.actions.start then
      addCode(codes, L["%s - Start Action"]:format(data.id), data.actions.start.custom, data.actions.start.do_custom)
      addCode(codes, L["%s - Start Custom Text"]:format(data.id), data.actions.start.message_custom, data.actions.start.do_message)
    end
    if data.actions.finish then
      addCode(codes, L["%s - Finish Action"]:format(data.id), data.actions.finish.custom, data.actions.finish.do_custom)
      addCode(codes, L["%s - Finish Custom Text"]:format(data.id), data.actions.finish.message_custom, data.actions.finish.do_message)
    end
  end

  if (data.animation) then
    checkAnimation(codes, L["%s - Start"]:format(data.id), data.animation.start);
    checkAnimation(codes, L["%s - Main"]:format(data.id), data.animation.main);
    checkAnimation(codes, L["%s - Finish"]:format(data.id), data.animation.finish);
  end

  addCode(codes, L["%s - Custom Grow"]:format(data.id), data.customGrow, data.regionType == "dynamicgroup" and data.grow == "CUSTOM")
  addCode(codes, L["%s - Custom Sort"]:format(data.id), data.customSort, data.regionType == "dynamicgroup" and data.sort == "custom")
  addCode(codes, L["%s - Custom Anchor"]:format(data.id), data.customAnchorPerUnit,
          data.regionType == "dynamicgroup" and data.grow ~= "CUSTOM" and data.useAnchorPerUnit and data.anchorPerUnit == "CUSTOM")

  if (data.conditions) then
    local customChat = 1
    local customCode = 1
    local customCheck = 1
    for _, condition in ipairs(data.conditions) do
      if (condition.changes) then
        for _, property in ipairs(condition.changes) do
          if type(property.value) == "table" and property.value.custom then
            if property.property == "chat" then
              addCode(codes, L["%s - Condition Custom Chat %s"]:format(data.id, customChat), property.value.custom);
              customChat = customChat + 1
            elseif property.property == "customcode" then
              addCode(codes, L["%s - Condition Custom Code %s"]:format(data.id, customCode), property.value.custom);
              customCode = customCode + 1
            end
          end
        end
      end

      local function recurseAddCustomCheck(checks)
        if not checks then return end
        for _, check in pairs(checks) do
          if check.trigger == -1 and check.variable == "customcheck" then
            addCode(codes, L["%s - Condition Custom Check %s"]:format(data.id, customCheck), check.value);
            customCheck = customCheck + 1
          end
          recurseAddCustomCheck(check.checks)
        end
      end

      if condition.check then
        if condition.check.trigger == -1 and condition.check.variable == "customcheck" then
          addCode(codes, L["%s - Condition Custom Check %s"]:format(data.id, customCheck), condition.check.value);
          customCheck = customCheck + 1
        end
        recurseAddCustomCheck(condition.check.checks)
      end
    end
  end
end
-- End of scam check

-- Diff algorithm
local deleted = {} -- magic value
local fieldToCategory
local internalFieldMarker = {}

local function FieldToCategory(field, isRoot)
  if not fieldToCategory then
    -- Initialize fieldToCategory
    fieldToCategory = {}
    for _, cat in ipairs(OptionsPrivate.Private.update_categories) do
      for _, property in ipairs(cat.fields) do
        fieldToCategory[property] = cat.name
      end
    end
    for _, key in pairs(OptionsPrivate.Private.internal_fields) do
      fieldToCategory[key] = internalFieldMarker
    end
  end

  local category = fieldToCategory[field]
  if category == internalFieldMarker then
    return nil
  end

  if category == nil then
    category = "display"
  end
  -- For child auras, anchor fields are arrangement
  if not isRoot and category == "anchor" then
    category = "arrangement"
  end
  return category
end

local function recurseUpdate(data, chunk)
  for k,v in pairs(chunk) do
    if v == deleted then
      data[k] = nil
    elseif type(v) == 'table' and type(data[k]) == 'table' then
      recurseUpdate(data[k], v)
    else
      data[k] = v
    end
  end
end

local function RecurseDiff(ours, theirs, ignored)
  local diff, seen, same = {}, {}, true
  for key, ourVal in pairs(ours) do
    local ignoredVal = ignored and ignored[key]
    if not ignoredVal or type(ignoredVal) == "table" then
      seen[key] = true
      local theirVal = theirs[key]
      if type(ourVal) == "table" and type(theirVal) == "table" then
        local diffVal = RecurseDiff(ourVal, theirVal, type(ignoredVal) == "table" and ignoredVal or nil)
        if diffVal then
          diff[key] = diffVal
          same = false
        end
      elseif ourVal ~= theirVal and -- of course, floating points can be nonequal by less than we could possibly care
      not(type(ourVal) == "number" and type(theirVal) == "number" and math.abs(ourVal - theirVal) < 1e-6) then
        if (theirVal == nil) then
          diff[key] = deleted
        else
          diff[key] = theirVal;
        end
        same = false
      end
    end
  end
  for key, theirVal in pairs(theirs) do
    if not seen[key] and not (type(ignored) == "table" and ignored[key] == true) then
      diff[key] = theirVal
      same = false
    end
  end
  if not same then return diff end
end

-- for debug purposes
local function RecurseSerial(lines, depth, chunk)
  for k, v in pairs(chunk) do
    if v == deleted then
      tinsert(lines, string.rep("  ", depth) .. "|cFFFF0000" .. k .. " -> deleted|r")
    elseif type(v) == "table" then
      tinsert(lines, string.rep("  ", depth) .. k .. " -> {")
      RecurseSerial(lines, depth + 1, v)
      tinsert(lines, string.rep("  ", depth) .. "}")
    else
      tinsert(lines, string.rep("  ", depth) .. k .. " -> " .. tostring(v))
    end
  end
end

local function DebugPrintDiff(diff, id, uid)
  local lines = {
    "==========================",
    string.format("Diff detected for %q (%s):", id, uid),
    "{",
  }
  RecurseSerial(lines, 1, diff)
  tinsert(lines, "}")
  tinsert(lines, "==========================")
  print(table.concat(lines, "\n"))
end

local function Diff(ours, theirs)
  local ignored = CreateFromMixins(
    OptionsPrivate.Private.internal_fields,
    OptionsPrivate.Private.non_transmissable_fields
  )

  -- generates a diff which WeakAuras.Update can use
  local debug = false
  if not ours or not theirs then return end
  local diff = RecurseDiff(ours, theirs, ignored)
  if diff then
    if debug then
      DebugPrintDiff(diff, theirs.id, theirs.uid)
    end
    return diff
  end
end
-- End of diff

local function EnsureUniqueUid(data)
  if not data.uid then
    data.uid = WeakAuras.GenerateUniqueID()
  elseif OptionsPrivate.Private.GetDataByUID(data.uid) then
    data.uid = WeakAuras.GenerateUniqueID()
  end
end

local function CopyDiff(diff)
  local copy = {}
  for k, v in pairs(diff) do
    if v == deleted then
      copy[k] = deleted
    elseif type(v) == "table" then
      copy[k] = CopyDiff(v)
    else
      copy[k] = v
    end
  end
  return copy
end

local function BuildUidMap(data, children, type)
  children = children or {}
  -- The eventual result

  --- @class UidMapData
  --- @field originalName auraId The original id of the aura
  --- @field id auraId The current id of the aura, might have changed due to ids being unique
  --- @field data auraData The raw data, is non-authoritative on e.g. id, controlledChildren, parent, sortHybridTable
  --- @field controlledChildren? uid[] A array of child uids
  --- @field parent? uid The parent uid
  --- @field sortHybrid boolean? optional bool !! the parent's sortHybridTable is split up and recorded per aura:
  ---                            nil, if the parent is not a dynamic group
  ---                            false/true based on the sortHybridTable of the dynamic group
  --- @field anchorFrameFrame uid? uid of the anchor iff the aura is anchored to another aura that is part of the same
  ---                              import, otherwise nil
  --- @field matchedUid uid? for "update", the matched uid. Is from a different domain!
  --- @field diff any  for "update", the diff and the categories of that diff between the aura and its match
  --- @field categories? table the categories
  --- @field index? number helpers that transport data between phase 1 and 2
  --- @field total? number helpers that transport data between phase 1 and 2
  --- @field parentIsDynamicGroup? boolean helpers that transport data between phase 1 and 2

  --- @class UidMap
  --- @field map table<uid, UidMapData>
  --- @field type "new"|"old"
  --- @field root uid uid of the root
  --- @field totalCount number
  --- @field idToUid table<auraId, uid> maps from id to uid
  local uidMap = {
    --- @type table<uid, UidMapData>
    map = {
    },
    type = type, -- Either old or new, only used for error checking
    root = data.uid,
    totalCount = #children + 1,
    idToUid = {}
  }

  -- Build helper map from id to uid
  local idToUid = {}
  idToUid[data.id] = data.uid
  for i, child in ipairs(children) do
    if idToUid[child.id] then
      error("Duplicate id in import data: "..child.id)
    end
    idToUid[child.id] = child.uid
  end

  uidMap.idToUid = idToUid

  local function handle(data)
    -- Add names and data to map
    uidMap.map[data.uid] = {
      originalName = data.id,
      id = data.id,
      data = data
    }

    -- Add controlled children
    if data.controlledChildren then
      local uidChildren = {}
      for i, id in ipairs(data.controlledChildren) do
        tinsert(uidChildren, idToUid[id])
      end
      uidMap.map[data.uid].controlledChildren = uidChildren
    end

    -- Add parent
    if data.parent then
      uidMap.map[data.uid].parent = idToUid[data.parent]
    end

    -- Handle anchorFrameFrame
    if data.anchorFrameType == "SELECTFRAME"
     and data.anchorFrameFrame
     and data.anchorFrameFrame:sub(1, 10) == "WeakAuras:"
  then
    local target = data.anchorFrameFrame:sub(11)
    if idToUid[target] then
      uidMap.map[data.uid].anchorFrameFrame = idToUid[target]
    end
  end

  end

  local function handleSortHybridTable(data)
    if data.regionType == "dynamicgroup" then
      local sortHybridTableByUid = {}
      if data.sortHybridTable then
        for id, b in pairs(data.sortHybridTable) do
          -- The sortHybridTable might contain stale ids, since e.g. ungroup doesn't correctly
          -- remove entries
          if idToUid[id] then
            sortHybridTableByUid[idToUid[id]] = b
          end
        end
      end

      local children = uidMap.map[data.uid].controlledChildren or {}
      for _, childUid in ipairs(children) do
        local sortHybrid = sortHybridTableByUid[childUid] and true or false
        uidMap.map[childUid].sortHybrid = sortHybrid
      end
    end
  end

  handle(data)
  for i, child in ipairs(children) do
    handle(child)
  end

  handleSortHybridTable(data)
  for _, child in ipairs(children) do
    handleSortHybridTable(child)
  end


  uidMap.InsertData = function(self, data, parentUid, children, sortHybrid, index)
    self.idToUid[data.id] = data.uid
    self.totalCount = self.totalCount + 1

    -- clean up children/sortHybrid
    -- The Update code first inserts children before it inserts us
    -- But not every child might be inserted, since empty groups aren't inserted
    -- so clean that up here
    if children then
      for index, childUid in ipairs_reverse(children) do
        if not self:Contains(childUid) then
          tremove(children, index)
          if sortHybrid then
            sortHybrid[childUid] = nil
          end
        end
      end
    end

    uidMap.map[data.uid] = {
      originalName = data.id,
      id = data.id,
      data = data,
      parent = parentUid,
      matchedUid = data.uid,
      controlledChildren = children,
      sortHybrid = sortHybrid
    }

    if index then
      if uidMap.map[parentUid] and uidMap.map[parentUid].controlledChildren then
        tinsert(uidMap.map[parentUid].controlledChildren, index, data.uid)
      else
        error("Can't insert into parent")
      end
    end
  end

  uidMap.GetRootUID = function(self)
    return self.root
  end

  uidMap.GetType = function(self)
    return self.type
  end

  uidMap.Contains = function(self, uid)
    return self.map[uid] and true or false
  end

  uidMap.GetTotalCount = function(self)
    return self.totalCount
  end

  uidMap.GetRawData = function(self, uid)
    if not self.map[uid] then
      error("GetRawData for unknown uid")
      return
    end
    return self.map[uid].data
  end

  -- Cleans up id, controlledChildren, sortHybridTable, parent
  uidMap.GetPhase1Data = function(self, uid, withAppliedPath, activeCategories)
    if not self.map[uid] then
      error("GetPhase1Data for unknown uid")
      return nil
    end
    local data = CopyTable(self.map[uid].data)
    if withAppliedPath then
      if self.type == "new" then
        error("Can't apply patch on new side")
      end
      local diff = self:GetDiff(uid, activeCategories)
      if diff then
        recurseUpdate(data, diff)
      end
    end

    data.id = self.map[uid].id

    if (data.controlledChildren) then
      data.controlledChildren = {}
    end

    if (data.sortHybridTable) then
      data.sortHybridTable = {}
    end

    data.parent = nil
    return data
  end

  -- Remaps parent, controlledChildren, sortHybridTable
  uidMap.GetPhase2Data = function(self, uid, withAppliedPath, activeCategories)
    if not self.map[uid] then
      error("GetPhase2Data for unknown uid")
      return nil
    end

    local data = CopyTable(self.map[uid].data)
    if withAppliedPath then
      if self.type == "new" then
        error("Can't apply patch on new side")
      end
      local diff = self:GetDiff(uid, activeCategories)

      if diff then
        recurseUpdate(data, diff)
      end
    end
    data.id = self.map[uid].id
    if uid == self.root then
      data.parent = self.rootParent
    elseif self.map[uid].parent then
      data.parent = self:GetIdFor(self.map[uid].parent)
    else
      data.parent = nil
    end

    if self.map[uid].controlledChildren then
      data.controlledChildren = {}
      for i, childUid in ipairs(self.map[uid].controlledChildren) do
        data.controlledChildren[i] = self:GetIdFor(childUid)
      end
    else
      data.controlledChildren = nil
    end

    if self.map[uid].anchorFrameFrame then
      data.anchorFrameFrame = nil
      local anchorUid = self.map[uid].anchorFrameFrame
      local target = self:Contains(anchorUid) and self:GetIdFor(anchorUid)
      if target then
        data.anchorFrameFrame = "WeakAuras:" .. target
      end
    end

    if data.regionType == "dynamicgroup" then
      data.sortHybridTable = {}
      for i, childUid in ipairs(self.map[uid].controlledChildren) do
        data.sortHybridTable[self:GetIdFor(childUid)] = self:GetSortHybrid(childUid)
      end
    else
      data.sortHybridTable = nil
    end

    return data
  end

  uidMap.GetChildren = function(self, uid)
    return self.map[uid] and self.map[uid].controlledChildren or {}
  end

  uidMap.GetRawChildren = function(self, uid)
    return self.map[uid] and self.map[uid].controlledChildren
  end

  uidMap.GetSortHybrid = function(self, uid)
    return self.map[uid] and self.map[uid].sortHybrid
  end

  uidMap.ChangeId = function(self, uid, id)
    if not self.map[uid] then
      error("ChangeId for unknown uid")
      return
    end

    local oldId = self.map[uid].id
    if (oldId == id) then
      return
    end
    uidMap.idToUid[oldId] = nil
    uidMap.idToUid[id] = uid

    self.map[uid].id = id
  end

  uidMap.ChangeUID = function(self, uid, newUid)
    if self.root == uid then
      self.root = newUid
    end
    if not self.map[uid] or self.map[newUid] then
      error("Invalid ChangeUID")
    end

    if self.map[uid] then
      self.map[newUid] = self.map[uid]
      self.map[uid] = nil

      self.map[newUid].data.uid = newUid
      self.idToUid[self.map[newUid].id] = newUid
      if self.map[newUid].parent then
        local parentMap = self.map[self.map[newUid].parent]
        for i, childUid in ipairs(parentMap.controlledChildren) do
          if childUid == uid then
            parentMap.controlledChildren[i] = newUid
            break;
          end
        end
      end

      if self.map[newUid].controlledChildren then
        for index, childUid in ipairs(self.map[newUid].controlledChildren) do
          self.map[childUid].parent = newUid
        end
      end

    end
  end

  uidMap.GetIdFor = function(self, uid)
    if not uid or not self.map[uid] then
      error(string.format("GetIdFor for unknown uid %s", uid))
      return
    end
    return self.map[uid].id
  end

  uidMap.GetOriginalName = function(self, uid)
    if not uid or not self.map[uid] then
      error(string.format("GetOriginalName for unknown uid %s", uid))
      return
    end
    return self.map[uid].originalName
  end

  uidMap.GetGroupOrder = function(self, uid)
    if not self.map[uid] then
      error("GetGroupOrder for unknown uid")
      return
    end
    return self.map[uid].index, self.map[uid].total
  end

  uidMap.SetGroupOrder = function(self, uid, index, total)
    if not self.map[uid] then
      error("SetGroupOrder for unknown uid")
      return
    end
    self.map[uid].index = index
    self.map[uid].total = total
  end

  uidMap.GetParent = function(self, uid)
    if not self.map[uid] then
      error("GetParent for unknown uid")
      return
    end
    return self.map[uid].parent
  end

  uidMap.UnsetParent = function(self, uid)
    if not self.map[uid] then
      error("GetParent for unknown uid")
      return
    end
    self.map[uid].parent = nil
  end

  uidMap.GetParentIsDynamicGroup = function(self, uid)
    if not self.map[uid] then
      error("GetParentIsDynamicGroup for unknown uid")
      return
    end
    return self.map[uid].parentIsDynamicGroup
  end

  uidMap.SetParentIsDynamicGroup = function(self, uid, parentIsDynamicGroup)
    if not self.map[uid] then
      error("SetParentIsDynamicGroup for unknown uid")
      return
    end
    self.map[uid].parentIsDynamicGroup = parentIsDynamicGroup
  end

  uidMap.SetUIDMatch = function(self, uid, matchedUid)
    if not self.map[uid] then
      error("SetUIDMatch for unknown uid")
      return
    end
    self.map[uid].matchedUid = matchedUid
  end

  uidMap.GetUIDMatch = function(self, uid)
    if not self.map[uid] then
      error("GetUIDMatch for unknown uid")
      return
    end
    return self.map[uid].matchedUid
  end

  uidMap.SetDiff = function(self, uid, diff, categories)
    if not self.map[uid] then
      error("SetDiff for unknown uid")
      return
    end
    self.map[uid].diff = diff
    self.map[uid].categories = categories
  end

  uidMap.GetDiff = function(self, uid, categories)
    if not self.map[uid] then
      error("GetDiff for unknown uid")
      return
    end
    if not self.map[uid].diff then
      return
    end
    local diff = CopyDiff(self.map[uid].diff)
    local isRoot = not self.map[uid].parent
    for key in pairs(diff) do
      local category = FieldToCategory(key, isRoot)
      if category == nil or not categories[category] then
        diff[key] = nil
      end
    end
    return diff
  end

  uidMap.GetGroupRegionType = function(self, uid)
    if not self.map[uid] then
      error("GetGroupRegionType for unknown uid")
      return
    end
    local data = self.map[uid].data
    if data.regionType == "group" or data.regionType == "dynamicgroup" then
      return data.regionType
    end
    return nil
  end

  uidMap.EnsureUniqueIdOfUnmatched = function(self, uid, IncProgress)
    uid = uid or self.root
    if not self.map[uid] then
      error(string.format("EnsureUniqueIdOfUnmatched for unknown uid %s", uid))
      return
    end

    if self.type == "old" then
      error("Call to EnsureUniqueIdOfUnmatched for old")
    end

    if not self:GetUIDMatch(uid) then
      if OptionsPrivate.Private.GetDataByUID(uid) then
        local newUid = WeakAuras.GenerateUniqueID()
        self:ChangeUID(uid, newUid)
        uid = newUid
      end
    end
    IncProgress()
    local children = self:GetChildren(uid)
    for _, childUid in ipairs(children) do
      self:EnsureUniqueIdOfUnmatched(childUid, IncProgress)
    end
    coroutine.yield(0.1, "ensure unique uids")
  end

  uidMap.InsertUnmatchedPhase1 = function(self, otherUidMap, otherUid, IncProgress)
    local children = otherUidMap:GetChildren(otherUid)
    local lastMatchUid = nil -- our uid
    local waitingForMatch = {} -- Auras that we haven't assigned to a match yet
                               -- Will be added to before on finding a match
                               -- or the parent will be added
    local matchToInsert = {
      -- from our uid to
      --   before: array of other uids that should be inserted before the uid
      --   after: array of other uids that should be inserted after the uid
    }

    for index, childUid in ipairs(children) do
      local needsToBeInserted = self:InsertUnmatchedPhase1(otherUidMap, childUid, IncProgress)
      local matchedUid = otherUidMap:GetUIDMatch(childUid)
      if matchedUid then
        lastMatchUid = matchedUid
        matchToInsert[matchedUid] = matchToInsert[matchedUid] or {}
        matchToInsert[matchedUid].before = waitingForMatch
        waitingForMatch = {}
      else
        -- Auras => matchToInsert/waitingForMatch
        -- Groups:
        --    with Children: => matchToInsert/waitingForMatch
        --    without Children => skip groups that are empty and don't match
        local toInsert = otherUidMap:GetGroupRegionType(childUid) == nil or needsToBeInserted
        if toInsert then
          if lastMatchUid then
            matchToInsert[lastMatchUid] = matchToInsert[lastMatchUid] or {}
            matchToInsert[lastMatchUid].after = matchToInsert[lastMatchUid].after or {}
            tinsert(matchToInsert[lastMatchUid].after, childUid)
          else
            tinsert(waitingForMatch, childUid)
          end
        else
          IncProgress()
          coroutine.yield(0.1)
        end
      end
      coroutine.yield(0.1)
    end

    for uid, otherList in pairs(matchToInsert) do
      -- First find uid in parent
      local parent = self.map[uid].parent
      if parent then
        local parentChildren = self:GetChildren(parent)
        local index = tIndexOf(parentChildren, uid)

        if otherList.before then
          for _, otherUid in ipairs(otherList.before) do
            local otherData = otherUidMap:GetRawData(otherUid)
            local rawChildren = otherUidMap:GetRawChildren(otherUid)
            local sortHybrid = otherUidMap:GetSortHybrid(otherUid)
            self:InsertData(otherData, parent, rawChildren, sortHybrid, index)
            index = index + 1
            otherUidMap:SetUIDMatch(otherUid, otherUid) -- Uids are the same!
            self:SetUIDMatch(otherUid, otherUid)
            IncProgress()
            coroutine.yield(0.1)
          end
          coroutine.yield(0.1)
        end

        if otherList.after then
          index = index + 1 -- We insert after the match
          for _, otherUid in ipairs(otherList.after) do
            local otherData = otherUidMap:GetRawData(otherUid)
            local rawChildren = otherUidMap:GetRawChildren(otherUid)
            local sortHybrid = otherUidMap:GetSortHybrid(otherUid)
            self:InsertData(otherData, parent, rawChildren, sortHybrid, index)
            index = index + 1
            otherUidMap:SetUIDMatch(otherUid, otherUid) -- Uids are the same!
            self:SetUIDMatch(otherUid, otherUid)
            IncProgress()
            coroutine.yield(0.1)
          end
          coroutine.yield(0.1)
        end
      end
      coroutine.yield(0.1)
    end

    for _, otherUid in ipairs(waitingForMatch) do
      local otherData = otherUidMap:GetRawData(otherUid)
      local parent = otherUidMap:GetParent(otherUid)
      local rawChildren = otherUidMap:GetRawChildren(otherUid)
      local sortHybrid = otherUidMap:GetSortHybrid(otherUid)

      if otherUidMap:GetUIDMatch(parent) then
        -- the parent is matched, we need to insert ourselves into it
        local matchedParent = otherUidMap:GetUIDMatch(parent)
        self:InsertData(otherData, matchedParent, rawChildren, sortHybrid, #(self:GetChildren(matchedParent)) + 1)
      else
        -- the parent is unmatched, so we'll end up inserting it
        self:InsertData(otherData, parent, rawChildren, sortHybrid)
      end
      otherUidMap:SetUIDMatch(otherUid, otherUid) -- Uids are the same!
      self:SetUIDMatch(otherUid, otherUid)
      IncProgress()
      coroutine.yield(0.1)
    end

    return #waitingForMatch > 0
  end

  uidMap.InsertUnmatchedFrom = function(self, otherUidMap, IncProgress)
    self:InsertUnmatchedPhase1(otherUidMap, otherUidMap:GetRootUID(), IncProgress)
  end

  uidMap.Remove = function(self, uid)
    if not self.map[uid] then
      error("Can't remove what isn't there")
    end

    local id = self:GetIdFor(uid)
    local parent = self:GetParent(uid)
    self.map[uid] = nil
    self.idToUid[id] = nil
    self.totalCount = self.totalCount - 1
    if parent then
      if not self.map[parent] then
        error("Parent not found")
      end
      tDeleteItem(self.map[parent].controlledChildren, uid)
    end
  end

  uidMap.SetRootParent = function(self, parentId)
    self.rootParent = parentId
  end

  uidMap.Dump = function(self, uid)
    if uid == nil then
      uid = self:GetRootUID()
    end
    print(self:GetIdFor(uid))
    local children = self:GetChildren(uid)
    for i, childUid in ipairs(children) do
      uidMap:Dump(childUid)
    end
  end

  return uidMap, uidMap.root
end


local function hasChildren(data)
  return data.controlledChildren and true or false
end

local function MatchChild(uid, newUidMap, oldUidMap)
  if oldUidMap:Contains(uid) then
    newUidMap:SetUIDMatch(uid, uid)
    oldUidMap:SetUIDMatch(uid, uid)
  end

  local newChildren = newUidMap:GetChildren(uid)
  for _, childUid in ipairs(newChildren) do
    MatchChild(childUid, newUidMap, oldUidMap)
  end

end

local function BuildMatches(newUidMap, oldUidMap)
  newUidMap:SetUIDMatch(newUidMap:GetRootUID(), oldUidMap:GetRootUID())
  oldUidMap:SetUIDMatch(oldUidMap:GetRootUID(), newUidMap:GetRootUID())

  local newChildren = newUidMap:GetChildren(newUidMap:GetRootUID())
  for _, childUid in ipairs(newChildren) do
    MatchChild(childUid, newUidMap, oldUidMap)
  end
end

local function CheckForChangedRegionTypesHelper(newUidMap, oldUidMap, uid)
  local matchedUid = newUidMap:GetUIDMatch(uid)
  if matchedUid then
    if newUidMap:GetGroupRegionType(uid) ~= oldUidMap:GetGroupRegionType(matchedUid) then
      return false
    end
  end

  local newChildren = newUidMap:GetChildren(uid)
  for _, childUID in ipairs(newChildren) do
    if not CheckForChangedRegionTypesHelper(newUidMap, oldUidMap, childUID) then
      return false
    end
  end
  return true
end

local function CheckForChangedRegionTypes(newUidMap, oldUidMap)
  return CheckForChangedRegionTypesHelper(newUidMap, oldUidMap, newUidMap:GetRootUID())
end

-- This checks for this kind of matches:
-- Old:
-- Root
--  |> A
--     |-> B
-- New:
-- Root
--  |> B
--     |-> A
-- Where the structures conflict.
-- We do that with the following check per aura 'A' in new:
-- Consider the parents of A_new, root -> A_new
--   For each (recursive) child of A_old, check that none point to any parent of A_new
local function CheckForIncompatibleStructuresCheckOld(oldUid, oldUidMap, parents)
  local oldChildren = oldUidMap:GetChildren(oldUid)
  for _, oldChildUid in ipairs(oldChildren) do
    if parents[oldUidMap:GetUIDMatch(oldChildUid)] then
      return false
    end
    if not CheckForIncompatibleStructuresCheckOld(oldChildUid, oldUidMap, parents) then
      return false
    end
  end

  return true
end

local function CheckForIncompatibleStructuresHelper(uid, parents, newUidMap, oldUidMap)
  local oldUid = newUidMap:GetUIDMatch(uid)
  if not CheckForIncompatibleStructuresCheckOld(oldUid, oldUidMap, parents) then
    return false
  end

  parents[uid] = true
  local newChildren = newUidMap:GetChildren(uid)
  for _, newChildUid in ipairs(newChildren) do
    if not CheckForIncompatibleStructuresHelper(newChildUid, parents, newUidMap, oldUidMap) then
      return false
    end
  end
  parents[uid] = nil
  return true
end

local function CheckForIncompatibleStructures(newUidMap, oldUidMap)
  local parents = {}
  return CheckForIncompatibleStructuresHelper(newUidMap:GetRootUID(), parents, newUidMap, oldUidMap)
end

local function SetCategories(globalCategories, categories)
  for key, b in pairs(categories) do
    if b then
      globalCategories[key] = true
    end
  end
end

local function OnlyMetaDataCategory(categories)
  local metaData = false
  for category in pairs(categories) do
    if category == "metadata" then
      metaData = true
    else
      return false
    end
  end
  return metaData
end

local function GetCategories(diff, isRoot)
  local categories = {}
  for key in pairs(diff) do
    local category = FieldToCategory(key, isRoot)
    if category then
      categories[category] = true
    end
  end

  return categories
end

local function BuildDiffsHelper(uid, newUidMap, oldUidMap, matchInfo)
  local matchedUid = newUidMap:GetUIDMatch(uid)
  local isGroup = newUidMap:GetGroupRegionType(uid)
  if matchedUid then
    local newParent = newUidMap:GetParent(uid)
    local oldParent = oldUidMap:GetParent(matchedUid)

    local differentParents = false
    if newParent == nil and oldParent == nil then
      -- Same
    elseif newParent == nil or oldParent == nil then
      -- Can't really happen
      differentParents = true
    else
      if newUidMap:GetUIDMatch(newParent) ~= oldParent then
        differentParents = true
      end
    end

    if differentParents then
      matchInfo.activeCategories.arrangement = true
    end

    if newUidMap:GetSortHybrid(uid) ~= oldUidMap:GetSortHybrid(matchedUid) then
      matchInfo.activeCategories.arrangement = true
    end

    -- We can use the raw data, because the diff algorithm ignores all the members that
    -- aren't directly comparable
    local oldRawData = oldUidMap:GetRawData(matchedUid)
    local newRawData = newUidMap:GetRawData(uid)
    local diff = Diff(oldRawData, newRawData)
    if diff then
      local categories = GetCategories(diff, uid == newUidMap:GetRootUID())
      newUidMap:SetDiff(uid, diff, categories)
      oldUidMap:SetDiff(matchedUid, diff, categories)
      SetCategories(matchInfo.activeCategories, categories)

      matchInfo.categories[uid] = categories

      if OnlyMetaDataCategory(categories) then
        matchInfo.onlyMetaDataModified[uid] = true
        if isGroup then
          matchInfo.modifiedMetaDataGroupCount = matchInfo.modifiedMetaDataGroupCount + 1
        else
          matchInfo.modifiedMetaDataCount = matchInfo.modifiedMetaDataCount + 1
        end
      else
        matchInfo.modified[uid] = true
        if isGroup then
          matchInfo.modifiedGroupCount = matchInfo.modifiedGroupCount + 1
        else
          matchInfo.modifiedCount = matchInfo.modifiedCount + 1
        end
      end
    else
      matchInfo.unmodified[uid] = true
      if isGroup then
        matchInfo.unmodifiedGroupCount = matchInfo.unmodifiedGroupCount + 1
      else
        matchInfo.unmodifiedCount = matchInfo.unmodifiedCount + 1
      end
    end
  else
    if isGroup then
      matchInfo.addedGroupCount = matchInfo.addedGroupCount + 1
      matchInfo.activeCategories.arrangement = true
    else
      matchInfo.added[uid] = true
      matchInfo.addedCount = matchInfo.addedCount + 1
      matchInfo.activeCategories.newchildren = true
    end
  end

  local newChildren = newUidMap:GetChildren(uid)
  for _, newChildUid in ipairs(newChildren) do
    BuildDiffsHelper(newChildUid, newUidMap, oldUidMap, matchInfo)
  end

  return matchInfo
end

local function BuildDiffsRemoved(oldUID, newUidMap, oldUidMap, matchInfo)
  local uid = oldUidMap:GetUIDMatch(oldUID)
  local isGroup = oldUidMap:GetGroupRegionType(oldUID)
  if not uid then
    if isGroup then
      matchInfo.deletedGroupCount = matchInfo.deletedGroupCount + 1
      matchInfo.activeCategories.arrangement = true
    else
      matchInfo.deleted[oldUID] = true
      matchInfo.deletedCount = matchInfo.deletedCount + 1
      matchInfo.activeCategories.oldchildren = true
    end
  end

  local oldChildren = oldUidMap:GetChildren(oldUID)
  for _, oldChildUid in ipairs(oldChildren) do
    BuildDiffsRemoved(oldChildUid, newUidMap, oldUidMap, matchInfo)
  end
end

-- This function compares the order of children in a given parent
-- It detects e.g.
-- Group         Group
--  A        =>   B
--- B             A
local function CompareControlledChildrenOrder(oldUID, newUidMap, oldUidMap, matchInfo)
  local newUid = oldUidMap:GetUIDMatch(oldUID)
  if newUid then
    -- We first iterate over the old order, and remember the index for all matches
    local oldOrder = {
      -- maps childUids of newUid to the index the corresponding aura has in oldUid
    }
    local oldChildren = oldUidMap:GetChildren(oldUID)
    for index, oldChildUid in ipairs(oldChildren) do
      local newChildUid = oldUidMap:GetUIDMatch(oldChildUid)
      if newChildUid then
        oldOrder[newChildUid] = index
      end
    end

    -- We now iterate the new order, and expect the indexes to monotonically increase
    local highestIndex = -1
    local newChildren = newUidMap:GetChildren(newUid)
    for index, newChildUid in ipairs(newChildren) do
      local oldIndex = oldOrder[newChildUid]
      if oldIndex then
        if oldIndex < highestIndex then
          matchInfo.activeCategories.arrangement = true
          return -- Don't need to check more
        else
          highestIndex = oldIndex
        end
      end
    end
  end

  local oldChildren = oldUidMap:GetChildren(oldUID)
  for _, oldChildUid in ipairs(oldChildren) do
    CompareControlledChildrenOrder(oldChildUid, newUidMap, oldUidMap, matchInfo)
  end
end

local function hasChanges(matchInfo)
  return matchInfo.modifiedCount > 0
         or matchInfo.modifiedGroupCount > 0
         or matchInfo.modifiedMetaDataCount > 0
         or matchInfo.modifiedMetaDataGroupCount > 0
         or matchInfo.addedCount > 0
         or matchInfo.addedGroupCount > 0
         or matchInfo.deletedCount > 0
         or matchInfo.deletedGroupCount > 0
         or matchInfo.activeCategories.arrangement
end

local function BuildDiffs(newUidMap, oldUidMap)
  local matchInfo = {
    modifiedCount = 0,
    modifiedGroupCount = 0,
    modifiedMetaDataCount = 0,
    modifiedMetaDataGroupCount = 0,
    unmodifiedCount = 0,
    unmodifiedGroupCount = 0,
    addedCount = 0,
    addedGroupCount = 0,
    deletedCount = 0,
    deletedGroupCount = 0,
    modified = {}, -- Contains uids that were modified
    onlyMetaDataModified = {}, -- Contains uids that are only metadata modified
    categories = {}, -- Contains categories for uids
    unmodified = {}, -- Contains new uids that had a empty diff
    added = {}, -- Contains new uids that were added
    deleted = {}, -- Contains old uids that were removed
    activeCategories = {} -- maps from name of Private.update_categories to true/nil
  }
  -- Handles addition + modification
  BuildDiffsHelper(newUidMap:GetRootUID(), newUidMap, oldUidMap, matchInfo)
  -- Handles removals
  BuildDiffsRemoved(oldUidMap:GetRootUID(), newUidMap, oldUidMap, matchInfo)
  if not matchInfo.activeCategories.arrangement then
    CompareControlledChildrenOrder(oldUidMap:GetRootUID(), newUidMap, oldUidMap, matchInfo)
  end

  return matchInfo
end

local function MatchInfo(data, children, target)
  -- Check that the import has uids, otherwise we won't even try to match
  if not data.uid then
    return nil, L["Import has no UID, cannot be matched to existing auras."]
  end
  if children then
    for _, child in ipairs(children) do
      if not child.uid then
        return nil, L["Import has no UID, cannot be matched to existing auras."]
      end
    end
  end

  if target then
    if hasChildren(data) ~= hasChildren(target) then
      return nil, L["Invalid target aura"]
    end
  else
    target = OptionsPrivate.Private.GetDataByUID(data.uid)
    if target and hasChildren(data) ~= hasChildren(target) then
      target = nil
    end
  end
  if not target then
    return nil -- No error
  end

  -- Build a uid map for the target auras
  local oldChildren = {}
  for child in OptionsPrivate.Private.TraverseAllChildren(target) do
    tinsert(oldChildren, child)
  end

  local newUidMap = BuildUidMap(data, children, "new")
  local oldUidMap = BuildUidMap(target, oldChildren, "old")
  oldUidMap:SetRootParent(target.parent)
  newUidMap:SetRootParent(target.parent)

  BuildMatches(newUidMap, oldUidMap)
  if not CheckForChangedRegionTypes(newUidMap, oldUidMap) then
    return nil, L["Incompatible changes to group region types detected"]
  end

  if not CheckForIncompatibleStructures(newUidMap, oldUidMap) then
    return nil, L["Incompatible changes to group structure detected"]
  end

  local matchInfo = BuildDiffs(newUidMap, oldUidMap)
  matchInfo.newUidMap = newUidMap
  matchInfo.oldUidMap = oldUidMap

  return matchInfo
end

local function CategoriesToDisplayText(categories)
  local categoriesDisplayTexts = {}
  for _, category in ipairs(OptionsPrivate.Private.update_categories) do
    if categories[category.name] then
      tinsert(categoriesDisplayTexts, category.label)
    end
  end
  if #categoriesDisplayTexts > 0 then
    return table.concat(categoriesDisplayTexts, ", ")
  else
    return nil
  end
end

local function AddAuraList(container, uidMap, list, categories, expandText)
  local expand = AceGUI:Create("WeakAurasExpand")
  local collapsed = true
  local image = collapsed and "Interface\\AddOns\\WeakAuras\\Media\\Textures\\expand"
                           or "Interface\\AddOns\\WeakAuras\\Media\\Textures\\collapse"
  expand:SetImage(image)
  expand:SetImageSize(10, 10)
  expand:SetFontObject(GameFontHighlight)
  expand:SetFullWidth(true)
  expand:SetLabel(expandText)
  container:AddChild(expand)

  local auraLabelContainer = AceGUI:Create("WeakAurasInlineGroup")
  auraLabelContainer:SetFullWidth(true)
  auraLabelContainer:DoLayout()
  container:AddChild(auraLabelContainer)

  local sortedNames = {}
  for uid in pairs(list) do
    if categories[uid] then
      local categoriesText = CategoriesToDisplayText(categories[uid])
      if categoriesText then
        tinsert(sortedNames, L["%s (%s)"]:format(uidMap:GetIdFor(uid), categoriesText))
      else
        tinsert(sortedNames, uidMap:GetIdFor(uid))
      end
    else
      tinsert(sortedNames, uidMap:GetIdFor(uid))
    end
  end
  table.sort(sortedNames)

  expand:SetCallback("OnClick", function()
    collapsed = not collapsed
    local image = collapsed and "Interface\\AddOns\\WeakAuras\\Media\\Textures\\expand"
                           or "Interface\\AddOns\\WeakAuras\\Media\\Textures\\collapse"
    expand:SetImage(image)

    if collapsed then
      auraLabelContainer:ReleaseChildren()
    else
      local text
      for _, name in ipairs(sortedNames) do
        text = (text or "") .. "    " .. name .. "\n"
      end
      if text then
        local auraLabel = AceGUI:Create("Label")
        auraLabel:SetText(text)
        auraLabel:SetFullWidth(true)
        auraLabelContainer:AddChild(auraLabel)
      end
    end
    auraLabelContainer:DoLayout()
    container:DoLayout()
  end)
end

local methods = {
  Open = function(self, data, children, target, linkedAuras, sender, callbackFunc)
    local optionsWindow =  self.optionsWindow
    local optionsWindowTitle = self.optionsWindow.window
    if(optionsWindowTitle == "importexport") then
      local importexport = OptionsPrivate.ImportExport(optionsWindow, true)
      if importexport then
        importexport:Close();
      end
    elseif(optionsWindowTitle == "texture") then
      local texturepicker = OptionsPrivate.TexturePicker(optionsWindow, true)
      if texturepicker then
        texturepicker:CancelClose();
      end
    elseif(optionsWindowTitle == "icon") then
      local iconpicker = OptionsPrivate.IconPicker(optionsWindow, true)
      if iconpicker then
        iconpicker:CancelClose();
      end
    elseif(optionsWindowTitle == "model") then
      local modelpicker = OptionsPrivate.ModelPicker(optionsWindow, true)
      if modelpicker then
        modelpicker:CancelClose();
      end
    end
    self.optionsWindow.window = "update"
    self.optionsWindow:UpdateFrameVisible()

    self.pendingData = {
      data = data,
      children = children or {},
      target = target,
      linkedAuras = linkedAuras,
      sender = sender
    }
    self.userChoices = {

    }
    self.callbackFunc = callbackFunc

    self:ReleaseChildren()
    self:AddBasicInformationWidgets(data, sender)

    do
      local highestVersion = data.internalVersion or 0
      if children then
        for _, child in ipairs(children) do
          highestVersion = max(highestVersion, child.internalVersion or 0)
        end
      end

      if (highestVersion > WeakAuras.InternalVersion()) then
        local highestVersionWarning = AceGUI:Create("Label")
        highestVersionWarning:SetFontObject(GameFontHighlight)
        highestVersionWarning:SetFullWidth(true)
        highestVersionWarning:SetText(L["This aura was created with a newer version of WeakAuras.\nUpgrade your version of WeakAuras or wait for next release before installing this aura."])
        highestVersionWarning:SetColor(1, 0, 0)
        self:AddChild(highestVersionWarning)
        self.importButton:Hide()
        self.viewCodeButton:Hide()
        self:DoLayout()
        return
      else
        self.importButton:Show()
      end
    end

    local matchInfoResult = AceGUI:Create("Label")
    matchInfoResult:SetFontObject(GameFontHighlight)
    matchInfoResult:SetFullWidth(true)
    self:AddChild(matchInfoResult)

    local matchInfo, errorMessage = MatchInfo(data, children, target)
    self.matchInfo = matchInfo

    -- Cases:
    -- No match => Import
    -- Match, but no difference => Import as Copy
    -- Match with difference  => Import as Copy / Update, preference depends on preferToUpdate
    if matchInfo ~= nil then
      if not hasChanges(matchInfo) then
        -- there is no difference whatsoever
        self.userChoices.mode = "import"
        matchInfoResult:SetText(L["You already have this group/aura. Importing will create a duplicate."])
        self.importButton:SetText(L["Import as Copy"])
      else
        local oldRootId = matchInfo.oldUidMap:GetIdFor(matchInfo.oldUidMap:GetRootUID())
        local preferToUpdate = matchInfo.oldUidMap:GetRawData(matchInfo.oldUidMap:GetRootUID()).preferToUpdate
        if (data.regionType == "group" or data.regionType == "dynamicgroup") then
          local matchInfoText = L["This is a modified version of your group: |cff9900FF%s|r"]:format(oldRootId)
          matchInfoResult:SetText(matchInfoText)
          if matchInfo.addedCount ~= 0 then
            AddAuraList(self, matchInfo.newUidMap, matchInfo.added, {},
                        L["%d |4aura:auras; added"]:format(matchInfo.addedCount))
          end
          local modifiedCount = matchInfo.modifiedCount + matchInfo.modifiedGroupCount
          if modifiedCount ~= 0  then
            AddAuraList(self, matchInfo.oldUidMap, matchInfo.modified, matchInfo.categories,
                        L["%d |4aura:auras; modified"]:format(modifiedCount))
          end
          local onlyMetaDataModifiedCount = matchInfo.modifiedMetaDataCount + matchInfo.modifiedMetaDataGroupCount
          if onlyMetaDataModifiedCount ~= 0 then
            AddAuraList(self, matchInfo.oldUidMap, matchInfo.onlyMetaDataModified, {},
                        L["%d |4aura:auras; with meta data modified"]:format(onlyMetaDataModifiedCount))
          end
          if matchInfo.deletedCount ~= 0 then
            AddAuraList(self, matchInfo.oldUidMap, matchInfo.deleted, {},
                        L["%d |4aura:auras; deleted"]:format(matchInfo.deletedCount))
          end
        else
          matchInfoResult:SetText(L["This is a modified version of your aura, |cff9900FF%s.|r"]:format(oldRootId))
        end

        self:AddChild(AceGUI:Create("WeakAurasSpacer"))
        local choicesHeader = AceGUI:Create("Label")
        choicesHeader:SetText(L["What do you want to do?"])
        choicesHeader:SetFontObject(GameFontNormalHuge)
        choicesHeader:SetFullWidth(true)
        self:AddChild(choicesHeader)

        local importCopyRadioButton = AceGUI:Create("CheckBox")
        importCopyRadioButton:SetLabel(L["Create a Copy"])
        importCopyRadioButton:SetType("radio")
        importCopyRadioButton:SetFullWidth(true)
        self.importCopyRadioButton = importCopyRadioButton
        self:AddChild(importCopyRadioButton)

        local updateRadioButton = AceGUI:Create("CheckBox")
        updateRadioButton:SetLabel(L["Update Auras"])
        updateRadioButton:SetType("radio")
        updateRadioButton:SetFullWidth(true)
        self.updateRadioButton = updateRadioButton
        self:AddChild(updateRadioButton)

        local updateUiArea = AceGUI:Create("WeakAurasInlineGroup")
        updateUiArea:SetFullWidth(true)
        updateUiArea:SetFullHeight(true)
        self.updateUiArea = updateUiArea
        self:AddChild(updateUiArea)

        importCopyRadioButton:SetCallback("OnValueChanged", function(_, _, v)
          self:SelectMode(v and "import" or "update")
          self:DoLayout()
        end)

        updateRadioButton:SetCallback("OnValueChanged", function(_, _, v)
          self:SelectMode(v and "update" or "import")
          self:DoLayout()
        end)

        self:SelectMode(preferToUpdate and "update" or "import")
      end
    else
      self.userChoices.mode = "import"
      local matchInfoText = ""
      if (errorMessage) then
        matchInfoText = matchInfoText .. "|cFFFF0000" .. errorMessage .. "|r\n"
      end

      -- No match, so plain import
      if data.controlledChildren then
        matchInfoText = matchInfoText .. L["Importing a group with %s child auras."]:format(#children)
      else
        matchInfoText = matchInfoText .. L["Importing a stand-alone aura."]
      end

      matchInfoResult:SetText(matchInfoText)
      self.importButton:SetText(L["Import"])
    end

    local scamCheckResult = {}
    scamCheck(scamCheckResult, data)
    if children then
      for _, child in ipairs(children) do
        scamCheck(scamCheckResult, child)
      end
    end
    self.scamCheckResult = scamCheckResult

    if (#scamCheckResult > 0) then
      self:AddChild(AceGUI:Create("WeakAurasSpacer"))

      local scamCheckText = AceGUI:Create("Label")
      scamCheckText:SetFontObject(GameFontHighlight)
      scamCheckText:SetFullWidth(true)
      scamCheckText:SetText(L["This aura contains custom Lua code.\nMake sure you can trust the person who sent it!"])
      scamCheckText:SetColor(1, 0, 0)
      self:AddChild(scamCheckText)
    end

    if linkedAuras and next(linkedAuras) then
      self:AddChild(AceGUI:Create("WeakAurasSpacer"))

      local linkedAurasText = AceGUI:Create("Label")
      linkedAurasText:SetFontObject(GameFontHighlight)
      linkedAurasText:SetFullWidth(true)

      local auraIdText = table.concat(self.pendingData.linkedAuras, ", ")
      if #self.pendingData.linkedAuras == 1 then
        linkedAurasText:SetText(L["This aura is marked as an update to an aura '%s', but cannot be used to update that aura. This usually happens if an aura is moved out of a group."]:format(auraIdText))
      else
        linkedAurasText:SetText(L["This aura is marked as an update to auras '%s', but cannot be used to update them. This usually happens if an aura is moved out of a group."]:format(auraIdText))
      end
      linkedAurasText:SetColor(1, 0, 0)
      self:AddChild(linkedAurasText)
    end

    local currentBuild = floor(WeakAuras.BuildInfo / 10000)
    local importBuild = data.tocversion and floor(data.tocversion / 10000)

    if importBuild and currentBuild ~= importBuild then
      local flavorWarning = AceGUI:Create("Label")
      flavorWarning:SetFontObject(GameFontHighlight)
      flavorWarning:SetFullWidth(true)
      flavorWarning:SetText(L["This aura was created with a different version (%s) of World of Warcraft.\nIt might not work correctly!"]:format(OptionsPrivate.Private.TocToExpansion[importBuild] or L["Unknown"]))
      flavorWarning:SetColor(1, 0, 0)
      self:AddChild(flavorWarning)
    end

    if (#scamCheckResult > 0) then
      self.viewCodeButton:Show()
    else
      self.viewCodeButton:Hide()
    end

    self:DoLayout()
  end,
  CreateUpdateArea = function(self, area, matchInfo)
    area:AddChild(AceGUI:Create("WeakAurasSpacer"))
    local categoryHeader = AceGUI:Create("Label")
    categoryHeader:SetText(L["Categories to Update"])
    categoryHeader:SetFontObject(GameFontNormalHuge)
    categoryHeader:SetFullWidth(true)
    area:AddChild(categoryHeader)

    self.userChoices.activeCategories = {}
    for index, category in pairs(OptionsPrivate.Private.update_categories) do
      local name = category.name
      if matchInfo.activeCategories[name] then
        local button = AceGUI:Create("CheckBox")
        button:SetLabel(category.label)
        button:SetFullWidth(true)
        button:SetValue(category.default)
        area:AddChild(button)

        self.userChoices.activeCategories[name] = category.default

        button:SetCallback("OnValueChanged", function(_, _, value)
          self.userChoices.activeCategories[name] = value
        end)

      end
    end

    area:DoLayout()
  end,
  SelectMode = function(self, mode)
    if self.userChoices.mode == mode then
      return
    end
    self.userChoices.mode = mode
    if mode == "update" then
      self.importButton:SetText(L["Update"])
      self.updateRadioButton:SetValue(true)
      self.importCopyRadioButton:SetValue(false)
      self:CreateUpdateArea(self.updateUiArea, self.matchInfo)
    elseif mode == "import" then
      self.importButton:SetText(L["Import as Copy"])
      self.updateRadioButton:SetValue(false)
      self.importCopyRadioButton:SetValue(true)
      self.updateUiArea:ReleaseChildren()
    end
  end,
  Import = function(self)
    if WeakAuras.IsClassicEra() and C_GameRules.IsHardcoreActive() then
      StaticPopupDialogs["WEAKAURAS_CONFIRM_IMPORT_HARDCORE"] = {
        text = L["You are about to Import an Aura with custom Lua code on a Hardcore server.\n\n|cFFFF0000There is a risk the custom code could be used to kill your hardcore character!|r\n\nWould you like to continue?"],
        button1 = L["Import"],
        button2 = L["Cancel"],
        OnShow = function(self)
          self.text:SetFontObject(GameFontNormalLarge)
        end,
        OnHide = function(self)
          self.text:SetFontObject(GameFontNormal)
        end,
        OnAccept = function()
          OptionsPrivate.Private.Threads:Add("import", coroutine.create(function()
            self:ImportImpl()
          end))
        end,
      }
      StaticPopup_Show("WEAKAURAS_CONFIRM_IMPORT_HARDCORE")
      return
    end
    OptionsPrivate.Private.Threads:Add("import", coroutine.create(function()
      self:ImportImpl()
    end))
  end,
  ImportImpl = function(self)
    local pendingData = self.pendingData
    local userChoices = self.userChoices
    local matchInfo = self.matchInfo

    self.importButton:SetEnabled(false)
    self.closeButton:SetEnabled(false)
    self.viewCodeButton:SetEnabled(false)
    OptionsPrivate.Private.SetImporting(true)
    coroutine.yield(10, "init")
    -- Adjust UI
    self:ReleaseChildren()
    self:AddBasicInformationWidgets(pendingData.data, pendingData.sender)
    self:AddProgressWidgets()

    ---@type {uid: uid, data: auraData, source: string}[]
    local copies = {}
    local pendingPickData

    if userChoices.mode == "import" then
      coroutine.yield(0.1, "start import")
      self:InitializeProgress(2 * (#pendingData.children + 1))

      EnsureUniqueUid(pendingData.data)
      coroutine.yield(0.1, "ensure unique uids")
      for i, child in ipairs(pendingData.children) do
        EnsureUniqueUid(child)
        coroutine.yield(0.1, "ensure unique uids")
      end

      coroutine.yield(1, "build uid map")
      local uidMap = BuildUidMap(pendingData.data, pendingData.children, "new")

      local phase2Order = {}
      coroutine.yield(1, "start phase 1")
      self:ImportPhase1(uidMap, uidMap:GetRootUID(), phase2Order)
      coroutine.yield(1, "start phase 2")
      self:ImportPhase2(uidMap, phase2Order, copies)

      pendingPickData = {
        id = uidMap:GetIdFor(uidMap:GetRootUID())
      }
      if #pendingData.children > 0 then
        pendingPickData.tabToShow = "group"
      end
      coroutine.yield(1, "update ui")
      OptionsPrivate.SortDisplayButtons()
    elseif userChoices.mode == "update" then
      coroutine.yield(0.1, "start update")
      local onePhaseProgress = matchInfo.oldUidMap:GetTotalCount() + matchInfo.newUidMap:GetTotalCount()
      local IncProgress = function() self:IncProgress() end

      -- The progress is more for appearances than anything resembling real calculation
      -- The estimate for the total work is wonky, as is how the code compensates for that
      -- But then again, lying progress bar is a industry standard pratice
      self:InitializeProgress(onePhaseProgress * 26)
      -- The uids of unmatched auras, might already be in use already, assign unique uids then
      -- This can happen if e.g. the user imports a group with a aura "A", but moves the aura out of the group
      -- On update, we won't match A_new to A_old, because A_old is outside the matched parent group
      -- Thus on import A_new needs to get its own uid
      -- On next import, the auras uids won't match either, there's not much we can do about that.
      coroutine.yield(0.1, "ensure unique uids")
      matchInfo.newUidMap:EnsureUniqueIdOfUnmatched(nil, IncProgress)
      self:SetMinimumProgress(1 * onePhaseProgress)

      local removeOldGroups = matchInfo.activeCategories.arrangement and userChoices.activeCategories.arrangement
      if userChoices.activeCategories.oldchildren or removeOldGroups then
        self:RemoveUnmatchedOld(matchInfo.oldUidMap, matchInfo.oldUidMap:GetRootUID(), matchInfo.newUidMap,
                                userChoices.activeCategories.oldchildren,
                                removeOldGroups)
      end

      self:SetMinimumProgress(2 * onePhaseProgress)

      local removeNewGroups = matchInfo.activeCategories.arrangement and not userChoices.activeCategories.arrangement
      if not userChoices.activeCategories.newchildren or removeNewGroups then
        self:RemoveUnmatchedNew(matchInfo.newUidMap, matchInfo.newUidMap:GetRootUID(), matchInfo.oldUidMap,
                                not userChoices.activeCategories.newchildren,
                                removeNewGroups)
      end
      self:SetMinimumProgress(3 * onePhaseProgress)

      local targetNames = {}

      local structureUidMap -- We iterate either over new or old, depending on the mode
      local GetPhase1Data   -- Getting the right data is a bit tricky, and depends on the mode
      local GetPhase2Data
      if userChoices.activeCategories.arrangement then
        -- new arrangement
        structureUidMap = matchInfo.newUidMap
        if not userChoices.activeCategories.oldchildren then
          -- Keep old children
          matchInfo.newUidMap:InsertUnmatchedFrom(matchInfo.oldUidMap, IncProgress)
          coroutine.yield(0.1, "keep old children done")
        end

        self:SetMinimumProgress(4 * onePhaseProgress)

        -- This ensures that we use unique (for new uids) or the same id (for existing uids) for the initial add
        -- There's another renaming after everything has been added
        self:FixUpNames(matchInfo.newUidMap)
        self:SetMinimumProgress(5 * onePhaseProgress)

        local useOldNames = not userChoices.activeCategories.name
        self:GatherTargetNames(matchInfo.newUidMap, matchInfo.oldUidMap, useOldNames, targetNames)
        self:SetMinimumProgress(6 * onePhaseProgress)

        GetPhase1Data = function(uid)
          local matchedUid = matchInfo.newUidMap:GetUIDMatch(uid)
          if matchedUid then
            local data = matchInfo.oldUidMap:GetPhase1Data(matchedUid, true, userChoices.activeCategories)
            data.uid = uid
            data.id = matchInfo.newUidMap:GetIdFor(uid)
            return data
          else
            return matchInfo.newUidMap:GetPhase1Data(uid)
          end
        end
        GetPhase2Data = function(uid)
          local matchedUid = matchInfo.newUidMap:GetUIDMatch(uid)
          if matchedUid then
            -- We want a combination of the old data updated via the diff and
            -- the new structure.
            local oldData = matchInfo.oldUidMap:GetPhase2Data(matchedUid, true, userChoices.activeCategories)
            local newData = matchInfo.newUidMap:GetPhase2Data(uid)
            oldData.controlledChildren = newData.controlledChildren
            oldData.parent = newData.parent
            oldData.sortHybridTable = newData.sortHybridTable
            oldData.uid = uid
            oldData.id = matchInfo.newUidMap:GetIdFor(uid)
            oldData.anchorFrameFrame = newData.anchorFrameFrame
            return oldData
          else
            return matchInfo.newUidMap:GetPhase2Data(uid)
          end
        end
      else
        -- old arrangement
        structureUidMap = matchInfo.oldUidMap
        if userChoices.activeCategories.newchildren then
          -- Add new children
          matchInfo.oldUidMap:InsertUnmatchedFrom(matchInfo.newUidMap, IncProgress)
        end
        self:SetMinimumProgress(4 * onePhaseProgress)

        self:FixUpNames(matchInfo.oldUidMap)
        self:SetMinimumProgress(5 * onePhaseProgress)

        local useNewNames = userChoices.activeCategories.name
        self:GatherTargetNames(matchInfo.oldUidMap, matchInfo.newUidMap, useNewNames, targetNames)
        self:SetMinimumProgress(6 * onePhaseProgress)

        GetPhase1Data  = function(uid)
          return matchInfo.oldUidMap:GetPhase1Data(uid, true, userChoices.activeCategories)
        end
        GetPhase2Data = function(uid)
          return matchInfo.oldUidMap:GetPhase2Data(uid, true, userChoices.activeCategories)
        end
      end

      coroutine.yield(10, "prep done")
      local phase2Order = {}
      self:UpdatePhase1(structureUidMap, structureUidMap:GetRootUID(), GetPhase1Data, phase2Order)
      self:SetMinimumProgress(16 * onePhaseProgress)
      coroutine.yield(10, " phase 1 done")
      self:UpdatePhase2(structureUidMap, GetPhase2Data, phase2Order, copies)

      self:SetMinimumProgress(26 * onePhaseProgress)
      coroutine.yield(10, " phase 2 done")

      local renameTries = 0
      while(self:RenameAuras(targetNames)) do
        -- Try renaming again and again...
        renameTries = renameTries + 1
        if renameTries % 10 == 0 then
          coroutine.yield(0.1, "renaming auras")
        end
      end
      self:SetMaxProgress()
      coroutine.yield(0.1, "renaming auras done")

      pendingPickData = {
        id = OptionsPrivate.Private.GetDataByUID(matchInfo.oldUidMap:GetRootUID()).id
      }
      if matchInfo.oldUidMap:GetGroupRegionType(matchInfo.oldUidMap:GetRootUID()) then
        pendingPickData.tabToShow = "group"
      end

      OptionsPrivate.SortDisplayButtons()
    end
    coroutine.yield(0.1, "winding down")
    OptionsPrivate.Private.SetImporting(false)
    self.viewCodeButton:SetEnabled(true)
    self.importButton:SetEnabled(true)
    self.closeButton:SetEnabled(true)
    OptionsPrivate.Private.callbacks:Fire("Import")

    self:Close(true, pendingPickData.id)

    if pendingPickData then
      OptionsPrivate.ClearPicks()
      WeakAuras.PickDisplay(pendingPickData.id, pendingPickData.tabToShow)
    end
    OptionsPrivate.Private.Threads:Add("history_update", coroutine.create(function()
      for _, copy in ipairs(copies) do
        OptionsPrivate.Private.SetHistory(copy.uid, copy.data, copy.source)
        coroutine.yield()
      end
    end), "background")
  end,
  -- This ensures that the id that we are adding is either
  --  same for existing uids
  --  or unique for non-existing uids
  -- Note: There's a final renaming via WeakAuras.Rename at the end of the update process
  FixUpNames = function(self, uidMap, uid)
    uid = uid or uidMap:GetRootUID()
    local existingData = OptionsPrivate.Private.GetDataByUID(uid)
    if existingData then
      if uidMap:GetIdFor(uid) ~= existingData.id then
      end
      uidMap:ChangeId(uid, existingData.id)
    else
      if WeakAuras.GetData(uidMap:GetIdFor(uid)) then
        local newId = OptionsPrivate.Private.FindUnusedId(uidMap:GetIdFor(uid))
        uidMap:ChangeId(uid, newId)
      end
    end
    self:IncProgress()
    coroutine.yield()
    local children = uidMap:GetChildren(uid)
    for _, childUid in ipairs(children) do
      self:FixUpNames(uidMap, childUid)
    end
  end,
  GatherTargetNames = function(self, structureUidMap, otherUidMap, useOtherUidMapNames, targetNames, uid)
    uid = uid or structureUidMap:GetRootUID()

    if useOtherUidMapNames then
      local matchedUid = structureUidMap:GetUIDMatch(uid)
      if matchedUid then
        targetNames[uid] = otherUidMap:GetOriginalName(matchedUid)
      else
        targetNames[uid] = structureUidMap:GetOriginalName(uid)
      end
    else
      targetNames[uid] = structureUidMap:GetOriginalName(uid)
    end

    self:IncProgress()
    coroutine.yield()
    local children = structureUidMap:GetChildren(uid)
    for _, childUid in ipairs(children) do
      self:GatherTargetNames(structureUidMap, otherUidMap, useOtherUidMapNames, targetNames, childUid)
    end
  end,
  RenameAuras = function(self, targetNames)
    local changed = false
    for uid, targetName in pairs(targetNames) do
      local aura = WeakAuras.GetData(targetName)
      if not aura then
        -- No squatter, so just take the name
        local data = OptionsPrivate.Private.GetDataByUID(uid)
        WeakAuras.Rename(data, targetName)
        targetNames[uid] = nil
        changed = true
        self:IncProgress()
        coroutine.yield()
      elseif aura.uid == uid then
        -- Already the correct name
        targetNames[uid] = nil
      else
        -- Somebody else is squatting the name, rename us with a suffix,
        -- so maybe a different aura can take our name

        local data = OptionsPrivate.Private.GetDataByUID(uid)
        if string.sub(data.id, 1, #targetName) == targetName then
          -- Our name is already prefixed with targetName, don't try to improve
        else
          local newId = OptionsPrivate.Private.FindUnusedId(targetName)
          local oldid = data.id
          WeakAuras.Rename(data, newId)
          if targetName[aura.uid] then -- We can hope that the aura the squatter renames itself, so try again
            changed = true
          end
          self:IncProgress()
          coroutine.yield()
        end
      end
    end
    coroutine.yield()
    return changed
  end,
  RemoveUnmatchedOld = function(self, uidMap, uid, otherMap, removeAuras, removeGroups)
    if uidMap:GetType() ~= "old" then
      error("Wrong map for delete")
    end

    local children = uidMap:GetChildren(uid)
    local removedAllChildren = true
    for index, childUid in ipairs_reverse(children) do
      local removed = self:RemoveUnmatchedOld(uidMap, childUid, otherMap, removeAuras, removeGroups)
      if not removed and not uidMap:GetUIDMatch(childUid) then
        removedAllChildren = false
      end
    end

    local matchedUid = uidMap:GetUIDMatch(uid)
    if not matchedUid and removedAllChildren then
      if uidMap:GetRootUID() == uid then
        error("Can't remove root")
      end

      if (uidMap:GetGroupRegionType(uid) and removeGroups)
          or (uidMap:GetGroupRegionType(uid) == nil and removeAuras)
        then

        for index, childUid in ipairs_reverse(children) do
          uidMap:UnsetParent(childUid)
        end

        local data = OptionsPrivate.Private.GetDataByUID(uid)
        if not data then
          error("Can't find data")
        end
        WeakAuras.Delete(data)
        uidMap:Remove(uid)
        self:IncProgress()
        coroutine.yield()
        return true
      end
    end
    self:IncProgress()
    coroutine.yield(0.1, "remove unmatched old")
    return false
  end,
  RemoveUnmatchedNew = function(self, uidMap, uid, otherMap, removeAuras, removeGroups)
    if uidMap:GetType() ~= "new" then
      error("Wrong map for delete")
    end

    local children = uidMap:GetChildren(uid)
    local removedAllChildren = true
    for index, childUid in ipairs_reverse(children) do
      local removed = self:RemoveUnmatchedNew(uidMap, childUid, otherMap, removeAuras, removeGroups)
      if not removed and not uidMap:GetUIDMatch(childUid) then
        removedAllChildren = false
      end
    end

    local matchedUid = uidMap:GetUIDMatch(uid)
    if not matchedUid and removedAllChildren then
      if uidMap:GetRootUID() == uid then
        error("Can't remove root")
      end

      if (uidMap:GetGroupRegionType(uid) and removeGroups)
          or (uidMap:GetGroupRegionType(uid) == nil and removeAuras)
        then

        for index, childUid in ipairs_reverse(children) do
          uidMap:UnsetParent(childUid)
        end

        uidMap:Remove(uid)
        self:IncProgress()
        coroutine.yield()
        return true
      end
    end
    self:IncProgress()
    coroutine.yield(0.1, "remove unmatched new")
    return false
  end,
  UpdatePhase1 = function(self, structureUidMap, uid, GetPhase1Data, phase2Order)
    local matched = structureUidMap:GetUIDMatch(uid)

    tinsert(phase2Order, uid)
    local data = GetPhase1Data(uid)
    data.preferToUpdate = true
    data.authorMode = nil

    WeakAuras.Add(data)
    WeakAuras.NewDisplayButton(data, true)
    self:IncProgress10()
    coroutine.yield(1, "adding phase 1 data")

    local children = structureUidMap:GetChildren(uid)
    local parentIsDynamicGroup = data.regionType == "dynamicgroup"
    for index, childUid in ipairs(children) do
      self:UpdatePhase1(structureUidMap, childUid, GetPhase1Data, phase2Order)
      structureUidMap:SetGroupOrder(childUid, index, #children)
      structureUidMap:SetParentIsDynamicGroup(childUid, parentIsDynamicGroup)
    end
  end,
  UpdatePhase2 = function(self, structureUidMap, GetPhase2Data, phase2Order, copies)
    for i = #phase2Order, 1, -1 do
      local uid = phase2Order[i]
      local data = GetPhase2Data(uid)
      data.preferToUpdate = true
      data.authorMode = nil
      WeakAuras.Add(data)
      table.insert(copies, {uid = uid, data = CopyTable(data), source = "update"})
      local button = OptionsPrivate.GetDisplayButton(data.id)
      button:SetData(data)
      if (data.parent) then
        local parentIsDynamicGroup = structureUidMap:GetParentIsDynamicGroup(uid)
        local index, total = structureUidMap:GetGroupOrder(uid)
        button:SetGroup(data.parent, parentIsDynamicGroup)
        button:SetGroupOrder(index, total)
      else
        button:SetGroup()
        button:SetGroupOrder(nil, nil)
      end
      button.callbacks.UpdateExpandButton()
      button:UpdateParentWarning()
      WeakAuras.UpdateGroupOrders(data)
      WeakAuras.UpdateThumbnail(data)
      WeakAuras.ClearAndUpdateOptions(data.id)
      self:IncProgress10()
      coroutine.yield()
    end

    -- Since we add from the leafs to the top, we need to correct the offset last
    for i = #phase2Order, 1, -1 do
      local uid = phase2Order[i]
      local data = OptionsPrivate.Private.GetDataByUID(uid)
      local displayButton = OptionsPrivate.GetDisplayButton(data.id)
      displayButton:UpdateOffset()
    end
  end,
  ImportPhase1 = function(self, uidMap, uid, phase2Order)
    tinsert(phase2Order, uid)
    local data = uidMap:GetPhase1Data(uid)
    local newId = OptionsPrivate.Private.FindUnusedId(data.id)
    uidMap:ChangeId(uid, newId)

    data.preferToUpdate = false
    data.authorMode = nil
    data.id = newId

    WeakAuras.Add(data)
    WeakAuras.NewDisplayButton(data, true)

    self:IncProgress()
    coroutine.yield()

    local children = uidMap:GetChildren(uid)
    local totalChildren = #children
    local parentIsDynamicGroup = data.regionType == "dynamicgroup"
    for index, childUid in ipairs(children) do
      self:ImportPhase1(uidMap, childUid, phase2Order)
      uidMap:SetGroupOrder(childUid, index, totalChildren)
      uidMap:SetParentIsDynamicGroup(childUid, parentIsDynamicGroup)
    end
  end,
  ImportPhase2 = function(self, uidMap, phase2Order, copies)
    for i = #phase2Order, 1, -1 do
      local uid = phase2Order[i]
      local data = uidMap:GetPhase2Data(uid)
      data.preferToUpdate = false
      data.authorMode = nil
      WeakAuras.Add(data)
      table.insert(copies, {uid = uid, data = CopyTable(data), source = "import"})

      local button = OptionsPrivate.GetDisplayButton(data.id)
      button:SetData(data)
      if (data.parent) then
        local parentIsDynamicGroup = uidMap:GetParentIsDynamicGroup(uid)
        local index, total = uidMap:GetGroupOrder(uid)
        button:SetGroup(data.parent, parentIsDynamicGroup)
        button:SetGroupOrder(index, total)
      else
        button:SetGroup()
        button:SetGroupOrder(nil, nil)
      end
      button.callbacks.UpdateExpandButton()
      button:UpdateParentWarning()
      WeakAuras.UpdateGroupOrders(data)
      WeakAuras.UpdateThumbnail(data)
      WeakAuras.ClearAndUpdateOptions(data.id)
      self:IncProgress()
      coroutine.yield()
    end

    for i = #phase2Order, 1, -1 do
      local uid = phase2Order[i]
      local data = OptionsPrivate.Private.GetDataByUID(uid)
      local displayButton = OptionsPrivate.GetDisplayButton(data.id)
      displayButton:UpdateOffset()
    end

  end,
  InitializeProgress = function(self, total)
    self.progress = 0
    self.total = total
    self.minProgress = nil
    self.progressBar:SetProgress(self.progress, self.total)
  end,
  IncProgress = function(self)
    if self.minProgress and self.progress + 10 < self.minProgress then
      self.progress = self.progress + 1 + floor((self.minProgress - self.progress + 1) / 10)
    else
      self.progress = self.progress + 1
    end
    self.progressBar:SetProgress(self.progress, self.total)
  end,
  IncProgress10 = function(self)
    if self.minProgress and self.progress + 10 < self.minProgress then
      self.progress = self.progress + 10 + floor((self.minProgress - self.progress + 10) / 10)
    else
      self.progress = self.progress + 10
    end
    self.progressBar:SetProgress(self.progress, self.total)
  end,
  SetMinimumProgress = function(self, minProgress)
    self.minProgress = minProgress
  end,
  SetMaxProgress = function(self)
    self.progress = self.total
    self.progressBar:SetProgress(self.progress, self.total)
  end,
  Close = function(self, success, id)
    self.optionsWindow.window = "default";
    self.optionsWindow:UpdateFrameVisible()
    if self.callbackFunc then
      self.callbackFunc(success, id)
    end
  end,
  AddBasicInformationWidgets = function(self, data, sender)
    local title = AceGUI:Create("Label")
    title:SetFontObject(GameFontNormalHuge)
    title:SetFullWidth(true)
    title:SetText(L["Importing %s"]:format(data.id))
    self:AddChild(title)

    local description = AceGUI:Create("Label")
    description:SetFontObject(GameFontHighlight)
    description:SetFullWidth(true)
    description:SetText(data.desc or "")
    self:AddChild(description)

    if data.url and data.url ~= "" then
      local url = AceGUI:Create("Label")
      url:SetFontObject(GameFontHighlight)
      url:SetFullWidth(true)
      url:SetText(L["Url: %s"]:format(data.url))
      self:AddChild(url)
    end

    if data.semver or data.version then
      local version = AceGUI:Create("Label")
      version:SetFontObject(GameFontHighlight)
      version:SetFullWidth(true)
      version:SetText(L["Version: %s"]:format(data.semver or data.version))
      self:AddChild(version)
    end

    if sender then
      local senderLabel = AceGUI:Create("Label")
      senderLabel:SetFontObject(GameFontHighlight)
      senderLabel:SetFullWidth(true)
      senderLabel:SetText(L["Aura received from: %s"]:format(sender))
      self:AddChild(senderLabel)
    end
  end,
  AddProgressWidgets = function(self)
    local title = AceGUI:Create("Label")
    title:SetFontObject(GameFontNormalHuge)
    title:SetFullWidth(true)
    title:SetText(L["Importing...."])
    self:AddChild(title)

    local progress = AceGUI:Create("WeakAurasProgressBar")
    self.progressBar = progress
    self:AddChild(progress)
  end
}

local updateFrame
local function ConstructUpdateFrame(frame)
  ---@class GroupUpdateFrame: AceGUIFrame
  local group = AceGUI:Create("ScrollFrame");
  group.frame:SetParent(frame);
  group.frame:SetPoint("TOPLEFT", frame, "TOPLEFT", 16, -63);
  group.frame:SetPoint("BOTTOMRIGHT", frame, "BOTTOMRIGHT", -16, 46);
  group.frame:Hide();
  group:SetLayout("flow");
  group.optionsWindow = frame


  -- Action buttons
  local viewCodeButton = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  viewCodeButton:SetScript("OnClick", function() OptionsPrivate.OpenCodeReview(group.scamCheckResult) end);
  viewCodeButton:SetPoint("BOTTOMLEFT", 20, -24);
  viewCodeButton:SetFrameLevel(viewCodeButton:GetFrameLevel() + 1)
  viewCodeButton:SetHeight(20);
  viewCodeButton:SetWidth(160);
  viewCodeButton:SetText(L["View custom code"])

  local importButton = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  importButton:SetScript("OnClick", function() group:Import() end);
  importButton:SetPoint("BOTTOMRIGHT", -190, -24);
  importButton:SetFrameLevel(importButton:GetFrameLevel() + 1)
  importButton:SetHeight(20);
  importButton:SetWidth(160);
  importButton:SetText(L["Import"])

  local closeButton = CreateFrame("Button", nil, group.frame, "UIPanelButtonTemplate");
  closeButton:SetScript("OnClick", function() group:Close(false) end);
  closeButton:SetPoint("BOTTOMRIGHT", -20, -24);
  closeButton:SetFrameLevel(closeButton:GetFrameLevel() + 1)
  closeButton:SetHeight(20);
  closeButton:SetWidth(160);
  closeButton:SetText(L["Close"])

  group.viewCodeButton = viewCodeButton
  group.importButton = importButton
  group.closeButton = closeButton

  for name, method in pairs(methods) do
    group[name] = method
  end

  return group
end

function OptionsPrivate.UpdateFrame(frame, noConstruct)
  updateFrame = updateFrame or (not noConstruct and ConstructUpdateFrame(frame))
  return updateFrame
end

=== END OF FILE: WeakAurasOptions/OptionsFrames/Update.lua ===


=== FILE: WeakAurasOptions/RegionOptions/AuraBar.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- Create region options table
local function createOptions(id, data)
  local statusbarList = {}
  Mixin(statusbarList, SharedMedia:HashTable("statusbar"))
  Mixin(statusbarList, SharedMedia:HashTable("statusbar_atlas"))

  -- Region options
  local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;
  local options = {
    __title = L["Progress Bar Settings"],
    __order = 1,
    textureSource = {
      type = "select",
      order = 1,
      width = WeakAuras.doubleWidth,
      name = L["Texture Selection Mode"],
      values = {
        LSM = L["LibSharedMedia"],
        Picker = L["Texture Picker"]
      },
      get = function()
        return data.textureSource or "LSM"
      end,
    },
    texture = {
      type = "select",
      dialogControl = "WA_LSM30_StatusbarAtlas",
      order = 2,
      width = WeakAuras.doubleWidth,
      name = L["Bar Texture"],
      values = statusbarList,
      hidden = function()
        return data.textureSource == "Picker"
      end
    },
    textureInput = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Texture"],
      order = 3,
      hidden = function()
        return data.textureSource ~= "Picker"
      end
    },
    chooseTexture = {
      type = "execute",
      name = L["Choose"],
      width = 0.15,
      order = 4,
      func = function()
        local path = {}
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(data, paths, {
          texture = "textureInput",
          color = "color",
        }, OptionsPrivate.Private.texture_types, nil, true)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
      hidden = function()
        return data.textureSource ~= "Picker"
      end
    },
    orientation = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Orientation"],
      order = 25,
      values = OptionsPrivate.Private.orientation_types,
      set = function(info, v)
        if(
          (
          data.orientation:find("INVERSE")
          and not v:find("INVERSE")
          )
          or (
          v:find("INVERSE")
          and not data.orientation:find("INVERSE")
          )
          ) then
          data.icon_side = data.icon_side == "LEFT" and "RIGHT" or "LEFT";
        end

        if(
          (
          data.orientation:find("HORIZONTAL")
          and v:find("VERTICAL")
          )
          or (
          data.orientation:find("VERTICAL")
          and v:find("HORIZONTAL")
          )
          ) then
          local temp = data.width;
          data.width = data.height;
          data.height = temp;
          data.icon_side = data.icon_side == "LEFT" and "RIGHT" or "LEFT";

          if(data.rotateText == "LEFT" or data.rotateText == "RIGHT") then
            data.rotateText = "NONE";
          elseif(data.rotateText == "NONE") then
            data.rotateText = "LEFT"
          end
        end

        data.orientation = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    inverse = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Inverse"],
      order = 35
    },
    smoothProgress = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Smooth Progress"],
      desc = L["Animates progress changes"],
      order = 37
    },
    useTooltip = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Tooltip on Mouseover"],
      hidden = function() return not OptionsPrivate.Private.CanHaveTooltip(data) end,
      order = 38
    },
    bar_header = {
      type = "header",
      name = L["Bar Color Settings"],
      order = 39
    },
    enableGradient = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Enable Gradient"],
      order = 39.1
    },
    gradientOrientation = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = OptionsPrivate.Private.gradient_orientations,
      name = L["Gradient Orientation"],
      order = 39.2
    },
    barColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Bar Color/Gradient Start"],
      hasAlpha = true,
      order = 39.3
    },
    barColor2 = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Gradient End"],
      hasAlpha = true,
      order = 39.4
    },
    backgroundColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Background Color"],
      hasAlpha = true,
      order = 39.5
    },
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Bar Alpha"],
      order = 39.6,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    },
    icon_header = {
      type = "header",
      name = L["Icon Settings"],
      order = 40.1
    },
    icon = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show Icon"],
      order = 40.2,
    },
    icon_side = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Icon Position"],
      values = OptionsPrivate.Private.icon_side_types,
      hidden = function() return data.orientation:find("VERTICAL") or not data.icon end,
      order = 40.3,
    },
    icon_side2 = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Icon Position"],
      values = OptionsPrivate.Private.rotated_icon_side_types,
      hidden = function() return data.orientation:find("HORIZONTAL") or not data.icon end,
      order = 40.3,
      get = function()
        return data.icon_side;
      end,
      set = function(info, v)
        data.icon_side = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
      end
    },
    iconSource = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Source"],
      order = 40.4,
      values = OptionsPrivate.Private.IconSources(data),
      hidden = function() return not data.icon end,
    },
    displayIcon = {
      type = "input",
      width = WeakAuras.normalWidth - 0.15,
      name = L["Manual"],
      disabled = function() return not data.icon end,
      order = 40.5,
      get = function()
        return data.displayIcon and tostring(data.displayIcon) or "";
      end,
      set = function(info, v)
        data.displayIcon = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
      end,
      hidden = function() return not data.icon end,
    },
    chooseIcon = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      disabled = function() return not data.icon end,
      order = 40.6,
      func = function()
        local path = {"displayIcon"}
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenIconPicker(data, paths)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
      hidden = function() return not data.icon end,
    },
    desaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 40.8,
      hidden = function() return not data.icon end,
    },
    icon_color = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 40.9,
      hidden = function() return not data.icon end,
    },
    zoom = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Zoom"],
      order = 40.91,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true,
      hidden = function() return not data.icon end,
    },
    spark_header = {
      type = "header",
      name = L["Spark Settings"],
      order = 42
    },
    spark = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show Spark"],
      order = 43
    },
    sparkTexture = {
      type = "input",
      name = L["Spark Texture"],
      order = 44,
      width = WeakAuras.doubleWidth - 0.15,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkChooseTexture = {
      type = "execute",
      name = L["Choose"],
      width = 0.15,
      order = 44.1,
      func = function()
        local path = {}
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(data, paths, {
          texture = "sparkTexture",
          color = "sparkColor",
          rotation = "sparkRotation",
          mirror = "sparkMirror",
          blendMode = "sparkBlendMode"
        }, OptionsPrivate.Private.texture_types)
      end,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    sparkDesaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 44.2,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    spaceSpark = {
      type = "execute",
      name = "",
      width = WeakAuras.normalWidth,
      order = 44.3,
      image = function() return "", 0, 0 end,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 44.4,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkBlendMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 44.5,
      values = OptionsPrivate.Private.blend_types,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkWidth = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Width"],
      order = 44.6,
      min = 1,
      softMax = screenWidth,
      bigStep = 1,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkHeight = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Height"],
      order = 44.7,
      min = 1,
      softMax = screenHeight,
      bigStep = 1,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkOffsetX = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["X Offset"],
      order = 44.8,
      min = -screenWidth,
      max = screenWidth,
      bigStep = 1,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkOffsetY = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y Offset"],
      order = 44.9,
      min = -screenHeight,
      max = screenHeight,
      bigStep = 1,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkRotationMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = OptionsPrivate.Private.spark_rotation_types,
      name = L["Rotation Mode"],
      order = 45,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkRotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      min = 0,
      max = 360,
      step = 90,
      order = 45.1,
      disabled = function() return not data.spark or data.sparkRotationMode == "AUTO" end,
      hidden = function() return not data.spark or data.sparkRotationMode == "AUTO" end,
    },
    sparkMirror = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Mirror"],
      order = 45.2,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    sparkHidden = {
      type = "select",
      width = WeakAuras.normalWidth,
      values = OptionsPrivate.Private.spark_hide_types,
      name = L["Hide on"],
      order = 45.3,
      disabled = function() return not data.spark end,
      hidden = function() return not data.spark end,
    },
    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  local overlayInfo = OptionsPrivate.Private.GetOverlayInfo(data);
  if (overlayInfo and next(overlayInfo)) then
    options["overlayheader"] = {
      type = "header",
      name = L["Overlays"],
      order = 58
    }
    local index = 0.01
    for id, display in ipairs(overlayInfo) do
      options["overlaytexture" .. id] = {
        type = "select",
        dialogControl = "WA_LSM30_StatusbarAtlas",
        width = WeakAuras.doubleWidth,
        name = string.format(L["%s Texture"], display),
        values = statusbarList,
        order = 58.1 + index,
        set = function(info, texture)
          if (not data.overlaysTexture) then
            data.overlaysTexture = {};
          end
          data.overlaysTexture[id] = texture;
          WeakAuras.Add(data);
        end,
        get = function()
          if data.overlaysTexture and data.overlaysTexture[id] then
            return data.overlaysTexture[id]
          end
        end
      }
      options["overlaycolor" .. id] = {
        type = "color",
        width = WeakAuras.normalWidth,
        name = string.format(L["%s Color"], display),
        hasAlpha = true,
        order = 58.2 + index,
        get = function()
          if (data.overlays and data.overlays[id]) then
            return unpack(data.overlays[id]);
          end
          return 1, 1, 1, 1;
        end,
        set = function(info, r, g, b, a)
          if (not data.overlays) then
            data.overlays = {};
          end
          data.overlays[id] = { r, g, b, a};
          WeakAuras.Add(data);
        end
      }
      index = index + 0.01
    end

    options["overlayclip"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Clip Overlays"],
      order = 58.3 + index;
    }

  end

  return {
    aurabar = options,
    progressOptions = OptionsPrivate.commonOptions.ProgressOptions(data),
    position = OptionsPrivate.commonOptions.PositionOptions(id, data),
  };
end

-- Create preview thumbnail
local function createThumbnail()
  -- Preview frame
  local borderframe = CreateFrame("Frame", nil, UIParent);
  borderframe:SetWidth(32);
  borderframe:SetHeight(32);

  -- Preview border
  local border = borderframe:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(borderframe);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  -- Main region
  local region = CreateFrame("Frame", nil, borderframe);
  borderframe.region = region;
  region:SetWidth(32);
  region:SetHeight(32);

  -- Status-bar frame
  local bar = CreateFrame("Frame", nil, region);
  borderframe.bar = bar;

  -- Fake status-bar
  local texture = bar:CreateTexture(nil, "OVERLAY");
  borderframe.texture = texture;

  -- Fake icon
  local icon = region:CreateTexture();
  borderframe.icon = icon;
  icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");

  -- Return preview
  return borderframe;
end

-- Modify preview thumbnail
local function modifyThumbnail(parent, borderframe, data, fullModify, width, height)
  -- Localize
  local region, bar, texture, icon = borderframe.region, borderframe.bar, borderframe.texture, borderframe.icon;

  borderframe:SetParent(parent)

  -- Default size
  width  = width or 26;
  height = height or 15;

  -- Fake orientation (main region)
  if(data.orientation:find("HORIZONTAL")) then
    region:SetWidth(width);
    region:SetHeight(height);
    region:ClearAllPoints();
    if(data.orientation == "HORIZONTAL_INVERSE") then
      region:SetPoint("RIGHT", borderframe, "RIGHT", -2, 0);
    else
      region:SetPoint("LEFT", borderframe, "LEFT", 2, 0);
    end
  else
    region:SetWidth(height);
    region:SetHeight(width);
    region:ClearAllPoints();
    if(data.orientation == "VERTICAL_INVERSE") then
      region:SetPoint("TOP", borderframe, "TOP", 0, -2);
    else
      region:SetPoint("BOTTOM", borderframe, "BOTTOM", 0, 2);
    end
  end

  -- Fake status-bar style
  OptionsPrivate.Private.SetTextureOrAtlas(texture, SharedMedia:Fetch("statusbar_atlas", data.texture) or SharedMedia:Fetch("statusbar", data.texture))
  texture:SetVertexColor(data.barColor[1], data.barColor[2], data.barColor[3], data.barColor[4]);

  -- Fake icon size
  local iconsize = height;
  icon:SetWidth(iconsize);
  icon:SetHeight(iconsize);

  -- Fake layout variables
  local percent, length;
  if(data.icon) then
    length = width - height;
    percent = 1 - (width / 100);
  else
    length = width;
    percent = 1 - (width / 100);
  end

  -- Reset region members
  icon:ClearAllPoints();
  bar:ClearAllPoints();
  texture:ClearAllPoints();

  -- Fake orientation (region members)
  if(data.orientation == "HORIZONTAL_INVERSE") then
    icon:SetPoint("LEFT", region, "LEFT");
    bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
    if(data.icon) then
      bar:SetPoint("TOPLEFT", icon, "TOPRIGHT");
    else
      bar:SetPoint("TOPLEFT", region, "TOPLEFT");
    end
    texture:SetPoint("BOTTOMRIGHT", bar, "BOTTOMRIGHT");
    texture:SetPoint("TOPRIGHT", bar, "TOPRIGHT");
    texture:SetTexCoord(1, 0, 1, 1, percent, 0, percent, 1);
    texture:SetWidth(length);
  elseif(data.orientation == "HORIZONTAL") then
    icon:SetPoint("RIGHT", region, "RIGHT");
    bar:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT");
    if(data.icon) then
      bar:SetPoint("TOPRIGHT", icon, "TOPLEFT");
    else
      bar:SetPoint("TOPRIGHT", region, "TOPRIGHT");
    end
    texture:SetPoint("BOTTOMLEFT", bar, "BOTTOMLEFT");
    texture:SetPoint("TOPLEFT", bar, "TOPLEFT");
    texture:SetTexCoord(percent, 0, percent, 1, 1, 0, 1, 1);
    texture:SetWidth(length);
  elseif(data.orientation == "VERTICAL_INVERSE") then
    icon:SetPoint("BOTTOM", region, "BOTTOM");
    bar:SetPoint("TOPLEFT", region, "TOPLEFT");
    if(data.icon) then
      bar:SetPoint("BOTTOMRIGHT", icon, "TOPRIGHT");
    else
      bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
    end
    texture:SetPoint("TOPLEFT", bar, "TOPLEFT");
    texture:SetPoint("TOPRIGHT", bar, "TOPRIGHT");
    texture:SetTexCoord(percent, 0, 1, 0, percent, 1, 1, 1);
    texture:SetHeight(length);
  elseif(data.orientation == "VERTICAL") then
    icon:SetPoint("TOP", region, "TOP");
    bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
    if(data.icon) then
      bar:SetPoint("TOPLEFT", icon, "BOTTOMLEFT");
    else
      bar:SetPoint("TOPLEFT", region, "TOPLEFT");
    end
    texture:SetPoint("BOTTOMLEFT", bar, "BOTTOMLEFT");
    texture:SetPoint("BOTTOMRIGHT", bar, "BOTTOMRIGHT");
    texture:SetTexCoord(1, 0, percent, 0, 1, 1, percent, 1);
    texture:SetHeight(length);
  end

  -- Fake icon (code)
  if(data.icon) then
    function borderframe:SetIcon(path)
      local iconPath
      if data.iconSource == 0 then
        iconPath = data.displayIcon
      else
        iconPath = path or data.displayIcon
      end

      if iconPath and iconPath ~= "" then
        OptionsPrivate.Private.SetTextureOrAtlas(self.icon, iconPath)
      else
        OptionsPrivate.Private.SetTextureOrAtlas(self.icon, "Interface\\Icons\\INV_Misc_QuestionMark")
      end
    end

    if data then
      local _, icon = WeakAuras.GetNameAndIcon(data)
      borderframe:SetIcon(icon)
    end

    icon:Show();
  else
    icon:Hide();
  end
end

-- Create "new region" preview
local function createIcon()
  -- Default data
  local data = {
    icon = true,
    iconSource = 0,
    texture = "Runes",
    orientation = "HORIZONTAL",
    alpha = 1.0,
    barColor = {1, 0, 0, 1},
    triggers = {}
  };

  -- Create and configure thumbnail
  local thumbnail = createThumbnail();
  modifyThumbnail(UIParent, thumbnail, data, nil, 32, 18);
  thumbnail:SetIcon("Interface\\Icons\\INV_Sword_62");

  -- Return thumbnail
  return thumbnail;
end

local templates = {
  {
    title = L["Horizontal Bar"],
    data = {
      width = 200,
      height = 30,
      barColor = { 0, 1, 0, 1},
      inverse = true,
      smoothProgress = true,
    }
  },
  {
    title = L["Vertical Bar"],
    data = {
      width = 30,
      height = 200,
      barColor = { 0, 1, 0, 1},
      rotateText = "LEFT",
      orientation = "VERTICAL_INVERSE",
      inverse = true,
      smoothProgress = true,
    }
  },
}

local anchorPoints = {
  BOTTOMLEFT = {
    display = { L["Background"], L["Bottom Left"] },
    type = "point"
  },
  BOTTOM = {
    display = { L["Background"], L["Bottom"] },
    type = "point"
  },
  BOTTOMRIGHT = {
    display = { L["Background"], L["Bottom Right"] },
    type = "point"
  },
  RIGHT = {
    display = { L["Background"], L["Right"] },
    type = "point"
  },
  TOPRIGHT = {
    display = { L["Background"], L["Top Right"] },
    type = "point"
  },
  TOP = {
    display = { L["Background"], L["Top"] },
    type = "point"
  },
  TOPLEFT = {
    display = { L["Background"], L["Top Left"] },
    type = "point"
  },
  LEFT = {
    display = { L["Background"], L["Left"] },
    type = "point"
  },
  CENTER = {
    display = { L["Background"], L["Center"] },
    type = "point"
  },

  INNER_BOTTOMLEFT = {
    display = { L["Background Inner"], L["Bottom Left"] },
    type = "point"
  },
  INNER_BOTTOM = {
    display = { L["Background Inner"], L["Bottom"] },
    type = "point"
  },
  INNER_BOTTOMRIGHT = {
    display = { L["Background Inner"], L["Bottom Right"] },
    type = "point"
  },
  INNER_RIGHT = {
    display = { L["Background Inner"], L["Right"] },
    type = "point"
  },
  INNER_TOPRIGHT = {
    display = { L["Background Inner"], L["Top Right"] },
    type = "point"
  },
  INNER_TOP = {
    display = { L["Background Inner"], L["Top"] },
    type = "point"
  },
  INNER_TOPLEFT = {
    display = { L["Background Inner"], L["Top Left"] },
    type = "point"
  },
  INNER_LEFT = {
    display = { L["Background Inner"], L["Left"] },
    type = "point"
  },
  INNER_CENTER = {
    display = { L["Background Inner"], L["Center"] },
    type = "point"
  },

  ICON_BOTTOMLEFT = {
    display = { L["Icon"], L["Bottom Left"] },
    type = "point"
  },
  ICON_BOTTOM = {
    display = { L["Icon"], L["Bottom"] },
    type = "point"
  },
  ICON_BOTTOMRIGHT = {
    display = { L["Icon"], L["Bottom Right"] },
    type = "point"
  },
  ICON_RIGHT = {
    display = { L["Icon"], L["Right"] },
    type = "point"
  },
  ICON_TOPRIGHT = {
    display = { L["Icon"], L["Top Right"] },
    type = "point"
  },
  ICON_TOP = {
    display = { L["Icon"], L["Top"] },
    type = "point"
  },
  ICON_TOPLEFT = {
    display = { L["Icon"], L["Top Left"] },
    type = "point"
  },
  ICON_LEFT = {
    display = { L["Icon"], L["Left"] },
    type = "point"
  },
  ICON_CENTER = {
    display = { L["Icon"], L["Center"] },
    type = "point"
  },

  SPARK = {
    display = L["Spark"],
    type = "point"
  },

  bar = {
    display = L["Full Bar"],
    type = "area"
  },

  icon = {
    display = L["Icon"],
    type = "area"
  },

  fg = {
    display = L["Foreground"],
    type = "area"
  },

  bg = {
    display = L["Background"],
    type = "area"
  }
}

local function GetAnchors(data)
  return anchorPoints;
end

-- Register new region type options with WeakAuras
OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("aurabar", createOptions, createIcon, L["Progress Bar"], createThumbnail, modifyThumbnail, L["Shows a progress bar with name, timer, and icon"], templates, GetAnchors);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/AuraBar.lua ===


=== FILE: WeakAurasOptions/RegionOptions/DynamicGroup.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local selfPoints = {
  default = "CENTER",
  RIGHT = function(data)
    if data.align  == "LEFT" then
      return "TOPLEFT"
    elseif data.align == "RIGHT" then
      return "BOTTOMLEFT"
    else
      return "LEFT"
    end
  end,
  LEFT = function(data)
    if data.align  == "LEFT" then
      return "TOPRIGHT"
    elseif data.align == "RIGHT" then
      return "BOTTOMRIGHT"
    else
      return "RIGHT"
    end
  end,
  UP = function(data)
    if data.align == "LEFT" then
      return "BOTTOMLEFT"
    elseif data.align == "RIGHT" then
      return "BOTTOMRIGHT"
    else
      return "BOTTOM"
    end
  end,
  DOWN = function(data)
    if data.align == "LEFT" then
      return "TOPLEFT"
    elseif data.align == "RIGHT" then
      return "TOPRIGHT"
    else
      return "TOP"
    end
  end,
  HORIZONTAL = function(data)
    if data.align == "LEFT" then
      return "TOP"
    elseif data.align == "RIGHT" then
      return "BOTTOM"
    else
      return "CENTER"
    end
  end,
  VERTICAL = function(data)
    if data.align == "LEFT" then
      return "LEFT"
    elseif data.align == "RIGHT" then
      return "RIGHT"
    else
      return "CENTER"
    end
  end,
  CIRCLE = "CENTER",
  COUNTERCIRCLE = "CENTER",
}

local gridSelfPoints = {
  RU = "BOTTOMLEFT",
  UR = "BOTTOMLEFT",
  LU = "BOTTOMRIGHT",
  UL = "BOTTOMRIGHT",
  RD = "TOPLEFT",
  DR = "TOPLEFT",
  LD = "TOPRIGHT",
  DL = "TOPRIGHT",
  HD = "TOP",
  HU = "BOTTOM",
  VR = "LEFT",
  VL = "RIGHT",
  DH = "TOP",
  UH = "BOTTOM",
  LV = "RIGHT",
  RV = "LEFT",
  HV = "CENTER",
  VH = "CENTER",
}

local function createOptions(id, data)
  local options = {
    __title = L["Dynamic Group Settings"],
    __order = 1,
    groupIcon = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Group Icon"],
      desc = L["Set Thumbnail Icon"],
      order = 0.5,
      get = function()
        return data.groupIcon and tostring(data.groupIcon) or ""
      end,
      set = function(info, v)
        data.groupIcon = v
        WeakAuras.Add(data)
        WeakAuras.UpdateThumbnail(data)
      end
    },
    chooseIcon = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 0.51,
      func = function()
        OptionsPrivate.OpenIconPicker(data, { [data.id] = {"groupIcon"} }, true)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    -- grow options
    grow = {
      type = "select",
      width = WeakAuras.doubleWidth,
      name = L["Grow"],
      order = 1,
      values = OptionsPrivate.Private.grow_types,
      set = function(info, v)
        data.grow = v
        if v == "GRID" then
          data.selfPoint = gridSelfPoints[data.gridType]
        else
          local selfPoint = selfPoints[data.grow] or selfPoints.default
          if type(selfPoint) == "function" then
            selfPoint = selfPoint(data)
          end
          data.selfPoint = selfPoint
        end
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
        OptionsPrivate.ResetMoverSizer()
      end,
    },
    growOn = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = L["Run on..."],
      desc = L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Grow Code on.\n\nWeakAuras will always run custom grow code if you include 'changed' in this list, or when a region is added, removed, or re-ordered."],
      order = 2 - 0.1,
      get = function()
        return data.growOn or ""
      end,
      hidden = function() return data.grow ~= "CUSTOM" end,
      set = function(info, v)
        data.growOn = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
        OptionsPrivate.ResetMoverSizer()
      end
    },
    useAnchorPerUnit = {
      type = "toggle",
      order = 1.5,
      width = WeakAuras.normalWidth,
      name = L["Group by Frame"],
      desc = L["Group and anchor each auras by frame.\n\n- Nameplates: attach to nameplates per unit.\n- Unit Frames: attach to unit frame buttons per unit.\n- Custom Frames: choose which frame each region should be anchored to."],
      hidden = function() return data.grow == "CUSTOM" end,
    },
    anchorPerUnit = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Group by Frame"],
      order = 1.6,
      values = {
        ["UNITFRAME"] = L["Unit Frames"],
        ["NAMEPLATE"] = L["Nameplates"],
        ["CUSTOM"] = L["Custom Frames"],
      },
      hidden = function() return data.grow == "CUSTOM" end,
      disabled = function() return not data.useAnchorPerUnit end
    },
    anchorOn = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = L["Run on..."],
      desc = L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the Anchor Code on.\n\nWeakAuras will always run custom anchor code if you include 'changed' in this list, or when a region is added, removed, or re-ordered."],
      order = 1.61,
      get = function()
        return data.anchorOn or ""
      end,
      hidden = function()
        return not(data.grow ~= "CUSTOM" and data.useAnchorPerUnit and data.anchorPerUnit == "CUSTOM")
      end,
      set = function(info, v)
        data.anchorOn = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
        OptionsPrivate.ResetMoverSizer()
      end
    },
    -- custom grow option added below
    align = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Align"],
      order = 2,
      values = OptionsPrivate.Private.align_types,
      set = function(info, v)
        data.align = v
        local selfPoint = selfPoints[data.grow] or selfPoints.default
        if type(selfPoint) == "function" then
          selfPoint = selfPoint(data)
        end
        data.selfPoint = selfPoint
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
        OptionsPrivate.ResetMoverSizer()
      end,
      hidden = function() return (data.grow == "CUSTOM" or data.grow == "LEFT" or data.grow == "RIGHT" or data.grow == "HORIZONTAL" or data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE" or data.grow == "GRID") end,
      disabled = function() return data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE" end
    },
    rotated_align = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Align"],
      order = 3,
      values = OptionsPrivate.Private.rotated_align_types,
      hidden = function() return (data.grow == "CUSTOM" or data.grow == "UP" or data.grow == "DOWN" or data.grow == "VERTICAL" or data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE" or data.grow == "GRID") end,
      get = function() return data.align; end,
      set = function(info, v)
        data.align = v
        local selfPoint = selfPoints[data.grow] or selfPoints.default
        if type(selfPoint) == "function" then
          selfPoint = selfPoint(data)
        end
        data.selfPoint = selfPoint
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
        OptionsPrivate.ResetMoverSizer()
      end,
    },
    centerType = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Aura Order"],
      order = 3,
      values = function()
        if data.grow == "HORIZONTAL" then
         return OptionsPrivate.Private.centered_types_h
        else
          return OptionsPrivate.Private.centered_types_v
        end
      end,
      hidden = function() return data.grow ~= "HORIZONTAL" and data.grow ~= "VERTICAL" end,
    },
    -- circle grow options
    constantFactor = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Constant Factor"],
      order = 4,
      values = OptionsPrivate.Private.circular_group_constant_factor_types,
      hidden = function() return not(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") end
    },
    rotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Start Angle"],
      order = 5,
      min = 0,
      max = 360,
      bigStep = 3,
      hidden = function() return not(data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") end
    },
    fullCircle = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Full Circle"],
      order = 7,
      hidden = function()
        return not(
          (data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE")
          and (data.constantFactor == "RADIUS" or data.constantFactor == "SPACING"))
        end
    },
    stepAngle = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Angle Between Auras"],
      order = 12,
      min = 0,
      max = 180,
      bigStep = 1,
      hidden = function()
        return not((data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") and data.constantFactor == "ANGLE")
      end
    },
    arcLength = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Total Angle"],
      order = 8,
      min = 0,
      max = 360,
      bigStep = 3,
      disabled = function() return data.fullCircle end,
      hidden = function()
        return not(
          (data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE")
          and (data.constantFactor == "RADIUS" or data.constantFactor == "SPACING"))
        end
    },
    radius = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Radius"],
      order = 9,
      softMin = 0,
      softMax = 500,
      bigStep = 1,
      hidden = function()
        return not(
          (data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE")
          and (data.constantFactor == "RADIUS" or data.constantFactor == "ANGLE"))
        end
    },
    -- grid grow options
    gridType = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Grid direction"],
      order = 8,
      values = OptionsPrivate.Private.grid_types,
      hidden = function() return data.grow ~= "GRID" end,
      set = function(info, value)
        data.selfPoint = gridSelfPoints[value]
        data.gridType = value
        WeakAuras.Add(data)
        OptionsPrivate.ResetMoverSizer()
      end,
    },
    gridWidth = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = function()
        if not data.gridType then return "" end
        if data.gridType:find("^[RLH]") then
          return L["Row Width"]
        else
          return L["Column Height"]
        end
      end,
      order = 9,
      min = 1,
      softMax = 20,
      step = 1,
      hidden = function() return data.grow ~= "GRID" end,
    },
    rowSpace = {
      type = "range",
      control = "WeakAurasSpinBox",
      name = L["Row Space"],
      width = WeakAuras.normalWidth,
      order = 10,
      softMin = 0,
      softMax = 300,
      step = 1,
      hidden = function() return data.grow ~= "GRID" end,
    },
    columnSpace = {
      type = "range",
      control = "WeakAurasSpinBox",
      name = L["Column Space"],
      width = WeakAuras.normalWidth,
      order = 11,
      softMin = 0,
      softMax = 300,
      step = 1,
      hidden = function() return data.grow ~= "GRID" end,
    },
    -- generic grow options
    space = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Space"],
      order = 7,
      softMin = 0,
      softMax = 300,
      bigStep = 1,
      hidden = function()
        return not(
          data.grow == "LEFT" or data.grow == "RIGHT"
          or data.grow == "UP" or data.grow == "DOWN"
          or data.grow == "HORIZONTAL" or data.grow == "VERTICAL"
          or ((data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE")
              and (data.constantFactor == "SPACING")))
      end
    },
    stagger = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Stagger"],
      order = 8,
      min = -50,
      max = 50,
      step = 0.1,
      bigStep = 1,
      hidden = function()
        return data.grow == "CUSTOM"
            or data.grow == "CIRCLE"
            or data.grow == "COUNTERCIRCLE"
            or data.grow == "GRID"
      end
    },
    -- sort options
    sort = {
      type = "select",
      width = WeakAuras.doubleWidth,
      name = L["Sort"],
      order = 20,
      values = OptionsPrivate.Private.group_sort_types
    },
    sortOn = {
      type = "input",
      width = WeakAuras.doubleWidth,
      name = L["Run on..."],
      desc = L["You can add a comma-separated list of state values here that (when changed) WeakAuras should also run the sort code on.WeakAuras will always run custom sort code if you include 'changed' in this list, or when a region is added, removed."],
      order = 21 - 0.1,
      get = function()
        return data.sortOn or ""
      end,
      hidden = function() return data.sort ~= "custom" end,
      set = function(info, v)
        data.sortOn = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
        OptionsPrivate.ResetMoverSizer()
      end
    },
    -- custom sort option added below
    hybridPosition = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Hybrid Position"],
      order = 21,
      values = OptionsPrivate.Private.group_hybrid_position_types,
      hidden = function() return not(data.sort == "hybrid") end,
    },
    hybridSortMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Hybrid Sort Mode"],
      order = 22,
      values = OptionsPrivate.Private.group_hybrid_sort_types,
      hidden = function() return not(data.sort == "hybrid") end,
    },
    sortHybrid = {
      type = "multiselect",
      width = "full",
      name = L["Select the auras you always want to be listed first"],
      order = 23,
      hidden = function() return not(data.sort == "hybrid") end,
      values = function()
        return data.controlledChildren
      end,
      get = function(info, index)
        local id = data.controlledChildren[index]
        return data.sortHybridTable and data.sortHybridTable[id] or false;
      end,
      set = function(info, index)
        if not data.sortHybridTable then data.sortHybridTable = {}; end
        local id = data.controlledChildren[index]
        local cur = data.sortHybridTable and data.sortHybridTable[id] or false;
        data.sortHybridTable[id] = not(cur);
      end,
    },
    sortSpace = {
      type = "description",
      name = "",
      width = WeakAuras.doubleWidth,
      order = 24,
      hidden = function() return data.sort == "hybrid" end
    },
    useLimit = {
      type = "toggle",
      order = 25,
      width = WeakAuras.normalWidth,
      name = L["Limit"],
      hidden = function() return data.grow == "CUSTOM" end,
    },
    limit = {
      type = "range",
      control = "WeakAurasSpinBox",
      order = 26,
      width = WeakAuras.normalWidth,
      name = L["Limit"],
      min = 0,
      softMax = 20,
      step = 1,
      disabled = function() return not data.useLimit end,
      hidden = function() return data.grow == "CUSTOM" end,
    },
    animate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Animated Expand and Collapse"],
      order = 27
    },
    spacer = {
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = 27.5
    },
    scale = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Group Scale"],
      order = 28,
      min = 0.05,
      softMax = 2,
      max = 10,
      bigStep = 0.05,
      get = function()
        return data.scale or 1
      end,
      set = function(info, v)
        data.scale = data.scale or 1
        local change = 1 - (v/data.scale)
        data.xOffset = data.xOffset/(1-change)
        data.yOffset = data.yOffset/(1-change)
        data.scale = v
        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Group Alpha"],
      order = 29,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    },
    sharedFrameLevel = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Flat Framelevels"],
      desc = L["The group and all direct children will share the same base frame level."],
      order = 30,
      set = function(info, v)
        data.sharedFrameLevel = v
        WeakAuras.Add(data)
        for parent in OptionsPrivate.Private.TraverseParents(data) do
          WeakAuras.Add(parent)
        end
      end
    },
    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  OptionsPrivate.commonOptions.AddCodeOption(options, data, L["Custom Grow"], "custom_grow", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#grow",
                          2, function() return data.grow ~= "CUSTOM" end, {"customGrow"}, false, { setOnParent = true })
  OptionsPrivate.commonOptions.AddCodeOption(options, data, L["Custom Sort"], "custom_sort", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-sort",
                          21, function() return data.sort ~= "custom" end, {"customSort"}, false, { setOnParent = true })
  OptionsPrivate.commonOptions.AddCodeOption(options, data, L["Custom Anchor"], "custom_anchor_per_unit", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#group-by-frame",
                          1.7, function() return not(data.grow ~= "CUSTOM" and data.useAnchorPerUnit and data.anchorPerUnit == "CUSTOM") end, {"customAnchorPerUnit"}, false, { setOnParent = true })

  local borderHideFunc = function() return data.useAnchorPerUnit end
  local disableSelfPoint = function() return data.grow ~= "CUSTOM" and data.grow ~= "GRID" and not data.useAnchorPerUnit end

  for k, v in pairs(OptionsPrivate.commonOptions.BorderOptions(id, data, nil, borderHideFunc, 70)) do
    options[k] = v
  end

  return {
    dynamicgroup = options,
    position = OptionsPrivate.commonOptions.PositionOptions(id, data, nil, true, disableSelfPoint, true),
  };
end

local function createThumbnail()
  -- frame
  local thumbnail = CreateFrame("Frame", nil, UIParent);
  thumbnail:SetWidth(32);
  thumbnail:SetHeight(32);

  -- border
  local border = thumbnail:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(thumbnail);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  return thumbnail
end

local function defaultIconAnimation(self, elapsed)
  self.elapsed = self.elapsed + elapsed
  if(self.elapsed < 0.5) then
    self.t2:SetPoint("TOP", self.t1, "BOTTOM", 0, -2 + (28 * self.elapsed))
    self.t2:SetAlpha(1 - (2 * self.elapsed))
  elseif(self.elapsed < 1.5) then
  -- do nothing
  elseif(self.elapsed < 2) then
    self.t2:SetPoint("TOP", self.t1, "BOTTOM", 0, -2 + (28 * (2 - self.elapsed)))
    self.t2:SetAlpha((2 * self.elapsed) - 3)
  elseif(self.elapsed < 3) then
  -- do nothing
  else
    self.elapsed = self.elapsed - 3
  end
end

local function createAnimatedDefaultIcon(parent)
  local defaultIcon = CreateFrame("Frame", nil, parent);
  parent.defaultIcon = defaultIcon;

  local t1 = defaultIcon:CreateTexture(nil, "ARTWORK");
  t1:SetWidth(24);
  t1:SetHeight(6);
  t1:SetColorTexture(0.8, 0, 0);
  t1:SetPoint("TOP", parent, "TOP", 0, -6);
  local t2 = defaultIcon:CreateTexture(nil, "ARTWORK");
  t2:SetWidth(12);
  t2:SetHeight(12);
  t2:SetColorTexture(0.2, 0.8, 0.2);
  t2:SetPoint("TOP", t1, "BOTTOM", 0, -2);
  local t3 = defaultIcon:CreateTexture(nil, "ARTWORK");
  t3:SetWidth(30);
  t3:SetHeight(4);
  t3:SetColorTexture(0.1, 0.25, 1);
  t3:SetPoint("TOP", t2, "BOTTOM", 0, -2);
  local t4 = defaultIcon:CreateTexture(nil, "OVERLAY");
  t4:SetWidth(1);
  t4:SetHeight(36);
  t4:SetColorTexture(1, 1, 1);
  t4:SetPoint("CENTER", parent, "CENTER");

  defaultIcon.t1 = t1
  defaultIcon.t2 = t2

  defaultIcon.elapsed = 0;
  defaultIcon:SetScript("OnUpdate", defaultIconAnimation)
  defaultIcon:SetScript("OnHide", function(self) self:SetScript("OnUpdate", nil) end)
  defaultIcon:SetScript("OnShow", function(self) self:SetScript("OnUpdate", defaultIconAnimation) end)

  return defaultIcon
end

-- Modify preview thumbnail
local function modifyThumbnail(parent, frame, data)
  function frame:SetIcon(path)
    if not frame.icon then
      local icon = frame:CreateTexture(nil, "OVERLAY")
      icon:SetAllPoints(frame)
      frame.icon = icon
    end
    local success = OptionsPrivate.Private.SetTextureOrAtlas(frame.icon, path or data.groupIcon) and (path or data.groupIcon)
    if success then
      if frame.defaultIcon then
        frame.defaultIcon:Hide()
      end
      frame.icon:Show()
    else
      if frame.icon then
        frame.icon:Hide()
      end
      if not frame.defaultIcon then
        frame.defaultIcon = createAnimatedDefaultIcon(frame)
      end
      frame.defaultIcon:Show()
    end
  end
  frame:SetIcon()
end

local function createIcon()
  local thumbnail = createThumbnail()
  thumbnail.defaultIcon = createAnimatedDefaultIcon(thumbnail)
  return thumbnail
end

OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("dynamicgroup", createOptions, createIcon, L["Dynamic Group"], createThumbnail, modifyThumbnail, L["A group that dynamically controls the positioning of its children"]);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/DynamicGroup.lua ===


=== FILE: WeakAurasOptions/RegionOptions/Empty.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local function createOptions(id, data)
  local options = {
    __title = L["Settings"],
    __order = 1,
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Alpha"],
      order = 1,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    },

    thumbnailIcon = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Thumbnail Icon"],
      order = 2,
      get = function()
        return data.thumbnailIcon and tostring(data.thumbnailIcon) or ""
      end,
      set = function(info, v)
        data.thumbnailIcon = v
        WeakAuras.Add(data)
        WeakAuras.UpdateThumbnail(data)
      end
    },
    chooseIcon = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 3,
      func = function()
         OptionsPrivate.OpenIconPicker(data, { [data.id] = {"thumbnailIcon"} }, true)
       end,
       imageWidth = 24,
       imageHeight = 24,
       control = "WeakAurasIcon",
       image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
  }

  return {
    empty = options,
    position = OptionsPrivate.commonOptions.PositionOptions(id, data),
  }

end

local function createThumbnail()
  ---@class frame: FrameScriptObject
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:SetWidth(32)
  frame:SetHeight(32)

  local border = frame:CreateTexture(nil, "OVERLAY")
  border:SetAllPoints(frame)
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp")
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8)

  local icon = frame:CreateTexture(nil, "OVERLAY")
  icon:SetAllPoints(frame)
  frame.icon = icon

  return frame
end

local function modifyThumbnail(parent, frame, data)
  local success = OptionsPrivate.Private.SetTextureOrAtlas(frame.icon, data.thumbnailIcon)
  if success then
    frame.icon:Show()
  else
    frame.icon:Hide()
  end
end

-- Register new region type options with WeakAuras
OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("empty", createOptions, createThumbnail, L["Empty Base Region"],
                                               createThumbnail, modifyThumbnail,
                                               L["Shows nothing, except sub elements"]);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/Empty.lua ===


=== FILE: WeakAurasOptions/RegionOptions/Group.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

-- Calculate bounding box
local function getRect(data)
  -- Temp variables
  local blx, bly, trx, try;
  blx, bly = data.xOffset or 0, data.yOffset or 0;

  if (data.width == nil or data.height == nil or data.regionType == "text") then
    return blx, bly, blx, bly;
  end

  -- Calc bounding box
  if(data.selfPoint:find("LEFT")) then
    trx = blx + data.width;
  elseif(data.selfPoint:find("RIGHT")) then
    trx = blx;
    blx = blx - data.width;
  else
    blx = blx - (data.width/2);
    trx = blx + data.width;
  end
  if(data.selfPoint:find("BOTTOM")) then
    try = bly + data.height;
  elseif(data.selfPoint:find("TOP")) then
    try = bly;
    bly = bly - data.height;
  else
    bly = bly - (data.height/2);
    try = bly + data.height;
  end

  -- Return data
  return blx, bly, trx, try;
end

local function getHeight(data, region)
  if data.regionType == "text" then
    return region.height
  else
    return data.height
  end
end


local function getWidth(data, region)
  if data.regionType == "text" then
    return region.width
  else
    return data.width
  end
end

local function createDistributeAlignOptions(id, data)
  return {
    align_h = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Horizontal Align"],
      order = 10,
      values = OptionsPrivate.Private.align_types,
      get = function()
        if(#data.controlledChildren < 1) then
          return nil;
        end
        ---@type AnchorPoint?, AnchorPoint?, AnchorPoint?
        local alignedCenter, alignedRight, alignedLeft = "CENTER", "RIGHT", "LEFT";
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local left, _, right = getRect(childData);
            local center = (left + right) / 2;
            if(math.abs(right) >= 0.01) then
              alignedRight = nil;
            end
            if(math.abs(left) >= 0.01) then
              alignedLeft = nil;
            end
            if(math.abs(center) >= 0.01) then
              alignedCenter = nil;
            end
          end
        end
        return (alignedCenter or alignedRight or alignedLeft);
      end,
      set = function(info, v)
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          local childRegion = WeakAuras.GetRegion(childId)
          if(childData and childRegion) then
            if(v == "CENTER") then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = 0 - (getWidth(childData, childRegion) / 2);
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = 0 + (getWidth(childData, childRegion) / 2);
              else
                childData.xOffset = 0;
              end
            elseif(v == "LEFT") then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = 0;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = 0 + getWidth(childData, childRegion);
              else
                childData.xOffset = 0 + (getWidth(childData, childRegion) / 2);
              end
            elseif(v == "RIGHT") then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = 0 - getWidth(childData, childRegion);
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = 0;
              else
                childData.xOffset = 0 - (getWidth(childData, childRegion) / 2);
              end
            end
            WeakAuras.Add(childData);
          end
        end
        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    align_v = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Vertical Align"],
      order = 15,
      values = OptionsPrivate.Private.rotated_align_types,
      get = function()
        if(#data.controlledChildren < 1) then
          return nil;
        end
        ---@type AnchorPoint?, AnchorPoint?, AnchorPoint?
        local alignedCenter, alignedBottom, alignedTop = "CENTER", "RIGHT", "LEFT";
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local _, bottom, _, top = getRect(childData);
            local center = (bottom + top) / 2;
            if(math.abs(bottom) >= 0.01) then
              alignedBottom = nil;
            end
            if(math.abs(top) >= 0.01) then
              alignedTop = nil;
            end
            if(math.abs(center) >= 0.01) then
              alignedCenter = nil;
            end
          end
        end
        return alignedCenter or alignedBottom or alignedTop;
      end,
      set = function(info, v)
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          local childRegion = WeakAuras.GetRegion(childId)
          if(childData and childRegion) then
            if(v == "CENTER") then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = 0 - (getHeight(childData, childRegion) / 2);
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = 0 + (getHeight(childData, childRegion) / 2);
              else
                childData.yOffset = 0;
              end
            elseif(v == "RIGHT") then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = 0;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = 0 + getHeight(childData, childRegion);
              else
                childData.yOffset = 0 + (getHeight(childData, childRegion) / 2);
              end
            elseif(v == "LEFT") then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = 0 - ( childData.height or childRegion.height);
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = 0;
              else
                childData.yOffset = 0 - (getHeight(childData, childRegion) / 2);
              end
            end
            WeakAuras.Add(childData);
          end
        end
        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    distribute_h = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Distribute Horizontally"],
      order = 20,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local left, _, right = getRect(childData);
            if not(previousData) then
              if not(math.abs(left) < 0.01 or math.abs(right) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local pleft, _, pright = getRect(previousData);
              if(left - pleft > 0) then
                if not(spaced) then
                  spaced = left - pleft;
                else
                  if(math.abs(spaced - (left - pleft)) > 0.01) then
                    return nil;
                  end
                end
              elseif(right - pright < 0) then
                if not(spaced) then
                  spaced = right - pright;
                else
                  if(math.abs(spaced - (right - pright)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local xOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          local childRegion = WeakAuras.GetRegion(childId)
          if(childData and childRegion) then
            if(v > 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset + getWidth(childData, childRegion);
              else
                childData.xOffset = xOffset + (getWidth(childData, childRegion) / 2);
              end
              xOffset = xOffset + v;
            elseif(v < 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset - getWidth(childData, childRegion);
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset;
              else
                childData.xOffset = xOffset - (getWidth(childData, childRegion) / 2);
              end
              xOffset = xOffset + v;
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    distribute_v = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Distribute Vertically"],
      order = 25,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local _, bottom, _, top = getRect(childData);
            if not(previousData) then
              if not(math.abs(bottom) < 0.01 or math.abs(top) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local _, pbottom, _, ptop = getRect(previousData);
              if(bottom - pbottom > 0) then
                if not(spaced) then
                  spaced = bottom - pbottom;
                else
                  if(math.abs(spaced - (bottom - pbottom)) > 0.01) then
                    return nil;
                  end
                end
              elseif(top - ptop < 0) then
                if not(spaced) then
                  spaced = top - ptop;
                else
                  if(math.abs(spaced - (top - ptop)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local yOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          local childRegion = WeakAuras.GetRegion(childId)
          if(childData and childRegion) then
            if(v > 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset + getHeight(childData, childRegion);
              else
                childData.yOffset = yOffset + (getHeight(childData, childRegion) / 2);
              end
              yOffset = yOffset + v;
            elseif(v < 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset - getHeight(childData, childRegion);
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset;
              else
                childData.yOffset = yOffset - (getHeight(childData, childRegion) / 2);
              end
              yOffset = yOffset + v;
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    space_h = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Space Horizontally"],
      order = 30,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local left, _, right = getRect(childData);
            if not(previousData) then
              if not(math.abs(left) < 0.01 or math.abs(right) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local pleft, _, pright = getRect(previousData);
              if(left - pright > 0) then
                if not(spaced) then
                  spaced = left - pright;
                else
                  if(math.abs(spaced - (left - pright)) > 0.01) then
                    return nil;
                  end
                end
              elseif(right - pleft < 0) then
                if not(spaced) then
                  spaced = right - pleft;
                else
                  if(math.abs(spaced - (right - pleft)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local xOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          local childRegion = WeakAuras.GetRegion(childId)
          if(childData and childRegion) then
            if(v >= 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset;
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset + getWidth(childData, childRegion);
              else
                childData.xOffset = xOffset + (getWidth(childData, childRegion) / 2);
              end
              xOffset = xOffset + v + getWidth(childData, childRegion);
            elseif(v < 0) then
              if(childData.selfPoint:find("LEFT")) then
                childData.xOffset = xOffset - getWidth(childData, childRegion);
              elseif(childData.selfPoint:find("RIGHT")) then
                childData.xOffset = xOffset;
              else
                childData.xOffset = xOffset - (getWidth(childData, childRegion) / 2);
              end
              xOffset = xOffset + v - getWidth(childData, childRegion);
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    space_v = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Space Vertically"],
      order = 35,
      softMin = -100,
      softMax = 100,
      bigStep = 1,
      get = function()
        if(#data.controlledChildren < 2) then
          return nil;
        end
        local spaced;
        local previousData;
        for _, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          if(childData) then
            local _, bottom, _, top = getRect(childData);
            if not(previousData) then
              if not(math.abs(bottom) < 0.01 or math.abs(top) < 0.01) then
                return nil;
              end
              previousData = childData;
            else
              local _, pbottom, _, ptop = getRect(previousData);
              if(bottom - ptop > 0) then
                if not(spaced) then
                  spaced = bottom - ptop;
                else
                  if(math.abs(spaced - (bottom - ptop)) > 0.01) then
                    return nil;
                  end
                end
              elseif(top - pbottom < 0) then
                if not(spaced) then
                  spaced = top - pbottom;
                else
                  if(math.abs(spaced - (top - pbottom)) > 0.01) then
                    return nil;
                  end
                end
              else
                return nil;
              end
            end
            previousData = childData;
          end
        end
        return spaced;
      end,
      set = function(info, v)
        local yOffset = 0;
        for index, childId in pairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childId);
          local childRegion = WeakAuras.GetRegion(childId)
          if(childData and childRegion) then
            if(v >= 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset;
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset + getHeight(childData, childRegion);
              else
                childData.yOffset = yOffset + (getHeight(childData, childRegion) / 2);
              end
              yOffset = yOffset + v + getHeight(childData, childRegion);
            elseif(v < 0) then
              if(childData.selfPoint:find("BOTTOM")) then
                childData.yOffset = yOffset - getHeight(childData, childRegion);
              elseif(childData.selfPoint:find("TOP")) then
                childData.yOffset = yOffset;
              else
                childData.yOffset = yOffset - (getHeight(childData, childRegion) / 2);
              end
              yOffset = yOffset + v - getHeight(childData, childRegion);
            end
            WeakAuras.Add(childData);
          end
        end

        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    }
  }
end

-- Create region options table
local function createOptions(id, data)
  -- Region options
  local options = {
    __title = L["Group Settings"],
    __order = 1,
    groupIcon = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Group Icon"],
      desc = L["Set Thumbnail Icon"],
      order = 0.50,
      get = function()
        return data.groupIcon and tostring(data.groupIcon) or ""
      end,
      set = function(info, v)
        data.groupIcon = v
        WeakAuras.Add(data)
        WeakAuras.UpdateThumbnail(data)
      end
    },
    chooseIcon = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 0.51,
      func = function()
         OptionsPrivate.OpenIconPicker(data, { [data.id] = {"groupIcon"} }, true)
       end,
       imageWidth = 24,
       imageHeight = 24,
       control = "WeakAurasIcon",
       image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    -- Alignment/Distribute options are added below
    scale = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Group Scale"],
      order = 45,
      min = 0.05,
      softMax = 2,
      max = 10,
      bigStep = 0.05,
      get = function()
        return data.scale or 1
      end,
      set = function(info, v)
        data.scale = data.scale or 1
        local change = 1 - (v/data.scale)
        data.xOffset = data.xOffset/(1-change)
        data.yOffset = data.yOffset/(1-change)
        data.scale = v
        WeakAuras.Add(data);
        OptionsPrivate.ResetMoverSizer();
      end
    },
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Group Alpha"],
      order = 46,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    },
    sharedFrameLevel = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Flat Framelevels"],
      desc = L["The group and all direct children will share the same base frame level."],
      order = 47,
      set = function(info, v)
        data.sharedFrameLevel = v
        WeakAuras.Add(data)
        for parent in OptionsPrivate.Private.TraverseParents(data) do
          WeakAuras.Add(parent)
        end
      end
    },
    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  local hasSubGroups = false
  local hasDynamicSubGroup = false
  for index, childId in pairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if childData.controlledChildren then
      hasSubGroups = true
    end
    if childData.regionType == "dynamicgroup" then
      hasDynamicSubGroup = true
    end

    if hasSubGroups and hasDynamicSubGroup then
      break
    end
  end


  if not hasSubGroups then
    for k, v in pairs(createDistributeAlignOptions(id, data)) do
      options[k] = v
    end
  end

  if not hasDynamicSubGroup then
    for k, v in pairs(OptionsPrivate.commonOptions.BorderOptions(id, data, nil, nil, 70)) do
      options[k] = v
    end
  end

  return {
    group = options,
    position = OptionsPrivate.commonOptions.PositionOptions(id, data, nil, true, true, true),
  };
end

local function createThumbnail()
  -- frame
  local thumbnail = CreateFrame("Frame", nil, UIParent);
  thumbnail:SetWidth(32);
  thumbnail:SetHeight(32);

  -- border
  local border = thumbnail:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(thumbnail);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  local icon = thumbnail:CreateTexture(nil, "OVERLAY")
  icon:SetAllPoints(thumbnail)
  thumbnail.icon = icon

  return thumbnail
end

local function createDefaultIcon(parent)
  -- default Icon
  local defaultIcon = CreateFrame("Frame", nil, parent);
  parent.defaultIcon = defaultIcon;

  local t1 = defaultIcon:CreateTexture(nil, "ARTWORK");
  t1:SetWidth(24);
  t1:SetHeight(8);
  t1:SetColorTexture(0.8, 0, 0, 0.5);
  t1:SetPoint("TOP", parent, "TOP", 0, -6);
  local t2 = defaultIcon:CreateTexture(nil, "ARTWORK");
  t2:SetWidth(20);
  t2:SetHeight(20);
  t2:SetColorTexture(0.2, 0.8, 0.2, 0.5);
  t2:SetPoint("TOP", t1, "BOTTOM", 0, 5);
  local t3 = defaultIcon:CreateTexture(nil, "ARTWORK");
  t3:SetWidth(20);
  t3:SetHeight(12);
  t3:SetColorTexture(0.1, 0.25, 1, 0.5);
  t3:SetPoint("TOP", t2, "BOTTOM", -5, 8);

  return defaultIcon
end

-- Modify preview thumbnail
local function modifyThumbnail(parent, frame, data)
  function frame:SetIcon()
    if data.groupIcon then
      local success = OptionsPrivate.Private.SetTextureOrAtlas(frame.icon, data.groupIcon)
      if success then
        if frame.defaultIcon then
          frame.defaultIcon:Hide()
        end
        frame.icon:Show()
        return
      end
    end

    if frame.icon then
      frame.icon:Hide()
    end
    if not frame.defaultIcon then
      frame.defaultIcon = createDefaultIcon(frame)
    end
    frame.defaultIcon:Show()
  end

  frame:SetIcon()
end

-- Create "new region" preview
local function createIcon()
  local thumbnail = createThumbnail()
  thumbnail.defaultIcon = createDefaultIcon(thumbnail)
  return thumbnail
end

-- Register new region type options with WeakAuras
OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("group", createOptions, createIcon, L["Group"], createThumbnail, modifyThumbnail,
                                              L["Controls the positioning and configuration of multiple displays at the same time"])
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/Group.lua ===


=== FILE: WeakAurasOptions/RegionOptions/Icon.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local Masque = LibStub("Masque", true)
local L = WeakAuras.L

local function createOptions(id, data)
  local hiddenIconExtra = function()
    return OptionsPrivate.IsCollapsed("icon", "icon", "iconextra", true);
  end
  local indentWidth = 0.15

  local options = {
    __title = L["Icon Settings"],
    __order = 1,
    color = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 1
    },
    desaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 2,
    },
    iconSource = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Icon Source"],
      order = 3,
      values = OptionsPrivate.Private.IconSources(data)
    },
    displayIcon = {
      type = "input",
      width = WeakAuras.normalWidth - 0.15,
      name = L["Manual Icon"],
      order = 4,
      get = function()
        return data.displayIcon and tostring(data.displayIcon) or "";
      end,
      set = function(info, v)
        data.displayIcon = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
      end
    },
    chooseIcon = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 5,
      func = function()
        local path = {"displayIcon"}
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenIconPicker(data, paths)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    useTooltip = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Tooltip on Mouseover"],
      hidden = function() return not OptionsPrivate.Private.CanHaveTooltip(data) end,
      order = 6
    },
    iconExtraDescription = {
      type = "execute",
      control = "WeakAurasExpandSmall",
      name = function()
        local line = L["|cFFffcc00Extra Options:|r"]
        local changed = false
        if data.alpha ~= 1 then
          line = L["%s Alpha: %d%%"]:format(line, data.alpha*100)
          changed = true
        end
        if data.zoom ~= 0 then
          line = L["%s Zoom: %d%%"]:format(line, data.zoom*100)
          changed = true
        end
        if data.iconInset and data.iconInset ~= 0 then
          line = L["%s Inset: %d%%"]:format(line, data.iconInset*100)
          changed = true
        end
        if data.keepAspectRatio then
          line = L["%s Keep Aspect Ratio"]:format(line)
          changed = true
        end
        if data.texXOffset and data.texXOffset ~= 0 then
          line = L["%s X offset by %d"]:format(line, data.texXOffset)
        end
        if data.texYOffset and data.texYOffset ~= 0 then
          line = L["%s Y offset by %d"]:format(line, data.texYOffset)
        end
        if not changed then
          line = L["%s Default Alpha, Zoom, Icon Inset, Aspect Ratio"]:format(line)
        end
        return line
      end,
      width = WeakAuras.doubleWidth,
      order = 7,
      image = function()
        local collapsed = OptionsPrivate.IsCollapsed("icon", "icon", "iconextra", true);
        return collapsed and "collapsed" or "expanded"
      end,
      imageWidth = 15,
      imageHeight = 15,
      func = function(info, button)
        local collapsed = OptionsPrivate.IsCollapsed("icon", "icon", "iconextra", true);
        OptionsPrivate.SetCollapsed("icon", "icon", "iconextra", not collapsed);
      end,
      arg = {
        expanderName = "icon"
      }
    },
    iconExtra_space1 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 7.02,
      hidden = hiddenIconExtra,
    },
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Alpha"],
      order = 7.03,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true,
      hidden = hiddenIconExtra,
    },
    zoom = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Zoom"],
      order = 7.04,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true,
      hidden = hiddenIconExtra,
    },
    iconExtra_space2 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 7.05,
      hidden = hiddenIconExtra,
    },
    texXOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Texture X Offset"],
      order = 7.06,
      min = -1,
      max = 1,
      bigStep = 0.1,
      hidden = hiddenIconExtra,
    },
    texYOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Texture Y Offset"],
      order = 7.07,
      min = -1,
      max = 1,
      bigStep = 0.1,
      hidden = hiddenIconExtra,
    },
    iconExtra_space3 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 7.08,
      hidden = hiddenIconExtra,
    },
    iconInset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Icon Inset"],
      order = 7.09,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true,
      hidden = function()
        return not Masque or hiddenIconExtra();
      end
    },
    keepAspectRatio = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Keep Aspect Ratio"],
      order = 7.10,
      hidden = hiddenIconExtra,
    },
    iconExtraAnchor = {
      type = "description",
      name = "",
      order = 8,
      hidden = hiddenIconExtra,
      control = "WeakAurasExpandAnchor",
      arg = {
        expanderName = "icon"
      }
    },
    cooldownHeader = {
      type = "header",
      order = 11,
      name = L["Swipe Overlay Settings"],
    },
    cooldown = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Enable Swipe"],
      order = 11.1,
      desc = L["Enable the \"Swipe\" radial overlay"],
      get = function() return data.cooldown; end
    },
    inverse = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Inverse"],
      order = 11.2,
      desc = L["Invert the direction of progress"],
      get = function() return data.inverse and data.cooldown; end,
      hidden = function() return not data.cooldown end
    },
    cooldownSwipe = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show \"Swipe\""],
      order = 11.3,
      desc = "|TInterface\\AddOns\\WeakAuras\\Media\\Textures\\swipe-example:30|t\n"..L["Enable \"swipe\" part of the overlay"],
      hidden = function() return not data.cooldown end,
    },
    cooldownEdge = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show \"Edge\""],
      order = 11.4,
      desc = "|TInterface\\AddOns\\WeakAuras\\Media\\Textures\\edge-example:30|t\n"..L["Enable \"Edge\" part of the overlay"],
      hidden = function() return not data.cooldown end,
    },
    cooldownTextDisabled = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Hide Timer Text"],
      order = 11.5,
      desc = L["A timer will automatically be displayed according to default Interface Settings (overridden by some addons).\nEnable this setting if you want this timer to be hidden, or when using a WeakAuras text to display the timer"],
      hidden = function() return not data.cooldown end,
    },
    useCooldownModRate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Blizzard Cooldown Reduction"],
      order = 11.6,
      desc = L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."],
      hidden = function() return not data.cooldown end,
    },
    ccWarning = {
      type = "description",
      width = WeakAuras.doubleWidth,
      name = function()
        if OmniCC then
          return L["The addon OmniCC is enabled. It might add cooldown numbers to the swipe. You can configure these in the OmniCC settings"]
        elseif ElvUI then
          return L["The addon ElvUI is enabled. It might add cooldown numbers to the swipe. You can configure these in the ElvUI settings"]
        else
          return L["Cooldown Numbers might be added by WoW. You can configure these in the game settings."]
        end
      end,
      order = 11.7,
      hidden = function() return data.cooldownTextDisabled end
    },
    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  return {
    icon = options,
    progressOptions = OptionsPrivate.commonOptions.ProgressOptions(data),
    position = OptionsPrivate.commonOptions.PositionOptions(id, data),
  };
end

local function createThumbnail()
  ---@class frame: FrameScriptObject
  local frame = CreateFrame("Frame", nil, UIParent)
  local icon = frame:CreateTexture();
  icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");
  icon:SetAllPoints(frame)
  frame.icon = icon
  return frame;
end

local function modifyThumbnail(parent, frame, data)
  local texWidth = 0.25 * data.zoom;
  frame.icon:SetTexCoord(texWidth, 1 - texWidth, texWidth, 1 - texWidth);
  frame:SetParent(parent)

  function frame:SetIcon(path)
    local iconPath
    if data.iconSource == 0 then
      iconPath = data.displayIcon
    else
      iconPath = path or data.displayIcon
    end
    if iconPath and iconPath ~= "" then
      OptionsPrivate.Private.SetTextureOrAtlas(self.icon, iconPath)
    else
      OptionsPrivate.Private.SetTextureOrAtlas(self.icon, "Interface\\Icons\\INV_Misc_QuestionMark")
    end
  end

  if data then
    local name, icon = WeakAuras.GetNameAndIcon(data);
    frame:SetIcon(icon)
  end
end

local templates = {
  {
    title = L["Default"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      cooldown = true,
      inverse = true,
    };
  },
  {
    title = L["Tiny Icon"],
    description = L["A 20x20 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 20,
      height = 20,
      cooldown = true,
      inverse = true,
    };
  },
  {
    title = L["Small Icon"],
    description = L["A 32x32 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 32,
      height = 32,
      cooldown = true,
      inverse = true,
    };
  },
  {
    title = L["Medium Icon"],
    description = L["A 40x40 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 40,
      height = 40,
      cooldown = true,
      inverse = true,
    };
  },
  {
    title = L["Big Icon"],
    description = L["A 48x48 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 48,
      height = 48,
      cooldown = true,
      inverse = true,
    };
  },
  {
    title = L["Huge Icon"],
    description = L["A 64x64 pixels icon"],
    icon = "Interface\\ICONS\\Temp.blp",
    data = {
      width = 64,
      height = 64,
      cooldown = true,
      inverse = true,
    };
  }
}

local anchorPoints = {
  BOTTOMLEFT = {
    display = { L["Edge"], L["Bottom Left"] },
    type = "point"
  },
  BOTTOM = {
    display = { L["Edge"], L["Bottom"] },
    type = "point"
  },
  BOTTOMRIGHT = {
    display = { L["Edge"], L["Bottom Right"] },
    type = "point"
  },
  RIGHT = {
    display = { L["Edge"], L["Right"] },
    type = "point"
  },
  TOPRIGHT = {
    display = { L["Edge"], L["Top Right"] },
    type = "point"
  },
  TOP = {
    display = { L["Edge"], L["Top"] },
    type = "point"
  },
  TOPLEFT = {
    display = { L["Edge"], L["Top Left"] },
    type = "point"
  },
  LEFT = {
    display = { L["Edge"], L["Left"] },
    type = "point"
  },
  CENTER = {
    display = L["Center"],
    type = "point"
  },
  INNER_BOTTOMLEFT = {
    display = { L["Inner"], L["Bottom Left"] },
    type = "point"
  },
  INNER_BOTTOM = {
    display = { L["Inner"], L["Bottom"] },
    type = "point"
  },
  INNER_BOTTOMRIGHT = {
    display = { L["Inner"], L["Bottom Right"] },
    type = "point"
  },
  INNER_RIGHT = {
    display = { L["Inner"], L["Right"] },
    type = "point"
  },
  INNER_TOPRIGHT = {
    display = { L["Inner"], L["Top Right"] },
    type = "point"
  },
  INNER_TOP = {
    display = { L["Inner"], L["Top"] },
    type = "point"
  },
  INNER_TOPLEFT = {
    display = { L["Inner"], L["Top Left"] },
    type = "point"
  },
  INNER_LEFT = {
    display = { L["Inner"], L["Left"] },
    type = "point"
  },
  OUTER_BOTTOMLEFT = {
    display = { L["Outer"], L["Bottom Left"] },
    type = "point"
  },
  OUTER_BOTTOM = {
    display = { L["Outer"], L["Bottom"] },
    type = "point"
  },
  OUTER_BOTTOMRIGHT = {
    display = { L["Outer"], L["Bottom Right"] },
    type = "point"
  },
  OUTER_RIGHT = {
    display = { L["Outer"], L["Right"] },
    type = "point"
  },
  OUTER_TOPRIGHT = {
    display = { L["Outer"], L["Top Right"] },
    type = "point"
  },
  OUTER_TOP = {
    display = { L["Outer"], L["Top"] },
    type = "point"
  },
  OUTER_TOPLEFT = {
    display = { L["Outer"], L["Top Left"] },
    type = "point"
  },
  OUTER_LEFT = {
    display = { L["Outer"], L["Left"] },
    type = "point"
  },
  ALL = {
    display = L["Whole Area"],
    type = "area"
  }
}

local function GetAnchors(data)
  return anchorPoints;
end

OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("icon", createOptions, "interface\\icons\\spell_holy_sealofsalvation.blp", L["Icon"],
                                  createThumbnail, modifyThumbnail,
                                  L["Shows a spell icon with an optional cooldown overlay"],
                                  templates, GetAnchors);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/Icon.lua ===


=== FILE: WeakAurasOptions/RegionOptions/Model.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function createOptions(id, data)
  local options = {
    __title = L["Model Settings"],
    __order = 1,
    modelIsUnit = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show model of unit "],
      order = 0.5,
      hidden = function() return data.modelDisplayInfo and WeakAuras.BuildInfo > 80100 end
    },
    modelDisplayInfo = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Use Display Info Id"],
      order = 0.6,
      hidden = function() return data.modelIsUnit end
    },
    model_fileId = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Model"],
      order = 1
    },
    chooseModel = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 2,
      func = function()
        OptionsPrivate.OpenModelPicker(data, {});
      end,
      disabled = function() return data.modelIsUnit or (WeakAuras.BuildInfo > 80100 and data.modelDisplayInfo) end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    advance = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Animate"],
      order = 5,
    },
    sequence = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Animation Sequence"],
      min = 0,
      softMax = 1499,
      step = 1,
      bigStep = 1,
      order = 6,
      disabled = function() return not data.advance end
    },
    api = {
      type = "toggle",
      name = L["Use SetTransform"],
      order = 7,
      width = WeakAuras.normalWidth,
    },
    portraitZoom = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Portrait Zoom"],
      order = 8,
    },
    -- old settings
    model_z = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Z Offset"],
      softMin = -20,
      softMax = 20,
      step = .001,
      bigStep = 0.05,
      order = 20,
      hidden = function() return data.api end
    },
    model_x = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["X Offset"],
      softMin = -20,
      softMax = 20,
      step = .001,
      bigStep = 0.05,
      order = 30,
      hidden = function() return data.api end
    },
    model_y = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y Offset"],
      softMin = -20,
      softMax = 20,
      step = .001,
      bigStep = 0.05,
      order = 40,
      hidden = function() return data.api end
    },
    rotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 45,
      hidden = function() return data.api end
    },
    -- New Settings
    model_st_tx = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["X Offset"],
      softMin = -1000,
      softMax = 1000,
      step = 1,
      bigStep = 5,
      order = 20,
      hidden = function() return not data.api end
    },
    model_st_ty = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y Offset"],
      softMin = -1000,
      softMax = 1000,
      step = 1,
      bigStep = 5,
      order = 21,
      hidden = function() return not data.api end
    },
    model_st_tz = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Z Offset"],
      softMin = -1000,
      softMax = 1000,
      step = 1,
      bigStep = 5,
      order = 22,
      hidden = function() return not data.api end
    },
    model_st_rx = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["X Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 23,
      hidden = function() return not data.api end
    },
    model_st_ry = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 24,
      hidden = function() return not data.api end
    },
    model_st_rz = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Z Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 25,
      hidden = function() return not data.api end
    },
    model_st_us = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Scale"],
      min = 5,
      max = 1000,
      step = 0.1,
      bigStep = 5,
      order = 26,
      hidden = function() return not data.api end
    },
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Alpha"],
      order = 50,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    },
    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  for k, v in pairs(OptionsPrivate.commonOptions.BorderOptions(id, data, nil, nil, 70)) do
    options[k] = v
  end

  return {
    model = options,
    position = OptionsPrivate.commonOptions.PositionOptions(id, data, nil, nil, nil),
  };
end

-- Duplicated because Private does not exist when we want to create the first thumbnail
local function ModelSetTransformFixed(self, tx, ty, tz, rx, ry, rz, s)
  -- In Dragonflight the api changed, this converts to the new api
  self:SetTransform(CreateVector3D(tx, ty, tz), CreateVector3D(rx, ry, rz), -s)
end

local function createThumbnail()
    ---@class frame
  local borderframe = CreateFrame("Frame", nil, UIParent);
  borderframe:SetWidth(32);
  borderframe:SetHeight(32);

  local border = borderframe:CreateTexture(nil, "Overlay");
  border:SetAllPoints(borderframe);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  ---@class Model
  local model = CreateFrame("PlayerModel", nil, borderframe);
  borderframe.model = model;
  model.SetTransformFixed = ModelSetTransformFixed
  model:SetFrameStrata("FULLSCREEN");

  return borderframe;
end

local function modifyThumbnail(parent, region, data)
  region:SetParent(parent)

  local model = region.model

  model:SetAllPoints(region);
  model:SetFrameStrata(region:GetParent():GetFrameStrata());
  model:SetWidth(region:GetWidth() - 2);
  model:SetHeight(region:GetHeight() - 2);
  model:SetPoint("center", region, "center");
  WeakAuras.SetModel(model, nil, data.model_fileId, data.modelIsUnit, data.modelDisplayInfo)
  model:SetScript("OnShow", function()
    WeakAuras.SetModel(model, nil, data.model_fileId, data.modelIsUnit, data.modelDisplayInfo)
    model:SetPortraitZoom(data.portraitZoom and 1 or 0)
    if data.api then
      model:SetTransformFixed(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
        rad(data.model_st_rx), rad(data.model_st_ry), rad(data.model_st_rz),
        data.model_st_us / 1000);
    else
      model:ClearTransform();
      model:SetPosition(data.model_z, data.model_x, data.model_y);
      model:SetFacing(rad(data.rotation));
    end
  end);

  if data.api then
    model:SetTransformFixed(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
      rad(data.model_st_rx), rad(data.model_st_ry), rad(data.model_st_rz),
      data.model_st_us / 1000);
  else
    model:SetPosition(data.model_z, data.model_x, data.model_y);
    model:SetFacing(rad(data.rotation));
  end
end

local function createIcon()
  local data = {
    model_fileId = WeakAuras.IsClassic() and "165589" or "122968", -- spells/arcanepower_state_chest.m2 & Creature/Arthaslichking/arthaslichking.m2
    modelIsUnit = false,
    model_x = 0,
    model_y = 0,
    model_z = 0.35,
    sequence = 1,
    advance = false,
    rotation = 0,
    scale = 1,
    height = 40,
    width = 40
  };

  local thumbnail = createThumbnail();
  modifyThumbnail(UIParent, thumbnail, data);

  return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    data = {
    };
  }
}

if WeakAuras.IsRetail() then
  tinsert(templates, {
    title = L["Fire Orb"],
    description = "",
    data = {
      width = 100,
      height = 100,
      model_fileId = "937416", -- spells/6fx_smallfire.m2
      model_x = 0,
      model_y = -0.5,
      model_z = -1.5
    },
  })
  tinsert(templates, {
    title = L["Blue Sparkle Orb"],
    description = "",
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_fileId = "1322288", -- spells/7fx_druid_halfmoon_missile.m2
      model_x = 0,
      model_y = 0.7,
      model_z = 1.5
    },
  })
  tinsert(templates, {
    title = L["Arcane Orb"],
    description = "",
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_fileId = "1042743", -- spells/proc_arcane_impact_low.m2
      model_x = 0,
      model_y = 0.8,
      model_z = 2
    },
  })
  tinsert(templates, {
    title = L["Orange Rune"],
    description = "",
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_fileId = "1307356", -- spells/7fx_godking_orangerune_state.m2
    },
  })
  tinsert(templates, {
    title = L["Blue Rune"],
    description = "",
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_fileId = "1307354", -- spells/7fx_godking_bluerune_state.m2
    }
  })
  tinsert(templates, {
    title = L["Yellow Rune"],
    description = "",
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_fileId = "1307358", -- spells/7fx_godking_yellowrune_state.m2
    }
  })
  tinsert(templates, {
    title = L["Purple Rune"],
    description = "",
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_fileId = "1307355", -- spells/7fx_godking_purplerune_state.m2
    }
  })
  tinsert(templates, {
    title = L["Green Rune"],
    description = "",
    data = {
      width = 100,
      height = 100,
      advance = true,
      sequence = 1,
      model_fileId = "1307357", -- spells/7fx_godking_greenrune_state.m2
    }
  })
end

OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("model", createOptions, createIcon, L["Model"], createThumbnail, modifyThumbnail,
                                  L["Shows a 3D model from the game files"], templates);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/Model.lua ===


=== FILE: WeakAurasOptions/RegionOptions/ProgressTexture.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;
local GetAtlasInfo = WeakAuras.IsClassicEra() and GetAtlasInfo or C_Texture.GetAtlasInfo

local function createOptions(id, data)
  local options = {
    __title = L["Progress Texture Settings"],
    __order = 1,
    foregroundTexture = {
      width = WeakAuras.normalWidth - 0.15,
      type = "input",
      name = L["Foreground Texture"],
      order = 1
    },
    chooseForegroundTexture = {
      type = "execute",
      name = L["Choose"],
      width = 0.15,
      order = 2,
      func = function()
        local path = {}
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(data, paths, {
          texture = "foregroundTexture",
          color = "foregroundColor",
          texRotation = "rotation",
          auraRotation = "auraRotation",
          mirror = "mirror",
          blendMode = "blendMode"
        }, OptionsPrivate.Private.texture_types, nil, true)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    backgroundTexture = {
      type = "input",
      width = WeakAuras.normalWidth - 0.15,
      name = L["Background Texture"],
      order = 5,
      disabled = function() return data.sameTexture; end,
      get = function() return data.sameTexture and data.foregroundTexture or data.backgroundTexture; end
    },
    chooseBackgroundTexture = {
      type = "execute",
      name = L["Choose"],
      width = 0.15,
      order = 6,
      func = function()
        local path = {}
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(data, paths, {
          texture = "backgroundTexture",
          color = "backgroundColor",
          texRotation = "rotation",
          auraRotation = "auraRotation",
          mirror = "mirror",
          blendMode = "blendMode"
        }, OptionsPrivate.Private.texture_types, nil, true)
      end,
      disabled = function() return data.sameTexture; end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    mirror = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Mirror"],
      order = 10,
      disabled = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
    },
    sameTexture = {
      type = "toggle",
      name = L["Same"],
      width = WeakAuras.normalWidth,
      order = 15
    },
    desaturateForeground = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 17.5,
    },
    desaturateBackground = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 17.6,
    },
    blendMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 20,
      values = OptionsPrivate.Private.blend_types
    },
    backgroundOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Background Offset"],
      min = 0,
      softMax = 25,
      bigStep = 1,
      order = 25
    },
    orientation = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Orientation"],
      order = 35,
      values = OptionsPrivate.Private.orientation_with_circle_types
    },
    compress = {
      type = "toggle",
      width = WeakAuras.halfWidth,
      name = L["Compress"],
      order = 40,
      disabled = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
    },
    inverse = {
      type = "toggle",
      width = WeakAuras.halfWidth,
      name = L["Inverse"],
      order = 41
    },
    foregroundColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Foreground Color"],
      hasAlpha = true,
      order = 30
    },
    backgroundColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Background Color"],
      hasAlpha = true,
      order = 37
    },
    user_x = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 42,
      name = L["Re-center X"],
      min = -0.5,
      max = 0.5,
      bigStep = 0.01,
      hidden = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
    },
    user_y = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 44,
      name = L["Re-center Y"],
      min = -0.5,
      max = 0.5,
      bigStep = 0.01,
      hidden = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
    },
    startAngle = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 42,
      name = L["Start Angle"],
      min = 0,
      max = 360,
      bigStep = 1,
      hidden = function() return data.orientation ~= "CLOCKWISE" and data.orientation ~= "ANTICLOCKWISE"; end
    },
    endAngle = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 44,
      name = L["End Angle"],
      min = 0,
      max = 360,
      bigStep = 1,
      hidden = function() return data.orientation ~= "CLOCKWISE" and data.orientation ~= "ANTICLOCKWISE"; end
    },
    crop_x = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Crop X"],
      order = 46,
      min = 0,
      softMax = 2,
      bigStep = 0.01,
      isPercent = true,
      set = function(info, v)
        data.width = data.width * ((1 + data.crop_x) / (1 + v));
        data.crop_x = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
      end,
    },
    crop_y = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Crop Y"],
      order = 47,
      min = 0,
      softMax = 2,
      bigStep = 0.01,
      isPercent = true,
      set = function(info, v)
        data.height = data.height * ((1 + data.crop_y) / (1 + v));
        data.crop_y = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
      end,
    },
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Alpha"],
      order = 48,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    },
    rotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Texture Rotation"],
      desc = L["Uses Texture Coordinates to rotate the texture."],
      order = 52,
      min = 0,
      max = 360,
      bigStep = 1
    },
    auraRotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      order = 53,
      min = 0,
      max = 360,
      bigStep = 1
    },
    smoothProgress = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Smooth Progress"],
      desc = L["Animates progress changes"],
      order = 55.1
    },
    textureWrapMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Texture Wrap"],
      order = 55.2,
      values = OptionsPrivate.Private.texture_wrap_types
    },
    slanted = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Slanted"],
      order = 55.3,
      hidden = function() return data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE"; end
    },
    slant = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Slant Amount"],
      order = 55.4,
      min = 0,
      max = 1,
      bigStep = 0.1,
      hidden = function() return not data.slanted or data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE" end
    },
    slantFirst = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Inverse Slant"],
      order = 55.5,
      hidden = function() return not data.slanted or data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE" end
    },
    slantMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Slant Mode"],
      order = 55.6,
      hidden = function() return not data.slanted or data.orientation == "CLOCKWISE" or data.orientation == "ANTICLOCKWISE" end,
      values = OptionsPrivate.Private.slant_mode
    },
    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  local overlayInfo = OptionsPrivate.Private.GetOverlayInfo(data);
  if (overlayInfo and next(overlayInfo)) then
    options["overlayheader"] = {
      type = "header",
      name = L["Overlays"],
      order = 58
    }
    local index = 58.01
    for id, display in ipairs(overlayInfo) do
      options["overlaycolor" .. id] = {
        type = "color",
        width = WeakAuras.normalWidth,
        name = string.format(L["%s Color"], display),
        hasAlpha = true,
        order = index,
        get = function()
          if (data.overlays and data.overlays[id]) then
            return unpack(data.overlays[id]);
          end
          return 1, 1, 1, 1;
        end,
        set = function(info, r, g, b, a)
          if (not data.overlays) then
            data.overlays = {};
          end
          data.overlays[id] = { r, g, b, a};
          WeakAuras.Add(data);
        end
      }
      index = index + 0.01
    end

    options["overlayclip"] = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Clip Overlays"],
      order = index
    }
  end

  return {
    progresstexture = options,
    progressOptions = OptionsPrivate.commonOptions.ProgressOptions(data),
    position = OptionsPrivate.commonOptions.PositionOptions(id, data),
  };
end

-- Credit to CommanderSirow for taking the time to properly craft the ApplyTransform function
-- to the enhance the abilities of Progress Textures.

-- NOTES:
--  Most SetValue() changes are quite equal (among compress/non-compress)
--  (There is no GUI button for mirror_v, but mirror_h)
--  New/Used variables
--   region.user_x (0) - User defined center x-shift [-1, 1]
--   region.user_y (0) - User defined center y-shift [-1, 1]
--   region.mirror_v (false) - Mirroring along x-axis [bool]
--   region.mirror_h (false) - Mirroring along y-axis [bool]
--   region.cos_rotation (1) - cos(ANGLE), precalculated cos-function for given ANGLE [-1, 1]
--   region.sin_rotation (0) - sin(ANGLE), precalculated cos-function for given ANGLE [-1, 1]
--   region.scale (1.0) - user defined scaling [1, INF]
--   region.full_rotation (false) - Allow full rotation [bool]


local function ApplyTransform(x, y, region)
  -- 1) Translate texture-coords to user-defined center
  x = x - 0.5
  y = y - 0.5

  -- 2) Shrink texture by 1/sqrt(2)
  x = x * 1.4142
  y = y * 1.4142

  -- 3) Scale texture by user-defined amount
  x = x / region.scale_x
  y = y / region.scale_y

  -- 4) Apply mirroring if defined
  if region.mirror_h then
    x = -x
  end
  if region.mirror_v then
    y = -y
  end

  -- 5) Rotate texture by user-defined value
  x, y = region.cos_rotation * x - region.sin_rotation * y, region.sin_rotation * x + region.cos_rotation * y

  -- 6) Translate texture-coords back to (0,0)
  x = x + 0.5 + region.user_x
  y = y + 0.5 + region.user_y

  -- Return results
  return x, y
end

local function Transform(tx, x, y, angle, aspect) -- Translates texture to x, y and rotates about its center
  local c, s = cos(angle), sin(angle)
  y = y / aspect
  local oy = 0.5 / aspect
  local ULx, ULy = 0.5 + (x - 0.5) * c - (y - oy) * s, (oy + (y - oy) * c + (x - 0.5) * s) * aspect
  local LLx, LLy = 0.5 + (x - 0.5) * c - (y + oy) * s, (oy + (y + oy) * c + (x - 0.5) * s) * aspect
  local URx, URy = 0.5 + (x + 0.5) * c - (y - oy) * s, (oy + (y - oy) * c + (x + 0.5) * s) * aspect
  local LRx, LRy = 0.5 + (x + 0.5) * c - (y + oy) * s, (oy + (y + oy) * c + (x + 0.5) * s) * aspect
  tx:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy)
end

local function createThumbnail()
  local borderframe = CreateFrame("Frame", nil, UIParent);
  borderframe:SetWidth(32);
  borderframe:SetHeight(32);

  local border = borderframe:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(borderframe);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  local region = CreateFrame("Frame", nil, borderframe);
  borderframe.region = region;
  region:SetWidth(32);
  region:SetHeight(32);

  local background = region:CreateTexture(nil, "BACKGROUND");
  borderframe.background = background;

  local foreground = region:CreateTexture(nil, "ARTWORK");
  borderframe.foreground = foreground;

  local OrgSetTexture = foreground.SetTexture;
  -- WORKAROUND, setting the same texture with a different wrap mode does not change the wrap mode
  foreground.SetTexture = function(self, texture, horWrapMode, verWrapMode)
    if (GetAtlasInfo(texture)) then
      self:SetAtlas(texture);
    else
      local needToClear = (self.horWrapMode and self.horWrapMode ~= horWrapMode) or (self.verWrapMode and self.verWrapMode ~= verWrapMode);
      self.horWrapMode = horWrapMode;
      self.verWrapMode = verWrapMode;
      if (needToClear) then
        OrgSetTexture(self, nil);
      end
      OrgSetTexture(self, texture, horWrapMode, verWrapMode);
    end
  end
  background.SetTexture = foreground.SetTexture;

  borderframe.backgroundSpinner = OptionsPrivate.Private.CircularProgressTextureBase.create(region, "BACKGROUND", 1)
  borderframe.foregroundSpinner = OptionsPrivate.Private.CircularProgressTextureBase.create(region, "ARTWORK", 1)

  return borderframe;
end

local function modifyThumbnail(parent, borderframe, data, fullModify, size)
  local region, background, foreground = borderframe.region, borderframe.background, borderframe.foreground;
  local foregroundSpinner, backgroundSpinner = borderframe.foregroundSpinner, borderframe.backgroundSpinner;

  size = size or 30;
  local scale;
  if(data.height > data.width) then
    scale = size/data.height;
    region:SetWidth(scale * data.width);
    region:SetHeight(size);
    foreground:SetWidth(scale * data.width);
    foreground:SetHeight(size);
    region.width = scale * data.width;
    region.height = size;
  else
    scale = size/data.width;
    region:SetWidth(size);
    region:SetHeight(scale * data.height);
    foreground:SetWidth(size);
    foreground:SetHeight(scale * data.height);
    region.width = size;
    region.height = scale * data.height;
  end

  region:ClearAllPoints();
  region:SetPoint("CENTER", borderframe, "CENTER");

  background:SetTexture(data.sameTexture and data.foregroundTexture or data.backgroundTexture);
  background:SetDesaturated(data.desaturateBackground)
  background:SetVertexColor(data.backgroundColor[1], data.backgroundColor[2], data.backgroundColor[3], data.backgroundColor[4]);
  background:SetBlendMode(data.blendMode);

  backgroundSpinner:SetTextureOrAtlas(data.sameTexture and data.foregroundTexture or data.backgroundTexture);
  backgroundSpinner:SetDesaturated(data.desaturateBackground)
  backgroundSpinner:SetColor(data.backgroundColor[1], data.backgroundColor[2], data.backgroundColor[3], data.backgroundColor[4]);
  backgroundSpinner:SetBlendMode(data.blendMode);

  foreground:SetTexture(data.foregroundTexture);
  foreground:SetVertexColor(data.foregroundColor[1], data.foregroundColor[2], data.foregroundColor[3], data.foregroundColor[4]);
  foreground:SetBlendMode(data.blendMode);

  foregroundSpinner:SetTextureOrAtlas(data.foregroundTexture);
  foregroundSpinner:SetDesaturated(data.desaturateForeground);
  foregroundSpinner:SetColor(data.foregroundColor[1], data.foregroundColor[2], data.foregroundColor[3], data.foregroundColor[4])
  foregroundSpinner:SetBlendMode(data.blendMode);

  background:ClearAllPoints();
  foreground:ClearAllPoints();
  background:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT");
  background:SetPoint("TOPRIGHT", region, "TOPRIGHT");

  region.mirror_h = data.mirror;
  region.scale_x = 1 + (data.crop_x or 0.41);
  region.scale_y = 1 + (data.crop_y or 0.41);
  region.texRotation = data.rotation or 0
  region.auraRotation = data.auraRotation or 0
  region.cos_rotation = cos(region.texRotation)
  region.sin_rotation = sin(region.texRotation)
  region.user_x = -1 * (data.user_x or 0);
  region.user_y = data.user_y or 0;
  region.aspect = 1;

  local function orientHorizontal()
    foreground:ClearAllPoints();
    foreground:SetPoint("LEFT", region, "LEFT");
    region.orientation = "HORIZONTAL_INVERSE";
    if(data.compress) then
      function region:SetValue(progress)
        region.progress = progress;

        local ULx, ULy = ApplyTransform(0, 0, region)
        local LLx, LLy = ApplyTransform(0, 1, region)
        local URx, URy = ApplyTransform(1, 0, region)
        local LRx, LRy = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        foreground:SetWidth(region:GetWidth() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    else
      function region:SetValue(progress)
        region.progress = progress;

        local ULx , ULy  = ApplyTransform(0, 0, region)
        local LLx , LLy  = ApplyTransform(0, 1, region)
        local URx , URy  = ApplyTransform(progress, 0, region)
        local URx_, URy_ = ApplyTransform(1, 0, region)
        local LRx , LRy  = ApplyTransform(progress, 1, region)
        local LRx_, LRy_ = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx , URy , LRx , LRy );
        foreground:SetWidth(region:GetWidth() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx, ULy, LLx, LLy, URx_, URy_, LRx_, LRy_);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    end
  end
  local function orientHorizontalInverse()
    foreground:ClearAllPoints();
    foreground:SetPoint("RIGHT", region, "RIGHT");
    region.orientation = "HORIZONTAL";
    if(data.compress) then
      function region:SetValue(progress)
        region.progress = progress;

        local ULx, ULy = ApplyTransform(0, 0, region)
        local LLx, LLy = ApplyTransform(0, 1, region)
        local URx, URy = ApplyTransform(1, 0, region)
        local LRx, LRy = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        foreground:SetWidth(region:GetWidth() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    else
      function region:SetValue(progress)
        region.progress = progress;

        local ULx , ULy  = ApplyTransform(1-progress, 0, region)
        local ULx_, ULy_ = ApplyTransform(0, 0, region)
        local LLx , LLy  = ApplyTransform(1-progress, 1, region)
        local LLx_, LLy_ = ApplyTransform(0, 1, region)
        local URx , URy  = ApplyTransform(1, 0, region)
        local LRx , LRy  = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx , ULy , LLx , LLy , URx, URy, LRx, LRy);
        foreground:SetWidth(region:GetWidth() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx_, ULy_, LLx_, LLy_, URx, URy, LRx, LRy);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    end
  end
  local function orientVertical()
    foreground:ClearAllPoints();
    foreground:SetPoint("BOTTOM", region, "BOTTOM");
    region.orientation = "VERTICAL_INVERSE";
    if(data.compress) then
      function region:SetValue(progress)
        region.progress = progress;


        local ULx, ULy = ApplyTransform(0, 0, region)
        local LLx, LLy = ApplyTransform(0, 1, region)
        local URx, URy = ApplyTransform(1, 0, region)
        local LRx, LRy = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        foreground:SetHeight(region:GetHeight() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    else
      function region:SetValue(progress)
        region.progress = progress;

        local ULx , ULy  = ApplyTransform(0, 1-progress, region)
        local ULx_, ULy_ = ApplyTransform(0, 0, region)
        local LLx , LLy  = ApplyTransform(0, 1, region)
        local URx , URy  = ApplyTransform(1, 1-progress, region)
        local URx_, URy_ = ApplyTransform(1, 0, region)
        local LRx , LRy  = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        foreground:SetHeight(region:GetHeight() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx_, ULy_, LLx, LLy, URx_, URy_, LRx, LRy);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    end
  end
  local function orientVerticalInverse()
    foreground:ClearAllPoints();
    foreground:SetPoint("TOP", region, "TOP");
    region.orientation = "VERTICAL";
    if(data.compress) then
      function region:SetValue(progress)
        region.progress = progress;


        local ULx, ULy = ApplyTransform(0, 0, region)
        local LLx, LLy = ApplyTransform(0, 1, region)
        local URx, URy = ApplyTransform(1, 0, region)
        local LRx, LRy = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        foreground:SetHeight(region:GetHeight() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    else
      function region:SetValue(progress)
        region.progress = progress;

        local ULx , ULy  = ApplyTransform(0, 0, region)
        local LLx , LLy  = ApplyTransform(0, progress, region)
        local LLx_, LLy_ = ApplyTransform(0, 1, region)
        local URx , URy  = ApplyTransform(1, 0, region)
        local LRx , LRy  = ApplyTransform(1, progress, region)
        local LRx_, LRy_ = ApplyTransform(1, 1, region)

        foreground:SetTexCoord(ULx, ULy, LLx, LLy, URx, URy, LRx, LRy);
        foreground:SetHeight(region:GetHeight() * progress);
        foreground:SetRotation(region.auraRotation / 180 * math.pi)
        background:SetTexCoord(ULx, ULy, LLx_, LLy_, URx, URy, LRx_, LRy_);
        background:SetRotation(region.auraRotation / 180 * math.pi)
      end
    end
  end

  local function orientCircular(clockwise)
    local startAngle = data.startAngle % 360;
    local endAngle = data.endAngle % 360;

    if (endAngle <= startAngle) then
      endAngle = endAngle + 360;
    end

    backgroundSpinner:SetWidth(30)
    backgroundSpinner:SetHeight(30)
    foregroundSpinner:SetWidth(30)
    foregroundSpinner:SetHeight(30)
    backgroundSpinner:SetProgress(startAngle, endAngle);
    foregroundSpinner:SetProgress(startAngle, endAngle);

    function region:SetValue(progress)
      region.progress = progress;

      if (progress < 0) then
        progress = 0;
      end

      if (progress > 1) then
        progress = 1;
      end

      if (not clockwise) then
        progress = 1 - progress;
      end

      local pAngle = (endAngle - startAngle) * progress + startAngle;

      if (clockwise) then
        foregroundSpinner:SetProgress(startAngle, pAngle);
      else
        foregroundSpinner:SetProgress(pAngle, endAngle);
      end
    end
  end

  local function showCircularProgress()
    foreground:Hide();
    background:Hide();
    foregroundSpinner:Show();
    backgroundSpinner:Show();
  end

  local function hideCircularProgress()
    foreground:Show();
    background:Show();
    foregroundSpinner:Hide();
    backgroundSpinner:Hide();
  end

  if(data.orientation == "HORIZONTAL_INVERSE") then
    hideCircularProgress();
    orientHorizontalInverse();
  elseif(data.orientation == "HORIZONTAL") then
    hideCircularProgress();
    orientHorizontal();
  elseif(data.orientation == "VERTICAL_INVERSE") then
    hideCircularProgress();
    orientVerticalInverse();
  elseif(data.orientation == "VERTICAL") then
    hideCircularProgress();
    orientVertical();
  elseif(data.orientation == "CLOCKWISE") then
    showCircularProgress();
    orientCircular(true);
  elseif(data.orientation == "ANTICLOCKWISE") then
    showCircularProgress();
    orientCircular(false);
  end

  if (region.SetValue) then
    region:SetValue(3/5);
  end
end

local function createIcon()
  local data = {
    foregroundTexture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura3",
    backgroundTexture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura3",
    sameTexture = true,
    backgroundOffset = 2,
    blendMode = "BLEND",
    width = 200,
    height = 200,
    orientation = "VERTICAL",
    alpha = 1.0,
    foregroundColor = {1, 1, 1, 1},
    backgroundColor = {0.5, 0.5, 0.5, 0.5}
  };

  local thumbnail = createThumbnail();
  modifyThumbnail(UIParent, thumbnail, data, nil, 32);

  thumbnail.elapsed = 0;
  thumbnail:SetScript("OnUpdate", function(self, elapsed)
    thumbnail.elapsed = thumbnail.elapsed + elapsed;
    if(thumbnail.elapsed > 4) then
      thumbnail.elapsed = thumbnail.elapsed - 4;
    end
    thumbnail.region:SetValue((4 - thumbnail.elapsed) / 4);
  end);

  return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    data = {
      inverse = true,
    };
  },
  {
    title = L["Top HUD position"],
    description = L["At the same position as Blizzard's spell alert"],
    data = {
      width = 200,
      height = 100,
      xOffset = 0,
      yOffset = 150,
      mirror = true,
      foregroundTexture = "460830", -- "Textures\\SpellActivationOverlays\\Backlash"
      orientation = "HORIZONTAL",
      inverse = true,
    },
  },
  {
    title = L["Left HUD position"],
    description = L["At the same position as Blizzard's spell alert"],
    data = {
      width = 100,
      height = 200,
      xOffset = -150,
      yOffset = 0,
      inverse = true,
    },
  },
  {
    title = L["Left 2 HUD position"],
    description = L["At a position a bit left of Left HUD position."],
    data = {
      width = 100,
      height = 200,
      xOffset = -200,
      yOffset = 0,
      inverse = true,
    },
  },
  {
    title = L["Right HUD position"],
    description = L["At the same position as Blizzard's spell alert"],
    data = {
      width = 100,
      height = 200,
      xOffset = 150,
      yOffset = 0,
      mirror = true,
      inverse = true,
    },
  },
  {
    title = L["Right 2 HUD position"],
    description = L["At a position a bit left of Right HUD position"],
    data = {
      width = 100,
      height = 200,
      xOffset = 200,
      yOffset = 0,
      mirror = true,
      inverse = true,
    },
  },
}

if WeakAuras.IsClassicEra() then
  table.remove(templates, 2)
end

OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("progresstexture", createOptions, createIcon, L["Progress Texture"], createThumbnail, modifyThumbnail, L["Shows a texture that changes based on duration"], templates);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/ProgressTexture.lua ===


=== FILE: WeakAurasOptions/RegionOptions/StopMotion.lua ===
local L = WeakAuras.L
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local texture_types = WeakAuras.StopMotion.texture_types;
local texture_data = WeakAuras.StopMotion.texture_data;
local animation_types = WeakAuras.StopMotion.animation_types;

-- Returns value only for Blizzard flipbooks
function OptionsPrivate.GetFlipbookTileSize(name)
  if texture_data[name] then
    if texture_data[name].isBlizzardFlipbook then
      if texture_data[name].tileWidth and texture_data[name].tileHeight then
        return {["tileWidth"] = texture_data[name].tileWidth, ["tileHeight"] = texture_data[name].tileHeight}
      end
    end
  end
end

local function createOptions(id, data)
    local textureNameHasData = OptionsPrivate.Private.StopMotionBase.textureNameHasData
    local setTextureFunc = OptionsPrivate.Private.StopMotionBase.setTextureFunc
    local options = {
        __title = L["Stop Motion Settings"],
        __order = 1,
        foregroundTexture = {
            type = "input",
            width = WeakAuras.doubleWidth - 0.15,
            name = L["Texture"],
            order = 1,
        },
        chooseForegroundTexture = {
            type = "execute",
            width = 0.15,
            name = L["Choose"],
            order = 2,
            func = function()
                local path = {}
                local paths = {}
                for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
                  paths[child.id] = path
                end
                OptionsPrivate.OpenTexturePicker(data, paths, {
                  texture = "foregroundTexture",
                  color = "foregroundColor",
                  mirror = "mirror",
                  blendMode = "blendMode"
                }, texture_types, setTextureFunc, true);
            end,
            imageWidth = 24,
            imageHeight = 24,
            control = "WeakAurasIcon",
            image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
        },
        foregroundColor = {
          type = "color",
          width = WeakAuras.normalWidth,
          name = L["Color"],
          hasAlpha = true,
          order = 3
        },
        desaturateForeground = {
          type = "toggle",
          width = WeakAuras.normalWidth,
          name = L["Desaturate"],
          order = 3.5,
        },
        customForegroundRows = {
            type = "input",
            width = WeakAuras.doubleWidth / 3,
            name = L["Rows"],
            validate = WeakAuras.ValidateNumeric,
            get = function()
              return data.customForegroundRows and tostring(data.customForegroundRows) or "";
            end,
            set = function(info, v)
              data.customForegroundRows = v and tonumber(v) or 0
              WeakAuras.Add(data);
              WeakAuras.UpdateThumbnail(data);
            end,
            order = 4,
            hidden = function()
              return texture_data[data.foregroundTexture] or textureNameHasData(data.foregroundTexture)
            end
        },
        customForegroundColumns = {
            type = "input",
            width = WeakAuras.doubleWidth / 3,
            name = L["Columns"],
            validate = WeakAuras.ValidateNumeric,
            get = function()
              return data.customForegroundColumns and tostring(data.customForegroundColumns) or "";
            end,
            set = function(info, v)
              data.customForegroundColumns = v and tonumber(v) or 0
              WeakAuras.Add(data);
              WeakAuras.UpdateThumbnail(data);
            end,
            order = 5,
            hidden = function()
              return texture_data[data.foregroundTexture] or textureNameHasData(data.foregroundTexture)
            end
        },
        customForegroundFrames = {
            type = "input",
            width = WeakAuras.doubleWidth / 3,
            name = L["Frame Count"],
            validate = WeakAuras.ValidateNumeric,
            get = function()
              return data.customForegroundFrames and tostring(data.customForegroundFrames) or "";
            end,
            set = function(info, v)
              data.customForegroundFrames = v and tonumber(v) or 0
              WeakAuras.Add(data);
              WeakAuras.UpdateThumbnail(data);
            end,
            order = 6,
            hidden = function()
              return texture_data[data.foregroundTexture] or textureNameHasData(data.foregroundTexture)
            end
        },
        customForegroundFileWidth = {
          type = "input",
          width = WeakAuras.normalWidth / 2,
          name = L["File Width"],
          desc = L["Must be a power of 2"],
          validate = function(info, val)
            if val ~= nil and val ~= "" and (not tonumber(val) or tonumber(val) >= 2^31 or math.frexp(val) ~= 0.5) then
              return false;
            end
            return true
          end,
          get = function()
            return data.customForegroundFileWidth and tostring(data.customForegroundFileWidth) or "";
          end,
          set = function(info, v)
            data.customForegroundFileWidth = v and tonumber(v) or 0
            WeakAuras.Add(data);
            WeakAuras.UpdateThumbnail(data);
          end,
          order = 7,
          hidden = function()
            return texture_data[data.foregroundTexture] or textureNameHasData(data.foregroundTexture)
          end
        },
        customForegroundFileHeight = {
          type = "input",
          width = WeakAuras.normalWidth / 2,
          name = L["File Height"],
          desc = L["Must be a power of 2"],
          validate = function(info, val)
            if val ~= nil and val ~= "" and (not tonumber(val) or tonumber(val) >= 2^31 or math.frexp(val) ~= 0.5) then
              return false;
            end
            return true
          end,
          get = function()
            return data.customForegroundFileHeight and tostring(data.customForegroundFileHeight) or "";
          end,
          set = function(info, v)
            data.customForegroundFileHeight = v and tonumber(v) or 0
            WeakAuras.Add(data);
            WeakAuras.UpdateThumbnail(data);
          end,
          order = 8,
          hidden = function()
            return texture_data[data.foregroundTexture] or textureNameHasData(data.foregroundTexture)
          end
        },
        customForegroundFrameWidth = {
          type = "input",
          width = WeakAuras.normalWidth / 2,
          name = L["Frame Width"],
          validate = WeakAuras.ValidateNumeric,
          desc = L["Can set to 0 if Columns * Width equal File Width"],
          get = function()
            return data.customForegroundFrameWidth and tostring(data.customForegroundFrameWidth) or "";
          end,
          set = function(info, v)
            data.customForegroundFrameWidth = v and tonumber(v) or 0
            WeakAuras.Add(data);
            WeakAuras.UpdateThumbnail(data);
          end,
          order = 9,
          hidden = function()
            return texture_data[data.foregroundTexture] or textureNameHasData(data.foregroundTexture)
          end
        },
        customForegroundFrameHeight = {
          type = "input",
          width = WeakAuras.normalWidth / 2,
          name = L["Frame Height"],
          validate = WeakAuras.ValidateNumeric,
          desc = L["Can set to 0 if Rows * Height equal File Height"],
          get = function()
            return data.customForegroundFrameHeight and tostring(data.customForegroundFrameHeight) or "";
          end,
          set = function(info, v)
            data.customForegroundFrameHeight = v and tonumber(v) or 0
            WeakAuras.Add(data);
            WeakAuras.UpdateThumbnail(data);
          end,
          order = 10,
          hidden = function()
            return texture_data[data.foregroundTexture] or textureNameHasData(data.foregroundTexture)
          end
        },
        blendMode = {
            type = "select",
            width = WeakAuras.normalWidth,
            name = L["Blend Mode"],
            order = 11,
            values = OptionsPrivate.Private.blend_types
        },
        animationType = {
            type = "select",
            width = WeakAuras.normalWidth,
            name = L["Animation Mode"],
            order = 12,
            values = animation_types
        },
        startPercent = {
            type = "range",
            control = "WeakAurasSpinBox",
            width = WeakAuras.normalWidth,
            name = L["Animation Start"],
            min = 0,
            max = 1,
            bigStep = 0.01,
            order = 13,
            isPercent = true
        },
        endPercent = {
            type = "range",
            control = "WeakAurasSpinBox",
            width = WeakAuras.normalWidth,
            name = L["Animation End"],
            min = 0,
            max = 1,
            bigStep  = 0.01,
            order = 14,
            isPercent = true
        },
        frameRate = {
           type = "range",
           control = "WeakAurasSpinBox",
           width = WeakAuras.normalWidth,
           name = L["Frame Rate"],
           min = 3,
           max = 120,
           step = 1,
           bigStep = 3,
           order = 15,
           disabled = function() return data.animationType == "progress" end;
        },
        inverse = {
          type = "toggle",
          width = WeakAuras.normalWidth,
          name = L["Inverse"],
          order = 15.5
        },
        customBackgroundHeader = {
          type = "header",
          name = L["Background Texture"],
          order = 16,
        },
        hideBackground = {
          type = "toggle",
          name = L["Hide Background"],
          order = 17,
          width = WeakAuras.normalWidth,
        },
        sameTexture = {
          type = "toggle",
          width = WeakAuras.normalWidth,
          name = L["Same texture as Foreground"],
          order = 18,
          disabled = function() return data.hideBackground; end,
          hidden = function() return data.hideBackground; end
        },
        backgroundTexture = {
            type = "input",
            width = WeakAuras.doubleWidth - 0.15,
            name = L["Background Texture"],
            order = 19,
            disabled = function() return data.sameTexture or data.hideBackground end,
            hidden = function() return data.hideBackground end,
            get = function() return data.sameTexture and data.foregroundTexture or data.backgroundTexture; end,
        },
        chooseBackgroundTexture = {
            type = "execute",
            width = 0.15,
            name = L["Choose"],
            order = 20,
            func = function()
              local path = {}
              local paths = {}
              for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
                paths[child.id] = path
              end
              OptionsPrivate.OpenTexturePicker(data, paths, {
                texture = "backgroundTexture",
                color = "backgroundColor",
                mirror = "mirror",
                blendMode = "blendMode"
              }, texture_types, setTextureFunc, true);
            end,
            disabled = function() return data.sameTexture or data.hideBackground; end,
            hidden = function() return data.hideBackground end,
            imageWidth = 24,
            imageHeight = 24,
            control = "WeakAurasIcon",
            image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
        },
        backgroundColor = {
            type = "color",
            width = WeakAuras.normalWidth,
            name = L["Color"],
            hasAlpha = true,
            order = 21,
            disabled = function() return data.hideBackground; end,
            hidden = function() return data.hideBackground; end
        },
        desaturateBackground = {
          type = "toggle",
          name = L["Desaturate"],
          order = 22,
          width = WeakAuras.normalWidth,
          disabled = function() return data.hideBackground; end,
          hidden = function() return data.hideBackground; end
      },
        backgroundColorHiddenSpacer = {
          type = "execute",
          width = WeakAuras.normalWidth,
          name = "",
          order = 23,
          image = function() return "", 0, 0 end,
          hidden = function() return not data.hideBackground end
        },
        customBackgroundRows = {
          type = "input",
          width = WeakAuras.doubleWidth / 3,
          name = L["Rows"],
          validate = WeakAuras.ValidateNumeric,
          get = function()
            return data.customBackgroundRows and tostring(data.customBackgroundRows) or "";
          end,
          set = function(info, v)
            data.customBackgroundRows = v and tonumber(v) or 0
            WeakAuras.Add(data);
            WeakAuras.UpdateThumbnail(data);
          end,
          order = 24,
          hidden = function()
            return data.sameTexture
                   or texture_data[data.backgroundTexture]
                   or textureNameHasData(data.backgroundTexture)
          end
      },
      customBackgroundColumns = {
          type = "input",
          width = WeakAuras.doubleWidth / 3,
          name = L["Columns"],
          validate = WeakAuras.ValidateNumeric,
          get = function()
            return data.customBackgroundColumns and tostring(data.customBackgroundColumns) or "";
          end,
          set = function(info, v)
            data.customBackgroundColumns = v and tonumber(v) or 0
            WeakAuras.Add(data);
            WeakAuras.UpdateThumbnail(data);
          end,
          order = 25,
          hidden = function()
            return data.sameTexture
                   or texture_data[data.backgroundTexture]
                   or textureNameHasData(data.backgroundTexture)
          end
      },
      customBackgroundFrames = {
          type = "input",
          width = WeakAuras.doubleWidth / 3,
          name = L["Frame Count"],
          validate = WeakAuras.ValidateNumeric,
          get = function()
            return data.customBackgroundFrames and tostring(data.customBackgroundFrames) or "";
          end,
          set = function(info, v)
            data.customBackgroundFrames = v and tonumber(v) or 0
            WeakAuras.Add(data);
            WeakAuras.UpdateThumbnail(data);
          end,
          order = 26,
          hidden = function()
            return data.sameTexture
                   or texture_data[data.backgroundTexture]
                   or textureNameHasData(data.backgroundTexture)
          end
      },
      customBackgroundFileWidth = {
        type = "input",
        width = WeakAuras.normalWidth / 2,
        name = L["File Width"],
        desc = L["Must be a power of 2"],
        validate = function(info, val)
          if val ~= nil and val ~= "" and (not tonumber(val) or tonumber(val) >= 2^31 or math.frexp(val) ~= 0.5) then
            return false;
          end
          return true
        end,
        get = function()
          return data.customBackgroundFileWidth and tostring(data.customBackgroundFileWidth) or "";
        end,
        set = function(info, v)
          data.customBackgroundFileWidth = v and tonumber(v) or 0
          WeakAuras.Add(data);
          WeakAuras.UpdateThumbnail(data);
        end,
        order = 27,
        hidden = function()
          return data.sameTexture or texture_data[data.backgroundTexture] or textureNameHasData(data.backgroundTexture)
        end
      },
      customBackgroundFileHeight = {
        type = "input",
        width = WeakAuras.normalWidth / 2,
        name = L["File Height"],
        desc = L["Must be a power of 2"],
        validate = function(info, val)
          if val ~= nil and val ~= "" and (not tonumber(val) or tonumber(val) >= 2^31 or math.frexp(val) ~= 0.5) then
            return false;
          end
          return true
        end,
        get = function()
          return data.customBackgroundFileHeight and tostring(data.customBackgroundFileHeight) or "";
        end,
        set = function(info, v)
          data.customBackgroundFileHeight = v and tonumber(v) or 0
          WeakAuras.Add(data);
          WeakAuras.UpdateThumbnail(data);
        end,
        order = 28,
        hidden = function()
          return data.sameTexture or texture_data[data.backgroundTexture] or textureNameHasData(data.backgroundTexture)
        end
      },
      customBackgroundFrameWidth = {
        type = "input",
        width = WeakAuras.normalWidth / 2,
        name = L["Frame Width"],
        validate = WeakAuras.ValidateNumeric,
        desc = L["Can set to 0 if Columns * Width equal File Width"],
        get = function()
          return data.customBackgroundFrameWidth and tostring(data.customBackgroundFrameWidth) or "";
        end,
        set = function(info, v)
          data.customBackgroundFrameWidth = v and tonumber(v) or 0
          WeakAuras.Add(data);
          WeakAuras.UpdateThumbnail(data);
        end,
        order = 29,
        hidden = function()
          return data.sameTexture or texture_data[data.backgroundTexture] or textureNameHasData(data.backgroundTexture)
        end
      },
      customBackgroundFrameHeight = {
        type = "input",
        width = WeakAuras.normalWidth / 2,
        name = L["Frame Height"],
        validate = WeakAuras.ValidateNumeric,
        desc = L["Can set to 0 if Rows * Height equal File Height"],
        get = function()
          return data.customBackgroundFrameHeight and tostring(data.customBackgroundFrameHeight) or "";
        end,
        set = function(info, v)
          data.customBackgroundFrameHeight = v and tonumber(v) or 0
          WeakAuras.Add(data);
          WeakAuras.UpdateThumbnail(data);
        end,
        order = 30,
        hidden = function()
          return data.sameTexture or texture_data[data.backgroundTexture] or textureNameHasData(data.backgroundTexture)
        end
      },
      backgroundPercent = {
        type = "range",
        control = "WeakAurasSpinBox",
        width = WeakAuras.normalWidth,
        name = L["Selected Frame"],
        min = 0,
        max = 1,
        order = 31,
        isPercent = true,
        hidden = function() return data.hideBackground; end
      }
    };

    return {
      stopmotion = options,
      progressOptions = OptionsPrivate.commonOptions.ProgressOptions(data),
      position = OptionsPrivate.commonOptions.PositionOptions(id, data, 2),
    }
end

local function createThumbnail()
    local borderframe = CreateFrame("Frame", nil, UIParent);
    borderframe:SetWidth(32);
    borderframe:SetHeight(32);

    local border = borderframe:CreateTexture(nil, "OVERLAY");
    border:SetAllPoints(borderframe);
    border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
    border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

    local texture = borderframe:CreateTexture();
    borderframe.texture = texture;
    texture:SetPoint("CENTER", borderframe, "CENTER");

    return borderframe;
end

local function modifyThumbnail(parent, region, data, fullModify, size)
    region:SetParent(parent)

    size = size or 30;
    local scale;
    if(data.height > data.width) then
        scale = size/data.height;
        region.texture:SetWidth(scale * data.width);
        region.texture:SetHeight(size);
    else
        scale = size/data.width;
        region.texture:SetWidth(size);
        region.texture:SetHeight(scale * data.height);
    end

    local frame = 1;
    region.foreground = region.foreground or {}
    local tdata = texture_data[data.foregroundTexture];
    if (tdata) then
      local lastFrame = tdata.count - 1;
      region.startFrame = floor( (data.startPercent or 0) * lastFrame) + 1;
      region.endFrame = floor( (data.endPercent or 1) * lastFrame) + 1;
      region.foreground.rows = tdata.rows;
      region.foreground.columns = tdata.columns;
      region.foreground.fileWidth = 0
      region.foreground.fileHeight = 0
      region.foreground.frameWidth = 0
      region.foreground.frameHeight = 0
    else
      local pattern = "%.x(%d+)y(%d+)f(%d+)%.[tb][gl][ap]"
      local pattern2 = "%.x(%d+)y(%d+)f(%d+)w(%d+)h(%d+)W(%d+)H(%d+)%.[tb][gl][ap]"
      local rows, columns, frames = data.foregroundTexture:lower():match(pattern)
      if rows then
        local lastFrame = frames - 1;
        region.startFrame = floor( (data.startPercent or 0) * lastFrame) + 1;
        region.endFrame = floor( (data.endPercent or 1) * lastFrame) + 1;
        region.foreground.rows = tonumber(rows);
        region.foreground.columns = tonumber(columns);
        region.foreground.fileWidth = 0
        region.foreground.fileHeight = 0
        region.foreground.frameWidth = 0
        region.foreground.frameHeight = 0
      else
        local rows, columns, frames, frameWidth, frameHeight, fileWidth, fileHeight
              = data.foregroundTexture:match(pattern2)
        if rows then
          local lastFrame = frames - 1;
          region.startFrame = floor( (data.startPercent or 0) * lastFrame) + 1;
          region.endFrame = floor( (data.endPercent or 1) * lastFrame) + 1;
          region.foreground.rows = tonumber(rows)
          region.foreground.columns = tonumber(columns)
          region.foreground.fileWidth = tonumber(fileWidth)
          region.foreground.fileHeight = tonumber(fileHeight)
          region.foreground.frameWidth = tonumber(frameWidth)
          region.foreground.frameHeight = tonumber(frameHeight)
        else
          local lastFrame = data.customForegroundFrames - 1;
          region.startFrame = floor( (data.startPercent or 0) * lastFrame) + 1;
          region.endFrame = floor( (data.endPercent or 1) * lastFrame) + 1;
          region.foreground.rows = data.customForegroundRows;
          region.foreground.columns = data.customForegroundColumns;
          region.foreground.fileWidth = data.customForegroundFileWidth
          region.foreground.fileHeight = data.customForegroundFileHeight
          region.foreground.frameWidth = data.customForegroundFrameWidth
          region.foreground.frameHeight = data.customForegroundFrameHeight
        end
      end
    end

    if (region.startFrame and region.endFrame) then
      frame = floor(region.startFrame + (region.endFrame - region.startFrame) * 0.75);
    end

    local texture = data.foregroundTexture or "Interface\\AddOns\\WeakAuras\\Media\\Textures\\stopmotion";

    if (region.foreground.rows and region.foreground.columns) then
      OptionsPrivate.Private.SetTextureOrAtlas(region.texture, texture)
      local frameScaleW, frameScaleH = 1, 1
      if region.foreground.fileWidth and region.foreground.frameWidth
        and region.foreground.fileWidth > 0 and region.foreground.frameWidth > 0
      then
        frameScaleW = (region.foreground.frameWidth * region.foreground.columns) / region.foreground.fileWidth
      end

      if region.foreground.fileHeight and region.foreground.frameHeight
         and region.foreground.fileHeight > 0 and region.foreground.frameHeight > 0
      then
        frameScaleH = (region.foreground.frameHeight * region.foreground.rows) / region.foreground.fileHeight
      end

      WeakAuras.setTile(region.texture, frame, region.foreground.rows, region.foreground.columns, frameScaleW, frameScaleH);

      region.SetValue = function(self, percent)
        local frame = floor(percent * (region.endFrame - region.startFrame) + region.startFrame);
        WeakAuras.setTile(self.texture, frame, region.foreground.rows, region.foreground.columns, frameScaleW, frameScaleH);
      end
    else
      region.texture:SetTexture(texture .. format("%03d", frame));
      region.texture:SetTexCoord(0, 1, 0, 1);

      region.SetValue = function(self, percent)
        local frame = floor(percent * (region.endFrame - region.startFrame) + region.startFrame);
        self.texture:SetTexture((data.foregroundTexture) .. format("%03d", frame));
      end
    end

    region.texture:SetVertexColor(data.foregroundColor[1], data.foregroundColor[2],
                                  data.foregroundColor[3], data.foregroundColor[4])
    region.texture:SetBlendMode(data.blendMode);

    region.elapsed = 0;
    region:SetScript("OnUpdate", function(self, elapsed)
        region.elapsed = region.elapsed + elapsed;
        if(region.elapsed > 4) then
            region.elapsed = region.elapsed - 4;
        end
        region:SetValue(region.elapsed / 4);
    end);
end

local function createIcon()
    local data = {
        height = 30,
        width = 30,
        foregroundTexture = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\stopmotion",
        foregroundColor = {1, 1, 1, 1},
        blendMode = "ADD",
        rotate = false,
        rotation = 0,
        startPercent = 0,
        endPercent = 1,
        backgroundPercent = 1,
        animationType = "progress"
    };

    local thumbnail = createThumbnail();
    modifyThumbnail(UIParent, thumbnail, data, nil, 75);

    thumbnail.elapsed = 0;
    thumbnail:SetScript("OnUpdate", function(self, elapsed)
        thumbnail.elapsed = thumbnail.elapsed + elapsed;
        if(thumbnail.elapsed > 2) then
            thumbnail.elapsed = thumbnail.elapsed - 2;
        end
        thumbnail:SetValue(thumbnail.elapsed / 2);
    end);

    return thumbnail;
end

OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("stopmotion", createOptions, createIcon, L["Stop Motion"],
                                      createThumbnail, modifyThumbnail, L["Shows a stop motion texture"]);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/StopMotion.lua ===


=== FILE: WeakAurasOptions/RegionOptions/Text.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

local screenWidth = math.ceil(GetScreenWidth() / 20) * 20;

local indentWidth = 0.15
local hiddenFontExtra = function()
  return OptionsPrivate.IsCollapsed("text", "text", "fontflags", true)
end

local dynamicTextInputs = {}

local function createOptions(id, data)
  local function hideCustomTextOption()
    if OptionsPrivate.Private.ContainsCustomPlaceHolder(data.displayText) then
      return false
    end

    if type(data.conditions) == "table" then
      for _, condition in ipairs(data.conditions) do
        if type(condition.changes) == "table" then
          for _, change in ipairs(condition.changes) do
            if type(change.property) == "string"
            and change.property == "displayText"
            and type(change.value) == "string"
            and OptionsPrivate.Private.ContainsCustomPlaceHolder(change.value)
            then
              return false
            end
          end
        end
      end
    end

    return true
  end

  local options = {
    __title = L["Text Settings"],
    __order = 1,
    __dynamicTextCodes = function()
      local widget = dynamicTextInputs["displayText"]
      OptionsPrivate.ToggleTextReplacements(data, widget, "ToggleButton")
    end,
    displayText = {
      type = "input",
      width = WeakAuras.doubleWidth,
      multiline = true,
      name = L["Display Text"],
      order = 10,
      get = function()
        return data.displayText;
      end,
      set = function(info, v)
        data.displayText = OptionsPrivate.Private.ReplaceLocalizedRaidMarkers(v);

        local metaData = OptionsPrivate.Private.GetAdditionalProperties(data)
        OptionsPrivate.Private.SetDefaultFormatters(data, data.displayText, "displayText_format_", metaData)

        WeakAuras.Add(data);
        WeakAuras.ClearAndUpdateOptions(data.id)
        WeakAuras.UpdateThumbnail(data);
        OptionsPrivate.ResetMoverSizer();
      end,
      control = "WeakAurasMultiLineEditBox",
      callbacks = {
        OnEditFocusGained = function(self)
          local widget = dynamicTextInputs["displayText"]
          OptionsPrivate.ToggleTextReplacements(data, widget, "OnEditFocusGained")
        end,
        OnEditFocusLost = function(self)
          OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
        end,
        OnShow = function(self)
          dynamicTextInputs["displayText"] = self
        end,
      }
    },
    customTextUpdate = {
      type = "select",
      width = WeakAuras.doubleWidth,
      hidden = hideCustomTextOption,
      name = L["Update Custom Text On..."],
      values = OptionsPrivate.Private.text_check_types,
      order = 36
    },
    text_customTextUpdateThrottle = {
      type = "range",
      control = "WeakAurasSpinBox",
      softMin = 0,
      softMax = 5,
      bigStep = 0.1,
      min = 0,
      width = WeakAuras.doubleWidth,
      name = L["Custom Text Update Throttle"],
      order = 36.1,
      get = function() return data.customTextUpdateThrottle or 0 end,
      set = function(info, v)
        v = tonumber(v) or 0
        if v < 0 then
          v = 0
        end
        data.customTextUpdateThrottle = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end,
      hidden = function()
        return hideCustomTextOption() or (data.customTextUpdate ~= "update")
      end
    },
    -- code editor added below

    font = {
      type = "select",
      width = WeakAuras.normalWidth,
      dialogControl = "LSM30_Font",
      name = L["Font"],
      order = 45,
      values = AceGUIWidgetLSMlists.font
    },
    fontSize = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Size"],
      order = 46,
      min = 6,
      softMax = 72,
      step = 1
    },
    color = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Text Color"],
      hasAlpha = true,
      order = 47
    },

    fontFlagsDescription = {
      order = 48,
      width = WeakAuras.doubleWidth,
      type = "execute",
      control = "WeakAurasExpandSmall",
      name = function()
        local textFlags = OptionsPrivate.Private.font_flags[data.outline]
        local color = format("%02x%02x%02x%02x",
                             data.shadowColor[4] * 255, data.shadowColor[1] * 255,
                             data.shadowColor[2] * 255, data.shadowColor[3]*255)

        local textJustify = ""
        if data.justify == "CENTER" then
          -- CENTER is default
        elseif data.justify == "LEFT" then
          textJustify = " " .. L["and aligned left"]
        elseif data.justify == "RIGHT" then
          textJustify = " " ..  L["and aligned right"]
        end

        local textWidth = ""
        if data.automaticWidth == "Fixed" then
          local wordWarp = ""
          if data.wordWrap == "WordWrap" then
            wordWarp = L["wrapping"]
          else
            wordWarp = L["eliding"]
          end
          textWidth = " "..L["and with width |cFFFF0000%s|r and %s"]:format(data.fixedWidth, wordWarp)
        end

        local secondline = L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s"]:format(textFlags, color, data.shadowXOffset, data.shadowYOffset, textJustify, textWidth)

        return secondline
      end,
      func = function(info, button)
        local collapsed = OptionsPrivate.IsCollapsed("text", "text", "fontflags", true)
        OptionsPrivate.SetCollapsed("text", "text", "fontflags", not collapsed)
      end,
      image = function()
        local collapsed = OptionsPrivate.IsCollapsed("text", "text", "fontflags", true)
        return collapsed and "collapsed" or "expanded"
      end,
      imageWidth = 15,
      imageHeight = 15,
      arg = {
        expanderName = "text"
      }
    },

    text_font_space = {
      type = "description",
      name = "",
      order = 48.1,
      hidden = hiddenFontExtra,
      width = indentWidth
    },
    outline = {
      type = "select",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Outline"],
      order = 48.2,
      values = OptionsPrivate.Private.font_flags,
      hidden = hiddenFontExtra
    },
    shadowColor = {
      type = "color",
      hasAlpha = true,
      width = WeakAuras.normalWidth,
      name = L["Shadow Color"],
      order = 48.3,
      hidden = hiddenFontExtra
    },

    text_font_space3 = {
      type = "description",
      name = "",
      order = 48.4,
      hidden = hiddenFontExtra,
      width = indentWidth
    },
    shadowXOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Shadow X Offset"],
      softMin = -15,
      softMax = 15,
      bigStep = 1,
      order = 48.5,
      hidden = hiddenFontExtra
    },
    shadowYOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Shadow Y Offset"],
      softMin = -15,
      softMax = 15,
      bigStep = 1,
      order = 48.6,
      hidden = hiddenFontExtra
    },

    text_font_space4 = {
      type = "description",
      name = "",
      order = 48.7,
      hidden = hiddenFontExtra,
      width = indentWidth
    },
    justify = {
      type = "select",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Justify"],
      order = 48.8,
      values = OptionsPrivate.Private.justify_types,
      hidden = hiddenFontExtra,
    },
    text_font_space55 = {
      type = "description",
      name = "",
      order = 48.85,
      hidden = hiddenFontExtra,
      width = WeakAuras.normalWidth
    },

    text_font_space5 = {
      type = "description",
      name = "",
      order = 48.9,
      hidden = hiddenFontExtra,
      width = indentWidth
    },
    automaticWidth = {
      type = "select",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Width"],
      order = 49,
      values = OptionsPrivate.Private.text_automatic_width,
      hidden = hiddenFontExtra,
    },
    fixedWidth = {
      name = L["Width"],
      width = WeakAuras.normalWidth,
      order = 49.1,
      type = "range",
      control = "WeakAurasSpinBox",
      min = 1,
      softMax = screenWidth,
      bigStep = 1,
      hidden = function() return hiddenFontExtra() or data.automaticWidth ~= "Fixed" end
    },
    text_font_space7 = {
      type = "description",
      name = "",
      order = 49.3,
      width = indentWidth,
      hidden = function() return hiddenFontExtra() or data.automaticWidth ~= "Fixed" end
    },
    wordWrap = {
      type = "select",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Overflow"],
      order = 49.4,
      values = OptionsPrivate.Private.text_word_wrap,
      hidden = function() return hiddenFontExtra() or data.automaticWidth ~= "Fixed" end
    },

    fontExtraAnchor = {
      type = "description",
      name = "",
      order = 50,
      hidden = hiddenFontExtra,
      control = "WeakAurasExpandAnchor",
      arg = {
        expanderName = "text"
      }
    },

    useTooltip = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Tooltip on Mouseover"],
      hidden = function() return not OptionsPrivate.Private.CanHaveTooltip(data) end,
      order = 51
    },

    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  OptionsPrivate.commonOptions.AddCodeOption(options, data, L["Custom Function"], "customText", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-text",
                          37, hideCustomTextOption, {"customText"}, false);

  -- Add Text Format Options
  local hidden = function()
    return OptionsPrivate.IsCollapsed("format_option", "text", "displayText", true)
  end

  local setHidden = function(hidden)
    OptionsPrivate.SetCollapsed("format_option", "text", "displayText", hidden)
  end

  local order = 12
  local function addOption(key, option)
    option.order = order
    order = order + 0.01
    if option.reloadOptions then
      option.reloadOptions = nil
      option.set = function(info, v)
        data["displayText_format_" .. key] = v
        WeakAuras.Add(data)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    end
    options["displayText_format_" .. key] = option
  end

  local total, index = 0, 1
  for _ in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
    total = total + 1
  end

  for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
    local texts = {}
    if child.displayText ~= "" then
      tinsert(texts, child.displayText)
    end
    for _, condition in ipairs(child.conditions) do
      if type(condition.changes) == "table" then
        for _, change in ipairs(condition.changes) do
          if type(change.property) == "string"
          and change.property == "displayText"
          and type(change.value) == "string"
          and change.value ~= ""
          then
            tinsert(texts, change.value)
          end
        end
      end
    end

    local get = function(key)
      return child["displayText_format_" .. key]
    end

    OptionsPrivate.AddTextFormatOption(texts, true, get, addOption, hidden, setHidden, false, index, total)
    index = index + 1
  end

  addOption("footer", {
    type = "description",
    name = "",
    width = WeakAuras.doubleWidth,
    hidden = hidden
  })

  return {
    text = options;
    position = OptionsPrivate.commonOptions.PositionOptions(id, data, nil, true);
  };
end

local function createThumbnail()
  local borderframe = CreateFrame("Frame", nil, UIParent);
  borderframe:SetWidth(32);
  borderframe:SetHeight(32);

  local border = borderframe:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(borderframe);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  local mask = CreateFrame("ScrollFrame", nil, borderframe);
  borderframe.mask = mask;
  mask:SetPoint("BOTTOMLEFT", borderframe, "BOTTOMLEFT", 2, 2);
  mask:SetPoint("TOPRIGHT", borderframe, "TOPRIGHT", -2, -2);

  local content = CreateFrame("Frame", nil, mask);
  borderframe.content = content;
  content:SetPoint("CENTER", mask, "CENTER");
  mask:SetScrollChild(content);

  local text = content:CreateFontString(nil, "OVERLAY");
  borderframe.text = text;
  text:SetNonSpaceWrap(true);

  borderframe.values = {};

  return borderframe;
end

local function modifyThumbnail(parent, borderframe, data, fullModify, size)
  local mask, content, text = borderframe.mask, borderframe.content, borderframe.text;

  size = size or 28;

  local fontPath = SharedMedia:Fetch("font", data.font) or data.font;
  text:SetFont(fontPath, data.fontSize, data.outline and "OUTLINE" or nil);
  text:SetTextHeight(data.fontSize);
  text:SetText(data.displayText);
  text:SetTextColor(data.color[1], data.color[2], data.color[3], data.color[4]);
  text:SetJustifyH(data.justify);

  text:ClearAllPoints();
  text:SetPoint("CENTER", UIParent, "CENTER");
  content:SetWidth(math.max(text:GetStringWidth(), size));
  content:SetHeight(math.max(text:GetStringHeight(), size));
  text:ClearAllPoints();
  text:SetPoint("CENTER", content, "CENTER");

  local function rescroll()
    content:SetWidth(math.max(text:GetStringWidth(), size));
    content:SetHeight(math.max(text:GetStringHeight(), size));
    local xo = 0;
    if(data.justify == "CENTER") then
      xo = mask:GetHorizontalScrollRange() / 2;
    elseif(data.justify == "RIGHT") then
      xo = mask:GetHorizontalScrollRange();
    end
    mask:SetHorizontalScroll(xo);
    mask:SetVerticalScroll(mask:GetVerticalScrollRange() / 2);
  end

  rescroll();
  mask:SetScript("OnScrollRangeChanged", rescroll);

  local function UpdateText()
    local textStr = data.displayText;
    text:SetText(textStr);
    rescroll();
  end

  function borderframe:SetIcon(path)
    UpdateText();
  end

  function borderframe:SetName(name)
    UpdateText();
  end

  UpdateText();
end

local function createIcon()
  local data = {
    outline = true,
    color = {1, 1, 0, 1},
    justify = "CENTER",
    font = "Friz Quadrata TT",
    fontSize = 12,
    displayText = "World\nof\nWarcraft";
  };

  local thumbnail = createThumbnail();
  modifyThumbnail(UIParent, thumbnail, data);
  thumbnail.mask:SetPoint("BOTTOMLEFT", thumbnail, "BOTTOMLEFT", 3, 3);
  thumbnail.mask:SetPoint("TOPRIGHT", thumbnail, "TOPRIGHT", -3, -3);

  return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    description = L["Displays a text, works best in combination with other displays"],
    data = {
    };
  }
}

OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("text", createOptions, createIcon, L["Text"], createThumbnail, modifyThumbnail, L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"], templates);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/Text.lua ===


=== FILE: WeakAurasOptions/RegionOptions/Texture.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local function createOptions(id, data)
  local options = {
    __title = L["Texture Settings"],
    __order = 1,
    texture = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Texture"],
      order = 1
    },
    chooseTexture = {
      type = "execute",
      name = L["Choose"],
      width = 0.15,
      order = 1.1,
      func = function()
        local path = {}
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(data, paths, {
          texture = "texture",
          color = "color",
          mirror = "mirror",
          blendMode = "blendMode"
        }, OptionsPrivate.Private.texture_types, nil, true)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    color = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 2
    },
    desaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 3,
    },
    alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Alpha"],
      order = 4,
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    },
    blendMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 5,
      values = OptionsPrivate.Private.blend_types
    },
    mirror = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Mirror"],
      order = 6
    },
    textureWrapMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Texture Wrap"],
      order = 7,
      values = OptionsPrivate.Private.texture_wrap_types,
      hidden = OptionsPrivate.Private.TextureBase.IsAtlas(data.texture)
    },
    rotate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Allow Full Rotation"],
      order = 8,
      hidden = OptionsPrivate.Private.TextureBase.IsAtlas(data.texture)
    },
    rotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 9,
    },
    endHeader = {
      type = "header",
      order = 100,
      name = "",
    },
  };

  return {
    texture = options,
    position = OptionsPrivate.commonOptions.PositionOptions(id, data),
  };
end

local function createThumbnail()
  local borderframe = CreateFrame("Frame", nil, UIParent);
  borderframe:SetWidth(32);
  borderframe:SetHeight(32);

  local border = borderframe:CreateTexture(nil, "OVERLAY");
  border:SetAllPoints(borderframe);
  border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2.blp");
  border:SetTexCoord(0.2, 0.8, 0.2, 0.8);

  local texture = borderframe:CreateTexture();
  borderframe.texture = texture;
  texture:SetPoint("CENTER", borderframe, "CENTER");

  return borderframe;
end

local SQRT2 = sqrt(2)
local function GetRotatedPoints(degrees, scaleForFullRotate)
  degrees = degrees or 0
  local angle = rad(135 - degrees);
  local factor = scaleForFullRotate and 1 or SQRT2
  local vx = math.cos(angle) / factor
  local vy = math.sin(angle) / factor

  return 0.5+vx,0.5-vy , 0.5-vy,0.5-vx , 0.5+vy,0.5+vx , 0.5-vx,0.5+vy
end

local function modifyThumbnail(parent, region, data, fullModify, size)
  size = size or 30;
  local scale;
  if(data.height > data.width) then
    scale = size/data.height;
    region.texture:SetWidth(scale * data.width);
    region.texture:SetHeight(size);
  else
    scale = size/data.width;
    region.texture:SetWidth(size);
    region.texture:SetHeight(scale * data.height);
  end

  OptionsPrivate.Private.SetTextureOrAtlas(region.texture, data.texture, data.textureWrapMode, data.textureWrapMode);
  region.texture:SetVertexColor(data.color[1], data.color[2], data.color[3], data.color[4]);
  region.texture:SetBlendMode(data.blendMode);

  local ulx,uly , llx,lly , urx,ury , lrx,lry = GetRotatedPoints(data.rotation, data.rotate)
  if(data.mirror) then
    region.texture:SetTexCoord(urx,ury , lrx,lry , ulx,uly , llx,lly);
  else
    region.texture:SetTexCoord(ulx,uly , llx,lly , urx,ury , lrx,lry);
  end
end

local function createIcon()
  local data = {
    height = 40,
    width = 40,
    texture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura3",
    color = {1, 1, 1, 1},
    blendMode = "ADD",
    rotate = true;
    rotation = 0;
  };

  local thumbnail = createThumbnail();
  modifyThumbnail(UIParent, thumbnail, data, nil, 50);

  return thumbnail;
end

local templates = {
  {
    title = L["Default"],
    data = {
    };
  },
  {
    title = L["Star"],
    data = {
      texture = "241049", -- Spells\\T_Star3
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
  {
    title = L["Leaf"],
    data = {
      texture = "166606", -- Spells\\Nature_Rune_128
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
  {
    title = L["Hawk"],
    data = {
      texture = "165609", -- Spells\\Aspect_Hawk
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
  {
    title = L["Low Mana"],
    data = {
      texture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura70",
      blendMode = "ADD",
      width = 200,
      height = 200,
      discrete_rotation = 0,
    }
  },
}

if WeakAuras.IsClassicEra() then
  table.remove(templates, 2)
end

OptionsPrivate.registerRegions = OptionsPrivate.registerRegions or {}
table.insert(OptionsPrivate.registerRegions, function()
  OptionsPrivate.Private.RegisterRegionOptions("texture", createOptions, createIcon, L["Texture"], createThumbnail, modifyThumbnail,
                                    L["Shows a custom texture"], templates);
end)

=== END OF FILE: WeakAurasOptions/RegionOptions/Texture.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/Background.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)
local L = WeakAuras.L;

do
  local function subCreateOptions(parentData, data, index, subIndex)
      local options = {
        __title = L["Background"],
        __order = 1,
        __up = function()
          for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
            OptionsPrivate.MoveSubRegionUp(child, index, "subbackground")
          end
          WeakAuras.ClearAndUpdateOptions(parentData.id)
        end,
        __down = function()
          for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
            OptionsPrivate.MoveSubRegionDown(child, index, "subbackground")
          end
          WeakAuras.ClearAndUpdateOptions(parentData.id)
        end,
        __notcollapsable = true
      }
      return options
    end

  WeakAuras.RegisterSubRegionOptions("subbackground", subCreateOptions, L["Background"]);
end

-- Foreground for aurabar

do
  local function subCreateOptions(parentData, data, index, subIndex)
    local options = {
      __title = L["Foreground"],
      __order = 1,
      __up = function()
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
          OptionsPrivate.MoveSubRegionUp(child, index, "subforeground")
        end
        WeakAuras.ClearAndUpdateOptions(parentData.id)
      end,
      __down = function()
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
          OptionsPrivate.MoveSubRegionDown(child, index, "subforeground")
        end
        WeakAuras.ClearAndUpdateOptions(parentData.id)
      end,
      __notcollapsable = true
    }
    return options
  end

  WeakAuras.RegisterSubRegionOptions("subforeground", subCreateOptions, L["Foreground"]);
end

=== END OF FILE: WeakAurasOptions/SubRegionOptions/Background.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/Border.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function createOptions(parentData, data, index, subIndex)
  local areaAnchors = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    Mixin(areaAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "area"))
  end

  local options = {
    __title = L["Border %s"]:format(subIndex),
    __order = 1,
    border_visible = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Show Border"],
      order = 2,
    },
    border_edge = {
      type = "select",
      width = WeakAuras.normalWidth,
      dialogControl = "LSM30_Border",
      name = L["Border Style"],
      order = 3,
      values = AceGUIWidgetLSMlists.border,
    },
    border_color = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Border Color"],
      hasAlpha = true,
      order = 4,
    },
    border_offset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Border Offset"],
      order = 5,
      softMin = 0,
      softMax = 32,
      bigStep = 1,
    },
    border_size = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Border Size"],
      order = 6,
      min = 1,
      softMax = 64,
      bigStep = 1,
    },
    anchor_area = {
      type = "select",
      width = WeakAuras.normalWidth,
      control = "WeakAurasTwoColumnDropdown",
      name = L["Border Anchor"],
      order = 7,
      values = areaAnchors,
      hidden = function() return parentData.regionType ~= "aurabar" end
    }
  }

  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "subborder")

  return options
end

WeakAuras.RegisterSubRegionOptions("subborder", createOptions, L["Shows a border"]);

=== END OF FILE: WeakAurasOptions/SubRegionOptions/Border.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/CircularProgressTexture.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function createOptions(parentData, data, index, subIndex)
  local pointAnchors = {}
  local areaAnchors = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    Mixin(pointAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "point"))
    Mixin(areaAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "area"))
  end

  local options = {
    __title = L["Circular Texture %s"]:format(subIndex),
    __order = 1,
    circularTextureVisible = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Show Circular Texture"],
      order = 1,
    },
    circularTextureTexture = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Texture"],
      order = 2,
    },
    chooseTexture = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 3,
      func = function()
        local path = { "subRegions", index }
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(parentData, paths, {
          texture = "circularTextureTexture",
          color = "circularTextureColor",
          blendMode = "circularTextureBlendMode"
        }, OptionsPrivate.Private.texture_types, nil)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    circularTextureClockwise = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Clockwise"],
      order = 4,
    },
    circularTextureMirror = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Mirror"],
      order = 5,
    },
    circularTextureColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 6
    },
    circularTextureDesaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 7,
    },
    circularTextureBlendMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 8,
      values = OptionsPrivate.Private.blend_types
    },
    circularTextureInverse = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Inverse"],
      order = 8.5,
    },
    circularTextureStartAngle = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 9,
      name = L["Start Angle"],
      min = 0,
      max = 360,
      bigStep = 1,
    },
    circularTextureEndAngle = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 10,
      name = L["End Angle"],
      min = 0,
      max = 360,
      bigStep = 1,
     },
     circularTextureCrop_x = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Crop X"],
      order = 11,
      min = 0,
      softMax = 2,
      bigStep = 0.01,
      isPercent = true,
    },
    circularTextureCrop_y = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Crop Y"],
      order = 12,
      min = 0,
      softMax = 2,
      bigStep = 0.01,
      isPercent = true,
    },
    -- Doesn't appear to work
    circularTextureRotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Texture Rotation"],
      desc = L["Uses Texture Coordinates to rotate the texture."],
      order = 13,
      min = 0,
      max = 360,
      bigStep = 1
    },
    -- Doesn't appear to work
    circularTextureAuraRotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      order = 14,
      min = 0,
      max = 360,
      bigStep = 1
    },
  }

  OptionsPrivate.commonOptions.ProgressOptionsForSubElement(parentData, data, options, 16)
  OptionsPrivate.commonOptions.PositionOptionsForSubElement(data, options, 17, areaAnchors, pointAnchors)

  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "subcirculartexture")

  return options
end

  WeakAuras.RegisterSubRegionOptions("subcirculartexture", createOptions, L["Shows a Circular Progress Texture"]);

=== END OF FILE: WeakAurasOptions/SubRegionOptions/CircularProgressTexture.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/Glow.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;
local indentWidth = 0.15

local function createOptions(parentData, data, index, subIndex)
  local areaAnchors = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    Mixin(areaAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "area"))
  end

  local hiddenGlowExtra = function()
    return OptionsPrivate.IsCollapsed("glow", "glow", "glowextra" .. index, true);
  end

  local options = {
    __title = L["Glow %s"]:format(subIndex),
    __order = 1,
    glow = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show Glow"],
      order = 2,
    },
    glowType = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Type"],
      order = 2,
      values = OptionsPrivate.Private.glow_types,
    },
    anchor_area = {
      type = "select",
      width = WeakAuras.normalWidth,
      control = "WeakAurasTwoColumnDropdown",
      name = L["Glow Anchor"],
      order = 3,
      values = areaAnchors,
      hidden = function() return parentData.regionType ~= "aurabar" end
    },
    glowExtraDescription = {
      type = "execute",
      control = "WeakAurasExpandSmall",
      name = function()
        local line = L["|cFFffcc00Extra Options:|r"]
        local color = L["Default Color"]
        if data.useGlowColor then
          color = L["|c%02x%02x%02x%02xCustom Color|r"]:format(
            data.glowColor[4] * 255,
            data.glowColor[1] * 255,
            data.glowColor[2] * 255,
            data.glowColor[3] * 255
          )
        end
        if data.glowType == "buttonOverlay" then
          line = ("%s %s"):format(line, color)
        elseif data.glowType == "ACShine" then
          line = L["%s %s, Particles: %d, Frequency: %0.2f, Scale: %0.2f"]:format(
            line,
            color,
            data.glowLines,
            data.glowFrequency,
            data.glowScale
          )
          if data.glowXOffset ~= 0 or data.glowYOffset ~= 0 then
            line = L["%s, offset: %0.2f;%0.2f"]:format(line, data.glowXOffset, data.glowYOffset)
          end
        elseif data.glowType == "Pixel" then
          line = L["%s %s, Lines: %d, Frequency: %0.2f, Length: %d, Thickness: %d"]:format(
            line,
            color,
            data.glowLines,
            data.glowFrequency,
            data.glowLength,
            data.glowThickness
          )
          if data.glowXOffset ~= 0 or data.glowYOffset ~= 0 then
            line = L["%s, Offset: %0.2f;%0.2f"]:format(line, data.glowXOffset, data.glowYOffset)
          end
          if data.glowBorder then
            line = L["%s, Border"]:format(line)
          end
        elseif data.glowType == "Proc" then
          line = ("%s %s, Duration: %d"):format(line, color, data.glowDuration)
          if data.glowStartAnim then
            line = L["%s, Start Animation"]:format(line)
          end
          if data.glowXOffset ~= 0 or data.glowYOffset ~= 0 then
            line = L["%s, offset: %0.2f;%0.2f"]:format(line, data.glowXOffset, data.glowYOffset)
          end
        end
        return line
      end,
      width = WeakAuras.doubleWidth,
      order = 4,
      image = function()
        local collapsed = OptionsPrivate.IsCollapsed("glow", "glow", "glowextra" .. index, true);
        return collapsed and "collapsed" or "expanded"
      end,
      imageWidth = 15,
      imageHeight = 15,
      func = function(info, button)
        local collapsed = OptionsPrivate.IsCollapsed("glow", "glow", "glowextra" .. index, true);
        OptionsPrivate.SetCollapsed("glow", "glow", "glowextra" .. index, not collapsed);
      end,
      arg = {
        expanderName = "glow" .. index .. "#" .. subIndex
      }
    },
    glow_space1 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 5,
      hidden = hiddenGlowExtra,
    },
    useGlowColor = {
      type = "toggle",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Use Custom Color"],
      desc = L["If unchecked, then a default color will be used (usually yellow)"],
      order = 6,
      hidden = hiddenGlowExtra
    },
    glowColor = {
      type = "color",
      hasAlpha = true,
      width = WeakAuras.normalWidth,
      name = L["Custom Color"],
      order = 7,
      disabled = function() return not data.useGlowColor end,
      hidden = hiddenGlowExtra
    },
    glow_space2 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 8,
      hidden = hiddenGlowExtra,
    },
    glowStartAnim = {
      type = "toggle",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Start Animation"],
      order = 8.5,
      hidden = function() return hiddenGlowExtra() or data.glowType ~= "Proc" end
    },
    glowLines = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Lines & Particles"],
      order = 9,
      min = 1,
      softMax = 30,
      step = 1,
      hidden = function() return hiddenGlowExtra() or data.glowType == "buttonOverlay" or data.glowType == "Proc" end,
    },
    glowFrequency = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Frequency"],
      order = 10,
      softMin = -2,
      softMax = 2,
      step = 0.05,
      hidden = function() return hiddenGlowExtra() or data.glowType == "buttonOverlay" or data.glowType == "Proc" end,
    },
    glowDuration = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Duration"],
      order = 10,
      softMin = 0.01,
      softMax = 3,
      step = 0.05,
      hidden = function() return hiddenGlowExtra() or data.glowType ~= "Proc" end,
    },
    glow_space3 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 11,
      hidden = function() return hiddenGlowExtra() or data.glowType ~= "Pixel" end,
    },
    glowLength = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Length"],
      order = 12,
      min = 1,
      softMax = 20,
      step = 0.05,
      hidden = function() return hiddenGlowExtra() or data.glowType ~= "Pixel" end,
    },
    glowThickness = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Thickness"],
      order = 13,
      min = 0.05,
      softMax = 20,
      step = 0.05,
      hidden = function() return hiddenGlowExtra() or data.glowType ~= "Pixel" end,
    },
    glow_space4 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 14,
      hidden = hiddenGlowExtra,
    },
    glowXOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["X-Offset"],
      order = 15,
      softMin = -100,
      softMax = 100,
      step = 0.5,
      hidden = function() return hiddenGlowExtra() or data.glowType == "buttonOverlay" end,
    },
    glowYOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y-Offset"],
      order = 16,
      softMin = -100,
      softMax = 100,
      step = 0.5,
      hidden = function() return hiddenGlowExtra() or data.glowType == "buttonOverlay" end,
    },
    glow_space5 = {
      type = "description",
      name = "",
      width = indentWidth,
      order = 17,
      hidden = hiddenGlowExtra,
    },
    glowScale = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Scale"],
      order = 18,
      min = 0.05,
      softMax = 10,
      step = 0.05,
      isPercent = true,
      hidden = function() return hiddenGlowExtra() or data.glowType ~= "ACShine" end,
    },
    glowBorder = {
      type = "toggle",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Border"],
      order = 19,
      hidden = function() return hiddenGlowExtra() or data.glowType ~= "Pixel" end,
    },

    glow_expand_anchor = {
      type = "description",
      name = "",
      order = 20,
      hidden = hiddenGlowExtra,
      control = "WeakAurasExpandAnchor",
      arg = {
        expanderName = "glow" .. index .. "#" .. subIndex
      }
    }
  }

  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "subglow")

  return options
end

WeakAuras.RegisterSubRegionOptions("subglow", createOptions, L["Shows a glow"]);

=== END OF FILE: WeakAurasOptions/SubRegionOptions/Glow.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/LinearProgressTexture.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function createOptions(parentData, data, index, subIndex)
  local pointAnchors = {}
  local areaAnchors = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    Mixin(pointAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "point"))
    Mixin(areaAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "area"))
  end

  local options = {
    __title = L["Linear Texture %s"]:format(subIndex),
    __order = 1,
    linearTextureVisible = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Show Linear Texture"],
      order = 1,
    },
    linearTextureTexture = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Texture"],
      order = 2,
    },
    chooseTexture = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 3,
      func = function()
        local path = { "subRegions", index }
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(parentData, paths, {
          texture = "linearTextureTexture",
          color = "linearTextureColor",
          blendMode = "linearTextureBlendMode"
        }, OptionsPrivate.Private.texture_types, nil)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    linearTextureOrientation = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Orientation"],
      order = 4,
      values = OptionsPrivate.Private.orientation_types
    },
    linearTextureWrapMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Texture Wrap"],
      order = 5,
      values = OptionsPrivate.Private.texture_wrap_types
    },
    linearTextureInverse = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Inverse"],
      order = 5.5,
    },
    linearTextureMirror = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Mirror"],
      order = 6,
    },
    linearTextureDesaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 7,
    },
    linearTextureColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 8,
    },
    linearTextureBlendMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 9,
      values = OptionsPrivate.Private.blend_types
    },
    linearTextureUser_x = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 11,
      name = L["Re-center X"],
      min = -0.5,
      max = 0.5,
      bigStep = 0.01,
    },
    linearTextureUser_y = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      order = 12,
      name = L["Re-center Y"],
      min = -0.5,
      max = 0.5,
      bigStep = 0.01,
    },
    linearTextureCrop_x = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Crop X"],
      order = 13,
      min = 0,
      softMax = 2,
      bigStep = 0.01,
      isPercent = true,
    },
    linearTextureCrop_y = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Crop Y"],
      order = 14,
      min = 0,
      softMax = 2,
      bigStep = 0.01,
      isPercent = true,
    },
    -- Doesn't appear to work
    linearTextureRotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Texture Rotation"],
      desc = L["Uses Texture Coordinates to rotate the texture."],
      order = 15,
      min = 0,
      max = 360,
      bigStep = 1
    },
    -- Doesn't appear to work
    linearTextureAuraRotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      order = 16,
      min = 0,
      max = 360,
      bigStep = 1
    },

    -- Anchor Options added below
  }

  OptionsPrivate.commonOptions.ProgressOptionsForSubElement(parentData, data, options, 18)
  OptionsPrivate.commonOptions.PositionOptionsForSubElement(data, options, 19, areaAnchors, pointAnchors)

  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "sublineartexture")

  return options
end

  WeakAuras.RegisterSubRegionOptions("sublineartexture", createOptions, L["Shows a Linear Progress Texture"]);

=== END OF FILE: WeakAurasOptions/SubRegionOptions/LinearProgressTexture.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/Model.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function createOptions(parentData, data, index, subIndex)
  local options = {
    __title = L["Model %s"]:format(subIndex),
    __order = 1,
    model_visible = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Show Model"],
      order = 9,
    },
    model_fileId = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Model"],
      order =  10.5,
    },
    chooseModel = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order =  11,
      func = function()
        OptionsPrivate.OpenModelPicker(parentData, {"subRegions", index});
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    bar_model_attach = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Attach to Foreground"],
      order = 12,
      hidden = function() return parentData.regionType ~= "aurabar" end
    },
    bar_model_stretch = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Stretched by Foreground"],
      order = 12.1,
      hidden = function()
        return parentData.regionType ~= "aurabar" or not data.bar_model_attach
      end
    },
    bar_model_spacer ={
      type = "description",
      width = WeakAuras.normalWidth,
      name = "",
      order = 12.15,
      hidden = function()
        return parentData.regionType ~= "aurabar" or data.bar_model_attach
      end
    },
    extra_width = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Extra Width"],
      order = 12.2,
      softMin = -100,
      softMax = 500,
      step = 1,
      hidden = function() return data.bar_model_attach and parentData.regionType == "aurabar" end
    },
    extra_height = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Extra Height"],
      order = 12.3,
      softMin = -100,
      softMax = 500,
      step = 1,
      hidden = function() return data.bar_model_attach and parentData.regionType == "aurabar" end
    },
    model_alpha = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Alpha"],
      order = 13,
      min = 0,
      max = 1,
      bigStep = 0.1
    },
    api = {
      type = "toggle",
      name = L["Use SetTransform"],
      order = 14,
      width = WeakAuras.normalWidth,
    },
    model_z = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Z Offset"],
      softMin = -20,
      softMax = 20,
      step = .001,
      bigStep = 0.05,
      order = 20,
      hidden = function() return data.api end
    },
    model_x = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["X Offset"],
      softMin = -20,
      softMax = 20,
      step = .001,
      bigStep = 0.05,
      order = 30,
      hidden = function() return data.api end
    },
    model_y = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y Offset"],
      softMin = -20,
      softMax = 20,
      step = .001,
      bigStep = 0.05,
      order = 40,
      hidden = function() return data.api end
    },
    rotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 45,
      hidden = function() return data.api end
    },
    -- New Settings
    model_st_tx = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["X Offset"],
      softMin = -1000,
      softMax = 1000,
      step = 1,
      bigStep = 5,
      order = 20,
      hidden = function() return not data.api end
    },
    model_st_ty = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y Offset"],
      softMin = -1000,
      softMax = 1000,
      step = 1,
      bigStep = 5,
      order = 21,
      hidden = function() return not data.api end
    },
    model_st_tz = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Z Offset"],
      softMin = -1000,
      softMax = 1000,
      step = 1,
      bigStep = 5,
      order = 22,
      hidden = function() return not data.api end
    },
    model_st_rx = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["X Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 23,
      hidden = function() return not data.api end
    },
    model_st_ry = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Y Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 24,
      hidden = function() return not data.api end
    },
    model_st_rz = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Z Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 25,
      hidden = function() return not data.api end
    },
    model_st_us = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Scale"],
      min = 5,
      max = 1000,
      step = 0.1,
      bigStep = 5,
      order = 26,
      hidden = function() return not data.api end
    },
  }

  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "submodel")

  return options
end

WeakAuras.RegisterSubRegionOptions("submodel", createOptions, L["Shows a model"]);

=== END OF FILE: WeakAurasOptions/SubRegionOptions/Model.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/StopMotion.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local texture_types = WeakAuras.StopMotion.texture_types
local texture_data = WeakAuras.StopMotion.texture_data
local animation_types = WeakAuras.StopMotion.animation_types

local function createOptions(parentData, data, index, subIndex)

  local pointAnchors = {}
  local areaAnchors = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    Mixin(pointAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "point"))
    Mixin(areaAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "area"))
  end

  local textureNameHasData = OptionsPrivate.Private.StopMotionBase.textureNameHasData
  local setTextureFunc = OptionsPrivate.Private.StopMotionBase.setTextureFunc
  local options = {
    __title = L["Stop Motion %s"]:format(subIndex),
    __order = 1,
    stopmotionVisible = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Show Stop Motion"],
      order = 1,
    },
    stopmotionTexture = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Texture"],
      order = 2,
    },
    chooseTexture = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 3,
      func = function()
        local path = { "subRegions", index }
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(parentData, paths, {
          texture = "stopmotionTexture",
          color = "stopmotionColor",
          blendMode = "stopmotionBlendMode"
        }, texture_types, setTextureFunc)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    stopmotionColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 4
    },
    stopmotionDesaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 5,
    },
    customRows = {
        type = "input",
        width = WeakAuras.doubleWidth / 3,
        name = L["Rows"],
        validate = WeakAuras.ValidateNumeric,
        get = function()
          return data.customRows and tostring(data.customRows) or "";
        end,
        set = function(info, v)
          data.customRows = v and tonumber(v) or 0
          WeakAuras.Add(parentData)
        end,
        order = 6,
        hidden = function()
          return texture_data[data.stopmotionTexture] or textureNameHasData(data.stopmotionTexture)
        end
    },
    customColumns = {
        type = "input",
        width = WeakAuras.doubleWidth / 3,
        name = L["Columns"],
        validate = WeakAuras.ValidateNumeric,
        get = function()
          return data.customColumns and tostring(data.customColumns) or "";
        end,
        set = function(info, v)
          data.customColumns = v and tonumber(v) or 0
          WeakAuras.Add(parentData)
        end,
        order = 7,
        hidden = function()
          return texture_data[data.stopmotionTexture] or textureNameHasData(data.stopmotionTexture)
        end
    },
    customFrames = {
        type = "input",
        width = WeakAuras.doubleWidth / 3,
        name = L["Frame Count"],
        validate = WeakAuras.ValidateNumeric,
        get = function()
          return data.customFrames and tostring(data.customFrames) or "";
        end,
        set = function(info, v)
          data.customFrames = v and tonumber(v) or 0
          WeakAuras.Add(parentData)
        end,
        order = 8,
        hidden = function()
          return texture_data[data.stopmotionTexture] or textureNameHasData(data.stopmotionTexture)
        end
    },
    customFileWidth = {
      type = "input",
      width = WeakAuras.normalWidth / 2,
      name = L["File Width"],
      desc = L["Must be a power of 2"],
      validate = function(info, val)
        if val ~= nil and val ~= "" and (not tonumber(val) or tonumber(val) >= 2^31 or math.frexp(val) ~= 0.5) then
          return false;
        end
        return true
      end,
      get = function()
        return data.customFileWidth and tostring(data.customFileWidth) or "";
      end,
      set = function(info, v)
        data.customFileWidth = v and tonumber(v) or 0
        WeakAuras.Add(parentData)
      end,
      order = 9,
      hidden = function()
        return texture_data[data.stopmotionTexture] or textureNameHasData(data.stopmotionTexture)
      end
    },
    customFileHeight = {
      type = "input",
      width = WeakAuras.normalWidth / 2,
      name = L["File Height"],
      desc = L["Must be a power of 2"],
      validate = function(info, val)
        if val ~= nil and val ~= "" and (not tonumber(val) or tonumber(val) >= 2^31 or math.frexp(val) ~= 0.5) then
          return false;
        end
        return true
      end,
      get = function()
        return data.customFileHeight and tostring(data.customFileHeight) or "";
      end,
      set = function(info, v)
        data.customFileHeight = v and tonumber(v) or 0
        WeakAuras.Add(parentData)
      end,
      order = 10,
      hidden = function()
        return texture_data[data.stopmotionTexture] or textureNameHasData(data.stopmotionTexture)
      end
    },
    customFrameWidth = {
      type = "input",
      width = WeakAuras.normalWidth / 2,
      name = L["Frame Width"],
      validate = WeakAuras.ValidateNumeric,
      desc = L["Can set to 0 if Columns * Width equal File Width"],
      get = function()
        return data.customFrameWidth and tostring(data.customFrameWidth) or "";
      end,
      set = function(info, v)
        data.customFrameWidth = v and tonumber(v) or 0
        WeakAuras.Add(parentData)
      end,
      order = 11,
      hidden = function()
        return texture_data[data.stopmotionTexture] or textureNameHasData(data.stopmotionTexture)
      end
    },
    customFrameHeight = {
      type = "input",
      width = WeakAuras.normalWidth / 2,
      name = L["Frame Height"],
      validate = WeakAuras.ValidateNumeric,
      desc = L["Can set to 0 if Rows * Height equal File Height"],
      get = function()
        return data.customFrameHeight and tostring(data.customFrameHeight) or "";
      end,
      set = function(info, v)
        data.customFrameHeight = v and tonumber(v) or 0
        WeakAuras.Add(parentData)
      end,
      order = 12,
      hidden = function()
        return texture_data[data.stopmotionTexture] or textureNameHasData(data.stopmotionTexture)
      end
    },
    stopmotionBlendMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 13,
      values = OptionsPrivate.Private.blend_types
    },
    animationType = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Animation Mode"],
      order = 14,
      values = animation_types
    },

    -- progress source added below

    startPercent = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Animation Start"],
      min = 0,
      max = 1,
      bigStep = 0.01,
      order = 17,
      isPercent = true
    },
    endPercent = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Animation End"],
      min = 0,
      max = 1,
      bigStep  = 0.01,
      order = 18,
      isPercent = true
    },

    inverse = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Inverse"],
      order = 19
    },

    frameRate = {
     type = "range",
     control = "WeakAurasSpinBox",
     width = WeakAuras.normalWidth,
     name = L["Frame Rate"],
     min = 3,
     max = 120,
     step = 1,
     bigStep = 3,
     order = 20,
     disabled = function() return data.animationType == "progress" end;
    },

    -- Anchor settings added below

    barModelClip = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Clipped by Foreground"],
      order = 27,
      hidden = function()
        return not (parentData.regionType == "aurabar"
                    and data.anchor_mode == "area"
                    and data.anchor_area == "fg")
      end
    },

    scale = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Scale Factor"],
      order = 28,
      softMin = 0.5,
      softMax = 3,
      step = 0.1,
      hidden = function()
        if parentData.regionType == "aurabar"
          and data.anchorMode == "area"
          and data.anchor_area == "fg"
          and data.barModelClip
        then
          return true
        end
        return data.anchor_mode ~= "area"
      end
    },
  }

  local progressSourceHiden = function()
    return not(data.animationType == "progress")
  end

  OptionsPrivate.commonOptions.ProgressOptionsForSubElement(parentData, data, options, 15, progressSourceHiden)
  OptionsPrivate.commonOptions.PositionOptionsForSubElement(data, options, 21, areaAnchors, pointAnchors)
  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "substopmotion")

  return options
end

  WeakAuras.RegisterSubRegionOptions("substopmotion", createOptions, L["Shows a Stop Motion"]);

=== END OF FILE: WeakAurasOptions/SubRegionOptions/StopMotion.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/SubRegionCommon.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Magic constant
local deleteCondition = {}

local function AdjustConditions(data, replacements)
  if (data.conditions) then
    for conditionIndex, condition in ipairs(data.conditions) do
      for changeIndex, change in ipairs(condition.changes) do
        if change.property then
          local sub, rest = string.match(change.property, "^(sub.%d+%.)(.+)$")
          if sub and replacements[sub] then
            if replacements[sub] == deleteCondition then
              change.property = nil
            else
              change.property = replacements[sub] .. rest
            end
          end
        end
      end
    end
  end
end

local function ReplacePrefix(hay, replacements)
  for old, new in pairs(replacements) do
    if hay:sub(1, #old) == old then
      return new .. hay:sub(#old + 1)
    end
  end
end

local function AdjustAnchors(data, replacements)
  if not data.subRegions then
    return
  end

  for _, subRegionData in ipairs(data.subRegions) do
    local anchor_area = subRegionData.anchor_area
    if anchor_area then
      local replaced = ReplacePrefix(anchor_area, replacements)
      if replaced then
        subRegionData.anchor_area = replaced
      end
    end
    local anchor_point = subRegionData.anchor_point
    if anchor_point then
      local replaced = ReplacePrefix(anchor_point, replacements)
      if replaced then
        subRegionData.anchor_point = replaced
      end
    end
  end
end

function OptionsPrivate.DeleteSubRegion(data, index, regionType)
  if not data.subRegions then
    return
  end
  if data.subRegions[index] and data.subRegions[index].type == regionType then
    tremove(data.subRegions, index)

    local replacements = {
      ["sub." .. index .. "."] = deleteCondition
    }

    for i = index + 1, #data.subRegions + 1 do
      replacements["sub." .. i .. "."] = "sub." .. (i - 1) .. "."
    end

    AdjustConditions(data, replacements);
    AdjustAnchors(data, replacements)

    WeakAuras.Add(data)
    OptionsPrivate.ClearOptions(data.id)
  end
end

function OptionsPrivate.MoveSubRegionUp(data, index, regionType)
  if not data.subRegions or index <= 1 then
    return
  end
  if data.subRegions[index] and data.subRegions[index].type == regionType then
    data.subRegions[index - 1], data.subRegions[index] = data.subRegions[index], data.subRegions[index - 1]

    local replacements = {
      ["sub." .. (index -1) .. "."] = "sub." .. index .. ".",
      ["sub." .. index .. "."] = "sub." .. (index - 1) .. ".",
    }

    AdjustConditions(data, replacements);
    AdjustAnchors(data, replacements)

    WeakAuras.Add(data)
    OptionsPrivate.ClearOptions(data.id)
  end
end

function OptionsPrivate.MoveSubRegionDown(data, index, regionType)
  if not data.subRegions then
    return
  end
  if data.subRegions[index] and data.subRegions[index].type == regionType and data.subRegions[index + 1] then
    data.subRegions[index], data.subRegions[index + 1] = data.subRegions[index + 1], data.subRegions[index]

    local replacements = {
      ["sub." .. index .. "."] = "sub." .. (index + 1) .. ".",
      ["sub." .. (index + 1) .. "."] = "sub." .. index .. ".",
    }

    AdjustConditions(data, replacements);
    AdjustAnchors(data, replacements)

    WeakAuras.Add(data)
    OptionsPrivate.ClearOptions(data.id)
  end
end

function OptionsPrivate.DuplicateSubRegion(data, index, regionType)
  if not data.subRegions then
    return
  end
  if data.subRegions[index] and data.subRegions[index].type == regionType then
    tinsert(data.subRegions, index, CopyTable(data.subRegions[index]))


    local replacements = {}
    for i = index + 1, #data.subRegions do
      replacements["sub." .. i .. "."] = "sub." .. (i + 1) .. "."
    end
    AdjustConditions(data, replacements)
    AdjustAnchors(data, replacements)

    WeakAuras.Add(data)
    OptionsPrivate.ClearOptions(data.id)
  end
end

function OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, subRegionType)
  options.__up = function()
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
      OptionsPrivate.MoveSubRegionUp(child, index, subRegionType)
    end
    WeakAuras.ClearAndUpdateOptions(parentData.id)
  end
  options.__down = function()
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
      OptionsPrivate.MoveSubRegionDown(child, index, subRegionType)
    end
    WeakAuras.ClearAndUpdateOptions(parentData.id)
  end
  options.__duplicate = function()
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
      OptionsPrivate.DuplicateSubRegion(child, index, subRegionType)
    end
    WeakAuras.ClearAndUpdateOptions(parentData.id)
  end
  options.__delete = function()
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
      OptionsPrivate.DeleteSubRegion(child, index, subRegionType)
    end
    WeakAuras.ClearAndUpdateOptions(parentData.id)
  end
end

=== END OF FILE: WeakAurasOptions/SubRegionOptions/SubRegionCommon.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/SubText.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20

local self_point_types = {
  BOTTOMLEFT = L["Bottom Left"],
  BOTTOM = L["Bottom"],
  BOTTOMRIGHT = L["Bottom Right"],
  RIGHT = L["Right"],
  TOPRIGHT = L["Top Right"],
  TOP = L["Top"],
  TOPLEFT = L["Top Left"],
  LEFT = L["Left"],
  CENTER = L["Center"],
  AUTO = L["Automatic"]
}

local dynamicTextInputs = {}

local function createOptions(parentData, data, index, subIndex)
  -- The toggles for font flags is intentionally not keyed on the id
  -- So that all auras share the state of that toggle
  local hiddenFontExtra = function()
    return OptionsPrivate.IsCollapsed("subtext", "subtext", "fontflags" .. index, true)
  end

  local indentWidth = 0.15

  local options = {
    __title = L["Text %s"]:format(subIndex),
    __order = 1,
    text_visible = {
      type = "toggle",
      width = WeakAuras.halfWidth,
      order = 9,
      name = L["Show Text"],
    },
    text_color = {
      type = "color",
      width = WeakAuras.halfWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 10,
    },
    text_text = {
      type = "input",
      width = WeakAuras.normalWidth - 0.15,
      name = L["Display Text"],
      order = 11,
      set = function(info, v)
        data.text_text = OptionsPrivate.Private.ReplaceLocalizedRaidMarkers(v)
        local metaData = OptionsPrivate.Private.GetAdditionalProperties(parentData)
        OptionsPrivate.Private.SetDefaultFormatters(data, data.text_text, "text_text_format_", metaData)

        WeakAuras.Add(parentData)
        WeakAuras.ClearAndUpdateOptions(parentData.id)
      end,
      control = "WeakAurasInputWithIndentation",
      callbacks = {
        OnEditFocusGained = function(self)
          local widget = dynamicTextInputs[subIndex]
          OptionsPrivate.ToggleTextReplacements(parentData, widget, "OnEditFocusGained")
        end,
        OnEditFocusLost = function(self)
          OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEditFocusLost")
        end,
        OnEnterPressed = function(self)
          OptionsPrivate.ToggleTextReplacements(nil, nil, "OnEnterPressed")
        end,
        OnShow = function(self)
          dynamicTextInputs[subIndex] = self
        end,
      }
    },
    text_replacements_button = {
      type = "execute",
      width = 0.15,
      name = L["Dynamic Text Replacements"],
      desc = L["There are several special codes available to make this text dynamic. Click to view a list with all dynamic text codes."],
      order = 11.1,
      func = function()
        local widget = dynamicTextInputs[subIndex]
        OptionsPrivate.ToggleTextReplacements(parentData, widget, "ToggleButton")
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\sidebar",
    },
    text_font = {
      type = "select",
      width = WeakAuras.normalWidth,
      dialogControl = "LSM30_Font",
      name = L["Font"],
      order = 13,
      values = AceGUIWidgetLSMlists.font,
    },
    text_fontSize = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Size"],
      order = 14,
      min = 6,
      softMax = 72,
      step = 1,
    },
    text_fontFlagsDescription = {
      type = "execute",
      control = "WeakAurasExpandSmall",
      name = function()
        local textFlags = OptionsPrivate.Private.font_flags[data.text_fontType]
        local color = format("%02x%02x%02x%02x",
                             data.text_shadowColor[4] * 255, data.text_shadowColor[1] * 255,
                             data.text_shadowColor[2] * 255, data.text_shadowColor[3]*255)

        local textJustify = ""
        if data.text_justify == "CENTER" then
          -- CENTER is default
        elseif data.text_justify == "LEFT" then
          textJustify = " " .. L["and aligned left"]
        elseif data.text_justify == "RIGHT" then
          textJustify = " " ..  L["and aligned right"]
        end

        local textRotate = ""
        if data.rotateText == "LEFT" then
          textRotate = " " .. L["and rotated left"]
        elseif data.rotateText == "RIGHT" then
          textRotate = " " .. L["and rotated right"]
        end

        local textWidth = ""
        if data.text_automaticWidth == "Fixed" then
          local wordWarp = ""
          if data.text_wordWrap == "WordWrap" then
            wordWarp = L["wrapping"]
          else
            wordWarp = L["eliding"]
          end
          textWidth = " "..L["and with width |cFFFF0000%s|r and %s"]:format(data.text_fixedWidth, wordWarp)
        end

        local secondline
          = L["|cFFffcc00Font Flags:|r |cFFFF0000%s|r and shadow |c%sColor|r with offset |cFFFF0000%s/%s|r%s%s%s"]
            :format(textFlags, color, data.text_shadowXOffset, data.text_shadowYOffset,
                    textRotate, textJustify, textWidth)

        return secondline
      end,
      width = WeakAuras.doubleWidth,
      order = 44,
      func = function(info, button)
        local collapsed = OptionsPrivate.IsCollapsed("subtext", "subtext", "fontflags" .. index, true)
        OptionsPrivate.SetCollapsed("subtext", "subtext", "fontflags" .. index, not collapsed)
      end,
      image = function()
        local collapsed = OptionsPrivate.IsCollapsed("subtext", "subtext", "fontflags" .. index, true)
        return collapsed and "collapsed" or "expanded"
      end,
      imageWidth = 15,
      imageHeight = 15,
      arg = {
        expanderName = "subtext" .. index .. "#" .. subIndex
      }
    },

    text_font_space = {
      type = "description",
      name = "",
      order = 45,
      hidden = hiddenFontExtra,
      width = indentWidth
    },

    text_fontType = {
      type = "select",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Outline"],
      order = 46,
      values = OptionsPrivate.Private.font_flags,
      hidden = hiddenFontExtra
    },
    text_shadowColor = {
      type = "color",
      hasAlpha = true,
      width = WeakAuras.normalWidth,
      name = L["Shadow Color"],
      order = 47,
      hidden = hiddenFontExtra
    },

    text_font_space3 = {
      type = "description",
      name = "",
      order = 47.5,
      hidden = hiddenFontExtra,
      width = indentWidth
    },
    text_shadowXOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Shadow X Offset"],
      softMin = -15,
      softMax = 15,
      bigStep = 1,
      order = 48,
      hidden = hiddenFontExtra
    },
    text_shadowYOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Shadow Y Offset"],
      softMin = -15,
      softMax = 15,
      bigStep = 1,
      order = 49,
      hidden = hiddenFontExtra
    },

    text_font_space4 = {
      type = "description",
      name = "",
      order = 49.5,
      hidden = hiddenFontExtra,
      width = indentWidth
    },
    rotateText = {
      type = "select",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Rotate Text"],
      values = OptionsPrivate.Private.text_rotate_types,
      order = 50,
      hidden = hiddenFontExtra
    },
    text_justify = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Alignment"],
      values = OptionsPrivate.Private.justify_types,
      order = 50.5,
      hidden = hiddenFontExtra
    },
    text_font_space5 = {
      type = "description",
      name = "",
      order = 51,
      hidden = hiddenFontExtra,
      width = indentWidth
    },
    text_automaticWidth = {
      type = "select",
      width = WeakAuras.normalWidth - indentWidth,
      name = L["Width"],
      order = 51.5,
      values = OptionsPrivate.Private.text_automatic_width,
      hidden = hiddenFontExtra
    },
    text_font_space6 = {
      type = "description",
      name = "",
      order = 52,
      hidden = hiddenFontExtra,
      width = WeakAuras.normalWidth
    },
    text_font_space7 = {
      type = "description",
      name = "",
      order = 52.5,
      width = indentWidth,
      hidden = function() return hiddenFontExtra() or data.text_automaticWidth ~= "Fixed" end
    },
    text_fixedWidth = {
      name = L["Width"],
      width = WeakAuras.normalWidth - indentWidth,
      order = 53,
      type = "range",
      control = "WeakAurasSpinBox",
      min = 1,
      softMax = 200,
      bigStep = 1,
      hidden = function() return hiddenFontExtra() or data.text_automaticWidth ~= "Fixed" end
    },
    text_wordWrap = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Overflow"],
      order = 54,
      values = OptionsPrivate.Private.text_word_wrap,
      hidden = function() return hiddenFontExtra() or data.text_automaticWidth ~= "Fixed" end
    },

    text_anchor = {
      type = "description",
      name = "",
      order = 55,
      hidden = hiddenFontExtra,
      control = "WeakAurasExpandAnchor",
      arg = {
        expanderName = "subtext" .. index .. "#" .. subIndex
      }
    }
  }

  -- Note: Anchor Options need to be generalized once there are multiple sub regions
  -- While every sub region will have anchor options, the initial
  -- design I had for anchor options proved to be not general enough for
  -- what SubText needed. So, I removed it, and postponed making it work for unknown future
  -- sub regions
  local anchors = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    Mixin(anchors, OptionsPrivate.Private.GetAnchorsForData(child, "point"))
  end

  -- Anchor Options
  options.text_anchorsDescription = {
    type = "execute",
    control = "WeakAurasExpandSmall",
    name = function()
      local selfPoint = data.text_selfPoint ~= "AUTO" and self_point_types[data.text_selfPoint]
      local anchorPoint = anchors[data.anchor_point or "CENTER"] or anchors["CENTER"]

      local xOffset = data.text_anchorXOffset or 0
      local yOffset = data.text_anchorYOffset or 0

      if (type(anchorPoint) == "table") then
        anchorPoint = anchorPoint[1] .. "/" .. anchorPoint[2]
      end

      if selfPoint then
        if xOffset == 0 and yOffset == 0 then
          return L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r"]
                 :format(selfPoint, anchorPoint)
        else
          return L["|cFFffcc00Anchors:|r Anchored |cFFFF0000%s|r to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"]
                 :format(selfPoint, anchorPoint, xOffset, yOffset)
        end
      else
        if xOffset == 0 and yOffset == 0 then
          return L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r"]:format(anchorPoint)
        else
          return L["|cFFffcc00Anchors:|r Anchored to frame's |cFFFF0000%s|r with offset |cFFFF0000%s/%s|r"]
                 :format(anchorPoint, xOffset, yOffset)
        end
      end
    end,
    width = WeakAuras.doubleWidth,
    order = 60,
    image = function()
      local collapsed = OptionsPrivate.IsCollapsed("subregion", "text_anchors", tostring(index), true)
      return collapsed and "collapsed" or "expanded"
    end,
    imageWidth = 15,
    imageHeight = 15,
    func = function(info, button)
      local collapsed = OptionsPrivate.IsCollapsed("subregion", "text_anchors", tostring(index), true)
      OptionsPrivate.SetCollapsed("subregion", "text_anchors", tostring(index), not collapsed)
    end,
    arg = {
      expanderName = "subtext_anchor" .. index .. "#" .. subIndex
    }
  }


  local hiddenFunction = function()
    return OptionsPrivate.IsCollapsed("subregion", "text_anchors", tostring(index), true)
  end

  options.text_anchor_space = {
    type = "description",
    name = "",
    order = 60.15,
    hidden = hiddenFunction,
    width = indentWidth
  }

  options.text_selfPoint = {
    type = "select",
    width = WeakAuras.normalWidth - indentWidth,
    name = L["Anchor"],
    order = 60.2,
    values = self_point_types,
    hidden = hiddenFunction
  }

  options.anchor_point = {
    type = "select",
    width = WeakAuras.normalWidth,
    name = function()
      return L["To Frame's"]
    end,
    order = 60.3,
    values = anchors,
    hidden = hiddenFunction,
    control = "WeakAurasTwoColumnDropdown"
  }

  options.text_anchor_space2 = {
    type = "description",
    name = "",
    order = 60.35,
    hidden = hiddenFunction,
    width = indentWidth
  }

  options.text_anchorXOffset = {
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth - indentWidth,
    name = L["X Offset"],
    order = 60.4,
    softMin = (-1 * screenWidth),
    softMax = screenWidth,
    bigStep = 10,
    hidden = hiddenFunction
  }

  options.text_anchorYOffset = {
    type = "range",
    control = "WeakAurasSpinBox",
    width = WeakAuras.normalWidth,
    name = L["Y Offset"],
    order = 60.5,
    softMin = (-1 * screenHeight),
    softMax = screenHeight,
    bigStep = 10,
    hidden = hiddenFunction
  }

  options.text_anchor_anchor = {
    type = "description",
    name = "",
    order = 61,
    hidden = hiddenFunction,
    control = "WeakAurasExpandAnchor",
    arg = {
      expanderName = "subtext_anchor" .. index .. "#" .. subIndex
    }
  }

  local function hideCustomTextOption()
    if not parentData.subRegions then
      return true
    end

    for _, subRegion in ipairs(parentData.subRegions) do
      if subRegion.type == "subtext" and OptionsPrivate.Private.ContainsCustomPlaceHolder(subRegion.text_text) then
        return false
      end
    end

    if type(parentData.conditions) == "table" then
      for _, condition in ipairs(parentData.conditions) do
        if type(condition.changes) == "table" then
          for _, change in ipairs(condition.changes) do
            if type(change.property) == "string"
            and change.property:match("sub%.%d+%.text_text")
            and type(change.value) == "string"
            and OptionsPrivate.Private.ContainsCustomPlaceHolder(change.value)
            then
              return false
            end
          end
        end
      end
    end

    return true
  end

  local commonTextOptions = {
    __title = L["Common Text"],
    __hidden = function() return hideCustomTextOption() end,
    text_customTextUpdate = {
      type = "select",
      width = WeakAuras.doubleWidth,
      hidden = hideCustomTextOption,
      name = L["Update Custom Text On..."],
      values = OptionsPrivate.Private.text_check_types,
      order = 3,
      get = function() return parentData.customTextUpdate or "event" end,
      set = function(info, v)
        parentData.customTextUpdate = v
        WeakAuras.Add(parentData)
        WeakAuras.ClearAndUpdateOptions(parentData.id)
      end
    },
    text_customTextUpdateThrottle = {
      type = "range",
      control = "WeakAurasSpinBox",
      softMin = 0,
      softMax = 5,
      bigStep = 0.1,
      min = 0,
      width = WeakAuras.doubleWidth,
      name = L["Custom Text Update Throttle"],
      order = 3.01,
      get = function() return parentData.customTextUpdateThrottle or 0 end,
      set = function(info, v)
        v = tonumber(v) or 0
        if v < 0 then
          v = 0
        end
        parentData.customTextUpdateThrottle = v
        WeakAuras.Add(parentData)
        WeakAuras.ClearAndUpdateOptions(parentData.id)
      end,
      hidden = function()
        return hideCustomTextOption() or (parentData.customTextUpdate ~= "update")
      end
    }
  }

  OptionsPrivate.commonOptions.AddCodeOption(commonTextOptions, parentData, L["Custom Function"], "customText",
                          "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-text",
                          4,  hideCustomTextOption, {"customText"}, false)

  -- Add Text Format Options
  local hidden = function()
    return OptionsPrivate.IsCollapsed("format_option", "text", "text_text" .. index, true)
  end

  local setHidden = function(hidden)
    OptionsPrivate.SetCollapsed("format_option", "text", "text_text" .. index, hidden)
  end

  local order = 12
  local function addOption(key, option)
    option.order = order
    order = order + 0.01
    if option.reloadOptions then
      option.reloadOptions = nil
      option.set = function(info, v)
        data["text_text_format_" .. key] = v
        WeakAuras.Add(parentData)
        WeakAuras.ClearAndUpdateOptions(parentData.id, true)
      end
    end
    options["text_text_format_" .. key] = option
  end

  local list = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    if child.subRegions then
      local childSubRegion = child.subRegions[index]
      if childSubRegion then
        tinsert(list, child)
      end
    end
  end

  for listIndex, child in ipairs(list) do
    local childSubRegion = child.subRegions[index]
    local get = function(key)
      return childSubRegion["text_text_format_" .. key]
    end
    local texts = {}
    if type(childSubRegion.text_text) == "string" and childSubRegion.text_text ~= "" then
      -- found text of subregion
      tinsert(texts, childSubRegion.text_text)
    end

    for _, condition in ipairs(child.conditions) do
      if type(condition.changes) == "table" then
        for _, change in ipairs(condition.changes) do
          if change.property == "sub."..index..".text_text"
            and type(change.value) == "string"
            and change.value ~= ""
          then
            -- found a condition editing text of that subregion
            tinsert(texts, change.value)
          end
        end
      end
    end
    OptionsPrivate.AddTextFormatOption(texts, true, get, addOption, hidden, setHidden, false, listIndex, #list)
  end

  addOption("footer", {
    type = "description",
    name = "",
    width = WeakAuras.doubleWidth,
    hidden = hidden
  })

  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "subtext")

  return options, commonTextOptions
end

WeakAuras.RegisterSubRegionOptions("subtext", createOptions,
 L["Shows one or more lines of text, which can include dynamic information such as progress or stacks"])

=== END OF FILE: WeakAurasOptions/SubRegionOptions/SubText.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/Texture.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function createOptions(parentData, data, index, subIndex)
  local pointAnchors = {}
  local areaAnchors = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
    Mixin(pointAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "point"))
    Mixin(areaAnchors, OptionsPrivate.Private.GetAnchorsForData(child, "area"))
  end

  local options = {
    __title = L["Texture %s"]:format(subIndex),
    __order = 1,
    textureVisible = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Show Texture"],
      order = 1,
    },
    textureTexture = {
      type = "input",
      width = WeakAuras.doubleWidth - 0.15,
      name = L["Texture"],
      order = 2,
    },
    chooseTexture = {
      type = "execute",
      width = 0.15,
      name = L["Choose"],
      order = 2.1,
      func = function()
        local path = { "subRegions", index }
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(parentData, paths, {
          texture = "textureTexture",
          color = "textureColor",
          mirror = "textureMirror",
          blendMode = "textureBlendMode"
        }, OptionsPrivate.Private.texture_types)
      end,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    textureColor = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      hasAlpha = true,
      order = 3
    },
    textureDesaturate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Desaturate"],
      order = 4,
    },
    textureBlendMode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 11,
      values = OptionsPrivate.Private.blend_types
    },
    textureMirror = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Mirror"],
      order = 12
    },

    textureRotate = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Allow Full Rotation"],
      order = 13,
      hidden = data and OptionsPrivate.Private.TextureBase.IsAtlas(data.texture)
    },
    textureRotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      min = 0,
      max = 360,
      step = 1,
      bigStep = 3,
      order = 14,
    },
  }

  OptionsPrivate.commonOptions.PositionOptionsForSubElement(data, options, 15, areaAnchors, pointAnchors)
  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "subtexture")

  return options
end

  WeakAuras.RegisterSubRegionOptions("subtexture", createOptions, L["Shows a Texture"]);

=== END OF FILE: WeakAurasOptions/SubRegionOptions/Texture.lua ===


=== FILE: WeakAurasOptions/SubRegionOptions/Tick.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L;

local function createOptions(parentData, data, index, subIndex)
  local hiddentickextras = function()
    return OptionsPrivate.IsCollapsed("subtext", "subtext", "tickextras" .. index, true)
  end
  local options = {
    __title = L["Tick %s"]:format(subIndex),
    __order = 1,
    tick_visible = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Show Tick"],
      order = 1,
    },
    tick_color = {
      type = "color",
      width = WeakAuras.normalWidth,
      name = L["Color"],
      order = 2,
      hasAlpha = true,
    },

    tick_thickness = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Thickness"],
      order = 2.5,
      min = 0,
      softMax = 20,
      step = 1,
    },

    tick_progress_source_space = {
      type = "description",
      name = "",
      order = 3,
      width = WeakAuras.normalWidth,
    },

    tick_placement_mode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Tick Mode"],
      order = 3.1,
      values = OptionsPrivate.Private.tick_placement_modes,
    },


    tick_progress_source_space_2 = {
      type = "description",
      name = "",
      order = 3.2,
      width = WeakAuras.normalWidth,
    },

    tick_add = {
      type = "execute",
      name = L["Add"],
      order = 5,
      width = WeakAuras.normalWidth,
      func = function()
        tinsert(data.tick_placements, 0)
        WeakAuras.Add(parentData)
        WeakAuras.ClearAndUpdateOptions(parentData.id)
      end
    },

    tick_extrasDescription = {
      type = "execute",
      control = "WeakAurasExpandSmall",
      name = function()
        local lengthtext = ""
        if data.automatic_length then
          lengthtext = L["|cFFFF0000Automatic|r length"]
        else
          lengthtext = L["Length of |cFFFF0000%s|r"]:format(data.tick_length)
        end

        local texturetext = ""
        if data.use_texture then
          local desaturatetext = data.tick_desaturate and L["|cFFFF0000desaturated|r "] or ""
          local blendtext = OptionsPrivate.Private.blend_types[data.tick_blend_mode]
          local rotationtext = data.tick_rotation ~= 0 and L[" rotated |cFFFF0000%s|r degrees"]:format(data.tick_rotation) or ""
          local mirrortext = data.tick_mirror and L[" and |cFFFF0000mirrored|r"] or ""
          texturetext = L["%s|cFFFF0000custom|r texture with |cFFFF0000%s|r blend mode%s%s"]:format(desaturatetext, blendtext, rotationtext, mirrortext)
        else
          texturetext = L["|cFFFF0000default|r texture"]
        end

        local offsettext = ""
        if data.tick_xOffset ~=0 or data.tick_yOffset ~=0 then
          offsettext = L["Offset by |cFFFF0000%s|r/|cFFFF0000%s|r"]:format(data.tick_xOffset, data.tick_yOffset)
        end

        local description = L["|cFFffcc00Extra:|r %s and %s %s"]:format(lengthtext, texturetext, offsettext)

        return description
      end,
      width = WeakAuras.doubleWidth,
      order = 7,
      func = function(info, button)
        local collapsed = OptionsPrivate.IsCollapsed("subtext", "subtext", "tickextras" .. index, true)
        OptionsPrivate.SetCollapsed("subtext", "subtext", "tickextras" .. index, not collapsed)
      end,
      image = function()
        local collapsed = OptionsPrivate.IsCollapsed("subtext", "subtext", "tickextras" .. index, true)
        return collapsed and "collapsed" or "expanded"
      end,
      imageWidth = 15,
      imageHeight = 15,
      arg = {
        expanderName = "tick" .. index .. "#" .. subIndex
      }
    },
    automatic_length = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Automatic length"],
      order = 8,
      desc = L["Matches the height setting of a horizontal bar or width for a vertical bar."],
      hidden = hiddentickextras,
    },
    tick_length = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Length"],
      order = 9,
      min = 0,
      softMax = 50,
      step = 1,
      disabled = function() return data.automatic_length end,
      hidden = hiddentickextras,
    },
    use_texture = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Use Texture"],
      order = 10,
      hidden = hiddentickextras,
    },
    tick_blend_mode = {
      type = "select",
      width = WeakAuras.normalWidth,
      name = L["Blend Mode"],
      order = 11,
      values = OptionsPrivate.Private.blend_types,
      disabled = function() return not data.use_texture end,
      hidden = hiddentickextras,
    },
    tick_texture = {
      type = "input",
      name = L["Texture"],
      order = 12,
      width = WeakAuras.doubleWidth - 0.15,
      disabled = function() return not data.use_texture end,
      hidden = hiddentickextras,
    },
    texture_chooser = {
      type = "execute",
      name = L["Choose"],
      width = 0.15,
      order = 12.5,
      func = function()
        local path = { "subRegions", index }
        local paths = {}
        for child in OptionsPrivate.Private.TraverseLeafsOrAura(parentData) do
          paths[child.id] = path
        end
        OptionsPrivate.OpenTexturePicker(parentData, paths, {
          texture = "tick_texture",
          color = "tick_color",
          blendMode = "tick_blend_mode"
        }, OptionsPrivate.Private.texture_types);
      end,
      disabled = function() return not data.use_texture end,
      hidden = hiddentickextras,
      imageWidth = 24,
      imageHeight = 24,
      control = "WeakAurasIcon",
      image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\browse",
    },
    tick_desaturate = {
      type = "toggle",
      width = WeakAuras.doubleWidth,
      name = L["Desaturate"],
      order = 13,
      hidden = hiddentickextras,
    },
    tick_rotation = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["Rotation"],
      min = 0,
      max = 360,
      step = 1,
      order = 14,
      hidden = hiddentickextras,
    },
    tick_mirror = {
      type = "toggle",
      width = WeakAuras.normalWidth,
      name = L["Mirror"],
      order = 15,
      disabled = function() return not data.use_texture end,
      hidden = hiddentickextras,
    },
    tick_xOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["x-Offset"],
      order = 16,
      softMin = -200,
      softMax = 200,
      step = 1,
      hidden = hiddentickextras,
    },
    tick_yOffset = {
      type = "range",
      control = "WeakAurasSpinBox",
      width = WeakAuras.normalWidth,
      name = L["y-Offset"],
      order = 17,
      softMin = -200,
      softMax = 200,
      step = 1,
      hidden = hiddentickextras,
    },

    tick_anchor = {
      type = "description",
      name = "",
      order = 18,
      hidden = hiddentickextras,
      control = "WeakAurasExpandAnchor",
      arg = {
        expanderName = "tick" .. index .. "#" .. subIndex
      }
    }
  }

  if data then
    for i in ipairs(data.tick_placements) do
      options["tick_progress_source" .. i] = {
        type = "select",
        width = WeakAuras.normalWidth,
        name = L["Progress Source"],
        order = 4 + i / 100,
        control = "WeakAurasTwoColumnDropdown",
        values = OptionsPrivate.Private.GetProgressSourcesForUi(parentData, true),
        get = function(info)
          return OptionsPrivate.Private.GetProgressValueConstant(data.progressSources[i] or {-2, ""})
        end,
        set = function(info, value)
          if value then
            data.progressSources = data.progressSources or {}
            data.progressSources[i] = data.progressSources[i] or {}
            -- Copy only trigger + property
            data.progressSources[i][1] = value[1]
            data.progressSources[i][2] = value[2]
          else
            data.progressSources[i] = nil
          end
          WeakAuras.Add(parentData)
        end,
        hidden = function()
          return not(data.tick_placement_mode == "ValueOffset")
        end
      }

      options["tick_placement" .. i] = {
        type = "input",
        width = WeakAuras.normalWidth - 0.15,
        name = L["Tick Placement"],
        order = 4 + i / 100 + 0.001,
        validate = WeakAuras.ValidateNumeric,
        desc = L["Enter in a value for the tick's placement."],
        get = function(info)
          return data.tick_placements[i] or ""
        end,
        set = function(info, value)
          data.tick_placements[i] = value
          WeakAuras.Add(parentData)
        end
      }

      options["tick_placement_delete" .. i] = {
        type = "execute",
        width = 0.15,
        name = L["Delete"],
        order = 4 + i / 100 + 0.002,
        func = function()
          tremove(data.tick_placements, i)
          WeakAuras.Add(parentData)
          WeakAuras.ClearAndUpdateOptions(parentData.id)
        end,
        image = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\delete",
        imageWidth = 24,
        imageHeight = 24,
        control = "WeakAurasIcon",
        disabled = function()
          return #data.tick_placements < 2
        end
      }
    end
  end

  OptionsPrivate.AddUpDownDeleteDuplicate(options, parentData, index, "subtick")

  return options
end

local getAnchors = function(data)
  local anchors = {}
  for i in ipairs(data.tick_placements) do
    anchors["tick."..i] = {
      display = L["Tick Center %s"]:format(i),
      type = "point"
    }
    anchors["tickarea."..i] = {
      display = L["Tick Area %s"]:format(i),
      type = "area"
    }
  end
  return anchors
end

WeakAuras.RegisterSubRegionOptions("subtick", createOptions, L["Places a tick on the bar"], getAnchors)

=== END OF FILE: WeakAurasOptions/SubRegionOptions/Tick.lua ===


=== FILE: WeakAurasOptions/TriggerOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

local L = WeakAuras.L

local removeFuncs = OptionsPrivate.commonOptions.removeFuncs
local replaceNameDescFuncs = OptionsPrivate.commonOptions.replaceNameDescFuncs
local replaceImageFuncs = OptionsPrivate.commonOptions.replaceImageFuncs
local replaceValuesFuncs = OptionsPrivate.commonOptions.replaceValuesFuncs
local disabledAll = OptionsPrivate.commonOptions.CreateDisabledAll("trigger")
local hiddenAll = OptionsPrivate.commonOptions.CreateHiddenAll("trigger")
local getAll = OptionsPrivate.commonOptions.CreateGetAll("trigger")
local setAll = OptionsPrivate.commonOptions.CreateSetAll("trigger", getAll)
local executeAll = OptionsPrivate.commonOptions.CreateExecuteAll("trigger")

local flattenRegionOptions = OptionsPrivate.commonOptions.flattenRegionOptions
local fixMetaOrders = OptionsPrivate.commonOptions.fixMetaOrders

local function union(table1, table2)
  local meta = {};
  for i,v in pairs(table1) do
    meta[i] = v;
  end
  for i,v in pairs(table2) do
    meta[i] = v;
  end
  return meta;
end

local function GetGlobalOptions(data)

  local globalTriggerOptions = {
    __title = L["Trigger Combination"],
    __order = 1,
    disjunctive = {
      type = "select",
      name = L["Required for Activation"],
      width = WeakAuras.doubleWidth,
      order = 2,
      values = function()
        if #data.triggers > 1 then
          return OptionsPrivate.Private.trigger_require_types;
        else
          return  OptionsPrivate.Private.trigger_require_types_one;
        end
      end,
      get = function()
        if #data.triggers > 1 then
          return data.triggers.disjunctive or "all";
        else
          return (data.triggers.disjunctive and data.triggers.disjunctive ~= "all") and data.triggers.disjunctive or "any";
        end
      end,
      set = function(info, v)
        data.triggers.disjunctive = v;
        WeakAuras.Add(data);
      end
    },
    -- custom trigger combiner text editor added below
    activeTriggerMode = {
      type = "select",
      name = L["Dynamic Information"],
      width = WeakAuras.doubleWidth,
      order = 2.3,
      values = function()
        local vals = {};
        vals[OptionsPrivate.Private.trigger_modes.first_active] = L["Dynamic information from first active trigger"];
        for i = 1, #data.triggers do
          vals[i] = L["Dynamic information from Trigger %i"]:format(i);
        end
        return vals;
      end,
      get = function()
        return data.triggers.activeTriggerMode or OptionsPrivate.Private.trigger_modes.first_active;
      end,
      set = function(info, v)
        data.triggers.activeTriggerMode = v;
        WeakAuras.Add(data);
        WeakAuras.UpdateThumbnail(data);
      end,
      hidden = function() return #data.triggers <= 1 end
    }
  }

  local function hideTriggerCombiner()
    return not (data.triggers.disjunctive == "custom")
  end
  OptionsPrivate.commonOptions.AddCodeOption(globalTriggerOptions, data, L["Custom"], "custom_trigger_combination", "https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Code-Blocks#custom-activation",
                          2.4, hideTriggerCombiner, {"triggers", "customTriggerLogic"}, false);

  return {
    global = globalTriggerOptions
  }
end

local collapsedId = {}
local maxTriggerNumForExpand = 0

local function AddOptions(allOptions, data)
  allOptions = union(allOptions, GetGlobalOptions(data))

  local triggerOptions = {}
  for index, trigger in ipairs(data.triggers) do
    local triggerSystemOptionsFunction = trigger.trigger.type and OptionsPrivate.Private.triggerTypesOptions[trigger.trigger.type]
    if (triggerSystemOptionsFunction) then
      triggerOptions = union(triggerOptions, triggerSystemOptionsFunction(data, index))
    else
      -- Unknown trigger system, empty options
      local options = {};
      OptionsPrivate.commonOptions.AddCommonTriggerOptions(options, data, index)
      OptionsPrivate.AddTriggerMetaFunctions(options, data, index)
      triggerOptions = union(triggerOptions, {
          ["trigger." .. index .. ".unknown"] = options
      })
    end
  end

  triggerOptions["addTriggerOption"] = {
    __title = L["Add Trigger"],
    __order = 5000,
    __withoutheader = true,
    __topLine = true,
    __collapsed = false,
    addTrigger = {
      type = "execute",
      width = WeakAuras.normalWidth,
      name = L["Add Trigger"],
      order = 1,
      func = function()
        tinsert(data.triggers,
          {
            trigger =
            {
              type = "aura2"
            },
            untrigger = {
            }
          })
        WeakAuras.Add(data)
        OptionsPrivate.SetCollapsed(collapsedId, "trigger", #data.triggers, false)
        maxTriggerNumForExpand = max(maxTriggerNumForExpand, #data.triggers)
        WeakAuras.ClearAndUpdateOptions(data.id)
      end
    }
  }

  return union(allOptions, triggerOptions)
end

function OptionsPrivate.GetTriggerOptions(data)
  local allOptions = {}
  for child in OptionsPrivate.Private.TraverseLeafsOrAura(data) do
    allOptions = AddOptions(allOptions, child)
  end

  fixMetaOrders(allOptions)

  local triggerOptions = {
    type = "group",
    name = L["Trigger"],
    order = 20,
    args = flattenRegionOptions(allOptions, false)
  }

  if data.controlledChildren then
    removeFuncs(triggerOptions, true);
    replaceNameDescFuncs(triggerOptions, data, "trigger");
    replaceImageFuncs(triggerOptions, data, "trigger");
    replaceValuesFuncs(triggerOptions, data, "trigger");

    triggerOptions.get = function(info, ...)
      return getAll(data, info, ...)
    end
    triggerOptions.set = function(info, ...)
      setAll(data, info, ...)
    end
    triggerOptions.hidden = function(info, ...)
      return hiddenAll(data, info, ...)
    end
    triggerOptions.disabled = function(info, ...)
      return disabledAll(data, info, ...)
    end

    triggerOptions.func = function(info, ...)
      return executeAll(data, info, ...)
    end
  end

  return triggerOptions
end

local function DeleteConditionsForTriggerHandleSubChecks(checks, triggernum)
  for _, check in ipairs(checks) do
    if (check.trigger == triggernum) then
      check.trigger = nil;
    end

    if (check.trigger and check.trigger > triggernum) then
      check.trigger = check.trigger - 1;
    end

    if (check.checks) then
      DeleteConditionsForTriggerHandleSubChecks(check.checks, triggernum);
    end
  end
end

local function DeleteConditionsForTrigger(data, triggernum)
  for _, condition in ipairs(data.conditions) do
    if (condition.check and condition.check.trigger == triggernum) then
      condition.check.trigger = nil;
    end

    if (condition.check and condition.check.trigger and condition.check.trigger > triggernum) then
      condition.check.trigger = condition.check.trigger - 1;
    end

    if (condition.check and condition.check.checks) then
      DeleteConditionsForTriggerHandleSubChecks(condition.check.checks, triggernum)
    end
  end
end

local function FixUpProgressSourceAfterDelete(data, triggernum)
  local function FixUpProgressSource(data)
    if data.progressSource then
      local trigger, property = unpack(data.progressSource)
      if trigger > triggernum then
        data.progressSource = {trigger - 1, property}
      end
    end
  end

  FixUpProgressSource(data)

  for _, subRegionData in ipairs(data.subRegions) do
    FixUpProgressSource(subRegionData)
  end
end

local function moveTriggerDownConditionCheck(check, i)
  if (check.trigger == i) then
    check.trigger = i + 1;
  elseif (check.trigger == i  + 1) then
    check.trigger = i;
  end
  if (check.checks) then
    for _, subCheck in ipairs(check.checks) do
      moveTriggerDownConditionCheck(subCheck, i);
    end
  end
end

--- @type fun(data: auraData, i: number) : boolean
local function moveTriggerDownImpl(data, i)
  if (i < 1 or i >= #data.triggers) then
    return false;
  end
  data.triggers[i], data.triggers[i + 1] = data.triggers[i + 1], data.triggers[i]
  for _, condition in ipairs(data.conditions) do
    moveTriggerDownConditionCheck(condition.check, i);
  end

  local function fixUpProgressSource(data)
    if data.progressSource then
      local trigger, property = unpack(data.progressSource)
      if trigger == i then
        data.progressSource = {i + 1, property}
      elseif trigger == i + 1 then
        data.progressSource = {i, property}
      end
    end
  end

  fixUpProgressSource(data)

  for _, subRegionData in ipairs(data.subRegions) do
    fixUpProgressSource(subRegionData)
  end

  return true;
end

function OptionsPrivate.ClearTriggerExpandState()
  for i = 1, maxTriggerNumForExpand do
    OptionsPrivate.SetCollapsed(collapsedId, "trigger", i, nil)
  end
  maxTriggerNumForExpand = 0
end

function OptionsPrivate.GetTriggerTitle(data, triggernum)
  if data.triggers[triggernum] then
    local trigger = data.triggers[triggernum].trigger
    if trigger then
      local event_prototype = OptionsPrivate.Private.event_prototypes[trigger.event]
      local triggerType = trigger.type
      local name
      if triggerType == "aura2" then
        name = L["Aura"]
      elseif triggerType == "custom" then
        name = L["Custom"]
      else
        name = event_prototype.name
      end
      return L["Trigger %i: %s"]:format(triggernum, name)
    end
  end
  return L["Trigger %i"]:format(triggernum)
end

local triggerDeleteDialogOpen = false

function OptionsPrivate.AddTriggerMetaFunctions(options, data, triggernum)
  options.__title = OptionsPrivate.GetTriggerTitle(data, triggernum)
  options.__order = triggernum * 10
  options.__collapsed = #data.triggers > 1
  options.__isCollapsed = function()
    return OptionsPrivate.IsCollapsed(collapsedId, "trigger", triggernum, #data.triggers > 1)
  end
  options.__setCollapsed = function(info, button, secondCall)
    if not secondCall then
      local isCollapsed = OptionsPrivate.IsCollapsed(collapsedId, "trigger", triggernum, #data.triggers > 1)
      OptionsPrivate.SetCollapsed(collapsedId, "trigger", triggernum, not isCollapsed)
      maxTriggerNumForExpand = max(maxTriggerNumForExpand, triggernum)
    end
  end
  options.__up =
  {
    disabled = function()
      return triggernum < 2
    end,
    func = function()
      if (moveTriggerDownImpl(data, triggernum - 1)) then
        WeakAuras.Add(data);
        OptionsPrivate.MoveCollapseDataUp(collapsedId, "trigger", {triggernum})
        WeakAuras.ClearAndUpdateOptions(data.id);
      end
    end
  }
  options.__down =
  {
    disabled = function()
      return triggernum == #data.triggers
    end,
    func = function()
      if (moveTriggerDownImpl(data, triggernum)) then
        WeakAuras.Add(data);
        OptionsPrivate.MoveCollapseDataDown(collapsedId, "trigger", {triggernum})
        WeakAuras.ClearAndUpdateOptions(data.id);
      end
    end
  }
  options.__duplicate = function()
    local trigger = CopyTable(data.triggers[triggernum])
    tinsert(data.triggers, trigger)
    WeakAuras.Add(data)
    WeakAuras.ClearAndUpdateOptions(data.id)
  end
  options.__delete = {
    disabled = function()
      return #data.triggers == 1
    end,
    func = function(...)
      if triggerDeleteDialogOpen then
        -- This function is called multiple times if multiple auras are selected
        return
      end

      local canDelete = false
      -- Since we want to handle all selected auras in one dialog, we have to iterate over GetPickedDisplay
      local picked = OptionsPrivate.GetPickedDisplay()
      for child in OptionsPrivate.Private.TraverseLeafsOrAura(picked) do
        if #child.triggers > 1 and #child.triggers >= triggernum then
          canDelete = true
          break;
        end
      end

      if canDelete then
        StaticPopupDialogs["WEAKAURAS_CONFIRM_TRIGGER_DELETE"] = {
          text = L["You are about to delete a trigger. |cFFFF0000This cannot be undone!|r Would you like to continue?"],
          button1 = L["Delete"],
          button2 = L["Cancel"],
          OnAccept = function()
            for child in OptionsPrivate.Private.TraverseLeafsOrAura(picked) do
              if #child.triggers > 1 and #child.triggers >= triggernum then
                tremove(child.triggers, triggernum)
                DeleteConditionsForTrigger(child, triggernum)
                FixUpProgressSourceAfterDelete(child, triggernum)
                WeakAuras.Add(child)
                OptionsPrivate.RemoveCollapsed(collapsedId, "trigger", {triggernum})
                OptionsPrivate.ClearOptions(child.id)
              end
            end

            WeakAuras.FillOptions()
            triggerDeleteDialogOpen = false
          end,
          OnCancel = function()
            triggerDeleteDialogOpen = false
          end,
          showAlert = true,
          whileDead = true,
          preferredindex = 4,
        }
        triggerDeleteDialogOpen = true
        StaticPopup_Show("WEAKAURAS_CONFIRM_TRIGGER_DELETE")
      end
    end
  }
  if (C_AddOns.GetAddOnEnableState("WeakAurasTemplates") ~= Enum.AddOnEnableState.None) then
    options.__applyTemplate = function()
      -- If we have more than a single aura selected,
      -- we want to open the template view with the group/multi selection
      OptionsPrivate.OpenTriggerTemplate(OptionsPrivate.GetPickedDisplay())
    end
  end
end

=== END OF FILE: WeakAurasOptions/TriggerOptions.lua ===


=== FILE: WeakAurasOptions/VersionCheck.lua ===
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

local optionsVersion = "5.20.5"
--[==[@debug@
optionsVersion = "Dev"
--@end-debug@]==]

if optionsVersion ~= WeakAuras.versionString then
  local message = string.format(L["The WeakAuras Options Addon version %s doesn't match the WeakAuras version %s. If you updated the addon while the game was running, try restarting World of Warcraft. Otherwise try reinstalling WeakAuras"],
                    optionsVersion, WeakAuras.versionString)
  ---@diagnostic disable-next-line: duplicate-set-field
  WeakAuras.IsLibsOk = function() return false end
  ---@diagnostic disable-next-line: duplicate-set-field
  WeakAuras.ToggleOptions = function()
       WeakAuras.prettyPrint(message)
  end

end

=== END OF FILE: WeakAurasOptions/VersionCheck.lua ===


=== FILE: WeakAurasOptions/WeakAurasOptions.lua ===
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class OptionsPrivate
local OptionsPrivate = select(2, ...)

-- Lua APIs
local tinsert, tremove, wipe = table.insert, table.remove, wipe
local pairs, type = pairs, type
local error = error
local coroutine = coroutine
local _G = _G

-- WoW APIs
local InCombatLockdown = InCombatLockdown
local CreateFrame = CreateFrame

local AceGUI = LibStub("AceGUI-3.0")

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L
local ADDON_NAME = "WeakAurasOptions";

local displayButtons = {};
OptionsPrivate.displayButtons = displayButtons;

local spellCache = WeakAuras.spellCache;
local savedVars = {};
OptionsPrivate.savedVars = savedVars;

OptionsPrivate.expanderAnchors = {}
OptionsPrivate.expanderButtons = {}

local collapsedOptions = {}
local collapsed = {} -- magic value

local tempGroup = {
  id = {"tempGroup"},
  regionType = "group",
  controlledChildren = {},
  load = {},
  triggers = {{}},
  config = {},
  authorOptions = {},
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0
};
OptionsPrivate.tempGroup = tempGroup;

-- Does not duplicate child auras.
function OptionsPrivate.DuplicateAura(data, newParent, massEdit, targetIndex)
  local base_id = data.id .. " "
  local num = 2

  -- if the old id ends with a number increment the number
  local matchName, matchNumber = string.match(data.id, "^(.-)(%d*)$")
  matchNumber = tonumber(matchNumber)
  if (matchName ~= "" and matchNumber ~= nil) then
    base_id = matchName
    num = matchNumber + 1
  end

  local new_id = base_id .. num
  while(WeakAuras.GetData(new_id)) do
    new_id = base_id .. num
    num = num + 1
  end

  local newData = CopyTable(data)
  newData.id = new_id
  newData.parent = nil
  newData.uid = WeakAuras.GenerateUniqueID()
  if newData.controlledChildren then
    newData.controlledChildren = {}
  end
  WeakAuras.Add(newData)
  WeakAuras.NewDisplayButton(newData, massEdit)
  if(newParent or data.parent) then
    local parentId = newParent or data.parent
    local parentData = WeakAuras.GetData(parentId)
    local index
    if targetIndex then
      index = targetIndex
    elseif newParent then
      index = #parentData.controlledChildren + 1
    else
      index = tIndexOf(parentData.controlledChildren, data.id) + 1
    end
    if(index) then
      tinsert(parentData.controlledChildren, index, newData.id)
      newData.parent = parentId
      WeakAuras.Add(newData)
      WeakAuras.Add(parentData)
      OptionsPrivate.Private.AddParents(parentData)

      for index, id in pairs(parentData.controlledChildren) do
        local childButton = OptionsPrivate.GetDisplayButton(id)
        childButton:SetGroup(parentData.id, parentData.regionType == "dynamicgroup")
        childButton:SetGroupOrder(index, #parentData.controlledChildren)
      end

      if not massEdit then
        local button = OptionsPrivate.GetDisplayButton(parentData.id)
        button.callbacks.UpdateExpandButton()
        button:UpdateParentWarning()
      end
      OptionsPrivate.ClearOptions(parentData.id)
    end
  end
  return newData
end

AceGUI:RegisterLayout("AbsoluteList", function(content, children)
  local yOffset = 0;
  for i = 1, #children do
    local child = children[i]

    local frame = child.frame;
    frame:ClearAllPoints();
    frame:Show();

    frame:SetPoint("LEFT", content);
    frame:SetPoint("RIGHT", content);
    frame:SetPoint("TOP", content, "TOP", 0, yOffset)

    if child.DoLayout then
      child:DoLayout()
    end

    yOffset = yOffset - ((frame.height or frame:GetHeight() or 0) + 2);
  end
  if(content.obj.LayoutFinished) then
    content.obj:LayoutFinished(nil, yOffset * -1);
  end
end);

AceGUI:RegisterLayout("ButtonsScrollLayout", function(content, children, skipLayoutFinished)
  local yOffset = 0
  local scrollTop, scrollBottom = content.obj:GetScrollPos()
  for i = 1, #children do
    local child = children[i]
    local frame = child.frame;

    if not child.dragging then
      local frameHeight = (frame.height or frame:GetHeight() or 0);
      frame:ClearAllPoints();
      if (-yOffset + frameHeight > scrollTop and -yOffset - frameHeight < scrollBottom) then
        frame:Show();
        frame:SetPoint("LEFT", content);
        frame:SetPoint("RIGHT", content);
        frame:SetPoint("TOP", content, "TOP", 0, yOffset)
      else
        frame:Hide();
        frame.yOffset = yOffset
      end
      yOffset = yOffset - (frameHeight + 2);
    end

    if child.DoLayout then
      child:DoLayout()
    end

  end
  if(content.obj.LayoutFinished and not skipLayoutFinished) then
    content.obj:LayoutFinished(nil, yOffset * -1)
  end
end)

function OptionsPrivate.MultipleDisplayTooltipDesc()
  local desc = {{L["Multiple Displays"], L["Temporary Group"]}};
  for index, id in pairs(tempGroup.controlledChildren) do
    desc[index + 1] = {" ", id};
  end
  desc[2][1] = L["Children:"]
  tinsert(desc, " ");
  tinsert(desc, {" ", "|cFF00FFFF"..L["Right-click for more options"]});
  tinsert(desc, {" ", "|cFF00FFFF"..L["Drag to move"]});
  return desc;
end

local frame;
local db;
local odb;
--- @type boolean?
local reopenAfterCombat = false;
local loadedFrame = CreateFrame("Frame");
loadedFrame:RegisterEvent("ADDON_LOADED");
loadedFrame:RegisterEvent("PLAYER_REGEN_ENABLED");
loadedFrame:RegisterEvent("PLAYER_REGEN_DISABLED");
loadedFrame:SetScript("OnEvent", function(self, event, addon)
  if (event == "ADDON_LOADED") then
    if(addon == ADDON_NAME) then
      db = WeakAurasSaved;
      WeakAurasOptionsSaved = WeakAurasOptionsSaved or {};

      odb = WeakAurasOptionsSaved;

      -- Remove icon and id cache (replaced with spellCache)
      if (odb.iconCache) then
        odb.iconCache = nil;
      end
      if (odb.idCache) then
        odb.idCache = nil;
      end
      odb.spellCache = odb.spellCache or {};
      spellCache.Load(odb);

      if odb.magnetAlign == nil then
        odb.magnetAlign = true
      end

      if db.import_disabled then
        db.import_disabled = nil
      end

      savedVars.db = db;
      savedVars.odb = odb;
    end
  elseif (event == "PLAYER_REGEN_DISABLED") then
    if(frame and frame:IsVisible()) then
      reopenAfterCombat = true;
      WeakAuras.HideOptions();
    end
  elseif (event == "PLAYER_REGEN_ENABLED") then
    if (reopenAfterCombat) then
      reopenAfterCombat = nil;
      WeakAuras.ShowOptions()
    end
  end
end);

local function addParents(hash, data)
  local parent = data.parent
  if parent then
    hash[parent] = true
    local parentData = WeakAuras.GetData(parent)
    if parentData then
      addParents(hash, parentData)
    end
  end
end

local function commonParent(controlledChildren)
  local allSame = true
  local parent = nil
  local targetIndex = math.huge
  for index, id in ipairs(controlledChildren) do
    local childData = WeakAuras.GetData(id);
    local childButton = OptionsPrivate.GetDisplayButton(id)
    targetIndex = min(targetIndex, childButton:GetGroupOrder() or math.huge)

    if (parent == nil) then
      parent = childData.parent
    elseif not childData.parent then
      allSame = false
    elseif childData.parent ~= parent then
      allSame = false
    end
  end
  if allSame then
    return parent, targetIndex
  end
end

local function CreateNewGroupFromSelection(regionType, resetChildPositions)
  local data = {
    id = OptionsPrivate.Private.FindUnusedId(tempGroup.controlledChildren[1].." Group"),
    regionType = regionType,
  };

  WeakAuras.DeepMixin(data, OptionsPrivate.Private.data_stub)
  data.internalVersion = WeakAuras.InternalVersion()
  OptionsPrivate.Private.validate(data, OptionsPrivate.Private.regionTypes[regionType].default);

  local parent, targetIndex = commonParent(tempGroup.controlledChildren)

  if (parent) then
    local parentData = WeakAuras.GetData(parent)
    tinsert(parentData.controlledChildren, targetIndex, data.id)
    data.parent = parent
    WeakAuras.Add(data);
    WeakAuras.Add(parentData);
    OptionsPrivate.Private.AddParents(parentData)
    WeakAuras.NewDisplayButton(data);
    WeakAuras.UpdateGroupOrders(parentData);
    OptionsPrivate.ClearOptions(parentData.id);

    local parentButton = OptionsPrivate.GetDisplayButton(parent)
    parentButton.callbacks.UpdateExpandButton();
    parentButton:Expand();
    parentButton:ReloadTooltip();
    parentButton:UpdateParentWarning();
  else
    WeakAuras.Add(data);
    WeakAuras.NewDisplayButton(data);
  end

  for index, childId in pairs(tempGroup.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    local childButton = OptionsPrivate.GetDisplayButton(childId)
    local oldParent = childData.parent
    local oldParentData = WeakAuras.GetData(oldParent)
    if (oldParent) then
      local oldIndex = childButton:GetGroupOrder()

      tremove(oldParentData.controlledChildren, oldIndex)
      WeakAuras.Add(oldParentData)
      OptionsPrivate.Private.AddParents(oldParentData)
      WeakAuras.UpdateGroupOrders(oldParentData);
      WeakAuras.ClearAndUpdateOptions(oldParent);
      local oldParentButton = OptionsPrivate.GetDisplayButton(oldParent)
      oldParentButton.callbacks.UpdateExpandButton();
      oldParentButton:ReloadTooltip()
      oldParentButton:UpdateParentWarning()
    end

    tinsert(data.controlledChildren, childId);
    childData.parent = data.id;
    if resetChildPositions then
      childData.xOffset = 0;
        childData.yOffset = 0;
    end
    WeakAuras.Add(data);
    WeakAuras.Add(childData);
    OptionsPrivate.ClearOptions(childData.id)

    childButton:SetGroup(data.id, data.regionType == "dynamicgroup");
    childButton:SetGroupOrder(index, #data.controlledChildren);
  end

  local button = OptionsPrivate.GetDisplayButton(data.id);
  button.callbacks.UpdateExpandButton();
  button:UpdateParentWarning()
  OptionsPrivate.SortDisplayButtons();
  button:Expand();

  if data.parent then
    OptionsPrivate.Private.AddParents(data)
  end
end

function OptionsPrivate.MultipleDisplayTooltipMenu()
  local frame = frame;
  local menu = {
    {
      text = L["Add to new Group"],
      notCheckable = 1,
      func = function()
        CreateNewGroupFromSelection("group")
      end
    },
    {
      text = L["Add to new Dynamic Group"],
      notCheckable = 1,
      func = function()
        CreateNewGroupFromSelection("dynamicgroup", true)
      end
    },
    {
      text = L["Duplicate All"],
      notCheckable = 1,
      func = function()
        local duplicated = {};
        for child in OptionsPrivate.Private.TraverseAllChildren(tempGroup) do
          local newData = OptionsPrivate.DuplicateAura(child)
          tinsert(duplicated, newData.id);
        end

        OptionsPrivate.ClearPicks();
        frame:PickDisplayBatch(duplicated);
      end
    },
    {
      text = " ",
      notCheckable = 1,
      notClickable = 1
    },
    {
      text = L["Delete all"],
      notCheckable = 1,
      func = function()
        local toDelete = {};
        local parents = {};
        for child in OptionsPrivate.Private.TraverseAllChildren(tempGroup) do
          tinsert(toDelete, child)
          addParents(parents, child)
        end
        OptionsPrivate.ConfirmDelete(toDelete, parents)
      end
    },
    {
      text = " ",
      notClickable = 1,
      notCheckable = 1,
    },
    {
      text = L["Close"],
      notCheckable = 1,
      func = function() WeakAuras_DropDownMenu:Hide() end
    }
  };

  local anyGroup = false;
  local allSameParent = true
  local commonParent = nil
  local first = true
  for _, id in pairs(tempGroup.controlledChildren) do
    local childData = WeakAuras.GetData(id);
    if(childData and childData.controlledChildren) then
      anyGroup = true;
    end

    if (first) then
      commonParent = childData.parent
      first = false
    elseif childData.parent ~= commonParent then
      allSameParent = false
    end
  end

  if(anyGroup) then
    -- Disable "Add to New Dynamic Group"
    menu[2].notClickable = 1;
    menu[2].text = "|cFF777777"..menu[2].text;
  end

  -- Also disable Add to New Dynamic Group/Group if that would create
  -- a group inside a dynamic group
  if (allSameParent and commonParent) then
    local parentData = WeakAuras.GetData(commonParent);
    if (parentData and parentData.regionType == "dynamicgroup") then
      menu[1].notClickable = 1;
      menu[1].text = "|cFF777777"..menu[1].text;
      menu[2].notClickable = 1;
      menu[2].text = "|cFF777777"..menu[1].text;
    end
  end

  return menu;
end

StaticPopupDialogs["WEAKAURAS_CONFIRM_DELETE"] = {
  text = "",
  button1 = L["Delete"],
  button2 = L["Cancel"],
  OnAccept = function(self)
    if self.data then
      OptionsPrivate.DeleteAuras(self.data.toDelete, self.data.parents)
    end
  end,
  OnCancel = function(self)
    self.data = nil
  end,
  showAlert = true,
  whileDead = true,
  preferredindex = 4,
}

function OptionsPrivate.IsWagoUpdateIgnored(auraId)
    local auraData = WeakAuras.GetData(auraId)
      if auraData then
        for child in OptionsPrivate.Private.TraverseAll(auraData) do
          if child.ignoreWagoUpdate then
            return true
          end
        end
      end
    return false
end

function OptionsPrivate.HasWagoUrl(auraId)
  local auraData = WeakAuras.GetData(auraId)
    if auraData then
      for child in OptionsPrivate.Private.TraverseAll(auraData) do
        if child.url and child.url ~= "" then
          return true
        end
      end
    end
  return false
end

function OptionsPrivate.ConfirmDelete(toDelete, parents)
  if toDelete then
    local warningForm = L["You are about to delete %d aura(s). |cFFFF0000This cannot be undone!|r Would you like to continue?"]
    StaticPopupDialogs["WEAKAURAS_CONFIRM_DELETE"].text = warningForm:format(#toDelete)
    StaticPopup_Show("WEAKAURAS_CONFIRM_DELETE", "", "", {toDelete = toDelete, parents = parents})
  end
end

local function AfterScanForLoads()
  if(frame) then
    if (frame:IsVisible()) then
      OptionsPrivate.SortDisplayButtons(nil, true);
    else
      frame.needsSort = true;
    end
  end
end

local function OnAboutToDelete(event, uid, id, parentUid, parentId)
  local data = OptionsPrivate.Private.GetDataByUID(uid)
  if(data.controlledChildren) then
    for index, childId in pairs(data.controlledChildren) do
      local childButton = displayButtons[childId];
      if(childButton) then
        childButton:SetGroup();
      end
      local childData = db.displays[childId];
      if(childData) then
        childData.parent = nil;
      end
    end
  end

  OptionsPrivate.Private.CollapseAllClones(id);
  OptionsPrivate.ClearOptions(id)

  frame:ClearPicks();

  if(displayButtons[id])then
    frame.buttonsScroll:DeleteChild(displayButtons[id]);
    displayButtons[id] = nil;
  end

  collapsedOptions[id] = nil
end

local function OnRename(event, uid, oldid, newid)
  local data = OptionsPrivate.Private.GetDataByUID(uid)

  OptionsPrivate.displayButtons[newid] = OptionsPrivate.displayButtons[oldid];
  OptionsPrivate.displayButtons[newid]:SetData(data)
  OptionsPrivate.displayButtons[oldid] = nil;
  OptionsPrivate.ClearOptions(oldid)

  OptionsPrivate.displayButtons[newid]:SetTitle(newid);

  collapsedOptions[newid] = collapsedOptions[oldid]
  collapsedOptions[oldid] = nil

  if(data.controlledChildren) then
    for _, childId in pairs(data.controlledChildren) do
      OptionsPrivate.displayButtons[childId]:SetGroup(newid)
    end
  end

  OptionsPrivate.StopGrouping()
  OptionsPrivate.SortDisplayButtons(nil, true)

  frame:OnRename(uid, oldid, newid)

  WeakAuras.PickDisplay(newid)

  local parent = data.parent
  while parent do
    OptionsPrivate.ClearOptions(parent)
    local parentData = WeakAuras.GetData(parent)
    parent = parentData.parent
  end
end

local function OptionsFrame()
  if(frame) then
    return frame
  else
    return nil
  end
end

if not WeakAuras.ToggleOptions then
  ---@type fun(msg: string, Private: Private)
  function WeakAuras.ToggleOptions(msg, Private)
    if not Private then
      return
    end
    if not OptionsPrivate.Private then
      OptionsPrivate.Private = Private
      Private.OptionsFrame = OptionsFrame
      for _, fn in ipairs(OptionsPrivate.registerRegions) do
        fn()
      end
      OptionsPrivate.Private.callbacks:RegisterCallback("AuraWarningsUpdated", function(event, uid)
        local id = OptionsPrivate.Private.UIDtoID(uid)
        if displayButtons[id] then
          -- The button does not yet exists if a new aura is created
          displayButtons[id]:UpdateWarning()
        end
        local data = Private.GetDataByUID(uid)
        if data and data.parent then
          local button = OptionsPrivate.GetDisplayButton(data.parent);
          if button then
            button:UpdateParentWarning()
          end
        end
      end)

      OptionsPrivate.Private.callbacks:RegisterCallback("ScanForLoads", AfterScanForLoads)
      OptionsPrivate.Private.callbacks:RegisterCallback("AboutToDelete", OnAboutToDelete)
      OptionsPrivate.Private.callbacks:RegisterCallback("Rename", OnRename)
      OptionsPrivate.Private.OpenUpdate = OptionsPrivate.OpenUpdate
    end

    if(frame and frame:IsVisible()) then
      WeakAuras.HideOptions();
    elseif (InCombatLockdown()) then
      WeakAuras.prettyPrint(L["Options will open after combat ends."])
      reopenAfterCombat = true;
    else
      WeakAuras.ShowOptions(msg);
    end
  end
end

function WeakAuras.HideOptions()
  if(frame) then
    frame:Hide()
  end
end

function WeakAuras.IsOptionsOpen()
  if(frame and frame:IsVisible()) then
    return true;
  else
    return false;
  end
end

local function EnsureDisplayButton(data)
  local id = data.id;
  if not(displayButtons[id]) then
    displayButtons[id] = AceGUI:Create("WeakAurasDisplayButton");
    if(displayButtons[id]) then
      displayButtons[id]:SetData(data);
      displayButtons[id]:Initialize();
      displayButtons[id]:UpdateWarning()
    else
      print("|cFF8800FFWeakAuras|r: Error creating button for", id);
    end
  end
end

local function GetSortedOptionsLists()
  local loadedSorted, unloadedSorted = {}, {};
  local to_sort = {};
  for id, data in pairs(db.displays) do
    if(data.parent) then
    -- Do nothing; children will be added later
  elseif(OptionsPrivate.Private.loaded[id]) then
      tinsert(to_sort, id);
    end
  end
  table.sort(to_sort, function(a, b) return a:lower() < b:lower() end)
  for _, id in ipairs(to_sort) do
    local data = WeakAuras.GetData(id);
    for child in OptionsPrivate.Private.TraverseAll(data) do
      tinsert(loadedSorted, child.id)
    end
  end

  wipe(to_sort);
  for id, data in pairs(db.displays) do
    if(data.parent) then
    -- Do nothing; children will be added later
    elseif not(OptionsPrivate.Private.loaded[id]) then
      tinsert(to_sort, id);
    end
  end
  table.sort(to_sort, function(a, b) return a:lower() < b:lower() end)
  for _, id in ipairs(to_sort) do
    local data = WeakAuras.GetData(id);
    for child in OptionsPrivate.Private.TraverseAll(data) do
      tinsert(unloadedSorted, child.id)
    end
  end

  return loadedSorted, unloadedSorted;
end

local function LayoutDisplayButtons(msg)
  local total = 0;
  for _,_ in pairs(db.displays) do
    total = total + 1;
  end

  local loadedSorted, unloadedSorted = GetSortedOptionsLists();

  frame:SetLoadProgressVisible(true)
  if OptionsPrivate.Private.CompanionData.slugs then
    frame.buttonsScroll:AddChild(frame.pendingInstallButton);
    frame.buttonsScroll:AddChild(frame.pendingUpdateButton);
  end
  frame.buttonsScroll:AddChild(frame.loadedButton);
  frame.buttonsScroll:AddChild(frame.unloadedButton);

  local func2 = function()
    local num = frame.loadProgressNum or 0;
    for _, id in pairs(unloadedSorted) do
      local data = WeakAuras.GetData(id);
      if(data) then
        EnsureDisplayButton(data);
        WeakAuras.UpdateThumbnail(data);

        frame.buttonsScroll:AddChild(displayButtons[data.id]);

        if (num % 50 == 0) then
          frame.buttonsScroll:ResumeLayout()
          frame.buttonsScroll:PerformLayout()
          frame.buttonsScroll:PauseLayout()
        end

        num = num + 1;
      end
      frame.loadProgress:SetText(L["Creating buttons: "]..num.."/"..total);
      frame.loadProgressNum = num;
      coroutine.yield();
    end

    frame.buttonsScroll:ResumeLayout()
    frame.buttonsScroll:PerformLayout()
    OptionsPrivate.SortDisplayButtons(msg);

    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
    if (WeakAuras.IsOptionsOpen()) then
      for id, button in pairs(displayButtons) do
        if OptionsPrivate.Private.loaded[id] then
          button:PriorityShow(1);
          coroutine.yield()
        end
      end
      OptionsPrivate.Private.OptionsFrame().loadedButton:RecheckVisibility()
      coroutine.yield()
    end
    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)

    frame:SetLoadProgressVisible(false)
  end

  local func1 = function()
    local num = frame.loadProgressNum or 0;
    frame.buttonsScroll:PauseLayout()
    for _, id in pairs(loadedSorted) do
      local data = WeakAuras.GetData(id);
      if(data) then
        EnsureDisplayButton(data);
        WeakAuras.UpdateThumbnail(data);

        local button = displayButtons[data.id]
        frame.buttonsScroll:AddChild(button);
        num = num + 1;
      end

      if (num % 50 == 0) then
        frame.buttonsScroll:ResumeLayout()
        frame.buttonsScroll:PerformLayout()
        frame.buttonsScroll:PauseLayout()
      end

      frame.loadProgress:SetText(L["Creating buttons: "]..num.."/"..total);
      frame.loadProgressNum = num;
      coroutine.yield();
    end

    local co2 = coroutine.create(func2);
    OptionsPrivate.Private.Threads:Add("LayoutDisplayButtons2", co2);
  end

  local co1 = coroutine.create(func1);
  OptionsPrivate.Private.Threads:Add("LayoutDisplayButtons1", co1);
end

function OptionsPrivate.DeleteAuras(auras, parents)
  local func1 = function()
    frame:SetLoadProgressVisible(true)
    local num = 0
    local total = 0
    for _, auraData in pairs(auras) do
      total = total +1
    end

    frame.loadProgress:SetText(L["Deleting auras: "]..num.."/"..total)

    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
    OptionsPrivate.massDelete = true
    for _, auraData in pairs(auras) do
      WeakAuras.Delete(auraData)
      num = num +1
      frame.loadProgress:SetText(L["Deleting auras: "]..num.."/"..total)
      coroutine.yield()
    end
    OptionsPrivate.massDelete = false

    if parents then
      for id in pairs(parents) do
        local parentData = WeakAuras.GetData(id)
        local parentButton = OptionsPrivate.GetDisplayButton(id)
        WeakAuras.UpdateGroupOrders(parentData)
        if(#parentData.controlledChildren == 0) then
          parentButton:DisableExpand()
        else
          parentButton:EnableExpand()
        end
        parentButton:SetNormalTooltip()
        WeakAuras.Add(parentData)
        WeakAuras.ClearAndUpdateOptions(parentData.id)
        parentButton:UpdateParentWarning()
        frame.loadProgress:SetText(L["Finishing..."])
        coroutine.yield()
      end
    end
    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
    OptionsPrivate.SortDisplayButtons(nil, true)

    frame:SetLoadProgressVisible(false)
  end

  local co1 = coroutine.create(func1)
  OptionsPrivate.Private.Threads:Add("Deleting Auras", co1)
end

function WeakAuras.ShowOptions(msg)
  local firstLoad = not(frame);
  OptionsPrivate.Private.Pause();
  OptionsPrivate.Private.SetFakeStates()

  WeakAuras.spellCache.Build()

  if (firstLoad) then
    frame = OptionsPrivate.CreateFrame();
    frame.buttonsScroll.frame:Show();

    LayoutDisplayButtons(msg);
  end

  if (frame:GetWidth() > GetScreenWidth()) then
    frame:SetWidth(GetScreenWidth())
  end

  if (frame:GetHeight() > GetScreenHeight() - 50) then
    frame:SetHeight(GetScreenHeight() - 50)
  end

  frame.buttonsScroll.frame:Show();

  if (frame.needsSort) then
    OptionsPrivate.SortDisplayButtons();
    frame.needsSort = nil;
  end

  frame:Show();

  if (OptionsPrivate.Private.mouseFrame) then
    OptionsPrivate.Private.mouseFrame:OptionsOpened();
  end

  if (OptionsPrivate.Private.personalRessourceDisplayFrame) then
    OptionsPrivate.Private.personalRessourceDisplayFrame:OptionsOpened();
  end

  if frame.moversizer then
    frame.moversizer:OptionsOpened()
  end

  if not(firstLoad) then
    -- Show what was last shown
    local suspended = OptionsPrivate.Private.PauseAllDynamicGroups()
    for id, button in pairs(displayButtons) do
      button:SyncVisibility()
    end
    OptionsPrivate.Private.ResumeAllDynamicGroups(suspended)
  end

  if (frame.pickedDisplay) then
    if (OptionsPrivate.IsPickedMultiple()) then
      local children = {}
      for k,v in pairs(tempGroup.controlledChildren) do
        children[k] = v
      end
      frame:PickDisplayBatch(children);
    else
      WeakAuras.PickDisplay(frame.pickedDisplay);
    end
  else
    frame:NewAura();
  end

  if (frame.window == "codereview") then
    local codereview = OptionsPrivate.CodeReview(frame, true)
    if codereview then
      codereview:Close();
    end
  end

  if firstLoad then
    frame:ShowTip()
  end

end

function OptionsPrivate.UpdateOptions()
  frame:UpdateOptions()
end

function WeakAuras.ClearAndUpdateOptions(id, clearChildren)
  frame:ClearAndUpdateOptions(id, clearChildren)
end

function OptionsPrivate.ClearOptions(id)
  frame:ClearOptions(id)
end

function WeakAuras.FillOptions()
  frame:FillOptions()
end

function OptionsPrivate.EnsureOptions(data, subOption)
  return frame:EnsureOptions(data, subOption)
end

function OptionsPrivate.GetPickedDisplay()
  return frame:GetPickedDisplay()
end

function OptionsPrivate.OpenTextEditor(...)
  OptionsPrivate.TextEditor(frame):Open(...);
end

function OptionsPrivate.ExportToString(id)
  OptionsPrivate.ImportExport(frame):Open("export", id);
end

function OptionsPrivate.ExportToTable(id)
  OptionsPrivate.ImportExport(frame):Open("table", id);
end

function OptionsPrivate.ImportFromString()
  OptionsPrivate.ImportExport(frame):Open("import");
end

function OptionsPrivate.OpenDebugLog(text)
  OptionsPrivate.DebugLog(frame):Open(text)
end

function OptionsPrivate.OpenUpdate(data, children, target, linkedAuras, sender, callbackFunc)
  return OptionsPrivate.UpdateFrame(frame):Open(data, children, target, linkedAuras, sender, callbackFunc)
end

function OptionsPrivate.ConvertDisplay(data, newType)
  local id = data.id;
  local visibility = displayButtons[id]:GetVisibility();
  displayButtons[id]:PriorityHide(2);

  if OptionsPrivate.Private.regions[id] and OptionsPrivate.Private.regions[id].region then
    OptionsPrivate.Private.regions[id].region:Collapse()
  end
  OptionsPrivate.Private.CollapseAllClones(id);

  OptionsPrivate.Private.Convert(data, newType);
  displayButtons[id]:Initialize();
  displayButtons[id]:PriorityShow(visibility);
  frame:ClearOptions(id)
  frame:FillOptions();
  WeakAuras.UpdateThumbnail(data);
  WeakAuras.SetMoverSizer(id)
  OptionsPrivate.ResetMoverSizer();
  OptionsPrivate.SortDisplayButtons()
end

function WeakAuras.NewDisplayButton(data, massEdit)
  local id = data.id;
  OptionsPrivate.Private.ScanForLoads({[id] = true});
  EnsureDisplayButton(db.displays[id]);
  WeakAuras.UpdateThumbnail(db.displays[id]);
  frame.buttonsScroll:AddChild(displayButtons[id]);
  if not massEdit then
    OptionsPrivate.SortDisplayButtons()
  end
end

function WeakAuras.UpdateGroupOrders(data)
  if(data.controlledChildren) then
    local total = #data.controlledChildren;
    for index, id in pairs(data.controlledChildren) do
      local button = OptionsPrivate.GetDisplayButton(id);
      button:SetGroupOrder(index, total);
    end
  end
end

function OptionsPrivate.UpdateButtonsScroll()
  if OptionsPrivate.Private.IsOptionsProcessingPaused() then return end
  frame.buttonsScroll:DoLayout()
end

local function addButton(button, aurasMatchingFilter, visible)
  button.frame:Show();
  if button.AcquireThumbnail then
    button:AcquireThumbnail()
  end
  tinsert(frame.buttonsScroll.children, button);
  visible[button] = true

  if button.data.controlledChildren and button:GetExpanded() then
    for _, childId in ipairs(button.data.controlledChildren) do
      if aurasMatchingFilter[childId] then
        addButton(displayButtons[childId], aurasMatchingFilter, visible)
      end
    end
  end
end

local previousFilter;
local pendingUpdateButtons = {}
local pendingInstallButtons = {}
function OptionsPrivate.SortDisplayButtons(filter, overrideReset, id)
  if (OptionsPrivate.Private.IsOptionsProcessingPaused()) then
    return;
  end

  local recenter = false;
  filter = filter or (overrideReset and previousFilter or "");
  if(frame.filterInput:GetText() ~= filter) then
    frame.filterInput:SetText(filter);
  end
  if(previousFilter and previousFilter ~= "" and (filter == "" or not filter)) then
    recenter = true;
  end
  previousFilter = filter;
  filter = filter:lower();

  wipe(frame.buttonsScroll.children);

  local pendingInstallButtonShown = false
  if OptionsPrivate.Private.CompanionData.stash then
    for id, companionData in pairs(OptionsPrivate.Private.CompanionData.stash) do
      if not pendingInstallButtonShown then
        tinsert(frame.buttonsScroll.children, frame.pendingInstallButton)
        pendingInstallButtonShown = true
      end
      local child = pendingInstallButtons[id]
      if frame.pendingInstallButton:GetExpanded() then
        if not child then
          child = AceGUI:Create("WeakAurasPendingInstallButton")
          pendingInstallButtons[id] = child
          child:Initialize(id, companionData)
          if companionData.logo then
            child:SetLogo(companionData.logo)
          end
          if companionData.refreshLogo then
            child:SetRefreshLogo(companionData.refreshLogo)
          end
          child.frame:Show()
          child:AcquireThumbnail()
          frame.buttonsScroll:AddChild(child)
        else
          if not child.frame:IsShown() then
            child.frame:Show()
            child:AcquireThumbnail()
          end
          tinsert(frame.buttonsScroll.children, child)
        end
      elseif child then
        child.frame:Hide()
        if child.ReleaseThumbnail then
          child:ReleaseThumbnail()
        end
      end
    end
  end
  if not pendingInstallButtonShown and frame.pendingInstallButton then
    frame.pendingInstallButton.frame:Hide()
  end

  local pendingUpdateButtonShown = false
  if OptionsPrivate.Private.CompanionData.slugs then
    local buttonsShown = {}
    for _, button in pairs(pendingUpdateButtons) do
      button:ResetLinkedAuras()
    end
    for id, aura in pairs(WeakAurasSaved.displays) do
      if not aura.ignoreWagoUpdate and aura.url and aura.url ~= "" then
        local slug, version = aura.url:match("wago.io/([^/]+)/([0-9]+)")
        if not slug and not version then
          slug = aura.url:match("wago.io/([^/]+)$")
          version = 1
        end
        if slug and version then
          local auraData = OptionsPrivate.Private.CompanionData.slugs[slug]
          if auraData and auraData.wagoVersion then
            if tonumber(auraData.wagoVersion) > tonumber(version) then
              -- there is an update for this aura
              if not pendingUpdateButtonShown then
                tinsert(frame.buttonsScroll.children, frame.pendingUpdateButton)
                pendingUpdateButtonShown = true
              end
              if frame.pendingUpdateButton:GetExpanded() then
                local child = pendingUpdateButtons[slug]
                if not child then
                  child = AceGUI:Create("WeakAurasPendingUpdateButton")
                  pendingUpdateButtons[slug] = child
                  child:Initialize(slug, auraData)
                  if auraData.logo then
                    child:SetLogo(auraData.logo)
                  end
                  if auraData.refreshLogo then
                    child:SetRefreshLogo(auraData.refreshLogo)
                  end
                  child.frame:Show()
                  child:AcquireThumbnail()
                  frame.buttonsScroll:AddChild(child)
                  buttonsShown[slug] = true
                end
                if not child.frame:IsShown() then
                  child.frame:Show()
                  child:AcquireThumbnail()
                end
                if not buttonsShown[slug] then
                  tinsert(frame.buttonsScroll.children, child)
                  buttonsShown[slug] = true
                end
                child:MarkLinkedAura(id)
                for childData in OptionsPrivate.Private.TraverseAllChildren(aura) do
                  child:MarkLinkedChildren(childData.id)
                end
              end
            end
          end
        end
      end
    end
    -- hide all buttons not marked as shown
    for slug, button in pairs(pendingUpdateButtons) do
      if not buttonsShown[slug] then
        if button and button.frame:IsShown() then
          button.frame:Hide()
          if button.ReleaseThumbnail then
            button:ReleaseThumbnail()
          end
        end
      end
    end
  end
  if not pendingUpdateButtonShown and frame.pendingUpdateButton then
    frame.pendingUpdateButton.frame:Hide()
  end

  tinsert(frame.buttonsScroll.children, frame.loadedButton);

  local aurasMatchingFilter = {}
  local useTextFilter = filter ~= ""
  local filterTable = OptionsPrivate.Private.splitAtOr(filter)
  local topLevelLoadedAuras = {}
  local topLevelUnloadedAuras = {}
  local visible = {}

  for id, child in pairs(displayButtons) do
    if child.data.controlledChildren then
      local hasLoaded, hasStandBy, hasNotLoaded = 0, 0, 0
      for leaf in OptionsPrivate.Private.TraverseLeafs(child.data) do
        local id = leaf.id
        if OptionsPrivate.Private.loaded[id] == true then
          hasLoaded = hasLoaded + 1
        elseif OptionsPrivate.Private.loaded[id] == false then
          hasStandBy = hasStandBy + 1
        else
          hasNotLoaded = hasNotLoaded + 1
        end
      end
      if hasLoaded > 0 then
        child:SetLoaded(1, "loaded", L["Loaded"], L["%d displays loaded"]:format(hasLoaded))
      elseif hasStandBy > 0 then
        child:SetLoaded(2, "standby", L["Standby"], L["%d displays on standby"]:format(hasStandBy))
      elseif hasNotLoaded > 0 then
        child:SetLoaded(3, "unloaded", L["Not Loaded"], L["%d displays not loaded"]:format(hasNotLoaded))
      else
        child:ClearLoaded()
      end
    else
      if OptionsPrivate.Private.loaded[id] == true then
        child:SetLoaded(1, "loaded", L["Loaded"], L["This display is currently loaded"])
      elseif OptionsPrivate.Private.loaded[id] == false then
        child:SetLoaded(2, "standby", L["Standby"], L["This display is on standby, it will be loaded when needed."])
      else
        child:SetLoaded(3, "unloaded", L["Not Loaded"], L["This display is not currently loaded"])
      end
    end

    if useTextFilter then
      for _, word in ipairs(filterTable) do
        if(id:lower():find(word, 1, true)) then
          aurasMatchingFilter[id] = true
          for parent in OptionsPrivate.Private.TraverseParents(child.data) do
            aurasMatchingFilter[parent.id] = true
          end
        end
      end
    else
      aurasMatchingFilter[id] = true
    end

    if not child:GetGroup() then
      -- Top Level aura
      if OptionsPrivate.Private.loaded[id] ~= nil then
        tinsert(topLevelLoadedAuras, id)
      else
        tinsert(topLevelUnloadedAuras, id)
      end
    end
  end

  wipe(frame.loadedButton.childButtons)
  if frame.loadedButton:GetExpanded() then
    table.sort(topLevelLoadedAuras, function(a, b) return a:lower() < b:lower() end)
    for _, id in ipairs(topLevelLoadedAuras) do
      if aurasMatchingFilter[id] then
        addButton(displayButtons[id], aurasMatchingFilter, visible)
      end
    end
  end

  for _, id in ipairs(topLevelLoadedAuras) do
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(WeakAuras.GetData(id)) do
      tinsert(frame.loadedButton.childButtons, displayButtons[child.id])
    end
  end

  tinsert(frame.buttonsScroll.children, frame.unloadedButton);

  wipe(frame.unloadedButton.childButtons)
  if frame.unloadedButton:GetExpanded() then
    table.sort(topLevelUnloadedAuras, function(a, b) return a:lower() < b:lower() end)
    for _, id in ipairs(topLevelUnloadedAuras) do
      if aurasMatchingFilter[id] then
        addButton(displayButtons[id], aurasMatchingFilter, visible)
      end
    end
  end

  for _, id in ipairs(topLevelUnloadedAuras) do
    for child in OptionsPrivate.Private.TraverseLeafsOrAura(WeakAuras.GetData(id)) do
      tinsert(frame.unloadedButton.childButtons, displayButtons[child.id])
    end
  end

  for _, child in pairs(displayButtons) do
    if(not visible[child]) then
      child.frame:Hide();
      if child.ReleaseThumbnail then
        child:ReleaseThumbnail()
      end
    end
  end

  frame.buttonsScroll:DoLayout();
  if(recenter) then
    frame:CenterOnPicked();
  end
end


function OptionsPrivate.IsPickedMultiple()
  if(frame.pickedDisplay == tempGroup) then
    return true;
  else
    return false;
  end
end

function OptionsPrivate.IsDisplayPicked(id)
  if(frame.pickedDisplay == tempGroup) then
    for child in OptionsPrivate.Private.TraverseLeafs(tempGroup) do
      if(id == child.id) then
        return true;
      end
    end
    return false;
  else
    return frame.pickedDisplay == id;
  end
end

function WeakAuras.PickDisplay(id, tab, noHide)
  frame:PickDisplay(id, tab, noHide)
  OptionsPrivate.UpdateButtonsScroll()
end

function OptionsPrivate.PickAndEditDisplay(id)
  frame:PickDisplay(id);
  OptionsPrivate.UpdateButtonsScroll()
  displayButtons[id].callbacks.OnRenameClick();
end

function OptionsPrivate.ClearPick(id)
  frame:ClearPick(id);
end

function OptionsPrivate.ClearPicks()
  frame:ClearPicks();
end

function OptionsPrivate.PickDisplayMultiple(id)
  frame:PickDisplayMultiple(id);
end

function OptionsPrivate.PickDisplayMultipleShift(target)
  if (frame.pickedDisplay) then
    -- get first aura selected
    local first;
    if (OptionsPrivate.IsPickedMultiple()) then
      first = tempGroup.controlledChildren[#tempGroup.controlledChildren];
    else
      first = frame.pickedDisplay;
    end
    if (first and first ~= target) then
      -- check if target and first are in same group and are not a group
      local firstData = WeakAuras.GetData(first);
      local targetData = WeakAuras.GetData(target);
      if (firstData.parent == targetData.parent and not targetData.controlledChildren and not firstData.controlledChildren) then
        local batchSelection = {};
        -- in a group
        if (firstData.parent) then
          local group = WeakAuras.GetData(targetData.parent);
          for index, child in ipairs(group.controlledChildren) do
            -- 1st button
            if (child == target or child == first) then
              table.insert(batchSelection, child);
              for i = index + 1, #group.controlledChildren do
                local current = group.controlledChildren[i];
                if (WeakAuras.GetData(current).controlledChildren) then
                  -- Skip sub groups
                else
                  table.insert(batchSelection, current);
                end
                -- last button: stop selection
                if (current == target or current == first) then
                  break;
                end
              end
              break;
            end
          end
        elseif (firstData.parent == nil and targetData.parent == nil) then
          -- top-level
          for index, button in ipairs(frame.buttonsScroll.children) do
            if button.type == "WeakAurasDisplayButton" then
              local data = button.data;
              -- 1st button
              if (data and (data.id == target or data.id == first)) then
                table.insert(batchSelection, data.id);
                for i = index + 1, #frame.buttonsScroll.children do
                  local current = frame.buttonsScroll.children[i];
                  local currentData = current.data;
                  if currentData and not currentData.parent and not currentData.controlledChildren then
                    table.insert(batchSelection, currentData.id);
                    -- last button: stop selection
                    if (currentData.id == target or currentData.id == first) then
                      break;
                    end
                  end
                end
                break;
              end
            end
          end
        end
        if #batchSelection > 0 then
          frame:PickDisplayBatch(batchSelection);
        end
      end
    end
  else
    WeakAuras.PickDisplay(target);
  end
end

function OptionsPrivate.GetDisplayButton(id)
  if(id and displayButtons[id]) then
    return displayButtons[id];
  end
end

function OptionsPrivate.AddDisplayButton(data)
  EnsureDisplayButton(data);
  WeakAuras.UpdateThumbnail(data);
  frame.buttonsScroll:AddChild(displayButtons[data.id]);
end

function OptionsPrivate.StartGrouping(data)
  if not data then
    return
  end

  if not OptionsPrivate.IsDisplayPicked(data) then
    WeakAuras.PickDisplay(data.id)
  end

  if (frame.pickedDisplay == tempGroup and #tempGroup.controlledChildren > 0) then
    local children = {};
    -- start grouping for selected buttons
    for index, childId in ipairs(tempGroup.controlledChildren) do
      local button = OptionsPrivate.GetDisplayButton(childId);
      button:StartGrouping(tempGroup.controlledChildren, true);
      children[childId] = true;
    end
    -- set grouping for non selected buttons
    for _, button in pairs(displayButtons) do
      if not children[button.data.id] then
        button:StartGrouping(tempGroup.controlledChildren, false);
      end
    end
  else
    local children = {};
    for child in OptionsPrivate.Private.TraverseAllChildren(data) do
      children[child.id] = true
    end

    for id, button in pairs(displayButtons) do
      button:StartGrouping({data.id},
                           data.id == id,
                           data.regionType == "dynamicgroup" or data.regionType == "group",
                           children[id]);
    end
  end
end

function OptionsPrivate.StopGrouping(data)
  for id, button in pairs(displayButtons) do
    button:StopGrouping();
  end
end

function OptionsPrivate.Ungroup(data)
  if not OptionsPrivate.IsDisplayPicked(data.id) then
    WeakAuras.PickDisplay(data.id)
  end

  if (frame.pickedDisplay == tempGroup and #tempGroup.controlledChildren > 0) then
    for index, childId in ipairs(tempGroup.controlledChildren) do
      local button = OptionsPrivate.GetDisplayButton(childId);
      button:Ungroup(data);
    end
  else
    local button = OptionsPrivate.GetDisplayButton(data.id);
    button:Ungroup(data);
  end
  WeakAuras.FillOptions()
end

function OptionsPrivate.DragReset()
  for _, button in pairs(displayButtons) do
    button:DragReset();
  end
  OptionsPrivate.UpdateButtonsScroll()
end

local function CompareButtonOrder(a, b)
  if (a.data.parent == b.data.parent) then
    if (a.data.parent) then
      return a:GetGroupOrder() < b:GetGroupOrder()
    else
      return a.data.id < b.data.id
    end
  end

  -- Different parents, so find common parent by first
  -- going up a's hierarchy

  local parents = {}

  local aNode = a.data.id
  local lastAParent = aNode

  while(aNode) do
    local parent = WeakAuras.GetData(aNode).parent
    if (parent) then
      parents[parent] = aNode
      lastAParent = parent
    end
    aNode = parent
  end

  local bNode = b.data.id
  local lastBParent = bNode

  while(bNode) do
    local parent = WeakAuras.GetData(bNode).parent
    if parent then
      if (parents[parent]) then
        -- We have found the common parent, the last node in the chain is
        -- Compare the previous nodes GroupOrder
        local aButton = OptionsPrivate.GetDisplayButton(parents[parent])
        local bButton = OptionsPrivate.GetDisplayButton(bNode)
        return aButton:GetGroupOrder() < bButton:GetGroupOrder()
      end
      lastBParent = parent
    end
    bNode = parent
  end

  -- If we are here there was no common parent
  local aButton = OptionsPrivate.GetDisplayButton(lastAParent)
  local bButton = OptionsPrivate.GetDisplayButton(lastBParent)

  return aButton.data.id < bButton.data.id
end

local function CompareButtonOrderReverse(a, b)
  return CompareButtonOrder(b, a)
end

function OptionsPrivate.Drop(mainAura, target, action, area)
  WeakAuras_DropDownMenu:Hide()

  local func1 = function()
    frame:SetLoadProgressVisible(true)

    local total = 0
    local num = 0
    for id, button in pairs(displayButtons) do
      if button:IsDragging() then
        total = total + 1
      end
    end
    frame.loadProgress:SetText(L["Moving auras: "]..num.."/"..total)

    local mode = ""
    if (frame.pickedDisplay == tempGroup and #tempGroup.controlledChildren > 0) then
      mode = "MULTI"
    elseif mainAura.controlledChildren then
      mode = "GROUP"
    else
      mode = "SINGLE"
    end

    local buttonsToSort = {}

    for id, button in pairs(displayButtons) do
      if button:IsDragging() then
        tinsert(buttonsToSort, button)
        num = num + 1
        frame.loadProgress:SetText(L["Preparing auras: "]..num.."/"..total)
      else
        button:Drop(mode, mainAura, target, action);
      end
      coroutine.yield()
    end

    num = 0
    frame.loadProgress:SetText(L["Moving auras: "]..num.."/"..total)
    if mode == "MULTI" then
      -- If we are dragging and dropping multiple auras at once, the order in which we drop is important
      -- We want to preserve the top-down order
      -- Depending on how exactly we find the insert position, we need to use the right order of insertions
      if area == "GROUP" then
        table.sort(buttonsToSort, CompareButtonOrderReverse)
      elseif area == "BEFORE" then
        table.sort(buttonsToSort, CompareButtonOrder)
      else -- After
        table.sort(buttonsToSort, CompareButtonOrderReverse)
      end
    end

    for _, button in ipairs(buttonsToSort) do
      button:Drop(mode, mainAura, target, action)
      num = num + 1
      frame.loadProgress:SetText(L["Moving auras: "]..num.."/"..total)
      coroutine.yield()
    end

    -- Update offset, this is a bit wasteful to do for every aura
    -- But we also need to update the offset if a parent was dragged
    for _, button in pairs(displayButtons) do
      button:UpdateOffset();
    end
    coroutine.yield()
    frame:SetLoadProgressVisible(false)
    OptionsPrivate.SortDisplayButtons()
    OptionsPrivate.UpdateButtonsScroll()
    WeakAuras.FillOptions()
  end

  local co1 = coroutine.create(func1)
  OptionsPrivate.Private.Threads:Add("Dropping Auras", co1)
end

function OptionsPrivate.StartDrag(mainAura)
  WeakAuras_DropDownMenu:Hide()

  if (frame.pickedDisplay == tempGroup and #tempGroup.controlledChildren > 0) then
    -- Multi selection
    local children = {};
    local size = #tempGroup.controlledChildren;
    -- set dragging for selected buttons in reverse for ordering

    for child in OptionsPrivate.Private.TraverseAllChildren(tempGroup) do
      local button = OptionsPrivate.GetDisplayButton(child.id);
      button:DragStart("MULTI", true, mainAura, size)
      children[child.id] = true
    end
    -- set dragging for non selected buttons
    for id, button in pairs(displayButtons) do
      if not children[button.data.id] then
        button:DragStart("MULTI", false, mainAura);
      end
    end
  else
    if mainAura.controlledChildren then
      -- Group aura
      local mode = "GROUP"
      local children = {};
      for child in OptionsPrivate.Private.TraverseAll(mainAura) do
        local button = OptionsPrivate.GetDisplayButton(child.id);
        button:DragStart(mode, true, mainAura)
        children[child.id] = true
      end
      -- set dragging for non selected buttons
      for _, button in pairs(displayButtons) do
        if not children[button.data.id] then
          button:DragStart(mode, false, mainAura);
        end
      end
    else
      for id, button in pairs(displayButtons) do
        button:DragStart("SINGLE", id == mainAura.id, mainAura);
      end
    end
  end
  OptionsPrivate.UpdateButtonsScroll()
end

function OptionsPrivate.DropIndicator()
  local indicator = frame.dropIndicator
  if not indicator then
    ---@class Frame
    indicator = CreateFrame("Frame", "WeakAuras_DropIndicator")
    indicator:SetHeight(4)
    indicator:SetFrameStrata("FULLSCREEN")

    local groupTexture = indicator:CreateTexture(nil, "ARTWORK")
    groupTexture:SetBlendMode("ADD")
    groupTexture:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite")

    local lineTexture = indicator:CreateTexture(nil, "ARTWORK")
    lineTexture:SetBlendMode("ADD")
    lineTexture:SetAllPoints(indicator)
    lineTexture:SetTexture("Interface\\PaperDollInfoFrame\\UI-Character-Tab-Highlight")

    indicator.lineTexture = lineTexture
    indicator.groupTexture = groupTexture
    frame.dropIndicator = indicator
    indicator:Hide()

    function indicator:ShowAction(target, action)
      self:Show()
      self:ClearAllPoints()
      if action == "GROUP" then
        self.groupTexture:ClearAllPoints()
        self.groupTexture:SetVertexColor(0.4, 0.7, 1, 0.7)
        self.groupTexture:Show()
        self.groupTexture:SetPoint("TOPLEFT", target.icon, "TOPRIGHT", 2, -1)
        self.groupTexture:SetPoint("BOTTOMRIGHT", target.frame, "BOTTOMRIGHT", 0, 1)
      else
        self.groupTexture:Hide()
      end

      -- Position line texture, if needed
      if action == "BEFORE" then
        self.lineTexture:Show()
        self:SetPoint("BOTTOMLEFT", target.frame, "TOPLEFT", 0, -1)
        self:SetPoint("BOTTOMRIGHT", target.frame, "TOPRIGHT", 0, -1)
        self:SetHeight(4)
      elseif action == "AFTER" then
        self.lineTexture:Show()
        self:SetPoint("TOPLEFT", target.frame, "BOTTOMLEFT", 0, 1)
        self:SetPoint("TOPRIGHT", target.frame, "BOTTOMRIGHT", 0, 1)
        self:SetHeight(4)
      else
        self.lineTexture:Hide()
      end
    end

  end
  return indicator
end

function WeakAuras.UpdateThumbnail(data)
  local id = data.id
  local button = displayButtons[id]
  if (not button) then
    return
  end
  button:UpdateThumbnail()
end

function OptionsPrivate.OpenTexturePicker(baseObject, paths, properties, textures, SetTextureFunc, adjustSize)
   OptionsPrivate.TexturePicker(frame):Open(baseObject, paths, properties, textures, SetTextureFunc, adjustSize)
end

function OptionsPrivate.OpenIconPicker(baseObject, paths, groupIcon)
  OptionsPrivate.IconPicker(frame):Open(baseObject, paths, groupIcon)
end

function OptionsPrivate.OpenModelPicker(baseObject, path)
  if not(C_AddOns.IsAddOnLoaded("WeakAurasModelPaths")) then
    local loaded, reason = C_AddOns.LoadAddOn("WeakAurasModelPaths");
    if not(loaded) then
      reason = string.lower("|cffff2020" .. _G["ADDON_" .. reason] .. "|r.")
      WeakAuras.prettyPrint(string.format(L["ModelPaths could not be loaded, the addon is %s"], reason));
      WeakAuras.ModelPaths = {};
    end
    OptionsPrivate.ModelPicker(frame).modelTree:SetTree(WeakAuras.ModelPaths)
  end
  OptionsPrivate.ModelPicker(frame):Open(baseObject, path);
end

function OptionsPrivate.OpenCodeReview(data)
  OptionsPrivate.CodeReview(frame):Open(data);
end

function OptionsPrivate.OpenTriggerTemplate(data, targetId)
  if not(C_AddOns.IsAddOnLoaded("WeakAurasTemplates")) then
    local loaded, reason = C_AddOns.LoadAddOn("WeakAurasTemplates");
    if not(loaded) then
      reason = string.lower("|cffff2020" .. _G["ADDON_" .. reason] .. "|r.")
      WeakAuras.prettyPrint(string.format(L["Templates could not be loaded, the addon is %s"], reason));
      return;
    end
    frame.newView = WeakAuras.CreateTemplateView(OptionsPrivate.Private, frame);
  end
  -- This is called multiple times if a group is selected
  if frame.window ~= "newView" then
    frame.newView:Open(data, targetId);
  end
end

OptionsPrivate.currentDynamicTextInput = false;

local BaseDynamicTextCodes = {
  trigger = {
    {type = "mini", name = "p", desc = L["Progress - The remaining time of a timer, or a non-timer value"]},
    {type = "mini", name = "t", desc = L["Total - The maximum duration of a timer, or a maximum non-timer value"]},
    {type = "mini", name = "n", desc = L["Name - The name of the display (usually an aura name), or the display's ID if there is no dynamic name"]},
    {type = "mini", name = "i", desc = L["Icon - The icon associated with the display"]},
    {type = "mini", name = "s", desc = L["Stacks - The number of stacks of an aura (usually)"]},
  },
  global = {
    {type = "mini", name = "c", desc = L["Custom - Allows you to define a custom Lua function that returns a list of string values. %c1 will be replaced by the first value returned, %c2 by the second, etc."]},
    {type = "mini", name = "%", desc = L["% - To show a percent sign"]},
  }
}

function OptionsPrivate.UpdateTextReplacements(frame, data)
  frame.scrollList:ReleaseChildren()

  local props = OptionsPrivate.Private.GetAdditionalProperties(data)
  local sortedProps = {}

  -- Add global header and markers
  table.insert(sortedProps, {type = "header", triggerNum = 0, name = "Global Properties"})
  for index, icon in ipairs(ICON_LIST) do
    table.insert(sortedProps, {type = "marker", triggerNum = 0, name = "{rt"..index.."}", desc = icon..":0|t", widthFraction = #ICON_LIST})
  end

  -- Add base dynamic text codes
  local globalProps = {}
  tAppendAll(globalProps, CopyTable(BaseDynamicTextCodes.trigger))
  tAppendAll(globalProps, CopyTable(BaseDynamicTextCodes.global))
  for _, prop in ipairs(globalProps) do
    prop.widthFraction = #globalProps
    prop.triggerNum = 0
    table.insert(sortedProps, prop)
  end

  -- Process each trigger's properties
  for triggerNum, triggerProps in pairs(props) do
    if next(triggerProps) then
      -- Create a temporary table for this trigger's properties
      local tempProps = {}

      -- Add the properties to the temporary table
      for name, data in pairs(triggerProps) do
        table.insert(tempProps, {triggerNum = triggerNum, name = name, desc = data.display})
      end

      -- Sort the temporary table by name
      table.sort(tempProps, function(a, b)
        return a.name < b.name
      end)

      -- Add a header for the trigger
      table.insert(sortedProps, {type = "header", triggerNum = triggerNum, name = OptionsPrivate.GetTriggerTitle(data, triggerNum)})

      -- Add the base properties for the trigger
      for _, v in ipairs(BaseDynamicTextCodes.trigger) do
        local prop = CopyTable(v)
        prop.widthFraction = #BaseDynamicTextCodes.trigger
        prop.triggerNum = triggerNum
        table.insert(sortedProps, prop)
      end

      -- Add the sorted properties to the sortedProps table
      for _, prop in ipairs(tempProps) do
        table.insert(sortedProps, prop)
      end
    end
  end

  -- Create a modified WeakAurasSnippetButton for each property and add it to ScrollList
  local lastType, miniGroup
  for i, prop in ipairs(sortedProps) do
    if prop.type == "header" then
      local heading = AceGUI:Create("Heading")
      heading:SetText(prop.name)
      heading:SetRelativeWidth(1)
      heading.label:SetFontObject(GameFontNormalSmall2)
      frame.scrollList:AddChild(heading)
    else
      if ((prop.type == "mini" or prop.type == "marker") and prop.type ~= lastType)
      then
        miniGroup = AceGUI:Create("SimpleGroup")
        miniGroup:SetLayout("Flow")
        miniGroup:SetAutoAdjustHeight(true)
        miniGroup:SetRelativeWidth(1)
        frame.scrollList:AddChild(miniGroup)
      end
      local button = AceGUI:Create("WeakAurasSnippetButton")
      local propIndex = prop.triggerNum > 0 and ("%s"):format(prop.triggerNum) or ""
      local propPrefix = prop.triggerNum > 0 and ("%%%s."):format(propIndex) or "%"
      if prop.type == "marker" then
        button:SetTitle(prop.desc)
      else
        button:SetTitle(string.format("|cFFFFCC00%s|r%s", propPrefix, prop.name))
      end
      if prop.type == "mini" or prop.type == "marker" then
        button:SetRelativeWidth((1/prop.widthFraction) - 1e-10)
      else
        button:SetRelativeWidth(1)
      end
      button.title:SetFontObject(GameFontNormal)
      button.frame:SetHeight(28)
      button:SetDynamicTextStyle()

      -- Set Tooltip
      if prop.type ~= "marker" then
        button.frame:SetScript("OnEnter", function(frame)
          local tooltip = GameTooltip
          tooltip:SetWidth(300)
          tooltip:SetOwner(frame, "ANCHOR_RIGHT")
          tooltip:ClearLines()
          tooltip:AddLine(("%s%s"):format(propPrefix, prop.name))
          tooltip:AddLine(prop.desc, 1, 1, 1, true)
          if prop.name ~= "c" and prop.name ~= "%" then
            tooltip:AddLine("\n")
            tooltip:AddLine(
              prop.triggerNum > 0
              and L["The trigger number is optional. When no trigger number is specified, the trigger selected via dynamic information will be used."]
              or L["By default this shows the information from the trigger selected via dynamic information. The information from a specific trigger can be shown via e.g. %2.p."],
              0.8, 0.8, 0.8,
              true)
          end
          tooltip:Show()
          frame.obj:Fire("OnEnter")
        end)
      else
        button.frame:SetScript("OnEnter", nil)
      end

      -- Insert dynamic text property on click
      button:SetCallback("OnClick", function()
        local insertProp
        if prop.type == "marker" then
          insertProp = prop.name
        else
          if IsShiftKeyDown() then
            insertProp = prop.name == "%" and "%%" or ("%%{%s}"):format(prop.name)
            if prop.triggerNum > 0 then
              insertProp = string.format("%%{%d.%s}", propIndex, prop.name)
            end
          else
            insertProp = prop.name == "%" and "%%" or ("%%%s"):format(prop.name)
            if prop.triggerNum > 0 then
              insertProp = string.format("%%%d.%s", propIndex, prop.name)
            end
          end
        end

        OptionsPrivate.currentDynamicTextInput.editbox:Insert(insertProp)
        OptionsPrivate.currentDynamicTextInput.editbox:SetFocus()
      end)

      if prop.type == "mini" or prop.type == "marker" then
        miniGroup:AddChild(button)
      else
        frame.scrollList:AddChild(button)
      end
    end
    lastType = prop.type
  end
end

function OptionsPrivate.ResetMoverSizer()
  if(frame and frame.mover and frame.moversizer and frame.mover.moving.region and frame.mover.moving.data) then
    frame.moversizer:SetToRegion(frame.mover.moving.region, frame.mover.moving.data);
  end
end

function WeakAuras.SetMoverSizer(id)
  OptionsPrivate.Private.EnsureRegion(id)
  if OptionsPrivate.Private.regions[id].region.toShow then
    frame.moversizer:SetToRegion(OptionsPrivate.Private.regions[id].region, db.displays[id])
  else
    if OptionsPrivate.Private.clones[id] then
      local _, clone = next(OptionsPrivate.Private.clones[id])
      if clone then
        frame.moversizer:SetToRegion(clone, db.displays[id])
      end
    end
  end
end

function WeakAuras.GetMoverSizerId()
  return frame.moversizer:GetCurrentId()
end

local function AddDefaultSubRegions(data)
  data.subRegions = data.subRegions or {}
  for type, subRegionData in pairs(OptionsPrivate.Private.subRegionTypes) do
    if subRegionData.addDefaultsForNewAura then
      subRegionData.addDefaultsForNewAura(data)
    end
  end
end

function WeakAuras.NewAura(sourceData, regionType, targetId)
  local function ensure(t, k, v)
    return t and k and v and t[k] == v
  end
  local new_id = OptionsPrivate.Private.FindUnusedId("New")
  local data = {id = new_id, regionType = regionType, uid = WeakAuras.GenerateUniqueID()}
  WeakAuras.DeepMixin(data, OptionsPrivate.Private.data_stub);
  if (sourceData) then
    WeakAuras.DeepMixin(data, sourceData);
  end
  data.internalVersion = WeakAuras.InternalVersion();
  OptionsPrivate.Private.validate(data, OptionsPrivate.Private.regionTypes[regionType].default);

  AddDefaultSubRegions(data)

  if targetId then
    local target = OptionsPrivate.GetDisplayButton(targetId);
    local group
    if (target) then
      if (target:IsGroup()) then
        group = target;
      else
        group = OptionsPrivate.GetDisplayButton(target.data.parent);
      end
      if (group) then
        -- Sanity check so that we don't create a group/dynamic group in a group
        if (regionType == "group" or regionType == "dynamicgroup") and group.data.regionType == "dynamicgroup" then
          return
        end

        local children = group.data.controlledChildren;
        local index = target:GetGroupOrder();
        if (ensure(children, index, target.data.id)) then
          -- account for insert position
          index = index + 1;
          tinsert(children, index, data.id);
        else
          -- move source into group as the first child
          tinsert(children, 1, data.id);
        end
        data.parent = group.data.id;
        WeakAuras.Add(data);
        WeakAuras.Add(group.data);
        OptionsPrivate.Private.AddParents(group.data)
        WeakAuras.NewDisplayButton(data);
        WeakAuras.UpdateGroupOrders(group.data);
        OptionsPrivate.ClearOptions(group.data.id);
        group.callbacks.UpdateExpandButton();
        group:UpdateParentWarning();
        group:Expand();
        group:ReloadTooltip();
        OptionsPrivate.PickAndEditDisplay(data.id);
      else
        -- move source into the top-level list
        WeakAuras.Add(data);
        WeakAuras.NewDisplayButton(data);
        OptionsPrivate.PickAndEditDisplay(data.id);
      end
    else
      error(string.format("Calling 'WeakAuras.NewAura' with invalid groupId %s. Reload your UI to fix the display list.", targetId))
    end
  else
    -- move source into the top-level list
    WeakAuras.Add(data);
    WeakAuras.NewDisplayButton(data);
    OptionsPrivate.PickAndEditDisplay(data.id);
  end
end


function OptionsPrivate.ResetCollapsed(id, namespace)
  if id then
    if namespace and collapsedOptions[id] then
      collapsedOptions[id][namespace] = nil
    else
      collapsedOptions[id] = nil
    end
  end
end

function OptionsPrivate.IsCollapsed(id, namespace, path, default)
  local tmp = collapsedOptions[id]
  if tmp == nil then return default end

  tmp = tmp[namespace]
  if tmp == nil then return default end

  if type(path) ~= "table" then
    tmp = tmp[path]
  else
    for _, key in ipairs(path) do
      tmp = tmp[key]
      if tmp == nil or tmp[collapsed] then
        break
      end
    end
  end
  if tmp == nil or tmp[collapsed] == nil then
    return default
  else
    return tmp[collapsed]
  end
end

function OptionsPrivate.SetCollapsed(id, namespace, path, v)
  collapsedOptions[id] = collapsedOptions[id] or {}
  collapsedOptions[id][namespace] = collapsedOptions[id][namespace] or {}
  if type(path) ~= "table" then
    collapsedOptions[id][namespace][path] = collapsedOptions[id][namespace][path] or {}
    collapsedOptions[id][namespace][path][collapsed] = v
  else
    local tmp = collapsedOptions[id][namespace] or {}
    for _, key in ipairs(path) do
      tmp[key] = tmp[key] or {}
      tmp = tmp[key]
    end
    tmp[collapsed] = v
  end
end

function OptionsPrivate.MoveCollapseDataUp(id, namespace, path)
  collapsedOptions[id] = collapsedOptions[id] or {}
  collapsedOptions[id][namespace] = collapsedOptions[id][namespace] or {}
  if type(path) ~= "table" then
    collapsedOptions[id][namespace][path], collapsedOptions[id][namespace][path - 1]
      = collapsedOptions[id][namespace][path - 1], collapsedOptions[id][namespace][path]
  else
    local tmp = collapsedOptions[id][namespace]
    local lastKey = tremove(path)
    for _, key in ipairs(path) do
      tmp[key] = tmp[key] or {}
      tmp = tmp[key]
    end
    tmp[lastKey], tmp[lastKey - 1] = tmp[lastKey - 1], tmp[lastKey]
  end
end

function OptionsPrivate.MoveCollapseDataDown(id, namespace, path)
  collapsedOptions[id] = collapsedOptions[id] or {}
  collapsedOptions[id][namespace] = collapsedOptions[id][namespace] or {}
  if type(path) ~= "table" then
    collapsedOptions[id][namespace][path], collapsedOptions[id][namespace][path + 1]
      = collapsedOptions[id][namespace][path + 1], collapsedOptions[id][namespace][path]
  else
    local tmp = collapsedOptions[id][namespace]
    local lastKey = tremove(path)
    for _, key in ipairs(path) do
      tmp[key] = tmp[key] or {}
      tmp = tmp[key]
    end
    tmp[lastKey], tmp[lastKey + 1] = tmp[lastKey + 1], tmp[lastKey]
  end
end

function OptionsPrivate.RemoveCollapsed(id, namespace, path)
  local data = collapsedOptions[id] and collapsedOptions[id][namespace]
  if not data then
    return
  end
  local index
  local maxIndex = 0
  if type(path) ~= "table" then
    index = path
  else
    index = path[#path]
    for i = 1, #path - 1 do
      data = data[path[i]]
      if not data then
        return
      end
    end
  end
  for k in pairs(data) do
    if k ~= collapsed then
      maxIndex = max(maxIndex, k)
    end
  end
  while index <= maxIndex do
    data[index] = data[index + 1]
    index = index + 1
  end
end

function OptionsPrivate.InsertCollapsed(id, namespace, path, value)
  local data = collapsedOptions[id] and collapsedOptions[id][namespace]
  if not data then
    return
  end
  local insertPoint
  local maxIndex
  if type(path) ~= "table" then
    insertPoint = path
  else
    insertPoint = path[#path]
    for i = 1, #path - 1 do
      data = data[path[i]]
      if not data then
        return
      end
    end
  end
  for k in pairs(data) do
    if k ~= collapsed and k >= insertPoint then
      if not maxIndex or k > maxIndex then
        maxIndex = k
      end
    end
  end
  if maxIndex then -- may be nil if insertPoint is greater than the max of anything else
    for i = maxIndex, insertPoint, -1 do
      data[i + 1] = data[i]
    end
  end
  data[insertPoint] = {[collapsed] = value}
end

function OptionsPrivate.DuplicateCollapseData(id, namespace, path)
  collapsedOptions[id] = collapsedOptions[id] or {}
  collapsedOptions[id][namespace] = collapsedOptions[id][namespace] or {}
  if type(path) ~= "table" then
    if (collapsedOptions[id][namespace][path]) then
      tinsert(collapsedOptions[id][namespace], path + 1, CopyTable(collapsedOptions[id][namespace][path]))
    end
  else
    local tmp = collapsedOptions[id][namespace]
    local lastKey = tremove(path)
    for _, key in ipairs(path) do
      tmp[key] = tmp[key] or {}
      tmp = tmp[key]
    end

    if (tmp[lastKey]) then
      tinsert(tmp, lastKey + 1, CopyTable(tmp[lastKey]))
    end
  end
end

function OptionsPrivate.AddTextFormatOption(input, withHeader, get, addOption, hidden, setHidden,
                                            withoutColor, index, total)
  local headerOption
  if withHeader and (not index or index == 1) then
    headerOption =  {
      type = "execute",
      control = "WeakAurasExpandSmall",
      name = L["|cffffcc00Format Options|r"],
      width = WeakAuras.doubleWidth,
      func = function(info, button)
        setHidden(not hidden())
      end,
      image = function()
        return hidden() and "collapsed" or "expanded"
      end,
      imageWidth = 15,
      imageHeight = 15,
      arg = {
        expanderName = tostring(addOption)
      }
    }
    addOption("header", headerOption)
  else
    hidden = false
  end


  local seenSymbols = {}

  local parseFn = function(symbol)
    if not seenSymbols[symbol] then
      local _, sym = string.match(symbol, "(.+)%.(.+)")
      sym = sym or symbol

      if sym == "i" then
        -- No special options for these
      else
        addOption(symbol .. "desc", {
          type = "description",
          name = L["Format for %s"]:format("%" .. symbol),
          width = WeakAuras.normalWidth,
          hidden = hidden
        })
        addOption(symbol .. "_format", {
          type = "select",
          name = L["Format"],
          width = WeakAuras.normalWidth,
          values = OptionsPrivate.Private.format_types_display,
          hidden = hidden,
          reloadOptions = true
        })

        local selectedFormat = get(symbol .. "_format")
        if (OptionsPrivate.Private.format_types[selectedFormat]) then
          OptionsPrivate.Private.format_types[selectedFormat].AddOptions(symbol, hidden, addOption, get, withoutColor)
        end
        seenSymbols[symbol] = true
      end
    end
  end

  if type(input) == "table" then
    for _, txt in ipairs(input) do
      OptionsPrivate.Private.ParseTextStr(txt, parseFn)
    end
  else
    OptionsPrivate.Private.ParseTextStr(input, parseFn)
  end

  if withHeader and (not index or index == total) then
    addOption("header_anchor",
    {
      type = "description",
      name = "",
      control = "WeakAurasExpandAnchor",
      arg = {
        expanderName = tostring(addOption)
      }
    }

  )
  end

  if not next(seenSymbols) and headerOption and not index then
    headerOption.hidden = true
  end

  return next(seenSymbols) ~= nil
end

=== END OF FILE: WeakAurasOptions/WeakAurasOptions.lua ===

