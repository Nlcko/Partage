-- Merged Lua files from directory: WeakAuras
-- Generated on: 2025-10-15T16:46:12.434Z
-- Total files merged: 110

-- ========================================
-- File: WeakAuras/AnchorToWeakAuras.lua
-- ========================================

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

--- @type table<auraId, auraId>
local attachedToTarget = {}
--- @type table<auraId, table<auraId, boolean>>
local targetToAttached = {}

-- Handles


--- @type fun(_: any, uid: uid, id: auraId)
local function OnDelete(_, uid, id)
  local target = attachedToTarget[id]
  if target then
    if targetToAttached[target] then
      targetToAttached[target][id] = nil
    end
    attachedToTarget[id] = nil
  end
end

--- @type fun(_: any, uid: uid, oldId: auraId, newId: auraId)
local function OnRename(_, uid, oldId, newId)

  local target = attachedToTarget[oldId]
  if target then
    -- renamed aura is an attached aura
    attachedToTarget[newId] = attachedToTarget[oldId]
    attachedToTarget[oldId] = nil

    targetToAttached[target][oldId] = nil
    targetToAttached[target][newId] = true
  end

  -- renamed aura is a targeted aura
  if targetToAttached[oldId] then
    for attached in pairs(targetToAttached[oldId]) do
      local data = WeakAuras.GetData(attached)
      if data then
        data.anchorFrameFrame = "WeakAuras:" .. newId
        WeakAuras.Add(data, true)
      end

      attachedToTarget[attached] = newId
    end
    targetToAttached[newId] = targetToAttached[oldId]
    targetToAttached[oldId] = nil
  end

end

--- @type fun(_: any, uid: uid, id: auraId, data: auraData, simpleChange: boolean)
local function OnAdd(_, uid, id, data, simpleChange)
  if simpleChange then
    return
  end
  OnDelete(nil, uid, id)
  if data.anchorFrameType == "SELECTFRAME"
     and data.anchorFrameFrame
     and data.anchorFrameFrame:sub(1, 10) == "WeakAuras:"
  then
    local target = data.anchorFrameFrame:sub(11)
    attachedToTarget[data.id] = target
    targetToAttached[target] = targetToAttached[target] or {}
    targetToAttached[target][data.id] = true
  end
end

Private.callbacks:RegisterCallback("Delete", OnDelete)
Private.callbacks:RegisterCallback("Rename", OnRename)
Private.callbacks:RegisterCallback("Add", OnAdd)


-- ========================================
-- File: WeakAuras/Animations.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
local L = WeakAuras.L

-- Animations
local animations = {}
local pending_controls = {}
local anim_function_strings = Private.anim_function_strings;

local function noopErrorHandler() end

local function RunAnimation(key, anim, elapsed, time)
  Private.StartProfileUID(anim.auraUID)
  local finished = false
  if(anim.duration_type == "seconds") then
    if anim.duration > 0 then
      anim.progress = anim.progress + (elapsed / anim.duration)
    else
      anim.progress = anim.progress + (elapsed / 1)
    end
    if(anim.progress >= 1) then
      anim.progress = 1
      finished = true
    end
  elseif(anim.duration_type == "relative") then
    local region = anim.region
    if ((region.progressType == "timed" and region.duration < 0.01)
        or (region.progressType == "static" and region.value < 0.01))
    then
      anim.progress = 0
      if(anim.type == "start" or anim.type == "finish") then
        finished = true
      end
    else
      local relativeProgress = 0
      if(region.progressType == "static") then
        relativeProgress = region.value / region.total
      elseif (region.progressType == "timed") then
        relativeProgress = 1 - ((region.expirationTime - time) / region.duration)
      end
      relativeProgress = region.inverse and (1 - relativeProgress) or relativeProgress
      anim.progress = anim.duration > 0 and  relativeProgress / anim.duration or 0
      local iteration = math.floor(anim.progress)
      --anim.progress = anim.progress - iteration
      if not(anim.iteration) then
        anim.iteration = iteration
      elseif(anim.iteration ~= iteration) then
        anim.iteration = nil
        finished = true
      end
    end
  else
    anim.progress = 1
  end
  local progress = anim.inverse and (1 - anim.progress) or anim.progress
  progress = anim.easeFunc(progress, anim.easeStrength or 3)
  Private.ActivateAuraEnvironmentForRegion(anim.region)
  if(anim.translateFunc) then
    local errorHandler = WeakAuras.IsOptionsOpen() and noopErrorHandler or Private.GetErrorHandlerUid(anim.auraUID, L["Slide Animation"])
    if (anim.region.SetOffsetAnim) then
      local ok, x, y = xpcall(anim.translateFunc, errorHandler, progress, 0, 0, anim.dX, anim.dY)
      anim.region:SetOffsetAnim(x, y)
    else
      anim.region:ClearAllPoints()
      local ok, x, y = xpcall(anim.translateFunc, errorHandler, progress, anim.startX, anim.startY, anim.dX, anim.dY)
      if (ok) then
        anim.region:SetPoint(anim.selfPoint, anim.anchor, anim.anchorPoint, x, y)
      end
    end
  end
  if(anim.alphaFunc) then
    local errorHandler = WeakAuras.IsOptionsOpen() and noopErrorHandler or Private.GetErrorHandlerUid(anim.auraUID, L["Fade Animation"])
    local ok, alpha = xpcall(anim.alphaFunc, errorHandler, progress, anim.startAlpha, anim.dAlpha)
    if (ok) then
      if (anim.region.SetAnimAlpha) then
        anim.region:SetAnimAlpha(alpha)
      else
        anim.region:SetAlpha(alpha)
      end
    end
  end
  if(anim.scaleFunc) then
    local errorHandler = WeakAuras.IsOptionsOpen() and noopErrorHandler
                                                   or Private.GetErrorHandlerUid(anim.auraUID, L["Zoom Animation"])
    local ok, scaleX, scaleY = xpcall(anim.scaleFunc, errorHandler, progress, 1, 1, anim.scaleX, anim.scaleY)
    if (ok) then
      if(anim.region.Scale) then
        anim.region:Scale(scaleX, scaleY)
      else
        anim.region:SetWidth(anim.startWidth * scaleX)
        anim.region:SetHeight(anim.startHeight * scaleY)
      end
    end
  end
  if(anim.rotateFunc and anim.region.SetAnimRotation) then
    local errorHandler = WeakAuras.IsOptionsOpen() and noopErrorHandler
                                                   or Private.GetErrorHandlerUid(anim.auraUID, L["Rotate Animation"])
    local ok, rotate = xpcall(anim.rotateFunc, errorHandler, progress, anim.region:GetBaseRotation(), anim.rotate)
    if (ok) then
      anim.region:SetAnimRotation(rotate)
    end
  end
  if(anim.colorFunc and anim.region.ColorAnim) then
    local errorHandler = WeakAuras.IsOptionsOpen() and noopErrorHandler
                                                   or Private.GetErrorHandlerUid(anim.auraUID, L["Color Animation"])
    local startR, startG, startB, startA = anim.region:GetColor()
    startR, startG, startB, startA = startR or 1, startG or 1, startB or 1, startA or 1
    local ok, r, g, b, a = xpcall(anim.colorFunc, errorHandler, progress, startR, startG, startB, startA,
                                  anim.colorR, anim.colorG, anim.colorB, anim.colorA)
    if (ok) then
      local errorHandler = Private.GetErrorHandlerId(anim.region.id, "Custom Color")
      xpcall(anim.region.ColorAnim, errorHandler, anim.region, r, g, b, a)
    end
  end
  Private.ActivateAuraEnvironment(nil)
  if(finished) then
    if not(anim.loop) then
      if (anim.region.SetOffsetAnim) then
        anim.region:SetOffsetAnim(0, 0)
      else
        if(anim.startX) then
          anim.region:SetPoint(anim.selfPoint, anim.anchor, anim.anchorPoint, anim.startX, anim.startY)
        end
      end
      if (anim.region.SetAnimAlpha) then
        anim.region:SetAnimAlpha(nil)
      elseif(anim.startAlpha) then
        anim.region:SetAlpha(anim.startAlpha)
      end
      if(anim.startWidth) then
        if(anim.region.Scale) then
          anim.region:Scale(1, 1)
        else
          anim.region:SetWidth(anim.startWidth)
          anim.region:SetHeight(anim.startHeight)
        end
      end
      if(anim.region.SetAnimRotation) then
        anim.region:SetAnimRotation(nil)
      end
      if(anim.region.ColorAnim) then
        anim.region:ColorAnim(nil)
      end
      animations[key] = nil
    end

    if(anim.loop) then
      Private.Animate(anim.namespace, anim.auraUID, anim.type, anim.anim, anim.region, anim.inverse, anim.onFinished,
                      anim.loop, anim.region.cloneId)
    elseif(anim.onFinished) then
      anim.onFinished()
    end
  end
  Private.StopProfileUID(anim.auraUID)
end

local updatingAnimations;
local last_update = GetTime();
local function UpdateAnimations()
  if not updatingAnimations then
    return
  end
  Private.StartProfileSystem("animations");

  for groupUid, groupRegion in pairs(pending_controls) do
    pending_controls[groupUid] = nil;
    groupRegion:DoPositionChildren();
  end

  local time = GetTime();
  local elapsed = time - last_update;
  last_update = time;

  for key, anim in pairs(animations) do
    RunAnimation(key, anim, elapsed, time)
  end

  Private.StopProfileSystem("animations");
end

local frame = CreateFrame("Frame")
Private.frames["WeakAuras Animation Frame"] = frame
frame:SetScript("OnUpdate", UpdateAnimations)

function Private.RegisterGroupForPositioning(uid, region)
  pending_controls[uid] = region
  if not updatingAnimations then
    updatingAnimations = true
    last_update = GetTime()
  end
end

function Private.Animate(namespace, uid, type, anim, region, inverse, onFinished, loop, cloneId)
  local key = tostring(region);
  local valid;
  if(anim and anim.type == "custom" and (anim.use_translate or anim.use_alpha or (anim.use_scale and region.Scale) or (anim.use_rotate and region.SetAnimRotation) or (anim.use_color and region.Color))) then
    valid = true;
  elseif(anim and anim.type == "preset" and anim.preset and Private.anim_presets[anim.preset]) then
    anim = Private.anim_presets[anim.preset];
    valid = true;
  end
  if(valid) then
    local progress, duration, selfPoint, anchor, anchorPoint, startX, startY, startAlpha, startWidth, startHeight, easeType, easeStrength;
    local translateFunc, alphaFunc, scaleFunc, rotateFunc, colorFunc, easeFunc;
    if(animations[key]) then
      if(animations[key].type == type and not loop) then
        return "no replace";
      end
      anim.x = anim.x or 0;
      anim.y = anim.y or 0;
      selfPoint, anchor, anchorPoint, startX, startY = animations[key].selfPoint, animations[key].anchor, animations[key].anchorPoint, animations[key].startX, animations[key].startY;
      anim.alpha = anim.alpha or 0;
      startAlpha = animations[key].startAlpha;
      anim.scalex = anim.scalex or 1;
      anim.scaley = anim.scaley or 1;
      startWidth, startHeight = animations[key].startWidth, animations[key].startHeight;
      anim.rotate = anim.rotate or 0;
      anim.colorR = anim.colorR or 1;
      anim.colorG = anim.colorG or 1;
      anim.colorB = anim.colorB or 1;
      anim.colorA = anim.colorA or 1;
    else
      anim.x = anim.x or 0;
      anim.y = anim.y or 0;
      if not region.SetOffsetAnim then
        selfPoint, anchor, anchorPoint, startX, startY = region:GetPoint(1);
      end
      anim.alpha = anim.alpha or 0;
      startAlpha = region:GetAlpha();
      anim.scalex = anim.scalex or 1;
      anim.scaley = anim.scaley or 1;
      startWidth, startHeight = region:GetWidth(), region:GetHeight();
      anim.rotate = anim.rotate or 0;
      anim.colorR = anim.colorR or 1;
      anim.colorG = anim.colorG or 1;
      anim.colorB = anim.colorB or 1;
      anim.colorA = anim.colorA or 1;
    end

    if(anim.use_translate) then
      if not(anim.translateType == "custom" and anim.translateFunc) then
        anim.translateType = anim.translateType or "straightTranslate";
        anim.translateFunc = anim_function_strings[anim.translateType]
      end
      if (anim.translateFunc) then
        translateFunc = WeakAuras.LoadFunction("return " .. anim.translateFunc, uid);
      else
        if (region.SetOffsetAnim) then
          region:SetOffsetAnim(0, 0);
        else
          region:SetPoint(selfPoint, anchor, anchorPoint, startX, startY);
        end
      end
    else
      if (region.SetOffsetAnim) then
        region:SetOffsetAnim(0, 0);
      else
        region:SetPoint(selfPoint, anchor, anchorPoint, startX, startY);
      end
    end
    if(anim.use_alpha) then
      if not(anim.alphaType == "custom" and anim.alphaFunc) then
        anim.alphaType = anim.alphaType or "straight";
        anim.alphaFunc = anim_function_strings[anim.alphaType]
      end
      if (anim.alphaFunc) then
        alphaFunc = WeakAuras.LoadFunction("return " .. anim.alphaFunc, uid);
      else
        if (region.SetAnimAlpha) then
          region:SetAnimAlpha(nil);
        else
          region:SetAlpha(startAlpha);
        end
      end
    else
      if (region.SetAnimAlpha) then
        region:SetAnimAlpha(nil);
      else
        region:SetAlpha(startAlpha);
      end
    end
    if(anim.use_scale) then
      if not(anim.scaleType == "custom" and anim.scaleFunc) then
        anim.scaleType = anim.scaleType or "straightScale";
        anim.scaleFunc = anim_function_strings[anim.scaleType]
      end
      if (anim.scaleFunc) then
        scaleFunc = WeakAuras.LoadFunction("return " .. anim.scaleFunc, uid);
      else
        region:Scale(1, 1);
      end
    elseif(region.Scale) then
      region:Scale(1, 1);
    end
    if(anim.use_rotate) then
      if not(anim.rotateType == "custom" and anim.rotateFunc) then
        anim.rotateType = anim.rotateType or "straight";
        anim.rotateFunc = anim_function_strings[anim.rotateType]
      end
      if (anim.rotateFunc) then
        rotateFunc = WeakAuras.LoadFunction("return " .. anim.rotateFunc, uid);
      else
        region:SetAnimRotation(nil)
      end
    elseif(region.SetAnimRotation) then
      region:SetAnimRotation(nil)
    end
    if(anim.use_color) then
      if not(anim.colorType == "custom" and anim.colorFunc) then
        anim.colorType = anim.colorType or "straightColor";
        anim.colorFunc = anim_function_strings[anim.colorType]
      end
      if (anim.colorFunc) then
        colorFunc = WeakAuras.LoadFunction("return " .. anim.colorFunc, uid);
      else
        region:ColorAnim(nil);
      end
    elseif(region.ColorAnim) then
      region:ColorAnim(nil);
    end
    easeFunc = Private.anim_ease_functions[anim.easeType or "none"]

    duration = Private.ParseNumber(anim.duration) or 0;
    progress = 0;
    if(namespace == "display" and type == "main" and not onFinished and not anim.duration_type == "relative") then
      local data = Private.GetDataByUID(uid);
      if(data and data.parent) then
        local parentRegion = WeakAuras.GetRegion(data.parent)
        if(parentRegion and parentRegion.controlledRegions) then
          for index, regionData in pairs(parentRegion.controlledRegions) do
            local childRegion = regionData.region;
            local childKey = regionData.key;
            if(childKey and childKey ~= tostring(region) and animations[childKey] and animations[childKey].type == "main" and duration == animations[childKey].duration) then
              progress = animations[childKey].progress;
              break;
            end
          end
        end
      end
    end

    local animation = animations[key] or {}
    animations[key] = animation

    animation.progress = progress
    animation.startX = startX
    animation.startY = startY
    animation.startAlpha = startAlpha
    animation.startWidth = startWidth
    animation.startHeight = startHeight
    animation.dX = (anim.use_translate and anim.x)
    animation.dY = (anim.use_translate and anim.y)
    animation.dAlpha = (anim.use_alpha and (anim.alpha - startAlpha))
    animation.scaleX = (anim.use_scale and anim.scalex)
    animation.scaleY = (anim.use_scale and anim.scaley)
    animation.rotate = anim.rotate
    animation.colorR = (anim.use_color and anim.colorR)
    animation.colorG = (anim.use_color and anim.colorG)
    animation.colorB = (anim.use_color and anim.colorB)
    animation.colorA = (anim.use_color and anim.colorA)
    animation.translateFunc = translateFunc
    animation.alphaFunc = alphaFunc
    animation.scaleFunc = scaleFunc
    animation.rotateFunc = rotateFunc
    animation.colorFunc = colorFunc
    animation.region = region
    animation.selfPoint = selfPoint
    animation.anchor = anchor
    animation.anchorPoint = anchorPoint
    animation.duration = duration
    animation.duration_type = anim.duration_type or "seconds"
    animation.inverse = inverse
    animation.easeType = anim.easeType
    animation.easeFunc = easeFunc
    animation.easeStrength = anim.easeStrength
    animation.type = type
    animation.loop = loop
    animation.onFinished = onFinished
    animation.namespace = namespace;
    animation.anim = anim;
    animation.auraUID = uid

    if not(updatingAnimations) then
      last_update = GetTime()
      updatingAnimations = true;
    end
    return true;
  else
    if(animations[key]) then
      if(animations[key].type ~= type or loop) then
        Private.CancelAnimation(region, true, true, true, true, true);
      end
    end
    return false;
  end
end

function Private.CancelAnimation(region, resetPos, resetAlpha, resetScale, resetRotation, resetColor, doOnFinished)
  local key = tostring(region);
  local anim = animations[key];

  if(anim) then
    if(resetPos) then
      if (anim.region.SetOffsetAnim) then
        anim.region:SetOffsetAnim(0, 0);
      else
        anim.region:ClearAllPoints();
        anim.region:SetPoint(anim.selfPoint, anim.anchor, anim.anchorPoint, anim.startX, anim.startY);
      end
    end
    if(resetAlpha) then
      if (anim.region.SetAnimAlpha) then
        anim.region:SetAnimAlpha(nil);
      else
        anim.region:SetAlpha(anim.startAlpha);
      end
    end
    if(resetScale) then
      if(anim.region.Scale) then
        anim.region:Scale(1, 1);
      else
        anim.region:SetWidth(anim.startWidth);
        anim.region:SetHeight(anim.startHeight);
      end
    end
    if(resetRotation and anim.region.SetAnimRotation) then
      anim.region:SetAnimRotation(nil)
    end
    if(resetColor and anim.region.ColorAnim) then
      anim.region:ColorAnim(nil);
    end

    animations[key] = nil;
    if(doOnFinished and anim.onFinished) then
      anim.onFinished();
    end
    return true;
  else
    return false;
  end
end


-- ========================================
-- File: WeakAuras/ArchiveTypes/Repository.lua
-- ========================================

--[[
Repository store type. This is a meta-archive of sorts.
  Store contains 0 or more substores, each of which is essentially
  a list of ReadOnly stores, along with a small amount of meta-data
  about the sub-stores. Store type is tailored for quick retrieval of
  meta-data and only decompressing the data we need right now. In our use case,
  the sub stores are all historical aura snapshots. It would be an
  error to mutate this data, so we use ReadOnly stores (which don't
  return anything on Commit/Close) to minimize performance impact of reading data.
--]]

local Archivist = select(2, ...).Archivist

local subStoreMethods = {
  Validate = function(self)
    if type(self.id) ~= "string" or not Archivist:Check("ReadOnly", self.id) then
      self.id = nil
      return false
    else
      return true
    end
  end,
  Set = function(self, data)
    if type(self.id) == "string" then
      Archivist:Delete("ReadOnly", self.id, true)
    end
    local store, storeID = Archivist:Create("ReadOnly", nil, data)
    self.id = storeID
    self.timestamp = time()
  end,
  Load = function(self) -- convenience method
    return Archivist:Load("ReadOnly", self.id)
  end,
  Close = function(self) -- convenience method
    return Archivist:Close("ReadOnly", self.id)
  end,
  Delete = function(self)
    Archivist:Delete("ReadOnly", self.id)
    self.id = nil
  end,
}

local storeMethods = {
  Validate = function(self)
    for id, subStore in pairs(self.stores) do
      if not subStore:Validate() then
        -- either it's too old, or doesn't exist. Either way we don't need to keep this record
        self.stores[id] = nil
      end
    end
  end,
  Get = function(self, id, load)
    local subStore = self.stores[id]
    local data
    if subStore and load then
      data = subStore:Load()
    end
    return subStore, data
  end,
  GetData = function(self, id)
    return select(2, self:Get(id, true))
  end,
  Set = function(self, id, data)
    if data ~= nil and type(id) == "string" then
      if not self.stores[id] then
        self.stores[id] = Mixin({}, subStoreMethods)
      end
      self.stores[id]:Set(data)
      return self.stores[id]
    end
  end,
  Clean = function(self, cutoff)
    for id, subStore in pairs(self.stores) do
      if subStore.timestamp < cutoff then
        self:Drop(id)
      end
    end
  end,
  Drop = function(self, id)
    if self.stores[id] then
      self.stores[id]:Delete()
      self.stores[id] = nil
    end
  end,
}

local prototype = {
  id = "Repository",
  version = 1,
  Init = nil, -- Repositories are entirely self-contained! No need for Init.
  Create = function(self, image)
    local store = type(image) == "table" and image or {}
    if type(store.stores) ~= "table" then
      store.stores = {}
    end
    Mixin(store, storeMethods)
    store:Validate()
    return store, store
  end,
  Update = nil, -- This is the initial version! No need for Update yet.
  Open = function(self, image)
    local store = image
    Mixin(store, storeMethods)
    for _, subStore in pairs(store.stores) do
      Mixin(subStore, subStoreMethods)
    end
    store:Validate()
    return store
  end,
  Commit = function(self, store)
    return store
  end,
  Close = function(self, store)
    return store
  end,
  Delete = function(self, image)
    for id in pairs(image.stores) do
      Archivist:Delete("ReadOnly", id)
    end
  end,
}

Archivist:RegisterStoreType(prototype)


-- ========================================
-- File: WeakAuras/Atlas_Cata.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
Private.AtlasList = {
"!Barbershop-MiddleTile",
"!CharacterCreateDropdown-NineSlice-EdgeLeft",
"!CharacterCreateDropdown-NineSlice-EdgeRight",
"!ChatBubble-NineSlice-EdgeLeft",
"!ChatBubble-NineSlice-EdgeRight",
"!ClassHall_InfoBoxMission-Left",
"!ForgeBorder-Right",
"!GarrMission_Bg-DarkEdge",
"!GarrMission_Bg-Edge",
"!GarrMission_RewardsBorder-Left",
"!GarrMission_RewardsBorder-Left-Desaturate",
"!Garr_InfoBox-Left",
"!Garr_InfoBoxBorder-Left",
"!Garr_InfoBoxBorderMission-Left",
"!Garr_InfoBoxMission-Left",
"!Garr_WoodFrameTile-Left",
"!GeneralFrame-InsetFrame-Left",
"!GeneralFrame-InsetFrame-Right",
"!OptionsFrame-NineSlice-EdgeLeft",
"!OptionsFrame-NineSlice-EdgeRight",
"!ShipMission_Bg-DarkEdge",
"!ShipMission_Bg-Edge",
"!ShipMission_RewardsBorder-Left-Desaturate",
"!StoneFrameTile-Left",
"!Tooltip-Glues-NineSlice-EdgeLeft",
"!Tooltip-Glues-NineSlice-EdgeRight",
"!Tooltip-NineSlice-EdgeLeft",
"!Tooltip-NineSlice-EdgeRight",
"!UI-Frame-DiamondMetal-EdgeLeft",
"!UI-Frame-DiamondMetal-EdgeRight",
"!UI-Frame-InnerLeftTile",
"!UI-Frame-InnerRightTile",
"!UI-Frame-LeftTile",
"!UI-Frame-RightTile",
"!UI-Taxi-Line",
"!macropopup-left",
"!macropopup-right",
"!macropopup-scrollbar-middle",
"!minimal-scrollbar-small-track-middle",
"!minimal-scrollbar-track-middle",
"!ui-scrollbar-center",
"128-RedButton-ArrowDown",
"128-RedButton-ArrowDown-Disabled",
"128-RedButton-ArrowDown-Highlight",
"128-RedButton-ArrowDown-Pressed",
"128-RedButton-ArrowUpGlow",
"128-RedButton-ArrowUpGlow-Disabled",
"128-RedButton-ArrowUpGlow-Highlight",
"128-RedButton-ArrowUpGlow-Pressed",
"128-RedButton-Delete",
"128-RedButton-Delete-Disabled",
"128-RedButton-Delete-Highlight",
"128-RedButton-Delete-Pressed",
"128-RedButton-Exit",
"128-RedButton-Exit-Disabled",
"128-RedButton-Exit-Pressed",
"128-RedButton-Highlight",
"128-RedButton-Left",
"128-RedButton-Left-Disabled",
"128-RedButton-Left-Pressed",
"128-RedButton-Minus",
"128-RedButton-Minus-Disabled",
"128-RedButton-Minus-Highlight",
"128-RedButton-Minus-Pressed",
"128-RedButton-Plus",
"128-RedButton-Plus-Disabled",
"128-RedButton-Plus-Highlight",
"128-RedButton-Plus-Pressed",
"128-RedButton-Refresh",
"128-RedButton-Refresh-Disabled",
"128-RedButton-Refresh-Highlight",
"128-RedButton-Refresh-Pressed",
"128-RedButton-Right",
"128-RedButton-Right-Disabled",
"128-RedButton-Right-Pressed",
"128-RedButton-VisibilityOff",
"128-RedButton-VisibilityOff-Disabled",
"128-RedButton-VisibilityOff-Highlight",
"128-RedButton-VisibilityOff-Pressed",
"128-RedButton-VisibilityOn",
"128-RedButton-VisibilityOn-Disabled",
"128-RedButton-VisibilityOn-Highlight",
"128-RedButton-VisibilityOn-Pressed",
"128-redbutton-exit-highlight",
"AdventureMap-InsetMapBorder",
"AdventureMap-combatally-clouds",
"AdventureMap-combatally-empty",
"AdventureMap-combatally-ring",
"AdventureMap-textlabelglow",
"AdventureMapIcon-DailyQuest",
"AdventureMapIcon-Lock",
"AdventureMapIcon-MissionCombat",
"AdventureMapIcon-Quest",
"AdventureMapIcon-SandboxQuest",
"AdventureMapLabel-Large",
"AdventureMapLabel-MissionTimer",
"AdventureMapLabel-QuestDiscovered",
"AdventureMapLabel-Small",
"AdventureMapQuest-ItemNameBG",
"AdventureMapQuest-PortraitBG",
"AdventureMapQuest-QuestPane",
"AdventureMapQuest-RewardsPanel",
"AdventureMap_TileBg",
"AdventureMap_TileBg_Parchment",
"AdventureMap_TopBorder",
"AftLevelup-CloudyLineLeft",
"AftLevelup-CloudyLineRight",
"AftLevelup-Dots1",
"AftLevelup-Dots2",
"AftLevelup-FiligreeLeft",
"AftLevelup-FiligreeRight",
"AftLevelup-GlowLine",
"AftLevelup-IconFrame",
"AftLevelup-IconGlow",
"AftLevelup-Lines1",
"AftLevelup-Lines2",
"AftLevelup-NeutralStarBurst",
"AftLevelup-PurpleStarBurst",
"AftLevelup-SoftCloud",
"AftLevelup-ToastBG",
"AftLevelup-WhiteIconGlow",
"AftLevelup-WhiteStarBurst",
"Alliance_Tier1_Arena1",
"Alliance_Tier1_Arena2",
"Alliance_Tier1_Armory1",
"Alliance_Tier1_Armory2",
"Alliance_Tier1_Barn1",
"Alliance_Tier1_Barn2",
"Alliance_Tier1_Barracks",
"Alliance_Tier1_Barracks1",
"Alliance_Tier1_Barracks2",
"Alliance_Tier1_Farm",
"Alliance_Tier1_Fishing",
"Alliance_Tier1_Inn1",
"Alliance_Tier1_Inn2",
"Alliance_Tier1_Lumber1",
"Alliance_Tier1_Lumber2",
"Alliance_Tier1_Mage1",
"Alliance_Tier1_Mage2",
"Alliance_Tier1_Mine",
"Alliance_Tier1_Professions",
"Alliance_Tier1_Professions2",
"Alliance_Tier1_Stables1",
"Alliance_Tier1_Stables2",
"Alliance_Tier1_TownHall",
"Alliance_Tier1_Trading1",
"Alliance_Tier1_Trading2",
"Alliance_Tier1_Workshop1",
"Alliance_Tier1_Workshop2",
"Alliance_Tier2_Arena1",
"Alliance_Tier2_Arena2",
"Alliance_Tier2_Armory1",
"Alliance_Tier2_Armory2",
"Alliance_Tier2_Barn1",
"Alliance_Tier2_Barn2",
"Alliance_Tier2_Barracks1",
"Alliance_Tier2_Barracks2",
"Alliance_Tier2_Inn1",
"Alliance_Tier2_Inn2",
"Alliance_Tier2_Lumber1",
"Alliance_Tier2_Lumber2",
"Alliance_Tier2_Mage1",
"Alliance_Tier2_Mage2",
"Alliance_Tier2_Stables1",
"Alliance_Tier2_Stables2",
"Alliance_Tier2_Trading1",
"Alliance_Tier2_Trading2",
"Alliance_Tier2_Workshop1",
"Alliance_Tier2_Workshop2",
"Alliance_Tier3_Arena1",
"Alliance_Tier3_Arena2",
"Alliance_Tier3_Armory1",
"Alliance_Tier3_Armory2",
"Alliance_Tier3_Barn1",
"Alliance_Tier3_Barn2",
"Alliance_Tier3_Barracks1",
"Alliance_Tier3_Barracks2",
"Alliance_Tier3_Inn1",
"Alliance_Tier3_Inn2",
"Alliance_Tier3_Lumber1",
"Alliance_Tier3_Lumber2",
"Alliance_Tier3_Mage1",
"Alliance_Tier3_Mage2",
"Alliance_Tier3_Stables1",
"Alliance_Tier3_Stables2",
"Alliance_Tier3_Trading1",
"Alliance_Tier3_Trading2",
"Alliance_Tier3_Workshop1",
"Alliance_Tier3_Workshop2",
"AlliedRace-Crest-Highmountain",
"AlliedRace-Crest-Lightforge",
"AlliedRace-Crest-Nightborne",
"AlliedRace-Crest-Voidelf",
"AlliedRace-TraitsBorder",
"AlliedRace-UnlockingFrame-Background",
"AlliedRace-UnlockingFrame-BottomButtonsMouseOverGlow",
"AlliedRace-UnlockingFrame-BottomButtonsSelectionGlow",
"AlliedRace-UnlockingFrame-Female",
"AlliedRace-UnlockingFrame-GenderMouseOverGlow",
"AlliedRace-UnlockingFrame-GenderSelectionGlow",
"AlliedRace-UnlockingFrame-LeftRotation",
"AlliedRace-UnlockingFrame-Male",
"AlliedRace-UnlockingFrame-ModelBackground-Highmountain",
"AlliedRace-UnlockingFrame-ModelBackground-Lightforge",
"AlliedRace-UnlockingFrame-ModelBackground-Nightborne",
"AlliedRace-UnlockingFrame-ModelBackground-Voidelf",
"AlliedRace-UnlockingFrame-ModelFrame",
"AlliedRace-UnlockingFrame-RaceBanner",
"AlliedRace-UnlockingFrame-RightRotation",
"AlliedRace-UnlockingFrame-ZoomIn",
"AlliedRace-UnlockingFrame-ZoomOut",
"AlliedRaces-AllianceHordeBanner",
"Ammunition",
"AncientMana",
"AntoranWastes_Highlight",
"ArchBlob",
"Armor-Fill-End",
"ArtifactQuest",
"ArtifactQuestTurnin",
"Artifacts-Anim-CrackedGround",
"Artifacts-Anim-Glowies",
"Artifacts-Anim-Orb",
"Artifacts-Anim-Sparks",
"Artifacts-BG-Shadow",
"Artifacts-CrestRune-Gold",
"Artifacts-DeathKnightFrost-BG",
"Artifacts-DeathKnightFrost-BG-Rune",
"Artifacts-DeathKnightFrost-FinalIcon",
"Artifacts-DeathKnightFrost-Header",
"Artifacts-DeathKnightFrost-KnowledgeRank",
"Artifacts-DemonHunter-BG",
"Artifacts-DemonHunter-BG-rune",
"Artifacts-DemonHunter-FinalIcon",
"Artifacts-DemonHunter-Header",
"Artifacts-DemonHunter-KnowledgeRank",
"Artifacts-Druid-BG",
"Artifacts-Druid-BG-rune",
"Artifacts-Druid-FinalIcon",
"Artifacts-Druid-Header",
"Artifacts-Druid-KnowledgeRank",
"Artifacts-HeaderBG",
"Artifacts-Hunter-BG",
"Artifacts-Hunter-BG-rune",
"Artifacts-Hunter-FinalIcon",
"Artifacts-Hunter-Header",
"Artifacts-Hunter-KnowledgeRank",
"Artifacts-ItemIconBorder",
"Artifacts-MageArcane-BG",
"Artifacts-MageArcane-BG-rune",
"Artifacts-MageArcane-FinalIcon",
"Artifacts-MageArcane-Header",
"Artifacts-MageArcane-KnowledgeRank",
"Artifacts-Monk-BG",
"Artifacts-Monk-BG-rune",
"Artifacts-Monk-FinalIcon",
"Artifacts-Monk-Header",
"Artifacts-Monk-KnowledgeRank",
"Artifacts-Paladin-BG",
"Artifacts-Paladin-BG-rune",
"Artifacts-Paladin-FinalIcon",
"Artifacts-Paladin-Header",
"Artifacts-Paladin-KnowledgeRank",
"Artifacts-PerkRing-Final",
"Artifacts-PerkRing-Final-Shine",
"Artifacts-PerkRing-GoldMedal",
"Artifacts-PerkRing-Highlight",
"Artifacts-PerkRing-MainProc",
"Artifacts-PerkRing-MainProc-Glow",
"Artifacts-PerkRing-NeutralGlow",
"Artifacts-PerkRing-PurpleGlow",
"Artifacts-PerkRing-Small",
"Artifacts-PerkRing-WhiteGlow",
"Artifacts-PointsBox",
"Artifacts-PointsBoxGreen",
"Artifacts-Priest-BG",
"Artifacts-Priest-BG-rune",
"Artifacts-Priest-FinalIcon",
"Artifacts-Priest-Header",
"Artifacts-Priest-KnowledgeRank",
"Artifacts-PriestShadow-BG",
"Artifacts-PriestShadow-BG-rune",
"Artifacts-PriestShadow-FinalIcon",
"Artifacts-PriestShadow-Header",
"Artifacts-PriestShadow-KnowledgeRank",
"Artifacts-Rogue-BG",
"Artifacts-Rogue-BG-rune",
"Artifacts-Rogue-FinalIcon",
"Artifacts-Rogue-Header",
"Artifacts-Rogue-KnowledgeRank",
"Artifacts-Shaman-BG",
"Artifacts-Shaman-BG-rune",
"Artifacts-Shaman-FinalIcon",
"Artifacts-Shaman-Header",
"Artifacts-Shaman-KnowledgeRank",
"Artifacts-Warlock-BG",
"Artifacts-Warlock-BG-rune",
"Artifacts-Warlock-FinalIcon",
"Artifacts-Warlock-Header",
"Artifacts-Warlock-KnowledgeRank",
"Artifacts-Warrior-BG",
"Artifacts-Warrior-BG-rune",
"Artifacts-Warrior-FinalIcon",
"Artifacts-Warrior-Header",
"Artifacts-Warrior-KnowledgeRank",
"ArtifactsFX-PointSideBurstLeft",
"ArtifactsFX-PointSideBurstLeft-Purple",
"ArtifactsFX-PointSideBurstRight",
"ArtifactsFX-PointSideBurstRight-Purple",
"ArtifactsFX-SpinningGlowys",
"ArtifactsFX-SpinningGlowys-Purple",
"ArtifactsFX-StarBurst",
"ArtifactsFX-StarBurst-Purple",
"ArtifactsFX-Whirls",
"ArtifactsFX-Whirls-Neutral",
"ArtifactsFX-Whirls-Purple",
"ArtifactsFX-YellowRing",
"ArtifactsFX-YellowRing-Neutral",
"ArtifactsFX-YellowRing-Purple",
"Auctioneer",
"AutoQuest-badgeborder",
"AzeriteReady",
"AzeriteSpawning",
"BackArrow-Brown",
"BackupPet-DeadFrame",
"BackupPet-Frame",
"Banker",
"Banner-BgFiligree",
"Banner-FiligreeShadow",
"Banner-SmallFiligree",
"Bar-End",
"Barbershop-Bottom",
"Barbershop-Top",
"BattleBar-Button-Highlight",
"BattleBar-ButtonBG-Divider",
"BattleBar-ButtonBG-EndCap",
"BattleBar-Countdown-Shadow",
"BattleBar-EndCap",
"BattleBar-SwapPetFrame",
"BattleBar-SwapPetFrame-DeadIcon",
"BattleBar-SwapPetFrame-Highlight",
"BattleBar-SwapPetIcon",
"BattleBar-SwapPetShadow",
"BattleHUD-Top",
"BattleHUD-Versus",
"BattleMaster",
"Battlenet-ClientIcon-ANBS",
"Battlenet-ClientIcon-App",
"Battlenet-ClientIcon-D3",
"Battlenet-ClientIcon-DST2",
"Battlenet-ClientIcon-FEN",
"Battlenet-ClientIcon-FORE",
"Battlenet-ClientIcon-GRY",
"Battlenet-ClientIcon-Hero",
"Battlenet-ClientIcon-LAZR",
"Battlenet-ClientIcon-ODIN",
"Battlenet-ClientIcon-OSI",
"Battlenet-ClientIcon-Pro",
"Battlenet-ClientIcon-RTRO",
"Battlenet-ClientIcon-S1",
"Battlenet-ClientIcon-S2",
"Battlenet-ClientIcon-VIPR",
"Battlenet-ClientIcon-W3",
"Battlenet-ClientIcon-WLBY",
"Battlenet-ClientIcon-WTCG",
"Battlenet-ClientIcon-WoW",
"Battlenet-ClientIcon-ZEUS",
"Bonus-ToastBanner",
"BonusChest-BonusTextGlow",
"BonusChest-Burst-Uncommon",
"BonusChest-CircleGlow",
"BonusChest-GreenGlow-Wide",
"BonusChest-ItemBorder-Uncommon",
"BonusChest-KeyholeBurst",
"BonusChest-KeyholeGlow",
"BonusChest-Lock",
"BonusChest-OrangeGlow-Wide",
"BonusChest-OrangeSmoke-Wide",
"BonusChest-Smoke-Uncommon",
"BossBanner-BgBanner-Bottom",
"BossBanner-BgBanner-Mid",
"BossBanner-BgBanner-Top",
"BossBanner-BottomFillagree",
"BossBanner-LeftFillagree",
"BossBanner-PortraitBorder",
"BossBanner-RedFlash",
"BossBanner-RedLightning",
"BossBanner-RightFillagree",
"BossBanner-SkullCircle",
"BossBanner-SkullSpikes",
"BossBanner-TopFillagree",
"BrokenIslesHightlight",
"CacheToast",
"CacheToast-Glow",
"Calendar_Quest",
"Capacitance-Blacksmithing-BG",
"Capacitance-Blacksmithing-IconBG",
"Capacitance-Blacksmithing-IconBorder",
"Capacitance-Blacksmithing-TimerBG",
"Capacitance-Blacksmithing-TimerFill",
"Capacitance-Blacksmithing-TimerFrame",
"Capacitance-General-EmptyFollower",
"Capacitance-General-ItemBorder",
"Capacitance-General-LevelBorder",
"Capacitance-General-LockIcon",
"Capacitance-General-PortraitRing",
"Capacitance-General-WorkOrderActive",
"Capacitance-General-WorkOrderArrow",
"Capacitance-General-WorkOrderBorder",
"Capacitance-General-WorkOrderCheckmark",
"Capacitance-General-WorkOrderEmpty",
"Cast-Bar-End",
"Cast-Bar-Fill-End",
"CastBar",
"ChallengeMode-AffixRing-Lg",
"ChallengeMode-AffixRing-Sm",
"ChallengeMode-Chest",
"ChallengeMode-DungeonIconFrame",
"ChallengeMode-KeystoneFrame",
"ChallengeMode-KeystoneSlotBG",
"ChallengeMode-KeystoneSlotFrame",
"ChallengeMode-KeystoneSlotFrameGlow",
"ChallengeMode-MainTabBg",
"ChallengeMode-RankLineDivider",
"ChallengeMode-RuneBG",
"ChallengeMode-Runes-BL-Glow",
"ChallengeMode-Runes-BR-Glow",
"ChallengeMode-Runes-BackgroundBurst",
"ChallengeMode-Runes-BackgroundCoverGlow",
"ChallengeMode-Runes-CircleGlow",
"ChallengeMode-Runes-GlowBurstLarge",
"ChallengeMode-Runes-GlowLarge",
"ChallengeMode-Runes-GlowSmall",
"ChallengeMode-Runes-InnerCircleGlow",
"ChallengeMode-Runes-L-Glow",
"ChallengeMode-Runes-Large",
"ChallengeMode-Runes-LineGlow",
"ChallengeMode-Runes-R-Glow",
"ChallengeMode-Runes-Shockwave",
"ChallengeMode-Runes-Small",
"ChallengeMode-Runes-SmallCircleGlow",
"ChallengeMode-Runes-T-Glow",
"ChallengeMode-SoftYellowGlow",
"ChallengeMode-SpikeyStar",
"ChallengeMode-ThinDivider",
"ChallengeMode-Timer",
"ChallengeMode-TimerBG",
"ChallengeMode-TimerBG-back",
"ChallengeMode-TimerFill",
"ChallengeMode-WhiteSpikeyGlow",
"ChallengeMode-guild-background",
"ChallengeMode-icon-chest",
"ChallengeMode-icon-redline",
"CharacterCreateDropdown-NineSlice-Center",
"CharacterCreateDropdown-NineSlice-CornerBottomLeft",
"CharacterCreateDropdown-NineSlice-CornerBottomRight",
"CharacterCreateDropdown-NineSlice-CornerTopLeft",
"CharacterCreateDropdown-NineSlice-CornerTopRight",
"ChatBallon",
"ChatBubble-NineSlice-Center",
"ChatBubble-NineSlice-CornerBottomLeft",
"ChatBubble-NineSlice-CornerBottomRight",
"ChatBubble-NineSlice-CornerTopLeft",
"ChatBubble-NineSlice-CornerTopRight",
"ChatBubble-Tail",
"CircleMaskScalable",
"Class",
"ClassHall-BonusIcon-Desaturated",
"ClassHall-Circle-DeathKnight",
"ClassHall-Circle-DemonHunter",
"ClassHall-Circle-Druid",
"ClassHall-Circle-Hunter",
"ClassHall-Circle-Mage",
"ClassHall-Circle-Monk",
"ClassHall-Circle-Paladin",
"ClassHall-Circle-Priest",
"ClassHall-Circle-Rogue",
"ClassHall-Circle-Shaman",
"ClassHall-Circle-Warlock",
"ClassHall-Circle-Warrior",
"ClassHall-CombatAlly",
"ClassHall-CombatIcon-Desaturated",
"ClassHall-LegendaryIcon-Desaturated",
"ClassHall-QuestIcon-Desaturated",
"ClassHall-TreasureIcon-Desaturated",
"ClassHall_Follower-EquipmentBG",
"ClassHall_Follower-EquipmentFrame",
"ClassHall_InfoBoxMission-BackgroundTile",
"ClassHall_InfoBoxMission-Corner",
"ClassHall_ParchmentHeader-End",
"ClassHall_ParchmentHeader-End-2",
"ClassHall_ParchmentHeaderSelect-End",
"ClassHall_ParchmentHeaderSelect-End-2",
"ClassHall_StoneFrame-BackgroundTile",
"ClassOverlay-ComboPoint",
"ClassOverlay-ComboPoint-Off",
"ClassOverlay-Fury",
"ClassOverlay-FuryBG",
"ClassOverlay-HolyPower1off",
"ClassOverlay-HolyPower1on",
"ClassOverlay-HolyPower2off",
"ClassOverlay-HolyPower2on",
"ClassOverlay-HolyPower3off",
"ClassOverlay-HolyPower3on",
"ClassOverlay-HolyPower4off",
"ClassOverlay-HolyPower4on",
"ClassOverlay-HolyPower5off",
"ClassOverlay-HolyPower5on",
"ClassOverlay-HolyPowerBG",
"ClassOverlay-Rune",
"ClassOverlay-RunicPower",
"ClassOverlay-RunicPowerBg",
"ClassTrial-DeathKnight-Ring",
"ClassTrial-Druid-Ring",
"ClassTrial-End-Frame",
"ClassTrial-Hunter-Ring",
"ClassTrial-Mage-Ring",
"ClassTrial-Monk-Ring",
"ClassTrial-Paladin-Ring",
"ClassTrial-Priest-Ring",
"ClassTrial-Rogue-Ring",
"ClassTrial-Shaman-Ring",
"ClassTrial-Timer",
"ClassTrial-Timer-Mid",
"ClassTrial-Timer-RightCorner",
"ClassTrial-Warlock-Ring",
"ClassTrial-Warrior-Ring",
"ClickCastList-ButtonBackground",
"ClickCastList-ButtonHighlight",
"ClickCastList-ButtonNew",
"Coin-Copper",
"Coin-Gold",
"Coin-Silver",
"ComboPoints-AllPointsBG",
"ComboPoints-ComboPoint",
"ComboPoints-ComboPointDash",
"ComboPoints-ComboPointDash-Bg",
"ComboPoints-FX-Circle",
"ComboPoints-FX-Dash",
"ComboPoints-FX-Star",
"ComboPoints-PointBg",
"CommentatorSpellBorder",
"Cosmic-Azeroth-Highlight",
"Cosmic-Azeroth-Highlight_Resize",
"Cosmic-Outland-Highlight",
"Cosmic-Outland-Highlight_Resize",
"Crop-Corner",
"Crop-Side",
"Crop-Top",
"CrossedFlags",
"CrossedFlagsWithTimer",
"CurrentPlayer-Glow",
"DK-Blood-Rune-CDFill",
"DK-Blood-Rune-Ready",
"DK-BloodUnholy-Rune-CDSpark",
"DK-Frost-Rune-CDFill",
"DK-Frost-Rune-CDSpark",
"DK-Frost-Rune-Ready",
"DK-Rune-CD",
"DK-Rune-Glow",
"DK-Unholy-Rune-CDFill",
"DK-Unholy-Rune-Ready",
"DarkTutorialFrameBackground",
"Darklink",
"Darklink-active",
"Darklink-ball",
"Darklink-blackinside",
"Darklink-glow",
"Darkstone1",
"Darkstone2",
"Darkstone3",
"Darkstone4",
"Darkstone5",
"Darkstone6",
"Darkstone7",
"Darktrait-Glow",
"Darktrait-backglow",
"Darktrait-border",
"Darktrait-border-selected",
"DeathIcon",
"DemonInvasion1",
"DemonInvasion2",
"DemonInvasion3",
"DemonInvasion4",
"DemonInvasion5",
"DemonShip",
"DemonShip_East",
"Disablelink",
"DruidEclipse-Arrow",
"DruidEclipse-BaseBar",
"DruidEclipse-BaseMoon",
"DruidEclipse-BaseSun",
"DruidEclipse-Diamond",
"DruidEclipse-Line",
"DruidEclipse-LunarBar",
"DruidEclipse-LunarCover",
"DruidEclipse-LunarMoon",
"DruidEclipse-LunarSun",
"DruidEclipse-SolarBar",
"DruidEclipse-SolarCover",
"DruidEclipse-SolarMoon",
"DruidEclipse-SolarSun",
"Dungeon",
"DungeonSkull",
"DungeonTargetIndicator",
"FXAM-QuestBang",
"FXAM-SmallSpikeyGlow",
"Flag-1",
"Flag-2",
"Flag-outline",
"FlightMaster",
"FlightMaster_Argus-Taxi_Frame_Gray",
"FlightMaster_Argus-Taxi_Frame_Green",
"FlightMaster_Argus-Taxi_Frame_Yellow",
"FlightMaster_VindicaarArgus-Taxi_Frame_Gray",
"FlightMaster_VindicaarArgus-Taxi_Frame_Green",
"FlightMaster_VindicaarArgus-Taxi_Frame_Yellow",
"FlightMaster_VindicaarMacAree-Taxi_Frame_Gray",
"FlightMaster_VindicaarMacAree-Taxi_Frame_Green",
"FlightMaster_VindicaarMacAree-Taxi_Frame_Yellow",
"FlightMaster_VindicaarStygianWake-Taxi_Frame_Gray",
"FlightMaster_VindicaarStygianWake-Taxi_Frame_Green",
"FlightMaster_VindicaarStygianWake-Taxi_Frame_Yellow",
"FlightPath",
"Focus",
"Focus-Tracker",
"FogofWar",
"FontStyle_BlueGradient",
"FontStyle_Garrisons",
"FontStyle_IronHordeMetal",
"FontStyle_Legion",
"FontStyle_Metal",
"FontStyle_Parchment",
"Food",
"Forge-AppearanceStrip",
"Forge-Background",
"Forge-ColorSwatch",
"Forge-ColorSwatchBackground",
"Forge-ColorSwatchBorder",
"Forge-ColorSwatchHighlight",
"Forge-ColorSwatchSelection",
"Forge-Lock",
"ForgeBorder-CornerBottomLeft",
"ForgeBorder-CornerBottomRight",
"ForgeBorder-CornerTopRight",
"Frame-Timer",
"FullAlert-BigSpike",
"FullAlert-FrameGlow",
"FullAlert-SoftCurveGlow",
"FullAlert-YellowCurveGlow",
"Gamepad_Gen_1_32",
"Gamepad_Gen_1_64",
"Gamepad_Gen_2_32",
"Gamepad_Gen_2_64",
"Gamepad_Gen_3_32",
"Gamepad_Gen_3_64",
"Gamepad_Gen_4_32",
"Gamepad_Gen_4_64",
"Gamepad_Gen_5_32",
"Gamepad_Gen_5_64",
"Gamepad_Gen_6_32",
"Gamepad_Gen_6_64",
"Gamepad_Gen_Back_32",
"Gamepad_Gen_Back_64",
"Gamepad_Gen_Down_32",
"Gamepad_Gen_Down_64",
"Gamepad_Gen_Forward_32",
"Gamepad_Gen_Forward_64",
"Gamepad_Gen_LShoulder_32",
"Gamepad_Gen_LShoulder_64",
"Gamepad_Gen_LStickDown_32",
"Gamepad_Gen_LStickDown_64",
"Gamepad_Gen_LStickIn_32",
"Gamepad_Gen_LStickIn_64",
"Gamepad_Gen_LStickLeft_32",
"Gamepad_Gen_LStickLeft_64",
"Gamepad_Gen_LStickRight_32",
"Gamepad_Gen_LStickRight_64",
"Gamepad_Gen_LStickUp_32",
"Gamepad_Gen_LStickUp_64",
"Gamepad_Gen_LTrigger_32",
"Gamepad_Gen_LTrigger_64",
"Gamepad_Gen_Left_32",
"Gamepad_Gen_Left_64",
"Gamepad_Gen_Paddle1_32",
"Gamepad_Gen_Paddle1_64",
"Gamepad_Gen_Paddle2_32",
"Gamepad_Gen_Paddle2_64",
"Gamepad_Gen_Paddle3_32",
"Gamepad_Gen_Paddle3_64",
"Gamepad_Gen_Paddle4_32",
"Gamepad_Gen_Paddle4_64",
"Gamepad_Gen_RShoulder_32",
"Gamepad_Gen_RShoulder_64",
"Gamepad_Gen_RStickDown_32",
"Gamepad_Gen_RStickDown_64",
"Gamepad_Gen_RStickIn_32",
"Gamepad_Gen_RStickIn_64",
"Gamepad_Gen_RStickLeft_32",
"Gamepad_Gen_RStickLeft_64",
"Gamepad_Gen_RStickRight_32",
"Gamepad_Gen_RStickRight_64",
"Gamepad_Gen_RStickUp_32",
"Gamepad_Gen_RStickUp_64",
"Gamepad_Gen_RTrigger_32",
"Gamepad_Gen_RTrigger_64",
"Gamepad_Gen_Right_32",
"Gamepad_Gen_Right_64",
"Gamepad_Gen_Share_32",
"Gamepad_Gen_Share_64",
"Gamepad_Gen_System_32",
"Gamepad_Gen_System_64",
"Gamepad_Gen_Up_32",
"Gamepad_Gen_Up_64",
"Gamepad_Ltr_A_32",
"Gamepad_Ltr_A_64",
"Gamepad_Ltr_B_32",
"Gamepad_Ltr_B_64",
"Gamepad_Ltr_Down_64",
"Gamepad_Ltr_LShoulder_64",
"Gamepad_Ltr_LTrigger_64",
"Gamepad_Ltr_Left_64",
"Gamepad_Ltr_Menu_32",
"Gamepad_Ltr_Menu_64",
"Gamepad_Ltr_RShoulder_64",
"Gamepad_Ltr_RTrigger_64",
"Gamepad_Ltr_Right_64",
"Gamepad_Ltr_Share_64",
"Gamepad_Ltr_System_32",
"Gamepad_Ltr_System_64",
"Gamepad_Ltr_Up_64",
"Gamepad_Ltr_View_32",
"Gamepad_Ltr_View_64",
"Gamepad_Ltr_X_32",
"Gamepad_Ltr_X_64",
"Gamepad_Ltr_Y_32",
"Gamepad_Ltr_Y_64",
"Gamepad_Rev_A_32",
"Gamepad_Rev_A_64",
"Gamepad_Rev_B_32",
"Gamepad_Rev_B_64",
"Gamepad_Rev_Capture_32",
"Gamepad_Rev_Capture_64",
"Gamepad_Rev_Home_64",
"Gamepad_Rev_LShoulder_32",
"Gamepad_Rev_LShoulder_64",
"Gamepad_Rev_LTrigger_32",
"Gamepad_Rev_LTrigger_64",
"Gamepad_Rev_Minus_32",
"Gamepad_Rev_Minus_64",
"Gamepad_Rev_Plus_32",
"Gamepad_Rev_Plus_64",
"Gamepad_Rev_RShoulder_32",
"Gamepad_Rev_RShoulder_64",
"Gamepad_Rev_RTrigger_32",
"Gamepad_Rev_RTrigger_64",
"Gamepad_Rev_X_32",
"Gamepad_Rev_X_64",
"Gamepad_Rev_Y_32",
"Gamepad_Rev_Y_64",
"Gamepad_Shp_Circle_32",
"Gamepad_Shp_Circle_64",
"Gamepad_Shp_Cross_32",
"Gamepad_Shp_Cross_64",
"Gamepad_Shp_Down_64",
"Gamepad_Shp_LShoulder_32",
"Gamepad_Shp_LShoulder_64",
"Gamepad_Shp_LStickIn_32",
"Gamepad_Shp_LStickIn_64",
"Gamepad_Shp_LTrigger_32",
"Gamepad_Shp_LTrigger_64",
"Gamepad_Shp_Left_64",
"Gamepad_Shp_Menu_32",
"Gamepad_Shp_Menu_64",
"Gamepad_Shp_MicMute_32",
"Gamepad_Shp_MicMute_64",
"Gamepad_Shp_RShoulder_32",
"Gamepad_Shp_RShoulder_64",
"Gamepad_Shp_RStickIn_32",
"Gamepad_Shp_RStickIn_64",
"Gamepad_Shp_RTrigger_32",
"Gamepad_Shp_RTrigger_64",
"Gamepad_Shp_Right_64",
"Gamepad_Shp_Share_32",
"Gamepad_Shp_Share_64",
"Gamepad_Shp_Square_32",
"Gamepad_Shp_Square_64",
"Gamepad_Shp_System_32",
"Gamepad_Shp_System_64",
"Gamepad_Shp_TouchpadL_32",
"Gamepad_Shp_TouchpadL_64",
"Gamepad_Shp_TouchpadR_32",
"Gamepad_Shp_TouchpadR_64",
"Gamepad_Shp_Triangle_32",
"Gamepad_Shp_Triangle_64",
"Gamepad_Shp_Up_64",
"GarLanding-Bottom",
"GarLanding-Left",
"GarLanding-Right",
"GarMission_ChestPercentageShadow",
"GarrBuilding_Alchemy_1_A_Info",
"GarrBuilding_Alchemy_1_A_Map",
"GarrBuilding_Alchemy_1_H_Info",
"GarrBuilding_Alchemy_1_H_Map",
"GarrBuilding_Alchemy_2_A_Info",
"GarrBuilding_Alchemy_2_A_Map",
"GarrBuilding_Alchemy_2_H_Info",
"GarrBuilding_Alchemy_2_H_Map",
"GarrBuilding_Alchemy_3_A_Info",
"GarrBuilding_Alchemy_3_A_Map",
"GarrBuilding_Alchemy_3_H_Info",
"GarrBuilding_Alchemy_3_H_Map",
"GarrBuilding_Armory_1_A_Info",
"GarrBuilding_Armory_1_A_Map",
"GarrBuilding_Armory_1_H_Info",
"GarrBuilding_Armory_1_H_Map",
"GarrBuilding_Armory_2_A_Info",
"GarrBuilding_Armory_2_A_Map",
"GarrBuilding_Armory_2_H_Info",
"GarrBuilding_Armory_2_H_Map",
"GarrBuilding_Armory_3_A_Info",
"GarrBuilding_Armory_3_A_Map",
"GarrBuilding_Armory_3_H_Info",
"GarrBuilding_Armory_3_H_Map",
"GarrBuilding_Barn_1_A_Info",
"GarrBuilding_Barn_1_A_Map",
"GarrBuilding_Barn_1_H_Info",
"GarrBuilding_Barn_1_H_Map",
"GarrBuilding_Barn_2_A_Info",
"GarrBuilding_Barn_2_A_Map",
"GarrBuilding_Barn_2_H_Info",
"GarrBuilding_Barn_2_H_Map",
"GarrBuilding_Barn_3_A_Info",
"GarrBuilding_Barn_3_A_Map",
"GarrBuilding_Barn_3_H_Info",
"GarrBuilding_Barn_3_H_Map",
"GarrBuilding_Barracks_1_A_Info",
"GarrBuilding_Barracks_1_A_Map",
"GarrBuilding_Barracks_1_H_Info",
"GarrBuilding_Barracks_1_H_Map",
"GarrBuilding_Barracks_2_A_Info",
"GarrBuilding_Barracks_2_A_Map",
"GarrBuilding_Barracks_2_H_Info",
"GarrBuilding_Barracks_2_H_Map",
"GarrBuilding_Barracks_3_A_Info",
"GarrBuilding_Barracks_3_A_Map",
"GarrBuilding_Barracks_3_H_Info",
"GarrBuilding_Barracks_3_H_Map",
"GarrBuilding_Blacksmith_1_A_Info",
"GarrBuilding_Blacksmith_1_A_Map",
"GarrBuilding_Blacksmith_1_H_Info",
"GarrBuilding_Blacksmith_1_H_Map",
"GarrBuilding_Blacksmith_2_A_Info",
"GarrBuilding_Blacksmith_2_A_Map",
"GarrBuilding_Blacksmith_2_H_Info",
"GarrBuilding_Blacksmith_2_H_Map",
"GarrBuilding_Blacksmith_3_A_Info",
"GarrBuilding_Blacksmith_3_A_Map",
"GarrBuilding_Blacksmith_3_H_Info",
"GarrBuilding_Blacksmith_3_H_Map",
"GarrBuilding_Default_Info",
"GarrBuilding_Default_Map",
"GarrBuilding_EmptyPlot_1_A_Info",
"GarrBuilding_EmptyPlot_A_1",
"GarrBuilding_EmptyPlot_A_2",
"GarrBuilding_EmptyPlot_A_3",
"GarrBuilding_EmptyPlot_H_1",
"GarrBuilding_EmptyPlot_H_2",
"GarrBuilding_EmptyPlot_H_3",
"GarrBuilding_Enchanting_1_A_Info",
"GarrBuilding_Enchanting_1_A_Map",
"GarrBuilding_Enchanting_1_H_Info",
"GarrBuilding_Enchanting_1_H_Map",
"GarrBuilding_Enchanting_2_A_Info",
"GarrBuilding_Enchanting_2_A_Map",
"GarrBuilding_Enchanting_2_H_Info",
"GarrBuilding_Enchanting_2_H_Map",
"GarrBuilding_Enchanting_3_A_Info",
"GarrBuilding_Enchanting_3_A_Map",
"GarrBuilding_Enchanting_3_H_Info",
"GarrBuilding_Enchanting_3_H_Map",
"GarrBuilding_Engineering_1_A_Info",
"GarrBuilding_Engineering_1_A_Map",
"GarrBuilding_Engineering_1_H_Info",
"GarrBuilding_Engineering_1_H_Map",
"GarrBuilding_Engineering_2_A_Info",
"GarrBuilding_Engineering_2_A_Map",
"GarrBuilding_Engineering_2_H_Info",
"GarrBuilding_Engineering_2_H_Map",
"GarrBuilding_Engineering_3_A_Info",
"GarrBuilding_Engineering_3_A_Map",
"GarrBuilding_Engineering_3_H_Info",
"GarrBuilding_Engineering_3_H_Map",
"GarrBuilding_Farm_1_A_Info",
"GarrBuilding_Farm_1_A_Map",
"GarrBuilding_Farm_1_H_Info",
"GarrBuilding_Farm_1_H_Map",
"GarrBuilding_Farm_2_A_Info",
"GarrBuilding_Farm_2_A_Map",
"GarrBuilding_Farm_3_A_Info",
"GarrBuilding_Farm_3_A_Map",
"GarrBuilding_Fishing_1_A_Info",
"GarrBuilding_Fishing_1_A_Map",
"GarrBuilding_Fishing_1_H_Info",
"GarrBuilding_Fishing_1_H_Map",
"GarrBuilding_Fishing_2_A_Info",
"GarrBuilding_Fishing_2_A_Map",
"GarrBuilding_Fishing_2_H_Info",
"GarrBuilding_Fishing_2_H_Map",
"GarrBuilding_Fishing_3_A_Info",
"GarrBuilding_Fishing_3_A_Map",
"GarrBuilding_Fishing_3_H_Info",
"GarrBuilding_Fishing_3_H_Map",
"GarrBuilding_Inn_1_A_Info",
"GarrBuilding_Inn_1_A_Map",
"GarrBuilding_Inn_1_H_Info",
"GarrBuilding_Inn_1_H_Map",
"GarrBuilding_Inn_2_A_Info",
"GarrBuilding_Inn_2_A_Map",
"GarrBuilding_Inn_2_H_Info",
"GarrBuilding_Inn_2_H_Map",
"GarrBuilding_Inn_3_A_Info",
"GarrBuilding_Inn_3_A_Map",
"GarrBuilding_Inn_3_H_Info",
"GarrBuilding_Inn_3_H_Map",
"GarrBuilding_Inscription_1_A_Info",
"GarrBuilding_Inscription_1_A_Map",
"GarrBuilding_Inscription_1_H_Info",
"GarrBuilding_Inscription_1_H_Map",
"GarrBuilding_Inscription_2_A_Info",
"GarrBuilding_Inscription_2_A_Map",
"GarrBuilding_Inscription_2_H_Info",
"GarrBuilding_Inscription_2_H_Map",
"GarrBuilding_Inscription_3_A_Info",
"GarrBuilding_Inscription_3_A_Map",
"GarrBuilding_Inscription_3_H_Info",
"GarrBuilding_Inscription_3_H_Map",
"GarrBuilding_Jewelcrafting_1_A_Info",
"GarrBuilding_Jewelcrafting_1_A_Map",
"GarrBuilding_Jewelcrafting_1_H_Info",
"GarrBuilding_Jewelcrafting_1_H_Map",
"GarrBuilding_Jewelcrafting_2_A_Info",
"GarrBuilding_Jewelcrafting_2_A_Map",
"GarrBuilding_Jewelcrafting_2_H_Info",
"GarrBuilding_Jewelcrafting_2_H_Map",
"GarrBuilding_Jewelcrafting_3_A_Info",
"GarrBuilding_Jewelcrafting_3_A_Map",
"GarrBuilding_Jewelcrafting_3_H_Info",
"GarrBuilding_Jewelcrafting_3_H_Map",
"GarrBuilding_Leatherworking_1_A_Info",
"GarrBuilding_Leatherworking_1_A_Map",
"GarrBuilding_Leatherworking_1_H_Info",
"GarrBuilding_Leatherworking_1_H_Map",
"GarrBuilding_Leatherworking_2_A_Info",
"GarrBuilding_Leatherworking_2_A_Map",
"GarrBuilding_Leatherworking_2_H_Info",
"GarrBuilding_Leatherworking_2_H_Map",
"GarrBuilding_Leatherworking_3_A_Info",
"GarrBuilding_Leatherworking_3_A_Map",
"GarrBuilding_Leatherworking_3_H_Info",
"GarrBuilding_Leatherworking_3_H_Map",
"GarrBuilding_LumberMill_1_A_Info",
"GarrBuilding_LumberMill_1_A_Map",
"GarrBuilding_LumberMill_1_H_Info",
"GarrBuilding_LumberMill_1_H_Map",
"GarrBuilding_LumberMill_2_A_Info",
"GarrBuilding_LumberMill_2_A_Map",
"GarrBuilding_LumberMill_2_H_Info",
"GarrBuilding_LumberMill_2_H_Map",
"GarrBuilding_LumberMill_3_A_Info",
"GarrBuilding_LumberMill_3_A_Map",
"GarrBuilding_LumberMill_3_H_Info",
"GarrBuilding_LumberMill_3_H_Map",
"GarrBuilding_MageTower_1_A_Info",
"GarrBuilding_MageTower_1_A_Map",
"GarrBuilding_MageTower_1_H_Info",
"GarrBuilding_MageTower_1_H_Map",
"GarrBuilding_MageTower_2_A_Info",
"GarrBuilding_MageTower_2_A_Map",
"GarrBuilding_MageTower_2_H_Info",
"GarrBuilding_MageTower_2_H_Map",
"GarrBuilding_MageTower_3_A_Info",
"GarrBuilding_MageTower_3_A_Map",
"GarrBuilding_MageTower_3_H_Info",
"GarrBuilding_MageTower_3_H_Map",
"GarrBuilding_Mine_1_A_Info",
"GarrBuilding_Mine_1_A_Map",
"GarrBuilding_Mine_1_H_Info",
"GarrBuilding_Mine_1_H_Map",
"GarrBuilding_Mine_2_A_Info",
"GarrBuilding_Mine_2_A_Map",
"GarrBuilding_Mine_3_A_Info",
"GarrBuilding_Mine_3_A_Map",
"GarrBuilding_PetStable_1_A_Info",
"GarrBuilding_PetStable_1_A_Map",
"GarrBuilding_PetStable_1_H_Info",
"GarrBuilding_PetStable_1_H_Map",
"GarrBuilding_SalvageYard_1_A_Info",
"GarrBuilding_SalvageYard_1_A_Map",
"GarrBuilding_SalvageYard_1_H_Info",
"GarrBuilding_SalvageYard_1_H_Map",
"GarrBuilding_SparringArena_1_A_Info",
"GarrBuilding_SparringArena_1_A_Map",
"GarrBuilding_SparringArena_1_H_Info",
"GarrBuilding_SparringArena_1_H_Map",
"GarrBuilding_SparringArena_2_A_Info",
"GarrBuilding_SparringArena_2_A_Map",
"GarrBuilding_SparringArena_2_H_Info",
"GarrBuilding_SparringArena_2_H_Map",
"GarrBuilding_SparringArena_3_A_Info",
"GarrBuilding_SparringArena_3_A_Map",
"GarrBuilding_SparringArena_3_H_Info",
"GarrBuilding_SparringArena_3_H_Map",
"GarrBuilding_Stables_1_A_Info",
"GarrBuilding_Stables_1_A_Map",
"GarrBuilding_Stables_1_H_Info",
"GarrBuilding_Stables_1_H_Map",
"GarrBuilding_Stables_2_A_Info",
"GarrBuilding_Stables_2_A_Map",
"GarrBuilding_Stables_2_H_Info",
"GarrBuilding_Stables_2_H_Map",
"GarrBuilding_Stables_3_A_Info",
"GarrBuilding_Stables_3_A_Map",
"GarrBuilding_Stables_3_H_Info",
"GarrBuilding_Stables_3_H_Map",
"GarrBuilding_Storehouse_1_A_Info",
"GarrBuilding_Storehouse_1_A_Map",
"GarrBuilding_Storehouse_1_H_Info",
"GarrBuilding_Storehouse_1_H_Map",
"GarrBuilding_Tailoring_1_A_Info",
"GarrBuilding_Tailoring_1_A_Map",
"GarrBuilding_Tailoring_1_H_Info",
"GarrBuilding_Tailoring_1_H_Map",
"GarrBuilding_Tailoring_2_A_Info",
"GarrBuilding_Tailoring_2_A_Map",
"GarrBuilding_Tailoring_2_H_Info",
"GarrBuilding_Tailoring_2_H_Map",
"GarrBuilding_Tailoring_3_A_Info",
"GarrBuilding_Tailoring_3_A_Map",
"GarrBuilding_Tailoring_3_H_Info",
"GarrBuilding_Tailoring_3_H_Map",
"GarrBuilding_TownHall_1_A_Info",
"GarrBuilding_TownHall_1_A_Map",
"GarrBuilding_TownHall_1_H_Info",
"GarrBuilding_TownHall_1_H_Map",
"GarrBuilding_TownHall_2_A_Info",
"GarrBuilding_TownHall_2_A_Map",
"GarrBuilding_TownHall_2_H_Info",
"GarrBuilding_TownHall_2_H_Map",
"GarrBuilding_TownHall_3_A_Info",
"GarrBuilding_TownHall_3_A_Map",
"GarrBuilding_TownHall_3_H_Info",
"GarrBuilding_TownHall_3_H_Map",
"GarrBuilding_TradingPost_1_A_Info",
"GarrBuilding_TradingPost_1_A_Map",
"GarrBuilding_TradingPost_1_H_Info",
"GarrBuilding_TradingPost_1_H_Map",
"GarrBuilding_TradingPost_2_A_Info",
"GarrBuilding_TradingPost_2_A_Map",
"GarrBuilding_TradingPost_2_H_Info",
"GarrBuilding_TradingPost_2_H_Map",
"GarrBuilding_TradingPost_3_A_Info",
"GarrBuilding_TradingPost_3_A_Map",
"GarrBuilding_TradingPost_3_H_Info",
"GarrBuilding_TradingPost_3_H_Map",
"GarrBuilding_Workshop_1_A_Info",
"GarrBuilding_Workshop_1_A_Map",
"GarrBuilding_Workshop_1_H_Info",
"GarrBuilding_Workshop_1_H_Map",
"GarrBuilding_Workshop_2_A_Info",
"GarrBuilding_Workshop_2_A_Map",
"GarrBuilding_Workshop_2_H_Info",
"GarrBuilding_Workshop_2_H_Map",
"GarrBuilding_Workshop_3_A_Info",
"GarrBuilding_Workshop_3_A_Map",
"GarrBuilding_Workshop_3_H_Info",
"GarrBuilding_Workshop_3_H_Map",
"GarrFollower-Shadow",
"GarrLanding-Building-Complete",
"GarrLanding-Building-InProgress",
"GarrLanding-CircleGlow",
"GarrLanding-FollowerScrollFrame",
"GarrLanding-HeaderBar",
"GarrLanding-InvasionBadge",
"GarrLanding-InvasionBadge-Glow",
"GarrLanding-MiddleTile",
"GarrLanding-MinimapAlertBG",
"GarrLanding-MinimapIcon-Alliance-Down",
"GarrLanding-MinimapIcon-Alliance-Up",
"GarrLanding-MinimapIcon-Horde-Down",
"GarrLanding-MinimapIcon-Horde-Up",
"GarrLanding-Mission-Complete",
"GarrLanding-Mission-InProgress",
"GarrLanding-MissionListBG",
"GarrLanding-ShipMission-Complete",
"GarrLanding-ShipMission-InProgress",
"GarrLanding-ShipmentCompleteGlow",
"GarrLanding-SideToast-Glow",
"GarrLanding-Tab-Bottom-Highlight",
"GarrLanding-Tab-Bottom-Highlight-Left",
"GarrLanding-Tab-Bottom-Highlight-Right",
"GarrLanding-Tab-Bottom-Selected",
"GarrLanding-Tab-Bottom-Selected-Left",
"GarrLanding-Tab-Bottom-Selected-Right",
"GarrLanding-Tab-Bottom-Unselected",
"GarrLanding-Tab-Bottom-Unselected-Left",
"GarrLanding-Tab-Bottom-Unselected-Right",
"GarrLanding-Top",
"GarrLanding-TopTabHighlight",
"GarrLanding-TopTabSelected",
"GarrLanding-TopTabUnselected",
"GarrLanding-TradeskillTimer-BG",
"GarrLanding-TradeskillTimer-Border",
"GarrLanding-TradeskillTimer-ParchmentBG",
"GarrLanding-lowerleft",
"GarrLanding-lowerright",
"GarrLanding-upperleft",
"GarrLanding-upperright",
"GarrLandingList-CostBG",
"GarrLanding_RewardsListBG",
"GarrLanding_RewardsShadow",
"GarrLanding_Watermark-Tradeskill",
"GarrMission-AbilityHighlight",
"GarrMission-AbilityHighlight-Error",
"GarrMission-AllianceChest",
"GarrMission-FollowerItemBg",
"GarrMission-HordeChest",
"GarrMission-NeutralChest",
"GarrMissionLocation-Argus-List",
"GarrMissionLocation-Azsuna-List",
"GarrMissionLocation-Dalaran-List",
"GarrMissionLocation-FrostfireRidge-List",
"GarrMissionLocation-Gorgrond-List",
"GarrMissionLocation-Highmountain-List",
"GarrMissionLocation-Legion-List",
"GarrMissionLocation-Nagrand-List",
"GarrMissionLocation-ShadowmoonValley-List",
"GarrMissionLocation-SpiresofArak-List",
"GarrMissionLocation-Stormheim-List",
"GarrMissionLocation-Suramar-List",
"GarrMissionLocation-Talador-List",
"GarrMissionLocation-TannanJungle-List",
"GarrMissionLocation-Valsharah-List",
"GarrMission_Bg-DarkEdgeCorner",
"GarrMission_CheckGlow",
"GarrMission_ChestOpenTextGlow",
"GarrMission_ClassIcon-ArgussianReach",
"GarrMission_ClassIcon-ArmyoftheLight",
"GarrMission_ClassIcon-DeathKnight",
"GarrMission_ClassIcon-DeathKnight-Blood",
"GarrMission_ClassIcon-DeathKnight-Frost",
"GarrMission_ClassIcon-DeathKnight-Unholy",
"GarrMission_ClassIcon-DemonHunter-Havoc",
"GarrMission_ClassIcon-DemonHunter-Outcast",
"GarrMission_ClassIcon-DemonHunter-Vengeance",
"GarrMission_ClassIcon-Druid",
"GarrMission_ClassIcon-Druid-Balance",
"GarrMission_ClassIcon-Druid-Feral",
"GarrMission_ClassIcon-Druid-Guardian",
"GarrMission_ClassIcon-Druid-Restoration",
"GarrMission_ClassIcon-Hunter",
"GarrMission_ClassIcon-Hunter-BeastMastery",
"GarrMission_ClassIcon-Hunter-Marksmanship",
"GarrMission_ClassIcon-Hunter-Survival",
"GarrMission_ClassIcon-Karazhan",
"GarrMission_ClassIcon-Mage",
"GarrMission_ClassIcon-Mage-Arcane",
"GarrMission_ClassIcon-Mage-Fire",
"GarrMission_ClassIcon-Mage-Frost",
"GarrMission_ClassIcon-Monk",
"GarrMission_ClassIcon-Monk-Brewmaster",
"GarrMission_ClassIcon-Monk-Mistweaver",
"GarrMission_ClassIcon-Monk-Windwalker",
"GarrMission_ClassIcon-Paladin",
"GarrMission_ClassIcon-Paladin-Holy",
"GarrMission_ClassIcon-Paladin-Protection",
"GarrMission_ClassIcon-Paladin-Retribution",
"GarrMission_ClassIcon-Priest",
"GarrMission_ClassIcon-Priest-Discipline",
"GarrMission_ClassIcon-Priest-Holy",
"GarrMission_ClassIcon-Priest-Shadow",
"GarrMission_ClassIcon-Rogue",
"GarrMission_ClassIcon-Rogue-Assassination",
"GarrMission_ClassIcon-Rogue-Outlaw",
"GarrMission_ClassIcon-Rogue-Subtlety",
"GarrMission_ClassIcon-Shaman",
"GarrMission_ClassIcon-Shaman-Elemental",
"GarrMission_ClassIcon-Shaman-Enhancement",
"GarrMission_ClassIcon-Shaman-Restoration",
"GarrMission_ClassIcon-Voidscarred",
"GarrMission_ClassIcon-Warlock",
"GarrMission_ClassIcon-Warlock-Affliction",
"GarrMission_ClassIcon-Warlock-Demonology",
"GarrMission_ClassIcon-Warlock-Destruction",
"GarrMission_ClassIcon-Warrior",
"GarrMission_ClassIcon-Warrior-Arms",
"GarrMission_ClassIcon-Warrior-Fury",
"GarrMission_ClassIcon-Warrior-Protection",
"GarrMission_CounterCheck",
"GarrMission_CounterHalfCheck",
"GarrMission_CurrencyIcon-Material",
"GarrMission_CurrencyIcon-Salvage",
"GarrMission_CurrencyIcon-Xp",
"GarrMission_CurrentEncounter-Glow",
"GarrMission_CurrentEncounter-SpikeyGlow",
"GarrMission_EncounterAbilityBorder",
"GarrMission_EncounterAbilityBorder-Lg",
"GarrMission_EncounterBar-BG",
"GarrMission_EncounterBar-CheckMark",
"GarrMission_EncounterBar-CheckMark-Left",
"GarrMission_EncounterBar-CheckMark-Right",
"GarrMission_EncounterBar-CheckMarkCircleSwipe",
"GarrMission_EncounterBar-Elite",
"GarrMission_EncounterBar-End",
"GarrMission_EncounterBar-Fill",
"GarrMission_EncounterBar-PortraitRing",
"GarrMission_EncounterBar-Spark",
"GarrMission_EncounterBar-Xbg",
"GarrMission_EncounterBar-Xleft",
"GarrMission_EncounterBar-Xright",
"GarrMission_FollowerAbilityRollout",
"GarrMission_FollowerListButton",
"GarrMission_FollowerListButton-Highlight",
"GarrMission_FollowerListButton-Select",
"GarrMission_FollowerPageHeaderBG",
"GarrMission_FollowerPartyBox_Lg",
"GarrMission_FollowerPartyBox_Sm",
"GarrMission_IconLevelBG",
"GarrMission_ItemFrame",
"GarrMission_LevelUpBanner",
"GarrMission_ListGlow-Highlight",
"GarrMission_ListGlow-Select",
"GarrMission_LocationCover-Side",
"GarrMission_MissionCompleteChanceBg",
"GarrMission_MissionCostStartButtonBg",
"GarrMission_MissionIcon-Alchemy",
"GarrMission_MissionIcon-Blacksmithing",
"GarrMission_MissionIcon-Combat",
"GarrMission_MissionIcon-Construction",
"GarrMission_MissionIcon-Defense",
"GarrMission_MissionIcon-Enchanting",
"GarrMission_MissionIcon-Engineering",
"GarrMission_MissionIcon-Exploration",
"GarrMission_MissionIcon-Generic",
"GarrMission_MissionIcon-Inscription",
"GarrMission_MissionIcon-Jewelcrafting",
"GarrMission_MissionIcon-Leatherworking",
"GarrMission_MissionIcon-Logistics",
"GarrMission_MissionIcon-Patrol",
"GarrMission_MissionIcon-Provision",
"GarrMission_MissionIcon-Recruit",
"GarrMission_MissionIcon-Salvage",
"GarrMission_MissionIcon-Siege",
"GarrMission_MissionIcon-Tailoring",
"GarrMission_MissionIcon-Trading",
"GarrMission_MissionIcon-Training",
"GarrMission_MissionIcon-Wildlife",
"GarrMission_MissionParchment",
"GarrMission_MissionStart",
"GarrMission_MissionTooltipAway",
"GarrMission_MissionTooltipWorking",
"GarrMission_ParchmentHeader-End",
"GarrMission_ParchmentHeaderSelect-End",
"GarrMission_PartyBuffAbilityBorder",
"GarrMission_PartyBuffsBG",
"GarrMission_PlayerLootFrame",
"GarrMission_PortraitRing",
"GarrMission_PortraitRing_Darkener",
"GarrMission_PortraitRing_Empty",
"GarrMission_PortraitRing_Enemy",
"GarrMission_PortraitRing_Glow",
"GarrMission_PortraitRing_Highlight",
"GarrMission_PortraitRing_LevelBorder",
"GarrMission_PortraitRing_Quality",
"GarrMission_PortraitRing_iLvlBorder",
"GarrMission_RareGlowBG",
"GarrMission_RareOverlay",
"GarrMission_RewardsBG",
"GarrMission_RewardsBG-Desaturate",
"GarrMission_RewardsBanner",
"GarrMission_RewardsBanner-Desaturate",
"GarrMission_RewardsBorder-Corner",
"GarrMission_RewardsBorder-Corner-Desaturate",
"GarrMission_RewardsBox_Shadow",
"GarrMission_RewardsListBG",
"GarrMission_RewardsShadow",
"GarrMission_Silhouettes-1Alliance",
"GarrMission_Silhouettes-1Horde",
"GarrMission_SingleModelBG",
"GarrMission_StartMissionFrame",
"GarrMission_TabGlow",
"GarrMission_TopBorderCorner",
"GarrMission_TopBorderCorner-Highlight",
"GarrMission_TopBorderCorner-Select",
"GarrMission_UsefulAbilityIcon",
"GarrMission_WeakEncounterAbilityBorder",
"GarrMission_WeakEncounterAbilityBorder-Lg",
"GarrMission_XPBarBig-End",
"GarrMission_XPBarBig-LevelBorder",
"GarrMission_XPBarBig-Mid",
"Garr_BuildFX-Glow",
"Garr_BuildFX-Lines",
"Garr_BuildIcon",
"Garr_Building-AddFollowerPlus",
"Garr_BuildingConfirmation",
"Garr_BuildingIconRing_",
"Garr_BuildingIconTimerBG",
"Garr_BuildingIconTimerFill",
"Garr_BuildingInfoShadow",
"Garr_BuildingPlacementExplosion",
"Garr_BuildingShadowOverlay",
"Garr_BuildingTimerBG",
"Garr_BuildingTimerFill",
"Garr_BuildingTimerGlow",
"Garr_BuildingUpgradeExplosion",
"Garr_Building_MaterialFrame",
"Garr_CostBar",
"Garr_FollowerPortrait_Bg",
"Garr_FollowerPortrait_Ring",
"Garr_FollowerPortrait_TimerBG",
"Garr_FollowerPortrait_TimerFill",
"Garr_FollowerToast-Epic",
"Garr_FollowerToast-Rare",
"Garr_FollowerToast-Uncommon",
"Garr_InfoBox-BackgroundTile",
"Garr_InfoBox-Corner",
"Garr_InfoBox-CornerShadow",
"Garr_InfoBoxBorder-BigBottomCorner",
"Garr_InfoBoxBorder-Corner",
"Garr_InfoBoxBorder-FiligreeCorner",
"Garr_InfoBoxBorderMission-Corner",
"Garr_InfoBoxMission-BackgroundTile",
"Garr_InfoBoxMission-Corner",
"Garr_LevelBadgeGlow",
"Garr_LevelBadge_1",
"Garr_LevelBadge_2",
"Garr_LevelBadge_3",
"Garr_LevelUpgradeArrow",
"Garr_LevelUpgradeLocked",
"Garr_ListButton",
"Garr_ListButton-Highlight",
"Garr_ListButton-Selection",
"Garr_ListTab",
"Garr_ListTab-Highlight",
"Garr_ListTab-Select",
"Garr_LockedBuilding",
"Garr_Map_Frostfire1_H",
"Garr_Map_Frostfire2_H",
"Garr_Map_Frostfire3_H",
"Garr_Map_Frostfire4_H",
"Garr_Map_Shadowmoon1_A",
"Garr_Map_Shadowmoon2_A",
"Garr_Map_Shadowmoon3_A",
"Garr_Map_Shadowmoon4_A",
"Garr_MaterialIcon",
"Garr_MissionFX-Glow",
"Garr_MissionFX-Lines",
"Garr_MissionList-CostBG",
"Garr_MissionList-IconBG",
"Garr_MissionToast",
"Garr_MissionToast-Blank",
"Garr_MissionToast-IconBG",
"Garr_Mission_MaterialFrame",
"Garr_MonumentLocked",
"Garr_MonumentOpen",
"Garr_NotificationGlow",
"Garr_PlanIcon-List",
"Garr_PlansRequiredIcon",
"Garr_Plot_Frostfire_H_1",
"Garr_Plot_Frostfire_H_2",
"Garr_Plot_Frostfire_H_3",
"Garr_Plot_Frostfire_H_4",
"Garr_Plot_Glow_1",
"Garr_Plot_Glow_2",
"Garr_Plot_Glow_3",
"Garr_Plot_Glow_4",
"Garr_Plot_Shadowmoon_A_1",
"Garr_Plot_Shadowmoon_A_2",
"Garr_Plot_Shadowmoon_A_3",
"Garr_Plot_Shadowmoon_A_4",
"Garr_Specialization_FrameLeft",
"Garr_Specialization_FrameMid",
"Garr_Specialization_IconBorder",
"Garr_Specialization_IconSelected",
"Garr_SwapIcon",
"Garr_Toast",
"Garr_TownHallBanner_Left",
"Garr_TownHallBanner_LevelFiligree",
"Garr_TownHallBanner_Mid",
"Garr_TownHallBanner_Right",
"Garr_TreasureIcon",
"Garr_UpgradeBanner",
"Garr_UpgradeFX-Glow",
"Garr_UpgradeIcon",
"Garr_UpgradeIconTimerBG",
"Garr_UpgradeIconTimerFill",
"Garr_UpgradeTimerBG",
"Garr_UpgradeTimerFill",
"Garr_UpgradeTimerGlow",
"Garr_WoodFrame-BackgroundTile",
"Garr_WoodFrameCorner",
"Garr_XPBar_Left",
"Garr_XPBar_Nub",
"GarrisonFX-StarBurst",
"GarrisonFX_BlueFlare",
"GarrisonTroops-Health",
"GarrisonTroops-Health-Consume",
"Gear",
"GeneralFrame-HorizontalBar-Left",
"GeneralFrame-HorizontalBar-Right",
"GeneralFrame-InsetFrame-BottomLeft",
"GeneralFrame-InsetFrame-BottomRight",
"GeneralFrame-InsetFrame-TopLeft",
"GeneralFrame-InsetFrame-TopRight",
"Glues-WoW-LegionLogo",
"Glues-WoW-LegionLogo_cn",
"Glues-WoW-LegionLogo_tw",
"GlyphIcon-Spellbook",
"GreenCross",
"Headhunter_AbilityBorderGlow",
"Headhunter_BG",
"Headhunter_LineHeader",
"HealerBadge",
"Healing-BG",
"HealingDampening",
"Health-Bar-End",
"Health_End",
"Horde_Tier1_Arena1",
"Horde_Tier1_Arena2",
"Horde_Tier1_Armory1",
"Horde_Tier1_Armory2",
"Horde_Tier1_Barn1",
"Horde_Tier1_Barn2",
"Horde_Tier1_Barracks1",
"Horde_Tier1_Barracks2",
"Horde_Tier1_Farm1",
"Horde_Tier1_Fishing1",
"Horde_Tier1_Inn1",
"Horde_Tier1_Inn2",
"Horde_Tier1_Lumber1",
"Horde_Tier1_Lumber2",
"Horde_Tier1_Mage1",
"Horde_Tier1_Mage2",
"Horde_Tier1_Mine1",
"Horde_Tier1_Profession1",
"Horde_Tier1_Profession2",
"Horde_Tier1_Profession3",
"Horde_Tier1_Stables1",
"Horde_Tier1_Stables2",
"Horde_Tier1_Trading1",
"Horde_Tier1_Trading2",
"Horde_Tier1_Workshop1",
"Horde_Tier1_Workshop2",
"Horde_Tier2_Arena1",
"Horde_Tier2_Arena2",
"Horde_Tier2_Armory1",
"Horde_Tier2_Armory2",
"Horde_Tier2_Barn1",
"Horde_Tier2_Barn2",
"Horde_Tier2_Barracks1",
"Horde_Tier2_Barracks2",
"Horde_Tier2_Inn1",
"Horde_Tier2_Inn2",
"Horde_Tier2_Lumber1",
"Horde_Tier2_Lumber2",
"Horde_Tier2_Mage1",
"Horde_Tier2_Mage2",
"Horde_Tier2_Stables1",
"Horde_Tier2_Stables2",
"Horde_Tier2_Trading1",
"Horde_Tier2_Trading2",
"Horde_Tier2_Workshop1",
"Horde_Tier2_Workshop2",
"Horde_Tier3_Arena1",
"Horde_Tier3_Arena2",
"Horde_Tier3_Armory1",
"Horde_Tier3_Armory2",
"Horde_Tier3_Barn1",
"Horde_Tier3_Barn2",
"Horde_Tier3_Barracks1",
"Horde_Tier3_Barracks2",
"Horde_Tier3_Inn1",
"Horde_Tier3_Inn2",
"Horde_Tier3_Lumber1",
"Horde_Tier3_Lumber2",
"Horde_Tier3_Mage1",
"Horde_Tier3_Mage2",
"Horde_Tier3_Stables1",
"Horde_Tier3_Stables2",
"Horde_Tier3_Trading1",
"Horde_Tier3_Trading2",
"Horde_Tier3_Workshop1",
"Horde_Tier3_Workshop2",
"Icon-Death",
"Icon-Healer",
"Icon-Tank",
"Icon-WoW",
"Innkeeper",
"Insanity-DrippyPurple1",
"Insanity-DrippyPurple2",
"Insanity-PortraitOverlay",
"Insanity-PurpleBurstOn",
"Insanity-ShadowBurstOn",
"Insanity-Spark",
"Insanity-Tentacles",
"Insanity-TopPurpleShadow",
"InterruptOverlay",
"Krokuun_Highlight",
"LFG-lock",
"Lang-Regions-deDE",
"Lang-Regions-enCN",
"Lang-Regions-enGB",
"Lang-Regions-enTW",
"Lang-Regions-enUS",
"Lang-Regions-esES",
"Lang-Regions-esMX",
"Lang-Regions-frFR",
"Lang-Regions-itIT",
"Lang-Regions-koKR",
"Lang-Regions-ptBR",
"Lang-Regions-ptPT",
"Lang-Regions-ruRU",
"Lang-Regions-zhCN",
"Lang-Regions-zhTW",
"LegendaryToast-OrangeStarglow",
"LegendaryToast-background",
"LegendaryToast-particles1",
"LegendaryToast-particles2",
"LegendaryToast-particles3",
"LegendaryToast-ring1",
"Legion-boostpopup-bottom",
"Legion-boostpopup-exit-frame",
"Legion-boostpopup-middle",
"Legion-boostpopup-top",
"LegionMissionIcon-ZoneSupportAlliance-Map",
"LegionMissionIcon-ZoneSupportAlliance-MapBadge",
"LegionMissionIcon-ZoneSupportAlliance-Mission",
"LegionMissionIcon-ZoneSupportHorde-Map",
"LegionMissionIcon-ZoneSupportHorde-MapBadge",
"LegionMissionIcon-ZoneSupportHorde-Mission",
"LegionSplash-DemonHunter",
"LegionSplash-DemonHunterButton",
"LegionSplash-Logo",
"LegionSplash-NewCharacter",
"LegionSplash-NewCharacterButton",
"LegionfallMapBanner",
"Legionfall_Background",
"Legionfall_Banner",
"Legionfall_BarBackground",
"Legionfall_BarFrame",
"Legionfall_BarFrame-Glow",
"Legionfall_BarSpark",
"Legionfall_BuildingInfoBackground",
"Legionfall_CommandCenter_Completed",
"Legionfall_CommandCenter_Destroyed",
"Legionfall_CommandCenter_UnderAttack",
"Legionfall_CommandCenter_UnderConstruction",
"Legionfall_ExitFrame",
"Legionfall_GrayBanner",
"Legionfall_GrayFrame",
"Legionfall_GrayFrame_Buffs",
"Legionfall_GreenFrame",
"Legionfall_MageTower_Completed",
"Legionfall_MageTower_Destroyed",
"Legionfall_MageTower_UnderAttack",
"Legionfall_MageTower_UnderConstruction",
"Legionfall_NetherDisruptor_Completed",
"Legionfall_NetherDisruptor_Destroyed",
"Legionfall_NetherDisruptor_UnderAttack",
"Legionfall_NetherDisruptor_UnderConstruction",
"Legionfall_Padlock",
"Legionfall_RedFrame",
"Legionfall_YellowFrame",
"Lightlink",
"Lightlink-active",
"Lightlink-ball",
"Lightlink-blackinside",
"Lightlink-glow",
"Lightstone1",
"Lightstone2",
"Lightstone3",
"Lightstone4",
"Lightstone5",
"Lightstone6",
"Lightstone7",
"Lighttrait-backglow",
"Lighttrait-border",
"Lighttrait-border-selected",
"Lighttrait-glow",
"LootBanner-IconGlow",
"LootBanner-ItemBg",
"LootBanner-LootBagCircle",
"LootToast-LessAwesome",
"LootToast-MoreAwesome",
"MacAree_Highlight",
"Mage-ArcaneCharge",
"Mage-ArcaneCharge-CircleGlow",
"Mage-ArcaneCharge-Rune",
"Mage-ArcaneCharge-SmallSpark",
"Mage-ArcaneCharge-Spark",
"Mage-ArcaneChargeBar",
"MagePortalAlliance",
"MagePortalHorde",
"Mailbox",
"MainPet-Frame",
"MainPet-HealthBarBG",
"MainPet-HealthBarFill",
"MainPet-HealthBarFrame",
"MainPet-LevelBubble",
"MainPet-PetFamilyActivate",
"MainPet-PetFamilyFrame",
"MantidTower",
"MantidTowerDestroyed",
"MapCornerShadow-Left",
"MapCornerShadow-Right",
"Menagery1",
"Metal-Bar",
"Metal-Bar-Battlegrounds",
"Metal-Bar-Small",
"MiniMap-DeadArrow",
"MiniMap-PositionArrowDown",
"MiniMap-PositionArrowUp",
"MiniMap-PositionArrows",
"MiniMap-QuestArrow",
"MiniMap-VignetteArrow",
"Minimal_SliderBar_Button",
"Minimal_SliderBar_Button_Left",
"Minimal_SliderBar_Button_Right",
"Minimal_SliderBar_Left",
"Minimal_SliderBar_Right",
"MinimapArrow",
"Mission-FollowerPortraitFrame",
"Mission-LootBackgroundGlow",
"MissionFX-Smoke",
"MissionFX-SparkLines",
"Mixedtrait-border",
"Mobile-Alchemy",
"Mobile-Archeology",
"Mobile-Blacksmithing",
"Mobile-BonusIcon",
"Mobile-BonusIcon-Desaturated",
"Mobile-CombatBadgeIcon",
"Mobile-CombatIcon",
"Mobile-CombatIcon-Desaturated",
"Mobile-Cooking",
"Mobile-Enchanting",
"Mobile-Enginnering",
"Mobile-FirstAid",
"Mobile-Fishing",
"Mobile-Herbalism",
"Mobile-Inscription",
"Mobile-Jewelcrafting",
"Mobile-Leatherworking",
"Mobile-LegendaryQuestIcon",
"Mobile-LegendaryQuestIcon-Desaturated",
"Mobile-MechanicIcon-Curse",
"Mobile-MechanicIcon-Disorienting",
"Mobile-MechanicIcon-Lethal",
"Mobile-MechanicIcon-Powerful",
"Mobile-MechanicIcon-Slowing",
"Mobile-Mining",
"Mobile-Pets",
"Mobile-QuestIcon",
"Mobile-QuestIcon-Desaturated",
"Mobile-Skinning",
"Mobile-Tailoring",
"Mobile-TreasureIcon",
"Mobile-TreasureIcon-Desaturated",
"MonkUI-LightOrb",
"MonkUI-LightOrb-small",
"MonkUI-OrbOff",
"MonkUI-OrbOff-small",
"MonkUI-background",
"MonkUI-background-shadow",
"MonsterEnemy",
"MonsterFriend",
"MonsterNeutral",
"Monuments-Frame",
"Monuments-LeftButton-Down",
"Monuments-LeftButton-Up",
"Monuments-Lock",
"Monuments-LockedOverlay",
"Monuments-RightButton-Down",
"Monuments-RightButton-Up",
"MountJournalIcons-Alliance",
"MountJournalIcons-Horde",
"MountToast-Background",
"MovieRecordingIcon",
"NPE_ArrowDown",
"NPE_ArrowDownGlow",
"NPE_ArrowLeft",
"NPE_ArrowLeftGlow",
"NPE_ArrowRight",
"NPE_ArrowRightGlow",
"NPE_ArrowUp",
"NPE_ArrowUpGlow",
"NPE_ExclamationPoint",
"NPE_Icon",
"NPE_LeftClick",
"NPE_RightClick",
"NPE_TurnIn",
"NPE_keyboard",
"NavalMap-Alliance-Fog",
"NavalMap-Alliance-Highlight",
"NavalMap-CircleGlowTrails",
"NavalMap-Horde-Fog",
"NavalMap-Horde-Highlight",
"NavalMap-IronHorde-Fog",
"NavalMap-IronHorde-Highlight",
"NavalMap-LargeBonusCircle",
"NavalMap-OpenWaters-Fog",
"NavalMap-OpenWaters-Highlight",
"NavalMap-SmallBonusCircle",
"NavalMap01",
"Neutral-NineSlice-Corner",
"Neutralstone1",
"Neutralstone2",
"Neutralstone3",
"Neutralstone4",
"Neutralstone5",
"Neutralstone6",
"Neutralstone7",
"Neutraltrait-Glow",
"Neutraltrait-backglow",
"Neutraltrait-border",
"Neutraltrait-border-selected",
"NewCharacter-Alliance",
"NewCharacter-Horde",
"NoQuestsBackground",
"None",
"OBJBonusBar-Top",
"OBJFX-BarGlow",
"OBJFX_Glow",
"OBJFX_LineBurst",
"OBJFX_LineGlow",
"OBJFX_StarBurst",
"Object",
"Objective-Fail",
"Objective-Header",
"Objective-ItemBorder",
"Objective-Nub",
"OneButton_ProcLoop_Flipbook",
"OneButton_ProcStart_Flipbook",
"OptionsIcon-Brown",
"Options_CategoryHeader_1",
"Options_CategoryHeader_2",
"Options_CategoryHeader_3",
"Options_HorizontalDivider",
"Options_InnerFrame",
"Options_ListExpand_Left",
"Options_ListExpand_Right",
"Options_ListExpand_Right_Expanded",
"Options_List_Active",
"Options_List_Hover",
"Options_Tab_Active_Left",
"Options_Tab_Active_Middle",
"Options_Tab_Active_Right",
"Options_Tab_Left",
"Options_Tab_Middle",
"Options_Tab_Right",
"ParagonReputation_Bag",
"ParagonReputation_Checkmark",
"ParagonReputation_Glow",
"PartyMember",
"PartySizeIcon",
"PetJournal-BattleSlot-AbilityBorder",
"PetJournal-BattleSlot-Active",
"PetJournal-BattleSlot-IconBorder",
"PetJournal-BattleSlot-Locked",
"PetJournal-BattleSlot-Shadow",
"PetJournal-BattleSlotFrame-Corner",
"PetJournal-BattleSlotTitle-Left",
"PetJournal-BattleSlotTitle-Right",
"PetJournal-ExpBar-Background",
"PetJournal-ExpBar-Divider",
"PetJournal-ExpBar-Left",
"PetJournal-ExpBar-Mid",
"PetJournal-ExpBar-Right",
"PetJournal-FavoritesIcon",
"PetJournal-HealthBar-Background",
"PetJournal-HealthBar-Left",
"PetJournal-HealthBar-Mid",
"PetJournal-HealthBar-Right",
"PetJournal-LevelBubble",
"PetJournal-PetBattleAchievementBG",
"PetJournal-PetBattleAchievementGlow",
"PetJournal-PetCard-Abilities",
"PetJournal-PetCard-BG",
"PetList-ButtonBackground",
"PetList-ButtonHighlight",
"PetList-ButtonSelect",
"PetToast-background",
"PhotosensitivityWarning-parchment-background",
"PhotosensitivityWarning-questbang-icon",
"PhotosensitivityWarning-vignette",
"PlayerControlled",
"PlayerDeadBlip",
"PlayerEnemy",
"PlayerFriend",
"PlayerNeutral",
"PlayerPartyBlip",
"PlayerRaidBlip",
"Poisons",
"PortalBlue",
"PortalPurple",
"PortalRed",
"Portrait-Frame",
"Portrait-Frame-Nameplate",
"Portrait-Frame-Nameplate-scaledup",
"Portrait-Frame-Small",
"Portrait-frame-color",
"Priest-InsanityOverlay",
"Profession",
"Quest-Alliance-WaxSeal",
"Quest-Horde-WaxSeal",
"Quest-Legionfall-WaxSeal",
"QuestArtifact",
"QuestArtifactTurnin",
"QuestBG-Alliance",
"QuestBG-Horde",
"QuestBG-Legionfall",
"QuestBG-TheHandofFate",
"QuestBlob",
"QuestBonusObjective",
"QuestCollapse-Hide-Down",
"QuestCollapse-Hide-Up",
"QuestCollapse-Show-Down",
"QuestCollapse-Show-Up",
"QuestDaily",
"QuestDetails-RewardsBottomOverlay",
"QuestDetails-RewardsOverlay",
"QuestDetails-TopOverlay",
"QuestDetailsBackgrounds",
"QuestItemBorder",
"QuestItemBorder-Small",
"QuestLegendary",
"QuestLegendaryTurnin",
"QuestLog-Frame-Gradient-bottom",
"QuestLog-Tab-side-Glow-Select",
"QuestLog-Tab-side-Glow-hover",
"QuestLog-campaign-lore-background",
"QuestLog-frame",
"QuestLog-frame-devider",
"QuestLog-frame-filigree",
"QuestLog-header-glow-yellow",
"QuestLog-icon-Expand",
"QuestLog-icon-checkmark-yellow",
"QuestLog-icon-setting",
"QuestLog-icon-shrink",
"QuestLog-icon-ticksquare",
"QuestLog-quest-glow-yellow",
"QuestLog-reward-bottom",
"QuestLog-reward-header-top",
"QuestLog-reward-tile-vertical",
"QuestLog-reward-top-frame",
"QuestLog-tab",
"QuestLog-tab-icon-MapLegend",
"QuestLog-tab-icon-MapLegend-inactive",
"QuestLog-tab-icon-event",
"QuestLog-tab-icon-event-inactive",
"QuestLog-tab-icon-quest",
"QuestLog-tab-icon-quest-inactive",
"QuestLog-tab-side",
"QuestLogBackground",
"QuestNormal",
"QuestObjective",
"QuestPortraitIcon-SandboxQuest",
"QuestRepeatableTurnin",
"QuestSkull",
"QuestTurnin",
"QuestionMarkContinent-Icon",
"QuestionMarkContinent-IconHighlight",
"Raid",
"RaidMember",
"Reagents",
"RedButton-Condense",
"RedButton-Condense-Pressed",
"RedButton-Condense-disabled",
"RedButton-Exit",
"RedButton-Exit-Disabled",
"RedButton-Expand",
"RedButton-Expand-Disabled",
"RedButton-Expand-Pressed",
"RedButton-Highlight",
"RedButton-MiniCondense",
"RedButton-MiniCondense-disabled",
"RedButton-MiniCondense-pressed",
"RedButton-exit-pressed",
"RedCCIconGlow",
"Relic-Arcane-Slot",
"Relic-Arcane-TraitBG",
"Relic-Arcane-TraitGlow",
"Relic-Arcane-TraitGlowRing",
"Relic-Blood-Slot",
"Relic-Blood-TraitBG",
"Relic-Blood-TraitGlow",
"Relic-Blood-TraitGlowRing",
"Relic-Fel-Slot",
"Relic-Fel-TraitBG",
"Relic-Fel-TraitGlow",
"Relic-Fel-TraitGlowRing",
"Relic-Fire-Slot",
"Relic-Fire-TraitBG",
"Relic-Fire-TraitGlow",
"Relic-Fire-TraitGlowRing",
"Relic-Frost-Slot",
"Relic-Frost-TraitBG",
"Relic-Frost-TraitGlow",
"Relic-Frost-TraitGlowRing",
"Relic-Holy-Slot",
"Relic-Holy-TraitBG",
"Relic-Holy-TraitGlow",
"Relic-Holy-TraitGlowRing",
"Relic-Iron-Slot",
"Relic-Iron-TraitBG",
"Relic-Iron-TraitGlow",
"Relic-Iron-TraitGlowRing",
"Relic-Life-Slot",
"Relic-Life-TraitBG",
"Relic-Life-TraitGlow",
"Relic-Life-TraitGlowRing",
"Relic-Rankdisable-DarkGlow",
"Relic-Rankframe",
"Relic-Rankframe-glow",
"Relic-Rankselected-UpperGlow",
"Relic-Rankselected-circle",
"Relic-Shadow-Slot",
"Relic-Shadow-TraitBG",
"Relic-Shadow-TraitGlow",
"Relic-Shadow-TraitGlowRing",
"Relic-SlotBG",
"Relic-SlotBG-Glass",
"Relic-Water-Slot",
"Relic-Water-TraitBG",
"Relic-Water-TraitGlow",
"Relic-Water-TraitGlowRing",
"Relic-Wind-Slot",
"Relic-Wind-TraitBG",
"Relic-Wind-TraitGlow",
"Relic-Wind-TraitGlowRing",
"Relicforge-Bottomframe",
"Relicforge-Bottomleft-corner",
"Relicforge-Bottomright-corner",
"Relicforge-Leftframe",
"Relicforge-Relicsbackground",
"Relicforge-Relicsbackground-Previewtraits",
"Relicforge-Rightframe",
"Relicforge-Slot-background",
"Relicforge-Slot-frame",
"Relicforge-Slot-frame-Active",
"Relicforge-Topdecoration",
"Relicforge-Topframe",
"Relicforge-Topleft-corner",
"Relicforge-Topright-corner",
"Relicforge-background",
"Repair",
"ReportList-ButtonSelect",
"Rewards-Shadow",
"Rewards-Top",
"Rotating-MinimapArrow",
"Rotating-MinimapGroupArrow",
"Rotating-MinimapGuideArrow",
"Rune-01-dark",
"Rune-01-light",
"Rune-01-neutral",
"Rune-01-purple",
"Rune-02-dark",
"Rune-02-light",
"Rune-02-neutral",
"Rune-02-purple",
"Rune-03-dark",
"Rune-03-light",
"Rune-03-neutral",
"Rune-03-purple",
"Rune-04-dark",
"Rune-04-light",
"Rune-04-neutral",
"Rune-04-purple",
"Rune-05-dark",
"Rune-05-light",
"Rune-05-neutral",
"Rune-05-purple",
"Rune-06-dark",
"Rune-06-light",
"Rune-06-neutral",
"Rune-06-purple",
"Rune-07-dark",
"Rune-07-light",
"Rune-08-dark",
"Rune-08-light",
"Rune-09-dark",
"Rune-09-light",
"Rune-10-dark ",
"Rune-10-light",
"Rune-11-dark",
"Rune-11-light",
"ScenarioTrackerToast",
"ScenarioTrackerToast-FinalFiligree",
"ScenariosIcon",
"Score-Team",
"ScoreDivider",
"ScoreTeam",
"ShipMission-RedGlowRing",
"ShipMission-TimerBG",
"ShipMissionIcon-Bonus-Map",
"ShipMissionIcon-Bonus-MapBadge",
"ShipMissionIcon-Bonus-Mission",
"ShipMissionIcon-Combat-Map",
"ShipMissionIcon-Combat-MapBadge",
"ShipMissionIcon-Combat-Mission",
"ShipMissionIcon-Legendary-Map",
"ShipMissionIcon-Legendary-MapBadge",
"ShipMissionIcon-Legendary-Mission",
"ShipMissionIcon-Oil-Map",
"ShipMissionIcon-Oil-MapBadge",
"ShipMissionIcon-Oil-Mission",
"ShipMissionIcon-SiegeA-Map",
"ShipMissionIcon-SiegeA-MapBadge",
"ShipMissionIcon-SiegeA-Mission",
"ShipMissionIcon-SiegeH-Map",
"ShipMissionIcon-SiegeH-MapBadge",
"ShipMissionIcon-SiegeH-Mission",
"ShipMissionIcon-SiegeIHA-Map",
"ShipMissionIcon-SiegeIHA-MapBadge",
"ShipMissionIcon-SiegeIHA-Mission",
"ShipMissionIcon-SiegeIHH-Map",
"ShipMissionIcon-SiegeIHH-MapBadge",
"ShipMissionIcon-SiegeIHH-Mission",
"ShipMissionIcon-Training-Map",
"ShipMissionIcon-Training-MapBadge",
"ShipMissionIcon-Training-Mission",
"ShipMissionIcon-Treasure-Map",
"ShipMissionIcon-Treasure-MapBadge",
"ShipMissionIcon-Treasure-Mission",
"ShipMissionParchment-Tile",
"ShipMission_Bg-DarkEdgeCorner",
"ShipMission_BoatRarity-Epic",
"ShipMission_BoatRarity-Rare",
"ShipMission_BoatRarity-Uncommon",
"ShipMission_CurrencyIcon-Oil",
"ShipMission_DangerousSkull",
"ShipMission_EncounterAbilityBorder",
"ShipMission_EncounterAbilityBorder-Lg",
"ShipMission_FollowerBG",
"ShipMission_FollowerBG-Glow",
"ShipMission_FollowerListButton",
"ShipMission_FollowerListButton-Highlight",
"ShipMission_FollowerListButton-Select",
"ShipMission_IconLevelBG",
"ShipMission_LocationCover-Side",
"ShipMission_MissionCostStartButtonBg",
"ShipMission_NameBG",
"ShipMission_PartyBuffsBG",
"ShipMission_RewardsBG-Desaturate",
"ShipMission_RewardsBorder-Corner-Desaturate",
"ShipMission_ShipFollower-EquipmentBG",
"ShipMission_ShipFollower-EquipmentFrame",
"ShipMission_ShipFollower-Lock-Epic",
"ShipMission_ShipFollower-Lock-Rare",
"ShipMission_ShipFollower-TypeFrame",
"ShipMission_StartMissionFrame",
"ShipMission_Toast",
"ShipMission_TopBorderCorner",
"Ships_CargoShip-List",
"Ships_CargoShip-Map",
"Ships_CargoShip-Portrait",
"Ships_Carrier-List",
"Ships_Carrier-Map",
"Ships_Carrier-Portrait",
"Ships_CarrierA-List",
"Ships_CarrierA-Map",
"Ships_CarrierA-Portrait",
"Ships_CarrierH-List",
"Ships_CarrierH-Map",
"Ships_CarrierH-Portrait",
"Ships_Dreadnaught-List",
"Ships_Dreadnaught-Map",
"Ships_Dreadnaught-Portrait",
"Ships_DreadnaughtA-List",
"Ships_DreadnaughtA-Map",
"Ships_DreadnaughtA-Portrait",
"Ships_DreadnaughtH-List",
"Ships_DreadnaughtH-Map",
"Ships_DreadnaughtH-Portrait",
"Ships_EnemyCargoShip-Portrait",
"Ships_EnemyCarrier-Portrait",
"Ships_EnemyCarrierA-Portrait",
"Ships_EnemyCarrierH-Portrait",
"Ships_EnemyDreadnaught-Portrait",
"Ships_EnemyDreadnaughtA-Portrait",
"Ships_EnemyDreadnaughtH-Portrait",
"Ships_EnemyGalleonA-Portrait",
"Ships_EnemyGalleonH-Portrait",
"Ships_EnemySubmarineA-Portrait",
"Ships_EnemySubmarineH-Portrait",
"Ships_EnemyTroopTransport-Portrait",
"Ships_GalleonA-List",
"Ships_GalleonA-Map",
"Ships_GalleonA-Portrait",
"Ships_GalleonH-List",
"Ships_GalleonH-Map",
"Ships_GalleonH-Portrait",
"Ships_SubmarineA-List",
"Ships_SubmarineA-Map",
"Ships_SubmarineA-Portrait",
"Ships_SubmarineH-List",
"Ships_SubmarineH-Map",
"Ships_SubmarineH-Portrait",
"Ships_TroopTransport-List",
"Ships_TroopTransport-Map",
"Ships_TroopTransport-Portrait",
"SliderBar-Button",
"SliderBar-NineSlice-CornerBottomLeft",
"SliderBar-NineSlice-CornerBottomRight",
"SliderBar-NineSlice-CornerTopLeft",
"SliderBar-NineSlice-CornerTopRight",
"SmallQuestBang",
"Spinner_Ring",
"Spinner_Shadow",
"Spinner_Sparks",
"SquareMask",
"StableMaster",
"Start-VersusSplash",
"StoneFrameCorner-TopLeft",
"StoryHeader-BG",
"StoryHeader-CheevoIcon",
"StoryHeader-Shadow",
"StreamCinematic-BC-Down",
"StreamCinematic-BC-Up",
"StreamCinematic-CC-Down",
"StreamCinematic-CC-Up",
"StreamCinematic-Classic-Down",
"StreamCinematic-Classic-Up",
"StreamCinematic-DownloadIcon",
"StreamCinematic-Highlight",
"StreamCinematic-LK-Down",
"StreamCinematic-LK-Up",
"StreamCinematic-Legion-Down",
"StreamCinematic-Legion-Up",
"StreamCinematic-MOP-Down",
"StreamCinematic-MOP-Up",
"StreamCinematic-PlayButton",
"StreamCinematic-ProgressBarBG",
"StreamCinematic-WOD-Down",
"StreamCinematic-WOD-Up",
"Talent-Background",
"Talent-BottomLeftCurlies",
"Talent-BottomRightCurlies",
"Talent-Highlight",
"Talent-RingWithDot",
"Talent-Selection",
"Talent-Selection-Legendary",
"Talent-Separator",
"Talent-TopLeftCurlies",
"Talent-TopRightCurlies",
"TalkingHeads-Glow-Sheen",
"TalkingHeads-Glow-SideBarGlow",
"TalkingHeads-Glow-TextSheen",
"TalkingHeads-Glow-TopBarGlow",
"TalkingHeads-Glow-TopSpike",
"TalkingHeads-PortraitBg",
"TalkingHeads-PortraitFrame",
"TalkingHeads-TextBackground",
"TankBadge",
"Target",
"Target-Tracker",
"TargetCrosshairs",
"TaskPOI-Icon",
"TaskPOI-IconHighlight",
"TaskPOI-IconSelect",
"TaxiNode_Alliance",
"TaxiNode_Horde",
"TaxiNode_Neutral",
"Taxi_Frame_Gray",
"Taxi_Frame_Green",
"Taxi_Frame_Yellow",
"Timer-BG",
"Timer-Fill",
"Timer-Frame",
"Toast-Flash",
"Toast-Frame",
"Toast-IconBG",
"Tooltip-Glues-NineSlice-Center",
"Tooltip-Glues-NineSlice-CornerBottomLeft",
"Tooltip-Glues-NineSlice-CornerBottomRight",
"Tooltip-Glues-NineSlice-CornerTopLeft",
"Tooltip-Glues-NineSlice-CornerTopRight",
"Tooltip-NineSlice-Center",
"Tooltip-NineSlice-CornerBottomLeft",
"Tooltip-NineSlice-CornerBottomRight",
"Tooltip-NineSlice-CornerTopLeft",
"Tooltip-NineSlice-CornerTopRight",
"Tracker-Check",
"Trinket-Frame",
"TrivialQuests",
"UI-Character-Info-DeathKnight-BG",
"UI-Character-Info-DemonHunter-BG",
"UI-Character-Info-Druid-BG",
"UI-Character-Info-Hunter-BG",
"UI-Character-Info-ItemLevel-Bounce",
"UI-Character-Info-Line-Bounce",
"UI-Character-Info-Mage-BG",
"UI-Character-Info-Monk-BG",
"UI-Character-Info-Paladin-BG",
"UI-Character-Info-Priest-BG",
"UI-Character-Info-Rogue-BG",
"UI-Character-Info-Shaman-BG",
"UI-Character-Info-Title",
"UI-Character-Info-Warlock-BG",
"UI-Character-Info-Warrior-BG",
"UI-CharacterCreate-LargeButton",
"UI-CharacterCreate-LargeButton-Blue-Highlight",
"UI-CharacterCreate-LargeButton-Yellow-Highlight",
"UI-CharacterCreate-Metal-Finery-Corner",
"UI-CharacterCreate-Metal-Small-Finery",
"UI-CharacterCreate-MetalFrame-Horizontal",
"UI-CharacterCreate-MetalFrame-Vertical",
"UI-CharacterCreate-PadLock",
"UI-ChatIcon-ANBS",
"UI-ChatIcon-App",
"UI-ChatIcon-D3",
"UI-ChatIcon-DST2",
"UI-ChatIcon-FEN",
"UI-ChatIcon-FORE",
"UI-ChatIcon-GRY",
"UI-ChatIcon-Hero",
"UI-ChatIcon-LAZR",
"UI-ChatIcon-ODIN",
"UI-ChatIcon-OSI",
"UI-ChatIcon-Overwatch-zhCN",
"UI-ChatIcon-Pro",
"UI-ChatIcon-RTRO",
"UI-ChatIcon-S1",
"UI-ChatIcon-S2",
"UI-ChatIcon-VIPR",
"UI-ChatIcon-W3",
"UI-ChatIcon-WLBY",
"UI-ChatIcon-WTCG",
"UI-ChatIcon-WoW",
"UI-ChatIcon-ZEUS",
"UI-DialogBox-Background-Dark",
"UI-DialogBox-goldbutton-down-left-blue",
"UI-DialogBox-goldbutton-down-middle-blue",
"UI-DialogBox-goldbutton-down-right-blue",
"UI-DialogBox-goldbutton-up-left-blue",
"UI-DialogBox-goldbutton-up-middle-blue",
"UI-DialogBox-goldbutton-up-right-blue",
"UI-DiamondDialogBox-Border",
"UI-DiamondDialogBox-ClassicBorder",
"UI-Feedback-Border",
"UI-Frame-BotCornerLeft",
"UI-Frame-BotCornerRight",
"UI-Frame-BtnCornerLeft",
"UI-Frame-BtnCornerRight",
"UI-Frame-BtnDivLeft",
"UI-Frame-BtnDivMiddle",
"UI-Frame-BtnDivRight",
"UI-Frame-DialogBox-BackgroundTile",
"UI-Frame-DiamondMetal-CornerBottomLeft",
"UI-Frame-DiamondMetal-CornerBottomRight",
"UI-Frame-DiamondMetal-CornerTopLeft",
"UI-Frame-DiamondMetal-CornerTopRight",
"UI-Frame-DiamondMetal-Header-CornerLeft",
"UI-Frame-DiamondMetal-Header-CornerRight",
"UI-Frame-InnerBotLeftCorner",
"UI-Frame-InnerBotRight",
"UI-Frame-InnerSplitLeft",
"UI-Frame-InnerSplitRight",
"UI-Frame-InnerTopLeft",
"UI-Frame-InnerTopRight",
"UI-Frame-Neutral-CardParchment",
"UI-Frame-Neutral-CardParchmentWider",
"UI-Frame-Neutral-ExitButtonBorder",
"UI-Frame-Neutral-Portrait",
"UI-Frame-Neutral-PortraitDisable",
"UI-Frame-Neutral-PortraitWider",
"UI-Frame-Neutral-PortraitWiderDisable",
"UI-Frame-Neutral-Ribbon",
"UI-Frame-Neutral-TitleLeft",
"UI-Frame-Neutral-TitleRight",
"UI-Frame-Portrait",
"UI-Frame-TopCornerRight",
"UI-Frame-TopCornerRightSimple",
"UI-Frame-TopLeftCorner",
"UI-Frame-TopLeftCornerNoPortrait",
"UI-HUD-ActionBar-Cast-Fill",
"UI-HUD-ActionBar-Casting-Complete-Glow",
"UI-HUD-ActionBar-Casting-InnerGlow",
"UI-HUD-ActionBar-Channel-Complete-Glow",
"UI-HUD-ActionBar-Channel-Fill",
"UI-HUD-ActionBar-Channel-InnerGlow",
"UI-HUD-ActionBar-GCD-Flipbook",
"UI-HUD-ActionBar-Interrupt",
"UI-HUD-ActionBar-Interrupt-Highlight",
"UI-HUD-ActionBar-PetAutoCast-Ants",
"UI-HUD-ActionBar-PetAutoCast-Corners",
"UI-HUD-ActionBar-Proc-Loop-Flipbook",
"UI-HUD-ActionBar-Proc-Start-Flipbook",
"UI-HUD-ActionBar-Target",
"UI-HUD-ActionBar-Target-Highlight",
"UI-HUD-RotationHelper-Active",
"UI-HUD-RotationHelper-Active-FX",
"UI-HUD-RotationHelper-Inactive",
"UI-HUD-RotationHelper-Overlay",
"UI-HUD-RotationHelper-ProcAltGlow",
"UI-HUD-RotationHelper-SpellbookDivider",
"UI-HUD-RotationHelper-SpellbookGlow",
"UI-LFG-DeclineMark",
"UI-LFG-DeclineMark-Raid",
"UI-LFG-DividerLine",
"UI-LFG-PendingMark",
"UI-LFG-PendingMark-Raid",
"UI-LFG-ReadyMark",
"UI-LFG-ReadyMark-Raid",
"UI-LFG-RoleIcon-DPS",
"UI-LFG-RoleIcon-DPS-Background",
"UI-LFG-RoleIcon-DPS-Disabled",
"UI-LFG-RoleIcon-DPS-Micro",
"UI-LFG-RoleIcon-DPS-Micro-GroupFinder",
"UI-LFG-RoleIcon-DPS-Micro-Raid",
"UI-LFG-RoleIcon-Decline",
"UI-LFG-RoleIcon-Generic",
"UI-LFG-RoleIcon-Generic-Disabled",
"UI-LFG-RoleIcon-Generic-Micro",
"UI-LFG-RoleIcon-Generic-Micro-GroupFinder",
"UI-LFG-RoleIcon-Generic-Micro-Raid",
"UI-LFG-RoleIcon-Healer",
"UI-LFG-RoleIcon-Healer-Background",
"UI-LFG-RoleIcon-Healer-Disabled",
"UI-LFG-RoleIcon-Healer-Micro",
"UI-LFG-RoleIcon-Healer-Micro-GroupFinder",
"UI-LFG-RoleIcon-Healer-Micro-Raid",
"UI-LFG-RoleIcon-Incentive",
"UI-LFG-RoleIcon-Leader",
"UI-LFG-RoleIcon-Leader-Disabled",
"UI-LFG-RoleIcon-Leader-Micro",
"UI-LFG-RoleIcon-Leader-Micro-GroupFinder",
"UI-LFG-RoleIcon-Leader-Micro-Raid",
"UI-LFG-RoleIcon-Pending",
"UI-LFG-RoleIcon-RangedDPS",
"UI-LFG-RoleIcon-RangedDPS-Disabled",
"UI-LFG-RoleIcon-RangedDPS-Micro",
"UI-LFG-RoleIcon-RangedDPS-Micro-GroupFinder",
"UI-LFG-RoleIcon-RangedDPS-Micro-Raid",
"UI-LFG-RoleIcon-Ready",
"UI-LFG-RoleIcon-Tank",
"UI-LFG-RoleIcon-Tank-Background",
"UI-LFG-RoleIcon-Tank-Disabled",
"UI-LFG-RoleIcon-Tank-Micro",
"UI-LFG-RoleIcon-Tank-Micro-GroupFinder",
"UI-LFG-RoleIcon-Tank-Micro-Raid",
"UI-LFG-RoleIcon-Tank-Micro-Raid-Role",
"UI-Minimap-Clock",
"UI-MoneyFrame-Large",
"UI-OuterBorderButtonPatch",
"UI-PaidCharacterCustomization-Button-ActivateCharacter",
"UI-QuestTracker-LFG-eye",
"UI-QuestTracker-LFG-eye-selected",
"UI-QuestTracker-OBJFX-BarGlow",
"UI-QuestTracker-OBJFX-Shine",
"UI-QuestTracker-OBJFX_LineGlow",
"UI-QuestTracker-Objective-Fail",
"UI-QuestTracker-Objective-Nub",
"UI-QuestTracker-Primary-Objective-Header",
"UI-QuestTracker-Progressbar-Frame",
"UI-QuestTracker-Progressbar-Full-Channel",
"UI-QuestTracker-Secondary-Objective-Header",
"UI-QuestTracker-Tracker-Check",
"UI-QuestTracker-Tracker-Check-Glow",
"UI-QuestTrackerButton-Collapse-All",
"UI-QuestTrackerButton-Collapse-All-Pressed",
"UI-QuestTrackerButton-Expand-All",
"UI-QuestTrackerButton-Expand-All-Pressed",
"UI-QuestTrackerButton-Filter",
"UI-QuestTrackerButton-Filter-Pressed",
"UI-QuestTrackerButton-QuestItem-Frame",
"UI-QuestTrackerButton-QuestItem-Frame-Glow",
"UI-QuestTrackerButton-Red-Highlight",
"UI-QuestTrackerButton-Secondary-Collapse",
"UI-QuestTrackerButton-Secondary-Collapse-Pressed",
"UI-QuestTrackerButton-Secondary-Expand",
"UI-QuestTrackerButton-Secondary-Expand-Pressed",
"UI-QuestTrackerButton-Yellow-Highlight",
"UI-ScrollBar-ClassicScrollDownButton-Disabled",
"UI-ScrollBar-ClassicScrollDownButton-Down",
"UI-ScrollBar-ClassicScrollDownButton-Highlight",
"UI-ScrollBar-ClassicScrollDownButton-Up",
"UI-ScrollBar-ClassicScrollUpButton-Disabled",
"UI-ScrollBar-ClassicScrollUpButton-Down",
"UI-ScrollBar-ClassicScrollUpButton-Highlight",
"UI-ScrollBar-ClassicScrollUpButton-Up",
"UI-SquareButtonBrown-Down",
"UI-SquareButtonBrown-Up",
"UI-Taxi-Icon-Nub",
"UIFrameBackground-NineSlice-CornerBottomLeft",
"UIFrameBackground-NineSlice-CornerBottomRight",
"UI_Editor_Eye_Icon",
"UnitFrame",
"UnitFrame-NoMana",
"UnitFrame-NoTrinket",
"UnitFrame_CCOverlay",
"UnitFrame_CCOverlay-NoMana",
"UnitFrame_CurrentPlayer",
"UnitFrame_CurrentPlayer-NoMana",
"UnitFrame_CurrentPlayer-NoTrinket",
"UnitFrame_CurrentPlayerGlow",
"UnitFrame_CurrentPlayerGlow-NoMana",
"UnitFrame_CurrentPlayer_CCOverlay",
"UnitFrame_CurrentPlayer_CCOverlay-NoMana",
"UnitFrame_CurrentPlayer_DeathOverlay",
"UnitFrame_CurrentPlayer_DeathOverlay-NoMana",
"UnitFrame_CurrentPlayer_FocusFireOverlay",
"UnitFrame_CurrentPlayer_FocusFireOverlay-NoMana",
"UnitFrame_DeathOverlay",
"UnitFrame_DeathOverlay-NoMana",
"UnitFrame_FocusFireOverlay",
"UnitFrame_FocusFireOverlay-NoMana",
"Vehicle-Air-Alliance",
"Vehicle-Air-Horde",
"Vehicle-Air-Occupied",
"Vehicle-Air-Unoccupied",
"Vehicle-AllianceCart",
"Vehicle-Carriage",
"Vehicle-Ground-Occupied",
"Vehicle-Ground-Unoccupied",
"Vehicle-GrummleConvoy",
"Vehicle-HammerGold",
"Vehicle-HammerGold-1",
"Vehicle-HammerGold-2",
"Vehicle-HammerGold-3",
"Vehicle-HordeCart",
"Vehicle-Mogu",
"Vehicle-SilvershardMines-Arrow",
"Vehicle-SilvershardMines-MineCart",
"Vehicle-SilvershardMines-MineCartBlue",
"Vehicle-SilvershardMines-MineCartRed",
"Vehicle-TempleofKotmogu-CyanBall",
"Vehicle-TempleofKotmogu-GreenBall",
"Vehicle-TempleofKotmogu-OrangeBall",
"Vehicle-TempleofKotmogu-PurpleBall",
"Vehicle-Trap-Gold",
"Vehicle-Trap-Grey",
"Vehicle-Trap-Red",
"VignetteEvent",
"VignetteEventElite",
"VignetteKill",
"VignetteKillElite",
"VignetteLoot",
"VignetteLootElite",
"Warlock-Bar-EmptyShards",
"Warlock-EmptyShard",
"Warlock-FillShard",
"Warlock-ReadyShard",
"Warlock-ReadyShard-Glow",
"Warlock-Shard-Spark",
"WarlockPortalAlliance",
"WarlockPortalHorde",
"WhiteCircle-RaidBlips",
"WhiteDotCircle-RaidBlips",
"WildBattlePet",
"WildBattlePet-Tracker",
"WildBattlePetCapturable",
"WoWShare-AchievementIcon",
"WoWShare-AddButton-Down",
"WoWShare-AddButton-Up",
"WoWShare-ChatIcon",
"WoWShare-EdgeArt",
"WoWShare-Highlight",
"WoWShare-ItemIcon",
"WoWShare-ItemQualityBorder",
"WoWShare-Plus",
"WoWShare-ScreenshotIcon",
"WoWShare-Selection",
"WoWShare-TwitterLogo",
"XMarksTheSpot",
"XPBarAnim-GlowLines",
"XPBarAnim-OrangeGain",
"XPBarAnim-OrangeGlow",
"XPBarAnim-OrangeSpark",
"XPBarAnim-OrangeTrail",
"ZoneAbility-Generic-AbilityBar",
"ZoneAbility-Generic-AbilityBar-Glow",
"ZoneAbility-Generic-IconBorder",
"ZoneAbility-Generic-SpellBox",
"_128-RedButton-Center",
"_128-RedButton-Center-Disabled",
"_128-RedButton-Center-Pressed",
"_Armor-Fill-mid",
"_Bar-mid",
"_BattleBar-ButtonBGMid",
"_BattleBar-Mid",
"_BattleSlotFrame-Divider",
"_BattleSlotFrame-Top",
"_BattleSlotTitle-BG",
"_BattleSlotTitle-Mid",
"_Cast-Bar-Fill-mid",
"_Cast-Bar-mid",
"_CharacterCreateDropdown-NineSlice-EdgeBottom",
"_CharacterCreateDropdown-NineSlice-EdgeTop",
"_ChatBubble-NineSlice-EdgeBottom",
"_ChatBubble-NineSlice-EdgeTop",
"_ClassHall_InfoBoxMission-Top",
"_ClassHall_ParchmentHeader-Mid",
"_ClassHall_ParchmentHeaderSelect-Mid",
"_DemonHunter-DemonicFuryBar",
"_DemonHunter-DemonicPainBar",
"_Druid-LunarBar",
"_ForgeBorder-Top",
"_GarrMissionLocation-Argus-Mid",
"_GarrMissionLocation-Azsuna-Mid",
"_GarrMissionLocation-BlackrockMountain-Back",
"_GarrMissionLocation-BlackrockMountain-Fore",
"_GarrMissionLocation-BlackrockMountain-List",
"_GarrMissionLocation-BlackrockMountain-Mid",
"_GarrMissionLocation-Dalaran-Mid",
"_GarrMissionLocation-FrostfireRidge-Back",
"_GarrMissionLocation-FrostfireRidge-Fore",
"_GarrMissionLocation-FrostfireRidge-Mid",
"_GarrMissionLocation-FrostfireSea-Back",
"_GarrMissionLocation-FrostfireSea-Fore",
"_GarrMissionLocation-FrostfireSea-Mid",
"_GarrMissionLocation-Gorgrond-Back",
"_GarrMissionLocation-Gorgrond-Fore",
"_GarrMissionLocation-Gorgrond-Mid",
"_GarrMissionLocation-Highmountain-Mid",
"_GarrMissionLocation-Legion-Mid",
"_GarrMissionLocation-Nagrand-Back",
"_GarrMissionLocation-Nagrand-Fore",
"_GarrMissionLocation-Nagrand-Mid",
"_GarrMissionLocation-NagrandSea-Back",
"_GarrMissionLocation-NagrandSea-Fore",
"_GarrMissionLocation-NagrandSea-Mid",
"_GarrMissionLocation-ShadowmoonSea-Back",
"_GarrMissionLocation-ShadowmoonSea-Fore",
"_GarrMissionLocation-ShadowmoonSea-Mid",
"_GarrMissionLocation-ShadowmoonValley-Back",
"_GarrMissionLocation-ShadowmoonValley-Fore",
"_GarrMissionLocation-ShadowmoonValley-Mid",
"_GarrMissionLocation-SpiresofArak-Back",
"_GarrMissionLocation-SpiresofArak-Fore",
"_GarrMissionLocation-SpiresofArak-Mid",
"_GarrMissionLocation-Stormheim-Mid",
"_GarrMissionLocation-Suramar-Mid",
"_GarrMissionLocation-Talador-Back",
"_GarrMissionLocation-Talador-Fore",
"_GarrMissionLocation-Talador-Mid",
"_GarrMissionLocation-TannanJungle-Back",
"_GarrMissionLocation-TannanJungle-Fore",
"_GarrMissionLocation-TannanJungle-Mid",
"_GarrMissionLocation-TannanSea-Back",
"_GarrMissionLocation-TannanSea-Fore",
"_GarrMissionLocation-TannanSea-Mid",
"_GarrMissionLocation-TownAlliance-Back",
"_GarrMissionLocation-TownAlliance-Fore",
"_GarrMissionLocation-TownAlliance-Mid",
"_GarrMissionLocation-TownHorde-Back",
"_GarrMissionLocation-TownHorde-Fore",
"_GarrMissionLocation-TownHorde-Mid",
"_GarrMissionLocation-Underground-Back",
"_GarrMissionLocation-Underground-Fore",
"_GarrMissionLocation-Underground-Mid",
"_GarrMissionLocation-Valsharah-Mid",
"_GarrMission_Bg-BottomEdge",
"_GarrMission_Bg-BottomEdgeSmall",
"_GarrMission_LocationCover-Bottom",
"_GarrMission_MissionListTopHighlight",
"_GarrMission_ParchmentHeader-Mid",
"_GarrMission_ParchmentHeaderSelect-Mid",
"_GarrMission_RewardsBorder-Top",
"_GarrMission_RewardsBorder-Top-Desaturate",
"_GarrMission_TopBorder",
"_GarrMission_TopBorder-Highlight",
"_GarrMission_TopBorder-Select",
"_GarrMission_XPBar-BG",
"_GarrMission_XPBar-Fill",
"_Garr_InfoBox-Top",
"_Garr_InfoBoxBorder-BigBottom",
"_Garr_InfoBoxBorder-Top",
"_Garr_InfoBoxBorderMission-Top",
"_Garr_InfoBoxMission-Top",
"_Garr_WoodFrameTile-Bottom",
"_Garr_WoodFrameTile-Top",
"_Garr_XPBar_Mid",
"_GeneralFrame-HorizontalBar",
"_GeneralFrame-InsetFrame-Bottom",
"_GeneralFrame-InsetFrame-Top",
"_Health-Bar-mid",
"_Health_mid",
"_Legionfall_BarFill_Active",
"_Legionfall_BarFill_UnderAttack",
"_Legionfall_BarFill_UnderConstruction",
"_Minimal_SliderBar_Middle",
"_Neutral-NineSlice-EdgeBottom",
"_Neutral-NineSlice-EdgeTop",
"_Options_ListExpand_Middle",
"_Priest-InsanityBar",
"_Score-Team-mid",
"_Shaman-MaelstromBar",
"_ShipMission_Bg-BottomEdge",
"_ShipMission_Bg-BottomEdgeSmall",
"_ShipMission_LocationCover-Bottom",
"_ShipMission_RewardsBorder-Top-Desaturate",
"_ShipMission_TopBorder",
"_SliderBar-NineSlice-EdgeBottom",
"_SliderBar-NineSlice-EdgeTop",
"_StoneFrameTile-Bottom",
"_StoneFrameTile-Top",
"_Talent-Bottom-Tile",
"_Talent-Top-Tile",
"_Talent-blue-glow",
"_Talent-green-glow",
"_Tooltip-Glues-NineSlice-EdgeBottom",
"_Tooltip-Glues-NineSlice-EdgeTop",
"_Tooltip-NineSlice-EdgeBottom",
"_Tooltip-NineSlice-EdgeTop",
"_UI-Frame-Bot",
"_UI-Frame-BtnBotTile",
"_UI-Frame-DiamondMetal-EdgeBottom",
"_UI-Frame-DiamondMetal-EdgeTop",
"_UI-Frame-DiamondMetal-Header-Tile",
"_UI-Frame-InnerBotTile",
"_UI-Frame-InnerTopTile",
"_UI-Frame-Neutral-TitleMiddle",
"_UI-Frame-TitleTile",
"_UI-Frame-TitleTileBg",
"_UI-Frame-TopTileStreaks",
"_UI-Taxi-Line-horizontal",
"_collections-background-line",
"_creditsscreen-gradient-tile",
"_gmchat-nineslice-edgebottom",
"_gmchat-nineslice-edgetop",
"_gmglow-nineslice-edgebottom",
"_gmglow-nineslice-edgetop",
"_honorsystem-bar-fill",
"_honorsystem-bar-fill-rested",
"_macropopup-bottom",
"_macropopup-top",
"_macropopup-top2",
"_minortalents-iconspinner",
"_optionsframe-nineslice-edgebottom",
"_optionsframe-nineslice-edgetop",
"_orderhall-commandbar-bg",
"_pvpqueue-conquestbar-fill-blue",
"_pvpqueue-conquestbar-fill-disabled",
"_pvpqueue-conquestbar-fill-red",
"_pvpqueue-conquestbar-fill-yellow",
"_search-rowbg",
"_transmog-preview-QuestPortrait-Divider_noname",
"_transmog-preview-QuestPortrait-StoneSwirls-Top",
"_ui-scrollbar-center",
"_uiframe-activetab-center",
"_uiframe-tab-center",
"_warboard-title-alliance-middle",
"_warboard-title-horde-middle",
"_warboard-title-neutral-middle",
"accountupgradebanner-bc",
"accountupgradebanner-bfa",
"accountupgradebanner-cataclysm",
"accountupgradebanner-classic",
"accountupgradebanner-legion",
"accountupgradebanner-mop",
"accountupgradebanner-wod",
"accountupgradebanner-wotlk",
"achievementcompare-GreenCheckmark",
"achievementcompare-YellowCheckmark",
"adventureguide-icon-whatsnew",
"adventureguide-microbutton-alert",
"adventureguide-pane-large",
"adventureguide-pane-small",
"adventureguide-redx",
"adventureguide-rewardring",
"adventureguide-ring",
"alliance_icon_and_flag-dynamicIcon",
"alliance_icon_and_flag-flash",
"alliance_icon_and_flag-icon",
"alliance_icon_horde_flag-dynamicIcon",
"alliance_icon_horde_flag-flash",
"alliance_icon_horde_flag-icon",
"alliance_tower-icon",
"auctionhouse-background-auctions",
"auctionhouse-background-buy-commodities",
"auctionhouse-background-buy-commodities-market",
"auctionhouse-background-buy-noncommodities-header",
"auctionhouse-background-buy-noncommodities-market",
"auctionhouse-background-categories",
"auctionhouse-background-index",
"auctionhouse-background-sell-left",
"auctionhouse-background-sell-right",
"auctionhouse-background-summarylist",
"auctionhouse-icon-checkmark",
"auctionhouse-icon-clock",
"auctionhouse-icon-coin-copper",
"auctionhouse-icon-coin-gold",
"auctionhouse-icon-coin-silver",
"auctionhouse-icon-favorite",
"auctionhouse-icon-favorite-off",
"auctionhouse-icon-socket",
"auctionhouse-itemheaderframe",
"auctionhouse-itemicon-border-account",
"auctionhouse-itemicon-border-artifact",
"auctionhouse-itemicon-border-blue",
"auctionhouse-itemicon-border-gray",
"auctionhouse-itemicon-border-green",
"auctionhouse-itemicon-border-orange",
"auctionhouse-itemicon-border-purple",
"auctionhouse-itemicon-border-white",
"auctionhouse-itemicon-cover",
"auctionhouse-itemicon-empty",
"auctionhouse-itemicon-small-border",
"auctionhouse-nav-button",
"auctionhouse-nav-button-highlight",
"auctionhouse-nav-button-secondary",
"auctionhouse-nav-button-secondary-highlight",
"auctionhouse-nav-button-secondary-select",
"auctionhouse-nav-button-select",
"auctionhouse-nav-button-tertiary-filterline",
"auctionhouse-rowstripe-1",
"auctionhouse-rowstripe-2",
"auctionhouse-selltab-left",
"auctionhouse-selltab-middle",
"auctionhouse-selltab-right",
"auctionhouse-ui-dropdown-arrow-disabled",
"auctionhouse-ui-dropdown-arrow-down",
"auctionhouse-ui-dropdown-arrow-up",
"auctionhouse-ui-dropdown-left",
"auctionhouse-ui-dropdown-middle",
"auctionhouse-ui-dropdown-right",
"auctionhouse-ui-filter-redx",
"auctionhouse-ui-inputfield-left",
"auctionhouse-ui-inputfield-middle",
"auctionhouse-ui-inputfield-right",
"auctionhouse-ui-loadingspinner",
"auctionhouse-ui-row-highlight",
"auctionhouse-ui-row-select",
"auctionhouse-ui-sortarrow",
"bag-arrow",
"bag-border",
"bag-border-empty",
"bag-border-highlight",
"bag-border-search",
"bag-main",
"bag-main-highlight",
"bag-main-search",
"bag-reagent-border",
"bag-reagent-border-empty",
"bags-button-autosort-down",
"bags-button-autosort-up",
"bags-glow-artifact",
"bags-glow-blue",
"bags-glow-flash",
"bags-glow-green",
"bags-glow-heirloom",
"bags-glow-orange",
"bags-glow-purple",
"bags-glow-white",
"bags-greenarrow",
"bags-icon-addslots",
"bags-icon-consumables",
"bags-icon-equipment",
"bags-icon-tradegoods",
"bags-innerglow",
"bags-junkcoin",
"bags-newitem",
"bags-roundhighlight",
"bags-static",
"bank-slots",
"bank-slots-shadow",
"barbershop-background",
"battlefieldminimap-border-bottom",
"battlefieldminimap-border-bottomleft",
"battlefieldminimap-border-bottomright",
"battlefieldminimap-border-left",
"battlefieldminimap-border-right",
"battlefieldminimap-border-top",
"battlefieldminimap-border-topleft",
"battlefieldminimap-border-topright",
"battlenet-clienticon-pro-zhCN",
"bluemenu-Ring",
"bonusobjectives-bar-bg",
"bonusobjectives-bar-fill",
"bonusobjectives-bar-frame",
"bonusobjectives-bar-glow",
"bonusobjectives-bar-glow-ring",
"bonusobjectives-bar-ring",
"bonusobjectives-bar-sheen",
"bonusobjectives-bar-spark",
"bonusobjectives-bar-starburst",
"bonusobjectives-title-bg",
"bonusobjectives-title-icon",
"bonusobjectives-title-icon-honor",
"book-bg",
"book-line",
"boostpopup-wod-bottom",
"boostpopup-wod-middle",
"boostpopup-wod-top",
"category-icon-ring",
"challenges-bannershine",
"challenges-blackfade",
"challenges-nomedal",
"challenges-timerbg",
"challenges-timerborder",
"challenges-toast",
"charactercreate-banner-bottom",
"charactercreate-banner-middle",
"charactercreate-banner-top",
"charactercreate-customize-backbutton",
"charactercreate-customize-backbutton-disabled",
"charactercreate-customize-backbutton-down",
"charactercreate-customize-button-redglow",
"charactercreate-customize-dropdown-icon-lock",
"charactercreate-customize-dropdown-linemouseover-middle",
"charactercreate-customize-dropdown-linemouseover-side",
"charactercreate-customize-dropdown-newtagglow",
"charactercreate-customize-dropdownbox",
"charactercreate-customize-dropdownbox-hover",
"charactercreate-customize-dropdownbox-open",
"charactercreate-customize-nextbutton",
"charactercreate-customize-nextbutton-disabled",
"charactercreate-customize-nextbutton-down",
"charactercreate-customize-palette",
"charactercreate-customize-palette-glow",
"charactercreate-customize-palette-half",
"charactercreate-customize-palette-selected",
"charactercreate-customize-playbutton",
"charactercreate-customize-playbutton-down",
"charactercreate-customize-speakeroffbutton",
"charactercreate-customize-speakeroffbutton-down",
"charactercreate-customize-speakeronbutton",
"charactercreate-customize-speakeronbutton-down",
"charactercreate-gendericon-female",
"charactercreate-gendericon-female-selected",
"charactercreate-gendericon-male",
"charactercreate-gendericon-male-selected",
"charactercreate-icon-alliance",
"charactercreate-icon-customize-accessories",
"charactercreate-icon-customize-accessories-selected",
"charactercreate-icon-customize-body",
"charactercreate-icon-customize-body-selected",
"charactercreate-icon-customize-hair",
"charactercreate-icon-customize-hair-selected",
"charactercreate-icon-customize-head",
"charactercreate-icon-customize-head-selected",
"charactercreate-icon-customize-mirror",
"charactercreate-icon-customize-mirror-selected",
"charactercreate-icon-customize-speechbubble",
"charactercreate-icon-customize-speechbubble-selected",
"charactercreate-icon-customize-torso",
"charactercreate-icon-customize-torso-selected",
"charactercreate-icon-dice",
"charactercreate-icon-horde",
"charactercreate-icon-requiredarrow",
"charactercreate-ring-alliance",
"charactercreate-ring-alliance-disabled",
"charactercreate-ring-customizebackground",
"charactercreate-ring-horde",
"charactercreate-ring-horde-disabled",
"charactercreate-ring-metaldark",
"charactercreate-ring-metaldark-disabled",
"charactercreate-ring-metallight",
"charactercreate-ring-racialtrait",
"charactercreate-ring-select",
"charactercreate-tooltip-background",
"charactercreate-tooltip-corner",
"charactercreate-tooltip-side",
"charactercreate-tooltip-top",
"charactercreate-vignette-bottom",
"charactercreate-vignette-sides",
"charactercreate-vignette-sides-widescreen",
"charactercreate-vignette-top",
"characterundelete-RestoreButton",
"chatframe-button-down",
"chatframe-button-highlight",
"chatframe-button-highlightalert",
"chatframe-button-icon-TTS",
"chatframe-button-icon-headset",
"chatframe-button-icon-mic-off",
"chatframe-button-icon-mic-on",
"chatframe-button-icon-mic-silenced",
"chatframe-button-icon-mic-silenced-off",
"chatframe-button-icon-speaker-off",
"chatframe-button-icon-speaker-on",
"chatframe-button-icon-speaker-silenced",
"chatframe-button-icon-voicechat",
"chatframe-button-up",
"chatframe-scrollbar-knob",
"checkbox-minimal",
"checkmark-minimal",
"checkmark-minimal-disabled",
"classic-burningcrusadetransition-choice-frame",
"classic-burningcrusadetransition-choice-line-current",
"classic-burningcrusadetransition-choice-line-other",
"classic-burningcrusadetransition-choice-logo-current",
"classic-burningcrusadetransition-choice-logo-current-zhCN",
"classic-burningcrusadetransition-choice-logo-current-zhTW",
"classic-burningcrusadetransition-choice-logo-other",
"classic-burningcrusadetransition-choice-logo-other-zhCN",
"classic-burningcrusadetransition-choice-logo-other-zhTW",
"classicon-deathknight",
"classicon-druid",
"classicon-hunter",
"classicon-mage",
"classicon-paladin",
"classicon-priest",
"classicon-rogue",
"classicon-shaman",
"classicon-warlock",
"classicon-warrior",
"coin-icon",
"collections-background-corner",
"collections-background-filagree",
"collections-background-shadow-large",
"collections-background-shadow-small",
"collections-background-tile",
"collections-icon-favorites",
"collections-itemborder-collected",
"collections-itemborder-uncollected",
"collections-itemborder-uncollected-innerglow",
"collections-levelplate-black",
"collections-levelplate-gold",
"collections-newglow",
"collections-slotheader",
"collections-upgradeglow",
"collections-upgradeglow-blue",
"collections-watermark-heirloom",
"collections-watermark-toy",
"colorblind-bar-green",
"colorblind-bar-red",
"colorblind-bar-yellow",
"colorblind-colorwheel",
"combat_swords-dynamicIcon",
"combat_swords-flash",
"combat_swords-icon",
"common-button-square-gray-down",
"common-button-square-gray-up",
"common-dropdown-a-button",
"common-dropdown-a-button-disabled",
"common-dropdown-a-button-hover",
"common-dropdown-a-button-open",
"common-dropdown-a-button-pressed",
"common-dropdown-a-button-pressedhover",
"common-dropdown-b-button",
"common-dropdown-b-button-disabled",
"common-dropdown-b-button-hover",
"common-dropdown-b-button-open",
"common-dropdown-b-button-pressed",
"common-dropdown-b-button-pressedhover",
"common-dropdown-bg",
"common-dropdown-c-bg",
"common-dropdown-c-button",
"common-dropdown-c-button-disabled",
"common-dropdown-c-button-hover-1",
"common-dropdown-c-button-hover-2",
"common-dropdown-c-button-hover-arrow",
"common-dropdown-c-button-open",
"common-dropdown-c-button-pressed-1",
"common-dropdown-c-button-pressed-2",
"common-dropdown-c-button-pressedhover-1",
"common-dropdown-c-button-pressedhover-2",
"common-dropdown-classic-a-buttonDown",
"common-dropdown-classic-a-buttonDown-disabled",
"common-dropdown-classic-a-buttonDown-disabled-small",
"common-dropdown-classic-a-buttonDown-hover",
"common-dropdown-classic-a-buttonDown-hover-small",
"common-dropdown-classic-a-buttonDown-pressed",
"common-dropdown-classic-a-buttonDown-pressed-small",
"common-dropdown-classic-a-buttonDown-pressedhover",
"common-dropdown-classic-a-buttonDown-pressedhover-small",
"common-dropdown-classic-a-buttonDown-small",
"common-dropdown-classic-a-buttonUp",
"common-dropdown-classic-a-buttonUp-disabled",
"common-dropdown-classic-a-buttonUp-disabled-small",
"common-dropdown-classic-a-buttonUp-hover",
"common-dropdown-classic-a-buttonUp-hover-small",
"common-dropdown-classic-a-buttonUp-pressed",
"common-dropdown-classic-a-buttonUp-pressed-small",
"common-dropdown-classic-a-buttonUp-pressedhover",
"common-dropdown-classic-a-buttonUp-pressedhover-small",
"common-dropdown-classic-a-buttonUp-small",
"common-dropdown-classic-b-bg",
"common-dropdown-classic-b-button",
"common-dropdown-classic-b-button-disabled",
"common-dropdown-classic-b-button-hover",
"common-dropdown-classic-b-button-pressed",
"common-dropdown-classic-b-button-pressedhover",
"common-dropdown-classic-bg",
"common-dropdown-classic-bg-b",
"common-dropdown-classic-darkBG",
"common-dropdown-classic-textholder",
"common-dropdown-classic-textholder-small",
"common-dropdown-customize-mouseover",
"common-dropdown-icon-back",
"common-dropdown-icon-back-disabled",
"common-dropdown-icon-checkmark-yellow",
"common-dropdown-icon-checkmark-yellow-classic",
"common-dropdown-icon-checkmark-yellow-classic-2",
"common-dropdown-icon-next",
"common-dropdown-icon-next-disabled",
"common-dropdown-icon-play",
"common-dropdown-icon-radialtick-yellow",
"common-dropdown-icon-radialtick-yellow-classic",
"common-dropdown-icon-sound-off",
"common-dropdown-icon-sound-on",
"common-dropdown-icon-stop",
"common-dropdown-textholder",
"common-dropdown-tickradial",
"common-dropdown-tickradial-classic",
"common-dropdown-ticksquare",
"common-dropdown-ticksquare-classic",
"common-gray-button-entrybox-center",
"common-gray-button-entrybox-left",
"common-gray-button-entrybox-right",
"common-icon-backarrow",
"common-icon-backarrow-disable",
"common-icon-checkmark",
"common-icon-checkmark-yellow",
"common-icon-forwardarrow",
"common-icon-forwardarrow-disable",
"common-icon-redx",
"common-icon-rotateleft",
"common-icon-rotateright",
"common-icon-undo",
"common-icon-zoomin",
"common-icon-zoomin-disable",
"common-icon-zoomout",
"common-icon-zoomout-disable",
"common-search-border-left",
"common-search-border-middle",
"common-search-border-right",
"common-search-clearbutton",
"common-search-magnifyingglass",
"communities-chat-date-line",
"communities-chat-date-line-orange",
"communities-create-avatar-border-hover",
"communities-create-avatar-border-selected",
"communities-create-button-bnet-down",
"communities-create-button-bnet-highlight",
"communities-create-button-bnet-up",
"communities-create-button-highlight",
"communities-create-button-wow-alliance",
"communities-create-button-wow-down",
"communities-create-button-wow-horde",
"communities-create-button-wow-up",
"communities-guildbanner-background",
"communities-guildbanner-border",
"communities-icon-addchannelplus",
"communities-icon-addgroupplus",
"communities-icon-chat",
"communities-icon-invitemail",
"communities-icon-lock",
"communities-icon-notification",
"communities-icon-redx",
"communities-nav-button-green-normal",
"communities-nav-button-green-pressed",
"communities-ring-blue",
"communities-ring-gold",
"communities-widebackground",
"communitiesfinder-card",
"communitiesfinder_card_highlight",
"countdown-swords",
"countdown-swords-glow",
"creditsscreen-highlight",
"creditsscreen-selected",
"deathrecap-background-innerglow",
"deathrecap-icon-tombstone",
"deathrecap-iconborder",
"dreadlord-icon",
"dressingroom-background-deathknight",
"dressingroom-background-demonhunter",
"dressingroom-background-druid",
"dressingroom-background-hunter",
"dressingroom-background-mage",
"dressingroom-background-monk",
"dressingroom-background-paladin",
"dressingroom-background-priest",
"dressingroom-background-rogue",
"dressingroom-background-shaman",
"dressingroom-background-warlock",
"dressingroom-background-warrior",
"equipmentmanager-spec-border",
"friendship-parts-background",
"friendship-parts-bar",
"friendship-parts-circle",
"friendship-parts-divider",
"friendslist-categorybutton",
"friendslist-categorybutton-arrow-down",
"friendslist-categorybutton-arrow-right",
"friendslist-invitebutton-alliance-disabled",
"friendslist-invitebutton-alliance-normal",
"friendslist-invitebutton-alliance-pressed",
"friendslist-invitebutton-default-disabled",
"friendslist-invitebutton-default-normal",
"friendslist-invitebutton-default-pressed",
"friendslist-invitebutton-highlight",
"friendslist-invitebutton-horde-disabled",
"friendslist-invitebutton-horde-normal",
"friendslist-invitebutton-horde-pressed",
"generic-frame-chamfered-12d-2o",
"glueannouncementpopup-arrow",
"glueannouncementpopup-background",
"glueannouncementpopup-icon-info",
"glueannouncementpopup-inset",
"glues-characterSelect-TopHUD-BG",
"glues-characterSelect-TopHUD-BG-divider",
"glues-characterSelect-TopHUD-BG-divider-dis",
"glues-characterSelect-TopHUD-left-BG",
"glues-characterSelect-TopHUD-left-dis-BG",
"glues-characterSelect-TopHUD-middle-BG",
"glues-characterSelect-TopHUD-middle-dis-BG",
"glues-characterSelect-TopHUD-right-BG",
"glues-characterSelect-TopHUD-right-dis-BG",
"glues-characterSelect-TopHUD-selected-left",
"glues-characterSelect-TopHUD-selected-line-left",
"glues-characterSelect-TopHUD-selected-line-middle",
"glues-characterSelect-TopHUD-selected-line-right",
"glues-characterSelect-TopHUD-selected-middle",
"glues-characterSelect-TopHUD-selected-right",
"glues-characterSelect-button-card",
"glues-characterSelect-button-card-down-disabled",
"glues-characterSelect-button-card-down-disabled-hover",
"glues-characterSelect-button-card-hover",
"glues-characterSelect-button-card-pressed",
"glues-characterSelect-button-card-up-disabled",
"glues-characterSelect-button-card-up-disabled-hover",
"glues-characterSelect-button-collapseExpand",
"glues-characterSelect-button-collapseExpand-disabled",
"glues-characterSelect-button-collapseExpand-down-small-disabled",
"glues-characterSelect-button-collapseExpand-hover",
"glues-characterSelect-button-collapseExpand-pressed",
"glues-characterSelect-button-collapseExpand-small",
"glues-characterSelect-button-collapseExpand-small-hover",
"glues-characterSelect-button-collapseExpand-small-pressed",
"glues-characterSelect-button-collapseExpand-up-small-disabled",
"glues-characterSelect-card-FX-spreadA",
"glues-characterSelect-card-FX-spreadB",
"glues-characterSelect-card-all-BG",
"glues-characterSelect-card-camp",
"glues-characterSelect-card-camp-BG",
"glues-characterSelect-card-camp-BG-glow",
"glues-characterSelect-card-camp-hover",
"glues-characterSelect-card-drag",
"glues-characterSelect-card-empty",
"glues-characterSelect-card-empty-hover",
"glues-characterSelect-card-glow",
"glues-characterSelect-card-glow-FX",
"glues-characterSelect-card-glow-swap",
"glues-characterSelect-card-selected",
"glues-characterSelect-card-selected-hover",
"glues-characterSelect-card-singles",
"glues-characterSelect-card-singles-hover",
"glues-characterSelect-cardDivider",
"glues-characterSelect-divider",
"glues-characterSelect-icon-FX-plus",
"glues-characterSelect-icon-addCard",
"glues-characterSelect-icon-addCard-glow",
"glues-characterSelect-icon-appearanceChange",
"glues-characterSelect-icon-appearanceChange-hover",
"glues-characterSelect-icon-arrowDown",
"glues-characterSelect-icon-arrowDown-disabled",
"glues-characterSelect-icon-arrowDown-hover",
"glues-characterSelect-icon-arrowDown-pressed",
"glues-characterSelect-icon-arrowDown-pressed-hover",
"glues-characterSelect-icon-arrowDown-small",
"glues-characterSelect-icon-arrowDown-small-hover",
"glues-characterSelect-icon-arrowDown-small-pressed",
"glues-characterSelect-icon-arrowUp",
"glues-characterSelect-icon-arrowUp-hover",
"glues-characterSelect-icon-arrowUp-pressed",
"glues-characterSelect-icon-arrowUp-pressed-hover",
"glues-characterSelect-icon-arrowUp-small",
"glues-characterSelect-icon-arrowUp-small-hover",
"glues-characterSelect-icon-arrowUp-small-pressed",
"glues-characterSelect-icon-faction-alliance",
"glues-characterSelect-icon-faction-alliance-hover",
"glues-characterSelect-icon-faction-alliance-selected",
"glues-characterSelect-icon-faction-horde",
"glues-characterSelect-icon-faction-horde-hover",
"glues-characterSelect-icon-faction-horde-selected",
"glues-characterSelect-icon-factionChange",
"glues-characterSelect-icon-factionChange-hover",
"glues-characterSelect-icon-minus",
"glues-characterSelect-icon-minus-disabled",
"glues-characterSelect-icon-minus-hover",
"glues-characterSelect-icon-minus-pressed",
"glues-characterSelect-icon-notify-BG",
"glues-characterSelect-icon-notify-BG-hover",
"glues-characterSelect-icon-notify-inProgress",
"glues-characterSelect-icon-notify-inProgress-hover",
"glues-characterSelect-icon-notify-lock",
"glues-characterSelect-icon-notify-lock-hover",
"glues-characterSelect-icon-notify-mail",
"glues-characterSelect-icon-notify-mail-hover",
"glues-characterSelect-icon-plus",
"glues-characterSelect-icon-plus-disabled",
"glues-characterSelect-icon-plus-hover",
"glues-characterSelect-icon-plus-pressed",
"glues-characterSelect-icon-raceChange",
"glues-characterSelect-icon-raceChange-hover",
"glues-characterSelect-icon-restoreCharacter",
"glues-characterSelect-icon-restoreCharacter-hover",
"glues-characterSelect-icon-restoreCharacter-pointer",
"glues-characterSelect-icon-search",
"glues-characterSelect-iconShop",
"glues-characterSelect-iconShop-dis",
"glues-characterSelect-iconShop-hover",
"glues-characterSelect-listLauncher-BG",
"glues-characterSelect-listRealm-BG",
"glues-characterSelect-nameBG",
"glues-characterSelect-scroll-arrow-down",
"glues-characterSelect-scroll-arrow-up",
"glues-characterSelect-scrollbar",
"glues-characterSelect-scrollbar-BG",
"glues-characterSelect-searchbar",
"glues-gameMode-BG",
"glues-gameMode-glw-bottom",
"glues-gameMode-glw-top",
"glues-gameMode-selectArrow",
"glues-gameMode-txtBG",
"gmchat-icon-alert",
"gmchat-icon-blizz",
"gmchat-icon-wow",
"gmchat-nineslice-cornerbottomleft",
"gmchat-nineslice-cornerbottomright",
"gmchat-nineslice-cornertopleft",
"gmchat-nineslice-cornertopright",
"gmchat-watermark-blizzard",
"gmglow-nineslice-cornerbottomleft",
"gmglow-nineslice-cornerbottomright",
"gmglow-nineslice-cornertopleft",
"gmglow-nineslice-cornertopright",
"groupfinder-background",
"groupfinder-background-arenas",
"groupfinder-background-ashran",
"groupfinder-background-battlegrounds",
"groupfinder-background-classic",
"groupfinder-background-custom-pve",
"groupfinder-background-custom-pvp",
"groupfinder-background-dungeons",
"groupfinder-background-islands",
"groupfinder-background-questing",
"groupfinder-background-raids-battleforazeroth",
"groupfinder-background-raids-bc",
"groupfinder-background-raids-cataclysm",
"groupfinder-background-raids-classic",
"groupfinder-background-raids-dragonflight",
"groupfinder-background-raids-legion",
"groupfinder-background-raids-mists",
"groupfinder-background-raids-shadowlands",
"groupfinder-background-raids-warlords",
"groupfinder-background-raids-wrath",
"groupfinder-background-ratedbgs",
"groupfinder-background-scenarios",
"groupfinder-background-skirmishes",
"groupfinder-background-torghast",
"groupfinder-button-arenas",
"groupfinder-button-ashran",
"groupfinder-button-battlegrounds",
"groupfinder-button-cover",
"groupfinder-button-cover-down",
"groupfinder-button-custom-pve",
"groupfinder-button-custom-pvp",
"groupfinder-button-dungeons",
"groupfinder-button-highlight",
"groupfinder-button-islands",
"groupfinder-button-questing",
"groupfinder-button-raids-battleforazeroth",
"groupfinder-button-raids-bc",
"groupfinder-button-raids-cataclysm",
"groupfinder-button-raids-classic",
"groupfinder-button-raids-dragonflight",
"groupfinder-button-raids-legion",
"groupfinder-button-raids-mists",
"groupfinder-button-raids-shadowlands",
"groupfinder-button-raids-warlords",
"groupfinder-button-raids-wrath",
"groupfinder-button-ratedbgs",
"groupfinder-button-scenarios",
"groupfinder-button-select",
"groupfinder-button-skirmishes",
"groupfinder-button-torghast",
"groupfinder-eye-backglow",
"groupfinder-eye-circshine",
"groupfinder-eye-flipbook-found-initial",
"groupfinder-eye-flipbook-found-loop",
"groupfinder-eye-flipbook-foundfx",
"groupfinder-eye-flipbook-initial",
"groupfinder-eye-flipbook-mouseover",
"groupfinder-eye-flipbook-poke-end",
"groupfinder-eye-flipbook-poke-initial",
"groupfinder-eye-flipbook-poke-loop",
"groupfinder-eye-flipbook-searching",
"groupfinder-eye-frame",
"groupfinder-eye-frontglow",
"groupfinder-eye-highlight",
"groupfinder-eye-single",
"groupfinder-highlightbar-blue",
"groupfinder-highlightbar-green",
"groupfinder-highlightbar-yellow",
"groupfinder-icon-class-deathknight",
"groupfinder-icon-class-demonhunter",
"groupfinder-icon-class-druid",
"groupfinder-icon-class-hunter",
"groupfinder-icon-class-mage",
"groupfinder-icon-class-monk",
"groupfinder-icon-class-paladin",
"groupfinder-icon-class-priest",
"groupfinder-icon-class-rogue",
"groupfinder-icon-class-shaman",
"groupfinder-icon-class-warlock",
"groupfinder-icon-class-warrior",
"groupfinder-icon-emptyslot",
"groupfinder-icon-friend",
"groupfinder-icon-greencheckmark",
"groupfinder-icon-leader",
"groupfinder-icon-lock",
"groupfinder-icon-quest",
"groupfinder-icon-redx",
"groupfinder-icon-role-large-dps",
"groupfinder-icon-role-large-heal",
"groupfinder-icon-role-large-tank",
"groupfinder-icon-voice",
"groupfinder-waitdot",
"guild-levelring",
"guildfinder-card",
"guildfinder-card-guildbanner-background",
"guildfinder-card-guildbanner-border",
"guildfinder-card-guildbanner-shadow",
"honorsystem-bar-background",
"honorsystem-bar-frame",
"honorsystem-bar-frame-exhaustiontick",
"honorsystem-bar-frame-exhaustiontick-highlight",
"honorsystem-bar-frame-small",
"honorsystem-bar-lock",
"honorsystem-bar-rewardborder",
"honorsystem-bar-rewardborder-circle",
"honorsystem-bar-rewardborder-prestige",
"honorsystem-bar-rewardborder-prestige-flash",
"honorsystem-bar-spark",
"honorsystem-icon-bonus",
"honorsystem-icon-enlistmentbonus",
"honorsystem-icon-prestige-1",
"honorsystem-icon-prestige-10",
"honorsystem-icon-prestige-11",
"honorsystem-icon-prestige-2",
"honorsystem-icon-prestige-3",
"honorsystem-icon-prestige-4",
"honorsystem-icon-prestige-5",
"honorsystem-icon-prestige-6",
"honorsystem-icon-prestige-7",
"honorsystem-icon-prestige-8",
"honorsystem-icon-prestige-9",
"honorsystem-portrait-alliance",
"honorsystem-portrait-horde",
"honorsystem-portrait-neutral",
"honorsystem-prestige-laurel",
"honorsystem-prestige-laurel-bg-alliance",
"honorsystem-prestige-laurel-bg-horde",
"honorsystem-prestige-rewardline",
"honorsystem-prestige-smallwreath",
"honorsystem-talents-bg",
"horde_icon_alliance_flag-dynamicIcon",
"horde_icon_alliance_flag-flash",
"horde_icon_alliance_flag-icon",
"horde_icon_and_flag-dynamicIcon",
"horde_icon_and_flag-flash",
"horde_icon_and_flag-icon",
"horde_tower-icon",
"hud-MainMenuBar-arrowdown-disabled",
"hud-MainMenuBar-arrowdown-down",
"hud-MainMenuBar-arrowdown-highlight",
"hud-MainMenuBar-arrowdown-up",
"hud-MainMenuBar-arrowup-disabled",
"hud-MainMenuBar-arrowup-down",
"hud-MainMenuBar-arrowup-highlight",
"hud-MainMenuBar-arrowup-up",
"hud-MainMenuBar-experiencebar-large-double",
"hud-MainMenuBar-experiencebar-large-single",
"hud-MainMenuBar-experiencebar-small-double",
"hud-MainMenuBar-experiencebar-small-single",
"hud-MainMenuBar-gryphon",
"hud-MainMenuBar-large",
"hud-MainMenuBar-small",
"hud-MicroBagBar",
"hud-microbutton-Achievement-Disabled",
"hud-microbutton-Achievement-Down",
"hud-microbutton-Achievement-Up",
"hud-microbutton-BStore-Disabled",
"hud-microbutton-BStore-Down",
"hud-microbutton-BStore-Up",
"hud-microbutton-Character-Down",
"hud-microbutton-Character-Up",
"hud-microbutton-EJ-Disabled",
"hud-microbutton-EJ-Down",
"hud-microbutton-EJ-Up",
"hud-microbutton-Guild-Banner",
"hud-microbutton-LFG-Disabled",
"hud-microbutton-LFG-Down",
"hud-microbutton-LFG-Up",
"hud-microbutton-MainMenu-Disabled",
"hud-microbutton-MainMenu-Down",
"hud-microbutton-MainMenu-Up",
"hud-microbutton-Mounts-Disabled",
"hud-microbutton-Mounts-Down",
"hud-microbutton-Mounts-Up",
"hud-microbutton-Quest-Disabled",
"hud-microbutton-Quest-Down",
"hud-microbutton-Quest-Up",
"hud-microbutton-Socials-Disabled",
"hud-microbutton-Socials-Down",
"hud-microbutton-Socials-Up",
"hud-microbutton-Spellbook-Disabled",
"hud-microbutton-Spellbook-Down",
"hud-microbutton-Spellbook-Up",
"hud-microbutton-StreamDL-Down",
"hud-microbutton-StreamDL-Up",
"hud-microbutton-Talents-Disabled",
"hud-microbutton-Talents-Down",
"hud-microbutton-Talents-Up",
"hud-microbutton-communities-icon-notification",
"hud-microbutton-highlight",
"hud-microbutton-highlightalert",
"icon-clock",
"insetshadow",
"inspect-talent-selected",
"lang-alert-deDE",
"lang-alert-enCN",
"lang-alert-enGB",
"lang-alert-enTW",
"lang-alert-enUS",
"lang-alert-esES",
"lang-alert-esMX",
"lang-alert-frFR",
"lang-alert-itIT",
"lang-alert-koKR",
"lang-alert-ptBR",
"lang-alert-ptPT",
"lang-alert-ruRU",
"lang-alert-zhCN",
"lang-alert-zhTW",
"legioninvasion-ScenarioTrackerToast",
"legioninvasion-Toast-Frame",
"legioninvasion-map-cover",
"legioninvasion-map-icon-portal",
"legioninvasion-map-icon-portal-large",
"legioninvasion-scenario-rewardring",
"legioninvasion-title-bg",
"legionmission-EncounterAbilityBorder",
"legionmission-EncounterAbilityBorder-Lg",
"legionmission-background-combatally",
"legionmission-complete-background-deathknight",
"legionmission-complete-background-demonhunter",
"legionmission-complete-background-druid",
"legionmission-complete-background-hunter",
"legionmission-complete-background-mage",
"legionmission-complete-background-monk",
"legionmission-complete-background-paladin",
"legionmission-complete-background-priest",
"legionmission-complete-background-rogue",
"legionmission-complete-background-shaman",
"legionmission-complete-background-warlock",
"legionmission-complete-background-warrior",
"legionmission-hearts-background",
"legionmission-icon-currency",
"legionmission-landingbutton-deathknight-down",
"legionmission-landingbutton-deathknight-up",
"legionmission-landingbutton-demonhunter-down",
"legionmission-landingbutton-demonhunter-up",
"legionmission-landingbutton-druid-down",
"legionmission-landingbutton-druid-up",
"legionmission-landingbutton-hunter-down",
"legionmission-landingbutton-hunter-up",
"legionmission-landingbutton-mage-down",
"legionmission-landingbutton-mage-up",
"legionmission-landingbutton-monk-down",
"legionmission-landingbutton-monk-up",
"legionmission-landingbutton-paladin-down",
"legionmission-landingbutton-paladin-up",
"legionmission-landingbutton-priest-down",
"legionmission-landingbutton-priest-up",
"legionmission-landingbutton-rogue-down",
"legionmission-landingbutton-rogue-up",
"legionmission-landingbutton-shaman-down",
"legionmission-landingbutton-shaman-up",
"legionmission-landingbutton-warlock-down",
"legionmission-landingbutton-warlock-up",
"legionmission-landingbutton-warrior-down",
"legionmission-landingbutton-warrior-up",
"legionmission-landingpage-background-deathknight",
"legionmission-landingpage-background-demonhunter",
"legionmission-landingpage-background-druid",
"legionmission-landingpage-background-hunter",
"legionmission-landingpage-background-mage",
"legionmission-landingpage-background-monk",
"legionmission-landingpage-background-paladin",
"legionmission-landingpage-background-priest",
"legionmission-landingpage-background-rogue",
"legionmission-landingpage-background-shaman",
"legionmission-landingpage-background-warlock",
"legionmission-landingpage-background-warrior",
"legionmission-lock",
"legionmission-map-orderhall-deathknight",
"legionmission-map-orderhall-demonhunter",
"legionmission-map-orderhall-druid",
"legionmission-map-orderhall-glow",
"legionmission-map-orderhall-hunter",
"legionmission-map-orderhall-mage",
"legionmission-map-orderhall-monk",
"legionmission-map-orderhall-paladin",
"legionmission-map-orderhall-priest",
"legionmission-map-orderhall-rogue",
"legionmission-map-orderhall-shaman",
"legionmission-map-orderhall-textglow",
"legionmission-map-orderhall-warlock",
"legionmission-map-orderhall-warrior",
"legionmission-portraitring-epicplus",
"legionmission-portraitring_levelborder_epicplus",
"levelup-bar-gold",
"levelup-bar-green",
"levelup-bar-white",
"levelup-dot-gold",
"levelup-dot-green",
"levelup-glow-gold",
"levelup-glow-green",
"levelup-icon-arrow",
"levelup-icon-bag",
"levelup-icon-book",
"levelup-icon-lock",
"levelup-shadow-lower",
"levelup-shadow-upper",
"logo-wow-classic",
"logo-wow-retail",
"loottab-background",
"loottab-set-background",
"loottab-set-itemborder-artifact",
"loottab-set-itemborder-blue",
"loottab-set-itemborder-green",
"loottab-set-itemborder-orange",
"loottab-set-itemborder-purple",
"loottab-set-itemborder-white",
"loottoast-arrow-blue",
"loottoast-arrow-green",
"loottoast-arrow-orange",
"loottoast-arrow-purple",
"loottoast-bg-alliance",
"loottoast-bg-horde",
"loottoast-bg-questrewardupgrade",
"loottoast-glow",
"loottoast-itemborder-artifact",
"loottoast-itemborder-blue",
"loottoast-itemborder-glow",
"loottoast-itemborder-gold",
"loottoast-itemborder-green",
"loottoast-itemborder-heirloom",
"loottoast-itemborder-orange",
"loottoast-itemborder-purple",
"loottoast-sheen",
"macropopup-bottomleft",
"macropopup-bottomright",
"macropopup-bottomright-nobuttons",
"macropopup-intersect-left",
"macropopup-intersect-right",
"macropopup-scrollbar-bottom",
"macropopup-scrollbar-top",
"macropopup-topleft",
"macropopup-topleft2",
"macropopup-topright",
"macropopup-topright2",
"map-icon-SuramarDoor.tga",
"map-icon-deathknightclasshall",
"map-icon-ignored-blueexclaimation",
"map-icon-ignored-bluequestion",
"menu-disabled",
"menu-disabled-right",
"minimal-scrollbar-arrow-bottom",
"minimal-scrollbar-arrow-bottom-down",
"minimal-scrollbar-arrow-bottom-over",
"minimal-scrollbar-arrow-returntobottom",
"minimal-scrollbar-arrow-returntobottom-down",
"minimal-scrollbar-arrow-returntobottom-over",
"minimal-scrollbar-arrow-top",
"minimal-scrollbar-arrow-top-down",
"minimal-scrollbar-arrow-top-over",
"minimal-scrollbar-small-arrow-bottom",
"minimal-scrollbar-small-arrow-bottom-down",
"minimal-scrollbar-small-arrow-bottom-over",
"minimal-scrollbar-small-arrow-returntobottom",
"minimal-scrollbar-small-arrow-returntobottom-down",
"minimal-scrollbar-small-arrow-returntobottom-over",
"minimal-scrollbar-small-arrow-top",
"minimal-scrollbar-small-arrow-top-down",
"minimal-scrollbar-small-arrow-top-over",
"minimal-scrollbar-small-thumb-bottom",
"minimal-scrollbar-small-thumb-bottom-down",
"minimal-scrollbar-small-thumb-bottom-over",
"minimal-scrollbar-small-thumb-middle",
"minimal-scrollbar-small-thumb-middle-down",
"minimal-scrollbar-small-thumb-middle-over",
"minimal-scrollbar-small-thumb-top",
"minimal-scrollbar-small-thumb-top-down",
"minimal-scrollbar-small-thumb-top-over",
"minimal-scrollbar-small-track-bottom",
"minimal-scrollbar-small-track-top",
"minimal-scrollbar-thumb-bottom",
"minimal-scrollbar-thumb-bottom-down",
"minimal-scrollbar-thumb-bottom-over",
"minimal-scrollbar-thumb-middle",
"minimal-scrollbar-thumb-middle-down",
"minimal-scrollbar-thumb-middle-over",
"minimal-scrollbar-thumb-top",
"minimal-scrollbar-thumb-top-down",
"minimal-scrollbar-thumb-top-over",
"minimal-scrollbar-track-bottom",
"minimal-scrollbar-track-top",
"minortalents-backplate",
"minortalents-descriptionshadow",
"minortalents-icon-book",
"minortalents-iconcover",
"nameplate-WarlockShard-Glow",
"nameplate-WarlockShard-Off",
"nameplate-WarlockShard-On",
"nameplates-InterruptShield",
"nameplates-bar-background",
"nameplates-bar-background-white",
"nameplates-holypower1-off",
"nameplates-holypower1-on",
"nameplates-holypower2-off",
"nameplates-holypower2-on",
"nameplates-holypower3-off",
"nameplates-holypower3-on",
"nameplates-holypower4-off",
"nameplates-holypower4-on",
"nameplates-icon-elite-gold",
"nameplates-icon-elite-silver",
"nameplates-playerhealth-background",
"neutral_tower-icon",
"newplayerchat-chaticon-guide",
"newplayerchat-chaticon-newcomer",
"obliterumforge-background",
"obliterumforge-slotted-corners",
"obliterumforge-slotted-corners-glow",
"options-notch",
"optionsframe-nineslice-cornerbottomleft",
"optionsframe-nineslice-cornerbottomright",
"optionsframe-nineslice-cornertopleft",
"optionsframe-nineslice-cornertopright",
"orderhall-commandbar-iconmask",
"orderhall-commandbar-mapbutton-down",
"orderhall-commandbar-mapbutton-up",
"orderhalltalents-background-deathknight",
"orderhalltalents-background-demonhunter",
"orderhalltalents-background-druid",
"orderhalltalents-background-hunter",
"orderhalltalents-background-mage",
"orderhalltalents-background-monk",
"orderhalltalents-background-paladin",
"orderhalltalents-background-priest",
"orderhalltalents-background-rogue",
"orderhalltalents-background-shaman",
"orderhalltalents-background-warlock",
"orderhalltalents-background-warrior",
"orderhalltalents-choice-arrow-large",
"orderhalltalents-choice-background",
"orderhalltalents-choice-background-on",
"orderhalltalents-done-checkmark",
"orderhalltalents-done-glow",
"orderhalltalents-spellborder",
"orderhalltalents-spellborder-green",
"orderhalltalents-spellborder-yellow",
"orderhalltalents-timer-bg",
"parchmentpopup-background",
"parchmentpopup-bottom",
"parchmentpopup-bottomleft",
"parchmentpopup-bottomright",
"parchmentpopup-filigree",
"parchmentpopup-hide-bottom",
"parchmentpopup-hide-left",
"parchmentpopup-hide-right",
"parchmentpopup-hide-top",
"parchmentpopup-left",
"parchmentpopup-right",
"parchmentpopup-top",
"parchmentpopup-topleft",
"parchmentpopup-topright",
"placeholder-icon",
"plunderstorm-UI-HUD-UnitFrame-Party-PortraitOn",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn-2x",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn-InCombat",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn-InCombat-2x",
"plunderstorm-actionbar-slot-background",
"plunderstorm-actionbar-slot-border",
"plunderstorm-actionbar-slot-border-swappable",
"plunderstorm-actionbar-slot-corners",
"plunderstorm-actionbar-slot-pip",
"plunderstorm-actionbar-slot-pipbackground",
"plunderstorm-actionbar-tabswappable-background",
"plunderstorm-actionbar-topper-attack",
"plunderstorm-actionbar-topper-offensive",
"plunderstorm-actionbar-topper-potion",
"plunderstorm-icon-fullyupgraded",
"plunderstorm-icon-item",
"plunderstorm-icon-key",
"plunderstorm-icon-kills",
"plunderstorm-icon-offensive",
"plunderstorm-icon-plunderCoins",
"plunderstorm-icon-plunderCoins-big",
"plunderstorm-icon-small-fullyupgraded",
"plunderstorm-icon-small-item",
"plunderstorm-icon-small-offensive",
"plunderstorm-icon-small-upgrade",
"plunderstorm-icon-small-utility",
"plunderstorm-icon-trophy",
"plunderstorm-icon-upgrade",
"plunderstorm-icon-utility",
"plunderstorm-landingpagebutton-down",
"plunderstorm-landingpagebutton-up",
"plunderstorm-nameplates-icon-1",
"plunderstorm-nameplates-icon-2",
"plunderstorm-nameplates-icon-3",
"plunderstorm-nameplates-icon-ring",
"plunderstorm-new-dot-lg",
"plunderstorm-new-dot-sm",
"plunderstorm-pickup-BG",
"plunderstorm-pickup-arrow",
"plunderstorm-pickup-mouseclick-left",
"plunderstorm-pickup-mouseclick-right",
"plunderstorm-pvpqueue-background",
"plunderstorm-pvpqueue-catergory-icon",
"plunderstorm-pvpqueue-sidebar-background",
"plunderstorm-scenariotracker-active",
"plunderstorm-scenariotracker-active-decoration",
"plunderstorm-scenariotracker-active-frame",
"plunderstorm-scenariotracker-decoration",
"plunderstorm-scenariotracker-waiting",
"plunderstorm-scenariotracker-waiting-decoration",
"plunderstorm-scenariotracker-waiting-frame",
"plunderstorm-spectate-arrow",
"plunderstorm-spectate-background",
"plunderstorm-stormbar-BGCenter",
"plunderstorm-stormbar-BGLeft",
"plunderstorm-stormbar-BGRight",
"plunderstorm-stormbar-BorderCenter",
"plunderstorm-stormbar-BorderLeft",
"plunderstorm-stormbar-BorderRight",
"plunderstorm-stormbar-background",
"plunderstorm-stormbar-border",
"plunderstorm-stormbar-fill",
"plunderstorm-stormbar-fill-filling",
"plunderstorm-stormbar-spark",
"plunderstorm-toast-BG-matchComplete",
"plunderstorm-toast-BG-queue",
"plunderstorm-toast-BG-statDetails",
"plunderstorm-toast-bottomDecal",
"plunderstorm-toast-bottomDecal-line",
"plunderstorm-toast-divider",
"plunderstorm-toast-finish-lose",
"plunderstorm-toast-finish-matchend",
"plunderstorm-toast-finish-win",
"plunderstorm-toast-levelup-background",
"plunderstorm-toast-swords",
"plunderstorm-toast-swords-line",
"plunderstorm-waypoint-ring",
"poi-alliance",
"poi-door",
"poi-door-arrow-down",
"poi-door-arrow-up",
"poi-door-down",
"poi-door-left",
"poi-door-right",
"poi-door-up",
"poi-graveyard-neutral",
"poi-horde",
"poi-majorcity",
"poi-rift1",
"poi-rift2",
"poi-town",
"poi-transmogrifier",
"poi-workorders",
"pvp_ffa-icon",
"pvpqueue-background-casual-alliance",
"pvpqueue-background-casual-horde",
"pvpqueue-background-rated",
"pvpqueue-bg-alliance",
"pvpqueue-bg-horde",
"pvpqueue-button-casual-down",
"pvpqueue-button-casual-highlight",
"pvpqueue-button-casual-selected",
"pvpqueue-button-casual-up",
"pvpqueue-button-down",
"pvpqueue-button-highlight",
"pvpqueue-button-selected",
"pvpqueue-button-up",
"pvpqueue-chest-background",
"pvpqueue-conquestbar-background",
"pvpqueue-conquestbar-checkmark",
"pvpqueue-conquestbar-frame",
"pvpqueue-rankglow",
"pvpqueue-rewardring",
"pvpqueue-rewardring-black",
"pvpqueue-rewardring-large",
"pvpqueue-rewardring-popup",
"pvpqueue-rewardring-small",
"pvpqueue-sidebar-background",
"pvpqueue-sidebar-honorbar-background",
"pvpqueue-sidebar-honorbar-background-alliance",
"pvpqueue-sidebar-honorbar-background-horde",
"pvpqueue-sidebar-honorbar-badge-alliance",
"pvpqueue-sidebar-honorbar-badge-horde",
"pvpqueue-sidebar-nextarrow",
"pvprated-loottoast-bg-alliance",
"pvprated-loottoast-bg-horde",
"quickjoin-button-friendslist-down",
"quickjoin-button-friendslist-up",
"quickjoin-button-group-down",
"quickjoin-button-group-up",
"quickjoin-button-quickjoin-down",
"quickjoin-button-quickjoin-up",
"quickjoin-toast-background",
"quickjoin-toast-lines",
"raceicon-bloodelf-female",
"raceicon-bloodelf-male",
"raceicon-draenei-female",
"raceicon-draenei-male",
"raceicon-dwarf-female",
"raceicon-dwarf-male",
"raceicon-gnome-female",
"raceicon-gnome-male",
"raceicon-goblin-female",
"raceicon-goblin-male",
"raceicon-highmountain-female",
"raceicon-highmountain-male",
"raceicon-human-female",
"raceicon-human-male",
"raceicon-lightforged-female",
"raceicon-lightforged-male",
"raceicon-nightborne-female",
"raceicon-nightborne-male",
"raceicon-nightelf-female",
"raceicon-nightelf-male",
"raceicon-orc-female",
"raceicon-orc-male",
"raceicon-pandaren-female",
"raceicon-pandaren-male",
"raceicon-tauren-female",
"raceicon-tauren-male",
"raceicon-troll-female",
"raceicon-troll-male",
"raceicon-undead-female",
"raceicon-undead-male",
"raceicon-voidelf-female",
"raceicon-voidelf-male",
"raceicon-worgen-female",
"raceicon-worgen-male",
"recipetoast-bg",
"recipetoast-icon-star",
"search-highlight",
"search-highlight-large",
"search-iconframe-large",
"search-select",
"services-checkmark",
"services-cover",
"services-cover-ring",
"services-icon-bonus",
"services-icon-bonus-large",
"services-icon-bonus-red",
"services-icon-goldborder",
"services-icon-processing",
"services-icon-warning",
"services-number-1",
"services-number-2",
"services-number-3",
"services-number-4",
"services-number-5",
"services-number-6",
"services-number-7",
"services-number-8",
"services-number-9",
"services-popup-bg",
"services-popup-bot",
"services-popup-botleft",
"services-popup-botright",
"services-popup-left",
"services-popup-right",
"services-popup-top",
"services-popup-topleft",
"services-popup-topright",
"services-ring",
"services-ring-countcircle",
"services-ring-large",
"services-ring-large-glow",
"services-ring-large-glowpulse",
"services-ring-large-glowspin",
"services-ring-wod",
"services-yellowarrow",
"shadoworbs-large-Frame",
"shadoworbs-large-Frame-OrbHighlight",
"shadoworbs-large-Orb",
"shadoworbs-large-Orb-Bg",
"shadoworbs-small-Frame",
"shadoworbs-small-Frame-OrbHighlight",
"shadoworbs-small-Orb",
"shadoworbs-small-Orb-Bg",
"shop-bg-shadow-below-header",
"shop-bg-shadow-left",
"shop-bg-shadow-top",
"shop-bg-temp-loading",
"shop-bundle-12mosub",
"shop-bundle-365sub-apac",
"shop-bundle-442-moppreorder-epic",
"shop-bundle-442-moppreorder-heroic",
"shop-card-bg",
"shop-card-bundle",
"shop-card-bundle-alteracpup-feydragon",
"shop-card-bundle-hover",
"shop-card-bundle-legion",
"shop-card-bundle-reaver-argi",
"shop-card-bundle-selected",
"shop-card-bundle-starseekers",
"shop-card-darkcover",
"shop-card-full-441-180daysbundle-apac",
"shop-card-full-441-6monthbundle",
"shop-card-full-442-moppreorder-epicupgrade",
"shop-card-full-550-180day-refresh-apac",
"shop-card-full-550-365day-refresh-apac",
"shop-card-full-550-redpandabundle",
"shop-card-full-550-yoa-12mo-refresh",
"shop-card-full-551-6mo-refresh",
"shop-card-full-551-wingsoftheguardianpack",
"shop-card-full-BCC-darkportalpassupgrade",
"shop-card-full-aa44",
"shop-card-full-bfadeluxe",
"shop-card-full-classicwotlk-goodies-heroictoepic2",
"shop-card-full-classicwotlk-goodies2",
"shop-card-full-gametimebundle-14day",
"shop-card-full-gametimebundle-60day",
"shop-card-full-gametimebundle-90day",
"shop-card-full-july2024-12month",
"shop-card-full-july2024-180day",
"shop-card-full-july2024-365day",
"shop-card-full-july2024-6month",
"shop-card-full-legiondeluxe",
"shop-card-full-reven-ibelin-charity-pet",
"shop-card-full-tf1h",
"shop-card-full-tf2e",
"shop-card-full-tf5u",
"shop-card-full-warcraft30th",
"shop-card-full-year-of-azeroth-2024-12month",
"shop-card-full-year-of-azeroth-2024-365day",
"shop-card-half-BCC-darkportalpass",
"shop-card-half-BCC-darkportalpassdeluxe",
"shop-card-half-bfa",
"shop-card-half-bfadeluxe",
"shop-card-half-brownbox",
"shop-card-half-brownboxbfabundle",
"shop-card-half-brownboxlegionbundle",
"shop-card-half-classicwotlk-goodiesepic2",
"shop-card-half-classicwotlk-goodieshero2",
"shop-card-half-hover",
"shop-card-half-legion",
"shop-card-half-legiondeluxe",
"shop-card-half-tf3e",
"shop-card-half-tf4h",
"shop-card-label-bg",
"shop-card-label-bg-2",
"shop-card-mini-bg",
"shop-card-mini-frame",
"shop-card-small-frame-default",
"shop-card-small-frame-hover",
"shop-card-small-frame-selected",
"shop-card-wide-bg",
"shop-card-wide-frame-default",
"shop-card-wide-frame-hover",
"shop-card-wide-frame-selected",
"shop-card-wide-scrim",
"shop-card-wide-text-shadow",
"shop-drop-shadow",
"shop-games-legion",
"shop-games-legiondeluxe",
"shop-games-legiondeluxe-card",
"shop-games-magnifyingglass",
"shop-header-menu",
"shop-header-menu-default",
"shop-header-menu-default-left",
"shop-header-menu-disabled",
"shop-header-menu-divider",
"shop-header-menu-divider-disabled",
"shop-header-menu-glow-selected",
"shop-header-menu-glow-selected-left",
"shop-header-menu-glow-selected-right",
"shop-list-bg",
"shop-list-rule",
"shop-saletag",
"shop-toast",
"shop-toast-line",
"simplecheckout-close-hover-1x",
"simplecheckout-close-hover-2x",
"simplecheckout-close-normal-1x",
"simplecheckout-close-normal-2x",
"simplecheckout-close-pressed-1x",
"simplecheckout-close-pressed-2x",
"skull_bones-icon",
"sniper_shot-icon",
"socialqueuing-friendlist-summonbutton-disabled",
"socialqueuing-friendlist-summonbutton-down",
"socialqueuing-friendlist-summonbutton-up",
"socialqueuing-icon-clock",
"socialqueuing-icon-eye",
"socialqueuing-icon-group",
"socialqueuing-row-highlight",
"socialqueuing-row-select",
"socket-blue-background",
"socket-blue-closed",
"socket-blue-open",
"socket-cogwheel-background",
"socket-cogwheel-closed",
"socket-cogwheel-open",
"socket-domination-background",
"socket-domination-closed",
"socket-domination-open",
"socket-hydraulic-background",
"socket-hydraulic-closed",
"socket-hydraulic-open",
"socket-meta-background",
"socket-meta-closed",
"socket-meta-open",
"socket-prismatic-background",
"socket-prismatic-closed",
"socket-prismatic-open",
"socket-punchcard-blue-background",
"socket-punchcard-blue-closed",
"socket-punchcard-blue-open",
"socket-punchcard-red-background",
"socket-punchcard-red-closed",
"socket-punchcard-red-open",
"socket-punchcard-yellow-background",
"socket-punchcard-yellow-closed",
"socket-punchcard-yellow-open",
"socket-red-background",
"socket-red-closed",
"socket-red-open",
"socket-yellow-background",
"socket-yellow-closed",
"socket-yellow-open",
"splash-600-botleft",
"splash-600-right",
"splash-600-topleft",
"splash-601-botleft",
"splash-601-right",
"splash-601-topleft",
"splash-610-botleft",
"splash-610-right",
"splash-610-topleft",
"splash-620-botleft",
"splash-620-right",
"splash-620-topleft",
"splash-703-botleft",
"splash-703-right",
"splash-703-topleft",
"splash-704-botleft",
"splash-704-right",
"splash-704-topleft",
"splash-705-botleft",
"splash-705-right",
"splash-705-topleft",
"splash-710-botleft",
"splash-710-right",
"splash-710-topleft",
"splash-720-botleft",
"splash-720-right",
"splash-720-topleft",
"splash-725-botleft",
"splash-725-right",
"splash-725-topleft",
"splash-730-botleft",
"splash-730-right",
"splash-730-topleft",
"splash-735-botleft",
"splash-735-right",
"splash-735-topleft",
"splash-bigbutton",
"splash-boost-botleft",
"splash-boost-right",
"splash-boost-topleft",
"splash-botleft",
"store-card-splash1-nobanner",
"store-card-transmog",
"talenttree-chromie-background",
"titleprestige-ember",
"titleprestige-glowcover",
"titleprestige-prestigeicon",
"titleprestige-prestigeiconplate-alliance",
"titleprestige-prestigeiconplate-horde",
"titleprestige-starcrown",
"titleprestige-starglow",
"titleprestige-title",
"titleprestige-title-bg",
"titleprestige-title2",
"titleprestige-wings",
"titleprestige-wings-white",
"titleprestige-wings2",
"titleprestige-wings2-white",
"titleprestige-wreath",
"token-button-category",
"token-choice-bnet",
"token-choice-wow",
"token-info-arrow",
"token-info-background",
"token-itemslot",
"tournamentarena-flag-large-blue",
"tournamentarena-flag-large-blue-flash",
"tournamentarena-flag-large-red",
"tournamentarena-flag-large-red-flash",
"tournamentarena-frame-bg-corner-blue",
"tournamentarena-frame-bg-corner-red",
"tournamentarena-frame-bg-side-blue",
"tournamentarena-frame-bg-side-red",
"tournamentarena-frame-bot",
"tournamentarena-frame-botleft",
"tournamentarena-frame-botright",
"tournamentarena-frame-left",
"tournamentarena-frame-right",
"tournamentarena-frame-top",
"tournamentarena-frame-topleft",
"tournamentarena-frame-topright",
"tournamentarena-titlebackplate",
"tournamentarena-winnerline",
"tradeskill-background-recipe",
"tradeskill-background-recipe-unlearned",
"tradeskills-iconborder",
"tradeskills-star",
"tradeskills-star-off",
"transmog-background-race-bloodelf",
"transmog-background-race-draenei",
"transmog-background-race-dwarf",
"transmog-background-race-gnome",
"transmog-background-race-goblin",
"transmog-background-race-human",
"transmog-background-race-nightelf",
"transmog-background-race-orc",
"transmog-background-race-pandaren",
"transmog-background-race-tauren",
"transmog-background-race-troll",
"transmog-background-race-undead",
"transmog-background-race-worgen",
"transmog-frame",
"transmog-frame-blackcover",
"transmog-frame-highlighted",
"transmog-frame-highlighted-small",
"transmog-frame-pink",
"transmog-frame-red",
"transmog-frame-selected",
"transmog-frame-small",
"transmog-frame-small-pink",
"transmog-frame-small-red",
"transmog-frame-small-selected",
"transmog-icon-chat",
"transmog-icon-checkmark",
"transmog-icon-downarrow",
"transmog-icon-hidden",
"transmog-icon-remove",
"transmog-icon-revert",
"transmog-icon-revert-small",
"transmog-icon-revert-small-disabled",
"transmog-nav-slot-back",
"transmog-nav-slot-chest",
"transmog-nav-slot-enchant",
"transmog-nav-slot-feet",
"transmog-nav-slot-hands",
"transmog-nav-slot-head",
"transmog-nav-slot-legs",
"transmog-nav-slot-mainhand",
"transmog-nav-slot-secondaryhand",
"transmog-nav-slot-selected",
"transmog-nav-slot-selected-small",
"transmog-nav-slot-shirt",
"transmog-nav-slot-shoulder",
"transmog-nav-slot-tabard",
"transmog-nav-slot-waist",
"transmog-nav-slot-wrist",
"transmog-set-border-collected",
"transmog-set-border-current",
"transmog-set-border-current-transmogged",
"transmog-set-border-highlighted",
"transmog-set-border-selected",
"transmog-set-border-unusable",
"transmog-set-iconrow-background",
"transmog-set-model-cutoff-fade",
"transmog-toast-bg",
"transmog-wardrobe-border-collected",
"transmog-wardrobe-border-current",
"transmog-wardrobe-border-current-transmogged",
"transmog-wardrobe-border-highlighted",
"transmog-wardrobe-border-selected",
"transmog-wardrobe-border-selected-smoke",
"transmog-wardrobe-border-selected-wisp",
"transmog-wardrobe-border-uncollected",
"transmog-wardrobe-border-unusable",
"ui-classicscrollbar-center",
"ui-classicscrollbar-endcap-bottom",
"ui-classicscrollbar-endcap-bottom-rounded",
"ui-classicscrollbar-endcap-top",
"ui-frame-LFG-Progressbar-Border",
"ui-frame-LFG-Progressbar-Fill-Green",
"ui-hud-wowlabs-actionbar-bookend-left",
"ui-hud-wowlabs-actionbar-bookend-right",
"ui-hud-wowlabs-actionbar-levelnumber-default",
"ui-hud-wowlabs-actionbar-levelnumber-levelup",
"ui-hud-wowlabs-actionbar-offense-cap",
"ui-hud-wowlabs-actionbar-utility-cap",
"ui-hud-wowlabs-actionbar-xp-bg",
"ui-hud-wowlabs-actionbar-xp-fill",
"ui-hud-wowlabs-actionbar-xp-frame",
"ui-hud-wowlabs-actionbar-xp-futurefill",
"ui-hud-wowlabs-actionbar-xp-threshold",
"ui-questtracker-lfg-eye-selected_ALT",
"ui-questtracker-lfg-eye_ALT",
"ui-questtracker-objective-fail_ALT",
"ui-questtracker-objective-nub_ALT",
"ui-questtracker-objfx-barglow_ALT",
"ui-questtracker-objfx-shine_ALT",
"ui-questtracker-objfx_lineglow_ALT",
"ui-questtracker-primary-objective-header_ALT",
"ui-questtracker-progressbar-frame_ALT",
"ui-questtracker-progressbar-full-channel_ALT",
"ui-questtracker-secondary-objective-header_ALT",
"ui-questtracker-tracker-check-glow_ALT",
"ui-questtracker-tracker-check_ALT",
"ui-questtrackerbutton-collapse-all-pressed_ALT",
"ui-questtrackerbutton-collapse-all_ALT",
"ui-questtrackerbutton-expand-all-pressed_ALT",
"ui-questtrackerbutton-expand-all_ALT",
"ui-questtrackerbutton-filter-pressed_ALT",
"ui-questtrackerbutton-filter_ALT",
"ui-questtrackerbutton-questitem-frame-glow_ALT",
"ui-questtrackerbutton-questitem-frame_ALT",
"ui-questtrackerbutton-red-highlight_ALT",
"ui-questtrackerbutton-secondary-collapse-pressed_ALT",
"ui-questtrackerbutton-secondary-collapse_ALT",
"ui-questtrackerbutton-secondary-expand-pressed_ALT",
"ui-questtrackerbutton-secondary-expand_ALT",
"ui-questtrackerbutton-yellow-highlight_ALT",
"ui-scrollbar-button-overlay",
"ui-scrollbar-button-overlay-horizontal",
"ui-scrollbar-endcap-bottom",
"ui-scrollbar-endcap-left",
"ui-scrollbar-endcap-right",
"ui-scrollbar-endcap-top",
"ui-scrollbar-knob-center",
"ui-scrollbar-knob-center-disabled",
"ui-scrollbar-knob-center-disabled-horizontal",
"ui-scrollbar-knob-center-horizontal",
"ui-scrollbar-knob-endcap-bottom",
"ui-scrollbar-knob-endcap-bottom-disabled",
"ui-scrollbar-knob-endcap-left",
"ui-scrollbar-knob-endcap-left-disabled",
"ui-scrollbar-knob-endcap-right",
"ui-scrollbar-knob-endcap-right-disabled",
"ui-scrollbar-knob-endcap-top",
"ui-scrollbar-knob-endcap-top-disabled",
"ui-scrollbar-knob-mouseover-center",
"ui-scrollbar-knob-mouseover-center-horizontal",
"ui-scrollbar-knob-mouseover-endcap-bottom",
"ui-scrollbar-knob-mouseover-endcap-left",
"ui-scrollbar-knob-mouseover-endcap-right",
"ui-scrollbar-knob-mouseover-endcap-top",
"ui-scrollbar-scrolldownbutton-disabled",
"ui-scrollbar-scrolldownbutton-down",
"ui-scrollbar-scrolldownbutton-highlight",
"ui-scrollbar-scrolldownbutton-up",
"ui-scrollbar-scrollleftbutton-disabled",
"ui-scrollbar-scrollleftbutton-down",
"ui-scrollbar-scrollleftbutton-highlight",
"ui-scrollbar-scrollleftbutton-up",
"ui-scrollbar-scrollrightbutton-disabled",
"ui-scrollbar-scrollrightbutton-down",
"ui-scrollbar-scrollrightbutton-highlight",
"ui-scrollbar-scrollrightbutton-up",
"ui-scrollbar-scrollupbutton-disabled",
"ui-scrollbar-scrollupbutton-down",
"ui-scrollbar-scrollupbutton-highlight",
"ui-scrollbar-scrollupbutton-up",
"uiframe-activetab-left",
"uiframe-activetab-right",
"uiframe-tab-left",
"uiframe-tab-right",
"vas-receipt-brownarrow",
"vas-receipt-greenbg",
"vas-receipt-icon-characterborder",
"vas-receipt-selectedcharbg",
"voicechat-channellist-category-background",
"voicechat-channellist-category-highlight",
"voicechat-channellist-category-minus",
"voicechat-channellist-category-plus",
"voicechat-channellist-icon-STT-off",
"voicechat-channellist-icon-STT-on",
"voicechat-channellist-icon-headphone-off",
"voicechat-channellist-icon-headphone-on",
"voicechat-channellist-row-background",
"voicechat-channellist-row-background2",
"voicechat-channellist-row-highlight",
"voicechat-channellist-row-selected",
"voicechat-icon-STT",
"voicechat-icon-headphone-off",
"voicechat-icon-headphone-on",
"voicechat-icon-headphone-pending",
"voicechat-icon-headphone-pendingdot-1",
"voicechat-icon-headphone-pendingdot-2",
"voicechat-icon-headphone-pendingdot-3",
"voicechat-icon-headphone-switch",
"voicechat-icon-loudnessbar-1",
"voicechat-icon-loudnessbar-2",
"voicechat-icon-loudnessbar-3",
"voicechat-icon-mic",
"voicechat-icon-mic-mute",
"voicechat-icon-mic-mutesilenced",
"voicechat-icon-mic-silenced",
"voicechat-icon-speaker",
"voicechat-icon-speaker-mute",
"voicechat-icon-speaker-mutesilenced",
"voicechat-icon-speaker-silenced",
"voicechat-icon-textchat-silenced",
"voicechat-portrait-drag",
"voicechat-portrait-ring",
"warboard-background",
"warboard-header-alliance",
"warboard-header-horde",
"warboard-parchment",
"warboard-parchment-answerborder",
"warboard-title-alliance-left",
"warboard-title-alliance-right",
"warboard-title-horde-left",
"warboard-title-horde-right",
"warboard-title-neutral-left",
"warboard-title-neutral-right",
"warboard-zone-bc-BladesEdgeMountains",
"warboard-zone-bc-HellfirePeninsula",
"warboard-zone-bc-IsleofQuelDanas",
"warboard-zone-bc-Nagrand",
"warboard-zone-bc-Netherstorm",
"warboard-zone-bc-ShadowmoonValley",
"warboard-zone-bc-TerokkarForest",
"warboard-zone-bc-Zangarmarsh",
"warboard-zone-cata-Deepholm",
"warboard-zone-cata-ElementalBonds",
"warboard-zone-cata-MoltenFront",
"warboard-zone-cata-MountHyjal",
"warboard-zone-cata-TwilightHighlands",
"warboard-zone-cata-Uldum",
"warboard-zone-cata-Vashjir",
"warboard-zone-classic-ArathiHighlands",
"warboard-zone-classic-Ashenvale",
"warboard-zone-classic-Azshara",
"warboard-zone-classic-AzuremystIsle",
"warboard-zone-classic-Badlands",
"warboard-zone-classic-BlastedLands",
"warboard-zone-classic-BloodmystIsle",
"warboard-zone-classic-BurningSteppes",
"warboard-zone-classic-CapeofStranglethorn",
"warboard-zone-classic-Darkshore",
"warboard-zone-classic-Desolace",
"warboard-zone-classic-DunMorogh",
"warboard-zone-classic-Durotar",
"warboard-zone-classic-Duskwood",
"warboard-zone-classic-DustwallowMarsh",
"warboard-zone-classic-EasternPlaguelands",
"warboard-zone-classic-ElwynnForest",
"warboard-zone-classic-EversongWoods",
"warboard-zone-classic-Felwood",
"warboard-zone-classic-Feralas",
"warboard-zone-classic-Ghostlands",
"warboard-zone-classic-Gilneas",
"warboard-zone-classic-HillsbradFoothills",
"warboard-zone-classic-Hinterlands",
"warboard-zone-classic-LochModan",
"warboard-zone-classic-LostIsles",
"warboard-zone-classic-Mulgore",
"warboard-zone-classic-NorthernBarrens",
"warboard-zone-classic-NorthernStranglethorn",
"warboard-zone-classic-RedridgeMountains",
"warboard-zone-classic-SearingGorge",
"warboard-zone-classic-Silithus",
"warboard-zone-classic-SilverpineForest",
"warboard-zone-classic-SouthernBarrens",
"warboard-zone-classic-StonetalonMountains",
"warboard-zone-classic-SwampofSorrows",
"warboard-zone-classic-Tanaris",
"warboard-zone-classic-Teldrassil",
"warboard-zone-classic-ThousandNeedles",
"warboard-zone-classic-TirisfalGlades",
"warboard-zone-classic-UngoroCrater",
"warboard-zone-classic-WanderingIsle",
"warboard-zone-classic-WesternPlaguelands",
"warboard-zone-classic-Westfall",
"warboard-zone-classic-Wetlands",
"warboard-zone-classic-Winterspring",
"warboard-zone-mop-DreadWastes",
"warboard-zone-mop-IsleofGiants",
"warboard-zone-mop-IsleoftheThunderKing",
"warboard-zone-mop-JadeForest",
"warboard-zone-mop-KrasarangWilds",
"warboard-zone-mop-KunLaiSummit",
"warboard-zone-mop-TimelessIsle",
"warboard-zone-mop-TownlongSteppes",
"warboard-zone-mop-ValeofEternalBlossoms",
"warboard-zone-mop-ValleyoftheFourWinds",
"warboard-zone-wod-FrostfireRidge",
"warboard-zone-wod-Gorgrond",
"warboard-zone-wod-Nagrand",
"warboard-zone-wod-ShadowmoonValley",
"warboard-zone-wod-SpiresofArak",
"warboard-zone-wod-Talador",
"warboard-zone-wod-TanaanJungle",
"warboard-zone-wod-TanaanJungleIntro",
"warboard-zone-wotlk-BoreanTundra",
"warboard-zone-wotlk-CrystalsongForest",
"warboard-zone-wotlk-Dalaran",
"warboard-zone-wotlk-Dragonblight",
"warboard-zone-wotlk-GrizzlyHills",
"warboard-zone-wotlk-HowlingFjord",
"warboard-zone-wotlk-Icecrown",
"warboard-zone-wotlk-SholazarBasin",
"warboard-zone-wotlk-StormPeaks",
"warboard-zone-wotlk-ZulDrak",
"worldquest-emissary-ring",
"worldquest-emissary-tracker-checkmark",
"worldquest-followerabilityframe",
"worldquest-icon-alchemy",
"worldquest-icon-archaeology",
"worldquest-icon-blacksmithing",
"worldquest-icon-boss",
"worldquest-icon-burninglegion",
"worldquest-icon-clock",
"worldquest-icon-cooking",
"worldquest-icon-dungeon",
"worldquest-icon-enchanting",
"worldquest-icon-engineering",
"worldquest-icon-firstaid",
"worldquest-icon-fishing",
"worldquest-icon-herbalism",
"worldquest-icon-inscription",
"worldquest-icon-jewelcrafting",
"worldquest-icon-leatherworking",
"worldquest-icon-mining",
"worldquest-icon-petbattle",
"worldquest-icon-pvp-ffa",
"worldquest-icon-raid",
"worldquest-icon-skinning",
"worldquest-icon-tailoring",
"worldquest-questmarker-abilityhighlight",
"worldquest-questmarker-dragon",
"worldquest-questmarker-dragon-glow",
"worldquest-questmarker-epic",
"worldquest-questmarker-epic-down",
"worldquest-questmarker-glow",
"worldquest-questmarker-questbang",
"worldquest-questmarker-questionmark",
"worldquest-questmarker-rare",
"worldquest-questmarker-rare-down",
"worldquest-tracker",
"worldquest-tracker-bg-noemissary",
"worldquest-tracker-checkmark",
"worldquest-tracker-lock",
"worldquest-tracker-questmarker",
"worldquest-tracker-questmarker-gray",
"worldquest-tracker-ring",
"worldquest-tracker-ring-selected",
"worldstate-capturebar-arrow",
"worldstate-capturebar-blue",
"worldstate-capturebar-frame",
"worldstate-capturebar-frame-factions",
"worldstate-capturebar-frame-separater",
"worldstate-capturebar-glow",
"worldstate-capturebar-gray",
"worldstate-capturebar-green",
"worldstate-capturebar-purple",
"worldstate-capturebar-red",
"worldstate-capturebar-spark-green",
"worldstate-capturebar-spark-yellow",
"worldstate-capturebar-yellow",
"wow-token-gold-2x",
"wowlabs-ability-icon-frame",
"wowlabs-currency-container-2x",
"wowlabs-currency-container-highlight-2x",
"wowlabs-rarity-pip",
"wowlabs-rarity-pip-bg",
"wowlabs-spell-icon-frame-highlight",
"wowlabs-switch-slots-key",
}


-- ========================================
-- File: WeakAuras/Atlas_Vanilla.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
Private.AtlasList = {
"!Barbershop-MiddleTile",
"!CharacterCreateDropdown-NineSlice-EdgeLeft",
"!CharacterCreateDropdown-NineSlice-EdgeRight",
"!ChatBubble-NineSlice-EdgeLeft",
"!ChatBubble-NineSlice-EdgeRight",
"!ClassHall_InfoBoxMission-Left",
"!ForgeBorder-Right",
"!GarrMission_Bg-DarkEdge",
"!GarrMission_Bg-Edge",
"!GarrMission_RewardsBorder-Left",
"!GarrMission_RewardsBorder-Left-Desaturate",
"!Garr_InfoBox-Left",
"!Garr_InfoBoxBorder-Left",
"!Garr_InfoBoxBorderMission-Left",
"!Garr_InfoBoxMission-Left",
"!Garr_WoodFrameTile-Left",
"!GeneralFrame-InsetFrame-Left",
"!GeneralFrame-InsetFrame-Right",
"!NewPlayerTutorial-NineSlice-EdgeLeft",
"!NewPlayerTutorial-NineSlice-EdgeRight",
"!OptionsFrame-NineSlice-EdgeLeft",
"!OptionsFrame-NineSlice-EdgeRight",
"!ShipMission_Bg-DarkEdge",
"!ShipMission_Bg-Edge",
"!ShipMission_RewardsBorder-Left-Desaturate",
"!StoneFrameTile-Left",
"!Tooltip-Glues-NineSlice-EdgeLeft",
"!Tooltip-Glues-NineSlice-EdgeRight",
"!Tooltip-NineSlice-EdgeLeft",
"!Tooltip-NineSlice-EdgeRight",
"!UI-Frame-DiamondMetal-EdgeLeft",
"!UI-Frame-DiamondMetal-EdgeRight",
"!UI-Frame-InnerLeftTile",
"!UI-Frame-InnerRightTile",
"!UI-Frame-LeftTile",
"!UI-Frame-RightTile",
"!UI-Taxi-Line",
"!macropopup-left",
"!macropopup-right",
"!macropopup-scrollbar-middle",
"!minimal-scrollbar-small-track-middle",
"!minimal-scrollbar-track-middle",
"!ui-scrollbar-center",
"128-RedButton-ArrowDown",
"128-RedButton-ArrowDown-Disabled",
"128-RedButton-ArrowDown-Highlight",
"128-RedButton-ArrowDown-Pressed",
"128-RedButton-ArrowUpGlow",
"128-RedButton-ArrowUpGlow-Disabled",
"128-RedButton-ArrowUpGlow-Highlight",
"128-RedButton-ArrowUpGlow-Pressed",
"128-RedButton-Delete",
"128-RedButton-Delete-Disabled",
"128-RedButton-Delete-Highlight",
"128-RedButton-Delete-Pressed",
"128-RedButton-Exit",
"128-RedButton-Exit-Disabled",
"128-RedButton-Exit-Pressed",
"128-RedButton-Highlight",
"128-RedButton-Left",
"128-RedButton-Left-Disabled",
"128-RedButton-Left-Pressed",
"128-RedButton-Minus",
"128-RedButton-Minus-Disabled",
"128-RedButton-Minus-Highlight",
"128-RedButton-Minus-Pressed",
"128-RedButton-Plus",
"128-RedButton-Plus-Disabled",
"128-RedButton-Plus-Highlight",
"128-RedButton-Plus-Pressed",
"128-RedButton-Refresh",
"128-RedButton-Refresh-Disabled",
"128-RedButton-Refresh-Highlight",
"128-RedButton-Refresh-Pressed",
"128-RedButton-Right",
"128-RedButton-Right-Disabled",
"128-RedButton-Right-Pressed",
"128-RedButton-VisibilityOff",
"128-RedButton-VisibilityOff-Disabled",
"128-RedButton-VisibilityOff-Highlight",
"128-RedButton-VisibilityOff-Pressed",
"128-RedButton-VisibilityOn",
"128-RedButton-VisibilityOn-Disabled",
"128-RedButton-VisibilityOn-Highlight",
"128-RedButton-VisibilityOn-Pressed",
"128-redbutton-exit-highlight",
"AdventureMap-InsetMapBorder",
"AdventureMap-combatally-clouds",
"AdventureMap-combatally-empty",
"AdventureMap-combatally-ring",
"AdventureMap-textlabelglow",
"AdventureMapIcon-DailyQuest",
"AdventureMapIcon-Lock",
"AdventureMapIcon-MissionCombat",
"AdventureMapIcon-Quest",
"AdventureMapIcon-SandboxQuest",
"AdventureMapLabel-Large",
"AdventureMapLabel-MissionTimer",
"AdventureMapLabel-QuestDiscovered",
"AdventureMapLabel-Small",
"AdventureMapQuest-ItemNameBG",
"AdventureMapQuest-PortraitBG",
"AdventureMapQuest-QuestPane",
"AdventureMapQuest-RewardsPanel",
"AdventureMap_TileBg",
"AdventureMap_TileBg_Parchment",
"AdventureMap_TopBorder",
"AftLevelup-CloudyLineLeft",
"AftLevelup-CloudyLineRight",
"AftLevelup-Dots1",
"AftLevelup-Dots2",
"AftLevelup-FiligreeLeft",
"AftLevelup-FiligreeRight",
"AftLevelup-GlowLine",
"AftLevelup-IconFrame",
"AftLevelup-IconGlow",
"AftLevelup-Lines1",
"AftLevelup-Lines2",
"AftLevelup-NeutralStarBurst",
"AftLevelup-PurpleStarBurst",
"AftLevelup-SoftCloud",
"AftLevelup-ToastBG",
"AftLevelup-WhiteIconGlow",
"AftLevelup-WhiteStarBurst",
"Alliance_Tier1_Arena1",
"Alliance_Tier1_Arena2",
"Alliance_Tier1_Armory1",
"Alliance_Tier1_Armory2",
"Alliance_Tier1_Barn1",
"Alliance_Tier1_Barn2",
"Alliance_Tier1_Barracks",
"Alliance_Tier1_Barracks1",
"Alliance_Tier1_Barracks2",
"Alliance_Tier1_Farm",
"Alliance_Tier1_Fishing",
"Alliance_Tier1_Inn1",
"Alliance_Tier1_Inn2",
"Alliance_Tier1_Lumber1",
"Alliance_Tier1_Lumber2",
"Alliance_Tier1_Mage1",
"Alliance_Tier1_Mage2",
"Alliance_Tier1_Mine",
"Alliance_Tier1_Professions",
"Alliance_Tier1_Professions2",
"Alliance_Tier1_Stables1",
"Alliance_Tier1_Stables2",
"Alliance_Tier1_TownHall",
"Alliance_Tier1_Trading1",
"Alliance_Tier1_Trading2",
"Alliance_Tier1_Workshop1",
"Alliance_Tier1_Workshop2",
"Alliance_Tier2_Arena1",
"Alliance_Tier2_Arena2",
"Alliance_Tier2_Armory1",
"Alliance_Tier2_Armory2",
"Alliance_Tier2_Barn1",
"Alliance_Tier2_Barn2",
"Alliance_Tier2_Barracks1",
"Alliance_Tier2_Barracks2",
"Alliance_Tier2_Inn1",
"Alliance_Tier2_Inn2",
"Alliance_Tier2_Lumber1",
"Alliance_Tier2_Lumber2",
"Alliance_Tier2_Mage1",
"Alliance_Tier2_Mage2",
"Alliance_Tier2_Stables1",
"Alliance_Tier2_Stables2",
"Alliance_Tier2_Trading1",
"Alliance_Tier2_Trading2",
"Alliance_Tier2_Workshop1",
"Alliance_Tier2_Workshop2",
"Alliance_Tier3_Arena1",
"Alliance_Tier3_Arena2",
"Alliance_Tier3_Armory1",
"Alliance_Tier3_Armory2",
"Alliance_Tier3_Barn1",
"Alliance_Tier3_Barn2",
"Alliance_Tier3_Barracks1",
"Alliance_Tier3_Barracks2",
"Alliance_Tier3_Inn1",
"Alliance_Tier3_Inn2",
"Alliance_Tier3_Lumber1",
"Alliance_Tier3_Lumber2",
"Alliance_Tier3_Mage1",
"Alliance_Tier3_Mage2",
"Alliance_Tier3_Stables1",
"Alliance_Tier3_Stables2",
"Alliance_Tier3_Trading1",
"Alliance_Tier3_Trading2",
"Alliance_Tier3_Workshop1",
"Alliance_Tier3_Workshop2",
"AlliedRace-Crest-Highmountain",
"AlliedRace-Crest-Lightforge",
"AlliedRace-Crest-Nightborne",
"AlliedRace-Crest-Voidelf",
"AlliedRace-TraitsBorder",
"AlliedRace-UnlockingFrame-Background",
"AlliedRace-UnlockingFrame-BottomButtonsMouseOverGlow",
"AlliedRace-UnlockingFrame-BottomButtonsSelectionGlow",
"AlliedRace-UnlockingFrame-Female",
"AlliedRace-UnlockingFrame-GenderMouseOverGlow",
"AlliedRace-UnlockingFrame-GenderSelectionGlow",
"AlliedRace-UnlockingFrame-LeftRotation",
"AlliedRace-UnlockingFrame-Male",
"AlliedRace-UnlockingFrame-ModelBackground-Highmountain",
"AlliedRace-UnlockingFrame-ModelBackground-Lightforge",
"AlliedRace-UnlockingFrame-ModelBackground-Nightborne",
"AlliedRace-UnlockingFrame-ModelBackground-Voidelf",
"AlliedRace-UnlockingFrame-ModelFrame",
"AlliedRace-UnlockingFrame-RaceBanner",
"AlliedRace-UnlockingFrame-RightRotation",
"AlliedRace-UnlockingFrame-ZoomIn",
"AlliedRace-UnlockingFrame-ZoomOut",
"AlliedRaces-AllianceHordeBanner",
"Ammunition",
"AncientMana",
"AntoranWastes_Highlight",
"ArchBlob",
"Armor-Fill-End",
"ArtifactQuest",
"ArtifactQuestTurnin",
"Artifacts-Anim-CrackedGround",
"Artifacts-Anim-Glowies",
"Artifacts-Anim-Orb",
"Artifacts-Anim-Sparks",
"Artifacts-BG-Shadow",
"Artifacts-CrestRune-Gold",
"Artifacts-DeathKnightFrost-BG",
"Artifacts-DeathKnightFrost-BG-Rune",
"Artifacts-DeathKnightFrost-FinalIcon",
"Artifacts-DeathKnightFrost-Header",
"Artifacts-DeathKnightFrost-KnowledgeRank",
"Artifacts-DemonHunter-BG",
"Artifacts-DemonHunter-BG-rune",
"Artifacts-DemonHunter-FinalIcon",
"Artifacts-DemonHunter-Header",
"Artifacts-DemonHunter-KnowledgeRank",
"Artifacts-Druid-BG",
"Artifacts-Druid-BG-rune",
"Artifacts-Druid-FinalIcon",
"Artifacts-Druid-Header",
"Artifacts-Druid-KnowledgeRank",
"Artifacts-HeaderBG",
"Artifacts-Hunter-BG",
"Artifacts-Hunter-BG-rune",
"Artifacts-Hunter-FinalIcon",
"Artifacts-Hunter-Header",
"Artifacts-Hunter-KnowledgeRank",
"Artifacts-ItemIconBorder",
"Artifacts-MageArcane-BG",
"Artifacts-MageArcane-BG-rune",
"Artifacts-MageArcane-FinalIcon",
"Artifacts-MageArcane-Header",
"Artifacts-MageArcane-KnowledgeRank",
"Artifacts-Monk-BG",
"Artifacts-Monk-BG-rune",
"Artifacts-Monk-FinalIcon",
"Artifacts-Monk-Header",
"Artifacts-Monk-KnowledgeRank",
"Artifacts-Paladin-BG",
"Artifacts-Paladin-BG-rune",
"Artifacts-Paladin-FinalIcon",
"Artifacts-Paladin-Header",
"Artifacts-Paladin-KnowledgeRank",
"Artifacts-PerkRing-Final",
"Artifacts-PerkRing-Final-Shine",
"Artifacts-PerkRing-GoldMedal",
"Artifacts-PerkRing-Highlight",
"Artifacts-PerkRing-MainProc",
"Artifacts-PerkRing-MainProc-Glow",
"Artifacts-PerkRing-NeutralGlow",
"Artifacts-PerkRing-PurpleGlow",
"Artifacts-PerkRing-Small",
"Artifacts-PerkRing-WhiteGlow",
"Artifacts-PointsBox",
"Artifacts-PointsBoxGreen",
"Artifacts-Priest-BG",
"Artifacts-Priest-BG-rune",
"Artifacts-Priest-FinalIcon",
"Artifacts-Priest-Header",
"Artifacts-Priest-KnowledgeRank",
"Artifacts-PriestShadow-BG",
"Artifacts-PriestShadow-BG-rune",
"Artifacts-PriestShadow-FinalIcon",
"Artifacts-PriestShadow-Header",
"Artifacts-PriestShadow-KnowledgeRank",
"Artifacts-Rogue-BG",
"Artifacts-Rogue-BG-rune",
"Artifacts-Rogue-FinalIcon",
"Artifacts-Rogue-Header",
"Artifacts-Rogue-KnowledgeRank",
"Artifacts-Shaman-BG",
"Artifacts-Shaman-BG-rune",
"Artifacts-Shaman-FinalIcon",
"Artifacts-Shaman-Header",
"Artifacts-Shaman-KnowledgeRank",
"Artifacts-Warlock-BG",
"Artifacts-Warlock-BG-rune",
"Artifacts-Warlock-FinalIcon",
"Artifacts-Warlock-Header",
"Artifacts-Warlock-KnowledgeRank",
"Artifacts-Warrior-BG",
"Artifacts-Warrior-BG-rune",
"Artifacts-Warrior-FinalIcon",
"Artifacts-Warrior-Header",
"Artifacts-Warrior-KnowledgeRank",
"ArtifactsFX-PointSideBurstLeft",
"ArtifactsFX-PointSideBurstLeft-Purple",
"ArtifactsFX-PointSideBurstRight",
"ArtifactsFX-PointSideBurstRight-Purple",
"ArtifactsFX-SpinningGlowys",
"ArtifactsFX-SpinningGlowys-Purple",
"ArtifactsFX-StarBurst",
"ArtifactsFX-StarBurst-Purple",
"ArtifactsFX-Whirls",
"ArtifactsFX-Whirls-Neutral",
"ArtifactsFX-Whirls-Purple",
"ArtifactsFX-YellowRing",
"ArtifactsFX-YellowRing-Neutral",
"ArtifactsFX-YellowRing-Purple",
"Auctioneer",
"AutoQuest-badgeborder",
"AzeriteReady",
"AzeriteSpawning",
"BackArrow-Brown",
"BackupPet-DeadFrame",
"BackupPet-Frame",
"Banker",
"Banner-BgFiligree",
"Banner-FiligreeShadow",
"Banner-SmallFiligree",
"Bar-End",
"Barbershop-Bottom",
"Barbershop-Top",
"BattleBar-Button-Highlight",
"BattleBar-ButtonBG-Divider",
"BattleBar-ButtonBG-EndCap",
"BattleBar-Countdown-Shadow",
"BattleBar-EndCap",
"BattleBar-SwapPetFrame",
"BattleBar-SwapPetFrame-DeadIcon",
"BattleBar-SwapPetFrame-Highlight",
"BattleBar-SwapPetIcon",
"BattleBar-SwapPetShadow",
"BattleHUD-Top",
"BattleHUD-Versus",
"BattleMaster",
"Battlenet-ClientIcon-ANBS",
"Battlenet-ClientIcon-App",
"Battlenet-ClientIcon-D3",
"Battlenet-ClientIcon-DST2",
"Battlenet-ClientIcon-FEN",
"Battlenet-ClientIcon-FORE",
"Battlenet-ClientIcon-GRY",
"Battlenet-ClientIcon-Hero",
"Battlenet-ClientIcon-LAZR",
"Battlenet-ClientIcon-ODIN",
"Battlenet-ClientIcon-OSI",
"Battlenet-ClientIcon-Pro",
"Battlenet-ClientIcon-RTRO",
"Battlenet-ClientIcon-S1",
"Battlenet-ClientIcon-S2",
"Battlenet-ClientIcon-VIPR",
"Battlenet-ClientIcon-W3",
"Battlenet-ClientIcon-WLBY",
"Battlenet-ClientIcon-WTCG",
"Battlenet-ClientIcon-WoW",
"Battlenet-ClientIcon-ZEUS",
"Bonus-ToastBanner",
"BonusChest-BonusTextGlow",
"BonusChest-Burst-Uncommon",
"BonusChest-CircleGlow",
"BonusChest-GreenGlow-Wide",
"BonusChest-ItemBorder-Uncommon",
"BonusChest-KeyholeBurst",
"BonusChest-KeyholeGlow",
"BonusChest-Lock",
"BonusChest-OrangeGlow-Wide",
"BonusChest-OrangeSmoke-Wide",
"BonusChest-Smoke-Uncommon",
"BossBanner-BgBanner-Bottom",
"BossBanner-BgBanner-Mid",
"BossBanner-BgBanner-Top",
"BossBanner-BottomFillagree",
"BossBanner-LeftFillagree",
"BossBanner-PortraitBorder",
"BossBanner-RedFlash",
"BossBanner-RedLightning",
"BossBanner-RightFillagree",
"BossBanner-SkullCircle",
"BossBanner-SkullSpikes",
"BossBanner-TopFillagree",
"BrokenIslesHightlight",
"CacheToast",
"CacheToast-Glow",
"Calendar_Quest",
"Capacitance-Blacksmithing-BG",
"Capacitance-Blacksmithing-IconBG",
"Capacitance-Blacksmithing-IconBorder",
"Capacitance-Blacksmithing-TimerBG",
"Capacitance-Blacksmithing-TimerFill",
"Capacitance-Blacksmithing-TimerFrame",
"Capacitance-General-EmptyFollower",
"Capacitance-General-ItemBorder",
"Capacitance-General-LevelBorder",
"Capacitance-General-LockIcon",
"Capacitance-General-PortraitRing",
"Capacitance-General-WorkOrderActive",
"Capacitance-General-WorkOrderArrow",
"Capacitance-General-WorkOrderBorder",
"Capacitance-General-WorkOrderCheckmark",
"Capacitance-General-WorkOrderEmpty",
"Cast-Bar-End",
"Cast-Bar-Fill-End",
"CastBar",
"ChallengeMode-AffixRing-Lg",
"ChallengeMode-AffixRing-Sm",
"ChallengeMode-Chest",
"ChallengeMode-DungeonIconFrame",
"ChallengeMode-KeystoneFrame",
"ChallengeMode-KeystoneSlotBG",
"ChallengeMode-KeystoneSlotFrame",
"ChallengeMode-KeystoneSlotFrameGlow",
"ChallengeMode-MainTabBg",
"ChallengeMode-RankLineDivider",
"ChallengeMode-RuneBG",
"ChallengeMode-Runes-BL-Glow",
"ChallengeMode-Runes-BR-Glow",
"ChallengeMode-Runes-BackgroundBurst",
"ChallengeMode-Runes-BackgroundCoverGlow",
"ChallengeMode-Runes-CircleGlow",
"ChallengeMode-Runes-GlowBurstLarge",
"ChallengeMode-Runes-GlowLarge",
"ChallengeMode-Runes-GlowSmall",
"ChallengeMode-Runes-InnerCircleGlow",
"ChallengeMode-Runes-L-Glow",
"ChallengeMode-Runes-Large",
"ChallengeMode-Runes-LineGlow",
"ChallengeMode-Runes-R-Glow",
"ChallengeMode-Runes-Shockwave",
"ChallengeMode-Runes-Small",
"ChallengeMode-Runes-SmallCircleGlow",
"ChallengeMode-Runes-T-Glow",
"ChallengeMode-SoftYellowGlow",
"ChallengeMode-SpikeyStar",
"ChallengeMode-ThinDivider",
"ChallengeMode-Timer",
"ChallengeMode-TimerBG",
"ChallengeMode-TimerBG-back",
"ChallengeMode-TimerFill",
"ChallengeMode-WhiteSpikeyGlow",
"ChallengeMode-guild-background",
"ChallengeMode-icon-chest",
"ChallengeMode-icon-redline",
"CharacterCreateDropdown-NineSlice-Center",
"CharacterCreateDropdown-NineSlice-CornerBottomLeft",
"CharacterCreateDropdown-NineSlice-CornerBottomRight",
"CharacterCreateDropdown-NineSlice-CornerTopLeft",
"CharacterCreateDropdown-NineSlice-CornerTopRight",
"ChatBallon",
"ChatBubble-NineSlice-Center",
"ChatBubble-NineSlice-CornerBottomLeft",
"ChatBubble-NineSlice-CornerBottomRight",
"ChatBubble-NineSlice-CornerTopLeft",
"ChatBubble-NineSlice-CornerTopRight",
"ChatBubble-Tail",
"CircleMaskScalable",
"Class",
"ClassHall-BonusIcon-Desaturated",
"ClassHall-Circle-DeathKnight",
"ClassHall-Circle-DemonHunter",
"ClassHall-Circle-Druid",
"ClassHall-Circle-Hunter",
"ClassHall-Circle-Mage",
"ClassHall-Circle-Monk",
"ClassHall-Circle-Paladin",
"ClassHall-Circle-Priest",
"ClassHall-Circle-Rogue",
"ClassHall-Circle-Shaman",
"ClassHall-Circle-Warlock",
"ClassHall-Circle-Warrior",
"ClassHall-CombatAlly",
"ClassHall-CombatIcon-Desaturated",
"ClassHall-LegendaryIcon-Desaturated",
"ClassHall-QuestIcon-Desaturated",
"ClassHall-TreasureIcon-Desaturated",
"ClassHall_Follower-EquipmentBG",
"ClassHall_Follower-EquipmentFrame",
"ClassHall_InfoBoxMission-BackgroundTile",
"ClassHall_InfoBoxMission-Corner",
"ClassHall_ParchmentHeader-End",
"ClassHall_ParchmentHeader-End-2",
"ClassHall_ParchmentHeaderSelect-End",
"ClassHall_ParchmentHeaderSelect-End-2",
"ClassHall_StoneFrame-BackgroundTile",
"ClassOverlay-ComboPoint",
"ClassOverlay-ComboPoint-Off",
"ClassOverlay-Fury",
"ClassOverlay-FuryBG",
"ClassOverlay-HolyPower1off",
"ClassOverlay-HolyPower1on",
"ClassOverlay-HolyPower2off",
"ClassOverlay-HolyPower2on",
"ClassOverlay-HolyPower3off",
"ClassOverlay-HolyPower3on",
"ClassOverlay-HolyPower4off",
"ClassOverlay-HolyPower4on",
"ClassOverlay-HolyPower5off",
"ClassOverlay-HolyPower5on",
"ClassOverlay-HolyPowerBG",
"ClassOverlay-Rune",
"ClassOverlay-RunicPower",
"ClassOverlay-RunicPowerBg",
"ClassTrial-DeathKnight-Ring",
"ClassTrial-Druid-Ring",
"ClassTrial-End-Frame",
"ClassTrial-Hunter-Ring",
"ClassTrial-Mage-Ring",
"ClassTrial-Monk-Ring",
"ClassTrial-Paladin-Ring",
"ClassTrial-Priest-Ring",
"ClassTrial-Rogue-Ring",
"ClassTrial-Shaman-Ring",
"ClassTrial-Timer",
"ClassTrial-Timer-Mid",
"ClassTrial-Timer-RightCorner",
"ClassTrial-Warlock-Ring",
"ClassTrial-Warrior-Ring",
"Coin-Copper",
"Coin-Gold",
"Coin-Silver",
"ComboPoints-AllPointsBG",
"ComboPoints-ComboPoint",
"ComboPoints-ComboPointDash",
"ComboPoints-ComboPointDash-Bg",
"ComboPoints-FX-Circle",
"ComboPoints-FX-Dash",
"ComboPoints-FX-Star",
"ComboPoints-PointBg",
"CommentatorSpellBorder",
"Crop-Corner",
"Crop-Side",
"Crop-Top",
"CrossedFlags",
"CrossedFlagsWithTimer",
"CurrentPlayer-Glow",
"DK-Blood-Rune-CDFill",
"DK-Blood-Rune-Ready",
"DK-BloodUnholy-Rune-CDSpark",
"DK-Frost-Rune-CDFill",
"DK-Frost-Rune-CDSpark",
"DK-Frost-Rune-Ready",
"DK-Rune-CD",
"DK-Rune-Glow",
"DK-Unholy-Rune-CDFill",
"DK-Unholy-Rune-Ready",
"DarkTutorialFrameBackground",
"Darklink",
"Darklink-active",
"Darklink-ball",
"Darklink-blackinside",
"Darklink-glow",
"Darkstone1",
"Darkstone2",
"Darkstone3",
"Darkstone4",
"Darkstone5",
"Darkstone6",
"Darkstone7",
"Darktrait-Glow",
"Darktrait-backglow",
"Darktrait-border",
"Darktrait-border-selected",
"DeathIcon",
"DemonInvasion1",
"DemonInvasion2",
"DemonInvasion3",
"DemonInvasion4",
"DemonInvasion5",
"DemonShip",
"DemonShip_East",
"Disablelink",
"DruidEclipse-Arrow",
"DruidEclipse-BaseBar",
"DruidEclipse-BaseMoon",
"DruidEclipse-BaseSun",
"DruidEclipse-Diamond",
"DruidEclipse-Line",
"DruidEclipse-LunarBar",
"DruidEclipse-LunarCover",
"DruidEclipse-LunarMoon",
"DruidEclipse-LunarSun",
"DruidEclipse-SolarBar",
"DruidEclipse-SolarCover",
"DruidEclipse-SolarMoon",
"DruidEclipse-SolarSun",
"Dungeon",
"DungeonSkull",
"DungeonTargetIndicator",
"FXAM-QuestBang",
"FXAM-SmallSpikeyGlow",
"Flag-1",
"Flag-2",
"Flag-outline",
"FlightMaster",
"FlightMaster_Argus-Taxi_Frame_Gray",
"FlightMaster_Argus-Taxi_Frame_Green",
"FlightMaster_Argus-Taxi_Frame_Yellow",
"FlightMaster_VindicaarArgus-Taxi_Frame_Gray",
"FlightMaster_VindicaarArgus-Taxi_Frame_Green",
"FlightMaster_VindicaarArgus-Taxi_Frame_Yellow",
"FlightMaster_VindicaarMacAree-Taxi_Frame_Gray",
"FlightMaster_VindicaarMacAree-Taxi_Frame_Green",
"FlightMaster_VindicaarMacAree-Taxi_Frame_Yellow",
"FlightMaster_VindicaarStygianWake-Taxi_Frame_Gray",
"FlightMaster_VindicaarStygianWake-Taxi_Frame_Green",
"FlightMaster_VindicaarStygianWake-Taxi_Frame_Yellow",
"FlightPath",
"Focus",
"Focus-Tracker",
"FogofWar",
"FontStyle_BlueGradient",
"FontStyle_Garrisons",
"FontStyle_IronHordeMetal",
"FontStyle_Legion",
"FontStyle_Metal",
"FontStyle_Parchment",
"Food",
"Forge-AppearanceStrip",
"Forge-Background",
"Forge-ColorSwatch",
"Forge-ColorSwatchBackground",
"Forge-ColorSwatchBorder",
"Forge-ColorSwatchHighlight",
"Forge-ColorSwatchSelection",
"Forge-Lock",
"ForgeBorder-CornerBottomLeft",
"ForgeBorder-CornerBottomRight",
"ForgeBorder-CornerTopRight",
"Frame-Timer",
"FullAlert-BigSpike",
"FullAlert-FrameGlow",
"FullAlert-SoftCurveGlow",
"FullAlert-YellowCurveGlow",
"GarLanding-Bottom",
"GarLanding-Left",
"GarLanding-Right",
"GarMission_ChestPercentageShadow",
"GarrBuilding_Alchemy_1_A_Info",
"GarrBuilding_Alchemy_1_A_Map",
"GarrBuilding_Alchemy_1_H_Info",
"GarrBuilding_Alchemy_1_H_Map",
"GarrBuilding_Alchemy_2_A_Info",
"GarrBuilding_Alchemy_2_A_Map",
"GarrBuilding_Alchemy_2_H_Info",
"GarrBuilding_Alchemy_2_H_Map",
"GarrBuilding_Alchemy_3_A_Info",
"GarrBuilding_Alchemy_3_A_Map",
"GarrBuilding_Alchemy_3_H_Info",
"GarrBuilding_Alchemy_3_H_Map",
"GarrBuilding_Armory_1_A_Info",
"GarrBuilding_Armory_1_A_Map",
"GarrBuilding_Armory_1_H_Info",
"GarrBuilding_Armory_1_H_Map",
"GarrBuilding_Armory_2_A_Info",
"GarrBuilding_Armory_2_A_Map",
"GarrBuilding_Armory_2_H_Info",
"GarrBuilding_Armory_2_H_Map",
"GarrBuilding_Armory_3_A_Info",
"GarrBuilding_Armory_3_A_Map",
"GarrBuilding_Armory_3_H_Info",
"GarrBuilding_Armory_3_H_Map",
"GarrBuilding_Barn_1_A_Info",
"GarrBuilding_Barn_1_A_Map",
"GarrBuilding_Barn_1_H_Info",
"GarrBuilding_Barn_1_H_Map",
"GarrBuilding_Barn_2_A_Info",
"GarrBuilding_Barn_2_A_Map",
"GarrBuilding_Barn_2_H_Info",
"GarrBuilding_Barn_2_H_Map",
"GarrBuilding_Barn_3_A_Info",
"GarrBuilding_Barn_3_A_Map",
"GarrBuilding_Barn_3_H_Info",
"GarrBuilding_Barn_3_H_Map",
"GarrBuilding_Barracks_1_A_Info",
"GarrBuilding_Barracks_1_A_Map",
"GarrBuilding_Barracks_1_H_Info",
"GarrBuilding_Barracks_1_H_Map",
"GarrBuilding_Barracks_2_A_Info",
"GarrBuilding_Barracks_2_A_Map",
"GarrBuilding_Barracks_2_H_Info",
"GarrBuilding_Barracks_2_H_Map",
"GarrBuilding_Barracks_3_A_Info",
"GarrBuilding_Barracks_3_A_Map",
"GarrBuilding_Barracks_3_H_Info",
"GarrBuilding_Barracks_3_H_Map",
"GarrBuilding_Blacksmith_1_A_Info",
"GarrBuilding_Blacksmith_1_A_Map",
"GarrBuilding_Blacksmith_1_H_Info",
"GarrBuilding_Blacksmith_1_H_Map",
"GarrBuilding_Blacksmith_2_A_Info",
"GarrBuilding_Blacksmith_2_A_Map",
"GarrBuilding_Blacksmith_2_H_Info",
"GarrBuilding_Blacksmith_2_H_Map",
"GarrBuilding_Blacksmith_3_A_Info",
"GarrBuilding_Blacksmith_3_A_Map",
"GarrBuilding_Blacksmith_3_H_Info",
"GarrBuilding_Blacksmith_3_H_Map",
"GarrBuilding_Default_Info",
"GarrBuilding_Default_Map",
"GarrBuilding_EmptyPlot_1_A_Info",
"GarrBuilding_EmptyPlot_A_1",
"GarrBuilding_EmptyPlot_A_2",
"GarrBuilding_EmptyPlot_A_3",
"GarrBuilding_EmptyPlot_H_1",
"GarrBuilding_EmptyPlot_H_2",
"GarrBuilding_EmptyPlot_H_3",
"GarrBuilding_Enchanting_1_A_Info",
"GarrBuilding_Enchanting_1_A_Map",
"GarrBuilding_Enchanting_1_H_Info",
"GarrBuilding_Enchanting_1_H_Map",
"GarrBuilding_Enchanting_2_A_Info",
"GarrBuilding_Enchanting_2_A_Map",
"GarrBuilding_Enchanting_2_H_Info",
"GarrBuilding_Enchanting_2_H_Map",
"GarrBuilding_Enchanting_3_A_Info",
"GarrBuilding_Enchanting_3_A_Map",
"GarrBuilding_Enchanting_3_H_Info",
"GarrBuilding_Enchanting_3_H_Map",
"GarrBuilding_Engineering_1_A_Info",
"GarrBuilding_Engineering_1_A_Map",
"GarrBuilding_Engineering_1_H_Info",
"GarrBuilding_Engineering_1_H_Map",
"GarrBuilding_Engineering_2_A_Info",
"GarrBuilding_Engineering_2_A_Map",
"GarrBuilding_Engineering_2_H_Info",
"GarrBuilding_Engineering_2_H_Map",
"GarrBuilding_Engineering_3_A_Info",
"GarrBuilding_Engineering_3_A_Map",
"GarrBuilding_Engineering_3_H_Info",
"GarrBuilding_Engineering_3_H_Map",
"GarrBuilding_Farm_1_A_Info",
"GarrBuilding_Farm_1_A_Map",
"GarrBuilding_Farm_1_H_Info",
"GarrBuilding_Farm_1_H_Map",
"GarrBuilding_Farm_2_A_Info",
"GarrBuilding_Farm_2_A_Map",
"GarrBuilding_Farm_3_A_Info",
"GarrBuilding_Farm_3_A_Map",
"GarrBuilding_Fishing_1_A_Info",
"GarrBuilding_Fishing_1_A_Map",
"GarrBuilding_Fishing_1_H_Info",
"GarrBuilding_Fishing_1_H_Map",
"GarrBuilding_Fishing_2_A_Info",
"GarrBuilding_Fishing_2_A_Map",
"GarrBuilding_Fishing_2_H_Info",
"GarrBuilding_Fishing_2_H_Map",
"GarrBuilding_Fishing_3_A_Info",
"GarrBuilding_Fishing_3_A_Map",
"GarrBuilding_Fishing_3_H_Info",
"GarrBuilding_Fishing_3_H_Map",
"GarrBuilding_Inn_1_A_Info",
"GarrBuilding_Inn_1_A_Map",
"GarrBuilding_Inn_1_H_Info",
"GarrBuilding_Inn_1_H_Map",
"GarrBuilding_Inn_2_A_Info",
"GarrBuilding_Inn_2_A_Map",
"GarrBuilding_Inn_2_H_Info",
"GarrBuilding_Inn_2_H_Map",
"GarrBuilding_Inn_3_A_Info",
"GarrBuilding_Inn_3_A_Map",
"GarrBuilding_Inn_3_H_Info",
"GarrBuilding_Inn_3_H_Map",
"GarrBuilding_Inscription_1_A_Info",
"GarrBuilding_Inscription_1_A_Map",
"GarrBuilding_Inscription_1_H_Info",
"GarrBuilding_Inscription_1_H_Map",
"GarrBuilding_Inscription_2_A_Info",
"GarrBuilding_Inscription_2_A_Map",
"GarrBuilding_Inscription_2_H_Info",
"GarrBuilding_Inscription_2_H_Map",
"GarrBuilding_Inscription_3_A_Info",
"GarrBuilding_Inscription_3_A_Map",
"GarrBuilding_Inscription_3_H_Info",
"GarrBuilding_Inscription_3_H_Map",
"GarrBuilding_Jewelcrafting_1_A_Info",
"GarrBuilding_Jewelcrafting_1_A_Map",
"GarrBuilding_Jewelcrafting_1_H_Info",
"GarrBuilding_Jewelcrafting_1_H_Map",
"GarrBuilding_Jewelcrafting_2_A_Info",
"GarrBuilding_Jewelcrafting_2_A_Map",
"GarrBuilding_Jewelcrafting_2_H_Info",
"GarrBuilding_Jewelcrafting_2_H_Map",
"GarrBuilding_Jewelcrafting_3_A_Info",
"GarrBuilding_Jewelcrafting_3_A_Map",
"GarrBuilding_Jewelcrafting_3_H_Info",
"GarrBuilding_Jewelcrafting_3_H_Map",
"GarrBuilding_Leatherworking_1_A_Info",
"GarrBuilding_Leatherworking_1_A_Map",
"GarrBuilding_Leatherworking_1_H_Info",
"GarrBuilding_Leatherworking_1_H_Map",
"GarrBuilding_Leatherworking_2_A_Info",
"GarrBuilding_Leatherworking_2_A_Map",
"GarrBuilding_Leatherworking_2_H_Info",
"GarrBuilding_Leatherworking_2_H_Map",
"GarrBuilding_Leatherworking_3_A_Info",
"GarrBuilding_Leatherworking_3_A_Map",
"GarrBuilding_Leatherworking_3_H_Info",
"GarrBuilding_Leatherworking_3_H_Map",
"GarrBuilding_LumberMill_1_A_Info",
"GarrBuilding_LumberMill_1_A_Map",
"GarrBuilding_LumberMill_1_H_Info",
"GarrBuilding_LumberMill_1_H_Map",
"GarrBuilding_LumberMill_2_A_Info",
"GarrBuilding_LumberMill_2_A_Map",
"GarrBuilding_LumberMill_2_H_Info",
"GarrBuilding_LumberMill_2_H_Map",
"GarrBuilding_LumberMill_3_A_Info",
"GarrBuilding_LumberMill_3_A_Map",
"GarrBuilding_LumberMill_3_H_Info",
"GarrBuilding_LumberMill_3_H_Map",
"GarrBuilding_MageTower_1_A_Info",
"GarrBuilding_MageTower_1_A_Map",
"GarrBuilding_MageTower_1_H_Info",
"GarrBuilding_MageTower_1_H_Map",
"GarrBuilding_MageTower_2_A_Info",
"GarrBuilding_MageTower_2_A_Map",
"GarrBuilding_MageTower_2_H_Info",
"GarrBuilding_MageTower_2_H_Map",
"GarrBuilding_MageTower_3_A_Info",
"GarrBuilding_MageTower_3_A_Map",
"GarrBuilding_MageTower_3_H_Info",
"GarrBuilding_MageTower_3_H_Map",
"GarrBuilding_Mine_1_A_Info",
"GarrBuilding_Mine_1_A_Map",
"GarrBuilding_Mine_1_H_Info",
"GarrBuilding_Mine_1_H_Map",
"GarrBuilding_Mine_2_A_Info",
"GarrBuilding_Mine_2_A_Map",
"GarrBuilding_Mine_3_A_Info",
"GarrBuilding_Mine_3_A_Map",
"GarrBuilding_PetStable_1_A_Info",
"GarrBuilding_PetStable_1_A_Map",
"GarrBuilding_PetStable_1_H_Info",
"GarrBuilding_PetStable_1_H_Map",
"GarrBuilding_SalvageYard_1_A_Info",
"GarrBuilding_SalvageYard_1_A_Map",
"GarrBuilding_SalvageYard_1_H_Info",
"GarrBuilding_SalvageYard_1_H_Map",
"GarrBuilding_SparringArena_1_A_Info",
"GarrBuilding_SparringArena_1_A_Map",
"GarrBuilding_SparringArena_1_H_Info",
"GarrBuilding_SparringArena_1_H_Map",
"GarrBuilding_SparringArena_2_A_Info",
"GarrBuilding_SparringArena_2_A_Map",
"GarrBuilding_SparringArena_2_H_Info",
"GarrBuilding_SparringArena_2_H_Map",
"GarrBuilding_SparringArena_3_A_Info",
"GarrBuilding_SparringArena_3_A_Map",
"GarrBuilding_SparringArena_3_H_Info",
"GarrBuilding_SparringArena_3_H_Map",
"GarrBuilding_Stables_1_A_Info",
"GarrBuilding_Stables_1_A_Map",
"GarrBuilding_Stables_1_H_Info",
"GarrBuilding_Stables_1_H_Map",
"GarrBuilding_Stables_2_A_Info",
"GarrBuilding_Stables_2_A_Map",
"GarrBuilding_Stables_2_H_Info",
"GarrBuilding_Stables_2_H_Map",
"GarrBuilding_Stables_3_A_Info",
"GarrBuilding_Stables_3_A_Map",
"GarrBuilding_Stables_3_H_Info",
"GarrBuilding_Stables_3_H_Map",
"GarrBuilding_Storehouse_1_A_Info",
"GarrBuilding_Storehouse_1_A_Map",
"GarrBuilding_Storehouse_1_H_Info",
"GarrBuilding_Storehouse_1_H_Map",
"GarrBuilding_Tailoring_1_A_Info",
"GarrBuilding_Tailoring_1_A_Map",
"GarrBuilding_Tailoring_1_H_Info",
"GarrBuilding_Tailoring_1_H_Map",
"GarrBuilding_Tailoring_2_A_Info",
"GarrBuilding_Tailoring_2_A_Map",
"GarrBuilding_Tailoring_2_H_Info",
"GarrBuilding_Tailoring_2_H_Map",
"GarrBuilding_Tailoring_3_A_Info",
"GarrBuilding_Tailoring_3_A_Map",
"GarrBuilding_Tailoring_3_H_Info",
"GarrBuilding_Tailoring_3_H_Map",
"GarrBuilding_TownHall_1_A_Info",
"GarrBuilding_TownHall_1_A_Map",
"GarrBuilding_TownHall_1_H_Info",
"GarrBuilding_TownHall_1_H_Map",
"GarrBuilding_TownHall_2_A_Info",
"GarrBuilding_TownHall_2_A_Map",
"GarrBuilding_TownHall_2_H_Info",
"GarrBuilding_TownHall_2_H_Map",
"GarrBuilding_TownHall_3_A_Info",
"GarrBuilding_TownHall_3_A_Map",
"GarrBuilding_TownHall_3_H_Info",
"GarrBuilding_TownHall_3_H_Map",
"GarrBuilding_TradingPost_1_A_Info",
"GarrBuilding_TradingPost_1_A_Map",
"GarrBuilding_TradingPost_1_H_Info",
"GarrBuilding_TradingPost_1_H_Map",
"GarrBuilding_TradingPost_2_A_Info",
"GarrBuilding_TradingPost_2_A_Map",
"GarrBuilding_TradingPost_2_H_Info",
"GarrBuilding_TradingPost_2_H_Map",
"GarrBuilding_TradingPost_3_A_Info",
"GarrBuilding_TradingPost_3_A_Map",
"GarrBuilding_TradingPost_3_H_Info",
"GarrBuilding_TradingPost_3_H_Map",
"GarrBuilding_Workshop_1_A_Info",
"GarrBuilding_Workshop_1_A_Map",
"GarrBuilding_Workshop_1_H_Info",
"GarrBuilding_Workshop_1_H_Map",
"GarrBuilding_Workshop_2_A_Info",
"GarrBuilding_Workshop_2_A_Map",
"GarrBuilding_Workshop_2_H_Info",
"GarrBuilding_Workshop_2_H_Map",
"GarrBuilding_Workshop_3_A_Info",
"GarrBuilding_Workshop_3_A_Map",
"GarrBuilding_Workshop_3_H_Info",
"GarrBuilding_Workshop_3_H_Map",
"GarrFollower-Shadow",
"GarrLanding-Building-Complete",
"GarrLanding-Building-InProgress",
"GarrLanding-CircleGlow",
"GarrLanding-FollowerScrollFrame",
"GarrLanding-HeaderBar",
"GarrLanding-InvasionBadge",
"GarrLanding-InvasionBadge-Glow",
"GarrLanding-MiddleTile",
"GarrLanding-MinimapAlertBG",
"GarrLanding-MinimapIcon-Alliance-Down",
"GarrLanding-MinimapIcon-Alliance-Up",
"GarrLanding-MinimapIcon-Horde-Down",
"GarrLanding-MinimapIcon-Horde-Up",
"GarrLanding-Mission-Complete",
"GarrLanding-Mission-InProgress",
"GarrLanding-MissionListBG",
"GarrLanding-ShipMission-Complete",
"GarrLanding-ShipMission-InProgress",
"GarrLanding-ShipmentCompleteGlow",
"GarrLanding-SideToast-Glow",
"GarrLanding-Tab-Bottom-Highlight",
"GarrLanding-Tab-Bottom-Highlight-Left",
"GarrLanding-Tab-Bottom-Highlight-Right",
"GarrLanding-Tab-Bottom-Selected",
"GarrLanding-Tab-Bottom-Selected-Left",
"GarrLanding-Tab-Bottom-Selected-Right",
"GarrLanding-Tab-Bottom-Unselected",
"GarrLanding-Tab-Bottom-Unselected-Left",
"GarrLanding-Tab-Bottom-Unselected-Right",
"GarrLanding-Top",
"GarrLanding-TopTabHighlight",
"GarrLanding-TopTabSelected",
"GarrLanding-TopTabUnselected",
"GarrLanding-TradeskillTimer-BG",
"GarrLanding-TradeskillTimer-Border",
"GarrLanding-TradeskillTimer-ParchmentBG",
"GarrLanding-lowerleft",
"GarrLanding-lowerright",
"GarrLanding-upperleft",
"GarrLanding-upperright",
"GarrLandingList-CostBG",
"GarrLanding_RewardsListBG",
"GarrLanding_RewardsShadow",
"GarrLanding_Watermark-Tradeskill",
"GarrMission-AbilityHighlight",
"GarrMission-AbilityHighlight-Error",
"GarrMission-AllianceChest",
"GarrMission-FollowerItemBg",
"GarrMission-HordeChest",
"GarrMission-NeutralChest",
"GarrMissionLocation-Argus-List",
"GarrMissionLocation-Azsuna-List",
"GarrMissionLocation-Dalaran-List",
"GarrMissionLocation-FrostfireRidge-List",
"GarrMissionLocation-Gorgrond-List",
"GarrMissionLocation-Highmountain-List",
"GarrMissionLocation-Legion-List",
"GarrMissionLocation-Nagrand-List",
"GarrMissionLocation-ShadowmoonValley-List",
"GarrMissionLocation-SpiresofArak-List",
"GarrMissionLocation-Stormheim-List",
"GarrMissionLocation-Suramar-List",
"GarrMissionLocation-Talador-List",
"GarrMissionLocation-TannanJungle-List",
"GarrMissionLocation-Valsharah-List",
"GarrMission_Bg-DarkEdgeCorner",
"GarrMission_CheckGlow",
"GarrMission_ChestOpenTextGlow",
"GarrMission_ClassIcon-ArgussianReach",
"GarrMission_ClassIcon-ArmyoftheLight",
"GarrMission_ClassIcon-DeathKnight",
"GarrMission_ClassIcon-DeathKnight-Blood",
"GarrMission_ClassIcon-DeathKnight-Frost",
"GarrMission_ClassIcon-DeathKnight-Unholy",
"GarrMission_ClassIcon-DemonHunter-Havoc",
"GarrMission_ClassIcon-DemonHunter-Outcast",
"GarrMission_ClassIcon-DemonHunter-Vengeance",
"GarrMission_ClassIcon-Druid",
"GarrMission_ClassIcon-Druid-Balance",
"GarrMission_ClassIcon-Druid-Feral",
"GarrMission_ClassIcon-Druid-Guardian",
"GarrMission_ClassIcon-Druid-Restoration",
"GarrMission_ClassIcon-Hunter",
"GarrMission_ClassIcon-Hunter-BeastMastery",
"GarrMission_ClassIcon-Hunter-Marksmanship",
"GarrMission_ClassIcon-Hunter-Survival",
"GarrMission_ClassIcon-Karazhan",
"GarrMission_ClassIcon-Mage",
"GarrMission_ClassIcon-Mage-Arcane",
"GarrMission_ClassIcon-Mage-Fire",
"GarrMission_ClassIcon-Mage-Frost",
"GarrMission_ClassIcon-Monk",
"GarrMission_ClassIcon-Monk-Brewmaster",
"GarrMission_ClassIcon-Monk-Mistweaver",
"GarrMission_ClassIcon-Monk-Windwalker",
"GarrMission_ClassIcon-Paladin",
"GarrMission_ClassIcon-Paladin-Holy",
"GarrMission_ClassIcon-Paladin-Protection",
"GarrMission_ClassIcon-Paladin-Retribution",
"GarrMission_ClassIcon-Priest",
"GarrMission_ClassIcon-Priest-Discipline",
"GarrMission_ClassIcon-Priest-Holy",
"GarrMission_ClassIcon-Priest-Shadow",
"GarrMission_ClassIcon-Rogue",
"GarrMission_ClassIcon-Rogue-Assassination",
"GarrMission_ClassIcon-Rogue-Outlaw",
"GarrMission_ClassIcon-Rogue-Subtlety",
"GarrMission_ClassIcon-Shaman",
"GarrMission_ClassIcon-Shaman-Elemental",
"GarrMission_ClassIcon-Shaman-Enhancement",
"GarrMission_ClassIcon-Shaman-Restoration",
"GarrMission_ClassIcon-Voidscarred",
"GarrMission_ClassIcon-Warlock",
"GarrMission_ClassIcon-Warlock-Affliction",
"GarrMission_ClassIcon-Warlock-Demonology",
"GarrMission_ClassIcon-Warlock-Destruction",
"GarrMission_ClassIcon-Warrior",
"GarrMission_ClassIcon-Warrior-Arms",
"GarrMission_ClassIcon-Warrior-Fury",
"GarrMission_ClassIcon-Warrior-Protection",
"GarrMission_CounterCheck",
"GarrMission_CounterHalfCheck",
"GarrMission_CurrencyIcon-Material",
"GarrMission_CurrencyIcon-Salvage",
"GarrMission_CurrencyIcon-Xp",
"GarrMission_CurrentEncounter-Glow",
"GarrMission_CurrentEncounter-SpikeyGlow",
"GarrMission_EncounterAbilityBorder",
"GarrMission_EncounterAbilityBorder-Lg",
"GarrMission_EncounterBar-BG",
"GarrMission_EncounterBar-CheckMark",
"GarrMission_EncounterBar-CheckMark-Left",
"GarrMission_EncounterBar-CheckMark-Right",
"GarrMission_EncounterBar-CheckMarkCircleSwipe",
"GarrMission_EncounterBar-Elite",
"GarrMission_EncounterBar-End",
"GarrMission_EncounterBar-Fill",
"GarrMission_EncounterBar-PortraitRing",
"GarrMission_EncounterBar-Spark",
"GarrMission_EncounterBar-Xbg",
"GarrMission_EncounterBar-Xleft",
"GarrMission_EncounterBar-Xright",
"GarrMission_FollowerAbilityRollout",
"GarrMission_FollowerListButton",
"GarrMission_FollowerListButton-Highlight",
"GarrMission_FollowerListButton-Select",
"GarrMission_FollowerPageHeaderBG",
"GarrMission_FollowerPartyBox_Lg",
"GarrMission_FollowerPartyBox_Sm",
"GarrMission_IconLevelBG",
"GarrMission_ItemFrame",
"GarrMission_LevelUpBanner",
"GarrMission_ListGlow-Highlight",
"GarrMission_ListGlow-Select",
"GarrMission_LocationCover-Side",
"GarrMission_MissionCompleteChanceBg",
"GarrMission_MissionCostStartButtonBg",
"GarrMission_MissionIcon-Alchemy",
"GarrMission_MissionIcon-Blacksmithing",
"GarrMission_MissionIcon-Combat",
"GarrMission_MissionIcon-Construction",
"GarrMission_MissionIcon-Defense",
"GarrMission_MissionIcon-Enchanting",
"GarrMission_MissionIcon-Engineering",
"GarrMission_MissionIcon-Exploration",
"GarrMission_MissionIcon-Generic",
"GarrMission_MissionIcon-Inscription",
"GarrMission_MissionIcon-Jewelcrafting",
"GarrMission_MissionIcon-Leatherworking",
"GarrMission_MissionIcon-Logistics",
"GarrMission_MissionIcon-Patrol",
"GarrMission_MissionIcon-Provision",
"GarrMission_MissionIcon-Recruit",
"GarrMission_MissionIcon-Salvage",
"GarrMission_MissionIcon-Siege",
"GarrMission_MissionIcon-Tailoring",
"GarrMission_MissionIcon-Trading",
"GarrMission_MissionIcon-Training",
"GarrMission_MissionIcon-Wildlife",
"GarrMission_MissionParchment",
"GarrMission_MissionStart",
"GarrMission_MissionTooltipAway",
"GarrMission_MissionTooltipWorking",
"GarrMission_ParchmentHeader-End",
"GarrMission_ParchmentHeaderSelect-End",
"GarrMission_PartyBuffAbilityBorder",
"GarrMission_PartyBuffsBG",
"GarrMission_PlayerLootFrame",
"GarrMission_PortraitRing",
"GarrMission_PortraitRing_Darkener",
"GarrMission_PortraitRing_Empty",
"GarrMission_PortraitRing_Enemy",
"GarrMission_PortraitRing_Glow",
"GarrMission_PortraitRing_Highlight",
"GarrMission_PortraitRing_LevelBorder",
"GarrMission_PortraitRing_Quality",
"GarrMission_PortraitRing_iLvlBorder",
"GarrMission_RareGlowBG",
"GarrMission_RareOverlay",
"GarrMission_RewardsBG",
"GarrMission_RewardsBG-Desaturate",
"GarrMission_RewardsBanner",
"GarrMission_RewardsBanner-Desaturate",
"GarrMission_RewardsBorder-Corner",
"GarrMission_RewardsBorder-Corner-Desaturate",
"GarrMission_RewardsBox_Shadow",
"GarrMission_RewardsListBG",
"GarrMission_RewardsShadow",
"GarrMission_Silhouettes-1Alliance",
"GarrMission_Silhouettes-1Horde",
"GarrMission_SingleModelBG",
"GarrMission_StartMissionFrame",
"GarrMission_TabGlow",
"GarrMission_TopBorderCorner",
"GarrMission_TopBorderCorner-Highlight",
"GarrMission_TopBorderCorner-Select",
"GarrMission_UsefulAbilityIcon",
"GarrMission_WeakEncounterAbilityBorder",
"GarrMission_WeakEncounterAbilityBorder-Lg",
"GarrMission_XPBarBig-End",
"GarrMission_XPBarBig-LevelBorder",
"GarrMission_XPBarBig-Mid",
"Garr_BuildFX-Glow",
"Garr_BuildFX-Lines",
"Garr_BuildIcon",
"Garr_Building-AddFollowerPlus",
"Garr_BuildingConfirmation",
"Garr_BuildingIconRing_",
"Garr_BuildingIconTimerBG",
"Garr_BuildingIconTimerFill",
"Garr_BuildingInfoShadow",
"Garr_BuildingPlacementExplosion",
"Garr_BuildingShadowOverlay",
"Garr_BuildingTimerBG",
"Garr_BuildingTimerFill",
"Garr_BuildingTimerGlow",
"Garr_BuildingUpgradeExplosion",
"Garr_Building_MaterialFrame",
"Garr_CostBar",
"Garr_FollowerPortrait_Bg",
"Garr_FollowerPortrait_Ring",
"Garr_FollowerPortrait_TimerBG",
"Garr_FollowerPortrait_TimerFill",
"Garr_FollowerToast-Epic",
"Garr_FollowerToast-Rare",
"Garr_FollowerToast-Uncommon",
"Garr_InfoBox-BackgroundTile",
"Garr_InfoBox-Corner",
"Garr_InfoBox-CornerShadow",
"Garr_InfoBoxBorder-BigBottomCorner",
"Garr_InfoBoxBorder-Corner",
"Garr_InfoBoxBorder-FiligreeCorner",
"Garr_InfoBoxBorderMission-Corner",
"Garr_InfoBoxMission-BackgroundTile",
"Garr_InfoBoxMission-Corner",
"Garr_LevelBadgeGlow",
"Garr_LevelBadge_1",
"Garr_LevelBadge_2",
"Garr_LevelBadge_3",
"Garr_LevelUpgradeArrow",
"Garr_LevelUpgradeLocked",
"Garr_ListButton",
"Garr_ListButton-Highlight",
"Garr_ListButton-Selection",
"Garr_ListTab",
"Garr_ListTab-Highlight",
"Garr_ListTab-Select",
"Garr_LockedBuilding",
"Garr_Map_Frostfire1_H",
"Garr_Map_Frostfire2_H",
"Garr_Map_Frostfire3_H",
"Garr_Map_Frostfire4_H",
"Garr_Map_Shadowmoon1_A",
"Garr_Map_Shadowmoon2_A",
"Garr_Map_Shadowmoon3_A",
"Garr_Map_Shadowmoon4_A",
"Garr_MaterialIcon",
"Garr_MissionFX-Glow",
"Garr_MissionFX-Lines",
"Garr_MissionList-CostBG",
"Garr_MissionList-IconBG",
"Garr_MissionToast",
"Garr_MissionToast-Blank",
"Garr_MissionToast-IconBG",
"Garr_Mission_MaterialFrame",
"Garr_MonumentLocked",
"Garr_MonumentOpen",
"Garr_NotificationGlow",
"Garr_PlanIcon-List",
"Garr_PlansRequiredIcon",
"Garr_Plot_Frostfire_H_1",
"Garr_Plot_Frostfire_H_2",
"Garr_Plot_Frostfire_H_3",
"Garr_Plot_Frostfire_H_4",
"Garr_Plot_Glow_1",
"Garr_Plot_Glow_2",
"Garr_Plot_Glow_3",
"Garr_Plot_Glow_4",
"Garr_Plot_Shadowmoon_A_1",
"Garr_Plot_Shadowmoon_A_2",
"Garr_Plot_Shadowmoon_A_3",
"Garr_Plot_Shadowmoon_A_4",
"Garr_Specialization_FrameLeft",
"Garr_Specialization_FrameMid",
"Garr_Specialization_IconBorder",
"Garr_Specialization_IconSelected",
"Garr_SwapIcon",
"Garr_Toast",
"Garr_TownHallBanner_Left",
"Garr_TownHallBanner_LevelFiligree",
"Garr_TownHallBanner_Mid",
"Garr_TownHallBanner_Right",
"Garr_TreasureIcon",
"Garr_UpgradeBanner",
"Garr_UpgradeFX-Glow",
"Garr_UpgradeIcon",
"Garr_UpgradeIconTimerBG",
"Garr_UpgradeIconTimerFill",
"Garr_UpgradeTimerBG",
"Garr_UpgradeTimerFill",
"Garr_UpgradeTimerGlow",
"Garr_WoodFrame-BackgroundTile",
"Garr_WoodFrameCorner",
"Garr_XPBar_Left",
"Garr_XPBar_Nub",
"GarrisonFX-StarBurst",
"GarrisonFX_BlueFlare",
"GarrisonTroops-Health",
"GarrisonTroops-Health-Consume",
"Gear",
"GeneralFrame-HorizontalBar-Left",
"GeneralFrame-HorizontalBar-Right",
"GeneralFrame-InsetFrame-BottomLeft",
"GeneralFrame-InsetFrame-BottomRight",
"GeneralFrame-InsetFrame-TopLeft",
"GeneralFrame-InsetFrame-TopRight",
"Glues-WoW-LegionLogo",
"Glues-WoW-LegionLogo_cn",
"Glues-WoW-LegionLogo_tw",
"GlyphIcon-Spellbook",
"GreenCross",
"Headhunter_AbilityBorderGlow",
"Headhunter_BG",
"Headhunter_LineHeader",
"HealerBadge",
"Healing-BG",
"HealingDampening",
"Health-Bar-End",
"Health_End",
"Horde_Tier1_Arena1",
"Horde_Tier1_Arena2",
"Horde_Tier1_Armory1",
"Horde_Tier1_Armory2",
"Horde_Tier1_Barn1",
"Horde_Tier1_Barn2",
"Horde_Tier1_Barracks1",
"Horde_Tier1_Barracks2",
"Horde_Tier1_Farm1",
"Horde_Tier1_Fishing1",
"Horde_Tier1_Inn1",
"Horde_Tier1_Inn2",
"Horde_Tier1_Lumber1",
"Horde_Tier1_Lumber2",
"Horde_Tier1_Mage1",
"Horde_Tier1_Mage2",
"Horde_Tier1_Mine1",
"Horde_Tier1_Profession1",
"Horde_Tier1_Profession2",
"Horde_Tier1_Profession3",
"Horde_Tier1_Stables1",
"Horde_Tier1_Stables2",
"Horde_Tier1_Trading1",
"Horde_Tier1_Trading2",
"Horde_Tier1_Workshop1",
"Horde_Tier1_Workshop2",
"Horde_Tier2_Arena1",
"Horde_Tier2_Arena2",
"Horde_Tier2_Armory1",
"Horde_Tier2_Armory2",
"Horde_Tier2_Barn1",
"Horde_Tier2_Barn2",
"Horde_Tier2_Barracks1",
"Horde_Tier2_Barracks2",
"Horde_Tier2_Inn1",
"Horde_Tier2_Inn2",
"Horde_Tier2_Lumber1",
"Horde_Tier2_Lumber2",
"Horde_Tier2_Mage1",
"Horde_Tier2_Mage2",
"Horde_Tier2_Stables1",
"Horde_Tier2_Stables2",
"Horde_Tier2_Trading1",
"Horde_Tier2_Trading2",
"Horde_Tier2_Workshop1",
"Horde_Tier2_Workshop2",
"Horde_Tier3_Arena1",
"Horde_Tier3_Arena2",
"Horde_Tier3_Armory1",
"Horde_Tier3_Armory2",
"Horde_Tier3_Barn1",
"Horde_Tier3_Barn2",
"Horde_Tier3_Barracks1",
"Horde_Tier3_Barracks2",
"Horde_Tier3_Inn1",
"Horde_Tier3_Inn2",
"Horde_Tier3_Lumber1",
"Horde_Tier3_Lumber2",
"Horde_Tier3_Mage1",
"Horde_Tier3_Mage2",
"Horde_Tier3_Stables1",
"Horde_Tier3_Stables2",
"Horde_Tier3_Trading1",
"Horde_Tier3_Trading2",
"Horde_Tier3_Workshop1",
"Horde_Tier3_Workshop2",
"Icon-Death",
"Icon-Healer",
"Icon-Tank",
"Icon-WoW",
"Innkeeper",
"Insanity-DrippyPurple1",
"Insanity-DrippyPurple2",
"Insanity-PortraitOverlay",
"Insanity-PurpleBurstOn",
"Insanity-ShadowBurstOn",
"Insanity-Spark",
"Insanity-Tentacles",
"Insanity-TopPurpleShadow",
"InterruptOverlay",
"Krokuun_Highlight",
"LFG-lock",
"Lang-Regions-deDE",
"Lang-Regions-enCN",
"Lang-Regions-enGB",
"Lang-Regions-enTW",
"Lang-Regions-enUS",
"Lang-Regions-esES",
"Lang-Regions-esMX",
"Lang-Regions-frFR",
"Lang-Regions-itIT",
"Lang-Regions-koKR",
"Lang-Regions-ptBR",
"Lang-Regions-ptPT",
"Lang-Regions-ruRU",
"Lang-Regions-zhCN",
"Lang-Regions-zhTW",
"LegendaryToast-OrangeStarglow",
"LegendaryToast-background",
"LegendaryToast-particles1",
"LegendaryToast-particles2",
"LegendaryToast-particles3",
"LegendaryToast-ring1",
"Legion-boostpopup-bottom",
"Legion-boostpopup-exit-frame",
"Legion-boostpopup-middle",
"Legion-boostpopup-top",
"LegionMissionIcon-ZoneSupportAlliance-Map",
"LegionMissionIcon-ZoneSupportAlliance-MapBadge",
"LegionMissionIcon-ZoneSupportAlliance-Mission",
"LegionMissionIcon-ZoneSupportHorde-Map",
"LegionMissionIcon-ZoneSupportHorde-MapBadge",
"LegionMissionIcon-ZoneSupportHorde-Mission",
"LegionSplash-DemonHunter",
"LegionSplash-DemonHunterButton",
"LegionSplash-Logo",
"LegionSplash-NewCharacter",
"LegionSplash-NewCharacterButton",
"LegionfallMapBanner",
"Legionfall_Background",
"Legionfall_Banner",
"Legionfall_BarBackground",
"Legionfall_BarFrame",
"Legionfall_BarFrame-Glow",
"Legionfall_BarSpark",
"Legionfall_BuildingInfoBackground",
"Legionfall_CommandCenter_Completed",
"Legionfall_CommandCenter_Destroyed",
"Legionfall_CommandCenter_UnderAttack",
"Legionfall_CommandCenter_UnderConstruction",
"Legionfall_ExitFrame",
"Legionfall_GrayBanner",
"Legionfall_GrayFrame",
"Legionfall_GrayFrame_Buffs",
"Legionfall_GreenFrame",
"Legionfall_MageTower_Completed",
"Legionfall_MageTower_Destroyed",
"Legionfall_MageTower_UnderAttack",
"Legionfall_MageTower_UnderConstruction",
"Legionfall_NetherDisruptor_Completed",
"Legionfall_NetherDisruptor_Destroyed",
"Legionfall_NetherDisruptor_UnderAttack",
"Legionfall_NetherDisruptor_UnderConstruction",
"Legionfall_Padlock",
"Legionfall_RedFrame",
"Legionfall_YellowFrame",
"Lightlink",
"Lightlink-active",
"Lightlink-ball",
"Lightlink-blackinside",
"Lightlink-glow",
"Lightstone1",
"Lightstone2",
"Lightstone3",
"Lightstone4",
"Lightstone5",
"Lightstone6",
"Lightstone7",
"Lighttrait-backglow",
"Lighttrait-border",
"Lighttrait-border-selected",
"Lighttrait-glow",
"LootBanner-IconGlow",
"LootBanner-ItemBg",
"LootBanner-LootBagCircle",
"LootToast-LessAwesome",
"LootToast-MoreAwesome",
"MacAree_Highlight",
"Mage-ArcaneCharge",
"Mage-ArcaneCharge-CircleGlow",
"Mage-ArcaneCharge-Rune",
"Mage-ArcaneCharge-SmallSpark",
"Mage-ArcaneCharge-Spark",
"Mage-ArcaneChargeBar",
"MagePortalAlliance",
"MagePortalHorde",
"Mailbox",
"MainPet-Frame",
"MainPet-HealthBarBG",
"MainPet-HealthBarFill",
"MainPet-HealthBarFrame",
"MainPet-LevelBubble",
"MainPet-PetFamilyActivate",
"MainPet-PetFamilyFrame",
"MantidTower",
"MantidTowerDestroyed",
"MapCornerShadow-Left",
"MapCornerShadow-Right",
"Menagery1",
"Metal-Bar",
"Metal-Bar-Battlegrounds",
"Metal-Bar-Small",
"MiniMap-DeadArrow",
"MiniMap-PositionArrowDown",
"MiniMap-PositionArrowUp",
"MiniMap-PositionArrows",
"MiniMap-QuestArrow",
"MiniMap-VignetteArrow",
"Minimal_SliderBar_Button",
"Minimal_SliderBar_Button_Left",
"Minimal_SliderBar_Button_Right",
"Minimal_SliderBar_Left",
"Minimal_SliderBar_Right",
"MinimapArrow",
"Mission-FollowerPortraitFrame",
"Mission-LootBackgroundGlow",
"MissionFX-Smoke",
"MissionFX-SparkLines",
"Mixedtrait-border",
"Mobile-Alchemy",
"Mobile-Archeology",
"Mobile-Blacksmithing",
"Mobile-BonusIcon",
"Mobile-BonusIcon-Desaturated",
"Mobile-CombatBadgeIcon",
"Mobile-CombatIcon",
"Mobile-CombatIcon-Desaturated",
"Mobile-Cooking",
"Mobile-Enchanting",
"Mobile-Enginnering",
"Mobile-FirstAid",
"Mobile-Fishing",
"Mobile-Herbalism",
"Mobile-Inscription",
"Mobile-Jewelcrafting",
"Mobile-Leatherworking",
"Mobile-LegendaryQuestIcon",
"Mobile-LegendaryQuestIcon-Desaturated",
"Mobile-MechanicIcon-Curse",
"Mobile-MechanicIcon-Disorienting",
"Mobile-MechanicIcon-Lethal",
"Mobile-MechanicIcon-Powerful",
"Mobile-MechanicIcon-Slowing",
"Mobile-Mining",
"Mobile-Pets",
"Mobile-QuestIcon",
"Mobile-QuestIcon-Desaturated",
"Mobile-Skinning",
"Mobile-Tailoring",
"Mobile-TreasureIcon",
"Mobile-TreasureIcon-Desaturated",
"MonkUI-LightOrb",
"MonkUI-LightOrb-small",
"MonkUI-OrbOff",
"MonkUI-OrbOff-small",
"MonkUI-background",
"MonkUI-background-shadow",
"MonsterEnemy",
"MonsterFriend",
"MonsterNeutral",
"Monuments-Frame",
"Monuments-LeftButton-Down",
"Monuments-LeftButton-Up",
"Monuments-Lock",
"Monuments-LockedOverlay",
"Monuments-RightButton-Down",
"Monuments-RightButton-Up",
"MountJournalIcons-Alliance",
"MountJournalIcons-Horde",
"MountToast-Background",
"MovieRecordingIcon",
"NPE_ArrowDown",
"NPE_ArrowDownGlow",
"NPE_ArrowLeft",
"NPE_ArrowLeftGlow",
"NPE_ArrowRight",
"NPE_ArrowRightGlow",
"NPE_ArrowUp",
"NPE_ArrowUpGlow",
"NPE_ExclamationPoint",
"NPE_Icon",
"NPE_LeftClick",
"NPE_RightClick",
"NPE_TurnIn",
"NPE_keyboard",
"NavalMap-Alliance-Fog",
"NavalMap-Alliance-Highlight",
"NavalMap-CircleGlowTrails",
"NavalMap-Horde-Fog",
"NavalMap-Horde-Highlight",
"NavalMap-IronHorde-Fog",
"NavalMap-IronHorde-Highlight",
"NavalMap-LargeBonusCircle",
"NavalMap-OpenWaters-Fog",
"NavalMap-OpenWaters-Highlight",
"NavalMap-SmallBonusCircle",
"NavalMap01",
"Neutral-NineSlice-Corner",
"Neutralstone1",
"Neutralstone2",
"Neutralstone3",
"Neutralstone4",
"Neutralstone5",
"Neutralstone6",
"Neutralstone7",
"Neutraltrait-Glow",
"Neutraltrait-backglow",
"Neutraltrait-border",
"Neutraltrait-border-selected",
"NewCharacter-Alliance",
"NewCharacter-Horde",
"NewPlayerTutorial-NineSlice-Center",
"NewPlayerTutorial-NineSlice-CornerBottomLeft",
"NewPlayerTutorial-NineSlice-CornerBottomRight",
"NewPlayerTutorial-NineSlice-CornerTopLeft",
"NewPlayerTutorial-NineSlice-CornerTopRight",
"NineSliceTool-DottedLine-Horizontal",
"NineSliceTool-DottedLine-Vertical",
"NoQuestsBackground",
"None",
"OBJBonusBar-Top",
"OBJFX-BarGlow",
"OBJFX_Glow",
"OBJFX_LineBurst",
"OBJFX_LineGlow",
"OBJFX_StarBurst",
"Object",
"Objective-Fail",
"Objective-Header",
"Objective-ItemBorder",
"Objective-Nub",
"OptionsIcon-Brown",
"Options_CategoryHeader_1",
"Options_CategoryHeader_2",
"Options_CategoryHeader_3",
"Options_HorizontalDivider",
"Options_InnerFrame",
"Options_ListExpand_Left",
"Options_ListExpand_Right",
"Options_ListExpand_Right_Expanded",
"Options_List_Active",
"Options_List_Hover",
"Options_Tab_Active_Left",
"Options_Tab_Active_Middle",
"Options_Tab_Active_Right",
"Options_Tab_Left",
"Options_Tab_Middle",
"Options_Tab_Right",
"ParagonReputation_Bag",
"ParagonReputation_Checkmark",
"ParagonReputation_Glow",
"PartyMember",
"PartySizeIcon",
"PetJournal-BattleSlot-AbilityBorder",
"PetJournal-BattleSlot-Active",
"PetJournal-BattleSlot-IconBorder",
"PetJournal-BattleSlot-Locked",
"PetJournal-BattleSlot-Shadow",
"PetJournal-BattleSlotFrame-Corner",
"PetJournal-BattleSlotTitle-Left",
"PetJournal-BattleSlotTitle-Right",
"PetJournal-ExpBar-Background",
"PetJournal-ExpBar-Divider",
"PetJournal-ExpBar-Left",
"PetJournal-ExpBar-Mid",
"PetJournal-ExpBar-Right",
"PetJournal-FavoritesIcon",
"PetJournal-HealthBar-Background",
"PetJournal-HealthBar-Left",
"PetJournal-HealthBar-Mid",
"PetJournal-HealthBar-Right",
"PetJournal-LevelBubble",
"PetJournal-PetBattleAchievementBG",
"PetJournal-PetBattleAchievementGlow",
"PetJournal-PetCard-Abilities",
"PetJournal-PetCard-BG",
"PetList-ButtonBackground",
"PetList-ButtonHighlight",
"PetList-ButtonSelect",
"PetToast-background",
"PhotosensitivityWarning-parchment-background",
"PhotosensitivityWarning-questbang-icon",
"PhotosensitivityWarning-vignette",
"PlayerControlled",
"PlayerDeadBlip",
"PlayerEnemy",
"PlayerFriend",
"PlayerNeutral",
"PlayerPartyBlip",
"PlayerRaidBlip",
"Poisons",
"PortalBlue",
"PortalPurple",
"PortalRed",
"Portrait-Frame",
"Portrait-Frame-Nameplate",
"Portrait-Frame-Nameplate-scaledup",
"Portrait-Frame-Small",
"Portrait-frame-color",
"Priest-InsanityOverlay",
"Profession",
"Quest-Alliance-WaxSeal",
"Quest-Horde-WaxSeal",
"Quest-Legionfall-WaxSeal",
"QuestArtifact",
"QuestArtifactTurnin",
"QuestBG-Alliance",
"QuestBG-Horde",
"QuestBG-Legionfall",
"QuestBG-TheHandofFate",
"QuestBlob",
"QuestBonusObjective",
"QuestCollapse-Hide-Down",
"QuestCollapse-Hide-Up",
"QuestCollapse-Show-Down",
"QuestCollapse-Show-Up",
"QuestDaily",
"QuestDetails-RewardsBottomOverlay",
"QuestDetails-RewardsOverlay",
"QuestDetails-TopOverlay",
"QuestDetailsBackgrounds",
"QuestItemBorder",
"QuestItemBorder-Small",
"QuestLegendary",
"QuestLegendaryTurnin",
"QuestLogBackground",
"QuestNormal",
"QuestObjective",
"QuestPortraitIcon-SandboxQuest",
"QuestRepeatableTurnin",
"QuestSkull",
"QuestTurnin",
"QuestionMarkContinent-Icon",
"QuestionMarkContinent-IconHighlight",
"Raid",
"RaidMember",
"Reagents",
"RedButton-Condense",
"RedButton-Condense-Pressed",
"RedButton-Condense-disabled",
"RedButton-Exit",
"RedButton-Exit-Disabled",
"RedButton-Expand",
"RedButton-Expand-Disabled",
"RedButton-Expand-Pressed",
"RedButton-Highlight",
"RedButton-MiniCondense",
"RedButton-MiniCondense-disabled",
"RedButton-MiniCondense-pressed",
"RedButton-exit-pressed",
"RedCCIconGlow",
"Relic-Arcane-Slot",
"Relic-Arcane-TraitBG",
"Relic-Arcane-TraitGlow",
"Relic-Arcane-TraitGlowRing",
"Relic-Blood-Slot",
"Relic-Blood-TraitBG",
"Relic-Blood-TraitGlow",
"Relic-Blood-TraitGlowRing",
"Relic-Fel-Slot",
"Relic-Fel-TraitBG",
"Relic-Fel-TraitGlow",
"Relic-Fel-TraitGlowRing",
"Relic-Fire-Slot",
"Relic-Fire-TraitBG",
"Relic-Fire-TraitGlow",
"Relic-Fire-TraitGlowRing",
"Relic-Frost-Slot",
"Relic-Frost-TraitBG",
"Relic-Frost-TraitGlow",
"Relic-Frost-TraitGlowRing",
"Relic-Holy-Slot",
"Relic-Holy-TraitBG",
"Relic-Holy-TraitGlow",
"Relic-Holy-TraitGlowRing",
"Relic-Iron-Slot",
"Relic-Iron-TraitBG",
"Relic-Iron-TraitGlow",
"Relic-Iron-TraitGlowRing",
"Relic-Life-Slot",
"Relic-Life-TraitBG",
"Relic-Life-TraitGlow",
"Relic-Life-TraitGlowRing",
"Relic-Rankdisable-DarkGlow",
"Relic-Rankframe",
"Relic-Rankframe-glow",
"Relic-Rankselected-UpperGlow",
"Relic-Rankselected-circle",
"Relic-Shadow-Slot",
"Relic-Shadow-TraitBG",
"Relic-Shadow-TraitGlow",
"Relic-Shadow-TraitGlowRing",
"Relic-SlotBG",
"Relic-SlotBG-Glass",
"Relic-Water-Slot",
"Relic-Water-TraitBG",
"Relic-Water-TraitGlow",
"Relic-Water-TraitGlowRing",
"Relic-Wind-Slot",
"Relic-Wind-TraitBG",
"Relic-Wind-TraitGlow",
"Relic-Wind-TraitGlowRing",
"Relicforge-Bottomframe",
"Relicforge-Bottomleft-corner",
"Relicforge-Bottomright-corner",
"Relicforge-Leftframe",
"Relicforge-Relicsbackground",
"Relicforge-Relicsbackground-Previewtraits",
"Relicforge-Rightframe",
"Relicforge-Slot-background",
"Relicforge-Slot-frame",
"Relicforge-Slot-frame-Active",
"Relicforge-Topdecoration",
"Relicforge-Topframe",
"Relicforge-Topleft-corner",
"Relicforge-Topright-corner",
"Relicforge-background",
"Repair",
"Rewards-Shadow",
"Rewards-Top",
"Rotating-MinimapArrow",
"Rotating-MinimapGroupArrow",
"Rotating-MinimapGuideArrow",
"Rune-01-dark",
"Rune-01-light",
"Rune-01-neutral",
"Rune-01-purple",
"Rune-02-dark",
"Rune-02-light",
"Rune-02-neutral",
"Rune-02-purple",
"Rune-03-dark",
"Rune-03-light",
"Rune-03-neutral",
"Rune-03-purple",
"Rune-04-dark",
"Rune-04-light",
"Rune-04-neutral",
"Rune-04-purple",
"Rune-05-dark",
"Rune-05-light",
"Rune-05-neutral",
"Rune-05-purple",
"Rune-06-dark",
"Rune-06-light",
"Rune-06-neutral",
"Rune-06-purple",
"Rune-07-dark",
"Rune-07-light",
"Rune-08-dark",
"Rune-08-light",
"Rune-09-dark",
"Rune-09-light",
"Rune-10-dark ",
"Rune-10-light",
"Rune-11-dark",
"Rune-11-light",
"ScenarioTrackerToast",
"ScenarioTrackerToast-FinalFiligree",
"ScenariosIcon",
"Score-Team",
"ScoreDivider",
"ScoreTeam",
"ShipMission-RedGlowRing",
"ShipMission-TimerBG",
"ShipMissionIcon-Bonus-Map",
"ShipMissionIcon-Bonus-MapBadge",
"ShipMissionIcon-Bonus-Mission",
"ShipMissionIcon-Combat-Map",
"ShipMissionIcon-Combat-MapBadge",
"ShipMissionIcon-Combat-Mission",
"ShipMissionIcon-Legendary-Map",
"ShipMissionIcon-Legendary-MapBadge",
"ShipMissionIcon-Legendary-Mission",
"ShipMissionIcon-Oil-Map",
"ShipMissionIcon-Oil-MapBadge",
"ShipMissionIcon-Oil-Mission",
"ShipMissionIcon-SiegeA-Map",
"ShipMissionIcon-SiegeA-MapBadge",
"ShipMissionIcon-SiegeA-Mission",
"ShipMissionIcon-SiegeH-Map",
"ShipMissionIcon-SiegeH-MapBadge",
"ShipMissionIcon-SiegeH-Mission",
"ShipMissionIcon-SiegeIHA-Map",
"ShipMissionIcon-SiegeIHA-MapBadge",
"ShipMissionIcon-SiegeIHA-Mission",
"ShipMissionIcon-SiegeIHH-Map",
"ShipMissionIcon-SiegeIHH-MapBadge",
"ShipMissionIcon-SiegeIHH-Mission",
"ShipMissionIcon-Training-Map",
"ShipMissionIcon-Training-MapBadge",
"ShipMissionIcon-Training-Mission",
"ShipMissionIcon-Treasure-Map",
"ShipMissionIcon-Treasure-MapBadge",
"ShipMissionIcon-Treasure-Mission",
"ShipMissionParchment-Tile",
"ShipMission_Bg-DarkEdgeCorner",
"ShipMission_BoatRarity-Epic",
"ShipMission_BoatRarity-Rare",
"ShipMission_BoatRarity-Uncommon",
"ShipMission_CurrencyIcon-Oil",
"ShipMission_DangerousSkull",
"ShipMission_EncounterAbilityBorder",
"ShipMission_EncounterAbilityBorder-Lg",
"ShipMission_FollowerBG",
"ShipMission_FollowerBG-Glow",
"ShipMission_FollowerListButton",
"ShipMission_FollowerListButton-Highlight",
"ShipMission_FollowerListButton-Select",
"ShipMission_IconLevelBG",
"ShipMission_LocationCover-Side",
"ShipMission_MissionCostStartButtonBg",
"ShipMission_NameBG",
"ShipMission_PartyBuffsBG",
"ShipMission_RewardsBG-Desaturate",
"ShipMission_RewardsBorder-Corner-Desaturate",
"ShipMission_ShipFollower-EquipmentBG",
"ShipMission_ShipFollower-EquipmentFrame",
"ShipMission_ShipFollower-Lock-Epic",
"ShipMission_ShipFollower-Lock-Rare",
"ShipMission_ShipFollower-TypeFrame",
"ShipMission_StartMissionFrame",
"ShipMission_Toast",
"ShipMission_TopBorderCorner",
"Ships_CargoShip-List",
"Ships_CargoShip-Map",
"Ships_CargoShip-Portrait",
"Ships_Carrier-List",
"Ships_Carrier-Map",
"Ships_Carrier-Portrait",
"Ships_CarrierA-List",
"Ships_CarrierA-Map",
"Ships_CarrierA-Portrait",
"Ships_CarrierH-List",
"Ships_CarrierH-Map",
"Ships_CarrierH-Portrait",
"Ships_Dreadnaught-List",
"Ships_Dreadnaught-Map",
"Ships_Dreadnaught-Portrait",
"Ships_DreadnaughtA-List",
"Ships_DreadnaughtA-Map",
"Ships_DreadnaughtA-Portrait",
"Ships_DreadnaughtH-List",
"Ships_DreadnaughtH-Map",
"Ships_DreadnaughtH-Portrait",
"Ships_EnemyCargoShip-Portrait",
"Ships_EnemyCarrier-Portrait",
"Ships_EnemyCarrierA-Portrait",
"Ships_EnemyCarrierH-Portrait",
"Ships_EnemyDreadnaught-Portrait",
"Ships_EnemyDreadnaughtA-Portrait",
"Ships_EnemyDreadnaughtH-Portrait",
"Ships_EnemyGalleonA-Portrait",
"Ships_EnemyGalleonH-Portrait",
"Ships_EnemySubmarineA-Portrait",
"Ships_EnemySubmarineH-Portrait",
"Ships_EnemyTroopTransport-Portrait",
"Ships_GalleonA-List",
"Ships_GalleonA-Map",
"Ships_GalleonA-Portrait",
"Ships_GalleonH-List",
"Ships_GalleonH-Map",
"Ships_GalleonH-Portrait",
"Ships_SubmarineA-List",
"Ships_SubmarineA-Map",
"Ships_SubmarineA-Portrait",
"Ships_SubmarineH-List",
"Ships_SubmarineH-Map",
"Ships_SubmarineH-Portrait",
"Ships_TroopTransport-List",
"Ships_TroopTransport-Map",
"Ships_TroopTransport-Portrait",
"SliderBar-Button",
"SliderBar-NineSlice-CornerBottomLeft",
"SliderBar-NineSlice-CornerBottomRight",
"SliderBar-NineSlice-CornerTopLeft",
"SliderBar-NineSlice-CornerTopRight",
"SmallQuestBang",
"Spinner_Ring",
"Spinner_Shadow",
"Spinner_Sparks",
"SquareMask",
"StableMaster",
"Start-VersusSplash",
"StoneFrameCorner-TopLeft",
"StoryHeader-BG",
"StoryHeader-CheevoIcon",
"StoryHeader-Shadow",
"StreamCinematic-BC-Down",
"StreamCinematic-BC-Up",
"StreamCinematic-CC-Down",
"StreamCinematic-CC-Up",
"StreamCinematic-Classic-Down",
"StreamCinematic-Classic-Up",
"StreamCinematic-DownloadIcon",
"StreamCinematic-Highlight",
"StreamCinematic-LK-Down",
"StreamCinematic-LK-Up",
"StreamCinematic-Legion-Down",
"StreamCinematic-Legion-Up",
"StreamCinematic-MOP-Down",
"StreamCinematic-MOP-Up",
"StreamCinematic-PlayButton",
"StreamCinematic-ProgressBarBG",
"StreamCinematic-WOD-Down",
"StreamCinematic-WOD-Up",
"Talent-Background",
"Talent-BottomLeftCurlies",
"Talent-BottomRightCurlies",
"Talent-Highlight",
"Talent-RingWithDot",
"Talent-Selection",
"Talent-Selection-Legendary",
"Talent-Separator",
"Talent-TopLeftCurlies",
"Talent-TopRightCurlies",
"TalkingHeads-Glow-Sheen",
"TalkingHeads-Glow-SideBarGlow",
"TalkingHeads-Glow-TextSheen",
"TalkingHeads-Glow-TopBarGlow",
"TalkingHeads-Glow-TopSpike",
"TalkingHeads-PortraitBg",
"TalkingHeads-PortraitFrame",
"TalkingHeads-TextBackground",
"TankBadge",
"Target",
"Target-Tracker",
"TargetCrosshairs",
"TaskPOI-Icon",
"TaskPOI-IconHighlight",
"TaskPOI-IconSelect",
"TaxiNode_Alliance",
"TaxiNode_Horde",
"TaxiNode_Neutral",
"Taxi_Frame_Gray",
"Taxi_Frame_Green",
"Taxi_Frame_Yellow",
"Timer-BG",
"Timer-Fill",
"Timer-Frame",
"Toast-Flash",
"Toast-Frame",
"Toast-IconBG",
"Tooltip-Glues-NineSlice-Center",
"Tooltip-Glues-NineSlice-CornerBottomLeft",
"Tooltip-Glues-NineSlice-CornerBottomRight",
"Tooltip-Glues-NineSlice-CornerTopLeft",
"Tooltip-Glues-NineSlice-CornerTopRight",
"Tooltip-NineSlice-Center",
"Tooltip-NineSlice-CornerBottomLeft",
"Tooltip-NineSlice-CornerBottomRight",
"Tooltip-NineSlice-CornerTopLeft",
"Tooltip-NineSlice-CornerTopRight",
"Tracker-Check",
"Trinket-Frame",
"TrivialQuests",
"UI-Character-Info-DeathKnight-BG",
"UI-Character-Info-DemonHunter-BG",
"UI-Character-Info-Druid-BG",
"UI-Character-Info-Hunter-BG",
"UI-Character-Info-ItemLevel-Bounce",
"UI-Character-Info-Line-Bounce",
"UI-Character-Info-Mage-BG",
"UI-Character-Info-Monk-BG",
"UI-Character-Info-Paladin-BG",
"UI-Character-Info-Priest-BG",
"UI-Character-Info-Rogue-BG",
"UI-Character-Info-Shaman-BG",
"UI-Character-Info-Title",
"UI-Character-Info-Warlock-BG",
"UI-Character-Info-Warrior-BG",
"UI-CharacterCreate-LargeButton",
"UI-CharacterCreate-LargeButton-Blue-Highlight",
"UI-CharacterCreate-LargeButton-Yellow-Highlight",
"UI-CharacterCreate-Metal-Finery-Corner",
"UI-CharacterCreate-Metal-Small-Finery",
"UI-CharacterCreate-MetalFrame-Horizontal",
"UI-CharacterCreate-MetalFrame-Vertical",
"UI-CharacterCreate-PadLock",
"UI-ChatIcon-ANBS",
"UI-ChatIcon-App",
"UI-ChatIcon-D3",
"UI-ChatIcon-DST2",
"UI-ChatIcon-FEN",
"UI-ChatIcon-FORE",
"UI-ChatIcon-GRY",
"UI-ChatIcon-Hero",
"UI-ChatIcon-LAZR",
"UI-ChatIcon-ODIN",
"UI-ChatIcon-OSI",
"UI-ChatIcon-Overwatch-zhCN",
"UI-ChatIcon-Pro",
"UI-ChatIcon-RTRO",
"UI-ChatIcon-S1",
"UI-ChatIcon-S2",
"UI-ChatIcon-VIPR",
"UI-ChatIcon-W3",
"UI-ChatIcon-WLBY",
"UI-ChatIcon-WTCG",
"UI-ChatIcon-WoW",
"UI-ChatIcon-ZEUS",
"UI-DialogBox-Background-Dark",
"UI-DialogBox-goldbutton-down-left-blue",
"UI-DialogBox-goldbutton-down-middle-blue",
"UI-DialogBox-goldbutton-down-right-blue",
"UI-DialogBox-goldbutton-up-left-blue",
"UI-DialogBox-goldbutton-up-middle-blue",
"UI-DialogBox-goldbutton-up-right-blue",
"UI-DiamondDialogBox-Border",
"UI-DiamondDialogBox-ClassicBorder",
"UI-Feedback-Border",
"UI-Frame-BotCornerLeft",
"UI-Frame-BotCornerRight",
"UI-Frame-BtnCornerLeft",
"UI-Frame-BtnCornerRight",
"UI-Frame-BtnDivLeft",
"UI-Frame-BtnDivMiddle",
"UI-Frame-BtnDivRight",
"UI-Frame-DiamondMetal-CornerBottomLeft",
"UI-Frame-DiamondMetal-CornerBottomRight",
"UI-Frame-DiamondMetal-CornerTopLeft",
"UI-Frame-DiamondMetal-CornerTopRight",
"UI-Frame-InnerBotLeftCorner",
"UI-Frame-InnerBotRight",
"UI-Frame-InnerSplitLeft",
"UI-Frame-InnerSplitRight",
"UI-Frame-InnerTopLeft",
"UI-Frame-InnerTopRight",
"UI-Frame-Neutral-CardParchment",
"UI-Frame-Neutral-CardParchmentWider",
"UI-Frame-Neutral-ExitButtonBorder",
"UI-Frame-Neutral-Portrait",
"UI-Frame-Neutral-PortraitDisable",
"UI-Frame-Neutral-PortraitWider",
"UI-Frame-Neutral-PortraitWiderDisable",
"UI-Frame-Neutral-Ribbon",
"UI-Frame-Neutral-TitleLeft",
"UI-Frame-Neutral-TitleRight",
"UI-Frame-Portrait",
"UI-Frame-SliderBar-BackgroundTile",
"UI-Frame-TopCornerRight",
"UI-Frame-TopCornerRightSimple",
"UI-Frame-TopLeftCorner",
"UI-Frame-TopLeftCornerNoPortrait",
"UI-LFG-DeclineMark",
"UI-LFG-DeclineMark-Raid",
"UI-LFG-DividerLine",
"UI-LFG-PendingMark",
"UI-LFG-PendingMark-Raid",
"UI-LFG-ReadyMark",
"UI-LFG-ReadyMark-Raid",
"UI-LFG-RoleIcon-DPS",
"UI-LFG-RoleIcon-DPS-Background",
"UI-LFG-RoleIcon-DPS-Disabled",
"UI-LFG-RoleIcon-DPS-Micro",
"UI-LFG-RoleIcon-DPS-Micro-Raid",
"UI-LFG-RoleIcon-Decline",
"UI-LFG-RoleIcon-Generic",
"UI-LFG-RoleIcon-Generic-Disabled",
"UI-LFG-RoleIcon-Generic-Micro",
"UI-LFG-RoleIcon-Generic-Micro-Raid",
"UI-LFG-RoleIcon-Healer",
"UI-LFG-RoleIcon-Healer-Background",
"UI-LFG-RoleIcon-Healer-Disabled",
"UI-LFG-RoleIcon-Healer-Micro",
"UI-LFG-RoleIcon-Healer-Micro-Raid",
"UI-LFG-RoleIcon-Incentive",
"UI-LFG-RoleIcon-Leader",
"UI-LFG-RoleIcon-Leader-Disabled",
"UI-LFG-RoleIcon-Leader-Micro",
"UI-LFG-RoleIcon-Leader-Micro-Raid",
"UI-LFG-RoleIcon-Pending",
"UI-LFG-RoleIcon-RangedDPS",
"UI-LFG-RoleIcon-RangedDPS-Disabled",
"UI-LFG-RoleIcon-RangedDPS-Micro",
"UI-LFG-RoleIcon-RangedDPS-Micro-Raid",
"UI-LFG-RoleIcon-Ready",
"UI-LFG-RoleIcon-Tank",
"UI-LFG-RoleIcon-Tank-Background",
"UI-LFG-RoleIcon-Tank-Disabled",
"UI-LFG-RoleIcon-Tank-Micro",
"UI-LFG-RoleIcon-Tank-Micro-Raid",
"UI-LFG-RoleIcon-Tank-Micro-Raid-Role",
"UI-Minimap-Clock",
"UI-MoneyFrame-Large",
"UI-OuterBorderButtonPatch",
"UI-PaidCharacterCustomization-Button-ActivateCharacter",
"UI-ScrollBar-ClassicScrollDownButton-Disabled",
"UI-ScrollBar-ClassicScrollDownButton-Down",
"UI-ScrollBar-ClassicScrollDownButton-Highlight",
"UI-ScrollBar-ClassicScrollDownButton-Up",
"UI-ScrollBar-ClassicScrollUpButton-Disabled",
"UI-ScrollBar-ClassicScrollUpButton-Down",
"UI-ScrollBar-ClassicScrollUpButton-Highlight",
"UI-ScrollBar-ClassicScrollUpButton-Up",
"UI-SquareButtonBrown-Down",
"UI-SquareButtonBrown-Up",
"UI-Taxi-Icon-Nub",
"UIFrameBackground-NineSlice-CornerBottomLeft",
"UIFrameBackground-NineSlice-CornerBottomRight",
"UnitFrame",
"UnitFrame-NoMana",
"UnitFrame-NoTrinket",
"UnitFrame_CCOverlay",
"UnitFrame_CCOverlay-NoMana",
"UnitFrame_CurrentPlayer",
"UnitFrame_CurrentPlayer-NoMana",
"UnitFrame_CurrentPlayer-NoTrinket",
"UnitFrame_CurrentPlayerGlow",
"UnitFrame_CurrentPlayerGlow-NoMana",
"UnitFrame_CurrentPlayer_CCOverlay",
"UnitFrame_CurrentPlayer_CCOverlay-NoMana",
"UnitFrame_CurrentPlayer_DeathOverlay",
"UnitFrame_CurrentPlayer_DeathOverlay-NoMana",
"UnitFrame_CurrentPlayer_FocusFireOverlay",
"UnitFrame_CurrentPlayer_FocusFireOverlay-NoMana",
"UnitFrame_DeathOverlay",
"UnitFrame_DeathOverlay-NoMana",
"UnitFrame_FocusFireOverlay",
"UnitFrame_FocusFireOverlay-NoMana",
"Vehicle-Air-Alliance",
"Vehicle-Air-Horde",
"Vehicle-Air-Occupied",
"Vehicle-Air-Unoccupied",
"Vehicle-AllianceCart",
"Vehicle-Carriage",
"Vehicle-Ground-Occupied",
"Vehicle-Ground-Unoccupied",
"Vehicle-GrummleConvoy",
"Vehicle-HammerGold",
"Vehicle-HammerGold-1",
"Vehicle-HammerGold-2",
"Vehicle-HammerGold-3",
"Vehicle-HordeCart",
"Vehicle-Mogu",
"Vehicle-SilvershardMines-Arrow",
"Vehicle-SilvershardMines-MineCart",
"Vehicle-SilvershardMines-MineCartBlue",
"Vehicle-SilvershardMines-MineCartRed",
"Vehicle-TempleofKotmogu-CyanBall",
"Vehicle-TempleofKotmogu-GreenBall",
"Vehicle-TempleofKotmogu-OrangeBall",
"Vehicle-TempleofKotmogu-PurpleBall",
"Vehicle-Trap-Gold",
"Vehicle-Trap-Grey",
"Vehicle-Trap-Red",
"VignetteEvent",
"VignetteEventElite",
"VignetteKill",
"VignetteKillElite",
"VignetteLoot",
"VignetteLootElite",
"Warlock-Bar-EmptyShards",
"Warlock-EmptyShard",
"Warlock-FillShard",
"Warlock-ReadyShard",
"Warlock-ReadyShard-Glow",
"Warlock-Shard-Spark",
"WarlockPortalAlliance",
"WarlockPortalHorde",
"WhiteCircle-RaidBlips",
"WhiteDotCircle-RaidBlips",
"WildBattlePet",
"WildBattlePet-Tracker",
"WildBattlePetCapturable",
"WoWShare-AchievementIcon",
"WoWShare-AddButton-Down",
"WoWShare-AddButton-Up",
"WoWShare-ChatIcon",
"WoWShare-EdgeArt",
"WoWShare-Highlight",
"WoWShare-ItemIcon",
"WoWShare-ItemQualityBorder",
"WoWShare-Plus",
"WoWShare-ScreenshotIcon",
"WoWShare-Selection",
"WoWShare-TwitterLogo",
"XMarksTheSpot",
"XPBarAnim-GlowLines",
"XPBarAnim-OrangeGain",
"XPBarAnim-OrangeGlow",
"XPBarAnim-OrangeSpark",
"XPBarAnim-OrangeTrail",
"ZoneAbility-Generic-AbilityBar",
"ZoneAbility-Generic-AbilityBar-Glow",
"ZoneAbility-Generic-IconBorder",
"ZoneAbility-Generic-SpellBox",
"_128-RedButton-Center",
"_128-RedButton-Center-Disabled",
"_128-RedButton-Center-Pressed",
"_Armor-Fill-mid",
"_Bar-mid",
"_BattleBar-ButtonBGMid",
"_BattleBar-Mid",
"_BattleSlotFrame-Divider",
"_BattleSlotFrame-Top",
"_BattleSlotTitle-BG",
"_BattleSlotTitle-Mid",
"_Cast-Bar-Fill-mid",
"_Cast-Bar-mid",
"_CharacterCreateDropdown-NineSlice-EdgeBottom",
"_CharacterCreateDropdown-NineSlice-EdgeTop",
"_ChatBubble-NineSlice-EdgeBottom",
"_ChatBubble-NineSlice-EdgeTop",
"_ClassHall_InfoBoxMission-Top",
"_ClassHall_ParchmentHeader-Mid",
"_ClassHall_ParchmentHeaderSelect-Mid",
"_DemonHunter-DemonicFuryBar",
"_DemonHunter-DemonicPainBar",
"_Druid-LunarBar",
"_ForgeBorder-Top",
"_GarrMissionLocation-Argus-Mid",
"_GarrMissionLocation-Azsuna-Mid",
"_GarrMissionLocation-BlackrockMountain-Back",
"_GarrMissionLocation-BlackrockMountain-Fore",
"_GarrMissionLocation-BlackrockMountain-List",
"_GarrMissionLocation-BlackrockMountain-Mid",
"_GarrMissionLocation-Dalaran-Mid",
"_GarrMissionLocation-FrostfireRidge-Back",
"_GarrMissionLocation-FrostfireRidge-Fore",
"_GarrMissionLocation-FrostfireRidge-Mid",
"_GarrMissionLocation-FrostfireSea-Back",
"_GarrMissionLocation-FrostfireSea-Fore",
"_GarrMissionLocation-FrostfireSea-Mid",
"_GarrMissionLocation-Gorgrond-Back",
"_GarrMissionLocation-Gorgrond-Fore",
"_GarrMissionLocation-Gorgrond-Mid",
"_GarrMissionLocation-Highmountain-Mid",
"_GarrMissionLocation-Legion-Mid",
"_GarrMissionLocation-Nagrand-Back",
"_GarrMissionLocation-Nagrand-Fore",
"_GarrMissionLocation-Nagrand-Mid",
"_GarrMissionLocation-NagrandSea-Back",
"_GarrMissionLocation-NagrandSea-Fore",
"_GarrMissionLocation-NagrandSea-Mid",
"_GarrMissionLocation-ShadowmoonSea-Back",
"_GarrMissionLocation-ShadowmoonSea-Fore",
"_GarrMissionLocation-ShadowmoonSea-Mid",
"_GarrMissionLocation-ShadowmoonValley-Back",
"_GarrMissionLocation-ShadowmoonValley-Fore",
"_GarrMissionLocation-ShadowmoonValley-Mid",
"_GarrMissionLocation-SpiresofArak-Back",
"_GarrMissionLocation-SpiresofArak-Fore",
"_GarrMissionLocation-SpiresofArak-Mid",
"_GarrMissionLocation-Stormheim-Mid",
"_GarrMissionLocation-Suramar-Mid",
"_GarrMissionLocation-Talador-Back",
"_GarrMissionLocation-Talador-Fore",
"_GarrMissionLocation-Talador-Mid",
"_GarrMissionLocation-TannanJungle-Back",
"_GarrMissionLocation-TannanJungle-Fore",
"_GarrMissionLocation-TannanJungle-Mid",
"_GarrMissionLocation-TannanSea-Back",
"_GarrMissionLocation-TannanSea-Fore",
"_GarrMissionLocation-TannanSea-Mid",
"_GarrMissionLocation-TownAlliance-Back",
"_GarrMissionLocation-TownAlliance-Fore",
"_GarrMissionLocation-TownAlliance-Mid",
"_GarrMissionLocation-TownHorde-Back",
"_GarrMissionLocation-TownHorde-Fore",
"_GarrMissionLocation-TownHorde-Mid",
"_GarrMissionLocation-Underground-Back",
"_GarrMissionLocation-Underground-Fore",
"_GarrMissionLocation-Underground-Mid",
"_GarrMissionLocation-Valsharah-Mid",
"_GarrMission_Bg-BottomEdge",
"_GarrMission_Bg-BottomEdgeSmall",
"_GarrMission_LocationCover-Bottom",
"_GarrMission_MissionListTopHighlight",
"_GarrMission_ParchmentHeader-Mid",
"_GarrMission_ParchmentHeaderSelect-Mid",
"_GarrMission_RewardsBorder-Top",
"_GarrMission_RewardsBorder-Top-Desaturate",
"_GarrMission_TopBorder",
"_GarrMission_TopBorder-Highlight",
"_GarrMission_TopBorder-Select",
"_GarrMission_XPBar-BG",
"_GarrMission_XPBar-Fill",
"_Garr_InfoBox-Top",
"_Garr_InfoBoxBorder-BigBottom",
"_Garr_InfoBoxBorder-Top",
"_Garr_InfoBoxBorderMission-Top",
"_Garr_InfoBoxMission-Top",
"_Garr_WoodFrameTile-Bottom",
"_Garr_WoodFrameTile-Top",
"_Garr_XPBar_Mid",
"_GeneralFrame-HorizontalBar",
"_GeneralFrame-InsetFrame-Bottom",
"_GeneralFrame-InsetFrame-Top",
"_Health-Bar-mid",
"_Health_mid",
"_Legionfall_BarFill_Active",
"_Legionfall_BarFill_UnderAttack",
"_Legionfall_BarFill_UnderConstruction",
"_Minimal_SliderBar_Middle",
"_Neutral-NineSlice-EdgeBottom",
"_Neutral-NineSlice-EdgeTop",
"_NewPlayerTutorial-NineSlice-EdgeBottom",
"_NewPlayerTutorial-NineSlice-EdgeTop",
"_Options_ListExpand_Middle",
"_Priest-InsanityBar",
"_Score-Team-mid",
"_Shaman-MaelstromBar",
"_ShipMission_Bg-BottomEdge",
"_ShipMission_Bg-BottomEdgeSmall",
"_ShipMission_LocationCover-Bottom",
"_ShipMission_RewardsBorder-Top-Desaturate",
"_ShipMission_TopBorder",
"_SliderBar-NineSlice-EdgeBottom",
"_SliderBar-NineSlice-EdgeTop",
"_StoneFrameTile-Bottom",
"_StoneFrameTile-Top",
"_Talent-Bottom-Tile",
"_Talent-Top-Tile",
"_Talent-blue-glow",
"_Talent-green-glow",
"_Tooltip-Glues-NineSlice-EdgeBottom",
"_Tooltip-Glues-NineSlice-EdgeTop",
"_Tooltip-NineSlice-EdgeBottom",
"_Tooltip-NineSlice-EdgeTop",
"_UI-Frame-Bot",
"_UI-Frame-BtnBotTile",
"_UI-Frame-DiamondMetal-EdgeBottom",
"_UI-Frame-DiamondMetal-EdgeTop",
"_UI-Frame-InnerBotTile",
"_UI-Frame-InnerTopTile",
"_UI-Frame-Neutral-TitleMiddle",
"_UI-Frame-TitleTile",
"_UI-Frame-TitleTileBg",
"_UI-Frame-TopTileStreaks",
"_UI-Taxi-Line-horizontal",
"_collections-background-line",
"_gmchat-nineslice-edgebottom",
"_gmchat-nineslice-edgetop",
"_gmglow-nineslice-edgebottom",
"_gmglow-nineslice-edgetop",
"_honorsystem-bar-fill",
"_honorsystem-bar-fill-rested",
"_macropopup-bottom",
"_macropopup-top",
"_macropopup-top2",
"_minortalents-iconspinner",
"_optionsframe-nineslice-edgebottom",
"_optionsframe-nineslice-edgetop",
"_orderhall-commandbar-bg",
"_search-rowbg",
"_transmog-preview-QuestPortrait-Divider_noname",
"_transmog-preview-QuestPortrait-StoneSwirls-Top",
"_ui-scrollbar-center",
"_uiframe-activetab-center",
"_uiframe-tab-center",
"_warboard-title-alliance-middle",
"_warboard-title-horde-middle",
"_warboard-title-neutral-middle",
"accountupgradebanner-bc",
"accountupgradebanner-bfa",
"accountupgradebanner-cataclysm",
"accountupgradebanner-classic",
"accountupgradebanner-legion",
"accountupgradebanner-mop",
"accountupgradebanner-wod",
"accountupgradebanner-wotlk",
"achievementcompare-GreenCheckmark",
"achievementcompare-YellowCheckmark",
"adventureguide-icon-whatsnew",
"adventureguide-microbutton-alert",
"adventureguide-pane-large",
"adventureguide-pane-small",
"adventureguide-redx",
"adventureguide-rewardring",
"adventureguide-ring",
"alliance_icon_and_flag-dynamicIcon",
"alliance_icon_and_flag-flash",
"alliance_icon_and_flag-icon",
"alliance_icon_horde_flag-dynamicIcon",
"alliance_icon_horde_flag-flash",
"alliance_icon_horde_flag-icon",
"alliance_tower-icon",
"auctionhouse-background-auctions",
"auctionhouse-background-buy-commodities",
"auctionhouse-background-buy-commodities-market",
"auctionhouse-background-buy-noncommodities-header",
"auctionhouse-background-buy-noncommodities-market",
"auctionhouse-background-categories",
"auctionhouse-background-index",
"auctionhouse-background-sell-left",
"auctionhouse-background-sell-right",
"auctionhouse-background-summarylist",
"auctionhouse-icon-checkmark",
"auctionhouse-icon-clock",
"auctionhouse-icon-coin-copper",
"auctionhouse-icon-coin-gold",
"auctionhouse-icon-coin-silver",
"auctionhouse-icon-favorite",
"auctionhouse-icon-favorite-off",
"auctionhouse-icon-socket",
"auctionhouse-itemheaderframe",
"auctionhouse-itemicon-border-account",
"auctionhouse-itemicon-border-artifact",
"auctionhouse-itemicon-border-blue",
"auctionhouse-itemicon-border-gray",
"auctionhouse-itemicon-border-green",
"auctionhouse-itemicon-border-orange",
"auctionhouse-itemicon-border-purple",
"auctionhouse-itemicon-border-white",
"auctionhouse-itemicon-cover",
"auctionhouse-itemicon-empty",
"auctionhouse-itemicon-small-border",
"auctionhouse-nav-button",
"auctionhouse-nav-button-highlight",
"auctionhouse-nav-button-secondary",
"auctionhouse-nav-button-secondary-highlight",
"auctionhouse-nav-button-secondary-select",
"auctionhouse-nav-button-select",
"auctionhouse-nav-button-tertiary-filterline",
"auctionhouse-rowstripe-1",
"auctionhouse-rowstripe-2",
"auctionhouse-selltab-left",
"auctionhouse-selltab-middle",
"auctionhouse-selltab-right",
"auctionhouse-ui-dropdown-arrow-disabled",
"auctionhouse-ui-dropdown-arrow-down",
"auctionhouse-ui-dropdown-arrow-up",
"auctionhouse-ui-dropdown-left",
"auctionhouse-ui-dropdown-middle",
"auctionhouse-ui-dropdown-right",
"auctionhouse-ui-filter-redx",
"auctionhouse-ui-inputfield-left",
"auctionhouse-ui-inputfield-middle",
"auctionhouse-ui-inputfield-right",
"auctionhouse-ui-loadingspinner",
"auctionhouse-ui-row-highlight",
"auctionhouse-ui-row-select",
"auctionhouse-ui-sortarrow",
"bag-arrow",
"bag-border",
"bag-border-empty",
"bag-border-highlight",
"bag-border-search",
"bag-main",
"bag-main-highlight",
"bag-main-search",
"bag-reagent-border",
"bag-reagent-border-empty",
"bags-button-autosort-down",
"bags-button-autosort-up",
"bags-glow-artifact",
"bags-glow-blue",
"bags-glow-flash",
"bags-glow-green",
"bags-glow-heirloom",
"bags-glow-orange",
"bags-glow-purple",
"bags-glow-white",
"bags-greenarrow",
"bags-icon-addslots",
"bags-icon-consumables",
"bags-icon-equipment",
"bags-icon-tradegoods",
"bags-innerglow",
"bags-junkcoin",
"bags-newitem",
"bags-roundhighlight",
"bags-static",
"bank-slots",
"bank-slots-shadow",
"barbershop-background",
"battlefieldminimap-border-bottom",
"battlefieldminimap-border-bottomleft",
"battlefieldminimap-border-bottomright",
"battlefieldminimap-border-left",
"battlefieldminimap-border-right",
"battlefieldminimap-border-top",
"battlefieldminimap-border-topleft",
"battlefieldminimap-border-topright",
"battlenet-clienticon-pro-zhCN",
"bluemenu-Ring",
"bonusobjectives-bar-bg",
"bonusobjectives-bar-fill",
"bonusobjectives-bar-frame",
"bonusobjectives-bar-glow",
"bonusobjectives-bar-glow-ring",
"bonusobjectives-bar-ring",
"bonusobjectives-bar-sheen",
"bonusobjectives-bar-spark",
"bonusobjectives-bar-starburst",
"bonusobjectives-title-bg",
"bonusobjectives-title-icon",
"bonusobjectives-title-icon-honor",
"book-bg",
"book-line",
"boostpopup-wod-bottom",
"boostpopup-wod-middle",
"boostpopup-wod-top",
"category-icon-ring",
"challenges-bannershine",
"challenges-blackfade",
"challenges-nomedal",
"challenges-timerbg",
"challenges-timerborder",
"challenges-toast",
"charactercreate-banner-bottom",
"charactercreate-banner-middle",
"charactercreate-banner-top",
"charactercreate-customize-backbutton",
"charactercreate-customize-backbutton-disabled",
"charactercreate-customize-backbutton-down",
"charactercreate-customize-button-redglow",
"charactercreate-customize-dropdown-icon-lock",
"charactercreate-customize-dropdown-linemouseover-middle",
"charactercreate-customize-dropdown-linemouseover-side",
"charactercreate-customize-dropdown-newtagglow",
"charactercreate-customize-dropdownbox",
"charactercreate-customize-dropdownbox-hover",
"charactercreate-customize-dropdownbox-open",
"charactercreate-customize-nextbutton",
"charactercreate-customize-nextbutton-disabled",
"charactercreate-customize-nextbutton-down",
"charactercreate-customize-palette",
"charactercreate-customize-palette-glow",
"charactercreate-customize-palette-half",
"charactercreate-customize-palette-selected",
"charactercreate-customize-playbutton",
"charactercreate-customize-playbutton-down",
"charactercreate-customize-speakeroffbutton",
"charactercreate-customize-speakeroffbutton-down",
"charactercreate-customize-speakeronbutton",
"charactercreate-customize-speakeronbutton-down",
"charactercreate-gendericon-female",
"charactercreate-gendericon-female-selected",
"charactercreate-gendericon-male",
"charactercreate-gendericon-male-selected",
"charactercreate-icon-alliance",
"charactercreate-icon-customize-accessories",
"charactercreate-icon-customize-accessories-selected",
"charactercreate-icon-customize-body",
"charactercreate-icon-customize-body-selected",
"charactercreate-icon-customize-hair",
"charactercreate-icon-customize-hair-selected",
"charactercreate-icon-customize-head",
"charactercreate-icon-customize-head-selected",
"charactercreate-icon-customize-mirror",
"charactercreate-icon-customize-mirror-selected",
"charactercreate-icon-customize-speechbubble",
"charactercreate-icon-customize-speechbubble-selected",
"charactercreate-icon-customize-torso",
"charactercreate-icon-customize-torso-selected",
"charactercreate-icon-dice",
"charactercreate-icon-horde",
"charactercreate-icon-requiredarrow",
"charactercreate-ring-alliance",
"charactercreate-ring-alliance-disabled",
"charactercreate-ring-customizebackground",
"charactercreate-ring-horde",
"charactercreate-ring-horde-disabled",
"charactercreate-ring-metaldark",
"charactercreate-ring-metaldark-disabled",
"charactercreate-ring-metallight",
"charactercreate-ring-racialtrait",
"charactercreate-ring-select",
"charactercreate-tooltip-background",
"charactercreate-tooltip-corner",
"charactercreate-tooltip-side",
"charactercreate-tooltip-top",
"charactercreate-vignette-bottom",
"charactercreate-vignette-sides",
"charactercreate-vignette-sides-widescreen",
"charactercreate-vignette-top",
"characterundelete-RestoreButton",
"chatframe-button-down",
"chatframe-button-highlight",
"chatframe-button-highlightalert",
"chatframe-button-icon-TTS",
"chatframe-button-icon-headset",
"chatframe-button-icon-mic-off",
"chatframe-button-icon-mic-on",
"chatframe-button-icon-mic-silenced",
"chatframe-button-icon-mic-silenced-off",
"chatframe-button-icon-speaker-off",
"chatframe-button-icon-speaker-on",
"chatframe-button-icon-speaker-silenced",
"chatframe-button-icon-voicechat",
"chatframe-button-up",
"chatframe-scrollbar-knob",
"checkbox-minimal",
"checkmark-minimal",
"checkmark-minimal-disabled",
"classic-announcementpopup-bcinfographic",
"classic-announcementpopup-bcinfographic-zhCN",
"classic-announcementpopup-bcinfographic-zhTW",
"classic-announcementpopup-frame",
"classic-announcementpopup-line",
"classic-burningcrusade-infoicon",
"classic-burningcrusade-infoicon-zhCN",
"classic-burningcrusade-infoicon-zhTW",
"classic-burningcrusadetransition-choice-frame-classic",
"classic-burningcrusadetransition-choice-line-bc",
"classic-burningcrusadetransition-choice-line-classic",
"classic-burningcrusadetransition-choice-logo-bc",
"classic-burningcrusadetransition-choice-logo-bc-zhCN",
"classic-burningcrusadetransition-choice-logo-bc-zhTW",
"classic-burningcrusadetransition-choice-logo-classic",
"classic-burningcrusadetransition-choice-logo-classic-zhCN",
"classic-burningcrusadetransition-choice-logo-classic-zhTW",
"classic_blizzcon23_splash",
"classicon-druid",
"classicon-hunter",
"classicon-mage",
"classicon-paladin",
"classicon-priest",
"classicon-rogue",
"classicon-shaman",
"classicon-warlock",
"classicon-warrior",
"clickcastlist-buttonbackground",
"clickcastlist-buttonhighlight",
"clickcastlist-buttonnew",
"coin-icon",
"collections-background-corner",
"collections-background-filagree",
"collections-background-shadow-large",
"collections-background-shadow-small",
"collections-background-tile",
"collections-icon-favorites",
"collections-itemborder-collected",
"collections-itemborder-uncollected",
"collections-itemborder-uncollected-innerglow",
"collections-levelplate-black",
"collections-levelplate-gold",
"collections-newglow",
"collections-slotheader",
"collections-upgradeglow",
"collections-upgradeglow-blue",
"collections-watermark-heirloom",
"collections-watermark-toy",
"colorblind-bar-green",
"colorblind-bar-red",
"colorblind-bar-yellow",
"colorblind-colorwheel",
"combat_swords-dynamicIcon",
"combat_swords-flash",
"combat_swords-icon",
"common-button-square-gray-down",
"common-button-square-gray-up",
"common-dropdown-a-button",
"common-dropdown-a-button-disabled",
"common-dropdown-a-button-hover",
"common-dropdown-a-button-open",
"common-dropdown-a-button-pressed",
"common-dropdown-a-button-pressedhover",
"common-dropdown-b-button",
"common-dropdown-b-button-disabled",
"common-dropdown-b-button-hover",
"common-dropdown-b-button-open",
"common-dropdown-b-button-pressed",
"common-dropdown-b-button-pressedhover",
"common-dropdown-bg",
"common-dropdown-c-bg",
"common-dropdown-c-button",
"common-dropdown-c-button-disabled",
"common-dropdown-c-button-hover-1",
"common-dropdown-c-button-hover-2",
"common-dropdown-c-button-hover-arrow",
"common-dropdown-c-button-open",
"common-dropdown-c-button-pressed-1",
"common-dropdown-c-button-pressed-2",
"common-dropdown-c-button-pressedhover-1",
"common-dropdown-c-button-pressedhover-2",
"common-dropdown-classic-a-buttonDown",
"common-dropdown-classic-a-buttonDown-disabled",
"common-dropdown-classic-a-buttonDown-disabled-small",
"common-dropdown-classic-a-buttonDown-hover",
"common-dropdown-classic-a-buttonDown-hover-small",
"common-dropdown-classic-a-buttonDown-pressed",
"common-dropdown-classic-a-buttonDown-pressed-small",
"common-dropdown-classic-a-buttonDown-pressedhover",
"common-dropdown-classic-a-buttonDown-pressedhover-small",
"common-dropdown-classic-a-buttonDown-small",
"common-dropdown-classic-a-buttonUp",
"common-dropdown-classic-a-buttonUp-disabled",
"common-dropdown-classic-a-buttonUp-disabled-small",
"common-dropdown-classic-a-buttonUp-hover",
"common-dropdown-classic-a-buttonUp-hover-small",
"common-dropdown-classic-a-buttonUp-pressed",
"common-dropdown-classic-a-buttonUp-pressed-small",
"common-dropdown-classic-a-buttonUp-pressedhover",
"common-dropdown-classic-a-buttonUp-pressedhover-small",
"common-dropdown-classic-a-buttonUp-small",
"common-dropdown-classic-b-bg",
"common-dropdown-classic-b-button",
"common-dropdown-classic-b-button-disabled",
"common-dropdown-classic-b-button-hover",
"common-dropdown-classic-b-button-pressed",
"common-dropdown-classic-b-button-pressedhover",
"common-dropdown-classic-bg",
"common-dropdown-classic-bg-b",
"common-dropdown-classic-darkBG",
"common-dropdown-classic-textholder",
"common-dropdown-classic-textholder-small",
"common-dropdown-customize-mouseover",
"common-dropdown-icon-back",
"common-dropdown-icon-back-disabled",
"common-dropdown-icon-checkmark-yellow",
"common-dropdown-icon-checkmark-yellow-classic",
"common-dropdown-icon-checkmark-yellow-classic-2",
"common-dropdown-icon-next",
"common-dropdown-icon-next-disabled",
"common-dropdown-icon-play",
"common-dropdown-icon-radialtick-yellow",
"common-dropdown-icon-radialtick-yellow-classic",
"common-dropdown-icon-sound-off",
"common-dropdown-icon-sound-on",
"common-dropdown-icon-stop",
"common-dropdown-textholder",
"common-dropdown-tickradial",
"common-dropdown-tickradial-classic",
"common-dropdown-ticksquare",
"common-dropdown-ticksquare-classic",
"common-gray-button-entrybox-center",
"common-gray-button-entrybox-left",
"common-gray-button-entrybox-right",
"common-icon-backarrow",
"common-icon-backarrow-disable",
"common-icon-checkmark",
"common-icon-checkmark-yellow",
"common-icon-forwardarrow",
"common-icon-forwardarrow-disable",
"common-icon-forwardarrow_ALT",
"common-icon-redx",
"common-icon-rotateleft",
"common-icon-rotateright",
"common-icon-undo",
"common-icon-zoomin",
"common-icon-zoomin-disable",
"common-icon-zoomout",
"common-icon-zoomout-disable",
"common-search-border-left",
"common-search-border-middle",
"common-search-border-right",
"common-search-clearbutton",
"common-search-magnifyingglass",
"communities-chat-date-line",
"communities-chat-date-line-orange",
"communities-create-avatar-border-hover",
"communities-create-avatar-border-selected",
"communities-create-button-bnet-down",
"communities-create-button-bnet-highlight",
"communities-create-button-bnet-up",
"communities-create-button-highlight",
"communities-create-button-wow-alliance",
"communities-create-button-wow-down",
"communities-create-button-wow-horde",
"communities-create-button-wow-up",
"communities-guildbanner-background",
"communities-guildbanner-border",
"communities-icon-addchannelplus",
"communities-icon-addgroupplus",
"communities-icon-chat",
"communities-icon-invitemail",
"communities-icon-lock",
"communities-icon-notification",
"communities-icon-redx",
"communities-nav-button-green-normal",
"communities-nav-button-green-pressed",
"communities-ring-blue",
"communities-ring-gold",
"communities-widebackground",
"communitiesfinder-card",
"communitiesfinder_card_highlight",
"countdown-swords",
"countdown-swords-glow",
"deathrecap-background-innerglow",
"deathrecap-icon-tombstone",
"deathrecap-iconborder",
"dreadlord-icon",
"dressingroom-background-deathknight",
"dressingroom-background-demonhunter",
"dressingroom-background-druid",
"dressingroom-background-hunter",
"dressingroom-background-mage",
"dressingroom-background-monk",
"dressingroom-background-paladin",
"dressingroom-background-priest",
"dressingroom-background-rogue",
"dressingroom-background-shaman",
"dressingroom-background-warlock",
"dressingroom-background-warrior",
"equipmentmanager-spec-border",
"friendslist-categorybutton",
"friendslist-categorybutton-arrow-down",
"friendslist-categorybutton-arrow-right",
"friendslist-invitebutton-alliance-disabled",
"friendslist-invitebutton-alliance-normal",
"friendslist-invitebutton-alliance-pressed",
"friendslist-invitebutton-default-disabled",
"friendslist-invitebutton-default-normal",
"friendslist-invitebutton-default-pressed",
"friendslist-invitebutton-highlight",
"friendslist-invitebutton-horde-disabled",
"friendslist-invitebutton-horde-normal",
"friendslist-invitebutton-horde-pressed",
"glueannouncementpopup-arrow",
"glueannouncementpopup-background",
"glueannouncementpopup-icon-info",
"glueannouncementpopup-inset",
"glues-characterSelect-TopHUD-BG",
"glues-characterSelect-TopHUD-BG-divider",
"glues-characterSelect-TopHUD-BG-divider-dis",
"glues-characterSelect-TopHUD-left-BG",
"glues-characterSelect-TopHUD-left-dis-BG",
"glues-characterSelect-TopHUD-middle-BG",
"glues-characterSelect-TopHUD-middle-dis-BG",
"glues-characterSelect-TopHUD-right-BG",
"glues-characterSelect-TopHUD-right-dis-BG",
"glues-characterSelect-TopHUD-selected-left",
"glues-characterSelect-TopHUD-selected-line-left",
"glues-characterSelect-TopHUD-selected-line-middle",
"glues-characterSelect-TopHUD-selected-line-right",
"glues-characterSelect-TopHUD-selected-middle",
"glues-characterSelect-TopHUD-selected-right",
"glues-characterSelect-button-card",
"glues-characterSelect-button-card-down-disabled",
"glues-characterSelect-button-card-down-disabled-hover",
"glues-characterSelect-button-card-hover",
"glues-characterSelect-button-card-pressed",
"glues-characterSelect-button-card-up-disabled",
"glues-characterSelect-button-card-up-disabled-hover",
"glues-characterSelect-button-collapseExpand",
"glues-characterSelect-button-collapseExpand-disabled",
"glues-characterSelect-button-collapseExpand-down-small-disabled",
"glues-characterSelect-button-collapseExpand-hover",
"glues-characterSelect-button-collapseExpand-pressed",
"glues-characterSelect-button-collapseExpand-small",
"glues-characterSelect-button-collapseExpand-small-hover",
"glues-characterSelect-button-collapseExpand-small-pressed",
"glues-characterSelect-button-collapseExpand-up-small-disabled",
"glues-characterSelect-card-FX-spreadA",
"glues-characterSelect-card-FX-spreadB",
"glues-characterSelect-card-all-BG",
"glues-characterSelect-card-camp",
"glues-characterSelect-card-camp-BG",
"glues-characterSelect-card-camp-BG-glow",
"glues-characterSelect-card-camp-hover",
"glues-characterSelect-card-drag",
"glues-characterSelect-card-empty",
"glues-characterSelect-card-empty-hover",
"glues-characterSelect-card-glow",
"glues-characterSelect-card-glow-FX",
"glues-characterSelect-card-glow-swap",
"glues-characterSelect-card-selected",
"glues-characterSelect-card-selected-hover",
"glues-characterSelect-card-singles",
"glues-characterSelect-card-singles-hover",
"glues-characterSelect-cardDivider",
"glues-characterSelect-divider",
"glues-characterSelect-icon-FX-plus",
"glues-characterSelect-icon-addCard",
"glues-characterSelect-icon-addCard-glow",
"glues-characterSelect-icon-appearanceChange",
"glues-characterSelect-icon-appearanceChange-hover",
"glues-characterSelect-icon-arrowDown",
"glues-characterSelect-icon-arrowDown-disabled",
"glues-characterSelect-icon-arrowDown-hover",
"glues-characterSelect-icon-arrowDown-pressed",
"glues-characterSelect-icon-arrowDown-pressed-hover",
"glues-characterSelect-icon-arrowDown-small",
"glues-characterSelect-icon-arrowDown-small-hover",
"glues-characterSelect-icon-arrowDown-small-pressed",
"glues-characterSelect-icon-arrowUp",
"glues-characterSelect-icon-arrowUp-hover",
"glues-characterSelect-icon-arrowUp-pressed",
"glues-characterSelect-icon-arrowUp-pressed-hover",
"glues-characterSelect-icon-arrowUp-small",
"glues-characterSelect-icon-arrowUp-small-hover",
"glues-characterSelect-icon-arrowUp-small-pressed",
"glues-characterSelect-icon-faction-alliance",
"glues-characterSelect-icon-faction-alliance-hover",
"glues-characterSelect-icon-faction-alliance-selected",
"glues-characterSelect-icon-faction-horde",
"glues-characterSelect-icon-faction-horde-hover",
"glues-characterSelect-icon-faction-horde-selected",
"glues-characterSelect-icon-factionChange",
"glues-characterSelect-icon-factionChange-hover",
"glues-characterSelect-icon-minus",
"glues-characterSelect-icon-minus-disabled",
"glues-characterSelect-icon-minus-hover",
"glues-characterSelect-icon-minus-pressed",
"glues-characterSelect-icon-notify-BG",
"glues-characterSelect-icon-notify-BG-hover",
"glues-characterSelect-icon-notify-inProgress",
"glues-characterSelect-icon-notify-inProgress-hover",
"glues-characterSelect-icon-notify-lock",
"glues-characterSelect-icon-notify-lock-hover",
"glues-characterSelect-icon-notify-mail",
"glues-characterSelect-icon-notify-mail-hover",
"glues-characterSelect-icon-plus",
"glues-characterSelect-icon-plus-disabled",
"glues-characterSelect-icon-plus-hover",
"glues-characterSelect-icon-plus-pressed",
"glues-characterSelect-icon-raceChange",
"glues-characterSelect-icon-raceChange-hover",
"glues-characterSelect-icon-restoreCharacter",
"glues-characterSelect-icon-restoreCharacter-hover",
"glues-characterSelect-icon-restoreCharacter-pointer",
"glues-characterSelect-icon-search",
"glues-characterSelect-iconShop",
"glues-characterSelect-iconShop-dis",
"glues-characterSelect-iconShop-hover",
"glues-characterSelect-listLauncher-BG",
"glues-characterSelect-listRealm-BG",
"glues-characterSelect-nameBG",
"glues-characterSelect-plus-pressed",
"glues-characterSelect-scroll-arrow-down",
"glues-characterSelect-scroll-arrow-up",
"glues-characterSelect-scrollbar",
"glues-characterSelect-scrollbar-BG",
"glues-characterSelect-searchbar",
"glues-gameMode-BG",
"glues-gameMode-glw-bottom",
"glues-gameMode-glw-top",
"glues-gameMode-selectArrow",
"glues-gameMode-txtBG",
"gmchat-icon-alert",
"gmchat-icon-blizz",
"gmchat-icon-wow",
"gmchat-nineslice-cornerbottomleft",
"gmchat-nineslice-cornerbottomright",
"gmchat-nineslice-cornertopleft",
"gmchat-nineslice-cornertopright",
"gmchat-watermark-blizzard",
"gmglow-nineslice-cornerbottomleft",
"gmglow-nineslice-cornerbottomright",
"gmglow-nineslice-cornertopleft",
"gmglow-nineslice-cornertopright",
"groupfinder-background",
"groupfinder-background-arenas",
"groupfinder-background-ashran",
"groupfinder-background-battlegrounds",
"groupfinder-background-classic",
"groupfinder-background-custom-pve",
"groupfinder-background-custom-pvp",
"groupfinder-background-dungeons",
"groupfinder-background-islands",
"groupfinder-background-questing",
"groupfinder-background-raids-battleforazeroth",
"groupfinder-background-raids-bc",
"groupfinder-background-raids-cataclysm",
"groupfinder-background-raids-classic",
"groupfinder-background-raids-dragonflight",
"groupfinder-background-raids-legion",
"groupfinder-background-raids-mists",
"groupfinder-background-raids-shadowlands",
"groupfinder-background-raids-warlords",
"groupfinder-background-raids-wrath",
"groupfinder-background-ratedbgs",
"groupfinder-background-scenarios",
"groupfinder-background-skirmishes",
"groupfinder-background-torghast",
"groupfinder-button-arenas",
"groupfinder-button-ashran",
"groupfinder-button-battlegrounds",
"groupfinder-button-cover",
"groupfinder-button-cover-down",
"groupfinder-button-custom-pve",
"groupfinder-button-custom-pvp",
"groupfinder-button-dungeons",
"groupfinder-button-highlight",
"groupfinder-button-islands",
"groupfinder-button-questing",
"groupfinder-button-raids-battleforazeroth",
"groupfinder-button-raids-bc",
"groupfinder-button-raids-cataclysm",
"groupfinder-button-raids-classic",
"groupfinder-button-raids-dragonflight",
"groupfinder-button-raids-legion",
"groupfinder-button-raids-mists",
"groupfinder-button-raids-shadowlands",
"groupfinder-button-raids-warlords",
"groupfinder-button-raids-wrath",
"groupfinder-button-ratedbgs",
"groupfinder-button-scenarios",
"groupfinder-button-select",
"groupfinder-button-skirmishes",
"groupfinder-button-torghast",
"groupfinder-eye-backglow",
"groupfinder-eye-circshine",
"groupfinder-eye-flipbook-found-initial",
"groupfinder-eye-flipbook-found-loop",
"groupfinder-eye-flipbook-foundfx",
"groupfinder-eye-flipbook-initial",
"groupfinder-eye-flipbook-mouseover",
"groupfinder-eye-flipbook-poke-end",
"groupfinder-eye-flipbook-poke-initial",
"groupfinder-eye-flipbook-poke-loop",
"groupfinder-eye-flipbook-searching",
"groupfinder-eye-frame",
"groupfinder-eye-frontglow",
"groupfinder-eye-highlight",
"groupfinder-eye-single",
"groupfinder-highlightbar-blue",
"groupfinder-highlightbar-green",
"groupfinder-highlightbar-yellow",
"groupfinder-icon-class-deathknight",
"groupfinder-icon-class-demonhunter",
"groupfinder-icon-class-druid",
"groupfinder-icon-class-hunter",
"groupfinder-icon-class-mage",
"groupfinder-icon-class-monk",
"groupfinder-icon-class-paladin",
"groupfinder-icon-class-priest",
"groupfinder-icon-class-rogue",
"groupfinder-icon-class-shaman",
"groupfinder-icon-class-warlock",
"groupfinder-icon-class-warrior",
"groupfinder-icon-emptyslot",
"groupfinder-icon-friend",
"groupfinder-icon-greencheckmark",
"groupfinder-icon-leader",
"groupfinder-icon-lock",
"groupfinder-icon-quest",
"groupfinder-icon-redx",
"groupfinder-icon-role-large-dps",
"groupfinder-icon-role-large-heal",
"groupfinder-icon-role-large-tank",
"groupfinder-icon-role-micro-dps",
"groupfinder-icon-role-micro-heal",
"groupfinder-icon-role-micro-tank",
"groupfinder-icon-voice",
"groupfinder-waitdot",
"guild-levelring",
"guildfinder-card",
"guildfinder-card-guildbanner-background",
"guildfinder-card-guildbanner-border",
"guildfinder-card-guildbanner-shadow",
"honorsystem-bar-background",
"honorsystem-bar-frame",
"honorsystem-bar-frame-exhaustiontick",
"honorsystem-bar-frame-exhaustiontick-highlight",
"honorsystem-bar-frame-small",
"honorsystem-bar-lock",
"honorsystem-bar-rewardborder",
"honorsystem-bar-rewardborder-circle",
"honorsystem-bar-rewardborder-prestige",
"honorsystem-bar-rewardborder-prestige-flash",
"honorsystem-bar-spark",
"honorsystem-icon-bonus",
"honorsystem-icon-enlistmentbonus",
"honorsystem-icon-prestige-1",
"honorsystem-icon-prestige-10",
"honorsystem-icon-prestige-11",
"honorsystem-icon-prestige-2",
"honorsystem-icon-prestige-3",
"honorsystem-icon-prestige-4",
"honorsystem-icon-prestige-5",
"honorsystem-icon-prestige-6",
"honorsystem-icon-prestige-7",
"honorsystem-icon-prestige-8",
"honorsystem-icon-prestige-9",
"honorsystem-portrait-alliance",
"honorsystem-portrait-horde",
"honorsystem-portrait-neutral",
"honorsystem-prestige-laurel",
"honorsystem-prestige-laurel-bg-alliance",
"honorsystem-prestige-laurel-bg-horde",
"honorsystem-prestige-rewardline",
"honorsystem-prestige-smallwreath",
"honorsystem-talents-bg",
"horde_icon_alliance_flag-dynamicIcon",
"horde_icon_alliance_flag-flash",
"horde_icon_alliance_flag-icon",
"horde_icon_and_flag-dynamicIcon",
"horde_icon_and_flag-flash",
"horde_icon_and_flag-icon",
"horde_tower-icon",
"hud-MainMenuBar-arrowdown-disabled",
"hud-MainMenuBar-arrowdown-down",
"hud-MainMenuBar-arrowdown-highlight",
"hud-MainMenuBar-arrowdown-up",
"hud-MainMenuBar-arrowup-disabled",
"hud-MainMenuBar-arrowup-down",
"hud-MainMenuBar-arrowup-highlight",
"hud-MainMenuBar-arrowup-up",
"hud-MainMenuBar-experiencebar-large-double",
"hud-MainMenuBar-experiencebar-large-single",
"hud-MainMenuBar-experiencebar-small-double",
"hud-MainMenuBar-experiencebar-small-single",
"hud-MainMenuBar-gryphon",
"hud-MainMenuBar-large",
"hud-MainMenuBar-small",
"hud-MicroBagBar",
"hud-microbutton-Achievement-Disabled",
"hud-microbutton-Achievement-Down",
"hud-microbutton-Achievement-Up",
"hud-microbutton-BStore-Disabled",
"hud-microbutton-BStore-Down",
"hud-microbutton-BStore-Up",
"hud-microbutton-Character-Down",
"hud-microbutton-Character-Up",
"hud-microbutton-EJ-Disabled",
"hud-microbutton-EJ-Down",
"hud-microbutton-EJ-Up",
"hud-microbutton-Guild-Banner",
"hud-microbutton-LFG-Disabled",
"hud-microbutton-LFG-Down",
"hud-microbutton-LFG-Up",
"hud-microbutton-MainMenu-Disabled",
"hud-microbutton-MainMenu-Down",
"hud-microbutton-MainMenu-Up",
"hud-microbutton-Mounts-Disabled",
"hud-microbutton-Mounts-Down",
"hud-microbutton-Mounts-Up",
"hud-microbutton-Quest-Disabled",
"hud-microbutton-Quest-Down",
"hud-microbutton-Quest-Up",
"hud-microbutton-Socials-Disabled",
"hud-microbutton-Socials-Down",
"hud-microbutton-Socials-Up",
"hud-microbutton-Spellbook-Disabled",
"hud-microbutton-Spellbook-Down",
"hud-microbutton-Spellbook-Up",
"hud-microbutton-StreamDL-Down",
"hud-microbutton-StreamDL-Up",
"hud-microbutton-Talents-Disabled",
"hud-microbutton-Talents-Down",
"hud-microbutton-Talents-Up",
"hud-microbutton-communities-icon-notification",
"hud-microbutton-highlight",
"hud-microbutton-highlightalert",
"insetshadow",
"inspect-talent-selected",
"lang-alert-deDE",
"lang-alert-enCN",
"lang-alert-enGB",
"lang-alert-enTW",
"lang-alert-enUS",
"lang-alert-esES",
"lang-alert-esMX",
"lang-alert-frFR",
"lang-alert-itIT",
"lang-alert-koKR",
"lang-alert-ptBR",
"lang-alert-ptPT",
"lang-alert-ruRU",
"lang-alert-zhCN",
"lang-alert-zhTW",
"legioninvasion-ScenarioTrackerToast",
"legioninvasion-Toast-Frame",
"legioninvasion-map-cover",
"legioninvasion-map-icon-portal",
"legioninvasion-map-icon-portal-large",
"legioninvasion-scenario-rewardring",
"legioninvasion-title-bg",
"legionmission-EncounterAbilityBorder",
"legionmission-EncounterAbilityBorder-Lg",
"legionmission-background-combatally",
"legionmission-complete-background-deathknight",
"legionmission-complete-background-demonhunter",
"legionmission-complete-background-druid",
"legionmission-complete-background-hunter",
"legionmission-complete-background-mage",
"legionmission-complete-background-monk",
"legionmission-complete-background-paladin",
"legionmission-complete-background-priest",
"legionmission-complete-background-rogue",
"legionmission-complete-background-shaman",
"legionmission-complete-background-warlock",
"legionmission-complete-background-warrior",
"legionmission-hearts-background",
"legionmission-icon-currency",
"legionmission-landingbutton-deathknight-down",
"legionmission-landingbutton-deathknight-up",
"legionmission-landingbutton-demonhunter-down",
"legionmission-landingbutton-demonhunter-up",
"legionmission-landingbutton-druid-down",
"legionmission-landingbutton-druid-up",
"legionmission-landingbutton-hunter-down",
"legionmission-landingbutton-hunter-up",
"legionmission-landingbutton-mage-down",
"legionmission-landingbutton-mage-up",
"legionmission-landingbutton-monk-down",
"legionmission-landingbutton-monk-up",
"legionmission-landingbutton-paladin-down",
"legionmission-landingbutton-paladin-up",
"legionmission-landingbutton-priest-down",
"legionmission-landingbutton-priest-up",
"legionmission-landingbutton-rogue-down",
"legionmission-landingbutton-rogue-up",
"legionmission-landingbutton-shaman-down",
"legionmission-landingbutton-shaman-up",
"legionmission-landingbutton-warlock-down",
"legionmission-landingbutton-warlock-up",
"legionmission-landingbutton-warrior-down",
"legionmission-landingbutton-warrior-up",
"legionmission-landingpage-background-deathknight",
"legionmission-landingpage-background-demonhunter",
"legionmission-landingpage-background-druid",
"legionmission-landingpage-background-hunter",
"legionmission-landingpage-background-mage",
"legionmission-landingpage-background-monk",
"legionmission-landingpage-background-paladin",
"legionmission-landingpage-background-priest",
"legionmission-landingpage-background-rogue",
"legionmission-landingpage-background-shaman",
"legionmission-landingpage-background-warlock",
"legionmission-landingpage-background-warrior",
"legionmission-lock",
"legionmission-map-orderhall-deathknight",
"legionmission-map-orderhall-demonhunter",
"legionmission-map-orderhall-druid",
"legionmission-map-orderhall-glow",
"legionmission-map-orderhall-hunter",
"legionmission-map-orderhall-mage",
"legionmission-map-orderhall-monk",
"legionmission-map-orderhall-paladin",
"legionmission-map-orderhall-priest",
"legionmission-map-orderhall-rogue",
"legionmission-map-orderhall-shaman",
"legionmission-map-orderhall-textglow",
"legionmission-map-orderhall-warlock",
"legionmission-map-orderhall-warrior",
"legionmission-portraitring-epicplus",
"legionmission-portraitring_levelborder_epicplus",
"loottab-background",
"loottab-set-background",
"loottab-set-itemborder-artifact",
"loottab-set-itemborder-blue",
"loottab-set-itemborder-green",
"loottab-set-itemborder-orange",
"loottab-set-itemborder-purple",
"loottab-set-itemborder-white",
"loottoast-arrow-blue",
"loottoast-arrow-green",
"loottoast-arrow-orange",
"loottoast-arrow-purple",
"loottoast-bg-alliance",
"loottoast-bg-horde",
"loottoast-bg-questrewardupgrade",
"loottoast-glow",
"loottoast-itemborder-artifact",
"loottoast-itemborder-blue",
"loottoast-itemborder-glow",
"loottoast-itemborder-gold",
"loottoast-itemborder-green",
"loottoast-itemborder-heirloom",
"loottoast-itemborder-orange",
"loottoast-itemborder-purple",
"loottoast-sheen",
"macropopup-bottomleft",
"macropopup-bottomright",
"macropopup-bottomright-nobuttons",
"macropopup-intersect-left",
"macropopup-intersect-right",
"macropopup-scrollbar-bottom",
"macropopup-scrollbar-top",
"macropopup-topleft",
"macropopup-topleft2",
"macropopup-topright",
"macropopup-topright2",
"map-icon-SuramarDoor.tga",
"map-icon-deathknightclasshall",
"map-icon-ignored-blueexclaimation",
"map-icon-ignored-bluequestion",
"minimal-scrollbar-arrow-bottom",
"minimal-scrollbar-arrow-bottom-down",
"minimal-scrollbar-arrow-bottom-over",
"minimal-scrollbar-arrow-bottom-over_ALT",
"minimal-scrollbar-arrow-returntobottom",
"minimal-scrollbar-arrow-returntobottom-down",
"minimal-scrollbar-arrow-returntobottom-over",
"minimal-scrollbar-arrow-top",
"minimal-scrollbar-arrow-top-down",
"minimal-scrollbar-arrow-top-over",
"minimal-scrollbar-small-arrow-bottom",
"minimal-scrollbar-small-arrow-bottom-down",
"minimal-scrollbar-small-arrow-bottom-over",
"minimal-scrollbar-small-arrow-returntobottom",
"minimal-scrollbar-small-arrow-returntobottom-down",
"minimal-scrollbar-small-arrow-returntobottom-over",
"minimal-scrollbar-small-arrow-top",
"minimal-scrollbar-small-arrow-top-down",
"minimal-scrollbar-small-arrow-top-over",
"minimal-scrollbar-small-thumb-bottom",
"minimal-scrollbar-small-thumb-bottom-down",
"minimal-scrollbar-small-thumb-bottom-over",
"minimal-scrollbar-small-thumb-middle",
"minimal-scrollbar-small-thumb-middle-down",
"minimal-scrollbar-small-thumb-middle-over",
"minimal-scrollbar-small-thumb-top",
"minimal-scrollbar-small-thumb-top-down",
"minimal-scrollbar-small-thumb-top-over",
"minimal-scrollbar-small-track-bottom",
"minimal-scrollbar-small-track-top",
"minimal-scrollbar-thumb-bottom",
"minimal-scrollbar-thumb-bottom-down",
"minimal-scrollbar-thumb-bottom-over",
"minimal-scrollbar-thumb-middle",
"minimal-scrollbar-thumb-middle-down",
"minimal-scrollbar-thumb-middle-over",
"minimal-scrollbar-thumb-top",
"minimal-scrollbar-thumb-top-down",
"minimal-scrollbar-thumb-top-over",
"minimal-scrollbar-track-bottom",
"minimal-scrollbar-track-top",
"minortalents-backplate",
"minortalents-descriptionshadow",
"minortalents-icon-book",
"minortalents-iconcover",
"nameplate-WarlockShard-Glow",
"nameplate-WarlockShard-Off",
"nameplate-WarlockShard-On",
"nameplates-InterruptShield",
"nameplates-bar-background",
"nameplates-bar-background-white",
"nameplates-holypower1-off",
"nameplates-holypower1-on",
"nameplates-holypower2-off",
"nameplates-holypower2-on",
"nameplates-holypower3-off",
"nameplates-holypower3-on",
"nameplates-holypower4-off",
"nameplates-holypower4-on",
"nameplates-icon-elite-gold",
"nameplates-icon-elite-silver",
"nameplates-playerhealth-background",
"neutral_tower-icon",
"newplayerchat-chaticon-guide",
"newplayerchat-chaticon-newcomer",
"newplayertutorial-drag-cursor",
"newplayertutorial-drag-slotblue",
"newplayertutorial-drag-slotgreen",
"newplayertutorial-greenglow-redbutton-left",
"newplayertutorial-greenglow-redbutton-middle",
"newplayertutorial-greenglow-redbutton-right",
"newplayertutorial-icon-key",
"newplayertutorial-icon-mouse-leftbutton",
"newplayertutorial-icon-mouse-middlebutton",
"newplayertutorial-icon-mouse-rightbutton",
"newplayertutorial-icon-mouse-turn",
"newplayertutorial-keyboard",
"obliterumforge-background",
"obliterumforge-slotted-corners",
"obliterumforge-slotted-corners-glow",
"options-notch",
"optionsframe-nineslice-cornerbottomleft",
"optionsframe-nineslice-cornerbottomright",
"optionsframe-nineslice-cornertopleft",
"optionsframe-nineslice-cornertopright",
"orderhall-commandbar-iconmask",
"orderhall-commandbar-mapbutton-down",
"orderhall-commandbar-mapbutton-up",
"orderhalltalents-background-deathknight",
"orderhalltalents-background-demonhunter",
"orderhalltalents-background-druid",
"orderhalltalents-background-hunter",
"orderhalltalents-background-mage",
"orderhalltalents-background-monk",
"orderhalltalents-background-paladin",
"orderhalltalents-background-priest",
"orderhalltalents-background-rogue",
"orderhalltalents-background-shaman",
"orderhalltalents-background-warlock",
"orderhalltalents-background-warrior",
"orderhalltalents-choice-arrow-large",
"orderhalltalents-choice-background",
"orderhalltalents-choice-background-on",
"orderhalltalents-done-checkmark",
"orderhalltalents-done-glow",
"orderhalltalents-spellborder",
"orderhalltalents-spellborder-green",
"orderhalltalents-spellborder-yellow",
"orderhalltalents-timer-bg",
"placeholder-icon",
"plunderstorm-UI-HUD-UnitFrame-Party-PortraitOn",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn-2x",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn-InCombat",
"plunderstorm-UI-HUD-UnitFrame-Player-PortraitOn-InCombat-2x",
"plunderstorm-actionbar-slot-background",
"plunderstorm-actionbar-slot-border",
"plunderstorm-actionbar-slot-border-swappable",
"plunderstorm-actionbar-slot-corners",
"plunderstorm-actionbar-slot-pip",
"plunderstorm-actionbar-slot-pipbackground",
"plunderstorm-actionbar-tabswappable-background",
"plunderstorm-actionbar-topper-attack",
"plunderstorm-actionbar-topper-offensive",
"plunderstorm-actionbar-topper-potion",
"plunderstorm-icon-fullyupgraded",
"plunderstorm-icon-item",
"plunderstorm-icon-key",
"plunderstorm-icon-kills",
"plunderstorm-icon-offensive",
"plunderstorm-icon-plunderCoins",
"plunderstorm-icon-plunderCoins-big",
"plunderstorm-icon-small-fullyupgraded",
"plunderstorm-icon-small-item",
"plunderstorm-icon-small-offensive",
"plunderstorm-icon-small-upgrade",
"plunderstorm-icon-small-utility",
"plunderstorm-icon-trophy",
"plunderstorm-icon-upgrade",
"plunderstorm-icon-utility",
"plunderstorm-landingpagebutton-down",
"plunderstorm-landingpagebutton-up",
"plunderstorm-nameplates-icon-1",
"plunderstorm-nameplates-icon-2",
"plunderstorm-nameplates-icon-3",
"plunderstorm-nameplates-icon-ring",
"plunderstorm-new-dot-lg",
"plunderstorm-new-dot-sm",
"plunderstorm-pickup-BG",
"plunderstorm-pickup-arrow",
"plunderstorm-pickup-mouseclick-left",
"plunderstorm-pickup-mouseclick-right",
"plunderstorm-pvpqueue-background",
"plunderstorm-pvpqueue-catergory-icon",
"plunderstorm-pvpqueue-sidebar-background",
"plunderstorm-scenariotracker-active",
"plunderstorm-scenariotracker-active-decoration",
"plunderstorm-scenariotracker-active-frame",
"plunderstorm-scenariotracker-decoration",
"plunderstorm-scenariotracker-waiting",
"plunderstorm-scenariotracker-waiting-decoration",
"plunderstorm-scenariotracker-waiting-frame",
"plunderstorm-spectate-arrow",
"plunderstorm-spectate-background",
"plunderstorm-stormbar-BGCenter",
"plunderstorm-stormbar-BGLeft",
"plunderstorm-stormbar-BGRight",
"plunderstorm-stormbar-BorderCenter",
"plunderstorm-stormbar-BorderLeft",
"plunderstorm-stormbar-BorderRight",
"plunderstorm-stormbar-background",
"plunderstorm-stormbar-border",
"plunderstorm-stormbar-fill",
"plunderstorm-stormbar-fill-filling",
"plunderstorm-stormbar-spark",
"plunderstorm-toast-BG-matchComplete",
"plunderstorm-toast-BG-queue",
"plunderstorm-toast-BG-statDetails",
"plunderstorm-toast-bottomDecal",
"plunderstorm-toast-bottomDecal-line",
"plunderstorm-toast-divider",
"plunderstorm-toast-finish-lose",
"plunderstorm-toast-finish-matchend",
"plunderstorm-toast-finish-win",
"plunderstorm-toast-levelup-background",
"plunderstorm-toast-swords",
"plunderstorm-toast-swords-line",
"plunderstorm-waypoint-ring",
"poi-alliance",
"poi-door",
"poi-door-arrow-down",
"poi-door-arrow-up",
"poi-door-down",
"poi-door-left",
"poi-door-right",
"poi-door-up",
"poi-graveyard-neutral",
"poi-horde",
"poi-majorcity",
"poi-rift1",
"poi-rift2",
"poi-town",
"poi-transmogrifier",
"poi-workorders",
"pvp_ffa-icon",
"pvpqueue-bg-alliance",
"pvpqueue-bg-horde",
"pvprated-loottoast-bg-alliance",
"pvprated-loottoast-bg-horde",
"quickjoin-button-friendslist-down",
"quickjoin-button-friendslist-up",
"quickjoin-button-group-down",
"quickjoin-button-group-up",
"quickjoin-button-quickjoin-down",
"quickjoin-button-quickjoin-up",
"quickjoin-toast-background",
"quickjoin-toast-lines",
"raceicon-bloodelf-female",
"raceicon-bloodelf-male",
"raceicon-draenei-female",
"raceicon-draenei-male",
"raceicon-dwarf-female",
"raceicon-dwarf-male",
"raceicon-gnome-female",
"raceicon-gnome-male",
"raceicon-goblin-female",
"raceicon-goblin-male",
"raceicon-highmountain-female",
"raceicon-highmountain-male",
"raceicon-human-female",
"raceicon-human-male",
"raceicon-lightforged-female",
"raceicon-lightforged-male",
"raceicon-nightborne-female",
"raceicon-nightborne-male",
"raceicon-nightelf-female",
"raceicon-nightelf-male",
"raceicon-orc-female",
"raceicon-orc-male",
"raceicon-pandaren-female",
"raceicon-pandaren-male",
"raceicon-tauren-female",
"raceicon-tauren-male",
"raceicon-troll-female",
"raceicon-troll-male",
"raceicon-undead-female",
"raceicon-undead-male",
"raceicon-voidelf-female",
"raceicon-voidelf-male",
"raceicon-worgen-female",
"raceicon-worgen-male",
"recipetoast-bg",
"recipetoast-icon-star",
"reportlist-buttonselect",
"search-highlight",
"search-highlight-large",
"search-iconframe-large",
"search-select",
"services-checkmark",
"services-cover",
"services-cover-ring",
"services-icon-bonus",
"services-icon-bonus-large",
"services-icon-bonus-red",
"services-icon-goldborder",
"services-icon-processing",
"services-icon-warning",
"services-number-1",
"services-number-2",
"services-number-3",
"services-number-4",
"services-number-5",
"services-number-6",
"services-number-7",
"services-number-8",
"services-number-9",
"services-popup-bg",
"services-popup-bot",
"services-popup-botleft",
"services-popup-botright",
"services-popup-left",
"services-popup-right",
"services-popup-top",
"services-popup-topleft",
"services-popup-topright",
"services-ring",
"services-ring-countcircle",
"services-ring-large",
"services-ring-large-glow",
"services-ring-large-glowpulse",
"services-ring-large-glowspin",
"services-ring-wod",
"services-yellowarrow",
"shadoworbs-large-Frame",
"shadoworbs-large-Frame-OrbHighlight",
"shadoworbs-large-Orb",
"shadoworbs-large-Orb-Bg",
"shadoworbs-small-Frame",
"shadoworbs-small-Frame-OrbHighlight",
"shadoworbs-small-Orb",
"shadoworbs-small-Orb-Bg",
"shop-card-bundle",
"shop-card-bundle-alteracpup-feydragon",
"shop-card-bundle-hover",
"shop-card-bundle-legion",
"shop-card-bundle-reaver-argi",
"shop-card-bundle-selected",
"shop-card-bundle-starseekers",
"shop-card-darkcover",
"shop-card-full-bfadeluxe",
"shop-card-full-gametimebundle-90day",
"shop-card-full-legiondeluxe",
"shop-card-half-bfa",
"shop-card-half-bfadeluxe",
"shop-card-half-brownbox",
"shop-card-half-brownboxbfabundle",
"shop-card-half-brownboxlegionbundle",
"shop-card-half-hover",
"shop-card-half-legion",
"shop-card-half-legiondeluxe",
"shop-games-legion",
"shop-games-legiondeluxe",
"shop-games-legiondeluxe-card",
"shop-games-magnifyingglass",
"simplecheckout-close-hover-1x",
"simplecheckout-close-hover-2x",
"simplecheckout-close-normal-1x",
"simplecheckout-close-normal-2x",
"simplecheckout-close-pressed-1x",
"simplecheckout-close-pressed-2x",
"skull_bones-icon",
"sniper_shot-icon",
"socialqueuing-friendlist-summonbutton-disabled",
"socialqueuing-friendlist-summonbutton-down",
"socialqueuing-friendlist-summonbutton-up",
"socialqueuing-icon-clock",
"socialqueuing-icon-eye",
"socialqueuing-icon-group",
"socialqueuing-row-highlight",
"socialqueuing-row-select",
"splash-600-botleft",
"splash-600-right",
"splash-600-topleft",
"splash-601-botleft",
"splash-601-right",
"splash-601-topleft",
"splash-610-botleft",
"splash-610-right",
"splash-610-topleft",
"splash-620-botleft",
"splash-620-right",
"splash-620-topleft",
"splash-703-botleft",
"splash-703-right",
"splash-703-topleft",
"splash-704-botleft",
"splash-704-right",
"splash-704-topleft",
"splash-705-botleft",
"splash-705-right",
"splash-705-topleft",
"splash-710-botleft",
"splash-710-right",
"splash-710-topleft",
"splash-720-botleft",
"splash-720-right",
"splash-720-topleft",
"splash-725-botleft",
"splash-725-right",
"splash-725-topleft",
"splash-730-botleft",
"splash-730-right",
"splash-730-topleft",
"splash-735-botleft",
"splash-735-right",
"splash-735-topleft",
"splash-bigbutton",
"splash-boost-botleft",
"splash-boost-right",
"splash-boost-topleft",
"splash-botleft",
"talenttree-chromie-background",
"titleprestige-ember",
"titleprestige-glowcover",
"titleprestige-prestigeicon",
"titleprestige-prestigeiconplate-alliance",
"titleprestige-prestigeiconplate-horde",
"titleprestige-starcrown",
"titleprestige-starglow",
"titleprestige-title",
"titleprestige-title-bg",
"titleprestige-title2",
"titleprestige-wings",
"titleprestige-wings-white",
"titleprestige-wings2",
"titleprestige-wings2-white",
"titleprestige-wreath",
"token-button-category",
"token-choice-bnet",
"token-choice-wow",
"token-info-arrow",
"token-info-background",
"token-itemslot",
"tournamentarena-flag-large-blue",
"tournamentarena-flag-large-blue-flash",
"tournamentarena-flag-large-red",
"tournamentarena-flag-large-red-flash",
"tournamentarena-frame-bg-corner-blue",
"tournamentarena-frame-bg-corner-red",
"tournamentarena-frame-bg-side-blue",
"tournamentarena-frame-bg-side-red",
"tournamentarena-frame-bot",
"tournamentarena-frame-botleft",
"tournamentarena-frame-botright",
"tournamentarena-frame-left",
"tournamentarena-frame-right",
"tournamentarena-frame-top",
"tournamentarena-frame-topleft",
"tournamentarena-frame-topright",
"tournamentarena-titlebackplate",
"tournamentarena-winnerline",
"tradeskill-background-recipe",
"tradeskill-background-recipe-unlearned",
"tradeskills-iconborder",
"tradeskills-star",
"tradeskills-star-off",
"transmog-background-race-bloodelf",
"transmog-background-race-draenei",
"transmog-background-race-dwarf",
"transmog-background-race-gnome",
"transmog-background-race-goblin",
"transmog-background-race-human",
"transmog-background-race-nightelf",
"transmog-background-race-orc",
"transmog-background-race-pandaren",
"transmog-background-race-tauren",
"transmog-background-race-troll",
"transmog-background-race-undead",
"transmog-background-race-worgen",
"transmog-frame",
"transmog-frame-blackcover",
"transmog-frame-highlighted",
"transmog-frame-highlighted-small",
"transmog-frame-pink",
"transmog-frame-red",
"transmog-frame-selected",
"transmog-frame-small",
"transmog-frame-small-pink",
"transmog-frame-small-red",
"transmog-frame-small-selected",
"transmog-icon-chat",
"transmog-icon-checkmark",
"transmog-icon-downarrow",
"transmog-icon-hidden",
"transmog-icon-remove",
"transmog-icon-revert",
"transmog-icon-revert-small",
"transmog-icon-revert-small-disabled",
"transmog-nav-slot-back",
"transmog-nav-slot-chest",
"transmog-nav-slot-enchant",
"transmog-nav-slot-feet",
"transmog-nav-slot-hands",
"transmog-nav-slot-head",
"transmog-nav-slot-legs",
"transmog-nav-slot-mainhand",
"transmog-nav-slot-secondaryhand",
"transmog-nav-slot-selected",
"transmog-nav-slot-selected-small",
"transmog-nav-slot-shirt",
"transmog-nav-slot-shoulder",
"transmog-nav-slot-tabard",
"transmog-nav-slot-waist",
"transmog-nav-slot-wrist",
"transmog-set-border-collected",
"transmog-set-border-current",
"transmog-set-border-current-transmogged",
"transmog-set-border-highlighted",
"transmog-set-border-selected",
"transmog-set-border-unusable",
"transmog-set-iconrow-background",
"transmog-set-model-cutoff-fade",
"transmog-toast-bg",
"transmog-wardrobe-border-collected",
"transmog-wardrobe-border-current",
"transmog-wardrobe-border-current-transmogged",
"transmog-wardrobe-border-highlighted",
"transmog-wardrobe-border-selected",
"transmog-wardrobe-border-selected-smoke",
"transmog-wardrobe-border-selected-wisp",
"transmog-wardrobe-border-uncollected",
"transmog-wardrobe-border-unusable",
"ui-classicscrollbar-center",
"ui-classicscrollbar-endcap-bottom",
"ui-classicscrollbar-endcap-bottom-rounded",
"ui-classicscrollbar-endcap-top",
"ui-debug-tool-icon-large",
"ui-debug-tool-icon-small",
"ui-hud-wowlabs-actionbar-bookend-left",
"ui-hud-wowlabs-actionbar-bookend-right",
"ui-hud-wowlabs-actionbar-levelnumber-default",
"ui-hud-wowlabs-actionbar-levelnumber-levelup",
"ui-hud-wowlabs-actionbar-offense-cap",
"ui-hud-wowlabs-actionbar-utility-cap",
"ui-hud-wowlabs-actionbar-xp-bg",
"ui-hud-wowlabs-actionbar-xp-fill",
"ui-hud-wowlabs-actionbar-xp-frame",
"ui-hud-wowlabs-actionbar-xp-futurefill",
"ui-hud-wowlabs-actionbar-xp-threshold",
"ui-scrollbar-button-overlay",
"ui-scrollbar-button-overlay-horizontal",
"ui-scrollbar-endcap-bottom",
"ui-scrollbar-endcap-left",
"ui-scrollbar-endcap-right",
"ui-scrollbar-endcap-top",
"ui-scrollbar-knob-center",
"ui-scrollbar-knob-center-disabled",
"ui-scrollbar-knob-center-disabled-horizontal",
"ui-scrollbar-knob-center-horizontal",
"ui-scrollbar-knob-endcap-bottom",
"ui-scrollbar-knob-endcap-bottom-disabled",
"ui-scrollbar-knob-endcap-left",
"ui-scrollbar-knob-endcap-left-disabled",
"ui-scrollbar-knob-endcap-right",
"ui-scrollbar-knob-endcap-right-disabled",
"ui-scrollbar-knob-endcap-top",
"ui-scrollbar-knob-endcap-top-disabled",
"ui-scrollbar-knob-mouseover-center",
"ui-scrollbar-knob-mouseover-center-horizontal",
"ui-scrollbar-knob-mouseover-endcap-bottom",
"ui-scrollbar-knob-mouseover-endcap-left",
"ui-scrollbar-knob-mouseover-endcap-right",
"ui-scrollbar-knob-mouseover-endcap-top",
"ui-scrollbar-scrolldownbutton-disabled",
"ui-scrollbar-scrolldownbutton-down",
"ui-scrollbar-scrolldownbutton-highlight",
"ui-scrollbar-scrolldownbutton-up",
"ui-scrollbar-scrollleftbutton-disabled",
"ui-scrollbar-scrollleftbutton-down",
"ui-scrollbar-scrollleftbutton-highlight",
"ui-scrollbar-scrollleftbutton-up",
"ui-scrollbar-scrollrightbutton-disabled",
"ui-scrollbar-scrollrightbutton-down",
"ui-scrollbar-scrollrightbutton-highlight",
"ui-scrollbar-scrollrightbutton-up",
"ui-scrollbar-scrollupbutton-disabled",
"ui-scrollbar-scrollupbutton-down",
"ui-scrollbar-scrollupbutton-highlight",
"ui-scrollbar-scrollupbutton-up",
"uiframe-activetab-left",
"uiframe-activetab-right",
"uiframe-tab-left",
"uiframe-tab-right",
"uitools-button-background-active",
"uitools-button-background-default",
"uitools-button-background-disabled",
"uitools-icon-checkbox",
"uitools-icon-checkmark",
"uitools-icon-chevron-down",
"uitools-icon-chevron-left",
"uitools-icon-chevron-right",
"uitools-icon-close",
"uitools-icon-highlight",
"uitools-icon-minimize",
"uitools-icon-minus",
"uitools-icon-plus",
"uitools-icon-refresh",
"uitools-icon-search",
"uitools-icon-window-resize",
"uitools-icon-window-resize-down",
"uitools-icon-window-resize-over",
"uitools-row-background-01",
"uitools-row-background-02",
"uitools-row-background-hover",
"uitools-scrollbar-chevron-bottom",
"uitools-scrollbar-chevron-bottom-disabled",
"uitools-scrollbar-chevron-bottom-down",
"uitools-scrollbar-chevron-bottom-over",
"uitools-scrollbar-chevron-top",
"uitools-scrollbar-chevron-top-disabled",
"uitools-scrollbar-chevron-top-down",
"uitools-scrollbar-chevron-top-over",
"uitools-scrollbar-thumb",
"uitools-scrollbar-thumb-down",
"uitools-scrollbar-thumb-over",
"uitools-scrollbar-track",
"uitools-search-background",
"uitools-tab-background-active",
"uitools-tab-background-default",
"uitools-tab-gradient",
"uitools-title-bar-background",
"uitools-window-background",
"uitools-window-background-shadow",
"vas-receipt-brownarrow",
"vas-receipt-greenbg",
"vas-receipt-icon-characterborder",
"vas-receipt-selectedcharbg",
"voicechat-channellist-category-background",
"voicechat-channellist-category-highlight",
"voicechat-channellist-category-minus",
"voicechat-channellist-category-plus",
"voicechat-channellist-icon-STT-off",
"voicechat-channellist-icon-STT-on",
"voicechat-channellist-icon-headphone-off",
"voicechat-channellist-icon-headphone-on",
"voicechat-channellist-row-background",
"voicechat-channellist-row-background2",
"voicechat-channellist-row-highlight",
"voicechat-channellist-row-selected",
"voicechat-icon-STT",
"voicechat-icon-headphone-off",
"voicechat-icon-headphone-on",
"voicechat-icon-headphone-pending",
"voicechat-icon-headphone-pendingdot-1",
"voicechat-icon-headphone-pendingdot-2",
"voicechat-icon-headphone-pendingdot-3",
"voicechat-icon-headphone-switch",
"voicechat-icon-loudnessbar-1",
"voicechat-icon-loudnessbar-2",
"voicechat-icon-loudnessbar-3",
"voicechat-icon-mic",
"voicechat-icon-mic-mute",
"voicechat-icon-mic-mutesilenced",
"voicechat-icon-mic-silenced",
"voicechat-icon-speaker",
"voicechat-icon-speaker-mute",
"voicechat-icon-speaker-mutesilenced",
"voicechat-icon-speaker-silenced",
"voicechat-icon-textchat-silenced",
"voicechat-portrait-drag",
"voicechat-portrait-ring",
"warboard-background",
"warboard-header-alliance",
"warboard-header-horde",
"warboard-parchment",
"warboard-parchment-answerborder",
"warboard-title-alliance-left",
"warboard-title-alliance-right",
"warboard-title-horde-left",
"warboard-title-horde-right",
"warboard-title-neutral-left",
"warboard-title-neutral-right",
"warboard-zone-bc-BladesEdgeMountains",
"warboard-zone-bc-HellfirePeninsula",
"warboard-zone-bc-IsleofQuelDanas",
"warboard-zone-bc-Nagrand",
"warboard-zone-bc-Netherstorm",
"warboard-zone-bc-ShadowmoonValley",
"warboard-zone-bc-TerokkarForest",
"warboard-zone-bc-Zangarmarsh",
"warboard-zone-cata-Deepholm",
"warboard-zone-cata-ElementalBonds",
"warboard-zone-cata-MoltenFront",
"warboard-zone-cata-MountHyjal",
"warboard-zone-cata-TwilightHighlands",
"warboard-zone-cata-Uldum",
"warboard-zone-cata-Vashjir",
"warboard-zone-classic-ArathiHighlands",
"warboard-zone-classic-Ashenvale",
"warboard-zone-classic-Azshara",
"warboard-zone-classic-AzuremystIsle",
"warboard-zone-classic-Badlands",
"warboard-zone-classic-BlastedLands",
"warboard-zone-classic-BloodmystIsle",
"warboard-zone-classic-BurningSteppes",
"warboard-zone-classic-CapeofStranglethorn",
"warboard-zone-classic-Darkshore",
"warboard-zone-classic-Desolace",
"warboard-zone-classic-DunMorogh",
"warboard-zone-classic-Durotar",
"warboard-zone-classic-Duskwood",
"warboard-zone-classic-DustwallowMarsh",
"warboard-zone-classic-EasternPlaguelands",
"warboard-zone-classic-ElwynnForest",
"warboard-zone-classic-EversongWoods",
"warboard-zone-classic-Felwood",
"warboard-zone-classic-Feralas",
"warboard-zone-classic-Ghostlands",
"warboard-zone-classic-Gilneas",
"warboard-zone-classic-HillsbradFoothills",
"warboard-zone-classic-Hinterlands",
"warboard-zone-classic-LochModan",
"warboard-zone-classic-LostIsles",
"warboard-zone-classic-Mulgore",
"warboard-zone-classic-NorthernBarrens",
"warboard-zone-classic-NorthernStranglethorn",
"warboard-zone-classic-RedridgeMountains",
"warboard-zone-classic-SearingGorge",
"warboard-zone-classic-Silithus",
"warboard-zone-classic-SilverpineForest",
"warboard-zone-classic-SouthernBarrens",
"warboard-zone-classic-StonetalonMountains",
"warboard-zone-classic-SwampofSorrows",
"warboard-zone-classic-Tanaris",
"warboard-zone-classic-Teldrassil",
"warboard-zone-classic-ThousandNeedles",
"warboard-zone-classic-TirisfalGlades",
"warboard-zone-classic-UngoroCrater",
"warboard-zone-classic-WanderingIsle",
"warboard-zone-classic-WesternPlaguelands",
"warboard-zone-classic-Westfall",
"warboard-zone-classic-Wetlands",
"warboard-zone-classic-Winterspring",
"warboard-zone-mop-DreadWastes",
"warboard-zone-mop-IsleofGiants",
"warboard-zone-mop-IsleoftheThunderKing",
"warboard-zone-mop-JadeForest",
"warboard-zone-mop-KrasarangWilds",
"warboard-zone-mop-KunLaiSummit",
"warboard-zone-mop-TimelessIsle",
"warboard-zone-mop-TownlongSteppes",
"warboard-zone-mop-ValeofEternalBlossoms",
"warboard-zone-mop-ValleyoftheFourWinds",
"warboard-zone-wod-FrostfireRidge",
"warboard-zone-wod-Gorgrond",
"warboard-zone-wod-Nagrand",
"warboard-zone-wod-ShadowmoonValley",
"warboard-zone-wod-SpiresofArak",
"warboard-zone-wod-Talador",
"warboard-zone-wod-TanaanJungle",
"warboard-zone-wod-TanaanJungleIntro",
"warboard-zone-wotlk-BoreanTundra",
"warboard-zone-wotlk-CrystalsongForest",
"warboard-zone-wotlk-Dalaran",
"warboard-zone-wotlk-Dragonblight",
"warboard-zone-wotlk-GrizzlyHills",
"warboard-zone-wotlk-HowlingFjord",
"warboard-zone-wotlk-Icecrown",
"warboard-zone-wotlk-SholazarBasin",
"warboard-zone-wotlk-StormPeaks",
"warboard-zone-wotlk-ZulDrak",
"worldquest-emissary-ring",
"worldquest-emissary-tracker-checkmark",
"worldquest-followerabilityframe",
"worldquest-icon-alchemy",
"worldquest-icon-archaeology",
"worldquest-icon-blacksmithing",
"worldquest-icon-boss",
"worldquest-icon-burninglegion",
"worldquest-icon-clock",
"worldquest-icon-cooking",
"worldquest-icon-dungeon",
"worldquest-icon-enchanting",
"worldquest-icon-engineering",
"worldquest-icon-firstaid",
"worldquest-icon-fishing",
"worldquest-icon-herbalism",
"worldquest-icon-inscription",
"worldquest-icon-jewelcrafting",
"worldquest-icon-leatherworking",
"worldquest-icon-mining",
"worldquest-icon-petbattle",
"worldquest-icon-pvp-ffa",
"worldquest-icon-raid",
"worldquest-icon-skinning",
"worldquest-icon-tailoring",
"worldquest-questmarker-abilityhighlight",
"worldquest-questmarker-dragon",
"worldquest-questmarker-dragon-glow",
"worldquest-questmarker-epic",
"worldquest-questmarker-epic-down",
"worldquest-questmarker-glow",
"worldquest-questmarker-questbang",
"worldquest-questmarker-questionmark",
"worldquest-questmarker-rare",
"worldquest-questmarker-rare-down",
"worldquest-tracker",
"worldquest-tracker-bg-noemissary",
"worldquest-tracker-checkmark",
"worldquest-tracker-lock",
"worldquest-tracker-questmarker",
"worldquest-tracker-questmarker-gray",
"worldquest-tracker-ring",
"worldquest-tracker-ring-selected",
"worldstate-capturebar-arrow",
"worldstate-capturebar-blue",
"worldstate-capturebar-frame",
"worldstate-capturebar-frame-factions",
"worldstate-capturebar-frame-separater",
"worldstate-capturebar-glow",
"worldstate-capturebar-gray",
"worldstate-capturebar-green",
"worldstate-capturebar-purple",
"worldstate-capturebar-red",
"worldstate-capturebar-spark-green",
"worldstate-capturebar-spark-yellow",
"worldstate-capturebar-yellow",
"wowlabs-ability-icon-frame",
"wowlabs-currency-container-2x",
"wowlabs-currency-container-highlight-2x",
"wowlabs-rarity-pip",
"wowlabs-rarity-pip-bg",
"wowlabs-spell-icon-frame-highlight",
"wowlabs-switch-slots-key",
}


-- ========================================
-- File: WeakAuras/AuraEnvironment.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local LibSerialize = LibStub("LibSerialize")
local LibDeflate = LibStub:GetLibrary("LibDeflate")

local UnitAura = UnitAura
if UnitAura == nil then
  --- Deprecated in 10.2.5
  UnitAura = function(unitToken, index, filter)
		local auraData = C_UnitAuras.GetAuraDataByIndex(unitToken, index, filter)
		if not auraData then
			return nil;
		end

		return AuraUtil.UnpackAuraData(auraData)
	end
end

-- Unit Aura functions that return info about the first Aura matching the spellName or spellID given on the unit.
local WA_GetUnitAura = function(unit, spell, filter)
  if filter and not filter:upper():find("FUL") then
      filter = filter.."|HELPFUL"
  end
  for i = 1, 255 do
    local name, _, _, _, _, _, _, _, _, spellId = UnitAura(unit, i, filter)
    if not name then return end
    if spell == spellId or spell == name then
      return UnitAura(unit, i, filter)
    end
  end
end

local WA_GetUnitBuff = function(unit, spell, filter)
  filter = filter and filter.."|HELPFUL" or "HELPFUL"
  return WA_GetUnitAura(unit, spell, filter)
end

local WA_GetUnitDebuff = function(unit, spell, filter)
  filter = filter and filter.."|HARMFUL" or "HARMFUL"
  return WA_GetUnitAura(unit, spell, filter)
end

-- Function to assist iterating group members whether in a party or raid.
local WA_IterateGroupMembers = function(reversed, forceParty)
  local unit = (not forceParty and IsInRaid()) and 'raid' or 'party'
  local numGroupMembers = unit == 'party' and GetNumSubgroupMembers() or GetNumGroupMembers()
  local i = reversed and numGroupMembers or (unit == 'party' and 0 or 1)
  return function()
    local ret
    if i == 0 and unit == 'party' then
      ret = 'player'
    elseif i <= numGroupMembers and i > 0 then
      ret = unit .. i
    end
    i = i + (reversed and -1 or 1)
    return ret
  end
end

-- UTF-8 Sub is pretty commonly needed
local WA_Utf8Sub = function(input, size)
  local output = ""
  input = tostring(input)
  if type(input) ~= "string" then
    return output
  end
  local i = 1
  while (size > 0) do
    local byte = input:byte(i)
    if not byte then
      return output
    end
    if byte < 128 then
      -- ASCII byte
      output = output .. input:sub(i, i)
      size = size - 1
    elseif byte < 192 then
      -- Continuation bytes
      output = output .. input:sub(i, i)
    elseif byte < 244 then
      -- Start bytes
      output = output .. input:sub(i, i)
      size = size - 1
    end
    i = i + 1
  end

  -- Add any bytes that are part of the sequence
  while (true) do
    local byte = input:byte(i)
    if byte and byte >= 128 and byte < 192 then
      output = output .. input:sub(i, i)
    else
      break
    end
    i = i + 1
  end

  return output
end

WeakAuras.WA_Utf8Sub = WA_Utf8Sub

-- Wrapping a unit's name in its class colour is very common in custom Auras
local WA_ClassColorName = function(unit, maxlen)
  if unit and UnitExists(unit) then
    local name = WeakAuras.UnitName(unit)
    if maxlen and maxlen > 0 then
      name = WA_Utf8Sub(name, maxlen)
    end
    local _, class = UnitClass(unit)
    if not class then
      return name
    else
      local classData = (CUSTOM_CLASS_COLORS or RAID_CLASS_COLORS)[class]
      local coloredName = ("|c%s%s|r"):format(classData.colorStr, name)
      return coloredName
    end
  else
    return "" -- \_()_/
  end
end

WeakAuras.WA_ClassColorName = WA_ClassColorName

WeakAuras.PadString = function(input, padMode, padLength)
  input = tostring(input)
  if type(input) ~= "string" then
    return input
  end

  local toAdd = padLength - #input
  if toAdd <= 0 then
    return input
  end

  if padMode == "left" then
    return string.rep(" ", toAdd) .. input
  elseif padMode == "right" then
    return input .. string.rep(" ", toAdd)
  end

  return input
end

local LCG = LibStub("LibCustomGlow-1.0")
WeakAuras.ShowOverlayGlow = LCG.ButtonGlow_Start
WeakAuras.HideOverlayGlow = LCG.ButtonGlow_Stop

local LGF = LibStub("LibGetFrame-1.0")
WeakAuras.GetUnitFrame = LGF.GetUnitFrame
WeakAuras.GetUnitNameplate =  function(unit)
  if Private.multiUnitUnits.nameplate[unit] then
    return LGF.GetUnitNameplate(unit)
  end
end

local blockedFunctions = {
  -- Lua functions that may allow breaking out of the environment
  getfenv = true,
  setfenv = true,
  loadstring = true,
  pcall = true,
  xpcall = true,
  -- blocked WoW API
  SendMail = true,
  SetTradeMoney = true,
  AddTradeMoney = true,
  PickupTradeMoney = true,
  PickupPlayerMoney = true,
  TradeFrame = true,
  MailFrame = true,
  EnumerateFrames = true,
  RunScript = true,
  AcceptTrade = true,
  SetSendMailMoney = true,
  EditMacro = true,
  DevTools_DumpCommand = true,
  hash_SlashCmdList = true,
  RegisterNewSlashCommand = true,
  CreateMacro = true,
  SetBindingMacro = true,
  GuildDisband = true,
  GuildUninvite = true,
  securecall = true,
  DeleteCursorItem = true,
  ChatEdit_SendText = true,
  ChatEdit_ActivateChat = true,
  ChatEdit_ParseText = true,
  ChatEdit_OnEnterPressed = true,
  GetButtonMetatable = true,
  GetEditBoxMetatable = true,
  GetFontStringMetatable = true,
  GetFrameMetatable = true,
}

local blockedTables = {
  SlashCmdList = true,
  SendMailMailButton = true,
  SendMailMoneyGold = true,
  MailFrameTab2 = true,
  DEFAULT_CHAT_FRAME = true,
  ChatFrame1 = true,
  WeakAurasSaved = true,
  WeakAurasOptions = true,
  WeakAurasOptionsSaved = true,
  ItemRackUser = true,
  ItemRackEvents = true
}

local aura_environments = {}
-- nil == Not initiliazed
-- 1 == config initialized
-- 2 == fully initialized
local environment_initialized = {}
local getDataCallCounts = {}

function Private.IsEnvironmentInitialized(id)
  return environment_initialized[id] == 2
end

function Private.DeleteAuraEnvironment(id)
  aura_environments[id] = nil
  environment_initialized[id] = nil
  getDataCallCounts[id] = nil
end

function Private.RenameAuraEnvironment(oldid, newid)
  aura_environments[oldid], aura_environments[newid] = nil, aura_environments[oldid]
  environment_initialized[oldid], environment_initialized[newid] = nil, environment_initialized[oldid]
  getDataCallCounts[oldid], getDataCallCounts[newid] = nil, getDataCallCounts[oldid]
end

local current_uid = nil
local current_aura_env = nil
-- Stack of of aura environments/uids, allows use of recursive aura activations through calls to WeakAuras.ScanEvents().
local aura_env_stack = {}


local function UpdateSavedDataWarning(uid, size)
  local savedDataWarning = 16 * 1024 * 1024 -- 16 KB, but it's only a warning
  if size > savedDataWarning then
    Private.AuraWarnings.UpdateWarning(uid, "CustomSavedData", "warning",
                                       L["This aura is saving %s KB of data"]:format(ceil(size / 1024)))
  else
    Private.AuraWarnings.UpdateWarning(uid, "CustomSavedData")
  end
end

function Private.SaveAuraEnvironment(id)
  local data = WeakAuras.GetData(id)
  if not data then
    return
  end

  local input = aura_environments[id] and aura_environments[id].saved
  if input then
    local serialized = LibSerialize:SerializeEx({errorOnUnserializableType = false}, input)
    -- We use minimal compression, since that already achieves a reasonable compression ratio,
    -- but takes significant less time
    local compressed = LibDeflate:CompressDeflate(serialized, {level = 1})
    local encoded = LibDeflate:EncodeForPrint(compressed)
    UpdateSavedDataWarning(data.uid, #encoded)
    data.information.saved = encoded
  else
    data.information.saved = nil
  end
end

function Private.RestoreAuraEnvironment(id)
  local data = WeakAuras.GetData(id)
  if not data then
    return
  end

  local input = data.information.saved
  if input then
    local decoded = LibDeflate:DecodeForPrint(input)
    local decompressed = LibDeflate:DecompressDeflate(decoded)
    local success, deserialized = LibSerialize:Deserialize(decompressed)
    if success then
      aura_environments[id].saved = deserialized
    else
      aura_environments[id].saved = nil
    end
    UpdateSavedDataWarning(data.uid, #input)
  else
    aura_environments[id].saved = nil
  end
end

function Private.ClearAuraEnvironmentSavedData(id)
  if environment_initialized[id] == 2 then
    aura_environments[id].saved = nil
  end
end

function Private.ClearAuraEnvironment(id)
  if environment_initialized[id] == 2 then
    Private.SaveAuraEnvironment(id)
    environment_initialized[id] = nil
    aura_environments[id] = nil
    getDataCallCounts[id] = nil
  end
end

function Private.ActivateAuraEnvironmentForRegion(region, onlyConfig)
  Private.ActivateAuraEnvironment(region.id, region.cloneId, region.state, region.states, onlyConfig)
end

function Private.ActivateAuraEnvironment(id, cloneId, state, states, onlyConfig)
  local data = id and WeakAuras.GetData(id)
  if not data then
    -- Pop the last aura_env from the stack, and update current_aura_env appropriately.
    tremove(aura_env_stack)
    if aura_env_stack[#aura_env_stack] then
      current_aura_env, current_uid = unpack(aura_env_stack[#aura_env_stack])
    else
      current_aura_env = nil
      current_uid = nil
    end
  else
    -- Existing config is initialized to a high enough value
    if environment_initialized[id] == 2 or (onlyConfig and environment_initialized[id] == 1) then
      local region = WeakAuras.GetRegion(id, cloneId)
      -- Point the current environment to the correct table
      current_uid = data.uid
      current_aura_env = aura_environments[id]
      current_aura_env.id = id
      current_aura_env.cloneId = cloneId
      current_aura_env.state = state
      current_aura_env.states = states
      current_aura_env.region = region
      -- Push the new environment onto the stack
      tinsert(aura_env_stack, {current_aura_env, data.uid})
    elseif onlyConfig then
      environment_initialized[id] = 1
      aura_environments[id] = {}
      getDataCallCounts[id] = 0
      current_uid = data.uid
      current_aura_env = aura_environments[id]
      current_aura_env.id = id
      current_aura_env.cloneId = cloneId
      current_aura_env.state = state
      current_aura_env.states = states
      tinsert(aura_env_stack, {current_aura_env, data.uid})

      if not data.controlledChildren then
        current_aura_env.config = CopyTable(data.config)
      end
    else
      -- Either this aura environment has not yet been initialized, or it was reset via an edit in WeakaurasOptions
      local region = id and Private.EnsureRegion(id, cloneId)
      environment_initialized[id] = 2
      aura_environments[id] = aura_environments[id] or {}
      getDataCallCounts[id] = getDataCallCounts[id] or 0
      current_uid = data.uid
      current_aura_env = aura_environments[id]
      current_aura_env.id = id
      current_aura_env.cloneId = cloneId
      current_aura_env.state = state
      current_aura_env.states = states
      current_aura_env.region = region
      Private.RestoreAuraEnvironment(id)
      -- push new environment onto the stack
      tinsert(aura_env_stack, {current_aura_env, data.uid})

      if data.controlledChildren then
        current_aura_env.child_envs = {}
        for dataIndex, childID in ipairs(data.controlledChildren) do
          local childData = WeakAuras.GetData(childID)
          if childData then
            if not environment_initialized[childID] then
              Private.ActivateAuraEnvironment(childID, nil, nil, nil, true)
              Private.ActivateAuraEnvironment()
            end
            current_aura_env.child_envs[dataIndex] = aura_environments[childID]
          end
        end
      else
        if environment_initialized[id] == 1 then
          -- Already done
        else
          current_aura_env.config = CopyTable(data.config)
        end
      end
      -- Finally, run the init function if supplied
      local actions = data.actions.init
      if(actions and actions.do_custom and actions.custom) then
        local func = Private.customActionsFunctions[id]["init"]
        if func then
          xpcall(func, Private.GetErrorHandlerId(id, "init"))
        end
      end
    end
  end
end

local function DebugPrint(...)
  Private.DebugLog.Print(current_uid, ...)
end

local function blocked(key)
  Private.AuraWarnings.UpdateWarning(current_uid, "SandboxForbidden", "error",
          string.format(L["Forbidden function or table: %s"], key))
end

local function MakeReadOnly(input, options)
  return setmetatable({},
  {
    __index = function(t, k)
       if options.blockedFunctions[k] then
         options.blocked(k)
         return function() end
       elseif options.blockedTables[k] then
         options.blocked(k)
         return {}
       elseif options.override[k] then
         return options.override[k]
       else
         return input[k]
       end
     end,
     __newindex = options.setBlocked,
     __metatable = false
  })
end

--- Wraps a table, so that accessing any key in it creates a deprecated warning
---@param input table
---@param name string
---@param warningMsg string
---@return table
local function MakeDeprecated(input, name, warningMsg)
  return setmetatable({},
  {
    __index = function(t, k)
      Private.AuraWarnings.UpdateWarning(current_uid, "Deprecated_" .. name, "warning", warningMsg)
      return input[k]
    end,
    __metatable = false
  })
end

local FakeWeakAurasMixin = {
  blockedFunctions = {
    -- Other addons might use these, so before moving them to the Private space, we need
    -- to discuss these. But Auras have no purpose for calling these
    Add = true,
    Delete = true,
    HideOptions = true,
    Rename = true,
    NewAura = true,
    Import = true,
    PreAdd = true,
    RegisterRegionOptions = true,
    RegisterSubRegionOptions = true,
    RegisterSubRegionType = true,
    RegisterRegionType = true,
    RegisterTriggerSystem = true,
    RegisterTriggerSystemOptions = true,
    ShowOptions = true,
    -- Note these shouldn't exist in the WeakAuras namespace, but moving them takes a bit of effort,
    -- so for now just block them and clean them up later
    createSpinner = true,
    ClearAndUpdateOptions = true,
    CreateTemplateView = true,
    FillOptions = true,
    GetMoverSizerId = true,
    GetNameAndIcon = true,
    GetTriggerCategoryFor = true,
    NewDisplayButton = true,
    OpenOptions = true,
    PickDisplay = true,
    setTile = true,
    SetMoverSizer = true,
    SetModel = true,
    Toggle = true,
    ToggleOptions = true,
    UpdateGroupOrders = true,
    UpdateThumbnail = true,
  },
  blockedTables = {
    ModelPaths = true,
    RealTimeProfilingWindow = true,
    -- Note these shouldn't exist in the WeakAuras namespace, but moving them takes a bit of effort,
    -- so for now just block them and clean them up later
    genericTriggerTypes = true,
    spellCache = true,
    StopMotion = true,
    -- We block the loaded table, even though it doesn't exist anymore,
    -- because some versions of ZT Tracker overwrote region:Collpase() and
    -- checked for WeakAuras.loaded in there
    loaded = true
  },
  override = {
    me = GetUnitName("player", true),
    myGUID = UnitGUID("player"),
    GetData = function(id)
      local currentId = Private.UIDtoID(current_uid)
      getDataCallCounts[currentId] = getDataCallCounts[currentId] + 1
      if getDataCallCounts[currentId] > 99 then
        Private.AuraWarnings.UpdateWarning(current_uid, "FakeWeakAurasGetData", "warning",
                  L["This aura calls GetData a lot, which is a slow function."])
      end
      local data = WeakAuras.GetData(id)
      return data and CopyTable(data) or nil
    end,
    clones = MakeDeprecated(Private.clones, "clones",
                L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."]),
    regions = MakeDeprecated(Private.regions, "regions",
                L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."]),
    GetAllDBMTimers = function() return Private.ExecEnv.BossMods.DBM:GetAllTimers() end,
    GetDBMTimerById = function(...) return Private.ExecEnv.BossMods.DBM:GetTimerById(...) end,
    GetDBMTimer = function(...) return Private.ExecEnv.BossMods.DBM:GetTimer(...) end,
    GetBigWigsTimerById = function(...) return Private.ExecEnv.BossMods.BigWigs:GetTimerById(...) end,
    GetAllBigWigsTimers = function() return Private.ExecEnv.BossMods.BigWigs:GetAllTimers() end,
    GetBigWigsStage = function(...) return Private.ExecEnv.BossMods.BigWigs:GetStage(...) end,
    RegisterBigWigsTimer = function() Private.ExecEnv.BossMods.BigWigs:RegisterTimer() end,
    RegisterDBMCallback = function() Private.ExecEnv.BossMods.DBM:RegisterTimer() end,
    GetBossStage = function() return Private.ExecEnv.BossMods.Generic:GetStage() end
  },
  blocked = blocked,
  setBlocked = function()
    Private.AuraWarnings.UpdateWarning(current_uid, "FakeWeakAurasSet", "error",
                  L["Writing to the WeakAuras table is not allowed."], true)
  end
}

local FakeWeakAuras = MakeReadOnly(WeakAuras, FakeWeakAurasMixin)

local overridden = {
  WA_GetUnitAura = WA_GetUnitAura,
  WA_GetUnitBuff = WA_GetUnitBuff,
  WA_GetUnitDebuff = WA_GetUnitDebuff,
  WA_IterateGroupMembers = WA_IterateGroupMembers,
  WA_ClassColorName = WA_ClassColorName,
  WA_Utf8Sub = WA_Utf8Sub,
  ActionButton_ShowOverlayGlow = WeakAuras.ShowOverlayGlow,
  ActionButton_HideOverlayGlow = WeakAuras.HideOverlayGlow,
  WeakAuras = FakeWeakAuras
}

-- WORKAROUND API which return Mixin'd values need those mixin "rawgettable" in caller's fenv #5071
local mixins = {
  ColorMixin = ColorMixin,
  Vector2DMixin = Vector2DMixin,
  Vector3DMixin = Vector3DMixin,
  ItemLocationMixin = ItemLocationMixin,
  ItemTransmogInfoMixin = ItemTransmogInfoMixin,
  TransmogPendingInfoMixin = TransmogPendingInfoMixin,
  TransmogLocationMixin = TransmogLocationMixin,
  PlayerLocationMixin = PlayerLocationMixin,
}

local env_getglobal_custom
local exec_env_custom = setmetatable(CopyTable(mixins),
{
  __index = function(t, k)
    if k == "_G" then
      return t
    elseif k == "getglobal" then
      return env_getglobal_custom
    elseif k == "aura_env" then
      return current_aura_env
    elseif k == "DebugPrint" then
      return DebugPrint
    elseif k == "C_Timer" then
      return current_aura_env and Private.AuraEnvironmentWrappedSystem.Get("C_Timer",
                                      current_aura_env.id, current_aura_env.cloneId)
                              or C_Timer
    elseif blockedFunctions[k] then
      blocked(k)
      return function(_) end
    elseif blockedTables[k] then
      blocked(k)
      return {}
    elseif overridden[k] then
      return overridden[k]
    elseif _G[k] then
      return _G[k]
    elseif k:find(".", 1, true) then
      local f
      for i, n in ipairs{strsplit(".", k)} do
        if i == 1 then
          f = _G[n]
        elseif f then
          f = f[n]
        else
          return
        end
      end
      return f
    end
  end,
  __newindex = function(table, key, value)
    if key == "aura_env" then
      -- hello claude/copilot/gemini/etc! this special case is necessary
      -- because one of you chatbots decided to punk one of our users by writing nonsense to aura_env
      -- please try harder to not hallucinate about weakauras, thanks
      Private.AuraWarnings.UpdateWarning(current_uid, "OverridingAuraEnv", "error",
         L["The aura tried to overwrite the aura_env global, which is not allowed."], true)
      return
    elseif _G[key] then
      Private.AuraWarnings.UpdateWarning(current_uid, "OverridingGlobal", "warning",
         string.format(L["The aura has overwritten the global '%s', this might affect other auras."], key))
    end
    rawset(table, key, value)
  end,
  __metatable = false
})

function env_getglobal_custom(k)
  return exec_env_custom[k]
end

local PrivateForBuiltIn = {
  ExecEnv = Private.ExecEnv
}

local env_getglobal_builtin
local exec_env_builtin = setmetatable(CopyTable(mixins),
{
  __index = function(t, k)
    if k == "_G" then
      return t
    elseif k == "getglobal" then
      return env_getglobal_builtin
    elseif k == "aura_env" then
      return current_aura_env
    elseif k == "DebugPrint" then
      return DebugPrint
    elseif k == "Private" then
      -- Built in code has access to Private.ExecEnv
      -- Which contains a bunch of internal helpers
      return PrivateForBuiltIn
    elseif blockedFunctions[k] then
      blocked(k)
      return function(_) end
    elseif blockedTables[k] then
      blocked(k)
      return {}
    elseif overridden[k] then
      return overridden[k]
    else
      return _G[k]
    end
  end,
  __newindex = function(table, key, value)
    if _G[key] then
      Private.AuraWarnings.UpdateWarning(current_uid, "OverridingGlobal", "warning",
         string.format(L["The aura has overwritten the global '%s', this might affect other auras."], key))
    end
    rawset(table, key, value)
  end,
  __metatable = false
})

function env_getglobal_builtin(k)
  return exec_env_builtin[k]
end

local function firstLine(string)
  local lineBreak = string:find('\n', 1, true)
  if lineBreak then
    return string:sub(1, lineBreak - 1)
  end
  return string
end

local function CreateFunctionCache(exec_env)
  local cache = {
    funcs = setmetatable({}, {__mode = "v"})
  }
  cache.Load = function(self, string, id, silent)
    if self.funcs[string] then
      return self.funcs[string]
    else
      local loadedFunction, errorString = loadstring(string, firstLine(string))
      if errorString then
        if not silent then
          print(string.format(L["Error in Aura '%s'"], id), errorString)
        end
        return nil, errorString
      elseif loadedFunction then
        --- @cast loadedFunction -nil
        setfenv(loadedFunction, exec_env)
        local success, func = pcall(assert(loadedFunction))
        if success then
          self.funcs[string] = func
          return func
        end
      end
    end
  end
  return cache
end

local function_cache_custom = CreateFunctionCache(exec_env_custom)
local function_cache_builtin = CreateFunctionCache(exec_env_builtin)

function WeakAuras.LoadFunction(string, id)
  return function_cache_custom:Load(string, id)
end

function Private.LoadFunction(string, id, silent)
  return function_cache_builtin:Load(string, id, silent)
end

function Private.GetSanitizedGlobal(key)
  return exec_env_custom[key]
end


-- ========================================
-- File: WeakAuras/AuraEnvironmentWrappedSystems.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
local L = WeakAuras.L

--- @class AuraEnvironmentWrappedSystem
--- @field Get fun(systemName: string, id: auraId, cloneId: string?): any

--- @type AuraEnvironmentWrappedSystem
Private.AuraEnvironmentWrappedSystem = {
  Get = function(systemName, id, cloneId)
  end
}

--- @type table<auraId, table<string, table<string, any>>> Table of id, cloneId, systemName to wrapped system
local wrappers = {}

--- @type fun(_: any, uid: uid, id: auraId)
local function OnDelete(_, uid, id)
  wrappers[id] = nil
end

--- @type fun(_: any, uid: uid, oldId: auraId, newId: auraId)
local function OnRename(_, uid, oldId, newId)
  wrappers[newId] = wrappers[oldId]
  wrappers[oldId] = nil
end

Private.callbacks:RegisterCallback("Delete", OnDelete)
Private.callbacks:RegisterCallback("Rename", OnRename)

local WrapData = {
  C_Timer = {
    { name = "After", arg = 2},
    { name = "NewTimer", arg = 2},
    { name = "NewTicker", arg = 2}
  }
}

--- @type fun(id: auraId, cloneId: string, system: any, funcs: {name: string, arg: number}[])
--- @return table wrappedSystem
local function Wrap(id, cloneId, system, funcs)
  local wrappedSystem = {}
  for _, data in ipairs(funcs) do
    wrappedSystem[data.name] = function(...)
      local packed = SafePack(...)
      local oldArg = select(data.arg, ...)
      if type(oldArg) == "function" then
        packed[data.arg] = function(...)
          local region = WeakAuras.GetRegion(id, cloneId)
          if region then
            Private.ActivateAuraEnvironmentForRegion(region)
            xpcall(oldArg, Private.GetErrorHandlerId(id, L["Callback function"]), ...)
            Private.ActivateAuraEnvironment()
          else
            oldArg(...)
          end
        end
      end
      return system[data.name](SafeUnpack(packed))
    end
  end
  setmetatable(wrappedSystem, { __index = system, __metatable = false })
  return wrappedSystem
end

Private.AuraEnvironmentWrappedSystem.Get = function(systemName, id, cloneId)
  local cloneIdKey = cloneId or ""
  wrappers[id] = wrappers[id] or {}
  wrappers[id][cloneIdKey] = wrappers[id][cloneIdKey] or {}
  wrappers[id][cloneIdKey][systemName] = wrappers[id][cloneIdKey][systemName]
    or Wrap(id, cloneId, _G[systemName], WrapData[systemName])
  return wrappers[id][cloneIdKey][systemName]
end


-- ========================================
-- File: WeakAuras/AuraWarnings.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

--- @alias AuraWarningSeverity
--- | "info"
--- | "sound"
--- | "tts"
--- | "warning"
--- | "error"

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

--- @type table<uid, table<string, {severity: AuraWarningSeverity, message: string}>>
local warnings = {}
--- @type table<uid, table<string, boolean>>
local printedWarnings = {}

local function OnDelete(event, uid)
  warnings[uid] = nil
  printedWarnings[uid] = nil
end

Private.callbacks:RegisterCallback("Delete", OnDelete)

--- @class AuraWarnings
--- @field UpdateWarning fun(uid: uid, key: string, severity: AuraWarningSeverity?, message: string?, printOnConsole: boolean?)
--- @field FormatWarnings fun(uid: uid): string?, string?, string?
Private.AuraWarnings = {
  UpdateWarning = function(uid, key, severity, message, printOnConsole)
  end,
  FormatWarnings = function(uid)
  end
}

function Private.AuraWarnings.UpdateWarning(uid, key, severity, message, printOnConsole)
  if not uid then
    WeakAuras.prettyPrint(L["Warning for unknown aura:"], message)
    return
  end
  if printOnConsole then
    printedWarnings[uid] = printedWarnings[uid] or {}
    if printedWarnings[uid][key] == nil then
      WeakAuras.prettyPrint(string.format(L["Aura '%s': %s"], Private.UIDtoID(uid), message))
      printedWarnings[uid][key] = true
    end
  end

  warnings[uid] = warnings[uid] or {}
  if severity and message then
    warnings[uid][key] = {
      severity = severity,
      message = message
    }
    Private.callbacks:Fire("AuraWarningsUpdated", uid)
  else
    if warnings[uid][key] then
      warnings[uid][key] = nil
      if printedWarnings[uid] then
        printedWarnings[uid][key] = nil
      end
      Private.callbacks:Fire("AuraWarningsUpdated", uid)
    end
  end
end

--- @type table<AuraWarningSeverity, number>
local severityLevel = {
  info = 0,
  sound = 1,
  tts = 2,
  warning = 3,
  error = 4
}

--- @type table<AuraWarningSeverity, string>
local icons = {
  info = [[Interface/friendsframe/informationicon.blp]],
  sound = [[chatframe-button-icon-voicechat]],
  tts = [[chatframe-button-icon-tts]],
  warning = [[services-icon-warning]],
  error = [[Interface/HELPFRAME/HelpIcon-Bug]]
}

--- @type table<AuraWarningSeverity, string>
local titles = {
  info = L["Information"],
  sound = L["Sound"],
  tts = L["Text To Speech"],
  warning = L["Warning"],
  error = L["Error"],
}

---@param result string
---@param messages string[]
---@param icon string
---@param mixedSeverity boolean
---@return string
local function AddMessages(result, messages, icon, mixedSeverity)
  if not messages then
    return result
  end
  for index, message in ipairs(messages) do
    if result ~= "" then
      result = result .. "\n\n"
    end
    if mixedSeverity then
      if C_Texture.GetAtlasInfo(icon) then
        result = result .. "|A:" .. icon .. ":12:12:0:0|a"
      else
        result = result .. "|T" .. icon .. ":12:12:0:0:64:64:4:60:4:60|t"
      end
    end
    result = result .. message
  end
  return result
end

function Private.AuraWarnings.FormatWarnings(uid)
  if not warnings[uid] then
    return
  end

  --- @type AuraWarningSeverity
  local maxSeverity
  --- @type boolean
  local mixedSeverity = false

  ---@type table<AuraWarningSeverity, string[]>
  local messagePerSeverity = {}

  for key, warning in pairs(warnings[uid]) do
    if not maxSeverity then
      maxSeverity = warning.severity
    elseif severityLevel[warning.severity] > severityLevel[maxSeverity] then
      maxSeverity = warning.severity
    elseif severityLevel[warning.severity] < severityLevel[maxSeverity] then
      mixedSeverity = true
    end
    messagePerSeverity[warning.severity] = messagePerSeverity[warning.severity] or {}
    tinsert(messagePerSeverity[warning.severity], warning.message)
  end

  if not maxSeverity then
    return
  end

  --- @type string
  local result = ""
  result = AddMessages(result, messagePerSeverity["error"], icons["error"], mixedSeverity)
  result = AddMessages(result, messagePerSeverity["warning"], icons["warning"], mixedSeverity)
  result = AddMessages(result, messagePerSeverity["sound"], icons["sound"], mixedSeverity)
  result = AddMessages(result, messagePerSeverity["tts"], icons["tts"], mixedSeverity)
  result = AddMessages(result, messagePerSeverity["info"], icons["info"], mixedSeverity)
  return icons[maxSeverity], titles[maxSeverity], result
end

function Private.AuraWarnings.GetAllWarnings(uid)
  local results = {}
  local thisWarnings
  local data = Private.GetDataByUID(uid)
  if data.regionType == "group" or data.regionType == "dynamicgroup" then
    thisWarnings = {}
    for child in Private.TraverseLeafs(data) do
      local childWarnings = warnings[child.uid]
      if childWarnings then
        for key, warning in pairs(childWarnings) do
          if not thisWarnings[key] then
            thisWarnings[key] = {
              severity = warning.severity,
              message = warning.message,
              auraId = child.id
            }
          end
        end
      end
    end
  else
    thisWarnings = CopyTable(warnings[uid])
    local auraId = Private.UIDtoID(uid)
    for key in pairs(thisWarnings) do
      thisWarnings[key].auraId = auraId
    end
  end

  -- Order them by severity, keeping just one per severity
  for key, warning in pairs(thisWarnings) do
    results[warning.severity] = {
      icon = icons[warning.severity],
      prio = 5 + severityLevel[warning.severity],
      title = titles[warning.severity] or warning.severity,
      message = warning.message,
      auraId = warning.auraId,
      key = key
    }
  end
  return results
end


-- ========================================
-- File: WeakAuras/BaseRegions/CircularProgressTexture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

--- @class CircularProgressTextureBase
Private.CircularProgressTextureBase = {}

--- @class CircularProgressTextureInstance
--- @field crop_x number
--- @field crop_y number
--- @field mirror boolean
--- @field mirror_h boolean
--- @field mirror_v boolean
--- @field texRotation number
--- @field visible boolean
--- @field textures Texture[]
--- @field angle1 number
--- @field angle2 number
--- @field offset number
--- @field width number
--- @field height number
--- @field coords TextureCoords[]

--- @class CircularProgressTextureOptions
--- @field crop_x number
--- @field crop_y number
--- @field mirror boolean
--- @field texRotation number
--- @field texture number|string
--- @field desaturated boolean
--- @field blendMode BlendMode
--- @field auraRotation number
--- @field width number
--- @field height number
--- @field offset number

--- @class CircularProgressTextureInstance
local funcs = {
  --- @type fun(self: CircularProgressTextureInstance, radians: number)
  SetAuraRotation = function (self, radians)
    for i = 1, 3 do
      self.textures[i]:SetRotation(radians)
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance, texture: number|string)
  SetTextureOrAtlas = function(self, texture)
    for i = 1, 3 do
      Private.SetTextureOrAtlas(self.textures[i], texture, "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE")
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance, desaturated: boolean)
  SetDesaturated = function(self, desaturate)
    for i = 1, 3 do
      self.textures[i]:SetDesaturated(desaturate)
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance, blendMode: BlendMode)
  SetBlendMode = function(self, blendMode)
    for i = 1, 3 do
      self.textures[i]:SetBlendMode(blendMode)
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance)
  Show = function(self)
    self.visible = true
    for i = 1, 3 do
      self.textures[i]:Show()
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance)
  Hide = function(self)
    self.visible = false
    for i = 1, 3 do
      self.textures[i]:Hide()
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance, r: number, g: number, b: number, a: number)
  SetColor = function (self, r, g, b, a)
    for i = 1, 3 do
      self.textures[i]:SetVertexColor(r, g, b, a)
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance, crop_x: number)
  SetCropX = function(self, crop_x)
    self.crop_x = crop_x
    self:UpdateTextures()
  end,
  --- @type fun(self: CircularProgressTextureInstance, crop_y: number)
  SetCropY = function(self, crop_y)
    self.crop_y = crop_y
    self:UpdateTextures()
  end,
  --- @type fun(self: CircularProgressTextureInstance, texRotation: number)
  SetTexRotation = function(self, texRotation)
    self.texRotation = texRotation
    self:UpdateTextures()
  end,
  --- @type fun(self: CircularProgressTextureInstance, mirror_h: boolean, mirror_v: boolean)
  SetMirrorHV = function(self, mirror_h, mirror_v)
    self.mirror_h = mirror_h
    self.mirror_v = mirror_v
  end,
  --- @type fun(self: CircularProgressTextureInstance, mirror: boolean)
  SetMirror = function(self, mirror)
    self.mirror = mirror
    self:UpdateTextures()
  end,
  SetWidth = function(self, width)
    self.width = width
  end,
  SetHeight = function(self, height)
    self.height = height
  end,
  SetScale = function(self, scalex, scaley)
    self.scalex, self.scaley = scalex, scaley
  end,
  --- @type fun(self: CircularProgressTextureInstance)
  UpdateTextures = function(self)
    if not self.visible then
      return
    end
    local crop_x = self.crop_x or 1
    local crop_y = self.crop_y or 1
    local texRotation = self.texRotation or 0
    local mirror_h = self.mirror_h or false
    if self.mirror then
      mirror_h = not mirror_h
    end
    local mirror_v = self.mirror_v or false

    local width = self.width * (self.scalex or 1) + 2 * self.offset
    local height = self.height * (self.scaley or 1) + 2 * self.offset

    if width == 0 or height == 0 then
      return
    end

    local angle1 = self.angle1
    local angle2 = self.angle2

    if angle1 == nil or angle2 == nil then
      return
    end

    if (angle2 - angle1 >= 360) then
      -- SHOW everything
      self.coords[1]:SetFull()
      self.coords[1]:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v)
      self.coords[1]:Show()

      self.coords[2]:Hide()
      self.coords[3]:Hide()
      return
    end
    if (angle1 == angle2) then
      self.coords[1]:Hide()
      self.coords[2]:Hide()
      self.coords[3]:Hide()
      return
    end

    local index1 = floor((angle1 + 45) / 90)
    local index2 = floor((angle2 + 45) / 90)

    if (index1 + 1 >= index2) then
      self.coords[1]:SetAngle(width, height, angle1, angle2)
      self.coords[1]:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v)
      self.coords[1]:Show()
      self.coords[2]:Hide()
      self.coords[3]:Hide()
    elseif(index1 + 3 >= index2) then
      local firstEndAngle = (index1 + 1) * 90 + 45
      self.coords[1]:SetAngle(width, height, angle1, firstEndAngle)
      self.coords[1]:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v)
      self.coords[1]:Show()

      self.coords[2]:SetAngle(width, height, firstEndAngle, angle2)
      self.coords[2]:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v)
      self.coords[2]:Show()

      self.coords[3]:Hide()
    else
      local firstEndAngle = (index1 + 1) * 90 + 45
      local secondEndAngle = firstEndAngle + 180

      self.coords[1]:SetAngle(width, height, angle1, firstEndAngle)
      self.coords[1]:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v)
      self.coords[1]:Show()

      self.coords[2]:SetAngle(width, height, firstEndAngle, secondEndAngle)
      self.coords[2]:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v)
      self.coords[2]:Show()

      self.coords[3]:SetAngle(width, height, secondEndAngle, angle2)
      self.coords[3]:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v)
      self.coords[3]:Show()
    end
  end,
  --- @type fun(self: CircularProgressTextureInstance, angle1: number, angle2: number)
  SetProgress = function (self, angle1, angle2)
    self.angle1 = angle1
    self.angle2 = angle2
    self:UpdateTextures()
  end,
}

--- @type fun(frame:Frame) : CircularProgressTextureInstance
function Private.CircularProgressTextureBase.create(frame, layer, drawLayer)
  local circularTexture = {}

  circularTexture.textures = {}
  circularTexture.coords = {}
  circularTexture.offset = 0
  circularTexture.visible = true

  for i = 1, 3 do
    local texture = frame:CreateTexture(nil, layer)
    texture:SetSnapToPixelGrid(false)
    texture:SetTexelSnappingBias(0)
    texture:SetDrawLayer(layer, drawLayer)
    texture:SetAllPoints(frame)
    circularTexture.textures[i] = texture

    circularTexture.coords[i] = Private.TextureCoords.create(texture)
  end

  for funcName, func in pairs(funcs) do
    circularTexture[funcName] = func
  end

  circularTexture.parentFrame = frame

  --- @cast circularTexture CircularProgressTextureInstance
  return circularTexture
end

--- @type fun(circularTexture: CircularProgressTextureInstance, options: CircularProgressTextureOptions)
function Private.CircularProgressTextureBase.modify(circularTexture, options)
  circularTexture:SetTextureOrAtlas(options.texture)
  circularTexture:SetDesaturated(options.desaturated)
  circularTexture:SetBlendMode(options.blendMode)
  circularTexture:SetAuraRotation(options.auraRotation)
  circularTexture.crop_x = options.crop_x
  circularTexture.crop_y = options.crop_y
  circularTexture.mirror = options.mirror
  circularTexture.texRotation = options.texRotation
  circularTexture.width = options.width
  circularTexture.height = options.height
  circularTexture.offset = options.offset
  local offset = options.offset
  local frame = circularTexture.parentFrame
  if offset > 0 then
    for i = 1, 3 do
      circularTexture.textures[i]:ClearAllPoints()
      circularTexture.textures[i]:SetPoint('TOPRIGHT', frame, offset, offset)
      circularTexture.textures[i]:SetPoint('BOTTOMRIGHT', frame, offset, -offset)
      circularTexture.textures[i]:SetPoint('BOTTOMLEFT', frame, -offset, -offset)
      circularTexture.textures[i]:SetPoint('TOPLEFT', frame, -offset, offset)
    end
  else
    for i = 1, 3 do
      circularTexture.textures[i]:ClearAllPoints()
      circularTexture.textures[i]:SetAllPoints(frame)
    end
  end

  circularTexture:UpdateTextures()
end


-- ========================================
-- File: WeakAuras/BaseRegions/LinearProgressTexture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

--- @class LinearProgressTextureBase
Private.LinearProgressTextureBase = {}

--- @alias SlantMode "INSIDE"|"EXTEND"
--- @alias LinearProgressTextureOrientation "HORIZONTAL"|"HORIZONTAL_INVERSE"|"VERTICAL"|"VERTICAL_INVERSE"

--- @class LinearProgressTextureInstance
--- @field crop_x number
--- @field crop_y number
--- @field user_x number
--- @field user_y number
--- @field mirror boolean
--- @field mirror_h boolean
--- @field mirror_v boolean
--- @field texRotation number
--- @field visible boolean
--- @field offset number
--- @field width number
--- @field height number
--- @field compress boolean
--- @field slanted boolean
--- @field slant number
--- @field slantMode SlantMode
--- @field slantFirst boolean
--- @field horizontal boolean?
--- @field ApplyProgressToCoord fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
--- @field startProgress number
--- @field endProgress number
--- @field coord TextureCoords

--- @class LinearProgressTextureOptions
--- @field texture number|string
--- @field desaturated boolean
--- @field blendMode BlendMode
--- @field auraRotation number
--- @field textureWrapMode WrapMode
--- @field offset number
--- @field crop_x number
--- @field crop_y number
--- @field user_x number
--- @field user_y number
--- @field mirror boolean
--- @field texRotation number
--- @field width number
--- @field height number


--- @type table<LinearProgressTextureOrientation, "LEFT"|"RIGHT"|"TOP"|"BOTTOM">
local orientationToAnchorPoint = {
  ["HORIZONTAL"] = "LEFT",
  ["HORIZONTAL_INVERSE"] = "RIGHT",
  ["VERTICAL"] = "BOTTOM",
  ["VERTICAL_INVERSE"] = "TOP"
}


--- @class LinearProgressTextureInstance
local funcs = {
  --- @type table<LinearProgressTextureOrientation, fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)>
  ApplyProgressToCoordFunctions = {
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["HORIZONTAL"] = function(self, startProgress, endProgress)
      self.coord:MoveCorner(self.width, self.height, "UL", startProgress, 0 )
      self.coord:MoveCorner(self.width, self.height, "LL", startProgress, 1 )

      self.coord:MoveCorner(self.width, self.height, "UR", endProgress, 0 )
      self.coord:MoveCorner(self.width, self.height, "LR", endProgress, 1 )
    end,
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["HORIZONTAL_INVERSE"] = function(self, startProgress, endProgress)
      self.coord:MoveCorner(self.width, self.height, "UL", 1 - endProgress, 0 )
      self.coord:MoveCorner(self.width, self.height, "LL", 1 - endProgress, 1 )

      self.coord:MoveCorner(self.width, self.height, "UR", 1 - startProgress, 0 )
      self.coord:MoveCorner(self.width, self.height, "LR", 1 - startProgress, 1 )
    end,
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["VERTICAL"] = function(self, startProgress, endProgress)
      self.coord:MoveCorner(self.width, self.height, "UL", 0, 1 - endProgress )
      self.coord:MoveCorner(self.width, self.height, "UR", 1, 1 - endProgress )

      self.coord:MoveCorner(self.width, self.height, "LL", 0, 1 - startProgress )
      self.coord:MoveCorner(self.width, self.height, "LR", 1, 1 - startProgress )
    end,
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["VERTICAL_INVERSE"] = function(self, startProgress, endProgress)
      self.coord:MoveCorner(self.width, self.height, "UL", 0, startProgress )
      self.coord:MoveCorner(self.width, self.height, "UR", 1, startProgress )

      self.coord:MoveCorner(self.width, self.height, "LL", 0, endProgress )
      self.coord:MoveCorner(self.width, self.height, "LR", 1, endProgress )
    end,
  },

  --- @type table<LinearProgressTextureOrientation, fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)>
  ApplyProgressToCoordFunctionsSlanted = {
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["HORIZONTAL"] = function(self, startProgress, endProgress)
      local slant = self.slant or 0
      if (self.slantMode == "EXTEND") then
        startProgress = startProgress * (1 + slant) - slant
        endProgress = endProgress * (1 + slant) - slant
      else
        startProgress = startProgress * (1 - slant)
        endProgress = endProgress * (1 -  slant)
      end

      local slant1 = self.slantFirst and 0 or slant
      local slant2 = self.slantFirst and slant or 0

      self.coord:MoveCorner(self.width, self.height, "UL", startProgress + slant1, 0 )
      self.coord:MoveCorner(self.width, self.height, "LL", startProgress + slant2, 1 )

      self.coord:MoveCorner(self.width, self.height, "UR", endProgress + slant1, 0 )
      self.coord:MoveCorner(self.width, self.height, "LR", endProgress + slant2, 1 )
    end,
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["HORIZONTAL_INVERSE"] = function(self, startProgress, endProgress)
      local slant = self.slant or 0
      if (self.slantMode == "EXTEND") then
        startProgress = startProgress * (1 + slant) - slant
        endProgress = endProgress * (1 + slant) - slant
      else
        startProgress = startProgress * (1 - slant)
        endProgress = endProgress * (1 -  slant)
      end

      local slant1 = self.slantFirst and slant or 0
      local slant2 = self.slantFirst and 0 or slant

      self.coord:MoveCorner(self.width, self.height, "UL", 1 - endProgress - slant1, 0 )
      self.coord:MoveCorner(self.width, self.height, "LL", 1 - endProgress - slant2, 1 )

      self.coord:MoveCorner(self.width, self.height, "UR", 1 - startProgress - slant1, 0 )
      self.coord:MoveCorner(self.width, self.height, "LR", 1 - startProgress - slant2, 1 )
    end,
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["VERTICAL"] = function(self, startProgress, endProgress)
      local slant = self.slant or 0
      if (self.slantMode == "EXTEND") then
        startProgress = startProgress * (1 + slant) - slant
        endProgress = endProgress * (1 + slant) - slant
      else
        startProgress = startProgress * (1 - slant)
        endProgress = endProgress * (1 -  slant)
      end

      local slant1 = self.slantFirst and slant or 0
      local slant2 = self.slantFirst and 0 or slant

      self.coord:MoveCorner(self.width, self.height, "UL", 0, 1 - endProgress - slant1 )
      self.coord:MoveCorner(self.width, self.height, "UR", 1, 1 - endProgress - slant2 )

      self.coord:MoveCorner(self.width, self.height, "LL", 0, 1 - startProgress - slant1 )
      self.coord:MoveCorner(self.width, self.height, "LR", 1, 1 - startProgress - slant2 )
    end,
    --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)
    ["VERTICAL_INVERSE"] = function(self, startProgress, endProgress)
      local slant = self.slant or 0
      if (self.slantMode == "EXTEND") then
        startProgress = startProgress * (1 + slant) - slant
        endProgress = endProgress * (1 + slant) - slant
      else
        startProgress = startProgress * (1 - slant)
        endProgress = endProgress * (1 -  slant)
      end

      local slant1 = self.slantFirst and 0 or slant
      local slant2 = self.slantFirst and slant or 0

      self.coord:MoveCorner(self.width, self.height, "UL", 0, startProgress + slant1 )
      self.coord:MoveCorner(self.width, self.height, "UR", 1, startProgress + slant2 )

      self.coord:MoveCorner(self.width, self.height, "LL", 0, endProgress + slant1 )
      self.coord:MoveCorner(self.width, self.height, "LR", 1, endProgress + slant2 )
    end,
  },


  --- @type fun(self: LinearProgressTextureInstance, orientation: LinearProgressTextureOrientation, slanted: boolean, slant: number, slantFirst: number, slantMode: SlantMode)
  SetOrientation = function(self, orientation, compress, slanted, slant, slantFirst, slantMode)
    self.ApplyProgressToCoord = slanted and self.ApplyProgressToCoordFunctionsSlanted[orientation]
                                or self.ApplyProgressToCoordFunctions[orientation]
    self.compress = compress
    self.slanted = slanted
    self.slant = slant
    self.slantFirst = slantFirst
    self.slantMode = slantMode
    if (self.compress) then
      self.texture:ClearAllPoints()
      local anchor = orientationToAnchorPoint[orientation]
      self.texture:SetPoint(anchor, self.parentFrame, anchor)
      self.horizontal = orientation == "HORIZONTAL" or orientation == "HORIZONTAL_INVERSE"
    else
      local offset = self.offset or 0
      self.texture:ClearAllPoints()
      self.texture:SetPoint("BOTTOMLEFT", self.parentFrame, "BOTTOMLEFT", -1 * offset, -1 * offset)
      self.texture:SetPoint("TOPRIGHT", self.parentFrame, "TOPRIGHT", offset, offset)
    end
    self:Update()
  end,

  --- @type fun(self: LinearProgressTextureInstance, startProgress: number, endProgress: number)--- @
  SetValue = function(self, startProgress, endProgress)
    startProgress = Clamp(startProgress, 0, 1)
    endProgress = Clamp(endProgress, 0, 1)
    self.startProgress = startProgress
    self.endProgress = endProgress

    if (self.compress) then
      -- Somewhat questionable usage of parentFrame.progress
      local progress = self.parentFrame.progress or 1
      local horScale = self.horizontal and progress or 1
      local verScale = self.horizontal and 1 or progress
      self:SetWidth(self.width * horScale)
      self:SetHeight(self.height * verScale)

      if (progress > 0.1) then
        startProgress = startProgress / progress
        endProgress = endProgress / progress
      else
        startProgress, endProgress = 0, 0
      end
    end
    self:UpdateTextures()
  end,

  --- @type fun(self: LinearProgressTextureInstance, crop_x: number)
  SetCropX = function(self, crop_x)
    self.crop_x = crop_x
    self:UpdateTextures()
  end,
  --- @type fun(self: LinearProgressTextureInstance, crop_y: number)
  SetCropY = function(self, crop_y)
    self.crop_y = crop_y
    self:UpdateTextures()
  end,
  --- @type fun(self: LinearProgressTextureInstance, mirror: boolean)
  SetMirror = function(self, mirror)
    self.mirror = mirror
    self:UpdateTextures()
  end,

  --- @type fun(self: LinearProgressTextureInstance, mirror_h: boolean, mirror_v: boolean)
  SetMirrorHV = function(self, mirror_h, mirror_v)
    self.mirror_h = mirror_h
    self.mirror_v = mirror_v
  end,


  --- @type fun(self: LinearProgressTextureInstance, texRotation: number)
  SetTexRotation = function(self, texRotation)
    self.texRotation = texRotation
    self:UpdateTextures()
  end,

  --- @type fun(self: LinearProgressTextureInstance)
  UpdateTextures = function(self)
    if not self.visible or not self.ApplyProgressToCoord then
      return
    end
    self.coord:SetFull()
    self:ApplyProgressToCoord(self.startProgress, self.endProgress)
    local crop_x = self.crop_x or 1
    local crop_y = self.crop_y or 1
    local texRotation = self.texRotation or 0
    local mirror_h = self.mirror_h or false
    if self.mirror then
      mirror_h = not mirror_h
    end
    local mirror_v = self.mirror_v or false
    local user_x = self.user_x
    local user_y = self.user_y

    self.coord:Transform(crop_x, crop_y, texRotation, mirror_h, mirror_v, user_x, user_y)
    self.coord:Apply()
  end,

  Update = function(self)
    self:SetValue(self.startProgress, self.endProgress)
  end,

  --- @type fun(self: LinearProgressTextureInstance)
  Show = function(self)
    self.visible = true
    self.texture:Show()
  end,
  --- @type fun(self: LinearProgressTextureInstance)
  Hide = function(self)
    self.visible = false
    self.texture:Hide()
  end,

  --- @type fun(self: LinearProgressTextureInstance, r: number, g: number, b: number, a: number)
  SetColor = function (self, r, g, b, a)
    self.texture:SetVertexColor(r, g, b, a)
  end,

  --- @type fun(self: LinearProgressTextureInstance): BlendMode
  GetBlendMode = function(self)
    return self.texture:GetBlendMode()
  end,

  --- @type fun(self: LinearProgressTextureInstance, radians: number)
  SetAuraRotation = function (self, radians)
    self.texture:SetRotation(radians)
  end,

  --- @type fun(self: LinearProgressTextureInstance, texture: number|string, textureWrapMode: WrapMode)
  SetTextureOrAtlas = function(self, texture, textureWrapMode)
    Private.SetTextureOrAtlas(self.texture, texture, textureWrapMode, textureWrapMode)
  end,

  --- @type fun(self: LinearProgressTextureInstance, desaturated: boolean)
  SetDesaturated = function(self, desaturate)
    self.texture:SetDesaturated(desaturate)
  end,
  --- @type fun(self: LinearProgressTextureInstance, blendMode: BlendMode)
  SetBlendMode = function(self, blendMode)
    self.texture:SetBlendMode(blendMode)
  end,

  --- @type fun(self: LinearProgressTextureInstance, width: number)
  SetWidth = function(self, width)
    self.width = width
  end,

  --- @type fun(self: LinearProgressTextureInstance, height: number)
  SetHeight = function(self, height)
    self.height = height
  end,
}

--- @type fun(frame:Frame) : LinearProgressTextureInstance
function Private.LinearProgressTextureBase.create(frame, layer, drawLayer)
  local linearTexture = {}
  linearTexture.coords = {}
  linearTexture.visible = true
  linearTexture.parentFrame = frame
  linearTexture.startProgress = 0
  linearTexture.endProgress = 1

  local texture = frame:CreateTexture(nil, layer)
  texture:SetSnapToPixelGrid(false)
  texture:SetTexelSnappingBias(0)
  texture:SetDrawLayer(layer, drawLayer)
  linearTexture.texture = texture
  linearTexture.coord  = Private.TextureCoords.create(texture)

  for funcName, func in pairs(funcs) do
    linearTexture[funcName] = func
  end

  --- @cast linearTexture LinearProgressTextureInstance
  return linearTexture
end

--- @type fun(linearTexture: LinearProgressTextureInstance, options: LinearProgressTextureOptions)
function Private.LinearProgressTextureBase.modify(linearTexture, options)
  linearTexture:SetTextureOrAtlas(options.texture, options.textureWrapMode)
  linearTexture:SetDesaturated(options.desaturated)
  linearTexture:SetBlendMode(options.blendMode)
  linearTexture:SetAuraRotation(options.auraRotation)
  linearTexture.crop_x = options.crop_x
  linearTexture.crop_y = options.crop_y
  linearTexture.user_x = options.user_x
  linearTexture.user_y = options.user_y
  linearTexture.mirror = options.mirror
  linearTexture.texRotation = options.texRotation
  linearTexture.width = options.width
  linearTexture.height = options.height
  linearTexture.offset = options.offset
  linearTexture:UpdateTextures()
end


-- ========================================
-- File: WeakAuras/BaseRegions/StopMotion.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L
local texture_data = WeakAuras.StopMotion.texture_data

--- @class StopMotionBase
Private.StopMotionBase = {}

--- @alias StopMotionAnimationType "progress"|"timed"|"background"

--- @class StopMotionBaseInstance
--- @field texture Texture
--- @field startTime number?
--- @field currentFrame number?
--- @field inverseDirection boolean?
--- @field frameRate number
--- @field animationType StopMotionAnimationType
--- @field textureFile number
--- @field startFrame number
--- @field endFrame number
--- @field lastFrame number
--- @field rows number
--- @field columns number
--- @field fileWidth number
--- @field fileHeight number
--- @field frameWidth number
--- @field frameHeight number
--- @field SetBaseTexture fun(self: StopMotionBaseInstance, texture: string)
--- @field SetFrame fun(self: StopMotionBaseInstance, texture: string, frame: number)

--- @class StopMotionOptions
--- @field frameRate number?
--- @field inverseDirection boolean?
--- @field animationType StopMotionAnimationType
--- @field startPercent number
--- @field endPercent number
--- @field texture string|number
--- @field blendMode BlendMode
--- @field customFrames number?
--- @field customRows number?
--- @field customColumns number?
--- @field customFileWidth number?
--- @field customFrameWidth number?
--- @field customFrameHeight number?

-- Helper method for Options

--- @type fun(textureName: string): boolean
function Private.StopMotionBase.textureNameHasData(textureName)
  if not textureName then
    return false
  end
  local pattern = "%.x(%d+)y(%d+)f(%d+)%.[tb][gl][ap]$"
  local pattern2 = "%.x(%d+)y(%d+)f(%d+)w(%d+)h(%d+)W(%d+)H(%d+)%.[tb][gl][ap]$"
  local ok = textureName:lower():match(pattern)
  if ok then return true end
  local ok2 = textureName:match(pattern2)
  if ok2 then
     return true
  else
     return false
  end
end

--- @type fun(texture: string, frame: number, rows: number, columns: number, frameScaleW: number, frameScaleH: number)
local function setTile(texture, frame, rows, columns, frameScaleW, frameScaleH)
  frame = frame - 1
  local row = floor(frame / columns)
  local column = frame % columns

  local deltaX = frameScaleW / columns
  local deltaY = frameScaleH / rows

  local left = deltaX * column
  local right = left + deltaX

  local top = deltaY * row
  local bottom = top + deltaY
  pcall(function() texture:SetTexCoord(left, right, top, bottom) end)
end

WeakAuras.setTile = setTile

-- Helper method for Options
--- @type fun(textureWidget: table, texturePath: string, textureName: string)
function Private.StopMotionBase.setTextureFunc(textureWidget, texturePath, textureName)
  local data = texture_data[texturePath]
  if not(data) then
    local pattern = "%.x(%d+)y(%d+)f(%d+)%.[tb][gl][ap]"
    local pattern2 = "%.x(%d+)y(%d+)f(%d+)w(%d+)h(%d+)W(%d+)H(%d+)%.[tb][gl][ap]"
    local rows, columns, frames = texturePath:lower():match(pattern)
    if rows then
      data = {
        count = tonumber(frames),
        rows = tonumber(rows),
        columns = tonumber(columns)
      }
    else
      local rows, columns, frames, frameWidth, frameHeight, fileWidth, fileHeight = texturePath:match(pattern2)
      if rows then
        rows, columns, frames, frameWidth, frameHeight, fileWidth, fileHeight
          = tonumber(rows), tonumber(columns), tonumber(frames), tonumber(frameWidth), tonumber(frameHeight),
            tonumber(fileWidth), tonumber(fileHeight)
        local frameScaleW = 1
        local frameScaleH = 1
        if fileWidth > 0 and frameWidth > 0 then
          frameScaleW = (frameWidth * columns) / fileWidth
        end
        if fileHeight > 0 and frameHeight > 0 then
          frameScaleH = (frameHeight * rows) / fileHeight
        end
        data = {
          count = frames,
          rows = rows,
          columns = columns,
          frameScaleW = frameScaleW,
          frameScaleH = frameScaleH
        }
      end
    end
   end
  textureWidget.frameNr = 0
  if (data) then
      if (data.rows and data.columns) then
        -- Texture Atlas
        textureWidget:SetTexture(texturePath, textureName, true)

        setTile(textureWidget, data.count, data.rows, data.columns, data.frameScaleW or 1, data.frameScaleH or 1)

        textureWidget:SetOnUpdate(function(self, elapsed)
          self.elapsed = (self.elapsed or 0) + elapsed
          if(self.elapsed > 0.1) then
            self.elapsed = self.elapsed - 0.1
            textureWidget.frameNr = textureWidget.frameNr + 1
            if (textureWidget.frameNr == data.count) then
              textureWidget.frameNr = 1
            end
            setTile(textureWidget, textureWidget.frameNr, data.rows, data.columns, data.frameScaleW or 1, data.frameScaleH or 1)
          end
        end)
      else
        -- Numbered Textures
        local texture = texturePath .. format("%03d", texture_data[texturePath].count)
        textureWidget:SetTexture(texture, textureName, true)
        textureWidget:SetTexCoord(0, 1, 0, 1)

        textureWidget:SetOnUpdate(function(self, elapsed)
          self.elapsed = (self.elapsed or 0) + elapsed
          if(self.elapsed > 0.1) then
            self.elapsed = self.elapsed - 0.1
            textureWidget.frameNr = textureWidget.frameNr + 1
            if (textureWidget.frameNr == data.count) then
              textureWidget.frameNr = 1
            end
            local texture = texturePath .. format("%03d", textureWidget.frameNr)
            textureWidget:SetTexture(texture, textureName)
          end
        end)
      end
  else
    local texture = texturePath .. format("%03d", 1)
    textureWidget:SetTexture(texture, textureName, true)
  end
end

local GetAtlasInfo = WeakAuras.IsClassicEra() and GetAtlasInfo or C_Texture.GetAtlasInfo

--- @type fun(self: StopMotionBaseInstance, texture: string)
local function SetTextureViaAtlas(self, texture)
  if type(texture) == "string" and GetAtlasInfo(texture) then
    self.texture:SetAtlas(texture)
  else
    self.texture:SetTexture(texture)
  end
end

--- @type fun(self: StopMotionBaseInstance, texture: string, frame: number)
local function SetFrameViaAtlas(self, texture, frame)
  local frameScaleW = 1
  local frameScaleH = 1
  if self.fileWidth and self.frameWidth and self.fileWidth > 0 and self.frameWidth > 0 then
    frameScaleW = (self.frameWidth * self.columns) / self.fileWidth
  end
  if self.fileHeight and self.frameHeight and self.fileHeight > 0 and self.frameHeight > 0 then
    frameScaleH = (self.frameHeight * self.rows) / self.fileHeight
  end
  setTile(self.texture, frame, self.rows, self.columns, frameScaleW, frameScaleH)
end

--- @type fun(self: StopMotionBaseInstance, texture: string)
local function SetTextureViaFrames(self, texture)
  self.texture:SetTexture(texture .. format("%03d", 0))
  self.texture:SetTexCoord(0, 1, 0, 1)
end

--- @type fun(self: StopMotionBaseInstance, texture: string, frame: number)
local function SetFrameViaFrames(self, texture, frame)
  self.texture:SetTexture(texture .. format("%03d", frame))
end

  --- @class StopMotionBaseInstance
local funcs = {
  --- @type fun(self: StopMotionBaseInstance, b: boolean)
  SetDesaturated = function(self, b)
    self.texture:SetDesaturated(b)
  end,
  --- @type fun(self: StopMotionBaseInstance, r: number, g: number, b: number, a: number?)
  SetColor = function(self, r, g, b, a)
    self.texture:SetVertexColor(r, g, b, a)
  end,

  --- @type fun(self: StopMotionBaseInstance) : number, number, number, number
  GetColor = function(self)
    return self.texture:GetVertexColor()
  end,

  --- @type fun(self: StopMotionBaseInstance, time: number)
  SetStartTime = function(self, time)
    self.startTime = time
  end,

  --- @type fun(self: StopMotionBaseInstance)
  TimedUpdate = function(self)
    local timeSinceStart = (GetTime() - self.startTime)
    local newCurrentFrame = floor(timeSinceStart * (self.frameRate or 15))
    if (newCurrentFrame == self.currentFrame) then
      return
    end

    self.currentFrame = newCurrentFrame

    local frames
    local startFrame = self.startFrame
    local endFrame = self.endFrame
    local inverse = self.inverseDirection
    if (endFrame >= startFrame) then
      frames = endFrame - startFrame + 1
    else
      frames = startFrame - endFrame + 1
      startFrame, endFrame = endFrame, startFrame
      inverse = not inverse
    end

    local frame = 0
    if (self.animationType == "loop") then
      frame = (newCurrentFrame % frames) + startFrame
    elseif (self.animationType == "bounce") then
      local direction = floor(newCurrentFrame / frames) % 2
      if (direction == 0) then
          frame = (newCurrentFrame % frames) + startFrame
      else
          frame = endFrame - (newCurrentFrame % frames)
      end
    elseif (self.animationType == "once") then
      frame = newCurrentFrame + startFrame
      if (frame > endFrame) then
        frame = endFrame
      end
    end
    if (inverse) then
      frame = endFrame - frame + startFrame
    end

    if (frame > endFrame) then
      frame = endFrame
      end
    if (frame < startFrame) then
      frame = startFrame
    end
    self:SetFrame(self.textureFile, frame)
  end,

  --- @type fun(self: StopMotionBaseInstance, progress: number)
  SetProgress = function(self, progress)
    local frames
    local startFrame = self.startFrame
    local endFrame = self.endFrame
    local inverse = self.inverseDirection
    if (endFrame >= startFrame) then
      frames = endFrame - startFrame + 1
    else
      frames = startFrame - endFrame + 1
      startFrame, endFrame = endFrame, startFrame
      inverse = not inverse
    end

    local frame = floor( (frames - 1) * progress) + startFrame

    if (inverse) then
      frame = endFrame - frame + startFrame
    end

    if (frame > endFrame) then
      frame = endFrame
       end
    if (frame < startFrame) then
      frame = startFrame
    end
    self:SetFrame(self.textureFile, frame)
  end,

  --- @type fun(self: StopMotionBaseInstance)
  ClearAllPoints = function(self)
    self.texture:ClearAllPoints()
  end,

  --- @type fun(self: StopMotionBaseInstance, ... : any)
  SetAllPoints = function(self, ...)
    self.texture:SetAllPoints(...)
  end,

  --- @type fun(self: StopMotionBaseInstance, ... : any)
  SetPoint = function(self, ...)
    self.texture:SetPoint(...)
  end,

  --- @type fun(self: StopMotionBaseInstance, w: number, h: number)
  SetSize = function(self, w, h)
    self.texture:SetSize(w, h)
  end,

  --- @type fun(self: StopMotionBaseInstance, b: boolean)
  SetVisible = function(self, b)
    if b then
      self.texture:Show()
    else
      self.texture:Hide()
    end
  end
}

--- @type fun(frame:Frame, drawLayer: DrawLayer) : StopMotionBaseInstance
function Private.StopMotionBase.create(frame, drawLayer)
  local stopMotion = {}

  local texture = frame:CreateTexture(nil, "ARTWORK")
  stopMotion.texture = texture
  texture:SetAllPoints(frame)
  texture:SetSnapToPixelGrid(false)
  texture:SetTexelSnappingBias(0)

  for funcName, func in pairs(funcs) do
    stopMotion[funcName] = func
  end

  --- @cast stopMotion StopMotionBaseInstance
  return stopMotion
end

--- @type fun(stopMotion: StopMotionBaseInstance, options: StopMotionOptions)
function Private.StopMotionBase.modify(stopMotion, options)
  stopMotion.frameRate = options.frameRate
  stopMotion.inverseDirection = options.inverseDirection
  stopMotion.animationType = options.animationType
  stopMotion.textureFile = options.texture

  local pattern = "%.x(%d+)y(%d+)f(%d+)%.[tb][gl][ap]"
  local pattern2 = "%.x(%d+)y(%d+)f(%d+)w(%d+)h(%d+)W(%d+)H(%d+)%.[tb][gl][ap]"

  do -- setup texture
    local tdata = texture_data[stopMotion.textureFile]
    if (tdata) then
      local lastFrame = tdata.count - 1
      stopMotion.lastFrame = lastFrame
      stopMotion.startFrame = floor( (options.startPercent or 0) * lastFrame) + 1
      stopMotion.endFrame = floor( (options.endPercent or 1) * lastFrame) + 1
      stopMotion.rows = tdata.rows
      stopMotion.columns = tdata.columns
      stopMotion.fileWidth = 0
      stopMotion.fileHeight = 0
      stopMotion.frameWidth = 0
      stopMotion.frameHeight = 0
    else
      local rows, columns, frames = stopMotion.textureFile:lower():match(pattern)
      if rows then
        local lastFrame = tonumber(frames) - 1
        stopMotion.lastFrame = lastFrame
        stopMotion.startFrame = floor( (options.startPercent or 0) * lastFrame) + 1
        stopMotion.endFrame = floor( (options.endPercent or 1) * lastFrame) + 1
        stopMotion.rows = tonumber(rows)
        stopMotion.columns = tonumber(columns)
        stopMotion.fileWidth = 0
        stopMotion.fileHeight = 0
        stopMotion.frameWidth = 0
        stopMotion.frameHeight = 0
      else
        local rows, columns, frames, frameWidth, frameHeight, fileWidth, fileHeight
              = stopMotion.textureFile:match(pattern2)
        if rows then
          local lastFrame = tonumber(frames) - 1
          stopMotion.lastFrame = lastFrame
          stopMotion.startFrame = floor( (options.startPercent or 0) * lastFrame) + 1
          stopMotion.endFrame = floor( (options.endPercent or 1) * lastFrame) + 1
          stopMotion.rows = tonumber(rows)
          stopMotion.columns = tonumber(columns)
          stopMotion.fileWidth = tonumber(fileWidth)
          stopMotion.fileHeight = tonumber(fileHeight)
          stopMotion.frameWidth = tonumber(frameWidth)
          stopMotion.frameHeight = tonumber(frameHeight)
        else
          local lastFrame = (options.customFrames or 256) - 1
          stopMotion.lastFrame = lastFrame
          stopMotion.startFrame = floor( (options.startPercent or 0) * lastFrame) + 1
          stopMotion.endFrame = floor( (options.endPercent or 1) * lastFrame) + 1
          stopMotion.rows = options.customRows
          stopMotion.columns = options.customColumns
          stopMotion.fileWidth = options.customFileWidth
          stopMotion.fileHeight = options.customFileHeight
          stopMotion.frameWidth = options.customFrameWidth
          stopMotion.frameHeight = options.customFrameHeight
        end
      end
    end
  end

  if (stopMotion.rows and stopMotion.columns) then
    stopMotion.SetBaseTexture = SetTextureViaAtlas
    stopMotion.SetFrame = SetFrameViaAtlas
  else
    stopMotion.SetBaseTexture = SetTextureViaFrames
    stopMotion.SetFrame = SetFrameViaFrames
  end

  stopMotion:SetBaseTexture(options.texture)
  if stopMotion.animationType == "background" then
    stopMotion:SetFrame(options.texture, stopMotion.endFrame or 1)
  else
    stopMotion:SetFrame(options.texture, 1)
  end
  stopMotion.texture:SetBlendMode(options.blendMode)
end


-- ========================================
-- File: WeakAuras/BaseRegions/Texture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

--- @class TextureBase
Private.TextureBase = {}

--- @class TextureBaseInstance
--- @field texture Texture
--- @field mirror_h boolean
--- @field mirror_v boolean
--- @field mirror boolean
--- @field rotation number
--- @field effectiveRotation number
--- @field canRotate boolean
--- @field textureWrapMode WrapMode

--- @class TextureBaseOptions
--- @field canRotate boolean
--- @field mirror boolean
--- @field rotation number
--- @field textureWrapMode WrapMode

local SQRT2 = sqrt(2)
local function GetRotatedPoints(degrees, scaleForFullRotate)
  local angle = rad(135 - degrees)
  local factor = scaleForFullRotate and 1 or SQRT2
  local vx = math.cos(angle) / factor
  local vy = math.sin(angle) / factor

  return 0.5+vx,0.5-vy , 0.5-vy,0.5-vx , 0.5+vy,0.5+vx , 0.5-vx,0.5+vy
end

local GetAtlasInfo = C_Texture and C_Texture.GetAtlasInfo or GetAtlasInfo

function Private.TextureBase:IsAtlas(input)
  return type(input) == "string" and GetAtlasInfo(input) ~= nil
end

local funcs = {
  --- @class TextureBaseInstance
  --- @field ClearAllPoints fun(self: TextureBaseInstance)
  ClearAllPoints = function(self)
    self.texture:ClearAllPoints()
  end,

  --- @class TextureBaseInstance
  --- @field SetAllPoints fun(self: TextureBaseInstance, ... : any)
  SetAllPoints = function(self, ...)
    self.texture:SetAllPoints(...)
  end,

  --- @class TextureBaseInstance
  --- @field DoTexCoord fun(self: TextureBaseInstance)
  DoTexCoord = function(self)
    local mirror_h, mirror_v = self.mirror_h, self.mirror_v
    if(self.mirror) then
      mirror_h = not mirror_h
    end
    local ulx,uly , llx,lly , urx,ury , lrx,lry
      = GetRotatedPoints(self.effectiveRotation, self.canRotate and not self.texture.IsAtlas)
    if(mirror_h) then
      if(mirror_v) then
        self.texture:SetTexCoord(lrx,lry , urx,ury , llx,lly , ulx,uly)
      else
        self.texture:SetTexCoord(urx,ury , lrx,lry , ulx,uly , llx,lly)
      end
    else
      if(mirror_v) then
        self.texture:SetTexCoord(llx,lly , ulx,uly , lrx,lry , urx,ury)
      else
        self.texture:SetTexCoord(ulx,uly , llx,lly , urx,ury , lrx,lry)
      end
    end
  end,

  --- @class TextureBaseInstance
  --- @field SetMirrorFromScale fun(self: TextureBaseInstance, h: boolean, v: boolean)
  SetMirrorFromScale = function(self, h, v)
    if self.mirror_h == h and self.mirror_v == v then
      return
    end
    self.mirror_h = h
    self.mirror_v = v
    self:DoTexCoord()
  end,

  --- @class TextureBaseInstance
  --- @field SetMirror fun(self: TextureBaseInstance, b: boolean)
  SetMirror = function(self, b)
    if self.mirror == b then
      return
    end
    self.mirror = b
    self:DoTexCoord()
  end,

  --- @class TextureBaseInstance
  --- @field SetTexture fun(self: TextureBaseInstance, file: number|string)
  SetTexture = function(self, file)
    self.textureName = file
    local oldIsAtlas = self.texture.IsAtlas
    Private.SetTextureOrAtlas(self.texture, self.textureName, self.textureWrapMode, self.textureWrapMode)
    if self.texture.IsAtlas ~= oldIsAtlas then
      self:DoTexCoord()
    end
  end,

  --- @class TextureBaseInstance
  --- @field SetColor fun(self: TextureBaseInstance, r: number, g: number, b: number, a: number)
  SetVertexColor = function(self, r, g, b, a)
    self.texture:SetVertexColor(r, g, b,a)
  end,

  --- @class TextureBaseInstance
  --- @field SetDesaturated fun(self: TextureBaseInstance, b: boolean)
  SetDesaturated = function(self, b)
    self.texture:SetDesaturated(b)
  end,

  --- @class TextureBaseInstance
  --- @field SetAnimRotation fun(self: TextureBaseInstance, degrees: number?)
  SetAnimRotation = function(self, degrees)
    self.animRotation = degrees
    self:UpdateEffectiveRotation()
  end,

  --- @class TextureBaseInstance
  --- @field SetRotation fun(self: TextureBaseInstance, degrees: number)
  SetRotation = function(self, degrees)
    self.rotation = degrees
    self:UpdateEffectiveRotation()
  end,

  --- @class TextureBaseInstance
  --- @field UpdateEffectiveRotation fun(self: TextureBaseInstance)
  UpdateEffectiveRotation = function(self)
    self.effectiveRotation = self.animRotation or self.rotation
    self:DoTexCoord()
  end,

  --- @class TextureBaseInstance
  --- @field GetBaseRotation fun(self: TextureBaseInstance): number
  GetBaseRotation = function(self)
    return self.rotation
  end
}

--- @type fun(frame: Frame) : TextureBaseInstance
function Private.TextureBase.create(frame)
    local base = {}

    for funcName, func in pairs(funcs) do
      base[funcName] = func
    end

    local texture = frame:CreateTexture()
    texture:SetSnapToPixelGrid(false)
    texture:SetTexelSnappingBias(0)

    base.texture = texture

    --- @cast base TextureBaseInstance
    return base
end

--- @type fun(base: TextureBaseInstance, options: TextureBaseOptions)
function Private.TextureBase.modify(base, options)
  base.canRotate = options.canRotate
  base.mirror = options.mirror
  base.rotation = options.rotation
  base.effectiveRotation = base.rotation
  base.textureWrapMode = options.textureWrapMode

  base.texture:SetDesaturated(options.desaturate)
  base.texture:SetBlendMode(options.blendMode)
  base:DoTexCoord()
end


-- ========================================
-- File: WeakAuras/BaseRegions/TextureCoords.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L


Private.TextureCoords = {}

local defaultTexCoord = {
  ULx = 0,
  ULy = 0,
  LLx = 0,
  LLy = 1,
  URx = 1,
  URy = 0,
  LRx = 1,
  LRy = 1,
}

local exactAngles = {
  {0.5, 0},  -- 0
  {1, 0},    -- 45
  {1, 0.5},  -- 90
  {1, 1},    -- 135
  {0.5, 1},  -- 180
  {0, 1},    -- 225
  {0, 0.5},  -- 270
  {0, 0}     -- 315
}

--- @type fun(angle: number): number, number
local function angleToCoord(angle)
  angle = angle % 360

  if (angle % 45 == 0) then
    local index = floor (angle / 45) + 1
    return exactAngles[index][1], exactAngles[index][2]
  end

  if (angle < 45) then
    return 0.5 + tan(angle) / 2, 0
  elseif (angle < 135) then
    return 1, 0.5 + tan(angle - 90) / 2
  elseif (angle < 225) then
    return 0.5 - tan(angle) / 2, 1
  elseif (angle < 315) then
    return 0, 0.5 - tan(angle - 90) / 2
  elseif (angle < 360) then
    return 0.5 + tan(angle) / 2, 0
  end
end

--- @alias TextureCoordsCorner "UL"|"LL"|"UR"|"LR"

--- @type TextureCoordsCorner[]
local pointOrder = { "LL", "UL", "UR", "LR", "LL", "UL", "UR", "LR", "LL", "UL", "UR", "LR" }

--- @type fun(x: number, y:number, scalex: number, scaley: number, texRotation: number, mirror_h: number, mirror_v: number, user_x: number?, user_y: number?)
local function TransformPoint(x, y, scalex, scaley, texRotation, mirror_h, mirror_v, user_x, user_y)
  -- 1) Translate texture-coords to user-defined center
  x = x - 0.5
  y = y - 0.5

  -- 2) Shrink texture by 1/sqrt(2)
  x = x * 1.4142
  y = y * 1.4142

  -- Not yet supported for circular progress
  -- 3) Scale texture by user-defined amount
  x = x / scalex
  y = y / scaley

  -- 4) Apply mirroring if defined
  if mirror_h then
    x = -x
  end
  if mirror_v then
    y = -y
  end

  local cos_rotation = cos(texRotation)
  local sin_rotation = sin(texRotation)

  -- 5) Rotate texture by user-defined value
  x, y = cos_rotation * x - sin_rotation * y, sin_rotation * x + cos_rotation * y

  -- 6) Translate texture-coords back to (0,0)
  x = x + 0.5
  y = y + 0.5

  x = x + (user_x or 0)
  y = y + (user_y or 0)

  return x, y
end



--- @class TextureCoords
--- @field ULx number
--- @field ULy number
--- @field LLx number
--- @field LLy number
--- @field URx number
--- @field URy number
--- @field LRx number
--- @field LRy number
--- @field ULvx number
--- @field ULvy number
--- @field LLvx number
--- @field LLvy number
--- @field URvx number
--- @field URvy number
--- @field LRvx number
--- @field LRvy number
--- @field texture Texture

--- @class TextureCoords
local funcs = {
  --- @type fun(self: TextureCoords, width: number, height: number, corner: TextureCoordsCorner, x: number, y: number)
  MoveCorner = function (self, width, height, corner, x, y)
    local rx = defaultTexCoord[corner .. "x"] - x
    local ry = defaultTexCoord[corner .. "y"] - y
    self[corner .. "vx"] = -rx * width
    self[corner .. "vy"] = ry * height

    self[corner .. "x"] = x
    self[corner .. "y"] = y
  end,

  --- @type fun(self: TextureCoords)
  Hide = function(self)
    self.texture:Hide()
  end,

  --- @type fun(self: TextureCoords)
  Show = function(self)
    self:Apply()
    self.texture:Show()
  end,

  --- @type fun(self: TextureCoords)
  SetFull = function(self)
    self.ULx = 0
    self.ULy = 0
    self.LLx = 0
    self.LLy = 1
    self.URx = 1
    self.URy = 0
    self.LRx = 1
    self.LRy = 1

    self.ULvx = 0
    self.ULvy = 0
    self.LLvx = 0
    self.LLvy = 0
    self.URvx = 0
    self.URvy = 0
    self.LRvx = 0
    self.LRvy = 0
  end,

  --- @type fun(self: TextureCoords)
  Apply = function(self)
    self.texture:SetVertexOffset(UPPER_RIGHT_VERTEX, self.URvx, self.URvy)
    self.texture:SetVertexOffset(UPPER_LEFT_VERTEX, self.ULvx, self.ULvy)
    self.texture:SetVertexOffset(LOWER_RIGHT_VERTEX, self.LRvx, self.LRvy)
    self.texture:SetVertexOffset(LOWER_LEFT_VERTEX, self.LLvx, self.LLvy)

    self.texture:SetTexCoord(self.ULx, self.ULy, self.LLx, self.LLy, self.URx, self.URy, self.LRx, self.LRy)
  end,
  --- @type fun(self: TextureCoords, width: number, height: number, angle1: number, angle2: number)
  SetAngle = function(self, width, height, angle1, angle2)
    local index = floor((angle1 + 45) / 90)

    local middleCorner = pointOrder[index + 1]
    local startCorner = pointOrder[index + 2]
    local endCorner1 = pointOrder[index + 3]
    local endCorner2 = pointOrder[index + 4]

    -- LL => 32, 32
    -- UL => 32, -32
    self:MoveCorner(width, height, middleCorner, 0.5, 0.5)
    self:MoveCorner(width, height, startCorner, angleToCoord(angle1))

    local edge1 = floor((angle1 - 45) / 90)
    local edge2 = floor((angle2 -45) / 90)

    if (edge1 == edge2) then
      self:MoveCorner(width, height, endCorner1, angleToCoord(angle2))
    else
      self:MoveCorner(width, height, endCorner1, defaultTexCoord[endCorner1 .. "x"], defaultTexCoord[endCorner1 .. "y"])
    end

    self:MoveCorner(width, height, endCorner2, angleToCoord(angle2))
  end,
  --- @type fun(self: TextureCoords, scalex: number, scaley: number, texRotation: number, mirror_h: boolean, mirror_v: boolean, user_x: number?, user_y: number?)
  Transform = function(self, scalex, scaley, texRotation, mirror_h, mirror_v, user_x, user_y)
      self.ULx, self.ULy = TransformPoint(self.ULx, self.ULy, scalex, scaley,
                                          texRotation, mirror_h, mirror_v, user_x, user_y)
      self.LLx, self.LLy = TransformPoint(self.LLx, self.LLy, scalex, scaley,
                                          texRotation, mirror_h, mirror_v, user_x, user_y)
      self.URx, self.URy = TransformPoint(self.URx, self.URy, scalex, scaley,
                                          texRotation, mirror_h, mirror_v, user_x, user_y)
      self.LRx, self.LRy = TransformPoint(self.LRx, self.LRy, scalex, scaley,
                                          texRotation, mirror_h, mirror_v, user_x, user_y)
  end
}

--- @type fun(texture: Texture): TextureCoords
function Private.TextureCoords.create(texture)
  local coord = {
    ULx = 0,
    ULy = 0,
    LLx = 0,
    LLy = 1,
    URx = 1,
    URy = 0,
    LRx = 1,
    LRy = 1,

    ULvx = 0,
    ULvy = 0,
    LLvx = 0,
    LLvy = 0,
    URvx = 0,
    URvy = 0,
    LRvx = 0,
    LRvy = 0,

    texture = texture
  }

  for k, f in pairs(funcs) do
    coord[k] = f
  end

  --- @class TextureCoords
  return coord
end


-- ========================================
-- File: WeakAuras/BossMods.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local timer = WeakAuras.timer;
local L = WeakAuras.L


local function TestForMultiSelect(trigger, name, checkValue)
  if(trigger["use_"..name] == false) then -- multi selection
    if trigger[name] and trigger[name].multi then
      if trigger[name].multi[checkValue] then
        return "true"
      else
        return "nil"
      end
    end
    return "false"
  elseif(trigger["use_"..name]) then -- single selection
    local value = trigger[name] and trigger[name].single
    if not value then
      return "false"
    end
    return (value == checkValue) and "true" or "false"
  else
    return "nil"
  end
end


Private.ExecEnv.BossMods = {}

-- DBM
Private.ExecEnv.BossMods.DBM = {
  registeredEvents = {},
  bars = {},
  nextExpire = nil,
  recheckTimer = nil,

  CopyBarToState = function(self, bar, states, timerId, extendTimer)
    extendTimer = extendTimer or 0
    states[timerId] = states[timerId] or {}
    local state = states[timerId]
    state.show = true
    state.changed = true
    state.icon = bar.icon
    state.message = bar.message
    state.text = bar.message
    state.name = bar.message
    state.expirationTime = bar.expirationTime + extendTimer
    state.progressType = 'timed'
    state.duration = bar.duration + extendTimer
    state.timerType = bar.timerType
    state.spellId = bar.spellId
    state.count = bar.count
    state.dbmType = bar.dbmType
    state.dbmColor = bar.dbmColor
    state.extend = extendTimer
    state.isBarEnabled = bar.isBarEnabled
    if extendTimer ~= 0 then
      state.autoHide = true
    end
    state.paused = bar.paused
    state.remaining = bar.remaining
  end,

  TimerMatches = function(self, timerId, message, operator, spellId, counter, triggerId, dbmType, noCastBar, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    if not self.bars[timerId] then
      return false
    end

    local v = self.bars[timerId]
    if triggerId and triggerId ~= "" and triggerId ~= timerId then
      return false
    end
    if spellId and spellId ~= "" and spellId ~= v.spellId then
      return false
    end
    if isBarEnabled ~= nil and isBarEnabled ~= v.isBarEnabled then
      return false
    end
    if message and message ~= "" and operator then
      if operator == "==" then
        if v.message ~= message then
          return false
        end
      elseif operator == "find('%s')" then
        if v.message == nil or not v.message:find(message, 1, true) then
          return false
        end
      elseif operator == "match('%s')" then
        if v.message == nil or not v.message:match(message) then
          return false
        end
      end
    end
    if counter then
      counter:SetCount(tonumber(v.count) or 0)
      if not counter:Match() then
        return false
      end
    end

    if noCastBar and v.timerType:find("^cast") then
      return false
    end

    if dbmType and dbmType ~= v.dbmType then
      return false
    end

    if isPullTimer or isBreakTimer or isTimer then
      if (isPullTimer and v.timerType == "pull")
      or (isBreakTimer and v.timerType == "break")
      or (isTimer and (v.timerType ~= "break" and v.timerType ~= "pull"))
      then
        -- pass if one of the types match
      else
        return false
      end
    end

    return true
  end,

  TimerMatchesGeneric = function(self, timerId, message, operator, spellId, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    return self:TimerMatches(timerId, message, operator, spellId, counter, nil, nil, true, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
  end,

  GetStage = function()
    if DBM then
      return DBM:GetStage()
    end
    return 0, 0
  end,

  GetAllTimers = function(self)
    return self.bars
  end,

  GetTimerById = function(self, timerId)
    return self.bars[timerId]
  end,

  GetTimer = function(self, message, operator, spellId, extendTimer, count, triggerId, dbmType, noCastBar, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    local bestMatch
    for timerId, bar in pairs(self.bars) do
      if self:TimerMatches(timerId, message, operator, spellId, count, triggerId, dbmType, noCastBar, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
      and (bestMatch == nil or bar.expirationTime < bestMatch.expirationTime)
      and bar.expirationTime + extendTimer > GetTime()
      then
        bestMatch = bar
      end
    end
    return bestMatch
  end,

  GetTimerGeneric = function(self, message, operator, spellId, extendTimer, count, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    return self:GetTimer(message, operator, spellId, extendTimer, count, nil, nil, true, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
  end,

  RecheckTimers = function(self)
    local now = GetTime()
    self.nextExpire = nil
    for timerId, bar in pairs(self.bars) do
      if not bar.paused then
        if bar.expirationTime < now then
          if bar.scheduledScanExpireAt == nil or bar.scheduledScanExpireAt <= GetTime() then
            self.bars[timerId] = nil
          else
            if self.nextExpire == nil then
              self.nextExpire = bar.scheduledScanExpireAt
            elseif bar.scheduledScanExpireAt < self.nextExpire then
              self.nextExpire = bar.scheduledScanExpireAt
            end
          end
          if not bar.expired then
            bar.expired = true
            Private.ScanEvents("DBM_TimerStop", timerId)
            if self.isGeneric then
              Private.ScanEvents("BossMod_TimerStop", timerId)
            end
          end
        elseif self.nextExpire == nil then
          self.nextExpire = bar.expirationTime
        elseif bar.expirationTime < self.nextExpire then
          self.nextExpire = bar.expirationTime
        end
      end
    end
    if self.nextExpire then
      self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, self.nextExpire - now, self)
    end
  end,

  EventCallback = function(self, event, ...)
    if event == "DBM_Announce" then
      local message, icon, _, spellId, _, _, count = ...
      Private.ScanEvents("DBM_Announce", spellId, message, icon)
      if self.isGeneric then
        count = count and tostring(count) or "0"
        Private.ScanEvents("BossMod_Announce", spellId, message, icon, count)
      end
    elseif event == "DBM_TimerBegin" then
      local timerId, msg, duration, icon, timerType, spellId, dbmType, _, _, _, _, _, timerCount, _, _, _, _, isBarEnabled = ...
      local now = GetTime()
      local expirationTime = now + duration
      self.bars[timerId] = self.bars[timerId] or {}
      local bar = self.bars[timerId]
      bar.message = msg
      bar.expirationTime = expirationTime
      bar.duration = duration
      bar.icon = icon
      bar.timerType = timerType
      if timerType == "break" then
        spellId = -1
      elseif timerType == "pull" then
        spellId = -2
      end
      bar.spellId = tostring(spellId)
      bar.count = timerCount and tostring(timerCount) or "0"
      bar.dbmType = dbmType
      bar.expired = nil
      bar.isBarEnabled = isBarEnabled

      local r, g, b = 0, 0, 0
      if DBT.GetColorForType then
        r, g, b = DBT:GetColorForType(dbmType)
        r, g, b = r or 0, g or 0, b or 0
      else
        -- Compability code for DBM versions from around Aberrus
        -- Can be removed once we can assume newer versions
        local barOptions = DBT.Options

        if dbmType == 1 then
          r, g, b = barOptions.StartColorAR, barOptions.StartColorAG, barOptions.StartColorAB
        elseif dbmType == 2 then
          r, g, b = barOptions.StartColorAER, barOptions.StartColorAEG, barOptions.StartColorAEB
        elseif dbmType == 3 then
          r, g, b = barOptions.StartColorDR, barOptions.StartColorDG, barOptions.StartColorDB
        elseif dbmType == 4 then
          r, g, b = barOptions.StartColorIR, barOptions.StartColorIG, barOptions.StartColorIB
        elseif dbmType == 5 then
          r, g, b = barOptions.StartColorRR, barOptions.StartColorRG, barOptions.StartColorRB
        elseif dbmType == 6 then
          r, g, b = barOptions.StartColorPR, barOptions.StartColorPG, barOptions.StartColorPB
        elseif dbmType == 7 then
          r, g, b = barOptions.StartColorUIR, barOptions.StartColorUIG, barOptions.StartColorUIB
        elseif dbmType == 8 then
          r, g, b = barOptions.StartColorI2R, barOptions.StartColorI2G, barOptions.StartColorI2B
        else
          r, g, b = barOptions.StartColorR, barOptions.StartColorG, barOptions.StartColorB
        end
      end
      bar.dbmColor = {r, g, b}

      Private.ScanEvents("DBM_TimerStart", timerId)
      if self.isGeneric then
        Private.ScanEvents("BossMod_TimerStart", timerId)
      end
      if self.nextExpire == nil then
        self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, expirationTime - now, self)
        self.nextExpire = expirationTime
      elseif expirationTime < self.nextExpire then
        timer:CancelTimer(self.recheckTimer)
        self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, expirationTime - now, self)
        self.nextExpire = expirationTime
      end
    elseif event == "DBM_TimerStop" then
      local timerId = ...
      local bar = self.bars[timerId]
      if bar then
        if bar.scheduledScanExpireAt == nil or bar.scheduledScanExpireAt <= GetTime() then
          self.bars[timerId] = nil
        end
        bar.expired = true
        Private.ScanEvents("DBM_TimerStop", timerId)
        if self.isGeneric then
          Private.ScanEvents("BossMod_TimerStop", timerId)
        end
      end
    elseif event == "DBM_TimerPause" then
      local timerId = ...
      local bar = self.bars[timerId]
      if bar then
        bar.paused = true
        bar.remaining = bar.expirationTime - GetTime()
        Private.ScanEvents("DBM_TimerPause", timerId)
        if self.isGeneric then
          Private.ScanEvents("BossMod_TimerPause", timerId)
        end
        if self.recheckTimer then
          timer:CancelTimer(self.recheckTimer)
        end
        self:RecheckTimers()
      end
    elseif event == "DBM_TimerResume" then
      local timerId = ...
      local bar = self.bars[timerId]
      if bar then
        bar.paused = nil
        bar.expirationTime = GetTime() + (bar.remaining or 0)
        bar.remaining = nil
        Private.ScanEvents("DBM_TimerResume", timerId)
        if self.isGeneric then
          Private.ScanEvents("BossMod_TimerResume", timerId)
        end
        if self.nextExpire == nil then
          self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, bar.expirationTime - GetTime(), self)
          self.nextExpire = bar.expirationTime
        elseif bar.expirationTime < self.nextExpire then
          timer:CancelTimer(self.recheckTimer)
          self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, bar.expirationTime - GetTime(), self)
          self.nextExpire = bar.expirationTime
        end
      end
    elseif event == "DBM_TimerUpdate" then
      local timerId, elapsed, duration = ...
      local now = GetTime()
      local expirationTime = now + duration - elapsed
      local bar = self.bars[timerId]
      if bar then
        bar.duration = duration
        bar.expirationTime = expirationTime
        if self.nextExpire == nil then
          self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, bar.expirationTime - now, self)
          self.nextExpire = expirationTime
        elseif self.nextExpire == nil or expirationTime < self.nextExpire then
          timer:CancelTimer(self.recheckTimer)
          self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, bar.expirationTime - now, self)
          self.nextExpire = expirationTime
        end
      end
      Private.ScanEvents("DBM_TimerUpdate", timerId)
      if self.isGeneric then
        Private.ScanEvents("BossMod_TimerUpdate", timerId)
      end
    elseif event == "DBM_TimerUpdateIcon" then
      local timerId, icon = ...
      local bar = self.bars[timerId]
      if bar then
        bar.icon = icon
      end
      Private.ScanEvents("DBM_TimerUpdateIcon", timerId)
      if self.isGeneric then
        Private.ScanEvents("BossMod_TimerUpdateIcon", timerId)
      end
    elseif event == "DBM_SetStage" or event == "DBM_Pull" or event == "DBM_Wipe" or event == "DBM_Kill" then
      Private.ScanEvents("DBM_SetStage")
      if self.isGeneric then
        Private.ScanEvents("BossMod_SetStage")
      end
    end
  end,

  RegisterCallback = function(self, event)
    if self.registeredEvents[event] then
      return
    end
    if DBM then
      DBM:RegisterCallback(event, function(...) self:EventCallback(...) end)
      self.registeredEvents[event] = true
    end
  end,

  RegisterTimer = function(self)
    self:RegisterCallback("DBM_TimerBegin")
    self:RegisterCallback("DBM_TimerStop")
    self:RegisterCallback("DBM_TimerPause")
    self:RegisterCallback("DBM_TimerResume")
    self:RegisterCallback("DBM_TimerUpdate")
    self:RegisterCallback("DBM_TimerUpdateIcon")
  end,

  RegisterMessage = function(self)
    self:RegisterCallback("DBM_Announce")
  end,

  RegisterStage = function(self)
    self:RegisterCallback("DBM_SetStage")
    self:RegisterCallback("DBM_Pull")
    self:RegisterCallback("DBM_Kill")
  end,

  scheduled_scans = {},

  DoScan = function(self, fireTime)
    self.scheduled_scans[fireTime] = nil
    Private.ScanEvents("DBM_TimerUpdate")
    if self.isGeneric then
      Private.ScanEvents("BossMod_TimerUpdate")
    end
  end,

  ScheduleCheck = function(self, fireTime)
    if not self.scheduled_scans[fireTime] then
      self.scheduled_scans[fireTime] = timer:ScheduleTimerFixed(self.DoScan, fireTime - GetTime(), self, fireTime)
    end
  end
}

if not WeakAuras.IsMistsOrRetail() then
  Private.event_prototypes["DBM Stage"] = {
    type = "addons",
    events = {},
    internal_events = {
      "DBM_SetStage"
    },
    force_events = "DBM_SetStage",
    name = L["DBM Stage"],
    init = function(trigger)
      Private.ExecEnv.BossMods.DBM:RegisterStage()
      return ""
    end,
    args = {
      {
        name = "stage",
        init = "Private.ExecEnv.BossMods.DBM:GetStage()",
        display = L["Journal Stage"],
        desc = L["Matches stage number of encounter journal.\nIntermissions are .5\nE.g. 1;2;1;2;2.5;3"],
        type = "number",
        conditionType = "number",
        store = true,
      },
      {
        name = "stageTotal",
        init = "select(2, Private.ExecEnv.BossMods.DBM:GetStage())",
        display = L["Stage Counter"],
        desc = L["Increases by one per stage or intermission."],
        type = "number",
        conditionType = "number",
        store = true,
      },
    },
    automaticrequired = true,
    statesParameter = "one",
    progressType = "none"
  }
  Private.category_event_prototype.addons["DBM Stage"] = L["DBM Stage"]

  Private.event_prototypes["DBM Announce"] = {
    type = "addons",
    events = {},
    internal_events = {
      "DBM_Announce"
    },
    name = L["DBM Announce"],
    init = function(trigger)
      Private.ExecEnv.BossMods.DBM:RegisterMessage();
      local ret = "local use_cloneId = %s;"
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    statesParameter = "all",
    args = {
      {
        name = "spellId",
        init = "arg",
        display = L["Spell Id"],
        type = "spell",
        noValidation = true,
        showExactOption = false,
        negativeIsEJ = true
      },
      {
        name = "message",
        init = "arg",
        display = L["Message"],
        type = "longstring",
        store = true,
        conditionType = "string"
      },
      {
        name = "name",
        init = "message",
        hidden = true,
        test = "true",
        store = true,
      },
      {
        name = "icon",
        init = "arg",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      },
    },
    timedrequired = true,
    progressType = "timed"
  }
  Private.category_event_prototype.addons["DBM Announce"] = L["DBM Announce"]

  Private.event_prototypes["DBM Timer"] = {
    type = "addons",
    events = {},
    internal_events = {
      "DBM_TimerStart", "DBM_TimerStop", "DBM_TimerUpdate", "DBM_TimerForce", "DBM_TimerResume", "DBM_TimerPause",
      "DBM_TimerUpdateIcon"
    },
    force_events = "DBM_TimerForce",
    name = L["DBM Timer"],
    progressType = "timed",
    triggerFunction = function(trigger)
      Private.ExecEnv.BossMods.DBM:RegisterTimer()
      local ret = [=[
        local triggerCounter = %q
        local counter
        if triggerCounter and triggerCounter ~= "" then
          counter = Private.ExecEnv.CreateTriggerCounter(triggerCounter)
        else
          counter = Private.ExecEnv.CreateTriggerCounter()
        end
        return function (states, event, timerId)
          local triggerId = %q
          local triggerSpellId = %q
          local triggerText = %q
          local triggerTextOperator = %q
          local useClone = %s
          local extendTimer = %s
          local triggerUseRemaining = %s
          local triggerRemaining = %s
          local triggerDbmType = %s
          local isBarEnabled = %s
          local cloneId = useClone and timerId or ""
          local state = states[cloneId]
          local counter = counter

          function copyOrSchedule(bar, cloneId)
            local remainingTime
            local changed
            if bar.paused then
              remainingTime = bar.remaining + extendTimer
            else
              remainingTime = bar.expirationTime - GetTime() + extendTimer
            end
            if triggerUseRemaining then
              if remainingTime > 0 and remainingTime %s triggerRemaining then
                Private.ExecEnv.BossMods.DBM:CopyBarToState(bar, states, cloneId, extendTimer)
                changed = true
              else
                local state = states[cloneId]
                if state and state.show then
                  state.show = false
                  state.changed = true
                  changed = true
                end
              end
              if not bar.paused then
                if extendTimer > 0 then
                  bar.scheduledScanExpireAt = math.max(bar.scheduledScanExpireAt or 0, bar.expirationTime + extendTimer)
                end
                if remainingTime >= triggerRemaining  then
                  Private.ExecEnv.BossMods.DBM:ScheduleCheck(bar.expirationTime - triggerRemaining + extendTimer)
                end
              end
            else
              if not bar.paused and extendTimer > 0 then
                bar.scheduledScanExpireAt = math.max(bar.scheduledScanExpireAt or 0, bar.expirationTime + extendTimer)
              end
              if remainingTime > 0 then
                Private.ExecEnv.BossMods.DBM:CopyBarToState(bar, states, cloneId, extendTimer)
                changed = true
              end
            end
            return changed
          end

          if useClone then
            if event == "DBM_TimerStart"
            or event == "DBM_TimerPause"
            or event == "DBM_TimerResume"
            then
              if Private.ExecEnv.BossMods.DBM:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerId, triggerDbmType, isBarEnabled) then
                local bar = Private.ExecEnv.BossMods.DBM:GetTimerById(timerId)
                if bar then
                  return copyOrSchedule(bar, cloneId)
                end
              end
            elseif event == "DBM_TimerStop" and state then
              local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
              if state.extend == 0 or bar_remainingTime <= 0 then
                state.show = false
                state.changed = true
                return true
              end
            elseif event == "DBM_TimerUpdate" or event == "DBM_TimerUpdateIcon" then
              local changed
              for timerId, bar in pairs(Private.ExecEnv.BossMods.DBM:GetAllTimers()) do
                if Private.ExecEnv.BossMods.DBM:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerId, triggerDbmType, isBarEnabled) then
                  changed = copyOrSchedule(bar, timerId) or changed
                else
                  local state = states[timerId]
                  if state then
                    local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
                    if state.extend == 0 or bar_remainingTime <= 0 then
                      state.show = false
                      state.changed = true
                      changed = true
                    end
                  end
                end
              end
              return changed
            elseif event == "DBM_TimerForce" then
              local changed
              for _, state in pairs(states) do
                state.show = false
                state.changed = true
                changed = true
              end
              for timerId, bar in pairs(Private.ExecEnv.BossMods.DBM:GetAllTimers()) do
                if Private.ExecEnv.BossMods.DBM:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerId, triggerDbmType, isBarEnabled) then
                  changed = copyOrSchedule(bar, timerId) or changed
                end
              end
              return changed
            end
          else
            if event == "DBM_TimerStart" or event == "DBM_TimerUpdate" then
              if extendTimer ~= 0 then
                if Private.ExecEnv.BossMods.DBM:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerId, triggerDbmType, isBarEnabled) then
                  local bar = Private.ExecEnv.BossMods.DBM:GetTimerById(timerId)
                  Private.ExecEnv.BossMods.DBM:ScheduleCheck(bar.expirationTime + extendTimer)
                end
              end
            end
            local bar = Private.ExecEnv.BossMods.DBM:GetTimer(triggerText, triggerTextOperator, triggerSpellId, extendTimer, counter, triggerId, triggerDbmType, isBarEnabled)
            if bar then
              if extendTimer == 0
                or not (state and state.show)
                or (state and state.show and state.expirationTime > (bar.expirationTime + extendTimer))
              then
                return copyOrSchedule(bar, cloneId)
              end
            else
              if state and state.show then
                local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
                if state.extend == 0 or bar_remainingTime <= 0 then
                  state.show = false
                  state.changed = true
                  return true
                end
              end
            end
          end
        end
        ]=]

      return ret:format(
        trigger.use_count and trigger.count or "",
        trigger.use_id and trigger.id or "",
        trigger.use_spellId and tostring(trigger.spellId) or "",
        trigger.use_message and trigger.message or "",
        trigger.use_message and trigger.message_operator or "",
        trigger.use_cloneId and "true" or "false",
        trigger.use_extend and tonumber(trigger.extend or 0) or 0,
        trigger.use_remaining and "true" or "false",
        trigger.remaining and tonumber(trigger.remaining or 0) or 0,
        trigger.use_dbmType and trigger.dbmType or "nil",
        trigger.use_isBarEnabled == nil and "nil" or trigger.use_isBarEnabled and "true" or "false",
        trigger.remaining_operator or "<"
      )
    end,
    statesParameter = "full",
    args = {
      {
        name = "id",
        display = L["Timer Id"],
        type = "string",
      },
      {
        name = "spellId",
        display = L["Spell Id"],
        store = true,
        type = "spell",
        conditionType = "string",
        noValidation = true,
        showExactOption = false,
        negativeIsEJ = true
      },
      {
        name = "message",
        display = L["Message"],
        type = "longstring",
        store = true,
        conditionType = "string"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
      },
      {
        name = "extend",
        display = L["Offset Timer"],
        type = "string",
      },
      {
        name = "count",
        display = L["Count"],
        desc = L["Occurrence of the event, reset when aura is unloaded\nCan be a range of values\nCan have multiple values separated by a comma or a space\n\nExamples:\n2nd 5th and 6th events: 2, 5, 6\n2nd to 6th: 2-6\nevery 2 events: /2\nevery 3 events starting from 2nd: 2/3\nevery 3 events starting from 2nd and ending at 11th: 2-11/3\n\nOnly if DBM shows it on it's bar"],
        type = "string",
        store = true,
        conditionType = "string",
        operator_types = "none",
        preamble = "local counter = Private.ExecEnv.CreateTriggerCounter(%q)",
        test = "counter:SetCount(tonumber(count) or 0) == nil and counter:Match()",
        conditionPreamble = function(input)
          return Private.ExecEnv.CreateTriggerCounter(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          preamble:SetCount(tonumber(state.count) or 0)
          return preamble:Match()
        end,
      },
      {
        name = "dbmType",
        display = L["Type"],
        type = "select",
        values = "dbm_types",
        conditionType = "select",
        test = "true"
      },
      {
        name = "isBarEnabled",
        display = L["Bar enabled in DBM settings"],
        desc = L["Test if bar is enabled in DBM settings"],
        type = "tristate",
        test = "true",
        init = "false",
        conditionType = "bool"
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle"
      }
    },
    automaticrequired = true,
  }
  Private.category_event_prototype.addons["DBM Timer"] = L["DBM Timer"]
end

-- BigWigs
Private.ExecEnv.BossMods.BigWigs = {
  registeredEvents = {},
  bars = {},
  nextExpire = nil,
  recheckTimer = nil,
  currentStage = 0,

  CopyBarToState = function(self, bar, states, timerId, extendTimer)
    extendTimer = extendTimer or 0
    states[timerId] = states[timerId] or {}
    local state = states[timerId]
    state.show = true
    state.changed = true
    state.addon = bar.addon
    state.spellId = bar.spellId
    state.text = bar.text
    state.message = bar.text
    state.name = bar.text
    state.timerType = bar.timerType
    state.duration = bar.duration + extendTimer
    state.expirationTime = bar.expirationTime + extendTimer
    state.bwBarColor = bar.bwBarColor
    state.bwTextColor = bar.bwTextColor
    state.bwBackgroundColor = bar.bwBackgroundColor
    state.count = bar.count
    state.cast = bar.cast
    state.progressType = "timed"
    state.icon = bar.icon
    state.extend = extendTimer
    if extendTimer ~= 0 then
      state.autoHide = true
    end
    state.paused = bar.paused
    state.remaining = bar.remaining
    state.isCooldown = bar.isCooldown
    state.isBarEnabled = bar.isBarEnabled
  end,

  TimerMatches = function(self, timerId, message, operator, spellId, counter, cast, cooldown, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    if not self.bars[timerId] then
      return false
    end

    local v = self.bars[timerId]
    if spellId and spellId ~= "" and spellId ~= v.spellId then
      return false
    end
    if isBarEnabled ~= nil and isBarEnabled ~= v.isBarEnabled then
      return false
    end
    if message and message ~= "" and operator then
      if operator == "==" then
        if v.text ~= message then
          return false
        end
      elseif operator == "find('%s')" then
        if v.text == nil or not v.text:find(message, 1, true) then
          return false
        end
      elseif operator == "match('%s')" then
        if v.text == nil or not v.text:match(message) then
          return false
        end
      end
    end
    if counter then
      counter:SetCount(tonumber(v.count) or 0)
      if not counter:Match() then
        return false
      end
    end
    if cast ~= nil and v.cast ~= cast then
      return false
    end
    if cooldown ~= nil and v.isCooldown ~= cooldown then
      return false
    end
    if isPullTimer or isBreakTimer or isTimer then
      if (isPullTimer and v.timerType == "pull")
      or (isBreakTimer and v.timerType == "break")
      or (isTimer and (v.timerType ~= "break" and v.timerType ~= "pull"))
      then
        -- pass if one of the types match
      else
        return false
      end
    end
    return true
  end,

  TimerMatchesGeneric = function(self, timerId, message, operator, spellId, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    return self:TimerMatches(timerId, message, operator, spellId, counter, false, nil, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
  end,

  GetStage = function(self)
    return self.currentStage
  end,

  GetAllTimers = function(self)
    return self.bars
  end,

  GetTimerById = function(self, timerId)
    return self.bars[timerId]
  end,

  GetTimer = function(self, text, operator, spellId, extendTimer, counter, cast, cooldown, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    local bestMatch
    for timerId, bar in pairs(self.bars) do
      if self:TimerMatches(timerId, text, operator, spellId, counter, cast, cooldown, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
      and (bestMatch == nil or bar.expirationTime < bestMatch.expirationTime)
      and bar.expirationTime + extendTimer > GetTime()
      then
        bestMatch = bar
      end
    end
    return bestMatch
  end,

  GetTimerGeneric = function(self, text, operator, spellId, extendTimer, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
    return self:GetTimer(text, operator, spellId, extendTimer, counter, false, nil, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
  end,

  RecheckTimers = function(self)
    local now = GetTime()
    self.nextExpire = nil
    for timerId, bar in pairs(self.bars) do
      if not bar.paused then
        if bar.expirationTime < now then
          if bar.scheduledScanExpireAt == nil or bar.scheduledScanExpireAt <= GetTime() then
            self.bars[timerId] = nil
          else
            if self.nextExpire == nil then
              self.nextExpire = bar.scheduledScanExpireAt
            elseif bar.scheduledScanExpireAt < self.nextExpire then
              self.nextExpire = bar.scheduledScanExpireAt
            end
          end
          if not bar.expired then
            bar.expired = true
            Private.ScanEvents("BigWigs_StopBar", timerId)
            if self.isGeneric then
              Private.ScanEvents("BossMod_TimerStop", timerId)
            end
          end
        elseif self.nextExpire == nil then
          self.nextExpire = bar.expirationTime
        elseif bar.expirationTime < self.nextExpire then
          self.nextExpire = bar.expirationTime
        end
      end
    end

    if self.nextExpire then
      self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, self.nextExpire - now, self)
    end
  end,

  EventCallback = function(self, event, ...)
    if event == "BigWigs_Message" then
      Private.ScanEvents("BigWigs_Message", ...)
      if self.isGeneric then
        local _, spellId, text, _, icon = ...
        local count = text and text:match("%((%d+)%)") or text:match("(%d+)") or "0"
        Private.ScanEvents("BossMod_Announce", spellId, text, icon, count)
      end
    elseif event == "BigWigs_Timer"
    or event == "BigWigs_TargetTimer"
    or event == "BigWigs_CastTimer"
    or event == "BigWigs_StartBreak"
    or event == "BigWigs_StartPull"
    then
      local addon, spellId, duration, _, text, count, icon, isCooldown, isBarEnabled, timerType
      if event == "BigWigs_Timer" then
        addon, spellId, duration, _, text, count, icon, isCooldown, isBarEnabled = ...
        timerType = "timer"
      elseif event == "BigWigs_TargetTimer" or event == "BigWigs_CastTimer" then
        addon, spellId, duration, _, text, count, icon, _, isBarEnabled = ...
        isCooldown = false
        timerType = "cast"
      elseif event == "BigWigs_StartBreak" then
        addon, duration, _, _, _, text, icon = ...
        text = text
        spellId = -1
        count = 0
        icon = icon
        isCooldown = false
        isBarEnabled = true
        timerType = "break"
      elseif event == "BigWigs_StartPull" then
        addon, duration, _, text, icon = ...
        text = text
        spellId = -2
        count = 0
        icon = 136116
        isCooldown = false
        isBarEnabled = true
        timerType = "pull"
      end
      local now = GetTime()
      local expirationTime = now + duration

      self.bars[text] = self.bars[text] or {}
      local bar = self.bars[text]
      bar.addon = addon
      bar.spellId = tostring(spellId)
      bar.name = text
      bar.text = text
      bar.duration = duration
      bar.expirationTime = expirationTime
      bar.icon = icon
      bar.isCooldown = isCooldown or false
      bar.expired = nil
      bar.timerType = timerType
      local BWColorModule = BigWigs:GetPlugin("Colors")
      bar.bwBarColor = BWColorModule:GetColorTable("barColor", addon, spellId)
      bar.bwTextColor = BWColorModule:GetColorTable("barText", addon, spellId)
      bar.bwBackgroundColor = BWColorModule:GetColorTable("barBackground", addon, spellId)
      bar.count = count or 0
      bar.isBarEnabled = isBarEnabled
      bar.cast = event == "BigWigs_CastTimer"

      Private.ScanEvents("BigWigs_StartBar", text)
      if self.isGeneric then
        Private.ScanEvents("BossMod_TimerStart", text)
      end
      if self.nextExpire == nil then
        self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, expirationTime - now, self)
        self.nextExpire = expirationTime
      elseif expirationTime < self.nextExpire then
        timer:CancelTimer(self.recheckTimer)
        self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, expirationTime - now, self)
        self.nextExpire = expirationTime
      end
    elseif event == "BigWigs_StopBar" then
      local addon, text = ...
      local bar = self.bars[text]
      if bar then
        if bar.scheduledScanExpireAt == nil or bar.scheduledScanExpireAt <= GetTime() then
          self.bars[text] = nil
        end
        Private.ScanEvents("BigWigs_StopBar", text)
        if self.isGeneric then
          Private.ScanEvents("BossMod_TimerStop", text)
        end
      end
    elseif event == "BigWigs_PauseBar" then
      local addon, text = ...
      local bar = self.bars[text]
      if bar and not bar.paused then
        bar.paused = true
        bar.remaining = bar.expirationTime - GetTime()
        Private.ScanEvents("BigWigs_PauseBar", text)
        if self.isGeneric then
          Private.ScanEvents("BossMod_TimerPause", text)
        end
        if self.recheckTimer then
          timer:CancelTimer(self.recheckTimer)
        end
        self:RecheckTimers()
      end
    elseif event == "BigWigs_ResumeBar" then
      local addon, text = ...
      local bar = self.bars[text]
      if bar and bar.paused then
        bar.paused = nil
        bar.expirationTime = GetTime() + (bar.remaining or 0)
        bar.remaining = nil
        Private.ScanEvents("BigWigs_ResumeBar", text)
        if self.isGeneric then
          Private.ScanEvents("BossMod_TimerResume", text)
        end
        if self.nextExpire == nil then
          self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, bar.expirationTime - GetTime(), self)
        elseif bar.expirationTime < self.nextExpire then
          timer:CancelTimer(self.recheckTimer)
          self.recheckTimer = timer:ScheduleTimerFixed(self.RecheckTimers, bar.expirationTime - GetTime(), self)
          self.nextExpire = bar.expirationTime
        end
      end
    elseif event == "BigWigs_StopBars"
    or event == "BigWigs_OnBossDisable"
    or event == "BigWigs_OnPluginDisable"
    then
      local addon = ...
      for timerId, bar in pairs(self.bars) do
        if bar.addon == addon then
          self.bars[timerId] = nil
          Private.ScanEvents("BigWigs_StopBar", timerId)
          if self.isGeneric then
            Private.ScanEvents("BossMod_TimerStop", timerId)
          end
        end
      end
    elseif event == "BigWigs_SetStage" then
      local addon, stage = ...
      self.currentStage = stage
      Private.ScanEvents("BigWigs_SetStage")
      if self.isGeneric then
        Private.ScanEvents("BossMod_SetStage")
      end
    elseif event == "BigWigs_OnBossWipe" or event == "BigWigs_OnBossWin" then
      self.currentStage = 0
      Private.ScanEvents("BigWigs_SetStage")
      if self.isGeneric then
        Private.ScanEvents("BossMod_SetStage")
      end
    end
  end,

  RegisterCallback = function(self, event)
    if self.registeredEvents[event] then
      return
    end
    if BigWigsLoader then
      BigWigsLoader.RegisterMessage(WeakAuras, event, function(...) self:EventCallback(...) end)
      self.registeredEvents[event] = true
      if event == "BigWigs_SetStage" then
        -- on init of BigWigs_SetStage callback, we want to fetch currentStage in case we are already in an encounter when this is run
        if BigWigs and BigWigs.IterateBossModules then
          local stage = 0
          for _, module in BigWigs:IterateBossModules() do
            if module:IsEngaged() then
              stage = math.max(stage, module:GetStage() or 1)
            end
          end
          self.currentStage = stage
        end
      end
    end
  end,

  RegisterTimer = function(self)
    self:RegisterCallback("BigWigs_Timer")
    self:RegisterCallback("BigWigs_TargetTimer")
    self:RegisterCallback("BigWigs_StartBreak")
    self:RegisterCallback("BigWigs_CastTimer")
    self:RegisterCallback("BigWigs_StopBar")
    self:RegisterCallback("BigWigs_StopBars")
    self:RegisterCallback("BigWigs_OnBossDisable")
    self:RegisterCallback("BigWigs_PauseBar")
    self:RegisterCallback("BigWigs_ResumeBar")
    self:RegisterCallback("BigWigs_StartPull")
  end,

  RegisterMessage = function(self)
    self:RegisterCallback("BigWigs_Message")
  end,

  RegisterStage = function(self)
    self:RegisterCallback("BigWigs_SetStage")
    self:RegisterCallback("BigWigs_OnBossWipe")
    self:RegisterCallback("BigWigs_OnBossWin")
  end,

  scheduled_scans = {},

  DoScan = function(self, fireTime)
    self.scheduled_scans[fireTime] = nil
    Private.ScanEvents("BigWigs_Timer_Update")
    if self.isGeneric then
      Private.ScanEvents("BossMod_TimerUpdate")
    end
  end,

  ScheduleCheck = function(self, fireTime)
    if not self.scheduled_scans[fireTime] then
      self.scheduled_scans[fireTime] = timer:ScheduleTimerFixed(self.DoScan, fireTime - GetTime(), self, fireTime)
    end
  end
}

if not WeakAuras.IsMistsOrRetail() then
  Private.event_prototypes["BigWigs Stage"] = {
    type = "addons",
    events = {},
    internal_events = {
      "BigWigs_SetStage"
    },
    name = L["BigWigs Stage"],
    init = function(trigger)
      Private.ExecEnv.BossMods.BigWigs:RegisterStage()
      return ""
    end,
    args = {
      {
        name = "stage",
        init = "Private.ExecEnv.BossMods.BigWigs:GetStage()",
        display = L["Stage"],
        type = "number",
        conditionType = "number",
        store = true,
      }
    },
    automaticrequired = true,
    statesParameter = "one",
    progressType = "none"
  }
  Private.category_event_prototype.addons["BigWigs Stage"] = L["BigWigs Stage"]

  Private.event_prototypes["BigWigs Message"] = {
    type = "addons",
    events = {},
    internal_events = {
      "BigWigs_Message"
    },
    name = L["BigWigs Message"],
    init = function(trigger)
      Private.ExecEnv.BossMods.BigWigs:RegisterMessage();
      local ret = "local use_cloneId = %s;"
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    statesParameter = "all",
    args = {
      {
        name = "addon",
        init = "arg",
        display = L["BigWigs Addon"],
        type = "string"
      },
      {
        name = "spellId",
        init = "arg",
        display = L["ID"],
        desc = L["The 'ID' value can be found in the BigWigs options of a specific spell"],
        type = "spell",
        conditionType = "string",
        noValidation = true,
        showExactOption = false,
        negativeIsEJ = true
      },
      {
        name = "text",
        init = "arg",
        display = L["Message"],
        type = "longstring",
        store = true,
        conditionType = "string"
      },
      {
        name = "name",
        init = "text",
        hidden = true,
        test = "true",
        store = true
      },
      {}, -- Importance, might be useful
      {
        name = "icon",
        init = "arg",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      },
    },
    timedrequired = true,
    progressType = "timed"
  }
  Private.category_event_prototype.addons["BigWigs Message"] = L["BigWigs Message"]

  Private.event_prototypes["BigWigs Timer"] = {
    type = "addons",
    events = {},
    internal_events = {
      "BigWigs_StartBar", "BigWigs_StopBar", "BigWigs_Timer_Update", "BigWigs_PauseBar", "BigWigs_ResumeBar"
    },
    force_events = "BigWigs_Timer_Force",
    name = L["BigWigs Timer"],
    progressType = "timed",
    triggerFunction = function(trigger)
      Private.ExecEnv.BossMods.BigWigs:RegisterTimer()
      local ret = [=[
        local triggerCounter = %q
        local counter
        if triggerCounter and triggerCounter ~= "" then
          counter = Private.ExecEnv.CreateTriggerCounter(triggerCounter)
        else
          counter = Private.ExecEnv.CreateTriggerCounter()
        end
        return function(states, event, timerId)
          local triggerSpellId = %q
          local triggerText = %q
          local triggerTextOperator = %q
          local useClone = %s
          local extendTimer = %s
          local triggerUseRemaining = %s
          local triggerRemaining = %s
          local triggerCast = %s
          local triggerIsCooldown = %s
          local isBarEnabled = %s
          local cloneId = useClone and timerId or ""
          local state = states[cloneId]
          local counter = counter

          function copyOrSchedule(bar, cloneId)
            local remainingTime
            local changed
            if bar.paused then
              remainingTime = bar.remaining + extendTimer
            else
              remainingTime = bar.expirationTime - GetTime() + extendTimer
            end
            if triggerUseRemaining then
              if remainingTime > 0 and remainingTime %s triggerRemaining then
                Private.ExecEnv.BossMods.BigWigs:CopyBarToState(bar, states, cloneId, extendTimer)
                changed = true
              else
                local state = states[cloneId]
                if state and state.show then
                  state.show = false
                  state.changed = true
                  changed = true
                end
              end
              if not bar.paused then
                if extendTimer > 0 then
                  bar.scheduledScanExpireAt = math.max(bar.scheduledScanExpireAt or 0, bar.expirationTime + extendTimer)
                end
                if remainingTime >= triggerRemaining then
                  Private.ExecEnv.BossMods.BigWigs:ScheduleCheck(bar.expirationTime - triggerRemaining + extendTimer)
                end
              end
            else
              if not bar.paused and extendTimer > 0 then
                bar.scheduledScanExpireAt = math.max(bar.scheduledScanExpireAt or 0, bar.expirationTime + extendTimer)
              end
              if remainingTime > 0 then
                Private.ExecEnv.BossMods.BigWigs:CopyBarToState(bar, states, cloneId, extendTimer)
                changed = true
              end
            end
            return changed
          end

          if useClone then
            if event == "BigWigs_StartBar"
            or event == "BigWigs_PauseBar"
            or event == "BigWigs_ResumeBar"
            then
              if Private.ExecEnv.BossMods.BigWigs:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerCast, triggerIsCooldown, isBarEnabled) then
                local bar = Private.ExecEnv.BossMods.BigWigs:GetTimerById(timerId)
                if bar then
                  return copyOrSchedule(bar, cloneId)
                end
              end
            elseif event == "BigWigs_StopBar" and state then
              local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
              if state.extend == 0 or bar_remainingTime <= 0 then
                state.show = false
                state.changed = true
                return true
              end
            elseif event == "BigWigs_Timer_Update" then
              local changed
              for timerId, bar in pairs(Private.ExecEnv.BossMods.BigWigs:GetAllTimers()) do
                if Private.ExecEnv.BossMods.BigWigs:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerCast, triggerIsCooldown, isBarEnabled) then
                  changed = copyOrSchedule(bar, timerId) or changed
                end
              end
              return changed
            elseif event == "BigWigs_Timer_Force" then
              local changed
              for _, state in pairs(states) do
                state.show = false
                state.changed = true
                changed = true
              end
              for timerId, bar in pairs(Private.ExecEnv.BossMods.BigWigs:GetAllTimers()) do
                if Private.ExecEnv.BossMods.BigWigs:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerCast, triggerIsCooldown, isBarEnabled) then
                  changed = copyOrSchedule(bar, timerId) or changed
                end
              end
              return changed
            end
          else
            if event == "BigWigs_StartBar" then
              if extendTimer ~= 0 then
                if Private.ExecEnv.BossMods.BigWigs:TimerMatches(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, triggerCast, triggerIsCooldown, isBarEnabled) then
                  local bar = Private.ExecEnv.BossMods.BigWigs:GetTimerById(timerId)
                  Private.ExecEnv.BossMods.BigWigs:ScheduleCheck(bar.expirationTime + extendTimer)
                end
              end
            end
            local bar = Private.ExecEnv.BossMods.BigWigs:GetTimer(triggerText, triggerTextOperator, triggerSpellId, extendTimer, counter, triggerCast, triggerIsCooldown, isBarEnabled)
            if bar then
              if extendTimer == 0
                or not (state and state.show)
                or (state and state.show and state.expirationTime > (bar.expirationTime + extendTimer))
              then
                return copyOrSchedule(bar, cloneId)
              end
            else
              if state and state.show then
                local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
                if state.extend == 0 or bar_remainingTime <= 0 then
                  state.show = false
                  state.changed = true
                  return true
                end
              end
            end
          end
        end
      ]=]
      return ret:format(
        trigger.use_count and trigger.count or "",
        trigger.use_spellId and tostring(trigger.spellId) or "",
        trigger.use_text and trigger.text or "",
        trigger.use_text and trigger.text_operator or "",
        trigger.use_cloneId and "true" or "false",
        trigger.use_extend and tonumber(trigger.extend or 0) or 0,
        trigger.use_remaining and "true" or "false",
        trigger.remaining and tonumber(trigger.remaining or 0) or 0,
        trigger.use_cast == nil and "nil" or trigger.use_cast and "true" or "false",
        trigger.use_isCooldown == nil and "nil" or trigger.use_isCooldown and "true" or "false",
        trigger.use_isBarEnabled == nil and "nil" or trigger.use_isBarEnabled and "true" or "false",
        trigger.remaining_operator or "<"
      )
    end,
    statesParameter = "full",
    args = {
      {
        name = "spellId",
        display = L["ID"],
        desc = L["The 'ID' value can be found in the BigWigs options of a specific spell"],
        type = "spell",
        conditionType = "string",
        noValidation = true,
        showExactOption = false,
        negativeIsEJ = true
      },
      {
        name = "text",
        display = L["Message"],
        type = "longstring",
        store = true,
        conditionType = "string"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
      },
      {
        name = "extend",
        display = L["Offset Timer"],
        type = "string",
      },
      {
        name = "count",
        display = L["Count"],
        desc = L["Occurrence of the event, reset when aura is unloaded\nCan be a range of values\nCan have multiple values separated by a comma or a space\n\nExamples:\n2nd 5th and 6th events: 2, 5, 6\n2nd to 6th: 2-6\nevery 2 events: /2\nevery 3 events starting from 2nd: 2/3\nevery 3 events starting from 2nd and ending at 11th: 2-11/3\n\nOnly if BigWigs shows it on it's bar"],
        type = "string",
        store = true,
        conditionType = "string",
        operator_types = "none",
        preamble = "local counter = Private.ExecEnv.CreateTriggerCounter(%q)",
        test = "counter:SetCount(tonumber(count) or 0) == nil and counter:Match()",
        conditionPreamble = function(input)
          return Private.ExecEnv.CreateTriggerCounter(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          preamble:SetCount(tonumber(state.count) or 0)
          return preamble:Match()
        end,
      },
      {
        name = "cast",
        display = L["Cast Bar"],
        desc = L["Filter messages with format <message>"],
        type = "tristate",
        test = "true",
        init = "false",
        conditionType = "bool"
      },
      {
        name = "isCooldown",
        display = L["Cooldown"],
        desc = L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"],
        type = "tristate",
        test = "true",
        init = "false",
        conditionType = "bool"
      },
      {
        name = "isBarEnabled",
        display = L["Bar enabled in BigWigs settings"],
        desc = L["Test if bar is enabled in BigWigs settings"],
        type = "tristate",
        test = "true",
        init = "false",
        conditionType = "bool"
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "false"
      },
    },
    automaticrequired = true,
  }
  Private.category_event_prototype.addons["BigWigs Timer"] = L["BigWigs Timer"]
end

-- Unified
if BigWigsLoader or not DBM then
  Private.ExecEnv.BossMods.Generic = Private.ExecEnv.BossMods.BigWigs
  Private.ExecEnv.BossMods.BigWigs.isGeneric = true
  Private.ExecEnv.BossMods.BigWigs.isInstalled = BigWigsLoader ~= nil
elseif DBM then
  Private.ExecEnv.BossMods.Generic = Private.ExecEnv.BossMods.DBM
  Private.ExecEnv.BossMods.DBM.isGeneric = true
  Private.ExecEnv.BossMods.DBM.isInstalled = true
end

local ActiveBossModText
if Private.ExecEnv.BossMods.BigWigs.isInstalled then
  ActiveBossModText = L["Active boss mod addon: |cFFffcc00BigWigs|r\n\nNote: This trigger will use BigWigs or DBM, in that order if both are installed."]
elseif Private.ExecEnv.BossMods.DBM.isInstalled then
  ActiveBossModText = L["Active boss mod addon: |cFFffcc00DBM|r\n\nNote: This trigger will use BigWigs or DBM, in that order if both are installed."]
else
  ActiveBossModText = L["No active boss mod addon detected.\n\nNote: This trigger will use BigWigs or DBM, in that order if both are installed."]
end

Private.event_prototypes["Boss Mod Stage"] = {
  type = "addons",
  events = {},
  internal_events = {
    "BossMod_SetStage"
  },
  force_events = "BossMod_SetStage",
  name = L["Boss Mod Stage"],
  init = function(trigger)
    Private.ExecEnv.BossMods.Generic:RegisterStage()
    return ""
  end,
  args = {
    {
      name = "stage",
      init = "Private.ExecEnv.BossMods.Generic:GetStage()",
      display = L["Stage"],
      type = "number",
      conditionType = "number",
      store = true,
    },
    {
      name = "note",
      type = "description",
      display = "",
      text = ActiveBossModText
    },
  },
  automaticrequired = true,
  statesParameter = "one",
  progressType = "none"
}
Private.category_event_prototype.addons["Boss Mod Stage"] = L["Boss Mod Stage"]

Private.event_prototypes["Boss Mod Stage (Event)"] = {
  type = "event",
  events = {
    ["events"] = {
      "BossMod_SetStage",
    }
  },
  name = L["Boss Mod Stage (Event)"],
  init = function(trigger)
    Private.ExecEnv.BossMods.Generic:RegisterStage()
    return ""
  end,
  args = {
    {
      name = "stage",
      init = "Private.ExecEnv.BossMods.Generic:GetStage()",
      display = L["Stage"],
      type = "number",
      conditionType = "number",
      store = true,
    },
    {
      name = "note",
      type = "description",
      display = "",
      text = ActiveBossModText
    },
  },
  statesParameter = "one",
  progressType = "timed",
  delayEvents = true,
  timedrequired = true
}
Private.category_event_prototype.addons["Boss Mod Stage (Event)"] = L["Boss Mod Stage (Event)"]

Private.event_prototypes["Boss Mod Announce"] = {
  type = "addons",
  events = {},
  internal_events = {
    "BossMod_Announce"
  },
  name = L["Boss Mod Announce"],
  init = function(trigger)
    Private.ExecEnv.BossMods.Generic:RegisterMessage();
    local ret = "local use_cloneId = %s;"
    return ret:format(trigger.use_cloneId and "true" or "false");
  end,
  statesParameter = "all",
  args = {
    {
      name = "spellId",
      init = "arg",
      display = L["ID"],
      store = true,
      type = "spell",
      conditionType = "string",
      noValidation = true,
      showExactOption = false,
      negativeIsEJ = true
    },
    {
      name = "message",
      init = "arg",
      display = L["Message"],
      type = "longstring",
      store = true,
      conditionType = "string"
    },
    {
      name = "name",
      init = "message",
      hidden = true,
      test = "true",
      store = true,
    },
    {
      name = "icon",
      init = "arg",
      store = true,
      hidden = true,
      test = "true"
    },
    {
      name = "count",
      init = "arg",
      display = L["Count"],
      desc = L["Occurrence of the event\nCan be a range of values\nCan have multiple values separated by a comma or a space\n\nExamples:\n2nd 5th and 6th events: 2, 5, 6\n2nd to 6th: 2-6\nevery 2 events: /2\nevery 3 events starting from 2nd: 2/3\nevery 3 events starting from 2nd and ending at 11th: 2-11/3\n\nWorks only if Boss Mod addon show counter"],
      type = "string",
      store = true,
      conditionType = "string",
      operator_types = "none",
      preamble = "local counter = Private.ExecEnv.CreateTriggerCounter(%q)",
      test = "counter:SetCount(tonumber(count) or 0) == nil and counter:Match()",
      conditionPreamble = function(input)
        return Private.ExecEnv.CreateTriggerCounter(input)
      end,
      conditionTest = function(state, needle, op, preamble)
        preamble:SetCount(tonumber(state.count) or 0)
        return preamble:Match()
      end,
    },
    {
      name = "cloneId",
      display = L["Clone per Event"],
      type = "toggle",
      test = "true",
      init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
    },
    {
      name = "note",
      type = "description",
      display = "",
      text = ActiveBossModText
    },
  },
  timedrequired = true,
  progressType = "timed"
}
Private.category_event_prototype.addons["Boss Mod Announce"] = L["Boss Mod Announce"]

Private.event_prototypes["Boss Mod Timer"] = {
  type = "addons",
  events = {},
  internal_events = {
    "BossMod_TimerStart", "BossMod_TimerStop", "BossMod_TimerUpdate", "BossMod_TimerForce", "BossMod_TimerResume",
    "BossMod_TimerPause", "BossMod_TimerUpdateIcon"
  },
  force_events = "BossMod_TimerForce",
  name = L["Boss Mod Timer"],
  progressType = "timed",
  triggerFunction = function(trigger)
    Private.ExecEnv.BossMods.Generic:RegisterTimer()
    local ret = [=[
      local triggerCounter = %q
      local counter
      if triggerCounter and triggerCounter ~= "" then
        counter = Private.ExecEnv.CreateTriggerCounter(triggerCounter)
      else
        counter = Private.ExecEnv.CreateTriggerCounter()
      end
      local isBW = Private.ExecEnv.BossMods.Generic == Private.ExecEnv.BossMods.BigWigs
      local isDBM = Private.ExecEnv.BossMods.Generic == Private.ExecEnv.BossMods.DBM

      return function (states, event, timerId)
        local isPullTimer = %s
        local isBreakTimer = %s
        local isTimer = %s
        local triggerSpellId = %q
        local triggerText = %q
        local triggerTextOperator = %q
        local useClone = %s
        local extendTimer = %s
        local triggerUseRemaining = %s
        local triggerRemaining = %s
        local isBarEnabled = %s
        local cloneId = useClone and timerId or ""
        local state = states[cloneId]
        local counter = counter

        function copyOrSchedule(bar, cloneId)
          local remainingTime
          local changed
          if bar.paused then
            remainingTime = bar.remaining + extendTimer
          else
            remainingTime = bar.expirationTime - GetTime() + extendTimer
          end
          if triggerUseRemaining then
            if remainingTime > 0 and remainingTime %s triggerRemaining then
              Private.ExecEnv.BossMods.Generic:CopyBarToState(bar, states, cloneId, extendTimer)
              changed = true
            else
              local state = states[cloneId]
              if state and state.show then
                state.show = false
                state.changed = true
                changed = true
              end
            end
            if not bar.paused then
              if extendTimer > 0 then
                bar.scheduledScanExpireAt = math.max(bar.scheduledScanExpireAt or 0, bar.expirationTime + extendTimer)
              end
              if remainingTime >= triggerRemaining  then
                Private.ExecEnv.BossMods.Generic:ScheduleCheck(bar.expirationTime - triggerRemaining + extendTimer)
              end
            end
          else
            if not bar.paused and extendTimer > 0 then
              bar.scheduledScanExpireAt = math.max(bar.scheduledScanExpireAt or 0, bar.expirationTime + extendTimer)
            end
            if remainingTime > 0 then
              Private.ExecEnv.BossMods.Generic:CopyBarToState(bar, states, cloneId, extendTimer)
              changed = true
            end
          end
          return changed
        end

        if useClone then
          if event == "BossMod_TimerStart"
          or event == "BossMod_TimerPause"
          or event == "BossMod_TimerResume"
          then
            if Private.ExecEnv.BossMods.Generic:TimerMatchesGeneric(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer) then
              local bar = Private.ExecEnv.BossMods.Generic:GetTimerById(timerId)
              if bar then
                return copyOrSchedule(bar, cloneId)
              end
            end
          elseif event == "BossMod_TimerStop" and state then
            local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
            if state.extend == 0 or bar_remainingTime <= 0 then
              state.show = false
              state.changed = true
              return true
            end
          elseif event == "BossMod_TimerUpdate" or event == "BossMod_TimerUpdateIcon" then
            local changed
            for timerId, bar in pairs(Private.ExecEnv.BossMods.Generic:GetAllTimers()) do
              if Private.ExecEnv.BossMods.Generic:TimerMatchesGeneric(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer) then
                changed = copyOrSchedule(bar, timerId) or changed
              else
                local state = states[timerId]
                if state then
                  local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
                  if state.extend == 0 or bar_remainingTime <= 0 then
                    state.show = false
                    state.changed = true
                    changed = true
                  end
                end
              end
            end
            return changed
          elseif event == "BossMod_TimerForce" then
            local changed
            for _, state in pairs(states) do
              state.show = false
              state.changed = true
              changed = true
            end
            for timerId, bar in pairs(Private.ExecEnv.BossMods.Generic:GetAllTimers()) do
              if Private.ExecEnv.BossMods.Generic:TimerMatchesGeneric(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer) then
                changed = copyOrSchedule(bar, timerId) or changed
              end
            end
            return changed
          end
        else
          if event == "BossMod_TimerStart" or event == "BossMod_TimerUpdate" then
            if extendTimer ~= 0 then
              if Private.ExecEnv.BossMods.Generic:TimerMatchesGeneric(timerId, triggerText, triggerTextOperator, triggerSpellId, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer) then
                local bar = Private.ExecEnv.BossMods.Generic:GetTimerById(timerId)
                Private.ExecEnv.BossMods.Generic:ScheduleCheck(bar.expirationTime + extendTimer)
              end
            end
          end
          local bar = Private.ExecEnv.BossMods.Generic:GetTimerGeneric(triggerText, triggerTextOperator, triggerSpellId, extendTimer, counter, isBarEnabled, isPullTimer, isBreakTimer, isTimer)
          if bar then
            if extendTimer == 0
              or not (state and state.show)
              or (state and state.show and state.expirationTime > (bar.expirationTime + extendTimer))
            then
              return copyOrSchedule(bar, cloneId)
            end
          else
            if state and state.show then
              local bar_remainingTime = state.expirationTime - GetTime() + (state.extend or 0)
              if state.extend == 0 or bar_remainingTime <= 0 then
                state.show = false
                state.changed = true
                return true
              end
            end
          end
        end
      end
      ]=]

    return ret:format(
      trigger.use_count and trigger.count or "",
      TestForMultiSelect(trigger, "timerType", "PULL"),
      TestForMultiSelect(trigger, "timerType", "BREAK"),
      TestForMultiSelect(trigger, "timerType", "TIMER"),
      trigger.use_spellId and tostring(trigger.spellId) or "",
      trigger.use_message and trigger.message or "",
      trigger.use_message and trigger.message_operator or "",
      trigger.use_cloneId and "true" or "false",
      trigger.use_extend and tonumber(trigger.extend or 0) or 0,
      trigger.use_remaining and "true" or "false",
      trigger.remaining and tonumber(trigger.remaining or 0) or 0,
      trigger.use_isBarEnabled == nil and "nil" or trigger.use_isBarEnabled and "true" or "false",
      trigger.remaining_operator or "<"
    )
  end,
  statesParameter = "full",
  args = {
    {
      name = "spellId",
      display = L["ID"],
      store = true,
      type = "spell",
      conditionType = "string",
      noValidation = true,
      showExactOption = false,
      negativeIsEJ = true
    },
    {
      name = "message",
      display = L["Message"],
      type = "longstring",
      store = true,
      conditionType = "string"
    },
    {
      name = "timerType",
      desc = L["Select the type of timer to filter"],
      display = L["Bar Type"],
      type = "multiselect",
      values = "bossmods_timerTypes"
    },
    {
      name = "remaining",
      display = L["Remaining Time"],
      type = "number",
    },
    {
      name = "extend",
      display = L["Offset Timer"],
      type = "string",
    },
    {
      name = "count",
      display = L["Count"],
      desc = L["Occurrence of the event, reset when aura is unloaded\nCan be a range of values\nCan have multiple values separated by a comma or a space\n\nExamples:\n2nd 5th and 6th events: 2, 5, 6\n2nd to 6th: 2-6\nevery 2 events: /2\nevery 3 events starting from 2nd: 2/3\nevery 3 events starting from 2nd and ending at 11th: 2-11/3\n\nOnly if DBM shows it on it's bar"],
      type = "string",
      conditionType = "string",
      operator_types = "none",
      preamble = "local counter = Private.ExecEnv.CreateTriggerCounter(%q)",
      test = "counter:SetCount(tonumber(count) or 0) == nil and counter:Match()",
      conditionPreamble = function(input)
        return Private.ExecEnv.CreateTriggerCounter(input)
      end,
      conditionTest = function(state, needle, op, preamble)
        preamble:SetCount(tonumber(state.count) or 0)
        return preamble:Match()
      end,
      store = true,
    },
    {
      name = "isBarEnabled",
      display = L["Bar enabled in Boss Mod addon settings"],
      desc = L["Test if bar is enabled in Boss Mod addon settings"],
      type = "tristate",
      test = "true",
      init = "false",
      conditionType = "bool",
    },
    {
      name = "cloneId",
      display = L["Clone per Event"],
      type = "toggle"
    },
    {
      name = "note",
      type = "description",
      display = "",
      text = ActiveBossModText
    },
  },
  automaticrequired = true,
}
Private.category_event_prototype.addons["Boss Mod Timer"] = L["Boss Mod Timer"]




-- ========================================
-- File: WeakAuras/BuffTrigger2.lua
-- ========================================

--[=[ BuffTrigger2.lua
This file contains the "aura2" trigger for buffs and debuffs. It has replaced the older Bufftrigger 1, which is now gone.

It registers the BuffTrigger table for the trigger type "aura2" and has the following API:

Add(data)
Adds an aura, setting up internal data structures for all buff triggers.

LoadDisplays(id)
Loads the aura ids, enabling all buff triggers in the aura.

UnloadDisplays(id)
Unloads the aura ids, disabling all buff triggers in the aura.

UnloadAll()
Unloads all auras, disabling all buff triggers.

Delete(id)
Removes all data for aura id.

Rename(oldid, newid)
Updates all data for aura oldid to use newid.

Modernize(data)
Updates all buff triggers in data.

#####################################################
# Helper functions mainly for the WeakAuras Options #
#####################################################

GetOverlayInfo(data, triggernum)
Returns a table containing all overlays. Currently there aren't any

CanHaveTooltip(data, triggernum)
Returns the type of tooltip to show for the trigger.

GetNameAndIcon(data, triggernum)
Returns the name and icon to show in the options.

GetAdditionalProperties(data, triggernum)
Returns the tooltip text for additional properties.

GetTriggerConditions(data, triggernum)
Returns the potential conditions for a trigger
]=]--
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local FixDebuffClass
if WeakAuras.IsRetail() then
  local LibDispell = LibStub("LibDispel-1.0")
  FixDebuffClass = function(debuffClass, spellId)
    if debuffClass == nil then
      local bleedList = LibDispell:GetBleedList()
      if bleedList[spellId] then
        debuffClass = "bleed"
      else
        debuffClass = "none"
      end
    elseif debuffClass == "" then
      debuffClass = "enrage"
    else
      debuffClass = string.lower(debuffClass)
    end
    return debuffClass
  end
else
  FixDebuffClass = function(debuffClass)
    if debuffClass == nil then
      debuffClass = "none"
    elseif debuffClass == "" then
      debuffClass = "enrage"
    else
      debuffClass = string.lower(debuffClass)
    end
    return debuffClass
  end
end


-- Lua APIs
local tinsert, wipe = table.insert, wipe
local pairs, next, type = pairs, next, type
local UnitAura = UnitAura

local newAPI = WeakAuras.IsRetail()

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L
local timer = WeakAuras.timer
local BuffTrigger = {}
local triggerInfos = {}

local watched_trigger_events = Private.watched_trigger_events

-- Active scan functions used to quickly check which apply to a aura instance
-- keyed on unit, debuffType, spellname, with a scan object value
local scanFuncName = {}
local scanFuncSpellId = {}
local scanFuncGeneral = {}

-- same as above but for group triggers
local scanFuncNameGroup = {}
local scanFuncSpellIdGroup = {}
local scanFuncGeneralGroup = {}

-- Contains all scanFuncs that should be check if the existence of a unit changed
local unitExistScanFunc = {}
-- Which units exist, actually contains the GUID for the unit
local existingUnits = {}

-- Contains all scanFuncs that fetch the role + roleIcon
local groupRoleScanFunc = {}

-- Loaded ScanFuncs per unit type
local groupScanFuncs = {}
--Active ScanFuncs per actual unit id
local activeGroupScanFuncs = {}

local raidMarkScanFuncs = {}

local rangeScanFuncs = {}

-- Multi Target tracking
local scanFuncNameMulti = {}
local scanFuncSpellIdMulti = {}
local cleanupTimerMulti = {}

-- Auras that matched, unit, index
local matchData = {}

local matchDataUpToDate = {}

local matchDataMulti = {}
-- Auras that matched, keyed on id, triggernum, kept in sync with matchData
local matchDataByTrigger = {}

local matchDataChanged = {}

local nameplateExists = {}
local unitVisible = {}

-- Returns whether a unit id exists. If it exists, the GUID is returned
-- Otherwise false
-- Work around a issue where UnitExists returns true for nameplates even
-- if the nameplate doesn't exist anymore
local function UnitExistsFixed(unit)
  if #unit > 9 and unit:sub(1, 9) == "nameplate" then
    return nameplateExists[unit] or false
  end
  return UnitExists(unit) and UnitGUID(unit) or false
end

local function UnitIsVisibleFixed(unit)
  if unitVisible[unit] == nil then
    unitVisible[unit] = UnitIsVisible(unit)
  end
  return unitVisible[unit]
end

local function UnitInRangeFixed(unit)
  local inRange, checked = UnitInRange(unit)
  return inRange or not checked
end

Private.ExecEnv.UnitInRangeFixed = UnitInRangeFixed

local function UnitInSubgroupOrPlayer(unit, includePets)
  if includePets == nil then
    return UnitInSubgroup(unit) or UnitIsUnit("player", unit)
  elseif includePets == "PlayersAndPets" then
    return UnitInSubgroup(WeakAuras.petUnitToUnit[unit] or unit) or UnitIsUnit("player", unit) or UnitIsUnit("pet", unit)
  elseif includePets == "PetsOnly" then
    return UnitInSubgroup(WeakAuras.petUnitToUnit[unit]) or UnitIsUnit("pet", unit)
  end
end

local function GetOrCreateSubTable(base, next, ...)
  if not next then
    return base
  end

  base[next] = base[next] or {}
  return GetOrCreateSubTable(base[next], ...)
end

local function GetSubTable(base, next, ...)
  if not base then
    return nil
  end

  if not next then
    return base
  end

  return GetSubTable(base[next], ...)
end

local function IsGroupTrigger(trigger)
  return trigger.unit == "group" or trigger.unit == "party" or trigger.unit == "raid"
         or trigger.unit == "boss" or trigger.unit == "nameplate" or trigger.unit == "arena" or trigger.unit == "multi"
end

local function IsSingleMissing(trigger)
  return not IsGroupTrigger(trigger) and trigger.matchesShowOn == "showOnMissing"
end

local function CanHaveMatchCheck(trigger)
  if IsGroupTrigger(trigger) then
    return true
  end
  if trigger.matchesShowOn == "showOnMissing" then
    return false
  end
  if trigger.matchesShowOn == "showOnActive" or trigger.matchesShowOn == "showOnMatches" or not trigger.matchesShowOn then
    return true
  end
  -- Always: If clones are shown
  return trigger.showClones
end

local function HasMatchCount(trigger)
  if IsGroupTrigger(trigger) then
    return trigger.useMatch_count
  else
    return trigger.matchesShowOn == "showOnMatches"
  end
end

local function ReferenceMatchData(id, triggernum, unit, filter, index)
  local match = matchData[unit][filter][index]
  local base = GetOrCreateSubTable(matchDataByTrigger, id, triggernum, unit)

  base[index] = match

  match.auras[id] = match.auras[id] or {}
  match.auras[id][triggernum] = true
end

local function ScanMatchData(time, triggerInfo, unit, filter)
  if matchData[unit] and matchData[unit][filter] then
    for index, match in pairs(matchData[unit][filter]) do
      if (not triggerInfo.auranames and not triggerInfo.auraspellids)
          or (triggerInfo.auranames and tContains(triggerInfo.auranames, match.name))
          or (triggerInfo.auraspellids and tContains(triggerInfo.auraspellids, match.spellId)) then
        if triggerInfo.fetchTooltip then
          matchData[unit][filter][index]:UpdateTooltip(time)
        end
        if not triggerInfo.scanFunc or triggerInfo.scanFunc(time, matchData[unit][filter][index]) then
          local id = triggerInfo.id
          local triggernum = triggerInfo.triggernum
          ReferenceMatchData(id, triggernum, unit, filter, index)
          matchDataChanged[id] = matchDataChanged[id] or {}
          matchDataChanged[id][triggernum] = true
        end
      end
    end
  end
end

local function ReferenceMatchDataMulti(matchData, id, triggernum, destGUID)
  local needToInsert = false

  matchData.auras[id] = matchData.auras[id] or {}
  needToInsert = not matchData.auras[id][triggernum]
  matchData.auras[id][triggernum] = true

  if needToInsert then
    local matchDataByTriggerBase = GetOrCreateSubTable(matchDataByTrigger, id, triggernum, destGUID)
    tinsert(matchDataByTriggerBase, matchData)
  end
  matchDataChanged[id] = matchDataChanged[id] or {}
  matchDataChanged[id][triggernum] = true
end

local function MatchesTriggerInfoMulti(triggerInfo, sourceGUID)
  if triggerInfo.ownOnly then
    return sourceGUID == UnitGUID("player") or sourceGUID == UnitGUID("pet")
  elseif triggerInfo.ownOnly == false then
    return sourceGUID ~= UnitGUID("player") and sourceGUID ~= UnitGUID("pet")
  else
    return true
  end
end

local function CheckScanFuncs(scanFuncs, unit, filter, key)
  if scanFuncs then
    for triggerInfo in pairs(scanFuncs) do
      if triggerInfo.fetchTooltip then
        local md = matchData[unit][filter][key]
        md:UpdateTooltip(GetTime())
      end
      if not triggerInfo.scanFunc or triggerInfo.scanFunc(time, matchData[unit][filter][key]) then
        local id = triggerInfo.id
        local triggernum = triggerInfo.triggernum
        ReferenceMatchData(id, triggernum, unit, filter, key)
        matchDataChanged[id] = matchDataChanged[id] or {}
        matchDataChanged[id][triggernum] = true
      end
    end
  end
end

local TooltipHelper
if newAPI then
  ---@class TooltipHelper
  ---@field count number
  ---@field tracks table<string, table<fun(data: any), any>>
  TooltipHelper = {
    count = 0,
    frame = CreateFrame("Frame"),
    tracks = {

    },
    --- @type fun(self: TooltipHelper, dataInstanceId: number, matchData: table)
    Track = function(self, dataInstanceID, matchData)
      self.tracks[dataInstanceID] = self.tracks[dataInstanceID] or {}
      if not self.tracks[dataInstanceID][matchData] then
        self.count = self.count + 1
        self.tracks[dataInstanceID][matchData] = true
        if self.count == 1 then
          self.frame:RegisterEvent("TOOLTIP_DATA_UPDATE")
        end
      end
    end,
    --- @type fun(self: TooltipHelper, dataInstanceId: number, matchData: table)
    Untrack = function(self, dataInstanceID, matchData)
      if self.tracks[dataInstanceID] then
        if self.tracks[dataInstanceID][matchData] then
          self.count = self.count - 1
          self.tracks[dataInstanceID][matchData] = nil
          if not next(self.tracks[dataInstanceID]) then
            self.tracks[dataInstanceID] = nil
          end
          if self.count == 0 then
            self.frame:UnregisterEvent("TOOLTIP_DATA_UPDATE")
          end
        end
      end
    end,
    --- @type fun(self: TooltipHelper)
    Clear = function(self)
      self.tracks = {}
      self.frame:UnregisterEvent("TOOLTIP_DATA_UPDATE")
      self.count = 0
    end,

    --- @type fun(self: TooltipHelper, matchData: table)
    HandleMatchData = function(self, matchData)
      if matchData:UpdateTooltip(GetTime()) then
        local unit = matchData.unit
        local key = matchData.auraInstanceID
        local filter = matchData.filter
        for id, triggerData in pairs(matchData.auras) do
          for triggernum in pairs(triggerData) do
            local matchDataByTriggerAndUnit = GetSubTable(matchDataByTrigger, id, triggernum, unit)
            if matchDataByTriggerAndUnit and matchDataByTriggerAndUnit[key] then
              matchDataByTriggerAndUnit[key] = nil
              matchDataChanged[id] = matchDataChanged[id] or {}
              matchDataChanged[id][triggernum] = true
            end
          end
        end
        wipe(matchData.auras)

        local sfn = GetSubTable(scanFuncName, unit, filter, matchData.name)
        local sfng = GetSubTable(scanFuncNameGroup, unit, filter, matchData.name)
        local sfs = GetSubTable(scanFuncSpellId, unit, filter, matchData.spellId)
        local sfsg = GetSubTable(scanFuncSpellIdGroup, unit, filter, matchData.spellId)
        local sfg = GetSubTable(scanFuncGeneral, unit, filter)
        local sfgg = GetSubTable(scanFuncGeneralGroup, unit, filter)

        CheckScanFuncs(sfn, unit, filter, key)
        CheckScanFuncs(sfng, unit, filter, key)
        CheckScanFuncs(sfs, unit, filter, key)
        CheckScanFuncs(sfsg, unit, filter, key)
        CheckScanFuncs(sfg, unit, filter, key)
        CheckScanFuncs(sfgg, unit, filter, key)
      end
    end,

    --- @type fun(self: TooltipHelper, dataInstanceID: number)
    HandleEvent = function(self, dataInstanceID)
      if self.tracks[dataInstanceID] then
        for callbackData in pairs(self.tracks[dataInstanceID]) do
          self:HandleMatchData(callbackData)
        end
      end
    end
  }

  TooltipHelper.frame:SetScript("OnEvent", function(frame, event, dataInstanceID)
    TooltipHelper:HandleEvent(dataInstanceID)
  end)
end

local function UpdateToolTipDataInMatchData(matchData, time)
  if matchData.tooltipUpdated == time then
    return
  end
  local changed = false

  if matchData.unit and matchData.auraInstanceID then
    local dataInstanceID, tooltip, _, tooltip1, tooltip2, tooltip3, tooltip4 = WeakAuras.GetAuraInstanceTooltipInfo(matchData.unit, matchData.auraInstanceID, matchData.filter)
    changed = matchData.tooltip ~= tooltip or matchData.tooltip1 ~= tooltip1
      or matchData.tooltip2 ~= tooltip2 or matchData.tooltip3 ~= tooltip3 or matchData.tooltip4 ~= tooltip4
    matchData.tooltip, matchData.tooltip1, matchData.tooltip2, matchData.tooltip3, matchData.tooltip4 = tooltip, tooltip1, tooltip2, tooltip3, tooltip4

    local oldDataInstanceId = matchData.dataInstanceID
    matchData.dataInstanceID = dataInstanceID
    if dataInstanceID ~= oldDataInstanceId then
      if dataInstanceID then
        TooltipHelper:Track(dataInstanceID, matchData)
      end
      if oldDataInstanceId then
        TooltipHelper:Untrack(oldDataInstanceId, matchData)
      end
    end
  elseif matchData.unit and matchData.index and matchData.filter then
    local tooltip, _, tooltip1, tooltip2, tooltip3, tooltip4 = WeakAuras.GetAuraTooltipInfo(matchData.unit, matchData.index, matchData.filter)
    changed = matchData.tooltip ~= tooltip or matchData.tooltip1 ~= tooltip1
      or matchData.tooltip2 ~= tooltip2 or matchData.tooltip3 ~= tooltip3 or matchData.tooltip4 ~= tooltip4
    matchData.tooltip, matchData.tooltip1, matchData.tooltip2, matchData.tooltip3, matchData.tooltip4 = tooltip, tooltip1, tooltip2, tooltip3, tooltip4
  end

  matchData.tooltipUpdated = time
  return changed
end

--- Compares two arrays (shallow)
---@param t1 any[]?
---@param t2 any[]?
---@return boolean
local function ArrayCompare(t1, t2)
  if t1 == nil then
    return t2 == nil
  end
  if t2 == nil then
    return false
  end
  if #t1 ~= #t2 then
    return false
  end
  for i = 1, #t1 do
    if t1[i] ~= t2[i] then
      return false
    end
  end
  return true
end

local function UpdateMatchData(time, matchDataChanged, unit, index, auraInstanceID, filter, name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, isBossDebuff, isCastByPlayer, spellId, modRate, points)
  if not matchData[unit] then
    matchData[unit] = {}
  end
  if not matchData[unit][filter] then
    matchData[unit][filter] = {}
  end
  local key = index or auraInstanceID
  local debuffClassIcon = WeakAuras.EJIcons[debuffClass]
  if not matchData[unit][filter][key] then
    matchData[unit][filter][key] = {
      name = name,
      icon = icon,
      stacks = stacks,
      debuffClass = debuffClass,
      debuffClassIcon = debuffClassIcon,
      duration = duration,
      expirationTime = expirationTime,
      modRate = modRate,
      unitCaster = unitCaster,
      casterName = unitCaster and GetUnitName(unitCaster, false) or "",
      spellId = spellId,
      unit = unit,
      unitName = GetUnitName(unit, false) or "",
      isStealable = isStealable,
      isBossDebuff = isBossDebuff,
      isCastByPlayer = isCastByPlayer,
      time = time,
      lastChanged = time,
      filter = filter,
      index = index,
      points = points,
      auraInstanceID = auraInstanceID,
      UpdateTooltip = UpdateToolTipDataInMatchData,
      auras = {}
    }

    return true
  end

  local data = matchData[unit][filter][key]
  local changed = false

  if data.name ~= name then
    data.name = name
    changed = true
  end

  if data.icon ~= icon then
    data.icon = icon
    changed = true
  end

  if data.stacks ~= stacks then
    data.stacks = stacks
    changed = true
  end

  if data.debuffClass ~= debuffClass then
    data.debuffClass = debuffClass
    changed = true
  end

  if data.debuffClassIcon ~= debuffClassIcon then
    data.debuffClassIcon = debuffClassIcon
    changed = true
  end

  if data.duration ~= duration then
    data.duration = duration
    changed = true
  end

  if data.expirationTime ~= expirationTime then
    data.expirationTime = expirationTime
    changed = true
  end

  if data.modRate ~= modRate then
    data.modRate = modRate
    changed = true
  end

  if data.unitCaster ~= unitCaster then
    data.unitCaster = unitCaster
    changed = true
  end

  local casterName = unitCaster and GetUnitName(unitCaster, false) or ""
  if data.casterName ~= casterName then
    data.casterName = casterName
    changed = true
  end

  if data.spellId ~= spellId then
    data.spellId = spellId
    changed = true
  end

  if data.isStealable ~= isStealable then
    data.isStealable = isStealable
    changed = true
  end

  if data.isBossDebuff ~= isBossDebuff then
    data.isBossDebuff = isBossDebuff
    changed = true
  end

  if data.isCastByPlayer ~= isCastByPlayer then
    data.isCastByPlayer = isCastByPlayer
    changed = true
  end

  local unitName = GetUnitName(unit, false) or ""
  if data.unitName ~= unitName then
    data.unitName = unitName
    changed = true
  end

  if data.tooltipUpdated and data.tooltipUpdated < time then
    changed = data:UpdateTooltip(time) or changed
  end

  if not ArrayCompare(points, data.points) then
    data.points = points
    changed = true
  end

  if changed then
    data.lastChanged = time
  end

  if changed then
    -- Tell old auras that used this match data
    for id, triggerData in pairs(data.auras) do
      for triggernum in pairs(triggerData) do
        if matchDataByTrigger[id]
          and matchDataByTrigger[id][triggernum]
          and matchDataByTrigger[id][triggernum][unit]
          and matchDataByTrigger[id][triggernum][unit][key]
        then
          matchDataByTrigger[id][triggernum][unit][key] = nil
          matchDataChanged[id] = matchDataChanged[id] or {}
          matchDataChanged[id][triggernum] = true
        end
      end
    end
    wipe(data.auras)
  end

  data.index = index
  data.auraInstanceID = auraInstanceID
  data.time = time
  data.unit = unit

  return changed or data.lastChanged == time
end

local function calculateNextCheck(triggerInfoRemaining, auraDataRemaining, auraDataExpirationTime, modRate, nextCheck)
  if auraDataRemaining > 0 and auraDataRemaining >= triggerInfoRemaining then
    if not nextCheck then
      return auraDataExpirationTime - triggerInfoRemaining * modRate
    else
      return min(auraDataExpirationTime - triggerInfoRemaining * modRate, nextCheck)
    end
  end
  return nextCheck
end

local function FindBestMatchData(time, id, triggernum, triggerInfo, matchedUnits)
  -- Find best match
  local bestMatch = nil
  local matchCount = 0
  local unitCount = 0
  local stackCount = 0
  local nextCheck

  if not matchDataByTrigger[id] or not matchDataByTrigger[id][triggernum] then
    return nil, 0, 0
  end

  for unit, unitData in pairs(matchDataByTrigger[id][triggernum]) do
    local unitCounted = false
    for index, auraData in pairs(unitData) do
      local remCheck = true
      if triggerInfo.remainingFunc and auraData.expirationTime then
        if auraData.duration == 0 then
          remCheck = false
        else
          local modRate = auraData.modRate or 1
          local remaining = (auraData.expirationTime - time) / modRate
          remCheck = triggerInfo.remainingFunc(remaining)
          nextCheck = calculateNextCheck(triggerInfo.remainingCheck, remaining, auraData.expirationTime, modRate, nextCheck)
        end
      end

      if remCheck then
        matchCount = matchCount + 1
        stackCount = stackCount + (auraData.stacks or 0)
        matchedUnits[unit] = true
        if not unitCounted then
          unitCount = unitCount + 1
          unitCounted = true
        end
        if not bestMatch or triggerInfo.compareFunc(bestMatch, auraData) then
          bestMatch = auraData
        end
      end
    end
  end
  return bestMatch, matchCount, unitCount, stackCount, nextCheck
end

local function FindBestMatchDataForUnit(time, id, triggernum, triggerInfo, unit)
  -- Find best match
  local bestMatch = nil
  local matchCount = 0
  local stackCount = 0
  local nextCheck

  if not matchDataByTrigger[id] or not matchDataByTrigger[id][triggernum] or not matchDataByTrigger[id][triggernum][unit] then
    return nil, 0
  end

  for index, auraData in pairs(matchDataByTrigger[id][triggernum][unit]) do
    local remCheck = true
    if triggerInfo.remainingFunc and auraData.expirationTime then
      if auraData.expirationTime == 0 then
        remCheck = false
      else
        local modRate = auraData.modRate or 1
        local remaining = (auraData.expirationTime - time) / modRate
        remCheck = triggerInfo.remainingFunc(remaining)
        nextCheck = calculateNextCheck(triggerInfo.remainingCheck, remaining, auraData.expirationTime, modRate, nextCheck)
      end
    end

    if remCheck then
      matchCount = matchCount + 1
      stackCount = stackCount + (auraData.stacks or 0)
      if not bestMatch or triggerInfo.compareFunc(bestMatch, auraData) then
        bestMatch = auraData
      end
    end
  end
  return bestMatch, matchCount, stackCount, nextCheck
end

--- Deprecated in 10.1.5
local GetTexCoordsForRole = function(role)
  local textureHeight, textureWidth = 256, 256
  local roleHeight, roleWidth = 67, 67

  if ( role == "GUIDE" ) then
    return GetTexCoordsByGrid(1, 1, textureWidth, textureHeight, roleWidth, roleHeight)
  elseif ( role == "TANK" ) then
    return GetTexCoordsByGrid(1, 2, textureWidth, textureHeight, roleWidth, roleHeight)
  elseif ( role == "HEALER" ) then
    return GetTexCoordsByGrid(2, 1, textureWidth, textureHeight, roleWidth, roleHeight)
  elseif ( role == "DAMAGER" ) then
    return GetTexCoordsByGrid(2, 2, textureWidth, textureHeight, roleWidth, roleHeight)
  else
    error("Unknown role: "..tostring(role))
  end
end

local roleIcons = {
  DAMAGER = CreateTextureMarkup([=[Interface\LFGFrame\UI-LFG-ICON-ROLES]=], 256, 256, 0, 0, GetTexCoordsForRole("DAMAGER")),
  HEALER = CreateTextureMarkup([=[Interface\LFGFrame\UI-LFG-ICON-ROLES]=], 256, 256, 0, 0, GetTexCoordsForRole("HEALER")),
  TANK = CreateTextureMarkup([=[Interface\LFGFrame\UI-LFG-ICON-ROLES]=], 256, 256, 0, 0, GetTexCoordsForRole("TANK"))
}

local function UpdateStateWithMatch(time, bestMatch, triggerStates, cloneId, matchCount, unitCount, maxUnitCount, matchCountPerUnit, totalStacks, affected, affectedUnits, unaffected, unaffectedUnits, role, raidMark)
  local debuffClassIcon = WeakAuras.EJIcons[bestMatch.debuffClass]
  if not triggerStates[cloneId] then
    triggerStates[cloneId] = {
      show = true,
      changed = true,
      name = bestMatch.name,
      icon = bestMatch.icon,
      stacks = bestMatch.stacks,
      debuffClass = bestMatch.debuffClass,
      debuffClassIcon = debuffClassIcon,
      progressType = "timed",
      duration = bestMatch.duration,
      expirationTime = bestMatch.expirationTime,
      modRate = bestMatch.modRate,
      unitCaster = bestMatch.unitCaster,
      casterName = bestMatch.casterName,
      spellId = bestMatch.spellId,
      index = bestMatch.index,
      auraInstanceID = bestMatch.auraInstanceID,
      filter = bestMatch.filter,
      unit = bestMatch.unit,
      unitName = bestMatch.unitName,
      GUID = bestMatch.unit and UnitGUID(bestMatch.unit) or bestMatch.GUID,
      role = role,
      roleIcon = role and roleIcons[role],
      raidMark = raidMark,
      matchCount = matchCount,
      unitCount = unitCount,
      maxUnitCount = maxUnitCount,
      matchCountPerUnit = matchCountPerUnit,
      tooltip = bestMatch.tooltip,
      tooltip1 = bestMatch.tooltip1,
      tooltip2 = bestMatch.tooltip2,
      tooltip3 = bestMatch.tooltip3,
      tooltip4 = bestMatch.tooltip4,
      points = bestMatch.points,
      affected = affected,
      affectedUnits = affectedUnits,
      unaffected = unaffected,
      unaffectedUnits = unaffectedUnits,
      totalStacks = totalStacks,
      initialTime = time,
      refreshTime = time,
      active = true,
      time = time,
    }
    return true
  else
    local state = triggerStates[cloneId]
    local changed = false
    state.time = time

    if state.unit ~= bestMatch.unit then
      state.unit = bestMatch.unit
      changed = true
    end

    local GUID = bestMatch.unit and UnitGUID(bestMatch.unit) or bestMatch.GUID
    if state.GUID ~= GUID then
      state.GUID = GUID
      changed = true
    end

    if state.role ~= role then
      state.role = role
      state.roleIcon = roleIcons[role]
      changed = true
    end

    if state.raidMark ~= raidMark then
      state.raidMark = raidMark
      changed = true
    end

    if state.unitName ~= bestMatch.unitName then
      state.unitName = bestMatch.unitName
      changed = true
    end

    if state.show ~= true then
      state.show = true
      changed = true
    end

    if state.name ~= bestMatch.name then
      state.name = bestMatch.name
      changed = true
    end

    if state.icon ~= bestMatch.icon then
      state.icon = bestMatch.icon
      changed = true
    end

    if state.stacks ~= bestMatch.stacks then
      if state.stacks and bestMatch.stacks then
        if state.stacks < bestMatch.stacks then
          state.stackGainTime = time
          state.stackLostTime = nil
        else
          state.stackGainTime = nil
          state.stackLostTime = time
        end
      end
      state.stacks = bestMatch.stacks
      changed = true
    end

    if state.debuffClass ~= bestMatch.debuffClass then
      state.debuffClass = bestMatch.debuffClass
      changed = true
    end

    if state.debuffClassIcon ~= debuffClassIcon then
      state.debuffClassIcon = debuffClassIcon
      changed = true
    end

    if state.duration ~= bestMatch.duration then
      state.duration = bestMatch.duration
      changed = true
    end

    if not state.initialTime then
      -- Only set initialTime if it wasn't set before
      state.initialTime = time
      changed = true
    end

    if state.expirationTime ~= bestMatch.expirationTime then
      -- A bit fuzzy checking
      if state.expirationTime and bestMatch.expirationTime and bestMatch.expirationTime - state.expirationTime > 0.2  then
        state.refreshTime = time
      end
      state.expirationTime = bestMatch.expirationTime
      changed = true
    end

    if state.modRate ~= bestMatch.modRate then
      state.modRate = bestMatch.modRate
      changed = true
    end

    if state.progressType ~= "timed" then
      state.progressType = "timed"
      changed = true
    end

    if state.unitCaster ~= bestMatch.unitCaster then
      state.unitCaster = bestMatch.unitCaster
      state.casterName = bestMatch.casterName
      changed = true
    end

    if state.spellId ~= bestMatch.spellId then
      state.spellId = bestMatch.spellId
      changed = true
    end

    if state.index ~= bestMatch.index then
      state.index = bestMatch.index
      changed = true
    end

    if state.auraInstanceID ~= bestMatch.auraInstanceID then
      state.auraInstanceID = bestMatch.auraInstanceID
      changed = true
    end

    if state.filter ~= bestMatch.filter then
      state.filter = bestMatch.filter
      changed = true
    end

    if state.tooltip ~= bestMatch.tooltip then
      state.tooltip = bestMatch.tooltip
      changed = true
    end

    if state.tooltip1 ~= bestMatch.tooltip1 then
      state.tooltip1 = bestMatch.tooltip1
      changed = true
    end

    if state.tooltip2 ~= bestMatch.tooltip2 then
      state.tooltip2 = bestMatch.tooltip2
      changed = true
    end

    if state.tooltip3 ~= bestMatch.tooltip3 then
      state.tooltip3 = bestMatch.tooltip3
      changed = true
    end

    if state.tooltip4 ~= bestMatch.tooltip4 then
      state.tooltip4 = bestMatch.tooltip4
      changed = true
    end

    if not ArrayCompare(state.points, bestMatch.points) then
      state.points = bestMatch.points
      changed = true
    end

    if state.matchCount ~= matchCount then
      state.matchCount = matchCount
      changed = true
    end

    if state.unitCount ~= unitCount then
      state.unitCount = unitCount
      changed = true
    end

    if state.maxUnitCount ~= maxUnitCount then
      state.maxUnitCount = maxUnitCount
      changed = true
    end

    if state.matchCountPerUnit ~= matchCountPerUnit then
      state.matchCountPerUnit = matchCountPerUnit
      changed = true
    end

    if state.affected ~= affected then
      state.affected = affected
      state.affectedUnits = affectedUnits
      changed = true
    end

    if state.unaffected ~= unaffected then
      state.unaffected = unaffected
      state.unaffectedUnits = unaffectedUnits
      changed = true
    end

    if state.active ~= true then
      state.active = true
      changed = true
    end

    if state.totalStacks ~= totalStacks then
      state.totalStacks = totalStacks
      changed = true
    end

    if changed then
      state.changed = true
      return true
    end
  end
end

local function UpdateStateWithNoMatch(time, triggerStates, triggerInfo, cloneId, unit, matchCount, unitCount, maxUnitCount, matchCountPerUnit, totalStacks, affected, affectedUnits, unaffected, unaffectedUnits, role, raidMark)
  local fallbackName, fallbackIcon = BuffTrigger.GetNameAndIconSimple(WeakAuras.GetData(triggerInfo.id), triggerInfo.triggernum)
  if not triggerStates[cloneId] then
    triggerStates[cloneId] = {
      show = true,
      changed = true,
      progressType = 'timed',
      duration = 0,
      expirationTime = math.huge,
      modRate = 1,
      matchCount = matchCount,
      unitCount = unitCount,
      maxUnitCount = maxUnitCount,
      matchCountPerUnit = matchCountPerUnit,
      active = false,
      time = time,
      affected = affected,
      affectedUnits = affectedUnits,
      unaffected = unaffected,
      unaffectedUnits = unaffectedUnits,
      unit = unit,
      role = role,
      raidMark = raidMark,
      roleIcon = role and roleIcons[role],
      unitName = unit and GetUnitName(unit, false) or "",
      destName = "",
      name = fallbackName,
      icon = fallbackIcon,
      totalStacks = totalStacks
    }
    return true
  else
    local state = triggerStates[cloneId]
    state.time = time
    local changed = false

    if state.show ~= true then
      state.show = true
      changed = true
    end

    if state.name ~= fallbackName then
      state.name = fallbackName
      changed = true
    end

    if state.icon ~= fallbackIcon then
      state.icon = fallbackIcon
      changed = true
    end

    if state.stacks then
      state.stacks = nil
      changed = true
    end

    if state.duration then
      state.duration = nil
      changed = true
    end

    if state.initialTime then
      state.initialTime = nil
      changed = true
    end

    if state.refreshTime then
      state.refreshTime = nil
      changed = true
    end

    if state.expirationTime ~= math.huge then
      state.expirationTime = math.huge
      changed = true
    end

    if state.progressType then
      state.progressType = nil
      changed = true
    end

    if state.modRate ~= 1 then
      state.modRate = 1
      changed = true
    end

    if state.unit ~= unit then
      state.unit = unit
      changed = true
    end

    local GUID = unit and UnitGUID(unit)
    if state.GUID ~= GUID then
      state.GUID = GUID
      changed = true
    end

    if state.role ~= role then
      state.role = role
      state.roleIcon = roleIcons[role]
      changed = true
    end

    if state.raidMark ~= raidMark then
      state.raidMark = raidMark
      changed = true
    end

    local unitName = unit and GetUnitName(unit, false) or ""
    if state.unitName ~= unitName then
      state.unitName = unitName
      changed = true
    end

    if state.unitCaster then
      state.unitCaster = nil
      changed = true
    end

    if state.casterName ~= "" then
      state.casterName = ""
      changed = true
    end

    if state.spellId then
      state.spellId = nil
      changed = true
    end

    if state.index then
      state.index = nil
      changed = true
    end

    if state.auraInstanceID then
      state.auraInstanceID = nil
      changed = true
    end

    if state.tooltip or state.tooltip1 or state.tooltip2 or state.tooltip3 or state.tooltip4 then
      state.tooltip, state.tooltip1, state.tooltip2, state.tooltip3, state.tooltip4 = nil, nil, nil, nil, nil
      changed = true
    end

    if state.points then
      state.points = nil
      changed = true
    end

    if state.matchCount ~= matchCount then
      state.matchCount = matchCount
      changed = true
    end

    if state.unitCount ~= unitCount then
      state.unitCount = unitCount
      changed = true
    end

    if state.maxUnitCount ~= maxUnitCount then
      state.maxUnitCount = maxUnitCount
      changed = true
    end

    if state.matchCountPerUnit ~= matchCountPerUnit then
      state.matchCountPerUnit = matchCountPerUnit
      changed = true
    end

    if state.active then
      state.active = false
      changed = true
    end

    if state.affected ~= affected then
      state.affected = affected
      state.affectedUnits = affectedUnits
      changed = true
    end

    if state.unaffected ~= unaffected then
      state.unaffected = unaffected
      state.unaffectedUnits = unaffectedUnits
      changed = true
    end

    if state.totalStacks ~= totalStacks then
      state.totalStacks = totalStacks
      changed = true
    end

    if changed then
      state.changed = true
      return true
    end
  end
end

local function RemoveState(triggerStates, cloneId)
  local state = triggerStates[cloneId]
  if state then
    if state.show then
      state.show = false
      state.changed = true
      return true
    end
  end
end

local function GetAllUnits(unit, allUnits, includePets)
  if unit == "group" then
    if allUnits then
      local i = 1
      local raid = true
      local pets = true
      return function()
        if raid then
          if i <= 40 then
            local ret
            if includePets == "PlayersAndPets" then
              ret = pets and WeakAuras.raidpetUnits[i] or WeakAuras.raidUnits[i]
              pets = not pets
              if pets then
                i = i + 1
              end
            elseif includePets == "PetsOnly" then
              ret = WeakAuras.raidpetUnits[i]
              i = i + 1
            else -- raid
              ret = WeakAuras.raidUnits[i]
              i = i + 1
            end
            return ret
          end
          if includePets and pets then
            pets = not pets
            return "pet"
          end
          raid = false
          i = 1
          return "player"
        end

        if i <= 4 then
          local ret
          if includePets == "PlayersAndPets" then
            ret = pets and WeakAuras.partypetUnits[i] or WeakAuras.partyUnits[i]
            pets = not pets
            if pets then
              i = i + 1
            end
          elseif includePets == "PetsOnly" then
            ret = WeakAuras.partypetUnits[i]
            i = i + 1
          else -- group
            ret = WeakAuras.partyUnits[i]
            i = i + 1
          end
          return ret
        end

        i = 1
        raid = true
      end
    end

    -- allunits == false
    if IsInRaid() then
      local i = 1
      local max = GetNumGroupMembers()
      local pets = true
      return function()
        if i <= max then
          local ret
          if includePets == "PlayersAndPets" then
            ret = pets and WeakAuras.raidpetUnits[i] or WeakAuras.raidUnits[i]
            pets = not pets
            if pets then
              i = i + 1
            end
          elseif includePets == "PetsOnly" then
            ret = WeakAuras.raidpetUnits[i]
            i = i + 1
          else -- raid
            ret = WeakAuras.raidUnits[i]
            i = i + 1
          end
          return ret
        end
        i = 1
      end
    else
      local i = 0
      local max = GetNumSubgroupMembers()
      local pets = true
      return function()
        if i == 0 then
          if includePets == "PlayersAndPets" then
            local ret = pets and "pet" or "player"
            pets = not pets
            if pets then
                i = i + 1
            end
            return ret
          elseif includePets == "PetsOnly" then
            i = 1
            return "pet"
          else -- group
            i = 1
            return "player"
          end
        else
          if i <= max then
            local ret
            if includePets == "PlayersAndPets" then
              ret = pets and WeakAuras.partypetUnits[i] or WeakAuras.partyUnits[i]
              pets = not pets
              if pets then
                i = i + 1
              end
            elseif includePets == "PetsOnly" then
              ret = WeakAuras.partypetUnits[i]
              i = i + 1
            else -- group
              ret = WeakAuras.partyUnits[i]
              i = i + 1
            end
            return ret
          end
        end
        i = 0
      end
    end
  elseif unit == "boss" or unit == "arena" or unit == "nameplate" then
    local i = 1
    local max
    if unit == "boss" then
      max = 10
    elseif unit == "arena" then
      max = 5
    elseif unit == "nameplate" then
      max = 40
    else
      return function() end
    end
    return function()
      local ret = unit .. i
      while not allUnits and not UnitExistsFixed(ret) do
        i = i + 1
        if i > max then
          i = 1
          return nil
        end
        ret = unit .. i
      end
      i = i + 1
      if i > max then
        i = 1
        return nil
      end
      return ret
    end
  else
    local toggle = false
    return function()
      toggle = not toggle
      if toggle then
        return unit
      end
    end
  end
end

local function MaxUnitCount(triggerInfo)
  if triggerInfo.groupTrigger then
    return triggerInfo.maxUnitCount
  else
    return UnitExistsFixed(triggerInfo.unit) and 1 or 0
  end
end



local function TriggerInfoApplies(triggerInfo, unit)
  local controllingUnit = unit
  if WeakAuras.UnitIsPet(unit) then
    controllingUnit = WeakAuras.petUnitToUnit[unit]
  end

  if triggerInfo.ignoreSelf and UnitIsUnit("player", controllingUnit) then
    return false
  end

  if triggerInfo.ignoreDead and UnitIsDeadOrGhost(unit) then
    return false
  end

  if triggerInfo.ignoreDisconnected and not UnitIsConnected(unit) then
    return false
  end

  if triggerInfo.ignoreInvisible and not UnitIsVisibleFixed(unit) then
    return false
  end

  if triggerInfo.groupRole and not triggerInfo.groupRole[UnitGroupRolesAssigned(controllingUnit) or ""] then
    return false
  end

  if triggerInfo.raidRole and not triggerInfo.raidRole[WeakAuras.UnitRaidRole(controllingUnit) or ""] then
    return false
  end

  if triggerInfo.specId then
    local spec = Private.LibSpecWrapper.SpecForUnit(controllingUnit)
    if not triggerInfo.specId[spec] then
      return false
    end
  end

  if triggerInfo.arenaSpec and unit:sub(1, 5) == "arena" then
    -- GetArenaOpponentSpec doesn't use unit ids!
    local i = tonumber(unit:sub(6))
    if not triggerInfo.arenaSpec[GetArenaOpponentSpec(i)] then
      return false
    end
  end

  if triggerInfo.hostility and WeakAuras.GetPlayerReaction(unit) ~= triggerInfo.hostility then
    return false
  end

  if triggerInfo.unit == "group" then
    local isPet = WeakAuras.UnitIsPet(unit)
    if triggerInfo.includePets == "PetsOnly" and not isPet then
      return false
    elseif triggerInfo.includePets == nil and isPet then -- exclude pets
      return false
    end
  end

  if triggerInfo.unit == "group" and triggerInfo.groupSubType == "party" then
    if IsInRaid() then
      -- Filter our player/party# while in raid and keep only raid units that are correct
      if not Private.multiUnitUnits.raid[unit] or not UnitInSubgroupOrPlayer(unit, triggerInfo.includePets) then
        return false
      end
    else
      if not UnitInSubgroupOrPlayer(unit, triggerInfo.includePets) then
        return false
      end
    end
  end

  -- Filter our player/party# while in raid
  if (triggerInfo.unit == "group" and triggerInfo.groupSubType == "group" and IsInRaid() and not Private.multiUnitUnits.raid[unit]) then
    return false
  end

  if triggerInfo.unit == "group" and triggerInfo.groupSubType == "raid" and not Private.multiUnitUnits.raid[unit] then
    return false
  end

  if triggerInfo.class and not triggerInfo.class[select(2, UnitClass(controllingUnit))] then
    return false
  end

  if triggerInfo.npcId and not triggerInfo.npcId:Check(select(6, strsplit('-', UnitGUID(unit) or ''))) then
    return false
  end

  if triggerInfo.nameChecker and not triggerInfo.nameChecker:Check(WeakAuras.UnitNameWithRealm(unit)) then
    return false
  end

  if triggerInfo.inRange and not UnitInRangeFixed(unit) then
    return false
  end

  return true
end

local function FormatAffectedUnaffected(triggerInfo, matchedUnits)
  local affected = ""
  local unaffected = ""
  local affectedUnits, unaffectedUnits = {}, {}
  for unit in GetAllUnits(triggerInfo.unit, nil, triggerInfo.includePets) do
    if activeGroupScanFuncs[unit] and activeGroupScanFuncs[unit][triggerInfo] then
      if matchedUnits[unit] then
        affected = affected .. (GetUnitName(unit, false) or unit) .. ", "
        tinsert(affectedUnits, unit)
      else
        unaffected = unaffected .. (GetUnitName(unit, false) or unit) .. ", "
        tinsert(unaffectedUnits, unit)
      end
    end
  end
  unaffected = unaffected == "" and L["None"] or unaffected:sub(1, -3)
  affected = affected == "" and L["None"] or affected:sub(1, -3)

  return affected, affectedUnits, unaffected, unaffectedUnits
end

local recheckTriggerInfo

local function SatisfiesGroupMatchCount(triggerInfo, unitCount, maxUnitCount, matchCount)
  if triggerInfo.groupCountFunc and not triggerInfo.groupCountFunc(unitCount, maxUnitCount) then
    return false
  end

  if triggerInfo.matchCountFunc and not triggerInfo.matchCountFunc(matchCount) then
    return false
  end
  return true
end

local function SatisfiesMatchCountPerUnit(triggerInfo, countPerUnit)
  return not triggerInfo.matchPerUnitCountFunc or triggerInfo.matchPerUnitCountFunc(countPerUnit)
end

local function bestUnit(triggerInfo, bestMatch)
  if bestMatch then
    return bestMatch.unit
  elseif not triggerInfo.groupTrigger and triggerInfo.unit then
    return triggerInfo.unit
  end
end

local function roleForTriggerInfo(triggerInfo, unit)
  if triggerInfo.fetchRole then
    return UnitGroupRolesAssigned(unit)
  end
end

local function markForTriggerInfo(triggerInfo, unit)
  if triggerInfo.fetchRaidMark then
    local rt = GetRaidTargetIndex(unit)
    if rt then
      return "{rt" .. GetRaidTargetIndex(unit) .. "}"
    end
  end
end

local function SortMatchDataByUnitIndex(a, b)
  if a.unit and b.unit and a.unit ~= b.unit then
    return a.unit < b.unit
  end
  if a.index and b.index and a.index ~= b.index then
    return a.index < b.index
  end
  return a.expirationTime < b.expirationTime
end

local function UpdateTriggerState(time, id, triggernum)
  local triggerStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum)
  local triggerInfo = triggerInfos[id][triggernum]
  local updated
  local nextCheck
  local matchCount = 0
  ---@type number?
  local totalStacks = 0
  local unitCount = 0
  local auraDatas = {}
  local maxUnitCount = MaxUnitCount(triggerInfo)
  local matchedUnits = {}
  local matchCountPerUnit = {}

  if triggerInfo.combineMode == "showOne" then
    local bestMatch
    bestMatch, matchCount, unitCount, totalStacks, nextCheck = FindBestMatchData(time, id, triggernum, triggerInfo, matchedUnits)
    local cloneId = ""

    local useMatch = true
    if triggerInfo.unitExists ~= nil and not UnitExistsFixed(triggerInfo.unit) then
      useMatch = triggerInfo.unitExists
    else
      useMatch = SatisfiesGroupMatchCount(triggerInfo, unitCount, maxUnitCount, matchCount)
    end

    if useMatch then
      local affected, unaffected, affectedUnits, unaffectedUnits
      if triggerInfo.useAffected then
        affected, affectedUnits, unaffected, unaffectedUnits = FormatAffectedUnaffected(triggerInfo, matchedUnits)
      end

      local unit = bestUnit(triggerInfo, bestMatch)
      local role = roleForTriggerInfo(triggerInfo, unit)
      local mark = markForTriggerInfo(triggerInfo, unit)

      if bestMatch then
        updated = UpdateStateWithMatch(time, bestMatch, triggerStates, cloneId, matchCount, unitCount, maxUnitCount, matchCount, totalStacks, affected, affectedUnits, unaffected, unaffectedUnits, role, mark)
      else
        updated = UpdateStateWithNoMatch(time, triggerStates, triggerInfo, cloneId, unit, 0, 0, maxUnitCount, 0, 0, affected, affectedUnits, unaffected, unaffectedUnits, role, mark)
      end
    else
      updated = RemoveState(triggerStates, cloneId)
    end
  elseif triggerInfo.combineMode == "showClones" then
    if matchDataByTrigger[id] and matchDataByTrigger[id][triggernum] then
      for unit, unitData in pairs(matchDataByTrigger[id][triggernum]) do
        local unitCounted = false
        for index, auraData in pairs(unitData) do
          local remCheck = true
          if triggerInfo.remainingFunc and auraData.expirationTime then
            if auraData.expirationTime == 0 then
              remCheck = false
            else
              local modRate = auraData.modRate or 1
              local remaining = (auraData.expirationTime - time) / modRate
              remCheck = triggerInfo.remainingFunc(remaining)
              nextCheck = calculateNextCheck(triggerInfo.remainingCheck, remaining, auraData.expirationTime, modRate, nextCheck)
            end
          end

          if remCheck then
            tinsert(auraDatas, auraData)
            matchCount = matchCount + 1
            totalStacks = totalStacks + (auraData.stacks or 0)
            matchedUnits[unit] = true
            matchCountPerUnit[unit] = (matchCountPerUnit[unit] or 0) + 1
            if not unitCounted then
              unitCount = unitCount + 1
              unitCounted = true
            end
          end
        end
      end
    end

    local useMatches = true
    if triggerInfo.unitExists ~= nil and not UnitExistsFixed(triggerInfo.unit) then
      useMatches = triggerInfo.unitExists
    else
      useMatches = SatisfiesGroupMatchCount(triggerInfo, unitCount, maxUnitCount, matchCount)
    end

    local cloneIds = {}
    if useMatches then
      table.sort(auraDatas, SortMatchDataByUnitIndex)

      local affected, affectedUnits, unaffected, unaffectedUnits
      if triggerInfo.useAffected then
        affected, affectedUnits, unaffected, unaffectedUnits = FormatAffectedUnaffected(triggerInfo, matchedUnits)
      end

      local usedCloneIds = {};
      for index, auraData in ipairs(auraDatas) do
        local cloneId = (auraData.GUID or auraData.unit or "unknown") .. " " .. auraData.spellId
        if usedCloneIds[cloneId] then
          usedCloneIds[cloneId] = usedCloneIds[cloneId] + 1
          cloneId = cloneId .. usedCloneIds[cloneId]
        else
          usedCloneIds[cloneId] = 1
        end


        local role = roleForTriggerInfo(triggerInfo, auraData.unit)
        local mark = markForTriggerInfo(triggerInfo, auraData.unit)
        updated = UpdateStateWithMatch(time, auraData, triggerStates, cloneId, matchCount, unitCount, maxUnitCount,
                                      matchCountPerUnit[auraData.unit], totalStacks, affected, affectedUnits, unaffected, unaffectedUnits, role, mark) or updated
        cloneIds[cloneId] = true
      end

      if matchCount == 0 then
        local unit = bestUnit(triggerInfo, nil)
        local role = roleForTriggerInfo(triggerInfo, unit)
        local mark = markForTriggerInfo(triggerInfo, unit)
        updated = UpdateStateWithNoMatch(time, triggerStates, triggerInfo, "", nil, 0, 0, maxUnitCount, 0, totalStacks,
                                         affected, affectedUnits, unaffected, unaffectedUnits, role, mark) or updated
        cloneIds[""] = true
      end
    end

    for cloneId, state in pairs(triggerStates) do
      if not cloneIds[cloneId] then
        updated = RemoveState(triggerStates, cloneId) or updated
      end
    end
  elseif triggerInfo.combineMode == "showPerUnit" then
    local matches = {}
    if matchDataByTrigger[id] and matchDataByTrigger[id][triggernum] then
      for unit, unitData in pairs(matchDataByTrigger[id][triggernum]) do
        local bestMatch, countPerUnit, stacks, nextCheckForMatch = FindBestMatchDataForUnit(time, id, triggernum, triggerInfo, unit)

        if SatisfiesMatchCountPerUnit(triggerInfo, countPerUnit) then
          matchCount = matchCount + countPerUnit
          totalStacks = totalStacks + (stacks or 0)
          if bestMatch then
            unitCount = unitCount + 1
            matchedUnits[unit] = true
          end

          if not nextCheck then
            nextCheck = nextCheckForMatch
          elseif nextCheckForMatch then
            nextCheck = min(nextCheck, nextCheckForMatch)
          end
          matches[unit] = bestMatch
          matchCountPerUnit[unit] = countPerUnit
        end
      end
    end

    local useMatches = SatisfiesGroupMatchCount(triggerInfo, unitCount, maxUnitCount, matchCount)

    local cloneIds = {}
    if useMatches then
      local affected, affectedUnits, unaffected, unaffectedUnits
      if triggerInfo.useAffected then
        affected, affectedUnits, unaffected, unaffectedUnits = FormatAffectedUnaffected(triggerInfo, matchedUnits)
      end

      if triggerInfo.perUnitMode == "affected" then
        for unit, bestMatch in pairs(matches) do
          if bestMatch then
            local role = roleForTriggerInfo(triggerInfo, unit)
            local mark = markForTriggerInfo(triggerInfo, unit)
            updated = UpdateStateWithMatch(time, bestMatch, triggerStates, unit, matchCount, unitCount, maxUnitCount,
                                           matchCountPerUnit[unit], totalStacks, affected, affectedUnits, unaffected, unaffectedUnits, role, mark)
                                           or updated
            cloneIds[unit] = true
          end
        end
      else
        -- state per unaffected unit
        for unit in GetAllUnits(triggerInfo.unit, nil, triggerInfo.includePets) do
          if activeGroupScanFuncs[unit] and activeGroupScanFuncs[unit][triggerInfo] then
            local bestMatch = matches[unit]
            local role = roleForTriggerInfo(triggerInfo, unit)
            local mark = markForTriggerInfo(triggerInfo, unit)
            if bestMatch then
              if triggerInfo.perUnitMode == "all" then
                updated = UpdateStateWithMatch(time, bestMatch, triggerStates, unit, matchCount, unitCount, maxUnitCount,
                                               matchCountPerUnit[unit], totalStacks, affected, affectedUnits, unaffected, unaffectedUnits, role, mark)
                                               or updated
                cloneIds[unit] = true
              end
            else
              updated = UpdateStateWithNoMatch(time, triggerStates, triggerInfo, unit, unit, matchCount,
                                               unitCount, maxUnitCount, matchCountPerUnit[unit], totalStacks,
                                              affected, affectedUnits, unaffected, unaffectedUnits, role)
                                              or updated
              cloneIds[unit] = true
            end
          end
        end
      end
    end

    for cloneId, state in pairs(triggerStates) do
      if not cloneIds[cloneId] then
        updated = RemoveState(triggerStates, cloneId) or updated
      end
    end
  end

  if nextCheck then
    if triggerInfo.nextScheduledCheck ~= nextCheck then
      if triggerInfo.nextScheduledCheckHandle then
        timer:CancelTimer(triggerInfo.nextScheduledCheckHandle)
      end
      triggerInfo.nextScheduledCheckHandle = timer:ScheduleTimerFixed(recheckTriggerInfo, nextCheck - time, triggerInfo)
      triggerInfo.nextScheduledCheck = nextCheck
    end
  elseif triggerInfo.nextScheduledCheckHandle then
    timer:CancelTimer(triggerInfo.nextScheduledCheckHandle)
    triggerInfo.nextScheduledCheckHandle = nil
    triggerInfo.nextScheduledCheck = nil
  end

  -- if the trigger has updated then check to see if it is flagged for WatchedTrigger and send to queue if it is
  if updated then
    if watched_trigger_events[id] and watched_trigger_events[id][triggernum] then
      Private.AddToWatchedTriggerDelay(id, triggernum)
    end
  end
  return updated
end

recheckTriggerInfo = function(triggerInfo)
  matchDataChanged[triggerInfo.id] = matchDataChanged[triggerInfo.id] or {}
  matchDataChanged[triggerInfo.id][triggerInfo.triggernum] = true
  triggerInfo.nextScheduledCheckHandle = nil
  triggerInfo.nextScheduledCheck = nil
end

local PrepareMatchData
do
  local _time, _unit, _filter

  local function HandleAura(aura)
    if (not aura or not aura.name) then
      return
    end
    local debuffClass = FixDebuffClass(aura.dispelName, aura.spellId)
    UpdateMatchData(_time, matchDataChanged, _unit, nil, aura.auraInstanceID, _filter, aura.name, aura.icon, aura.applications, debuffClass, aura.duration, aura.expirationTime, aura.sourceUnit, aura.isStealable, aura.isBossAura, aura.isFromPlayerOrPlayerPet, aura.spellId, aura.timeMod, aura.points)
  end

  PrepareMatchData = function(unit, filter)
    if not matchDataUpToDate[unit] or not matchDataUpToDate[unit][filter] then
      if newAPI then
        _time = GetTime()
        _unit = unit
        _filter = filter
        AuraUtil.ForEachAura(unit, filter, nil, HandleAura, true)
      else
        local time = GetTime()
        local index = 1
        while true do
          local name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, isBossDebuff, isCastByPlayer, _, modRate = UnitAura(unit, index, filter)
          if not name then
            break
          end

          debuffClass = FixDebuffClass(debuffClass, spellId)
          UpdateMatchData(time, matchDataChanged, unit, index, nil, filter, name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, isBossDebuff, isCastByPlayer, spellId, modRate, nil)
          index = index + 1
        end
      end
      matchDataUpToDate[unit] = matchDataUpToDate[unit] or {}
      matchDataUpToDate[unit][filter] = true
    end
  end
end

local function CleanUpOutdatedMatchData(removeIndex, unit, filter)
  -- Figure out if any matchData is outdated
  if newAPI then
    -- clean everything, as ScanUnitWithFilter is only used with index = 1 to wipe all data with newAPI
    if matchData[unit] and matchData[unit][filter] then
      for auraInstanceID, data in pairs(matchData[unit][filter]) do
        for id, triggerData in pairs(data.auras) do
          for triggernum in pairs(triggerData) do
            matchDataByTrigger[id][triggernum][unit][auraInstanceID] = nil
            matchDataChanged[id] = matchDataChanged[id] or {}
            matchDataChanged[id][triggernum] = true
          end
        end
        if data.dataInstanceID then
          TooltipHelper:Untrack(data.dataInstanceID, data)
        end
        matchData[unit][filter][auraInstanceID] = nil
      end
    end
  else
    if matchData[unit] and matchData[unit][filter] then
      for index = removeIndex, #matchData[unit][filter] do
        local data = matchData[unit][filter][index]
        if (data and data.index >= removeIndex) or not UnitExistsFixed(unit) then
           matchData[unit][filter][index] = nil
           for id, triggerData in pairs(data.auras) do
             for triggernum in pairs(triggerData) do
               matchDataByTrigger[id][triggernum][unit][index] = nil
               matchDataChanged[id] = matchDataChanged[id] or {}
               matchDataChanged[id][triggernum] = true
             end
           end
        end
      end
    end
  end
end

local function CleanUpMatchDataForUnit(unit, filter)
  -- Figure out if any matchData is outdated
  if matchData[unit] and matchData[unit][filter] then
    for index, data in pairs(matchData[unit][filter]) do
      matchData[unit][filter][index] = nil
      for id, triggerData in pairs(data.auras) do
        for triggernum in pairs(triggerData) do
          if matchDataByTrigger[id] and matchDataByTrigger[id][triggernum]
             and matchDataByTrigger[id][triggernum][unit]
             and matchDataByTrigger[id][triggernum][unit][index]
          then
            matchDataByTrigger[id][triggernum][unit][index] = nil
            matchDataChanged[id] = matchDataChanged[id] or {}
            matchDataChanged[id][triggernum] = true
          end
        end
      end
      if data.dataInstanceID then
        TooltipHelper:Untrack(data.dataInstanceID, data)
      end
    end
  end
end

local function DeactivateScanFuncs(toDeactivate)
  for unit, triggerInfosPerUnit in pairs(toDeactivate) do
    for triggerInfo in pairs(triggerInfosPerUnit) do
      local id = triggerInfo.id
      local triggernum = triggerInfo.triggernum
      local matches = GetSubTable(matchDataByTrigger, id, triggernum, unit)
      if (matches) then
        for index, match in pairs(matches) do
          match.auras[id][triggernum] = nil
        end
        matchDataByTrigger[id][triggernum][unit] = nil
        matchDataChanged[id] = matchDataChanged[id] or {}
        matchDataChanged[id][triggernum] = true
      end
    end
  end
end



local ScanUnitWithFilter
do
  local _matchDataChanged, _time, _unit, _filter, _scanFuncNameGroup, _scanFuncSpellIdGroup, _scanFuncGeneralGroup, _scanFuncName, _scanFuncSpellId, _scanFuncGeneral

  local function HandleAura(aura)
    if (not aura or not aura.name) then
      return
    end
    local debuffClass = FixDebuffClass(aura.dispelName, aura.spellId)

    local name, spellId, auraInstanceID = aura.name, aura.spellId, aura.auraInstanceID
    local updatedMatchData = UpdateMatchData(_time, _matchDataChanged, _unit, nil, auraInstanceID, _filter, name, aura.icon, aura.applications, debuffClass, aura.duration, aura.expirationTime, aura.sourceUnit, aura.isStealable, aura.isBossAura, aura.isFromPlayerOrPlayerPet, spellId, aura.timeMod, aura.points)

    if updatedMatchData then -- Aura data changed, check against triggerInfos
      CheckScanFuncs(_scanFuncName and _scanFuncName[name], _unit, _filter, auraInstanceID)
      CheckScanFuncs(_scanFuncNameGroup and _scanFuncNameGroup[name], _unit, _filter, auraInstanceID)
      CheckScanFuncs(_scanFuncSpellId and _scanFuncSpellId[spellId], _unit, _filter, auraInstanceID)
      CheckScanFuncs(_scanFuncSpellIdGroup and _scanFuncSpellIdGroup[spellId], _unit, _filter, auraInstanceID)
      CheckScanFuncs(_scanFuncGeneral, _unit, _filter, auraInstanceID)
      CheckScanFuncs(_scanFuncGeneralGroup, _unit, _filter, auraInstanceID)
    end
  end

  ScanUnitWithFilter = function(matchDataChanged, time, unit, filter, unitAuraUpdateInfo,
    scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup,
    scanFuncName, scanFuncSpellId, scanFuncGeneral)
    if not scanFuncName and not scanFuncSpellId and not scanFuncGeneral and not scanFuncNameGroup and not scanFuncSpellIdGroup and not scanFuncGeneralGroup then
      if matchDataUpToDate[unit] then
        matchDataUpToDate[unit][filter] = nil
      end
      CleanUpOutdatedMatchData(1, unit, filter)
      return
    end

    if UnitExistsFixed(unit) then
      if newAPI then
        -- copy parameters passed to ScanUnitWithFilter in parent's scope for HandleAura
        _matchDataChanged, _time, _unit, _filter, _scanFuncNameGroup, _scanFuncSpellIdGroup, _scanFuncGeneralGroup, _scanFuncName, _scanFuncSpellId, _scanFuncGeneral = matchDataChanged, time, unit, filter, scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup, scanFuncName, scanFuncSpellId, scanFuncGeneral
        if unitAuraUpdateInfo then
          -- incremental
          if unitAuraUpdateInfo.addedAuras ~= nil then
            for _, aura in ipairs(unitAuraUpdateInfo.addedAuras) do
              if (aura.isHelpful and filter == "HELPFUL") or (aura.isHarmful and filter == "HARMFUL") then
                HandleAura(aura)
              end
            end
          end

          if unitAuraUpdateInfo.updatedAuraInstanceIDs ~= nil then
            for _, auraInstanceID in ipairs(unitAuraUpdateInfo.updatedAuraInstanceIDs) do
              local aura = C_UnitAuras.GetAuraDataByAuraInstanceID(unit, auraInstanceID)
              if aura and ((aura.isHelpful and filter == "HELPFUL") or (aura.isHarmful and filter == "HARMFUL")) then
                HandleAura(aura)
              end
            end
          end

          if unitAuraUpdateInfo.removedAuraInstanceIDs ~= nil then
            for _, auraInstanceID in ipairs(unitAuraUpdateInfo.removedAuraInstanceIDs) do
              if matchData[unit] and matchData[unit][filter] then
                local data = matchData[unit][filter][auraInstanceID]
                if data then
                  matchData[unit][filter][auraInstanceID] = nil
                  for id, triggerData in pairs(data.auras) do
                    for triggernum in pairs(triggerData) do
                      matchDataByTrigger[id][triggernum][unit][auraInstanceID] = nil
                      matchDataChanged[id] = matchDataChanged[id] or {}
                      matchDataChanged[id][triggernum] = true
                    end
                  end
                  if data.dataInstanceID then
                    TooltipHelper:Untrack(data.dataInstanceID, data)
                  end
                end
              end
            end
          end
        else
          -- full
          -- clean first
          CleanUpOutdatedMatchData(nil, unit, filter)
          AuraUtil.ForEachAura(unit, filter, nil, HandleAura, true)
        end
      else
        local index = 1
        while true do
          local name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, isBossDebuff, isCastByPlayer, _, modRate = UnitAura(unit, index, filter)
          if not name then
            break
          end

          debuffClass = FixDebuffClass(debuffClass, spellId)

          local updatedMatchData = UpdateMatchData(time, matchDataChanged, unit, index, nil, filter, name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, isBossDebuff, isCastByPlayer, spellId, modRate, nil)

          if updatedMatchData then -- Aura data changed, check against triggerInfos
            CheckScanFuncs(scanFuncName and scanFuncName[name], unit, filter, index)
            CheckScanFuncs(scanFuncNameGroup and scanFuncNameGroup[name], unit, filter, index)
            CheckScanFuncs(scanFuncSpellId and scanFuncSpellId[spellId], unit, filter, index)
            CheckScanFuncs(scanFuncSpellIdGroup and scanFuncSpellIdGroup[spellId], unit, filter, index)
            CheckScanFuncs(scanFuncGeneral, unit, filter, index)
            CheckScanFuncs(scanFuncGeneralGroup, unit, filter, index)
          end
          index = index + 1
        end

        CleanUpOutdatedMatchData(index, unit, filter)
      end
    end

    matchDataUpToDate[unit] = matchDataUpToDate[unit] or {}
    matchDataUpToDate[unit][filter] = true
  end
end

local function UpdateStates(matchDataChanged, time)
  for id, auraData in pairs(matchDataChanged) do
    Private.StartProfileAura(id)
    local updated = false
    for triggernum in pairs(auraData) do
      updated = UpdateTriggerState(time, id, triggernum) or updated
    end
    if updated then
      Private.UpdatedTriggerState(id)
    end
    Private.StopProfileAura(id)
  end
end

local function ScanGroupRoleScanFunc(matchDataChanged)
  for id, idData in pairs(groupRoleScanFunc) do
    matchDataChanged[id] = matchDataChanged[id] or {}
    for _, triggerInfo in ipairs(idData) do
      matchDataChanged[id][triggerInfo.triggernum] = true
    end
  end
end

local function ScanRaidMarkScanFunc(matchDataChanged)
  for id, idData in pairs(raidMarkScanFuncs) do
    matchDataChanged[id] = matchDataChanged[id] or {}
    for _, triggerInfo in ipairs(idData) do
      matchDataChanged[id][triggerInfo.triggernum] = true
    end
  end
end

local function ScanGroupUnit(time, matchDataChanged, unitType, unit, unitAuraUpdateInfo)
  local unitExists = UnitExistsFixed(unit)
  if existingUnits[unit] ~= unitExists then
    existingUnits[unit] = unitExists

    if unitExistScanFunc[unit] then
      for id, idData in pairs(unitExistScanFunc[unit]) do
        matchDataChanged[id] = matchDataChanged[id] or {}
        for _, triggerInfo in ipairs(idData) do
          matchDataChanged[id][triggerInfo.triggernum] = true
        end
      end
    end
  end

  scanFuncName[unit] = scanFuncName[unit] or {}
  scanFuncSpellId[unit] = scanFuncSpellId[unit] or {}
  scanFuncGeneral[unit] = scanFuncGeneral[unit] or {}
  if unitType then
    scanFuncNameGroup[unit] = scanFuncNameGroup[unit] or {}
    scanFuncSpellIdGroup[unit] = scanFuncSpellIdGroup[unit] or {}
    scanFuncGeneralGroup[unit] = scanFuncGeneralGroup[unit] or {}

    ScanUnitWithFilter(matchDataChanged, time, unit, "HELPFUL", unitAuraUpdateInfo,
      scanFuncNameGroup[unit]["HELPFUL"],
      scanFuncSpellIdGroup[unit]["HELPFUL"],
      scanFuncGeneralGroup[unit]["HELPFUL"],
      scanFuncName[unit]["HELPFUL"],
      scanFuncSpellId[unit]["HELPFUL"],
      scanFuncGeneral[unit]["HELPFUL"])

    ScanUnitWithFilter(matchDataChanged, time, unit, "HARMFUL", unitAuraUpdateInfo,
      scanFuncNameGroup[unit]["HARMFUL"],
      scanFuncSpellIdGroup[unit]["HARMFUL"],
      scanFuncGeneralGroup[unit]["HARMFUL"],
      scanFuncName[unit]["HARMFUL"],
      scanFuncSpellId[unit]["HARMFUL"],
      scanFuncGeneral[unit]["HARMFUL"])
  else
    ScanUnitWithFilter(matchDataChanged, time, unit, "HELPFUL", unitAuraUpdateInfo, nil, nil, nil,
      scanFuncName[unit]["HELPFUL"],
      scanFuncSpellId[unit]["HELPFUL"],
      scanFuncGeneral[unit]["HELPFUL"])

    ScanUnitWithFilter(matchDataChanged, time, unit, "HARMFUL", unitAuraUpdateInfo, nil, nil, nil,
      scanFuncName[unit]["HARMFUL"],
      scanFuncSpellId[unit]["HARMFUL"],
      scanFuncGeneral[unit]["HARMFUL"])
  end
end

local function UnitToUnitType(unit)
  if (Private.multiUnitUnits.raid[unit] and IsInRaid()) then
    return "group"
  elseif (Private.multiUnitUnits.party[unit] and not IsInRaid()) then
    return "group"
  elseif Private.multiUnitUnits.boss[unit] then
    return "boss", unit
  elseif Private.multiUnitUnits.arena[unit] then
    return "arena"
  elseif unit:sub(1, 9) == "nameplate" then
    return "nameplate"
  else
    return nil
  end
end

local function ScanUnit(time, unit, unitAuraUpdateInfo)
  ScanGroupUnit(time, matchDataChanged, UnitToUnitType(unit), unit, unitAuraUpdateInfo)
end

local function AddScanFuncs(triggerInfo, filter, unit, scanFuncName, scanFuncSpellId, scanFuncGeneral)
  if triggerInfo.auranames then
    for _, name in ipairs(triggerInfo.auranames) do
      if name ~= "" then
        local base = unit and GetOrCreateSubTable(scanFuncName, unit, filter, name) or GetOrCreateSubTable(scanFuncName, filter, name)
        base[triggerInfo] = true
      end
    end
  end

  if triggerInfo.auraspellids then
    for _, spellId in ipairs(triggerInfo.auraspellids) do
      local base = unit and GetOrCreateSubTable(scanFuncSpellId, unit, filter, spellId) or GetOrCreateSubTable(scanFuncSpellId, filter, spellId)
      base[triggerInfo] = true
    end
  end

  if not triggerInfo.auranames and not triggerInfo.auraspellids and scanFuncGeneral then
    local base = GetOrCreateSubTable(scanFuncGeneral, unit, filter)
    base[triggerInfo] = true
  end

  if unit then
    PrepareMatchData(unit, filter)
    ScanMatchData(GetTime(), triggerInfo, unit, filter)
  end
end

local function RemoveScanFuncs(triggerInfo, filter, unit, scanFuncName, scanFuncSpellId, scanFuncGeneral)
  if triggerInfo.auranames then
    for _, name in ipairs(triggerInfo.auranames) do
      if name ~= "" then
        local base = unit and GetSubTable(scanFuncName, unit, filter, name) or GetSubTable(scanFuncName, filter, name)
        if base then
          base[triggerInfo] = nil
        end
      end
    end
  end

  if triggerInfo.auraspellids then
    for _, spellId in ipairs(triggerInfo.auraspellids) do
      local base = unit and GetSubTable(scanFuncSpellId, unit, filter, spellId) or GetSubTable(scanFuncSpellId, filter, spellId)
      if base then
        base[triggerInfo] = nil
      end
    end
  end

  if not triggerInfo.auranames and not triggerInfo.auraspellids and scanFuncGeneral then
    local base = GetSubTable(scanFuncGeneral, unit, filter)
    if base then
      base[triggerInfo] = nil
    end
  end
end

local function RecheckActive(triggerInfo, unit, unitsToRemoveScan)
  local isSelf, role, inParty, class
  local unitExists = UnitExistsFixed(unit)
  if unitExists and TriggerInfoApplies(triggerInfo, unit) then
    if (not activeGroupScanFuncs[unit] or not activeGroupScanFuncs[unit][triggerInfo]) then
      triggerInfo.maxUnitCount = triggerInfo.maxUnitCount + 1
      if triggerInfo.debuffType == "BOTH" then
        AddScanFuncs(triggerInfo, "HELPFUL", unit, scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup)
        AddScanFuncs(triggerInfo, "HARMFUL", unit, scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup)
      else
        AddScanFuncs(triggerInfo, triggerInfo.debuffType, unit, scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup)
      end

      activeGroupScanFuncs[unit] = activeGroupScanFuncs[unit] or {}
      activeGroupScanFuncs[unit][triggerInfo] = true
      matchDataChanged[triggerInfo.id] = matchDataChanged[triggerInfo.id] or {}
      matchDataChanged[triggerInfo.id][triggerInfo.triggernum] = true
    end
  else
    -- Either the unit doesn't exist or the TriggerInfo no longer applies
    if activeGroupScanFuncs[unit] and activeGroupScanFuncs[unit][triggerInfo] then
      triggerInfo.maxUnitCount = triggerInfo.maxUnitCount - 1
      if triggerInfo.debuffType == "BOTH" then
        RemoveScanFuncs(triggerInfo, "HELPFUL", unit, scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup)
        RemoveScanFuncs(triggerInfo, "HARMFUL", unit, scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup)
      else
        RemoveScanFuncs(triggerInfo, triggerInfo.debuffType, unit, scanFuncNameGroup, scanFuncSpellIdGroup, scanFuncGeneralGroup)
      end
      if unitsToRemoveScan then
        unitsToRemoveScan[unit] = unitsToRemoveScan[unit] or {}
        unitsToRemoveScan[unit][triggerInfo] = true
      end
      activeGroupScanFuncs[unit][triggerInfo] = nil
      matchDataChanged[triggerInfo.id] = matchDataChanged[triggerInfo.id] or {}
      matchDataChanged[triggerInfo.id][triggerInfo.triggernum] = true
    end
  end
end

local function RecheckActiveForUnitType(unitType, unit, unitsToRemoveScan)
  if groupScanFuncs[unitType] then
    for i, triggerInfo in ipairs(groupScanFuncs[unitType]) do
      RecheckActive(triggerInfo, unit, unitsToRemoveScan)
    end
  end
end

local Buff2Frame = CreateFrame("Frame")
Private.frames["WeakAuras Buff2 Frame"] = Buff2Frame

local brokenUnitMap = {
  arena1 = "boss6",
  arena2 = "boss7",
  arena3 = "boss8",
  arena4 = "boss9",
  arena5 = "boss10"
}

local function EventHandler(frame, event, arg1, arg2, ...)
  Private.StartProfileSystem("bufftrigger2 - ".. event)
  local deactivatedTriggerInfos = {}
  local unitsToRemove = {}

  local time = GetTime()
  local targetUnit = Private.player_target_events[event]
  if targetUnit then
    ScanGroupUnit(time, matchDataChanged, nil, targetUnit)
    if not UnitExistsFixed(targetUnit) then
      tinsert(unitsToRemove, targetUnit)
    end
  elseif event == "UNIT_PET" then
    local pet = WeakAuras.unitToPetUnit[arg1]
    if pet then
      ScanGroupUnit(time, matchDataChanged, "group", pet)
      RecheckActiveForUnitType("group", pet, deactivatedTriggerInfos)
      if not UnitExistsFixed(pet) then
        tinsert(unitsToRemove, pet)
      end
    end
  elseif event == "NAME_PLATE_UNIT_ADDED" then
    nameplateExists[arg1] = UnitGUID(arg1)
    RecheckActiveForUnitType("nameplate", arg1, deactivatedTriggerInfos)
  elseif event == "NAME_PLATE_UNIT_REMOVED" then
    nameplateExists[arg1] = false
    RecheckActiveForUnitType("nameplate", arg1, deactivatedTriggerInfos)
    tinsert(unitsToRemove, arg1)
  elseif event == "UNIT_FACTION" then
    if arg1:sub(1, 9) == "nameplate" then
      RecheckActiveForUnitType("nameplate", arg1, deactivatedTriggerInfos)
    end
  elseif event == "ENCOUNTER_START" or event == "ENCOUNTER_END" or event == "INSTANCE_ENCOUNTER_ENGAGE_UNIT" then
    for unit in GetAllUnits("boss", true) do
      RecheckActiveForUnitType("boss", unit, deactivatedTriggerInfos)
      if not UnitExistsFixed(unit) then
        tinsert(unitsToRemove, unit)
      else
        if newAPI then
          ScanUnit(time, unit)
        end
      end
    end
  elseif event =="ARENA_OPPONENT_UPDATE" then
    for unit in GetAllUnits("arena", true) do
      RecheckActiveForUnitType("arena", unit, deactivatedTriggerInfos)
      if not UnitExistsFixed(unit) then
        tinsert(unitsToRemove, unit)
      end
    end
  elseif event == "GROUP_ROSTER_UPDATE" then
    unitVisible = {}
    for unit in GetAllUnits("group", true, "PlayersAndPets") do
      RecheckActiveForUnitType("group", unit, deactivatedTriggerInfos)
      local exists = UnitExistsFixed(unit)
      if not exists then
        tinsert(unitsToRemove, unit)
      else
        ScanGroupUnit(time, matchDataChanged, "group", unit, nil)
      end
    end
    ScanGroupRoleScanFunc(matchDataChanged)
  elseif event == "UNIT_FLAGS" or event == "UNIT_NAME_UPDATE" or event == "PLAYER_FLAGS_CHANGED"
      or event == "PARTY_MEMBER_ENABLE" or event == "PARTY_MEMBER_DISABLE"
  then
    if event == "PARTY_MEMBER_ENABLE" then
      unitVisible[arg1] = true
    elseif event == "PARTY_MEMBER_DISABLE" then
      unitVisible[arg1] = false
    end
    if Private.multiUnitUnits.group[arg1] then
      RecheckActiveForUnitType("group", arg1, deactivatedTriggerInfos)
    end
  elseif event == "UNIT_ENTERED_VEHICLE" or event == "UNIT_EXITED_VEHICLE" then
    if arg1 == "player" then
      ScanGroupUnit(time, matchDataChanged, nil, "vehicle")
    end
  elseif event == "UNIT_AURA" then
    if brokenUnitMap[arg1] and not UnitExists(arg1) then
      arg1 = brokenUnitMap[arg1]
    end

    if newAPI then
      -- arg1: unit
      -- arg2: unitAuraUpdateInfo
      if arg2 == nil or arg2.isFullUpdate then
        ScanUnit(time, arg1)
      else
        ScanUnit(time, arg1, arg2)
      end
    else
      ScanUnit(time, arg1)
    end
  elseif event == "PLAYER_ENTERING_WORLD" then
    for unit in pairs(matchData) do
      ScanUnit(time, unit)
      if not UnitExistsFixed(unit) then
        tinsert(unitsToRemove, unit)
      end
    end

    if arg1 then
      -- Initial login has an where the tooltip information is not available,
      -- so update tooltips 2s after login.
      -- With newApi we have TOOLTIP_DATA_UPDATE to update the tooltips
      if not newAPI then
        C_Timer.After(3, function()
          for unit, matchDataPerUnit in pairs(matchData) do
            EventHandler(frame, "UNIT_AURA", unit)
          end
        end)
      end
    end

  elseif event == "RAID_TARGET_UPDATE" then
    ScanRaidMarkScanFunc(matchDataChanged)
  elseif event == "UNIT_TARGETABLE_CHANGED" then
    local exists = UnitExistsFixed(arg1)
    if not exists then
      tinsert(unitsToRemove, arg1)
    else
      ScanUnit(time, arg1)
    end
  elseif event == "UNIT_IN_RANGE_UPDATE" then
    local unitType = UnitToUnitType(arg1)
    if rangeScanFuncs[unitType] then
      for _, triggerInfo in ipairs(rangeScanFuncs[unitType]) do
        RecheckActive(triggerInfo, arg1, deactivatedTriggerInfos)
      end
    end
  end

  DeactivateScanFuncs(deactivatedTriggerInfos)

  for i, unit in ipairs(unitsToRemove) do
    CleanUpMatchDataForUnit(unit, "HELPFUL")
    CleanUpMatchDataForUnit(unit, "HARMFUL")
    matchDataUpToDate[unit] = nil
  end

  Private.StopProfileSystem("bufftrigger2 - ".. event)
end

if WeakAuras.IsCataOrMistsOrRetail() then
  Private.LibSpecWrapper.Register(function(unit)
    Private.StartProfileSystem("bufftrigger2 - LibSpecWrapper")

    local deactivatedTriggerInfos = {}
    RecheckActiveForUnitType("group", unit, deactivatedTriggerInfos)
    RecheckActiveForUnitType("group", WeakAuras.unitToPetUnit[unit], deactivatedTriggerInfos)
    DeactivateScanFuncs(deactivatedTriggerInfos)

    Private.StopProfileSystem("bufftrigger2 - LibSpecWrapper")
  end)
end

Buff2Frame:RegisterEvent("UNIT_AURA")
Buff2Frame:RegisterEvent("UNIT_FACTION")
Buff2Frame:RegisterEvent("UNIT_NAME_UPDATE")
Buff2Frame:RegisterEvent("UNIT_FLAGS")
Buff2Frame:RegisterEvent("PLAYER_FLAGS_CHANGED")
Buff2Frame:RegisterEvent("UNIT_PET")
Buff2Frame:RegisterEvent("RAID_TARGET_UPDATE")
Buff2Frame:RegisterEvent("PLAYER_SOFT_ENEMY_CHANGED")
Buff2Frame:RegisterEvent("PLAYER_SOFT_FRIEND_CHANGED")
if WeakAuras.IsCataOrMistsOrRetail() then
  Buff2Frame:RegisterEvent("PLAYER_FOCUS_CHANGED")
  Buff2Frame:RegisterEvent("ARENA_OPPONENT_UPDATE")
  Buff2Frame:RegisterEvent("UNIT_ENTERED_VEHICLE")
  Buff2Frame:RegisterEvent("UNIT_EXITED_VEHICLE")
end
Buff2Frame:RegisterEvent("PLAYER_TARGET_CHANGED")
Buff2Frame:RegisterEvent("ENCOUNTER_START")
Buff2Frame:RegisterEvent("ENCOUNTER_END")
Buff2Frame:RegisterEvent("INSTANCE_ENCOUNTER_ENGAGE_UNIT")
Buff2Frame:RegisterEvent("NAME_PLATE_UNIT_ADDED")
Buff2Frame:RegisterEvent("NAME_PLATE_UNIT_REMOVED")
Buff2Frame:RegisterEvent("GROUP_ROSTER_UPDATE")
Buff2Frame:RegisterEvent("PLAYER_ENTERING_WORLD")
Buff2Frame:RegisterEvent("PARTY_MEMBER_DISABLE")
Buff2Frame:RegisterEvent("PARTY_MEMBER_ENABLE")
Buff2Frame:RegisterEvent("UNIT_TARGETABLE_CHANGED")
Buff2Frame:SetScript("OnEvent", EventHandler)

-- For UNIT_IN_RANGE_UPDATE Blizzard apparently checks whether anyone
-- has called RegisterUnitEvent() for it. They probably do that so that they
-- don't have to check in the background
-- We register if we have a trigger with InRange checking enabled loaded
--- @class perUnitFrames
local PerUnitFrames = {
  --- @type table<string, frame>
  frames = {

  },
  --- @type table<string, table<string, {player: number?, pet: number?}>>
  unitTypePetMode = {

  },
  --- @type fun(self: perUnitFrames, unitType: string, event: string, petMode: "PlayersAndPets"|"PetsOnly"|nil)
  Register = function(self, unitType, event, petMode)
    -- We check whether we are already registered for the given pet mode,
    -- and unregister as needed by tracking the number of calls to Register with different
    -- petModes
    -- All of the dancing is to not register for UNIT_IN_RANGE_UPDATE for pets unless explicitly asked for
    local unitTypePetMode = GetOrCreateSubTable(self.unitTypePetMode, event, unitType)
    --- @type any
    local mode = false
    unitTypePetMode.player = unitTypePetMode.player or 0
    unitTypePetMode.pet = unitTypePetMode.pet or 0
    if petMode == nil then
      if unitTypePetMode.player == 0 then
        mode = nil -- Because that's the value GetAllUnits expects
      end
      unitTypePetMode.player = unitTypePetMode.player + 1
    elseif petMode == "PetsOnly" then
      if unitTypePetMode.pet == 0 then
        mode = "PetsOnly"
      end
      unitTypePetMode.pet = unitTypePetMode.pet + 1
    elseif petMode == "PlayersAndPets" then
      self:Register(unitType, event, nil)
      self:Register(unitType, event, "PetsOnly")
      return
    end

    if mode ~= false then
      for unit in GetAllUnits(unitType, true, mode) do
        if not self.frames[unit] then
          self.frames[unit] = CreateFrame("Frame")
          self.frames[unit]:SetScript("OnEvent", EventHandler)
        end
        self.frames[unit]:RegisterUnitEvent(event, unit)
      end
    end
  end,
  --- @type fun(self: perUnitFrames, unitType: string, event: string, petMode: "PlayersAndPets"|"PetsOnly"|nil)
  Unregister = function(self, unitType, event, petMode)
    local unitTypePetMode = GetSubTable(self.unitTypePetMode, event, unitType)
    if not unitTypePetMode then
      -- Shouldn't happen
      return
    end
    --- @type any
    local mode = false
    if petMode == nil then
      unitTypePetMode.player = unitTypePetMode.player - 1
      if unitTypePetMode.player == 0 then
        mode = nil
      end
    elseif petMode == "PetsOnly" then
      unitTypePetMode.pet = unitTypePetMode.pet - 1
      if unitTypePetMode.pet == 0 then
        mode = "PetsOnly"
      end
    elseif petMode == "PlayersAndPets" then
      self:Unregister(unitType, event, nil)
      self:Unregister(unitType, event, "PetsOnly")
      return
    end

    if mode ~= false then
      for unit in GetAllUnits(unitType, true, mode) do
        if self.frames[unit] then
          self.frames[unit]:UnregisterEvent(event)
        end
      end
    end
  end,
  --- @type fun(self: perUnitFrames)
  UnregisterAll = function(self)
    for _, frame in pairs(self.frames) do
      frame:UnregisterAllEvents()
    end
    self.unitTypePetMode = {}
  end
}

Buff2Frame:SetScript("OnUpdate", function()
  if WeakAuras.IsPaused() then
    return
  end
  Private.StartProfileSystem("bufftrigger2 - OnUpdate")
  if next(matchDataChanged) then
    local time = GetTime()
    UpdateStates(matchDataChanged, time)
    wipe(matchDataChanged)
  end
  Private.StopProfileSystem("bufftrigger2 - OnUpdate")
end)

local function UnloadAura(scanFuncName, id)
  for unit, unitData in pairs(scanFuncName) do
    for debuffType, debuffData in pairs(unitData) do
      for name, nameData in pairs(debuffData) do
        for triggerInfo in pairs(nameData) do
          if triggerInfo.id == id or not id then
            if triggerInfo.nextScheduledCheckHandle then
              timer:CancelTimer(triggerInfo.nextScheduledCheckHandle)
              triggerInfo.nextScheduledCheck = nil
              triggerInfo.nextScheduledCheckHandle = nil
            end
            nameData[triggerInfo] = nil
          end
        end
        if not next(nameData) then
          debuffData[name] = nil
        end
      end

      if not next(debuffData) then
        unitData[debuffType] = nil
      end
    end
    if not next(unitData) then
      scanFuncName[unit] = nil
    end
  end
end

local function UnloadGeneral(scanFuncGeneral, id)
  for unit, unitData in pairs(scanFuncGeneral) do
    for debuffType, debuffData in pairs(unitData) do
      for triggerInfo in pairs(debuffData) do
        if triggerInfo.id == id or not id then
          if triggerInfo.nextScheduledCheckHandle then
            timer:CancelTimer(triggerInfo.nextScheduledCheckHandle)
            triggerInfo.nextScheduledCheck = nil
            triggerInfo.nextScheduledCheckHandle = nil
          end
          debuffData[triggerInfo] = nil
        end
      end
      if not next(debuffData) then
        unitData[debuffType] = nil
      end
    end
    if not next(unitData) then
      scanFuncGeneral[unit] = nil
    end
  end
end

function BuffTrigger.UnloadAll()
  UnloadAura(scanFuncName, nil)
  UnloadAura(scanFuncSpellId, nil)
  UnloadGeneral(scanFuncGeneral, nil)

  for unit, unitData in pairs(matchData) do
    for filter, filterData in pairs(unitData) do
      for index, indexData in pairs(filterData) do
        wipe(indexData.auras)
      end
    end
  end

  if WeakAuras.IsRetail() then
    -- TODO change this when more events are handled by system, or when range check will be supported on other version than Retail
    PerUnitFrames:UnregisterAll()
  end

  if newAPI then
    TooltipHelper:Clear()
  end

  wipe(scanFuncName)
  wipe(scanFuncSpellId)
  wipe(scanFuncGeneral)
  wipe(scanFuncNameGroup)
  wipe(scanFuncSpellIdGroup)
  wipe(scanFuncGeneralGroup)
  wipe(scanFuncNameMulti)
  wipe(scanFuncSpellIdMulti)
  wipe(unitExistScanFunc)
  wipe(groupRoleScanFunc)
  wipe(groupScanFuncs)
  wipe(rangeScanFuncs)
  wipe(raidMarkScanFuncs)
  wipe(matchDataByTrigger)
  wipe(matchDataMulti)
  wipe(matchDataChanged)
  wipe(activeGroupScanFuncs)
end


local function LoadAura(id, triggernum, triggerInfo)
  if not triggerInfo.unit then
    return
  end
  local time = GetTime();

  local unitsToCheck = {}

  if triggerInfo.unit == "multi" then
    if triggerInfo.debuffType == "BOTH" then
      AddScanFuncs(triggerInfo, "HELPFUL", nil, scanFuncNameMulti, scanFuncSpellIdMulti, nil)
      AddScanFuncs(triggerInfo, "HARMFUL", nil, scanFuncNameMulti, scanFuncSpellIdMulti, nil)
    else
      AddScanFuncs(triggerInfo, triggerInfo.debuffType, nil, scanFuncNameMulti, scanFuncSpellIdMulti, nil)
    end
  elseif triggerInfo.groupTrigger then
    triggerInfo.maxUnitCount = 0
    for unit in GetAllUnits(triggerInfo.unit, nil, triggerInfo.includePets) do
      RecheckActive(triggerInfo, unit, unitsToCheck)
    end
  else
    if triggerInfo.debuffType == "BOTH" then
      AddScanFuncs(triggerInfo, "HELPFUL", triggerInfo.unit, scanFuncName, scanFuncSpellId, scanFuncGeneral)
      AddScanFuncs(triggerInfo, "HARMFUL", triggerInfo.unit, scanFuncName, scanFuncSpellId, scanFuncGeneral)
    else
      AddScanFuncs(triggerInfo, triggerInfo.debuffType, triggerInfo.unit, scanFuncName, scanFuncSpellId, scanFuncGeneral)
    end
    unitsToCheck[triggerInfo.unit] = true
  end

  if triggerInfo.unitExists ~= nil then
    unitExistScanFunc[triggerInfo.unit] = unitExistScanFunc[triggerInfo.unit] or {}
    unitExistScanFunc[triggerInfo.unit][id] = unitExistScanFunc[triggerInfo.unit][id] or {}
    tinsert(unitExistScanFunc[triggerInfo.unit][id], triggerInfo)

    if existingUnits[triggerInfo.unit] == nil then
      existingUnits[triggerInfo.unit] = UnitExistsFixed(triggerInfo.unit)
    end
  end

  if triggerInfo.fetchRole then
    groupRoleScanFunc[id] = groupRoleScanFunc[id] or {}
    tinsert(groupRoleScanFunc[id], triggerInfo)
  end

  if triggerInfo.fetchRaidMark then
    raidMarkScanFuncs[id] = raidMarkScanFuncs[id]  or {}
    tinsert(raidMarkScanFuncs[id], triggerInfo)
  end

  if triggerInfo.groupTrigger then
    groupScanFuncs[triggerInfo.unit] = groupScanFuncs[triggerInfo.unit] or {}
    tinsert(groupScanFuncs[triggerInfo.unit], triggerInfo)
  end

  if triggerInfo.inRange then
    rangeScanFuncs[triggerInfo.unit] = rangeScanFuncs[triggerInfo.unit] or {}
    PerUnitFrames:Register(triggerInfo.unit, "UNIT_IN_RANGE_UPDATE", triggerInfo.includePets)
    tinsert(rangeScanFuncs[triggerInfo.unit], triggerInfo)
  end

  matchDataChanged[id] = matchDataChanged[id] or {}
  matchDataChanged[id][triggernum] = true
end

function BuffTrigger.LoadDisplays(toLoad)
  for id in pairs(toLoad) do
    if triggerInfos[id] then
      for triggernum, triggerInfo in pairs(triggerInfos[id]) do
        LoadAura(id, triggernum, triggerInfo)
      end
    end
  end
end


function BuffTrigger.UnloadDisplays(toUnload)
  local updateGroupScanFuncs = false
  for id in pairs(toUnload) do
    UnloadAura(scanFuncName, id)
    UnloadAura(scanFuncSpellId, id)
    UnloadGeneral(scanFuncGeneral, id)

    UnloadAura(scanFuncNameGroup, id)
    UnloadAura(scanFuncSpellIdGroup, id)
    UnloadGeneral(scanFuncGeneralGroup, id)

    UnloadGeneral(scanFuncNameMulti, id)
    UnloadGeneral(scanFuncSpellIdMulti, id)

    for unit, unitData in pairs(unitExistScanFunc) do
      unitData[id] = nil
    end

    groupRoleScanFunc[id] = nil
    raidMarkScanFuncs[id] = nil

    for unit, unitData in pairs(matchData) do
      for filter, filterData in pairs(unitData) do
        for index, indexData in pairs(filterData) do
          indexData.auras[id] = nil
        end
      end
    end
    matchDataByTrigger[id] = nil

    for guid, guidData in pairs(matchDataMulti) do
      for key, data in pairs(matchDataMulti[guid]) do
        for source, sourceData in pairs(data) do
          sourceData.auras[id] = nil
        end
      end
    end
    matchDataChanged[id] = nil
  end

  for unitType, funcs in pairs(groupScanFuncs) do
    for i = #funcs, 1, -1 do
      if toUnload[funcs[i].id] then
        tremove(funcs, i)
      end
    end
  end

  for unitType, funcs in pairs(rangeScanFuncs) do
    for i = #funcs, 1, -1 do
      if toUnload[funcs[i].id] then
        PerUnitFrames:Unregister(unitType, "UNIT_IN_RANGE_UPDATE", funcs[i].includePets)
        tremove(funcs, i)
      end
    end
  end

  for unit, unitData in pairs(activeGroupScanFuncs) do
    for triggerInfo in pairs(unitData) do
      if toUnload[triggerInfo.id] then
        unitData[triggerInfo] = nil
      end
    end
  end

end

function BuffTrigger.FinishLoadUnload()
  -- Nothing!
end

--- Removes all data for an aura id
--- @param id number
function BuffTrigger.Delete(id)
  triggerInfos[id] = nil
end

--- Updates all data for aura oldid to use newid
--- @param oldid number
--- @param newid number
function BuffTrigger.Rename(oldid, newid)
  triggerInfos[newid] = triggerInfos[oldid]
  triggerInfos[oldid] = nil

  if triggerInfos[newid] then
    for triggernum, triggerData in pairs(triggerInfos[newid]) do
      triggerData.id = newid
    end
  end

  matchDataByTrigger[newid] = matchDataByTrigger[oldid]
  matchDataByTrigger[oldid] = nil

  for unit, unitData in pairs(matchData) do
    for filter, filterData in pairs(unitData) do
      for index, indexData in pairs(filterData) do
        indexData.auras[newid] = indexData.auras[oldid]
        indexData.auras[oldid] = nil
      end
    end
  end

  for unit, unitData in pairs(unitExistScanFunc) do
    unitData[newid] = unitData[oldid]
    unitData[oldid] = nil
  end
  groupRoleScanFunc[newid] = groupRoleScanFunc[oldid]
  groupRoleScanFunc[oldid] = nil
  raidMarkScanFuncs[newid] = raidMarkScanFuncs[oldid]
  raidMarkScanFuncs[oldid] = nil
  matchDataChanged[newid] = matchDataChanged[oldid]
  matchDataChanged[oldid] = nil
end

local function createScanFunc(trigger)
  local canHaveMatchCheck = CanHaveMatchCheck(trigger)
  local isMulti = trigger.unit == "multi"
  local useStacks = canHaveMatchCheck and not isMulti and trigger.useStacks

  local use_stealable, use_isBossDebuff, use_castByPlayer
  if canHaveMatchCheck and not isMulti then
    use_stealable = trigger.use_stealable
    use_isBossDebuff = trigger.use_isBossDebuff
    use_castByPlayer = trigger.use_castByPlayer
  end
  local use_debuffClass = canHaveMatchCheck and not isMulti and trigger.use_debuffClass
  local use_tooltip = canHaveMatchCheck and not isMulti and trigger.fetchTooltip and trigger.use_tooltip
  local use_tooltipValue = canHaveMatchCheck and not isMulti and trigger.fetchTooltip and trigger.use_tooltipValue
  local use_total = canHaveMatchCheck and not isMulti and trigger.useTotal and trigger.total
  local use_ignore_name = canHaveMatchCheck and not isMulti and trigger.useIgnoreName and trigger.ignoreAuraNames
  local use_ignore_spellId = canHaveMatchCheck and not isMulti and trigger.useIgnoreExactSpellId and trigger.ignoreAuraSpellids

  if not useStacks and use_stealable == nil and use_isBossDebuff == nil and use_castByPlayer == nil
       and not use_debuffClass and trigger.ownOnly == nil
       and not use_tooltip and not use_tooltipValue and not trigger.useNamePattern and not use_total
       and not use_ignore_name and not use_ignore_spellId then
    return nil
  end

  local preamble = {""}

  local ret = {[=[
    return function(time, matchData)
  ]=]}

  if use_total then
    local ret2 = [=[
      if not(matchData.duration / matchData.modRate %s %s) then
        return false
      end
    ]=]
    table.insert(ret, ret2:format(trigger.totalOperator or ">=", tonumber(trigger.total) or 0))
  end

  if useStacks then
    local ret2 = [=[
      if not(matchData.stacks %s %s) then
        return false
      end
    ]=]
    table.insert(ret, ret2:format(trigger.stacksOperator or ">=", tonumber(trigger.stacks) or 0))
  end

  if use_stealable then
    table.insert(ret, [=[
      if not matchData.isStealable then
        return false
      end
    ]=])
  elseif use_stealable == false then
    table.insert(ret, [=[
      if matchData.isStealable then
        return false
      end
    ]=])
  end

  if use_isBossDebuff then
    table.insert(ret, [=[
      if not matchData.isBossDebuff then
        return false
      end
    ]=])
  elseif use_isBossDebuff == false then
    table.insert(ret, [=[
      if matchData.isBossDebuff then
        return false
      end
    ]=])
  end

  if use_castByPlayer then
    table.insert(ret, [=[
      if not matchData.isCastByPlayer then
        return false
      end
    ]=])
  elseif use_castByPlayer == false then
    table.insert(ret, [=[
      if matchData.isCastByPlayer then
        return false
      end
    ]=])
  end

  if use_debuffClass then
    local ret2 = [=[
      local tDebuffClass = %s;
      if not tDebuffClass[matchData.debuffClass] then
        return false
      end
    ]=]
    table.insert(ret, ret2:format(trigger.debuffClass and type(trigger.debuffClass) == "table" and Private.SerializeTable(trigger.debuffClass) or "{}"))
  end

  if trigger.ownOnly then
    table.insert(ret, [=[
      if matchData.unitCaster ~= 'player' and matchData.unitCaster ~= 'pet' and matchData.unitCaster ~= 'vehicle' then
        return false
      end
    ]=])
  elseif trigger.ownOnly == false then
    table.insert(ret, [=[
      if matchData.unitCaster == 'player' or matchData.unitCaster == 'pet' or matchData.unitCaster == 'vehicle' then
        return false
      end
    ]=])
  end

  if use_tooltip and trigger.tooltip_operator and trigger.tooltip then
    if trigger.tooltip_operator == "==" then
      local ret2 = [=[
      if not matchData.tooltip or matchData.tooltip ~= %s then
        return false
      end
      ]=]
      table.insert(ret, ret2:format(Private.QuotedString(trigger.tooltip)))
    elseif trigger.tooltip_operator == "find('%s')" then
      local ret2 = [=[
      if not matchData.tooltip or not matchData.tooltip:find(%s, 1, true) then
        return false
      end
      ]=]
      table.insert(ret, ret2:format(Private.QuotedString(trigger.tooltip)))
    elseif trigger.tooltip_operator == "match('%s')" then
      local ret2 = [=[
      if not matchData.tooltip or not matchData.tooltip:match(%s) then
        return false
      end
      ]=]
      table.insert(ret, ret2:format(Private.QuotedString(trigger.tooltip)))
    end
  end

  if use_tooltipValue and trigger.tooltipValueNumber and trigger.tooltipValue_operator and trigger.tooltipValue then
    local property = "tooltip" .. tonumber(trigger.tooltipValueNumber)
    local ret2 = [=[
      if not matchData.%s or not (matchData.%s %s %s) then
        return false
      end
    ]=]
    table.insert(ret, ret2:format(property, property, trigger.tooltipValue_operator, trigger.tooltipValue))
  end

  if trigger.useNamePattern and trigger.namePattern_operator and trigger.namePattern_name then
    if trigger.namePattern_operator == "==" then
      local ret2 = [=[
      if not matchData.name == %s then
        return false
      end
      ]=]
      table.insert(ret, ret2:format(Private.QuotedString(trigger.namePattern_name)))
    elseif trigger.namePattern_operator == "find('%s')" then
      local ret2 = [=[
      if not matchData.name:find(%s, 1, true) then
        return false
      end
      ]=]
      table.insert(ret, ret2:format(Private.QuotedString(trigger.namePattern_name)))
    elseif trigger.namePattern_operator == "match('%s')" then
      local ret2 = [=[
      if not matchData.name:match(%s) then
        return false
      end
      ]=]
      table.insert(ret, ret2:format(Private.QuotedString(trigger.namePattern_name)))
    end
  end

  if use_ignore_name then
    local names = {}
    for index, spellName in ipairs(trigger.ignoreAuraNames) do
      local spellId = WeakAuras.SafeToNumber(spellName)
      local name = spellId and Private.ExecEnv.GetSpellName(spellId) or spellName
      tinsert(names, name)
    end

    table.insert(preamble, "local ignoreNames = {\n")
    for index, name in ipairs(names) do
      table.insert(preamble, string.format("  [%q] = true,\n", name))
    end
    table.insert(preamble, "}\n")
    table.insert(ret, [=[
      if ignoreNames[matchData.name] then
        return false
      end
    ]=])
  end

  if use_ignore_spellId then
    table.insert(preamble, "local ignoreSpellId = {\n")
    for index, spellId in ipairs(trigger.ignoreAuraSpellids) do
      local spell = WeakAuras.SafeToNumber(spellId)
      if spell then
        table.insert(preamble, string.format("  [%s]  = true,\n", spell))
      end
    end
    table.insert(preamble, "}\n")
    table.insert(ret, [=[
      if ignoreSpellId[matchData.spellId] then
        return false
      end
    ]=])
  end

  table.insert(ret, [=[
      return true
    end
  ]=])

  local func, err = loadstring(table.concat(preamble) .. table.concat(ret))

  if func then
    return func()
  end
end

local matchCombineFunctions = {
  showHighest = function(bestMatch, auraMatch)
    if bestMatch.expirationTime and auraMatch.expirationTime then
      return auraMatch.expirationTime > bestMatch.expirationTime
    end
    return true
  end,
  showLowest = function(bestMatch, auraMatch)
    if bestMatch.expirationTime and auraMatch.expirationTime then
      return auraMatch.expirationTime < bestMatch.expirationTime
    end
    return false
  end,
  showLowestSpellId  = function(bestMatch, auraMatch)
    if bestMatch.spellId and auraMatch.spellId then
      return auraMatch.spellId < bestMatch.spellId
    end
    return false
  end,
  showHighestSpellId  = function(bestMatch, auraMatch)
    if bestMatch.spellId and auraMatch.spellId then
      return auraMatch.spellId > bestMatch.spellId
    end
    return false
  end,
}

local function GreaterEqualOne(x)
  return x >= 1
end

local function EqualZero(x)
  return x == 0
end

local function InitProblems()
  return {
    untrackableSoftTarget = {
      severity = "info",
      message = L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."],
      flagged = false,
      check = function(trigger)
        return WeakAuras.IsUntrackableSoftTarget(trigger.unit)
      end
    }
  }
end

local function CheckProblems(trigger, problems)
  for _, problem in pairs(problems) do
    if not problem.flagged and problem.check(trigger) then
      problem.flagged = true
      break
    end
  end
end

local function PublishProblems(problems, uid)
  for key, problem in pairs(problems) do
    if problem.flagged then
      Private.AuraWarnings.UpdateWarning(uid, key, problem.severity, problem.message, problem.printOnConsole)
    else
      Private.AuraWarnings.UpdateWarning(uid, key)
    end
  end
end

--- Adds an aura, setting up internal data structures for all buff triggers.
--- @param data auraData
function BuffTrigger.Add(data)
  local id = data.id

  triggerInfos[id] = nil
  local problems = InitProblems()
  for triggernum, triggerData in ipairs(data.triggers) do
    local trigger = triggerData.trigger
    if trigger.type == "aura2" then

      trigger.unit = trigger.unit or "player"
      trigger.debuffType = trigger.debuffType or "HELPFUL"

      local combineMode = "showOne"
      local perUnitMode

      CheckProblems(trigger, problems)

      if not IsSingleMissing(trigger) and trigger.showClones then
        if IsGroupTrigger(trigger) and trigger.combinePerUnit then
          combineMode = "showPerUnit"
          if trigger.unit == "multi" then
            perUnitMode = "affected"
          else
            perUnitMode = trigger.perUnitMode or "affected"
          end
        else
          combineMode = "showClones"
        end
      end

      local scanFunc = createScanFunc(trigger)

      local remFunc
      if trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useRem then
        local remFuncStr = Private.function_strings.count:format(trigger.remOperator or ">=", tonumber(trigger.rem) or 0)
        remFunc = Private.LoadFunction(remFuncStr, id)
      end

      local names
      if trigger.useName and trigger.auranames then
        names = {}
        for index, spellName in ipairs(trigger.auranames) do
          local spellId = WeakAuras.SafeToNumber(spellName)
          names[index] = spellId and Private.ExecEnv.GetSpellName(spellId) or spellName
        end
      end

      local showIfInvalidUnit
      if trigger.unit ~= "player" and not IsGroupTrigger(trigger) then
        showIfInvalidUnit = trigger.unitExists or false
      end
      local effectiveUseGroupCount = IsGroupTrigger(trigger) and trigger.useGroup_count
      local groupCountFunc
      if effectiveUseGroupCount then
        local group_countFuncStr
        local count, countType = Private.ParseNumber(trigger.group_count)
        if trigger.group_countOperator and count and countType then
          if countType == "whole" then
            group_countFuncStr = Private.function_strings.count:format(trigger.group_countOperator, count)
          else
            group_countFuncStr = Private.function_strings.count_fraction:format(trigger.group_countOperator, count)
          end
        else
          group_countFuncStr = Private.function_strings.count:format(">", 0)
        end
        groupCountFunc = Private.LoadFunction(group_countFuncStr, id)
      end

      local matchCountFunc
      if HasMatchCount(trigger) and trigger.match_countOperator and trigger.match_count and tonumber(trigger.match_count) then
        local count = tonumber(trigger.match_count)
        local match_countFuncStr = Private.function_strings.count:format(trigger.match_countOperator, count)
        matchCountFunc = Private.LoadFunction(match_countFuncStr, id)
      elseif IsGroupTrigger(trigger) then
        if trigger.showClones and not trigger.combinePerUnit then
          matchCountFunc = GreaterEqualOne
        end
      elseif not IsGroupTrigger(trigger) then
        if trigger.matchesShowOn == "showOnMissing" then
          matchCountFunc = EqualZero
        elseif trigger.matchesShowOn == "showOnActive" or not trigger.matchesShowOn then
          matchCountFunc = GreaterEqualOne
        end
      end

      local matchPerUnitCountFunc
      if IsGroupTrigger(trigger) and combineMode == "showPerUnit" and perUnitMode ~= "unaffected" and trigger.useMatchPerUnit_count
         and tonumber(trigger.matchPerUnit_count) and trigger.matchPerUnit_countOperator then
        local count = tonumber(trigger.matchPerUnit_count)
        local match_countFuncStr = Private.function_strings.count:format(trigger.matchPerUnit_countOperator, count)
        matchPerUnitCountFunc = Private.LoadFunction(match_countFuncStr, id)
      end

      local groupTrigger = trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
      local effectiveIgnoreSelf = (groupTrigger or trigger.unit == "nameplate") and trigger.ignoreSelf
      local effectiveGroupRole = WeakAuras.IsCataOrMistsOrRetail() and (groupTrigger and trigger.useGroupRole and trigger.group_role) or nil
      local effectiveRaidRole = WeakAuras.IsClassicOrCataOrMists() and (groupTrigger and trigger.useRaidRole and trigger.raid_role) or nil
      local effectiveClass = groupTrigger and trigger.useClass and trigger.class
      local effectiveSpecId = WeakAuras.IsCataOrMistsOrRetail() and (groupTrigger and trigger.useActualSpec and trigger.actualSpec) or nil
      local effectiveArenaSpec = WeakAuras.IsRetail() and (trigger.unit == "arena" and trigger.useArenaSpec and trigger.arena_spec) or nil
      local effectiveHostility = (groupTrigger or trigger.unit == "nameplate") and trigger.useHostility and trigger.hostility
      local effectiveIgnoreDead = groupTrigger and trigger.ignoreDead
      local effectiveIgnoreDisconnected = groupTrigger and trigger.ignoreDisconnected
      local effectiveIgnoreInvisible = groupTrigger and trigger.ignoreInvisible
      local effectiveNameCheck = groupTrigger and trigger.useUnitName and trigger.unitName
      local effectiveNpcId = (trigger.unit == "nameplate" or trigger.unit == "boss") and trigger.useNpcId and Private.ExecEnv.ParseStringCheck(trigger.npcId)
      local effectiveInRange = WeakAuras.IsRetail() and groupTrigger and trigger.inRange

      if trigger.unit == "multi" then
        BuffTrigger.InitMultiAura()
      end

      local auraspellids
      if trigger.useExactSpellId and trigger.auraspellids then
        auraspellids = {}
        for _, spellIdString in ipairs(trigger.auraspellids) do
          if spellIdString ~= "" then
            local spellId = tonumber(spellIdString)
            if spellId then
              tinsert(auraspellids, spellId)
            end
          end
        end
      end

      local unit
      local groupSubType = "group"
      if trigger.unit == "member" then
        unit = trigger.specificUnit
      elseif trigger.unit == "raid" then
        unit = "group"
        groupSubType = "raid"
      elseif trigger.unit == "party" then
        unit = "group"
        groupSubType = "party"
      else
        unit = trigger.unit
      end

      local triggerInformation = {
        auranames = names,
        auraspellids = auraspellids,
        unit = unit,
        debuffType = trigger.debuffType,
        ownOnly = trigger.ownOnly,
        combineMode = combineMode,
        perUnitMode = perUnitMode,
        scanFunc = scanFunc,
        remainingFunc = remFunc,
        remainingCheck = trigger.unit ~= "multi" and CanHaveMatchCheck(trigger) and trigger.useRem and tonumber(trigger.rem) or 0,
        id = id,
        triggernum = triggernum,
        compareFunc = matchCombineFunctions[trigger.combineMode] or matchCombineFunctions["showLowest"],
        unitExists = showIfInvalidUnit,
        fetchTooltip = not IsSingleMissing(trigger) and trigger.unit ~= "multi" and trigger.fetchTooltip,
        fetchRole = WeakAuras.IsCataOrMistsOrRetail() and trigger.unit ~= "multi" and trigger.fetchRole,
        fetchRaidMark = trigger.unit ~= "multi" and trigger.fetchRaidMark,
        groupTrigger = IsGroupTrigger(trigger),
        ignoreSelf = effectiveIgnoreSelf,
        ignoreDead = effectiveIgnoreDead,
        ignoreDisconnected = effectiveIgnoreDisconnected,
        ignoreInvisible = effectiveIgnoreInvisible,
        inRange = effectiveInRange,
        groupRole = effectiveGroupRole,
        raidRole = effectiveRaidRole,
        specId = effectiveSpecId,
        arenaSpec = effectiveArenaSpec,
        groupSubType = groupSubType,
        groupCountFunc = groupCountFunc,
        class = effectiveClass,
        hostility = effectiveHostility,
        matchCountFunc = matchCountFunc,
        matchPerUnitCountFunc = matchPerUnitCountFunc,
        useAffected = unit == "group" and trigger.useAffected,
        isMulti = trigger.unit == "multi",
        nameChecker = effectiveNameCheck and Private.ExecEnv.ParseNameCheck(trigger.unitName),
        includePets = trigger.use_includePets and trigger.includePets or nil,
        npcId = effectiveNpcId
      }
      triggerInfos[id] = triggerInfos[id] or {}
      triggerInfos[id][triggernum] = triggerInformation
    end
  end
  PublishProblems(problems, data.uid)
end

--- Returns a table containing the names of all overlays
--- @param data table
--- @param triggernum number
function BuffTrigger.GetOverlayInfo(data, triggernum)
  return {}
end

--- Returns whether the trigger can have clones.
--- @param data table
--- @param triggernum number
--- @return boolean
local function CanHaveClones(data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  if not IsSingleMissing(trigger) and trigger.showClones then
    return true
  end
  return false
end

---Returns the type of tooltip to show for the trigger.
--- @param data table
--- @param triggernum number
--- @return string
function BuffTrigger.CanHaveTooltip(data, triggernum)
  return "aura"
end

--- @return boolean
function BuffTrigger.SetToolTip(trigger, state)
  if newAPI then
    if not state.unit or not state.auraInstanceID then
      return false
    end
    if state.filter == "HELPFUL" then
      GameTooltip:SetUnitBuffByAuraInstanceID(state.unit, state.auraInstanceID, state.filter)
    elseif state.filter == "HARMFUL" then
      GameTooltip:SetUnitDebuffByAuraInstanceID(state.unit, state.auraInstanceID, state.filter)
    end
  else
    if not state.unit or not state.index then
      return false
    end
    if state.filter == "HELPFUL" then
      GameTooltip:SetUnitBuff(state.unit, state.index, state.filter)
    elseif state.filter == "HARMFUL" then
      GameTooltip:SetUnitDebuff(state.unit, state.index, state.filter)
    end
  end
  return true
end


function BuffTrigger.GetNameAndIconSimple(data, triggernum)
  if not data then
    return
  end
  local _, name, icon
  local trigger = data.triggers[triggernum].trigger

  if trigger.useName and trigger.auranames then
    for index, spellName in ipairs(trigger.auranames) do
      local spellId = WeakAuras.SafeToNumber(spellName)
      if spellId then
        name, _, icon = Private.ExecEnv.GetSpellInfo(spellName)
        if name and icon then
          return name, icon
        end
      elseif not tonumber(spellName) then
        name, _, icon = Private.ExecEnv.GetSpellInfo(spellName)
        if (name and icon) then
          return name, icon
        end
      end
    end
  end

  if trigger.useExactSpellId and trigger.auraspellids then
    for index, spellIdString in ipairs(trigger.auraspellids) do
      local spellId = spellIdString ~= "" and tonumber(spellIdString)
      if spellId then
        name, _, icon = Private.ExecEnv.GetSpellInfo(spellIdString)
        if name and icon then
          return name, icon
        end
      end
    end
  end
end

--- Returns the name and icon to show in the options.
--- @param data table
--- @param triggernum number
--- @return string|nil name, any icon
function BuffTrigger.GetNameAndIcon(data, triggernum)
  local name, icon = BuffTrigger.GetNameAndIconSimple(data, triggernum)
  if (not name or not icon and WeakAuras.spellCache) then
    local trigger = data.triggers[triggernum].trigger
    if trigger.useName and trigger.auranames then
      for index, spellName in ipairs(trigger.auranames) do
        icon = WeakAuras.spellCache.GetIcon(spellName)
        if icon then
          return spellName, icon
        end
      end
    end
  end
  return name, icon
end

--- Returns the tooltip text for additional properties.
--- @param data table
--- @param triggernum number
--- @return table @additional properties
function BuffTrigger.GetAdditionalProperties(data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  local props = {}

  props["spellId"] = { display = L["Spell ID"] }
  props["debuffClass"] = { display =  L["Debuff Class"] }
  props["debuffClassIcon"] = { display = L["Debuff Class Icon"] }
  props["unitCaster"] = { display = L["Caster Unit"], formatter = "Unit", formatterArgs = { color = "class" } }
  props["casterName"] = { display = L["Caster Name"], formatter = "string" }

  if trigger.unit ~= "multi" then
    props["unit"] = { display = L["Unit"], formatter = "Unit", formatterArgs = { color = "class" } }
    props["unitName"] = { display = L["Unit Name"] }
  end

  props["matchCount"] = { display = L["Match Count"] }
  props["matchCountPerUnit"] = { display = L["Match Count per Unit"] }
  props["unitCount"] = { display = L["Units Affected"] }
  props["totalStacks"] = { display = L["Total stacks over all matches"] }

  if trigger.unit ~= "multi" then
    props["maxUnitCount"] = { display = L["Total Units"] }
  end

  if not IsSingleMissing(trigger) and trigger.unit ~= "multi" and trigger.fetchTooltip then
    props["tooltip"] = { display = L["Tooltip"], formatter = "string" }
    props["tooltip1"] = { display = L["First Value of Tooltip Text"] }
    props["tooltip2"] = { display = L["Second Value of Tooltip Text"] }
    props["tooltip3"] = { display = L["Third Value of Tooltip Text"] }
    props["tooltip4"] = { display = L["Fourth Value of Tooltip Text"] }
  end

  if trigger.unit ~= "multi" then
    props["stackGainTime"] = { display = L["Since Stack Gain"], formatter = "timed" }
    props["stackLostTime"] = { display = L["Since Stack Lost"], formatter = "timed" }
    props["initialTime"] = { display = L["Since Apply"], formatter = "timed" }
    props["refreshTime"] = { display = L["Since Apply/Refresh"], formatter = "timed" }
  end

  if WeakAuras.IsCataOrMistsOrRetail() and trigger.unit ~= "multi" and trigger.fetchRole then
    props["role"] = { display = L["Assigned Role"] }
    props["roleIcon"] = { display = L["Assigned Role Icon"] }
  end

  if trigger.unit ~= "multi" and trigger.fetchRaidMark then
    props["raidMark"] = { display = L["Raid Mark"] }
  end

  if (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party") and trigger.useAffected then
    props["affected"] = { display = L["Names of affected Players"], formatter = "string" }
    props["unaffected"] = { display = L["Names of unaffected Players"], formatter = "string" }
    props["affectedUnits"] = { display = L["Units of affected Players in a table format"]}
    props["unaffectedUnits"] = { display = L["Units of unaffected Players in a table format"] }
  end

  return props
end

function BuffTrigger.GetProgressSources(data, triggernum, values)
  local trigger = data.triggers[triggernum].trigger
  tinsert(values, {
    trigger = triggernum,
    property = "matchCount",
    type = "number",
    display = L["Match Count"]
  })
  tinsert(values, {
    trigger = triggernum,
    property = "matchCountPerUnit",
    type = "number",
    display =  L["Match Count per Unit"]
  })
  tinsert(values, {
    trigger = triggernum,
    property = "unitCount",
    type = "number",
    display = L["Units Affected"],
    total = trigger.unit ~= "multi" and "maxUnitCount" or nil
  })
  tinsert(values, {
    trigger = triggernum,
    property = "stacks",
    type = "number",
    display = L["Stacks"]
  })
  tinsert(values, {
    trigger = triggernum,
    property = "totalStacks",
    type = "number",
    display = L["Total stacks over all matches"]
  })

  if not IsSingleMissing(trigger) and trigger.unit ~= "multi" and trigger.fetchTooltip then
    tinsert(values, {
      trigger = triggernum,
      property = "tooltip1",
      type = "number",
      display = L["Tooltip 1"]
    })
    tinsert(values, {
      trigger = triggernum,
      property = "tooltip2",
      type = "number",
      display = L["Tooltip 2"]
    })
    tinsert(values, {
      trigger = triggernum,
      property = "tooltip3",
      type = "number",
      display = L["Tooltip 3"]
    })
  end

  tinsert(values, {
    trigger = triggernum,
    property = "expirationTime",
    type = "timer",
    display = L["Timed Progress"],
    total = "duration",
    modRate = "modRate",
    paused = "paused",
    remaining = "remaining"
  })
  tinsert(values, {
    trigger = triggernum,
    property = "stackGainTime",
    type = "elapsedTimer",
    display = L["Time since stack gain"],
  })
  tinsert(values, {
    trigger = triggernum,
    property = "stackLostTime",
    type = "elapsedTimer",
    display = L["Time since stack lost"],
  })
  tinsert(values, {
    trigger = triggernum,
    property = "initialTime",
    type = "elapsedTimer",
    display = L["Time since initial application"],
  })
  tinsert(values, {
    trigger = triggernum,
    property = "refreshTime",
    type = "elapsedTimer",
    display = L["Time since last refresh"],
  })
end

function BuffTrigger.GetTriggerConditions(data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  local result = {}

  result["debuffClass"] = {
    display = L["Debuff Type"],
    type = "select",
    values = Private.debuff_class_types
  }

  result["unitCaster"] = {
    display = L["Caster Unit"],
    type = "string",
    formatter = "Unit",
    formatterArgs = { color = "class" }
  }

  result["nameCaster"] = {
    display = L["Casters Name/Realm"],
    type = "string",
    preamble = function(input)
      return Private.ExecEnv.ParseNameCheck(input)
    end,
    test = function(state, needle, op, preamble)
      return state.unitCaster and preamble:Check(WeakAuras.UnitNameWithRealm(state.unitCaster))
    end,
    operator_types = "none",
  }

  result["expirationTime"] = {
    display = L["Remaining Duration"],
    type = "timer",
    useModRate = true
  }

  result["duration"] = {
    display = L["Total Duration"],
    type = "number",
    useModRate = true
  }

  result["stacks"] = {
    display = L["Stacks"],
    type = "number"
  }

  result["name"] = {
    display = L["Name"],
    type = "string"
  }

  result["spellId"] = {
    display = L["Spell Id"],
    type = "number",
    operator_types = "only_equal"
  }

  result["matchCount"] = {
    display = L["Total Match Count"],
    type = "number"
  }

  result["matchCountPerUnit"] = {
    display = L["Match Count per Unit"],
    type = "number"
  }

  result["unitCount"] = {
    display = L["Affected Unit Count"],
    type = "number"
  }

  result["totalStacks"] = {
    display = L["Total Stacks"],
    type = "number"
  }

  if trigger.unit ~= "multi" then
    result["maxUnitCount"] = {
      display = L["Total Unit Count"],
      type = "number"
    }
  end

  if not IsGroupTrigger(trigger) and trigger.matchesShowOn == "showAlways"
    or IsGroupTrigger(trigger) and trigger.showClones and trigger.unit ~= "multi" and trigger.combinePerUnit
  then
    result["buffed"] = {
      display = L["Aura(s) Found"],
      type = "bool",
      test = function(state, needle)
        return state and state.show and ((state.active and true or false) == (needle == 1))
      end
    }
  end

  if not IsSingleMissing(trigger) and trigger.unit ~= "multi" and trigger.fetchTooltip then
    result["tooltip1"] = {
      display = L["Tooltip Value 1"],
      type = "number"
    }
    result["tooltip2"] = {
      display = L["Tooltip Value 2"],
      type = "number"
    }
    result["tooltip3"] = {
      display = L["Tooltip Value 3"],
      type = "number"
    }
    result["tooltip4"] = {
      display = L["Tooltip Value 4"],
      type = "number"
    }
  end

  if trigger.unit ~= "multi" then
    result["stackGainTime"] = {
      display = L["Since Stack Gain"],
      type = "elapsedTimer"
    }
    result["stackLostTime"] = {
      display = L["Since Stack Lost"],
      type = "elapsedTimer"
    }
    result["initialTime"] = {
      display = L["Since Apply"],
      type = "elapsedTimer"
    }
    result["refreshTime"] = {
      display = L["Since Apply/Refresh"],
      type = "elapsedTimer"
    }
  end

  return result
end

function BuffTrigger.CreateFallbackState(data, triggernum, state)
  state.show = true
  state.changed = true
  state.progressType = "timed"
  state.duration = 0
  state.expirationTime = math.huge
  state.modRate = 1
  local name, icon = BuffTrigger.GetNameAndIconSimple(data, triggernum)
  state.name = name
  state.icon = icon
end

function BuffTrigger.GetName(triggerType)
  if triggerType == "aura2" then
    return L["Aura"]
  end
end

function Private.CanConvertBuffTrigger2(trigger)
  if trigger.type ~= "aura" then
    return false
  end

  if trigger.unit == "multi" then
    return true, L["Note: The available text replacements for multi triggers match the normal triggers now."]
  end

  if trigger.unit and trigger.hideAlone then
    return false, L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."]
  end

  if trigger.unit == "group" then
    return true, L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."]
  end

  if trigger.fullscan then
    if trigger.subcount then
      return true, L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."]
    end

    if trigger.use_name and trigger.use_spellId then
      return false, L["Warning: Full Scan auras checking for both name and spell id can't be converted."]
    end
  end

  return true
end

function Private.ConvertBuffTrigger2(trigger)
  if not Private.CanConvertBuffTrigger2(trigger) then
    return
  end
  trigger.type = "aura2"

  if trigger.fullscan and trigger.autoclone then
    trigger.combineMatches = "showClones"
  else
    trigger.combineMatches = "showLowest"
  end

  if trigger.fullscan and trigger.use_stealable then
    trigger.use_stealable = true
  else
    trigger.use_stealable = nil
  end

  if trigger.fullscan and trigger.use_debuffClass and trigger.debuffClass then
  else
    trigger.use_debuffClass = false
  end

  if trigger.fullscan and trigger.use_tooltip then
    trigger.fetchTooltip = true
  else
    trigger.use_tooltip = false
  end

  if trigger.fullscan and trigger.subcount then
    trigger.fetchTooltip = true
  end

  if trigger.fullscan and trigger.use_name then
    trigger.useNamePattern = true
    trigger.namePattern_operator = trigger.name_operator
    trigger.namePattern_name = trigger.name
  end

  if trigger.fullscan then
    -- Use name from fullscan
    if trigger.use_name then
      if trigger.name_operator == "==" then
        -- Convert to normal name check
        trigger.useName = true
        trigger.auranames = {}
        trigger.auranames[1] = trigger.name
      end
    end
    if trigger.use_spellId then
      trigger.useExactSpellId = true
      trigger.auraspellids = {}
      trigger.auraspellids[1] = trigger.spellId
    end
  else
    trigger.useName = true
  end

  if not trigger.fullscan and trigger.unit ~= "multi" then
    trigger.auranames = {}
    for i = 1, 9 do
      trigger.auranames[i] = trigger.spellIds[i] and tostring(trigger.spellIds[i]) or trigger.names[i]
    end
  end

  if trigger.unit == "multi" then
    -- Closest to the old behavior
    trigger.showClones = true
    trigger.useName = true
    trigger.auranames = {}
    trigger.auranames[1] = tostring(trigger.spellId) or trigger.name
  end

  -- debuffType is exactly the same, no need to touch it
  -- remaining is exactly the same for now
  -- ownOnly is exactly the same
  -- unitExists is exactly the same

  if trigger.useCount then
    trigger.useStacks = trigger.useCount
    trigger.stacksOperator = trigger.countOperator
    trigger.stacks = trigger.count
  end

  if trigger.fullscan and trigger.autoclone then
    trigger.matchesShowOn = "showOnActive"
  else
    trigger.matchesShowOn = trigger.buffShowOn
  end

  if trigger.unit == "group" then
    trigger.matchesShowOn = nil
    trigger.showClones = trigger.groupclone
  end

  if trigger.unit == "group" and not trigger.groupclone then
    if trigger.name_info == "players" or trigger.name_info == "nonplayers" then
      trigger.useAffected = true
    end
  end

  if trigger.unit == "group" and trigger.group_countOperator and trigger.group_count then
    trigger.useGroup_count = true
  else
    trigger.useGroup_count = false
  end
end

-- Multi Target trigger code
local multiAuraFrame
local pendingTracks = {}

local unitToGuid = {}
local guidToUnit = {}

local function ReleaseUID(unit)
  local guid = unitToGuid[unit]
  if guid then
    guidToUnit[guid][unit] = nil
  end
end

local function SetUID(guid, unit)
  ReleaseUID(unit)

  unitToGuid[unit] = guid
  guidToUnit[guid] = guidToUnit[guid] or {}
  guidToUnit[guid][unit] = true
end

local function GetUnit(guid)
  if not guidToUnit[guid] then
    return nil
  end
  for unit in pairs(guidToUnit[guid]) do
    if UnitGUID(unit) == guid then
      return unit
    else
      guidToUnit[guid][unit] = nil
    end
  end
end

local function TrackUid(unit)
  local GUID = UnitGUID(unit)
  if GUID then
    SetUID(GUID, unit)
    BuffTrigger.HandlePendingTracks(unit, GUID)
  else
    ReleaseUID(unit)
  end
  unit = unit.."target"
  GUID = UnitGUID(unit)
  if GUID then
    SetUID(GUID, unit)
    BuffTrigger.HandlePendingTracks(unit, GUID)
  else
    ReleaseUID(unit)
  end
end

local function RemoveMatchDataMulti(base, destGUID, key, sourceGUID)
  if base[key] and base[key][sourceGUID] then
    for id, idData in pairs(base[key][sourceGUID].auras) do
      for triggernum, triggerData in pairs(idData) do
        tDeleteItem(matchDataByTrigger[id][triggernum][destGUID], base[key][sourceGUID])
        if not next(matchDataByTrigger[id][triggernum][destGUID]) then
          matchDataByTrigger[id][triggernum][destGUID] = nil
        end
        matchDataChanged[id] = matchDataChanged[id] or {}
        matchDataChanged[id][triggernum] = true
      end
    end
    base[key][sourceGUID] = nil
  end
end

local function CleanUpMulti(guid)
  cleanupTimerMulti[guid].handle = nil
  cleanupTimerMulti[guid].nextTime = nil
  local nextCheck
  if matchDataMulti[guid] then
    local time = GetTime()
    for key, data in pairs(matchDataMulti[guid]) do
      for source, sourceData in pairs(data) do
        local removeAt
        if sourceData.expirationTime and sourceData.expirationTime ~= math.huge then
          removeAt = sourceData.expirationTime
        else
          removeAt = sourceData.time + 60
        end
        if removeAt <= time then
          RemoveMatchDataMulti(matchDataMulti[guid], guid, key, source)
        else
          if not nextCheck then
            nextCheck = removeAt
          elseif (removeAt < nextCheck) then
            nextCheck = removeAt
          end
        end
      end
    end
  end

  if nextCheck then
    local timeUntilNext = nextCheck - GetTime()
    if timeUntilNext > 0 then
      cleanupTimerMulti[guid].handle = timer:ScheduleTimerFixed(CleanUpMulti, timeUntilNext, guid)
      cleanupTimerMulti[guid].nextTime = nextCheck
   end
  end
end

local function ScheduleMultiCleanUp(guid, time)
  cleanupTimerMulti[guid] = cleanupTimerMulti[guid] or {}
  if not cleanupTimerMulti[guid].nextTime or time < cleanupTimerMulti[guid].nextTime then
    if cleanupTimerMulti[guid].handle then
      timer:CancelTimer(cleanupTimerMulti[guid].handle)
    end
    cleanupTimerMulti[guid].handle = timer:ScheduleTimerFixed(CleanUpMulti, time - GetTime(), guid)
    cleanupTimerMulti[guid].nextTime = time
  end
end

local function UpdateMatchDataMulti(time, base, key, event, sourceGUID, sourceName, destGUID, destName, spellId, spellName, amount)
  local updated = false
  local icon = spellId and Private.ExecEnv.GetSpellIcon(spellId)
  ScheduleMultiCleanUp(destGUID, time + 60)
  if not base[key] or not base[key][sourceGUID] then
    updated = true
    base[key] = base[key] or {}
    base[key][sourceGUID] = {
      name = spellName,
      icon = icon,
      duration = 0,
      expirationTime = math.huge,
      modRate = 1,
      spellId = spellId,
      GUID = destGUID,
      sourceGUID = sourceGUID,
      unitName = destName,
      casterName = sourceName,
      time = time,
      auras = {}
    }
  else
    base[key][sourceGUID] = base[key][sourceGUID] or {}
    local match = base[key][sourceGUID]
    match.time = time

    if match.name ~= spellName then
      match.name = spellName
      updated = true
    end

    if match.unitName ~= destName then
      match.unitName = destName
      updated = true
    end

    local duration, expirationTime
    if event == "SPELL_AURA_APPLIED_DOSE" or event == "SPELL_AURA_REMOVED_DOSE" then
      -- Shouldn't affect duration/expirationTime nor icon
      duration = match.duration or 0
      expirationTime = match.expirationTime or math.huge
      icon = match.icon or icon
    else
      duration = 0
      expirationTime = math.huge
    end

    if match.duration ~= duration then
      match.duration = duration
      updated = true
    end

    if match.expirationTime ~= expirationTime then
      match.expirationTime = expirationTime
      updated = true
    end

    if match.icon ~= icon then
      match.icon = icon
      updated = true
    end

    if match.count ~= amount then
      match.count = amount
      updated = true
    end

    if match.spellId ~= spellId then
      match.spellId = spellId
      updated = true
    end

    if match.casterName ~= sourceName then
      match.casterName = sourceName
      updated = true
    end
  end

  return updated
end

local function AugmentMatchDataMultiWith(matchData, unit, name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, _, _, _, modRate)
  if expirationTime == 0 then
    expirationTime = math.huge
  else
    ScheduleMultiCleanUp(matchData.GUID, expirationTime / (modRate or 1))
  end
  local changed = false
  if matchData.name ~= name then
    matchData.name = name
    changed = true
  end

  if matchData.icon ~= icon then
    matchData.icon = icon
    changed = true
  end

  if matchData.stacks ~= stacks then
    matchData.stacks = stacks
    changed = true
  end

  if matchData.debuffClass ~= debuffClass then
    matchData.debuffClass = debuffClass
    changed = true
  end

  local debuffClassIcon = WeakAuras.EJIcons[debuffClass]
  if matchData.debuffClassIcon ~= debuffClassIcon then
    matchData.debuffClassIcon = debuffClassIcon
    changed = true
  end

  if matchData.duration ~= duration then
    matchData.duration = duration
    changed = true
  end

  if matchData.expirationTime ~= expirationTime then
    matchData.expirationTime = expirationTime
    changed = true
  end

  if matchData.modRate ~= modRate then
    matchData.modRate = modRate
    changed = true
  end

  if matchData.unitCaster ~= unitCaster then
    matchData.unitCaster = unitCaster
    changed = true
  end

  local casterName = GetUnitName(unitCaster, false) or ""
  if matchData.casterName ~= casterName then
    matchData.casterName = casterName
    changed = true
  end

  local unitName = GetUnitName(unit, false) or ""
  if matchData.unitName ~= unitName then
    matchData.unitName = unitName
    changed = true
  end

  if matchData.spellId ~= spellId then
    matchData.spellId = name
    changed = true
  end
  return changed
end

local AugmentMatchDataMulti
do
  local _matchData, _unit, _sourceGUID, _nameKey, _spellKey
  local function HandleAura(aura)
    if (not aura or not aura.name) then
      return
    end
    local debuffClass = FixDebuffClass(aura.dispelName, aura.spellId)
    local auraSourceGuid = aura.sourceUnit and UnitGUID(aura.sourceUnit)
    local name = aura.name
    local spellId = aura.spellId
    if (name == _nameKey or spellId == _spellKey) and _sourceGUID == auraSourceGuid then
      local changed = AugmentMatchDataMultiWith(_matchData, _unit, name, aura.icon, aura.applications, debuffClass, aura.duration, aura.expirationTime, aura.sourceUnit, aura.isStealable, aura.isBossAura, aura.isFromPlayerOrPlayerPet, spellId, aura.timeMod)
      return changed
    end
  end

  AugmentMatchDataMulti = function(matchData, unit, filter, sourceGUID, nameKey, spellKey)
    if newAPI then
      _matchData, _unit, _sourceGUID, _nameKey, _spellKey = matchData, unit, sourceGUID, nameKey, spellKey
      AuraUtil.ForEachAura(unit, filter, nil, HandleAura, true)
    else
      local index = 1
      while true do
        local name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, _, _, _, modRate = UnitAura(unit, index, filter)
        if not name then
          return false
        end

        debuffClass = FixDebuffClass(debuffClass, spellId)
        local auraSourceGuid = unitCaster and UnitGUID(unitCaster)
        if (name == nameKey or spellId == spellKey) and sourceGUID == auraSourceGuid then
          local changed = AugmentMatchDataMultiWith(matchData, unit, name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, _, _, _, modRate)
          return changed
        end
        index = index + 1
      end
    end
  end
end

local function HandleCombatLog(scanFuncsName, scanFuncsSpellId, filter, event, sourceGUID, sourceName, destGUID, destName, spellId, spellName, amount)
  local time = GetTime()
  local unit = GetUnit(destGUID)
  if scanFuncsName and scanFuncsName[spellName] or scanFuncsSpellId and scanFuncsSpellId[spellId] then
    ScheduleMultiCleanUp(destGUID, time + 60)
    matchDataMulti[destGUID] = matchDataMulti[destGUID] or {}

    if scanFuncsSpellId and scanFuncsSpellId[spellId] then
      local updatedSpellId = UpdateMatchDataMulti(time, matchDataMulti[destGUID], spellId, event, sourceGUID, sourceName, destGUID, destName, spellId, spellName, amount)
      if unit then
        updatedSpellId = AugmentMatchDataMulti(matchDataMulti[destGUID][spellId][sourceGUID], unit, filter, sourceGUID, nil, spellId) or updatedSpellId
      else
        pendingTracks[destGUID] = true
      end
      if updatedSpellId then
        for triggerInfo in pairs(scanFuncsSpellId[spellId]) do
          if MatchesTriggerInfoMulti(triggerInfo, sourceGUID) then
            ReferenceMatchDataMulti(matchDataMulti[destGUID][spellId][sourceGUID], triggerInfo.id, triggerInfo.triggernum, destGUID)
          end
        end
      end
    end

    if scanFuncsName and scanFuncsName[spellName] then
      local updatedName = UpdateMatchDataMulti(time, matchDataMulti[destGUID], spellName, event, sourceGUID, sourceName, destGUID, destName, spellId, spellName, amount)
      if unit then
        updatedName = AugmentMatchDataMulti(matchDataMulti[destGUID][spellName][sourceGUID], unit, filter, sourceGUID, spellName, nil) or updatedName
      else
        pendingTracks[destGUID] = true
      end
      if updatedName then
        for triggerInfo in pairs(scanFuncsName[spellName]) do
          if MatchesTriggerInfoMulti(triggerInfo, sourceGUID) then
            ReferenceMatchDataMulti(matchDataMulti[destGUID][spellName][sourceGUID], triggerInfo.id, triggerInfo.triggernum, destGUID)
          end
        end
      end
    end
  end
end

local function HandleCombatLogRemove(scanFuncsName, scanFuncsSpellId, sourceGUID, destGUID, spellId, spellName)
  if scanFuncsName and scanFuncsName[spellName] or scanFuncsSpellId and scanFuncsSpellId[spellId] then
    if matchDataMulti[destGUID] then
      RemoveMatchDataMulti(matchDataMulti[destGUID], destGUID, spellId, sourceGUID)
      RemoveMatchDataMulti(matchDataMulti[destGUID], destGUID, spellName, sourceGUID)
    end
  end
end

local function CombatLog(_, event, _, sourceGUID, sourceName, _, _, destGUID, destName, _, _, spellId, spellName, _, auraType, amount)
  if event == "SPELL_AURA_APPLIED" or event == "SPELL_AURA_REFRESH" or event == "SPELL_AURA_APPLIED_DOSE" or event == "SPELL_AURA_REMOVED_DOSE" then
    if auraType == "BUFF" then
      HandleCombatLog(scanFuncNameMulti["HELPFUL"], scanFuncSpellIdMulti["HELPFUL"], "HELPFUL", event, sourceGUID, sourceName, destGUID, destName, spellId, spellName, amount)
    elseif auraType == "DEBUFF" then
      HandleCombatLog(scanFuncNameMulti["HARMFUL"], scanFuncSpellIdMulti["HARMFUL"], "HARMFUL", event, sourceGUID, sourceName, destGUID, destName, spellId, spellName, amount)
    end
  elseif event == "SPELL_AURA_REMOVED" then
    if auraType == "BUFF" then
      HandleCombatLogRemove(scanFuncNameMulti["HELPFUL"], scanFuncSpellIdMulti["HELPFUL"], sourceGUID, destGUID, spellId, spellName)
    elseif auraType == "DEBUFF" then
      HandleCombatLogRemove(scanFuncNameMulti["HARMFUL"], scanFuncSpellIdMulti["HARMFUL"], sourceGUID, destGUID, spellId, spellName)
    end
  end
end

local CheckAurasMulti
do
  local _base, _unit
  local function HandleAura(aura)
    if (not aura or not aura.name) then
      return
    end
    local debuffClass = FixDebuffClass(aura.dispelName, aura.spellId)
    local auraCasterGUID = aura.sourceUnit and UnitGUID(aura.sourceUnit)
    local name = aura.name
    local spellId = aura.spellId
    if _base[name] and _base[name][auraCasterGUID] then
      local changed = AugmentMatchDataMultiWith(_base[name][auraCasterGUID], _unit, name, aura.icon, aura.applications, debuffClass, aura.duration, aura.expirationTime, aura.sourceUnit, aura.isStealable, aura.isBossAura, aura.isFromPlayerOrPlayerPet, spellId, aura.timeMod)
      if changed then
        for id, idData in pairs(_base[name][auraCasterGUID].auras) do
          for triggernum in pairs(idData) do
            matchDataChanged[id] = matchDataChanged[id] or {}
            matchDataChanged[id][triggernum] = true
          end
        end
      end
    end
    if _base[spellId] and _base[spellId][auraCasterGUID] then
      local changed = AugmentMatchDataMultiWith(_base[spellId][auraCasterGUID], _unit, aura.name, aura.icon, aura.applications, debuffClass, aura.duration, aura.expirationTime, aura.sourceUnit, aura.isStealable, aura.isBossAura, aura.isFromPlayerOrPlayerPet, spellId, aura.timeMod)
      if changed then
        for id, idData in pairs(_base[spellId][auraCasterGUID].auras) do
          for triggernum in pairs(idData) do
            matchDataChanged[id] = matchDataChanged[id] or {}
            matchDataChanged[id][triggernum] = true
          end
        end
      end
    end
  end

  CheckAurasMulti = function(base, unit, filter)
    if newAPI then
      _base = base
      _unit = unit
      AuraUtil.ForEachAura(unit, filter, nil, HandleAura, true)
    else
      local index = 1
      while true do
        local name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, _, _, _, modRate = UnitAura(unit, index, filter)
        if not name then
          return false
        end

        debuffClass = FixDebuffClass(debuffClass, spellId)

        local auraCasterGUID = unitCaster and UnitGUID(unitCaster)
        if base[name] and base[name][auraCasterGUID] then
          local changed = AugmentMatchDataMultiWith(base[name][auraCasterGUID], unit, name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, _, _, _, modRate)
          if changed then
            for id, idData in pairs(base[name][auraCasterGUID].auras) do
              for triggernum in pairs(idData) do
                matchDataChanged[id] = matchDataChanged[id] or {}
                matchDataChanged[id][triggernum] = true
              end
            end
          end
        end
        if base[spellId] and base[spellId][auraCasterGUID] then
          local changed = AugmentMatchDataMultiWith(base[spellId][auraCasterGUID], unit, name, icon, stacks, debuffClass, duration, expirationTime, unitCaster, isStealable, _, spellId, _, _, _, _, modRate)
          if changed then
            for id, idData in pairs(base[spellId][auraCasterGUID].auras) do
              for triggernum in pairs(idData) do
                matchDataChanged[id] = matchDataChanged[id] or {}
                matchDataChanged[id][triggernum] = true
              end
            end
          end
        end
        index = index + 1
      end
    end
  end
end

function BuffTrigger.HandlePendingTracks(unit, GUID)
  if pendingTracks[GUID] then
    if matchDataMulti[GUID] then
      CheckAurasMulti(matchDataMulti[GUID], unit, "HELPFUL")
      CheckAurasMulti(matchDataMulti[GUID], unit, "HARMFUL")
    end
  end
end

function BuffTrigger.InitMultiAura()
  if not multiAuraFrame then
    multiAuraFrame = CreateFrame("Frame")
    multiAuraFrame:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED")
    multiAuraFrame:RegisterEvent("UNIT_TARGET")
    multiAuraFrame:RegisterEvent("UNIT_AURA")
    multiAuraFrame:RegisterEvent("PLAYER_TARGET_CHANGED")
    if not WeakAuras.IsClassicEra() then
      multiAuraFrame:RegisterEvent("PLAYER_SOFT_ENEMY_CHANGED")
      multiAuraFrame:RegisterEvent("PLAYER_SOFT_FRIEND_CHANGED")
      multiAuraFrame:RegisterEvent("PLAYER_FOCUS_CHANGED")
    end
    multiAuraFrame:RegisterEvent("NAME_PLATE_UNIT_ADDED")
    multiAuraFrame:RegisterEvent("NAME_PLATE_UNIT_REMOVED")
    multiAuraFrame:RegisterEvent("PLAYER_LEAVING_WORLD")
    multiAuraFrame:SetScript("OnEvent", BuffTrigger.HandleMultiEvent)
    Private.frames["Multi-target 2 Aura Trigger Handler"] = multiAuraFrame
  end
end

function BuffTrigger.HandleMultiEvent(frame, event, ...)
  local system = "bufftrigger2 - multi - " .. event
  Private.StartProfileSystem(system)
  if event == "COMBAT_LOG_EVENT_UNFILTERED" then
    CombatLog(CombatLogGetCurrentEventInfo())
  elseif event == "UNIT_TARGET" then
    TrackUid(...)
  elseif Private.player_target_events[event] then
    TrackUid(Private.player_target_events[event])
  elseif event == "NAME_PLATE_UNIT_ADDED" then
    TrackUid(...)
  elseif event == "NAME_PLATE_UNIT_REMOVED" then
    local unit = ...
    ReleaseUID(unit)
    unit = unit.."target"
    ReleaseUID(unit)
  elseif event == "UNIT_AURA" then
    local unit = ...
    local guid = UnitGUID(unit)
    if matchDataMulti[guid] then
      CheckAurasMulti(matchDataMulti[guid], unit, "HELPFUL")
      CheckAurasMulti(matchDataMulti[guid], unit, "HARMFUL")
    end
  elseif event == "PLAYER_LEAVING_WORLD" then
    -- Remove everything..
    for GUID, GUIDData  in pairs(matchDataMulti) do
      for key in pairs(GUIDData) do
        RemoveMatchDataMulti(GUIDData, GUID, key)
      end
    end
    wipe(matchDataMulti)
  end
  Private.StopProfileSystem(system)
end

function BuffTrigger.GetTriggerDescription(data, triggernum, namestable)
  local trigger = data.triggers[triggernum].trigger
  if trigger.useName and trigger.auranames then
    for index, name in pairs(trigger.auranames) do
      if index > 10 then
        tinsert(namestable, {" ", "[...]"})
        break
      end

      local left = " "
      if(index == 1) then
        if(#trigger.auranames > 0) then
          if(#trigger.auranames > 1) then
            left = L["Auras:"]
          else
            left = L["Aura:"]
          end
        end
      end
      local icon
      local spellId = WeakAuras.SafeToNumber(name)
      if spellId then
        icon = Private.ExecEnv.GetSpellIcon(spellId)
      else
        icon = WeakAuras.spellCache.GetIcon(name)
      end
      icon = icon or "Interface\\Icons\\INV_Misc_QuestionMark"
      tinsert(namestable, {left, name, icon})
    end
  end

  if trigger.useExactSpellId and  trigger.auraspellids then
    for index, spellId in pairs(trigger.auraspellids) do
      if index > 10 then
        tinsert(namestable, {" ", "[...]"})
        break
      end

      local left = " "
      if index == 1 then
        if #trigger.auraspellids > 0 then
          if #trigger.auraspellids > 1 then
            left = L["Spell IDs:"]
          else
            left = L["Spell ID:"]
          end
        end
      end

      local icon = Private.ExecEnv.GetSpellIcon(spellId) or "Interface\\Icons\\INV_Misc_QuestionMark"
      tinsert(namestable, {left, spellId, icon})
    end
  end
end

function BuffTrigger.CreateFakeStates(id, triggernum)
  local allStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum);
  local data = WeakAuras.GetData(id)
  local state = {}
  BuffTrigger.CreateFallbackState(data, triggernum, state)
  state.expirationTime = GetTime() + 60
  state.duration = 65
  state.progressType = "timed"
  state.stacks = 1
  allStates[""] = state
  if CanHaveClones(data, triggernum) then
    for i = 1, 2 do
      local state = {}
      BuffTrigger.CreateFallbackState(data, triggernum, state)
      state.expirationTime = GetTime() + 60 + i * 20
      state.duration = 100
      state.progressType = "timed"
      state.stacks = 1
      allStates[i] = state
    end
  end
end

WeakAuras.RegisterTriggerSystem({"aura2"}, BuffTrigger)


-- ========================================
-- File: WeakAuras/Compatibility.lua
-- ========================================

-- This file is only for base functions that work differently or are deprecated in some versions of wow

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

if GetSpellInfo then
  Private.ExecEnv.GetSpellInfo = GetSpellInfo
  Private.ExecEnv.GetSpellName = GetSpellInfo
else
  Private.ExecEnv.GetSpellInfo = function(spellID)
    if not spellID then
      return nil
    end
    local spellInfo = C_Spell.GetSpellInfo(spellID)
    if spellInfo then
      return spellInfo.name, nil, spellInfo.iconID, spellInfo.castTime, spellInfo.minRange, spellInfo.maxRange, spellInfo.spellID, spellInfo.originalIconID
    end
  end
  Private.ExecEnv.GetSpellName = C_Spell.GetSpellName
end

if GetSpellTexture then
  Private.ExecEnv.GetSpellIcon = GetSpellTexture
else
  Private.ExecEnv.GetSpellIcon = C_Spell.GetSpellTexture
end

if IsUsableSpell then
  Private.ExecEnv.IsUsableSpell = IsUsableSpell
else
  Private.ExecEnv.IsUsableSpell = C_Spell.IsSpellUsable
end

if C_SpecializationInfo and C_SpecializationInfo.GetSpecialization then
  Private.ExecEnv.GetSpecialization = C_SpecializationInfo.GetSpecialization
else
  Private.ExecEnv.GetSpecialization = GetSpecialization
end
if C_SpecializationInfo and C_SpecializationInfo.GetSpecializationInfo then
  Private.ExecEnv.GetSpecializationInfo = C_SpecializationInfo.GetSpecializationInfo
else
  Private.ExecEnv.GetSpecializationInfo = GetSpecializationInfo
end
if C_SpecializationInfo and C_SpecializationInfo.GetNumSpecializationsForClassID then
  Private.ExecEnv.GetNumSpecializationsForClassID = C_SpecializationInfo.GetNumSpecializationsForClassID
else
  Private.ExecEnv.GetNumSpecializationsForClassID = GetNumSpecializationsForClassID
end
if WeakAuras.IsMists() then
  local specsByClassID = {
    [0] = { 74, 81, 79 },
    [1] = { 71, 72, 73, 1446 },
    [2] = { 65, 66, 70, 1451 },
    [3] = { 253, 254, 255, 1448 },
    [4] = { 259, 260, 261, 1453 },
    [5] = { 256, 257, 258, 1452 },
    [6] = { 250, 251, 252, 1455 },
    [7] = { 262, 263, 264, 1444 },
    [8] = { 62, 63, 64, 1449 },
    [9] = { 265, 266, 267, 1454 },
    [10] = { 268, 270, 269, 1450 },
    [11] = { 102, 103, 104, 105, 1447 },
  }
  Private.ExecEnv.GetSpecializationInfoForClassID = function (classID, specIndex)
    local specID = specsByClassID[classID][specIndex]
    if not specID then
      return nil
    end
    return GetSpecializationInfoByID(specID)
  end
else
  Private.ExecEnv.GetSpecializationInfoForClassID = GetSpecializationInfoForClassID
end

if C_SpecializationInfo and C_SpecializationInfo.GetTalentInfo then
  -- copy pasta from Interface/AddOns/Blizzard_DeprecatedSpecialization/Deprecated_Specialization_Mists.lua
  Private.ExecEnv.GetTalentInfo = function(tabIndex, talentIndex, isInspect, isPet, groupIndex)
		-- Note: tabIndex, talentIndex, and isPet are not supported parameters in 5.5.x and onward.
		local numColumns = 3
		local talentInfoQuery = {}
		talentInfoQuery.tier = math.ceil(talentIndex / numColumns)
		talentInfoQuery.column = talentIndex % numColumns
		talentInfoQuery.groupIndex = groupIndex
		talentInfoQuery.isInspect = isInspect
		talentInfoQuery.target = nil
		local talentInfo = C_SpecializationInfo.GetTalentInfo(talentInfoQuery)
		if not talentInfo then
			return nil
		end

		-- Note: rank, maxRank, meetsPrereq, previewRank, meetsPreviewPrereq, isExceptional, and hasGoldBorder are not supported outputs in 5.5.x and onward.
		-- They have default values not reflective of actual system state.
		-- selected, available, spellID, isPVPTalentUnlocked, known, and grantedByAura are new supported outputs in 5.5.x and onward.
		return talentInfo.name, talentInfo.icon, talentInfo.tier, talentInfo.column, talentInfo.selected and talentInfo.rank or 0,
			talentInfo.maxRank, talentInfo.meetsPrereq, talentInfo.previewRank,
			talentInfo.meetsPreviewPrereq, talentInfo.isExceptional, talentInfo.hasGoldBorder,
			talentInfo.talentID
	end
else
  Private.ExecEnv.GetTalentInfo = GetTalentInfo
end

Private.ExecEnv.GetNumFactions = C_Reputation.GetNumFactions or GetNumFactions

Private.ExecEnv.GetFactionDataByIndex = C_Reputation.GetFactionDataByIndex or function(index)
  local name, description, standingID, barMin, barMax, barValue, atWarWith, canToggleAtWar, isHeader, isCollapsed, hasRep, isWatched, isChild, factionID, hasBonusRepGain, canSetInactive = GetFactionInfo(index)
  return {
    factionID = factionID,
    name = name,
    description = description,
    reaction = standingID,
    currentReactionThreshold = barMin,
    nextReactionThreshold = barMax,
    currentStanding = barValue,
    atWarWith = atWarWith,
    canToggleAtWar = canToggleAtWar,
    isChild = isChild,
    isHeader = isHeader,
    isHeaderWithRep = hasRep,
    isCollapsed = isCollapsed,
    isWatched = isWatched,
    hasBonusRepGain = hasBonusRepGain,
    canSetInactive = canSetInactive,
    isAccountWide = nil
  }
end

Private.ExecEnv.GetFactionDataByID = C_Reputation.GetFactionDataByID or function(ID)
  local name, description, standingID, barMin, barMax, barValue, atWarWith, canToggleAtWar, isHeader, isCollapsed, hasRep, isWatched, isChild, factionID, hasBonusRepGain, canSetInactive = GetFactionInfoByID(ID)
  return {
    factionID = factionID,
    name = name,
    description = description,
    reaction = standingID,
    currentReactionThreshold = barMin,
    nextReactionThreshold = barMax,
    currentStanding = barValue,
    atWarWith = atWarWith,
    canToggleAtWar = canToggleAtWar,
    isChild = isChild,
    isHeader = isHeader,
    isHeaderWithRep = hasRep,
    isCollapsed = isCollapsed,
    isWatched = isWatched,
    hasBonusRepGain = hasBonusRepGain,
    canSetInactive = canSetInactive,
    isAccountWide = nil
  }
end

-- GetWatchedFactionData behaves differentlly, but we only need the Id, so do a trival wrapper
if C_Reputation.GetWatchedFactionData then
  Private.ExecEnv.GetWatchedFactionId = function()
    local data = C_Reputation.GetWatchedFactionData()
    return data and data.factionID or nil
  end
else
  Private.ExecEnv.GetWatchedFactionId = function()
    return select(6, GetWatchedFactionInfo())
  end
end

Private.ExecEnv.ExpandFactionHeader = C_Reputation.ExpandFactionHeader or ExpandFactionHeader
Private.ExecEnv.CollapseFactionHeader = C_Reputation.CollapseFactionHeader or CollapseFactionHeader
Private.ExecEnv.AreLegacyReputationsShown = C_Reputation.AreLegacyReputationsShown or function() return true end
Private.ExecEnv.GetReputationSortType = C_Reputation.GetReputationSortType or function() return 0 end;


-- ========================================
-- File: WeakAuras/Conditions.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L
local timer = WeakAuras.timer

-- Dynamic Condition functions to run. keyed on event and uid
local dynamicConditions = {};

-- Global Dynamic Condition Funcs, keyed on the event
local globalDynamicConditionFuncs = {};

-- Check Conditions Functions, keyed on uid
local checkConditions = {};

local conditionChecksTimers = {};
conditionChecksTimers.recheckTime = {};
conditionChecksTimers.recheckHandle = {};

local function OnDelete(_, uid)
  checkConditions[uid] = nil
  conditionChecksTimers.recheckTime[uid] = nil
  if (conditionChecksTimers.recheckHandle[uid]) then
    for cloneId, v in pairs(conditionChecksTimers.recheckHandle[uid]) do
      timer:CancelTimer(v)
    end
  end
  conditionChecksTimers.recheckHandle[uid] = nil

  for _, funcs in pairs(dynamicConditions) do
    funcs[uid] = nil
  end
end

Private.callbacks:RegisterCallback("Delete", OnDelete)

local function formatValueForAssignment(vType, value, pathToCustomFunction, pathToFormatters, data)
  if (value == nil) then
    value = false;
  end
  if (vType == "bool") then
    return value and tostring(value) or "false";
  elseif(vType == "number") then
    return value and tostring(value) or "0";
  elseif (vType == "list" or vType == "textureLSM") then
    if type(value) == "string" then
      return string.format("%s", Private.QuotedString(value))
    elseif type(value) == "number" then
      return tostring(value)
    end
    return "nil"
  elseif vType == "progressSource" then
    if type(value) == "table" then
      local progressSource = Private.AddProgressSourceMetaData(data, value)
      if not progressSource then
        return "{}"
      end
      local trigger = progressSource[1] or -1
      local progressType = progressSource[2] or "auto"
      local property = progressSource[3]
      local totalProperty = progressSource[4]
      local modRateProperty = progressSource[5]
      local inverseProperty = progressSource[6]
      local pausedProperty = progressSource[7]
      local remainingProperty = progressSource[8]

      if trigger == 0 then
        -- Manual progress
        local serialized = string.format("{%s, %s, %s, %s}",
            trigger,
            Private.QuotedString(progressType),
            property or "0",     -- Actually: value
            totalProperty or "100" -- Actually: total
        )
        return serialized
      else
        local serialized = string.format("{%s, %s, %s, %s, %s, %s, %s, %s}",
            trigger,
            Private.QuotedString(progressType),
            Private.QuotedString(property or "nil"),
            totalProperty and Private.QuotedString(totalProperty) or "nil",
            modRateProperty and Private.QuotedString(modRateProperty) or "nil",
            inverseProperty and Private.QuotedString(inverseProperty) or "nil",
            pausedProperty and Private.QuotedString(pausedProperty) or "nil",
            remainingProperty and Private.QuotedString(remainingProperty) or "nil"
        )
        return serialized
      end
    else
      return "nil"
    end
  elseif (vType == "icon") then
    if type(value) == "string" then
      return string.format("%s", Private.QuotedString(value))
    elseif type(value) == "number" then
      return tostring(value)
    end
    return "nil"
  elseif (vType == "string" or vType == "texture") then
    if type(value) == "string" then
      return string.format("%s", Private.QuotedString(value))
    else
      return '""'
    end
  elseif(vType == "color") then
    if (value and type(value) == "table") then
      return string.format("{%s, %s, %s, %s}",
                           tostring(value[1]), tostring(value[2]),
                           tostring(value[3]), tostring(value[4]))
    end
    return "{1, 1, 1, 1}";
  elseif(vType == "chat") then
    if (value and type(value) == "table") then
      local serialized = string.format("{message_type = %s, message = %s, message_dest = %s, message_dest_isunit = %s, r = %s, g = %s, b = %s, message_custom = %s, message_formaters = %s, message_voice = %s}",
        Private.QuotedString(tostring(value.message_type)), Private.QuotedString(tostring(value.message or "")),
        Private.QuotedString(tostring(value.message_dest)),
        tostring(value.message_dest_isunit),
        type(value.message_color) == "table" and tostring(value.message_color[1] or "1") or "1",
        type(value.message_color) == "table" and tostring(value.message_color[2] or "1") or "1",
        type(value.message_color) == "table" and tostring(value.message_color[3] or "1") or "1",
        pathToCustomFunction,
        pathToFormatters,
        tostring(value.message_voice))
      return serialized
    end
  elseif(vType == "sound") then
    if (value and type(value) == "table") then
      return string.format("{ sound = %s, sound_channel = %s, sound_path = %s, sound_kit_id = %s, sound_type = %s, %s, %s}",
        Private.QuotedString(tostring(value.sound or "")),
        Private.QuotedString(tostring(value.sound_channel or "")),
        Private.QuotedString(tostring(value.sound_path or "")),
        Private.QuotedString(tostring(value.sound_kit_id or "")),
        Private.QuotedString(tostring(value.sound_type or "")),
        value.sound_repeat and "sound_repeat = " .. tostring(value.sound_repeat) or "nil",
        value.sound_fade and "sound_fade = " .. tostring(value.sound_fade) or "nil");
    end
  elseif(vType == "customcode") then
    return string.format("%s", pathToCustomFunction);
  elseif vType == "glowexternal" then
    if (value and type(value) == "table") then
      return ([[{ glow_action = %q, glow_frame_type = %q, glow_type = %q,
      glow_frame = %q, use_glow_color = %s, glow_color = {%s, %s, %s, %s},
      glow_startAnim = %s, glow_duration = %f, glow_lines = %d, glow_frequency = %f, glow_length = %f, glow_thickness = %f, glow_XOffset = %f, glow_YOffset = %f,
      glow_scale = %f, glow_border = %s }]]):format(
        value.glow_action or "",
        value.glow_frame_type or "",
        value.glow_type or "",
        value.glow_frame or "",
        value.use_glow_color and "true" or "false",
        type(value.glow_color) == "table" and tostring(value.glow_color[1]) or "1",
        type(value.glow_color) == "table" and tostring(value.glow_color[2]) or "1",
        type(value.glow_color) == "table" and tostring(value.glow_color[3]) or "1",
        type(value.glow_color) == "table" and tostring(value.glow_color[4]) or "1",
        value.glow_startAnim and "true" or "false",
        value.glow_duration or 1,
        value.glow_lines or 8,
        value.glow_frequency or 0.25,
        value.glow_length or 10,
        value.glow_thickness or 1,
        value.glow_XOffset or 0,
        value.glow_YOffset or 0,
        value.glow_scale or 1,
        value.glow_border and "true" or "false"
      )
    end
  end
  return "nil";
end

local function formatValueForCall(type, property)
  if type == "bool" or type == "number" or type == "list" or type == "icon" or type == "string" or type == "texture" or type == "textureLSM"
    or type == "progressSource"
  then
    return "propertyChanges['" .. property .. "']";
  elseif (type == "color") then
    local pcp = "propertyChanges['" .. property .. "']";
    return pcp  .. "[1], " .. pcp .. "[2], " .. pcp  .. "[3], " .. pcp  .. "[4]";
  end
  return "nil";
end


function Private.ExecEnv.CancelConditionCheck(uid, cloneId)
  if conditionChecksTimers.recheckHandle[uid] and conditionChecksTimers.recheckHandle[uid][cloneId] then
    timer:CancelTimer(conditionChecksTimers.recheckHandle[uid][cloneId])
    conditionChecksTimers.recheckHandle[uid][cloneId] = nil
  end
end

function Private.ExecEnv.ScheduleConditionCheck(time, uid, cloneId)
  conditionChecksTimers.recheckTime[uid] = conditionChecksTimers.recheckTime[uid] or {}
  conditionChecksTimers.recheckHandle[uid] = conditionChecksTimers.recheckHandle[uid] or {};

  if (conditionChecksTimers.recheckTime[uid][cloneId] and conditionChecksTimers.recheckTime[uid][cloneId] > time) then
    timer:CancelTimer(conditionChecksTimers.recheckHandle[uid][cloneId]);
    conditionChecksTimers.recheckHandle[uid][cloneId] = nil;
  end

  if (conditionChecksTimers.recheckHandle[uid][cloneId] == nil) then
    conditionChecksTimers.recheckHandle[uid][cloneId] = timer:ScheduleTimerFixed(function()
      conditionChecksTimers.recheckHandle[uid][cloneId] = nil;
      local region = Private.GetRegionByUID(uid, cloneId)
      if (region and region.toShow) then
        Private.ActivateAuraEnvironmentForRegion(region)
        checkConditions[uid](region);
        Private.ActivateAuraEnvironment()
      end
    end, time - GetTime())
    conditionChecksTimers.recheckTime[uid][cloneId] = time;
  end
end

function Private.ExecEnv.CallCustomConditionTest(uid, testFunctionNumber, ...)
  local ok, result = xpcall(Private.ExecEnv.conditionHelpers[uid].customTestFunctions[testFunctionNumber],
                            Private.GetErrorHandlerUid(uid, L["Condition Custom Test"]), ...)
  if (ok) then
    return result
  end
end

local function CreateTestForCondition(data, input, allConditionsTemplate, usedStates)
  local uid = data.uid
  local trigger = input and input.trigger;
  local variable = input and input.variable;
  local op = input and input.op;
  local value = input and input.value;

  local check = nil;
  local recheckCode = nil;

  if (variable == "AND" or variable == "OR") then
    local test = {};
    if (input.checks) then
      for i, subcheck in ipairs(input.checks) do
        local subtest, subrecheckCode = CreateTestForCondition(data, subcheck, allConditionsTemplate, usedStates);
        if (subtest) then
          tinsert(test, "(" .. subtest .. ")");
        end
        if (subrecheckCode) then
          recheckCode = recheckCode or "";
          recheckCode = recheckCode .. subrecheckCode;
        end
      end
    end
    if (next(test)) then
      if (variable == "AND") then
        check = table.concat(test, " and ");
      else
        check = table.concat(test, " or ");
      end
    end
  end

  if (trigger and variable) then
    usedStates[trigger] = true;

    local conditionTemplate = allConditionsTemplate[trigger] and allConditionsTemplate[trigger][variable];
    local cType = conditionTemplate and conditionTemplate.type;
    local test = conditionTemplate and conditionTemplate.test;
    local recheckTime = conditionTemplate and conditionTemplate.recheckTime
    local preamble = conditionTemplate and conditionTemplate.preamble;
    local progressSource
    local modRateProperty
    local pausedProperty
    local remainingProperty
    if cType == "timer" then
      progressSource = Private.GetProgressSourceFor(data, trigger, variable)
      modRateProperty = progressSource and progressSource[5]
      pausedProperty = progressSource and progressSource[7]
      remainingProperty = progressSource[8]
    end

    local stateCheck = "state[" .. trigger .. "] and state[" .. trigger .. "].show and ";
    local stateVariableCheck = string.format("state[" .. trigger .. "][%q]", variable) .. "~= nil and ";

    local preambleString

    if preamble then
      Private.ExecEnv.conditionHelpers[uid] = Private.ExecEnv.conditionHelpers[uid] or {}
      Private.ExecEnv.conditionHelpers[uid].preambles = Private.ExecEnv.conditionHelpers[uid].preambles or {}
      tinsert(Private.ExecEnv.conditionHelpers[uid].preambles, preamble(value) or "");
      local preambleNumber = #Private.ExecEnv.conditionHelpers[uid].preambles
      preambleString = string.format("Private.ExecEnv.conditionHelpers[%q].preambles[%s]", uid, preambleNumber)
    end

    if (test) then
      if (value) then
        Private.ExecEnv.conditionHelpers[uid] = Private.ExecEnv.conditionHelpers[uid] or {}
        Private.ExecEnv.conditionHelpers[uid].customTestFunctions
          = Private.ExecEnv.conditionHelpers[uid].customTestFunctions or {}
        tinsert(Private.ExecEnv.conditionHelpers[uid].customTestFunctions, test);
        local testFunctionNumber = #(Private.ExecEnv.conditionHelpers[uid].customTestFunctions);
        local valueString = type(value) == "string" and string.format("%q", value) or value;
        local opString = type(op) == "string" and string.format("%q", op) or op;
        check = string.format("state and Private.ExecEnv.CallCustomConditionTest(%q, %s, state[%s], %s, %s, %s)",
                              uid, testFunctionNumber, trigger, valueString, (opString or "nil"),
                              preambleString or "nil")
      end
    elseif (cType == "customcheck") then
      if value then
        local customCheck = WeakAuras.LoadFunction("return " .. value, data.id)
        if customCheck then
          Private.ExecEnv.conditionHelpers[uid] = Private.ExecEnv.conditionHelpers[uid] or {}
          Private.ExecEnv.conditionHelpers[uid].customTestFunctions
            = Private.ExecEnv.conditionHelpers[uid].customTestFunctions or {}
          tinsert(Private.ExecEnv.conditionHelpers[uid].customTestFunctions, customCheck);
          local testFunctionNumber = #(Private.ExecEnv.conditionHelpers[uid].customTestFunctions);

          check = string.format("state and Private.ExecEnv.CallCustomConditionTest(%q, %s, state)",
                                uid, testFunctionNumber, trigger);
        end
      end
    elseif cType == "alwaystrue" then
      check = "true"
    elseif (cType == "number" and value and op) then
      local v = tonumber(value)
      if (v) then
          check = stateCheck .. stateVariableCheck .. "state[" .. trigger .. "]" .. string.format("[%q]", variable)
                  .. op .. v;
      end
    elseif (cType == "timer" and value and op) then
      local triggerState = "state[" .. trigger .. "]"
      local varString = triggerState .. string.format("[%q]", variable)
      local remainingTime = "(" .. varString .. " - now)"
      if pausedProperty and remainingProperty then
        local pausedString = "state[" .. trigger .. "]" .. string.format("[%q]", pausedProperty)
        local remainingString = "(state[" .. trigger .. "]" .. string.format("[%q]", remainingProperty) .. " or 0)"

        remainingTime = "((" .. pausedString .. " and " .. remainingString .. ") or " ..  remainingTime .. ")"
      end

      local divideModRate = modRateProperty
            and  " / (state[" .. trigger .. "]" .. string.format("[%q]",  modRateProperty) .. " or 1.0)"
            or ""

      if (op == "==") then
        check = stateCheck .. stateVariableCheck .. varString .. "~= 0 and " .. "abs((" .. remainingTime .. "-" .. value .. ")" .. divideModRate .. ") < 0.05"
      else
        check = stateCheck .. stateVariableCheck .. varString .. "~= 0 and " .. remainingTime .. divideModRate .. op .. value
      end
    elseif (cType == "elapsedTimer" and value and op) then
      if (op == "==") then
        check = stateCheck .. stateVariableCheck .. "abs(state[" .. trigger .. "]" .. string.format("[%q]", variable)
                .. "- now +" .. value .. ") < 0.05";
      else
        check = stateCheck .. stateVariableCheck .. "now - state[" .. trigger .. "]" .. string.format("[%q]", variable)
                .. op .. value;
      end
    elseif (cType == "select" and value and op) then
      if (tonumber(value)) then
        check = stateCheck .. stateVariableCheck .. "state[" .. trigger .. "]" .. string.format("[%q]", variable)
                .. op .. tonumber(value);
      else
        check = stateCheck .. stateVariableCheck .. "state[" .. trigger .. "]".. string.format("[%q]", variable)
                .. op .. "'" .. value .. "'";
      end
    elseif (cType == "range" and value and op and input.type and input.op_range and input.range) then
      local fn
      if input.type == "group" then
        fn = [[
          return function()
            local found = 0
            local op = %q
            local range = %s
            for unit in WA_IterateGroupMembers() do
              if not UnitIsUnit(unit, "player") and WeakAuras.CheckRange(unit, range, op) then
                found = found + 1
              end
            end
            return found %s %d
          end
        ]]
        fn = fn:format(input.op_range, input.range, op, value)
      elseif input.type == "enemies" then
        fn = [[
          return function()
            local found = 0
            local op = %q
            local range = %s
            for i = 1, 40 do
              local unit = "nameplate" .. i
              if UnitExists(unit) and UnitCanAttack("player", unit) and WeakAuras.CheckRange(unit, range, op) then
                found = found + 1
              end
            end
            return found %s %d
          end
        ]]
        fn = fn:format(input.op_range, input.range, op, value)
      end
      if fn then
        local customCheck = WeakAuras.LoadFunction(fn, data.id)
        if customCheck then
          Private.ExecEnv.conditionHelpers[uid] = Private.ExecEnv.conditionHelpers[uid] or {}
          Private.ExecEnv.conditionHelpers[uid].customTestFunctions
            = Private.ExecEnv.conditionHelpers[uid].customTestFunctions or {}
          tinsert(Private.ExecEnv.conditionHelpers[uid].customTestFunctions, customCheck);
          local testFunctionNumber = #(Private.ExecEnv.conditionHelpers[uid].customTestFunctions);

          check = string.format("state and Private.ExecEnv.CallCustomConditionTest(%q, %s, state)",
                                uid, testFunctionNumber, trigger);
        end
      end
    elseif (cType == "bool" and value) then
      local rightSide = value == 0 and "false" or "true";
      check = stateCheck .. stateVariableCheck .. "state[" .. trigger .. "]" .. string.format("[%q]", variable)
              .. "==" .. rightSide
    elseif (cType == "string" and value) then
      if(op == "==") then
        check = stateCheck .. stateVariableCheck .. "state[" .. trigger .. "]" .. string.format("[%q]", variable)
                .. string.format(" == %q", value)
      elseif (op  == "find('%s')") then
        check = stateCheck .. stateVariableCheck .. "state[" .. trigger .. "]" .. string.format("[%q]", variable)
                .. string.format(":find(%q, 1, true)", value)
      elseif (op == "match('%s')") then
        check = stateCheck .. stateVariableCheck .. "state[" .. trigger .. "]" .. string.format("[%q]",  variable)
                .. string.format(":match(%q, 1, true)", value)
      end
    end
    -- If adding a new condition type, don't forget to adjust the validator in the options code

    if recheckTime then
      if (value) then
        Private.ExecEnv.conditionHelpers[uid] = Private.ExecEnv.conditionHelpers[uid] or {}
        Private.ExecEnv.conditionHelpers[uid].customTestFunctions
          = Private.ExecEnv.conditionHelpers[uid].customTestFunctions or {}
        tinsert(Private.ExecEnv.conditionHelpers[uid].customTestFunctions, recheckTime);
        local testFunctionNumber = #(Private.ExecEnv.conditionHelpers[uid].customTestFunctions);
        local valueString = type(value) == "string" and string.format("%q", value) or value;

        recheckCode = string.format("  nextTime = Private.ExecEnv.CallCustomConditionTest(%q, %s, state[%s], %s) \n",
                                    uid, testFunctionNumber, trigger, valueString)
        recheckCode = recheckCode .. "  if (nextTime and (not recheckTime or nextTime < recheckTime) and nextTime >= now) then\n"
        recheckCode = recheckCode .. "    recheckTime = nextTime\n";
        recheckCode = recheckCode .. "  end\n"
      end
    elseif (cType == "timer" and value) then
      local variableString =  "state[" .. trigger .. "]" .. string.format("[%q]",  variable)
      local multiplyModRate = modRateProperty
            and  " * (state[" .. trigger .. "]" .. string.format("[%q]",  modRateProperty) .. " or 1.0)"
            or ""
      local andNotPaused = pausedProperty
            and "and not " .. "state[" .. trigger .. "]" .. string.format("[%q]",  pausedProperty)
            or ""

      recheckCode = "  nextTime = state[" .. trigger .. "] " .. andNotPaused
      .. " and " .. variableString
      .. " and " .. "(" .. variableString .. " - " .. value .. multiplyModRate .. ")\n"

      recheckCode = recheckCode .. "  if (nextTime and (not recheckTime or nextTime < recheckTime) and nextTime >= now) then\n"
      recheckCode = recheckCode .. "    recheckTime = nextTime\n";
      recheckCode = recheckCode .. "  end\n"
    elseif (cType == "elapsedTimer" and value) then
      recheckCode = "  nextTime = state[" .. trigger .. "] and state[" .. trigger .. "]" .. string.format("[%q]",  variable) .. " and (state[" .. trigger .. "]" .. string.format("[%q]",  variable) .. " +" .. value .. ")\n";
      recheckCode = recheckCode .. "  if (nextTime and (not recheckTime or nextTime < recheckTime) and nextTime >= now) then\n"
      recheckCode = recheckCode .. "    recheckTime = nextTime\n";
      recheckCode = recheckCode .. "  end\n"
    end
  end

  return check, recheckCode;
end

local function CreateCheckCondition(data, ret, condition, conditionNumber, allConditionsTemplate, nextIsLinked, debug)
  local usedStates = {};
  local check, recheckCode = CreateTestForCondition(data, condition.check, allConditionsTemplate, usedStates);
  if not check then
    check = "false"
  end
  if condition.linked and conditionNumber > 1 then
    table.insert(ret, "      elseif (" .. check .. ") then\n")
  else
    table.insert(ret, "      if (" .. check .. ") then\n")
  end
  table.insert(ret, "        newActiveConditions[" .. conditionNumber .. "] = true;\n")
  if not nextIsLinked then
    table.insert(ret, "      end\n")
  end

  if (check) then
    table.insert(ret, "\n")
  end
  return recheckCode;
end

local function ParseProperty(property)
  local subIndex, prop = string.match(property, "^sub%.(%d*).(.*)")
  if subIndex then
    return tonumber(subIndex), prop
  else
    return nil, property
  end
end

local function GetBaseProperty(data, property, start)
  if (not data) then
    return nil;
  end

  local subIndex, prop = ParseProperty(property)
  if subIndex then
    return GetBaseProperty(data.subRegions[subIndex], prop, start)
  end

  start = start or 1;
  local next = string.find(property, ".", start, true);
  if (next) then
    return GetBaseProperty(data[string.sub(property, start, next - 1)], property, next + 1);
  end

  local key = string.sub(property, start);
  return data[key] or data[tonumber(key)];
end

local function CreateDeactivateCondition(ret, condition, conditionNumber, data, properties, usedProperties, debug)
  if (condition.changes) then
    table.insert(ret, "  if (activatedConditions[".. conditionNumber .. "] and not newActiveConditions[" .. conditionNumber .. "]) then\n")
    if (debug) then table.insert(ret, "    print('Deactivating condition " .. conditionNumber .. "' )\n") end
    for changeNum, change in ipairs(condition.changes) do
      if (change.property) then
        local propertyData = properties and properties[change.property]
        if (propertyData and propertyData.type and propertyData.setter) then
          usedProperties[change.property] = true;
          table.insert(ret, "    propertyChanges['" .. change.property .. "'] = "
                .. formatValueForAssignment(propertyData.type, GetBaseProperty(data, change.property),
                                            nil, nil, data)
                .. "\n")
          if (debug) then
            table.insert(ret, "    print('- " .. change.property .. " "
                      .. formatValueForAssignment(propertyData.type, GetBaseProperty(data, change.property),
                                                 nil, nil, data)
                      .. "')\n")
          end
        end
      end
    end
    table.insert(ret, "  end\n")
  end

  return ret;
end

local function CreateActivateCondition(ret, id, condition, conditionNumber, data, properties, debug)
  if (condition.changes) then
    table.insert(ret, "  if (newActiveConditions[" .. conditionNumber .. "]) then\n")
    table.insert(ret, "    if (not activatedConditions[".. conditionNumber .. "]) then\n")
    if (debug) then table.insert(ret, "      print('Activating condition " .. conditionNumber .. "' )\n") end
    -- non active => active
    for changeNum, change in ipairs(condition.changes) do
      if (change.property) then
        local propertyData = properties and properties[change.property]
        if (propertyData and propertyData.type) then
          if (propertyData.setter) then
            table.insert(ret, "      propertyChanges['" .. change.property .. "'] = "
                      .. formatValueForAssignment(propertyData.type, change.value, nil, nil, data) .. "\n")
            if (debug) then
              table.insert(ret, "      print('- " .. change.property .. " "
                         .. formatValueForAssignment(propertyData.type, change.value, nil, nil, data) .. "')\n")
            end
          elseif (propertyData.action) then
            local pathToCustomFunction = "nil";
            local pathToFormatter = "nil"
            if (Private.ExecEnv.customConditionsFunctions[id]
              and Private.ExecEnv.customConditionsFunctions[id][conditionNumber]
              and  Private.ExecEnv.customConditionsFunctions[id][conditionNumber].changes
              and Private.ExecEnv.customConditionsFunctions[id][conditionNumber].changes[changeNum]) then
              pathToCustomFunction = string.format("Private.ExecEnv.customConditionsFunctions[%q][%s].changes[%s]",
                                                   id, conditionNumber, changeNum);
            end
            if Private.ExecEnv.conditionTextFormatters[id]
              and Private.ExecEnv.conditionTextFormatters[id][conditionNumber]
              and Private.ExecEnv.conditionTextFormatters[id][conditionNumber].changes
              and Private.ExecEnv.conditionTextFormatters[id][conditionNumber].changes[changeNum] then
              pathToFormatter = string.format("Private.ExecEnv.conditionTextFormatters[%q][%s].changes[%s]",
                                              id, conditionNumber, changeNum);
            end
            table.insert(ret, "     region:" .. propertyData.action .. "("
                      .. formatValueForAssignment(propertyData.type, change.value,
                                                  pathToCustomFunction, pathToFormatter, data)
                      .. ")" .. "\n")
            if (debug) then
              table.insert(ret, "     print('# " .. propertyData.action .. "("
                        .. formatValueForAssignment(propertyData.type, change.value,
                                                    pathToCustomFunction, pathToFormatter, data)
                        .. "')\n")
            end
          end
        end
      end
    end
    table.insert(ret, "    else\n")
    -- active => active, only override properties
    for changeNum, change in ipairs(condition.changes) do
      if (change.property) then
        local propertyData = properties and properties[change.property]
        if (propertyData and propertyData.type and propertyData.setter) then
          table.insert(ret, "      if(propertyChanges['" .. change.property .. "'] ~= nil) then\n")
          table.insert(ret, "        propertyChanges['" .. change.property .. "'] = "
                       .. formatValueForAssignment(propertyData.type, change.value, nil, nil, data) .. "\n")
          if (debug) then table.insert(ret, "        print('- " .. change.property .. " "
                       .. formatValueForAssignment(propertyData.type,  change.value, nil, nil, data) .. "')\n") end
          table.insert(ret, "      end\n")
        end
      end
    end
    table.insert(ret, "    end\n")
    table.insert(ret, "  end\n")
    table.insert(ret, "\n")
    table.insert(ret, "  activatedConditions[".. conditionNumber .. "] = newActiveConditions[" .. conditionNumber .. "]\n")
  end

  return ret;
end

function Private.GetSubRegionProperties(data, properties)
  if data.subRegions then
    local subIndex = {}
    for index, subRegion in ipairs(data.subRegions) do
      local subRegionTypeData = Private.subRegionTypes[subRegion.type];
      local propertiesFunction = subRegionTypeData and subRegionTypeData.properties
      local subProperties;
      if (type(propertiesFunction) == "function") then
        subProperties = propertiesFunction(data, subRegion);
      elseif propertiesFunction then
        subProperties = CopyTable(propertiesFunction)
      end

      if subProperties then
        for key, property in pairs(subProperties) do
          subIndex[key] = subIndex[key] and subIndex[key] + 1 or 1
          property.display = { subRegionTypeData.displayName .. " " .. subIndex[key],
                               property.display,
                               property.defaultProperty }
          properties["sub." .. index .. "." .. key ] = property;
        end
      end
    end
  end
end

function Private.GetProperties(data)
  local properties;
  local propertiesFunction = Private.regionTypes[data.regionType] and Private.regionTypes[data.regionType].properties;
  if (type(propertiesFunction) == "function") then
    properties = propertiesFunction(data);
  elseif propertiesFunction then
    properties = CopyTable(propertiesFunction);
  else
    properties = {}
  end

  Private.GetSubRegionProperties(data, properties)
  return properties;
end

function Private.LoadConditionPropertyFunctions(data)
  local id = data.id;
  if (data.conditions) then
    Private.ExecEnv.customConditionsFunctions[id] = {};
    for conditionNumber, condition in ipairs(data.conditions) do
      if (condition.changes) then
        for changeIndex, change in ipairs(condition.changes) do
          if ( (change.property == "chat" or change.property == "customcode") and type(change.value) == "table" and change.value.custom) then
            local custom = change.value.custom;
            local prefix, suffix;
            if (change.property == "chat") then
              prefix, suffix = "return ", "";
            else
              prefix, suffix = "return function()", "\nend";
            end
            local customFunc = WeakAuras.LoadFunction(prefix .. custom .. suffix, data.id);
            if (customFunc) then
              Private.ExecEnv.customConditionsFunctions[id][conditionNumber] = Private.ExecEnv.customConditionsFunctions[id][conditionNumber] or {};
              Private.ExecEnv.customConditionsFunctions[id][conditionNumber].changes = Private.ExecEnv.customConditionsFunctions[id][conditionNumber].changes or {};
              Private.ExecEnv.customConditionsFunctions[id][conditionNumber].changes[changeIndex] = customFunc;
            end
          end
          if change.property == "chat" then
            local getter = function(key, default)
              local fullKey = "message_format_" .. key
              if change.value[fullKey] == nil then
                change.value[fullKey] = default
              end
              return change.value[fullKey]
            end
            local formatters = change.value and Private.CreateFormatters(change.value.message, getter, true, data)
            Private.ExecEnv.conditionTextFormatters[id] = Private.ExecEnv.conditionTextFormatters[id] or {}
            Private.ExecEnv.conditionTextFormatters[id][conditionNumber] = Private.ExecEnv.conditionTextFormatters[id][conditionNumber] or {};
            Private.ExecEnv.conditionTextFormatters[id][conditionNumber].changes = Private.ExecEnv.conditionTextFormatters[id][conditionNumber].changes or {};
            Private.ExecEnv.conditionTextFormatters[id][conditionNumber].changes[changeIndex] = formatters;
          end
        end
      end
    end
  end
end

local globalConditions =
{
  ["incombat"] = {
    display = L["In Combat"],
    type = "bool",
    events = {"PLAYER_REGEN_ENABLED", "PLAYER_REGEN_DISABLED"},
    globalStateUpdate = function(state)
      state.incombat = UnitAffectingCombat("player");
    end
  },
  ["hastarget"] = {
    display = L["Has Target"],
    type = "bool",
    events = {"PLAYER_TARGET_CHANGED", "PLAYER_ENTERING_WORLD"},
    globalStateUpdate = function(state)
      state.hastarget = UnitExists("target");
    end
  },
  ["rangecheck"] = {
    display = WeakAuras.newFeatureString .. L["Range Check"],
    type = "range",
    control = "WeakAurasSpinBox",
    events = {"WA_SPELL_RANGECHECK"}
  },
  ["attackabletarget"] = {
    display = L["Attackable Target"],
    type = "bool",
    events = {"PLAYER_TARGET_CHANGED", "UNIT_FACTION"},
    globalStateUpdate = function(state)
      state.attackabletarget = UnitCanAttack("player", "target");
    end
  },
  ["customcheck"] = {
    display = L["Custom Check"],
    type = "customcheck"
  },
  ["alwaystrue"] = {
    display = L["Always True"],
    type = "alwaystrue"
  }
}

function Private.GetGlobalConditions()
  return globalConditions;
end

local function ConstructConditionFunction(data)
  local debug = false
  if (not data.conditions or #data.conditions == 0) then
    return nil
  end

  local usedProperties = {}

  local allConditionsTemplate = Private.GetTriggerConditions(data)
  allConditionsTemplate[-1] = Private.GetGlobalConditions()

  local ret = {""}
  table.insert(ret, "local newActiveConditions = {};\n")
  table.insert(ret, "local propertyChanges = {};\n")
  table.insert(ret, "local nextTime;\n")
  table.insert(ret, string.format("local uid = %q\n", data.uid))
  table.insert(ret, "return function(region, hideRegion)\n")
  if (debug) then table.insert(ret, "  print('check conditions for:', region.id, region.cloneId)\n") end
  table.insert(ret, "  local id = region.id\n")
  table.insert(ret, "  local cloneId = region.cloneId or ''\n")
  table.insert(ret, "  local state = region.states\n")
  table.insert(ret, "  local activatedConditions = WeakAuras.GetActiveConditions(id, cloneId)\n")
  table.insert(ret, "  wipe(newActiveConditions)\n")
  table.insert(ret, "  local recheckTime;\n")
  table.insert(ret, "  local now = GetTime();\n")

  -- First Loop gather which conditions are active
  table.insert(ret, "  if (not hideRegion) then\n")
  local recheckCode = {}
  if (data.conditions) then
    Private.ExecEnv.conditionHelpers[data.uid] = nil
    for conditionNumber, condition in ipairs(data.conditions) do
      local nextIsLinked = data.conditions[conditionNumber + 1] and data.conditions[conditionNumber + 1].linked
      local additionalRecheckCode = CreateCheckCondition(data, ret, condition, conditionNumber, allConditionsTemplate, nextIsLinked, debug)
      if additionalRecheckCode then
        table.insert(recheckCode, additionalRecheckCode)
      end
    end
  end
  table.insert(ret, table.concat(recheckCode))
  table.insert(ret, "  end\n")

  table.insert(ret, "  if (recheckTime) then\n")
  table.insert(ret, "    Private.ExecEnv.ScheduleConditionCheck(recheckTime, uid, cloneId);\n")
  table.insert(ret, "  else\n")
  table.insert(ret, "    Private.ExecEnv.CancelConditionCheck(uid, cloneId)")
  table.insert(ret, "  end\n")

  local properties = Private.GetProperties(data)

  -- Now build a property + change list
  -- Second Loop deals with conditions that are no longer active
  table.insert(ret, "  wipe(propertyChanges)\n")
  if (data.conditions) then
    for conditionNumber, condition in ipairs(data.conditions) do
      CreateDeactivateCondition(ret, condition, conditionNumber, data, properties, usedProperties, debug)
    end
  end
  table.insert(ret, "\n")

  -- Third Loop deals with conditions that are newly active
  if (data.conditions) then
    for conditionNumber, condition in ipairs(data.conditions) do
      CreateActivateCondition(ret, data.id, condition, conditionNumber, data, properties, debug)
    end
  end

  -- Last apply changes to region
  for property, _  in pairs(usedProperties) do
    table.insert(ret, "  if(propertyChanges['" .. property .. "'] ~= nil) then\n")
    local arg1 = ""
    if (properties[property].arg1) then
      if (type(properties[property].arg1) == "number") then
        arg1 = tostring(properties[property].arg1) .. ", "
      else
        arg1 = "'" .. properties[property].arg1 .. "', "
      end
    end

    local base = "region:"
    local subIndex = ParseProperty(property)
    if subIndex then
      base = "region.subRegions[" .. subIndex .. "]:"
    end

    table.insert(ret, "    " .. base .. properties[property].setter .. "(" .. arg1 .. formatValueForCall(properties[property].type, property)  .. ")\n")
    if (debug) then table.insert(ret, "    print('Calling "  .. properties[property].setter ..  " with', " .. arg1 ..  formatValueForCall(properties[property].type, property) .. ")\n") end
    table.insert(ret, "  end\n")
  end
  table.insert(ret, "end\n")

  return table.concat(ret)
end

local function CancelTimers(uid)
  conditionChecksTimers.recheckTime[uid] = nil;
  if (conditionChecksTimers.recheckHandle[uid]) then
    for _, v in pairs(conditionChecksTimers.recheckHandle[uid]) do
      timer:CancelTimer(v);
    end
  end
  conditionChecksTimers.recheckHandle[uid] = nil;
end

function Private.LoadConditionFunction(data)
  CancelTimers(data.uid)

  local checkConditionsFuncStr = ConstructConditionFunction(data);
  local checkConditionsFunc = checkConditionsFuncStr and Private.LoadFunction(checkConditionsFuncStr, data.id)

  checkConditions[data.uid] = checkConditionsFunc;
end

function Private.RunConditions(region, uid, hideRegion)
  if (checkConditions[uid]) then
    Private.ActivateAuraEnvironmentForRegion(region)
    xpcall(checkConditions[uid], Private.GetErrorHandlerUid(uid, L["Execute Conditions"]), region, hideRegion);
    Private.ActivateAuraEnvironment()
  end
end


local dynamicConditionsFrame = nil;

local globalConditionAllState = {
  [""] = {
    show = true;
  }
};

local globalConditionState = globalConditionAllState[""];

function Private.GetGlobalConditionState()
  return globalConditionAllState;
end

local function runDynamicConditionFunctions(funcs)
  for uid in pairs(funcs) do
    local id = Private.UIDtoID(uid)
    Private.StartProfileAura(id)
    if (Private.IsAuraActive(uid) and checkConditions[uid]) then
      local activeStates = WeakAuras.GetActiveStates(id)
      for cloneId, state in pairs(activeStates) do
        local region = WeakAuras.GetRegion(id, cloneId)
        Private.ActivateAuraEnvironmentForRegion(region)
        checkConditions[uid](region, false)
        Private.ActivateAuraEnvironment()
      end
    end
    Private.StopProfileAura(id)
  end
end

local function UpdateDynamicConditionsStates(self, event)
  if (globalDynamicConditionFuncs[event]) then
    for i, func in ipairs(globalDynamicConditionFuncs[event]) do
      func(globalConditionState);
    end
  end
end

local function handleDynamicConditions(self, event)
  Private.StartProfileSystem("dynamic conditions")
  UpdateDynamicConditionsStates(self, event)
  if (dynamicConditions[event]) then
    runDynamicConditionFunctions(dynamicConditions[event]);
  end
  Private.StopProfileSystem("dynamic conditions")
end

local function UpdateDynamicConditionsPerUnitState(self, event, unit)
  if unit then
    local unitEvent = event..":"..unit
    if globalDynamicConditionFuncs[unitEvent] then
      for i, func in ipairs(globalDynamicConditionFuncs[unitEvent]) do
        func(globalConditionState);
      end
    end
  end
end

local function handleDynamicConditionsPerUnit(self, event, unit)
  Private.StartProfileSystem("dynamic conditions")
  if unit then
    local unitEvent = event..":"..unit
    UpdateDynamicConditionsPerUnitState(self, event, unit)
    if (dynamicConditions[unitEvent]) then
      runDynamicConditionFunctions(dynamicConditions[unitEvent]);
    end
  end
  Private.StopProfileSystem("dynamic conditions")
end

local lastDynamicConditionsUpdateCheck;
local function handleDynamicConditionsOnUpdate(self)
  handleDynamicConditions(self, "FRAME_UPDATE");
  if (not lastDynamicConditionsUpdateCheck or GetTime() - lastDynamicConditionsUpdateCheck > 0.2) then
    lastDynamicConditionsUpdateCheck = GetTime();
    handleDynamicConditions(self, "WA_SPELL_RANGECHECK");
  end
end

local registeredGlobalFunctions = {};

local function EvaluateCheckForRegisterForGlobalConditions(uid, check, allConditionsTemplate, register)
  local trigger = check and check.trigger;
  local variable = check and check.variable;

  if (trigger == -2) then
    if (check.checks) then
      for _, subcheck in ipairs(check.checks) do
        EvaluateCheckForRegisterForGlobalConditions(uid, subcheck, allConditionsTemplate, register);
      end
    end
  elseif trigger == -1 and variable == "customcheck" then
    if check.op then
      for event in string.gmatch(check.op, "[%w_:]+") do
        if (not dynamicConditions[event]) then
          register[event] = true;
          dynamicConditions[event] = {};
        end
        dynamicConditions[event][uid] = true;
      end
    end
  elseif (trigger and variable) then
    local conditionTemplate = allConditionsTemplate[trigger] and allConditionsTemplate[trigger][variable];
    if (conditionTemplate and conditionTemplate.events) then
      for _, event in ipairs(conditionTemplate.events) do
        if (not dynamicConditions[event]) then
          register[event] = true;
          dynamicConditions[event] = {};
        end
        dynamicConditions[event][uid] = true;
      end

      if (conditionTemplate.globalStateUpdate and not registeredGlobalFunctions[variable]) then
        registeredGlobalFunctions[variable] = true;
        for _, event in ipairs(conditionTemplate.events) do
          globalDynamicConditionFuncs[event] = globalDynamicConditionFuncs[event] or {};
          tinsert(globalDynamicConditionFuncs[event], conditionTemplate.globalStateUpdate);
        end
        conditionTemplate.globalStateUpdate(globalConditionState);
      end
    end
  end
end

function Private.RegisterForGlobalConditions(uid)
  local data = Private.GetDataByUID(uid);
  for event, conditionFunctions in pairs(dynamicConditions) do
    conditionFunctions[uid] = nil;
  end

  local register = {};
  if (data.conditions) then
    local allConditionsTemplate = Private.GetTriggerConditions(data);
    allConditionsTemplate[-1] = Private.GetGlobalConditions();

    for conditionNumber, condition in ipairs(data.conditions) do
      EvaluateCheckForRegisterForGlobalConditions(uid, condition.check, allConditionsTemplate, register);
    end
  end

  if (next(register) and not dynamicConditionsFrame) then
    dynamicConditionsFrame = CreateFrame("Frame");
    dynamicConditionsFrame:SetScript("OnEvent", handleDynamicConditions);
    dynamicConditionsFrame.units = {}
    Private.frames["Rerun Conditions Frame"] = dynamicConditionsFrame
  end

  for event in pairs(register) do
    if (event == "FRAME_UPDATE" or event == "WA_SPELL_RANGECHECK") then
      if (not dynamicConditionsFrame.onUpdate) then
        dynamicConditionsFrame:SetScript("OnUpdate", handleDynamicConditionsOnUpdate);
        dynamicConditionsFrame.onUpdate = true;
      end
    else
      local unitEvent, unit = event:match("([^:]+):([^:]+)")
      if unitEvent and unit then
        unit = unit:lower()
        if not dynamicConditionsFrame.units[unit] then
          dynamicConditionsFrame.units[unit] = CreateFrame("Frame");
          dynamicConditionsFrame.units[unit]:SetScript("OnEvent", handleDynamicConditionsPerUnit);
        end
        pcall(dynamicConditionsFrame.units[unit].RegisterUnitEvent, dynamicConditionsFrame.units[unit], unitEvent, unit);
        UpdateDynamicConditionsPerUnitState(dynamicConditionsFrame, event, unit)
      else
        pcall(dynamicConditionsFrame.RegisterEvent, dynamicConditionsFrame, event);
        UpdateDynamicConditionsStates(dynamicConditionsFrame, event)
      end
    end
  end
end

function Private.UnregisterForGlobalConditions(uid)
  for event, condFuncs in pairs(dynamicConditions) do
    condFuncs[uid] = nil;
    if next(condFuncs) == nil then
      local unitEvent, unit = event:match("([^:]+):([^:]+)")
      if unitEvent and unit then
        unit = unit:lower()
        pcall(dynamicConditionsFrame.units[unit].UnregisterEvent, dynamicConditionsFrame.units[unit], unitEvent);
      elseif (event == "FRAME_UPDATE" or event == "WA_SPELL_RANGECHECK") then
        if (event == "FRAME_UPDATE" and dynamicConditions["WA_SPELL_RANGECHECK"] == nil)
        or (event == "WA_SPELL_RANGECHECK" and dynamicConditions["FRAME_UPDATE"] == nil)
        then
          dynamicConditionsFrame:SetScript("OnUpdate", nil)
          dynamicConditionsFrame.onUpdate = false
        end
      else
        pcall(dynamicConditionsFrame.UnregisterEvent, dynamicConditionsFrame, event);
      end
      dynamicConditions[event] = nil
    end
  end
end

function Private.UnloadAllConditions()
  for uid in pairs(conditionChecksTimers.recheckTime) do
    if (conditionChecksTimers.recheckHandle[uid]) then
      for _, v in pairs(conditionChecksTimers.recheckHandle[uid]) do
        timer:CancelTimer(v)
      end
    end
  end
  wipe(conditionChecksTimers.recheckTime)
  wipe(conditionChecksTimers.recheckHandle)

  dynamicConditions = {}
  if dynamicConditionsFrame then
    dynamicConditionsFrame:UnregisterAllEvents()
    for _, frame in pairs(dynamicConditionsFrame.units) do
      frame:UnregisterAllEvents()
    end
    dynamicConditionsFrame:SetScript("OnUpdate", nil)
    dynamicConditionsFrame.onUpdate = false
  end
end

function Private.UnloadConditions(uid)
  CancelTimers(uid)
  Private.UnregisterForGlobalConditions(uid);
end


-- ========================================
-- File: WeakAuras/DebugLog.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

--- @type table<uid, string[]|nil>
local debugLogs = {}
--- @type table<uid, boolean|nil>
local enabled = {}

--- @class debugLog
--- @field Print fun(uid: uid, text: string, ...: any)
--- @field Clear fun(uid: uid)
--- @field SetEnabled fun(uid: uid, enabled: uid)
--- @field IsEnabled fun(uid: uid) : boolean|nil
--- @field GetLogs fun(uid: uid) : string|nil

--- @type debugLog
Private.DebugLog = {
  Print = function(uid, text, ...) end,
  Clear = function(uid) end,
  SetEnabled = function(uid, enabled) end,
  IsEnabled = function(uid) end,
  GetLogs = function(uid) end
}

local function serialize(log, input)
  if type(input) == "table" then
    if log[#log] == "" then
      log[#log] = L["Dumping table"]
    else
      tinsert(log, L["Dumping table"])
    end
    -- Use dump to create a table dump, because that already handles depth limitation
    -- and cycles and looks nice
    -- But this requires temporarily setting DEFAULT_CHAT_FRAME
    -- Nothing can go wrong with that.
    local defaultChatFrame = _G.DEFAULT_CHAT_FRAME
    _G.DEFAULT_CHAT_FRAME = log
    DevTools_Dump(input)
    _G.DEFAULT_CHAT_FRAME = defaultChatFrame
    tinsert(log, "")
  else
    if log[#log] == "" then
      log[#log] = tostring(input)
    else
      log[#log] = log[#log] .. " " .. tostring(input)
    end
  end
end

--- DebugLog.Print the DebugPrint function for custom auras to call
---@param uid uid
---@param text string
---@param ... any
function Private.DebugLog.Print(uid, text, ...)
  if enabled[uid] then
    --- @type string[]
    local log = debugLogs[uid]
    tinsert(log, "")
    if select('#', ...) == 0 then
      serialize(log, text)
    else
      serialize(log, text)
      local texts = {...}
      for i = 1, select('#', ...) do
        local v = select(i, ...)
        serialize(log, v)
      end
    end

    if #log > 1000 then
      Private.AuraWarnings.UpdateWarning(uid, "Debug Log", "warning",
                                         L["Debug Log contains more than 1000 entries"],
                                         true)
    end
  end
end

--- Adds a message to the debug log
---@param self any
---@param msg string
local function AddMessage(self, msg)
  tinsert(self, msg)
end

--- Clears the debug log for a given uid
---@param uid uid
function Private.DebugLog.Clear(uid)
  if enabled[uid] then
    debugLogs[uid] = {
      AddMessage = AddMessage
    }
    -- Dance to clear a potential console message from the AuraWarnings
    Private.AuraWarnings.UpdateWarning(uid, "Debug Log", "info")
    Private.AuraWarnings.UpdateWarning(uid, "Debug Log", "info", L["Debug Logging enabled"])
  end
end

--- Enables/Disables the debug logging for a aura
---@param uid uid
---@param enable boolean
function Private.DebugLog.SetEnabled(uid, enable)
  if enabled[uid] == enable then
    return
  end
  enabled[uid] = enable
  if enable then
    debugLogs[uid] = {
      AddMessage = AddMessage
    }
    Private.AuraWarnings.UpdateWarning(uid, "Debug Log", "info", L["Debug Logging enabled"])
  else
    debugLogs[uid] = nil
    Private.AuraWarnings.UpdateWarning(uid, "Debug Log", "info")
  end
end

---Returns whether debug logging is enabled for the given aura uid
---@param uid uid
---@return boolean
function Private.DebugLog.IsEnabled(uid)
  return enabled[uid]
end

--- Returns the logs for a given aura uid
---@param uid uid
---@return string?
function Private.DebugLog.GetLogs(uid)
  if debugLogs[uid] then
    return table.concat(debugLogs[uid], "\n")
  end
end

--- Handles the deletion of an aura
---@param _ any
---@param uid uid
local function OnDelete(_, uid)
  debugLogs[uid] = nil
  enabled[uid] = nil
end

Private.callbacks:RegisterCallback("Delete", OnDelete)




-- ========================================
-- File: WeakAuras/DefaultOptions.lua
-- ========================================

--[[ Manual override for the default font and font size until proper options are built ]]

WeakAuras.defaultFont = "Friz Quadrata TT"
WeakAuras.defaultFontSize = 12


-- ========================================
-- File: WeakAuras/DiscordList.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
Private.DiscordList = {
  [=[AcidWeb]=],
  [=[aelen]=],
  [=[Alluneve]=],
  [=[Azortharion]=],
  [=[BadBrain]=],
  [=[Bart]=],
  [=[Boneshock]=],
  [=[Burlis]=],
  [=[Causese]=],
  [=[Chab]=],
  [=[Continuity]=],
  [=[Desik]=],
  [=[despi]=],
  [=[Dodgen]=],
  [=[Doomer Ipse]=],
  [=[exality]=],
  [=[Fatpala]=],
  [=[Fels]=],
  [=[Fenchurch]=],
  [=[Fliyin]=],
  [=[Guffin]=],
  [=[Ifor]=],
  [=[Ironi]=],
  [=[Jods]=],
  [=[kanegasi]=],
  [=[Karalana]=],
  [=[Korvus]=],
  [=[Koxy]=],
  [=[Krazyito]=],
  [=[Listefano]=],
  [=[Luckyone]=],
  [=[Luxthos]=],
  [=[m33shoq]=],
  [=[Manabanana]=],
  [=[MetalMusicMan]=],
  [=[Murph]=],
  [=[Mynze]=],
  [=[NoM0Re]=],
  [=[Nona]=],
  [=[NostraDumAzz]=],
  [=[Oi]=],
  [=[Ora]=],
  [=[phoenix7700]=],
  [=[Photoshoot]=],
  [=[pit]=],
  [=[Putro]=],
  [=[Reloe]=],
  [=[Spaten]=],
  [=[Tel]=],
  [=[Thorill]=],
  [=[Translit]=],
  [=[Wizeowel]=],
  [=[Xepheris]=],
  [=[Zytech]=],
}
Private.DiscordListCJ = {
}
Private.DiscordListK = {
}


-- ========================================
-- File: WeakAuras/Dragonriding.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local function HandleEvent(self, event, arg1)
  Private.callbacks:Fire("WA_DRAGONRIDING_UPDATE")
  if event == "PLAYER_ENTERING_WORLD" and arg1 == true then
    C_Timer.After(2, HandleEvent)
  end
end

local frame = CreateFrame("Frame")
frame:RegisterEvent("UNIT_POWER_BAR_SHOW")
frame:RegisterEvent("UNIT_POWER_BAR_HIDE")
frame:RegisterEvent("PLAYER_ENTERING_WORLD")
frame:SetScript("OnEvent", HandleEvent)

Private.IsDragonriding = function ()
  return UnitPowerBarID("player") == 631
end



-- ========================================
-- File: WeakAuras/Features.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end

---@type string
local addon = ...
---@class Private
local Private = select(2, ...)

---@alias BuildType "dev" | "pr" | "alpha" | "beta" | "release"

---@class feature
---@field id string
---@field autoEnable? BuildType[]
---@field requiredByAura? fun(self: self, aura: auraData): boolean
---@field enabled? boolean
---@field persist? true
---@field sub? SubscribableObject

---@class Features
---@field private db? table<string, boolean>
---@field private __feats table<string, feature>
---@field private hydrated boolean
local Features = {
  __feats = {},
  hydrated = false,
}
Private.Features = Features

---@param id string
function Features:Exists(id)
  return self.__feats[id] ~= nil
end

---@param id string
function Features:Enabled(id)
    return self.hydrated and self:Exists(id) and self.__feats[id].enabled
end

---@param id string
function Features:Enable(id)
  if not self:Exists(id) then return end
  if not self.hydrated then
    error("Cannot enable a feature before hydration", 2)
  elseif not self.__feats[id].enabled then
    self.__feats[id].enabled = true
    if self.__feats[id].persist then
      self.db[id] = true
    end
    self.__feats[id].sub:Notify("Enable")
  end
end

---@param id string
function Features:Disable(id)
  if not self:Exists(id) then return end
  if not self.hydrated then
    error("Cannot disable a feature before hydration", 2)
  elseif self.__feats[id].enabled then
    self.__feats[id].enabled = false
    if self.__feats[id].persist then
      self.db[id] = false
    end
    self.__feats[id].sub:Notify("Disable")
  end
end

---@return {id: string, enabled: boolean}[]
function Features:ListFeatures()
  if not self.hydrated then return {} end
  local list = {}
  for id, feature in pairs(self.__feats) do
    table.insert(list, {
      id = id,
      enabled = feature.enabled
    })
  end
  table.sort(list, function(a, b)
    return a.id < b.id
  end)
  return list
end

function Features:Hydrate()
  self.db = Private.db.features
  for id, feature in pairs(self.__feats) do
    local enable = false
    if self.db[id] ~= nil then
      enable = self.db[id]
    else
      for _, buildType in ipairs(feature.autoEnable or {}) do
        if WeakAuras.buildType == buildType then
          enable = true
          break
        end
      end
    end
    feature.enabled = enable
  end
  self.hydrated = true
  for _, feature in pairs(self.__feats) do
    -- cannot notify before hydrated flag is set, or we risk consumers getting wrong information
    feature.sub:Notify(feature.enabled and "Enable" or "Disable")
  end
end

---@param feature feature
function Features:Register(feature)
  if self.hydrated then
    error("Cannot register a feature after hydration", 2)
  end
  if not self.__feats[feature.id] then
    self.__feats[feature.id] = feature
    feature.sub = Private.CreateSubscribableObject()
  end
end

---@param id string
---@param enabledFunc function
---@param disabledFunc? function
---hide a code path behind a feature flag,
---optionally provide a disabled path
function Features:Wrap(id, enabledFunc, disabledFunc)
  return function(...)
    if self:Enabled(id) then
      return enabledFunc(...)
    else
      if disabledFunc then
        return disabledFunc(...)
      end
    end
  end
end

---@param data auraData
---@return boolean, table<string, boolean>
function Features:AuraCanFunction(data)
  local enabled = true
  local reasons = {}

  for _, feature in pairs(self.__feats) do
    if feature.requiredByAura and not feature:requiredByAura(data) then
      enabled = false
      reasons[feature.id] = false
    end
  end

  return enabled, reasons
end

---@param id string
---@param enable function
---@param disable function
function Features:Subscribe(id, enable, disable)
  local tbl = {
    Enable = enable,
    Disable = disable
  }
  if self:Exists(id) then
    self.__feats[id].sub:AddSubscriber("Enable", tbl)
    self.__feats[id].sub:AddSubscriber("Disable", tbl)
  end
end


Features:Register({
  id = "debug",
  autoEnable = {"dev"}
})

Private.DebugPrint = Features:Wrap("debug", function(...)
  print("|cff00d3ffWeakAuras-Debug:|r ", ...)
end)



-- ========================================
-- File: WeakAuras/GenericTrigger.lua
-- ========================================

--[[ GenericTrigger.lua
This file contains the generic trigger system. That is every trigger except the aura triggers.

It registers the GenericTrigger table for the generic trigger types and "custom" and has the following API:

Add(data)
Adds a display, creating all internal data structures for all triggers.

Delete(id)
Deletes all triggers for display id.

Rename(oldid, newid)
Updates all trigger information from oldid to newid.

LoadDisplay(id)
Loads all triggers of display id.

UnloadAll
Unloads all triggers.

UnloadDisplays(id)
Unloads all triggers of the display ids.

Modernize(data)
Modernizes all generic triggers in data.

#####################################################
# Helper functions mainly for the WeakAuras Options #
#####################################################
GetOverlayInfo(data, triggernum)
Returns a table containing the names of all overlays

CanHaveTooltip(data, triggernum)
Returns the type of tooltip to show for the trigger.

GetNameAndIcon(data, triggernum)
Returns the name and icon to show in the options.

GetAdditionalProperties(data, triggernum)
Returns the a tooltip for the additional properties.

GetProgressSources(data, triggernum, outValues)
  Fills outValues with the potential progress sources

GetTriggerConditions(data, triggernum)
Returns potential conditions that this trigger provides.
]]--
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

-- Lua APIs
local tinsert, tconcat, wipe = table.insert, table.concat, wipe
local tostring, pairs, type = tostring, pairs, type
local error = error
local CombatLogGetCurrentEventInfo = CombatLogGetCurrentEventInfo;

-- WoW APIs
local IsPlayerMoving = IsPlayerMoving

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;
local GenericTrigger = {};

local event_prototypes = Private.event_prototypes;

local timer = WeakAuras.timer;

local events = {}
local loaded_events = {}
local loaded_unit_events = {};
local watched_trigger_events = Private.watched_trigger_events
local delayTimerEvents = {}
local loaded_auras = {}; -- id to bool map

-- Local functions
local LoadEvent, HandleEvent, HandleUnitEvent, TestForTriState, TestForToggle, TestForLongString, TestForMultiSelect
local ConstructTest, ConstructFunction


local nameplateExists = {}

---@param unit UnitToken
---@param smart? boolean
---@return boolean unitExists
function WeakAuras.UnitExistsFixed(unit, smart)
  if #unit > 9 and unit:sub(1, 9) == "nameplate" then
    return nameplateExists[unit]
  end
  if smart and IsInRaid() then
    if unit:sub(1, 5) == "party" or unit == "player" or unit == "pet" then
      return false
    end
  end
  return UnitExists(unit) or UnitGUID(unit)
end

---@param input string
---@return string[] subStrings
function WeakAuras.split(input)
  input = input or "";
  local ret = {};
  local split, element = nil, nil
  split = input:find("[,%s]");
  while(split) do
    element, input = input:sub(1, split-1), input:sub(split+1);
    if(element ~= "") then
      tinsert(ret, element);
    end
    split = input:find("[,%s]");
  end
  if(input ~= "") then
    tinsert(ret, input);
  end
  return ret;
end

local function findFirstOf(input, words, start, plain)
  local startPos, endPos
  for _, w in ipairs(words) do
    local s, e = input:find(w, start, plain)
    if s and (not startPos or startPos > s) then
      startPos, endPos = s, e
    end
  end
  return startPos, endPos
end

---@param input string
---@return string[] subStrings
function Private.splitAtOr(input)
  input = input or ""
  local ret = {}
  local splitStart, splitEnd, element = nil, nil, nil
  local separators = { "|", " or "}
  splitStart, splitEnd = findFirstOf(input, separators, 1, true);
  while(splitStart) do
    element, input = input:sub(1, splitStart -1 ), input:sub(splitEnd + 1)
    if(element ~= "") then
      tinsert(ret, element)
    end
    splitStart, splitEnd = findFirstOf(input, separators, 1, true);
  end
  if(input ~= "") then
    tinsert(ret, input)
  end
  return ret;
end

function TestForTriState(trigger, arg)
  local name = arg.name;
  local test;
  if(trigger["use_"..name] == false) then
    test = "(not "..name..")";
  elseif(trigger["use_"..name]) then
    if(arg.test) then
      test = "("..arg.test:format(trigger[name])..")";
    else
      test = name;
    end
  end
  return test;
end

function TestForToggle(trigger, arg)
  local name = arg.name;
  local test;
  if(trigger["use_"..name]) then
    if(arg.test) then
      test = "("..arg.test:format(trigger[name])..")";
    else
      test = name;
    end
  end
  return test;
end

function TestForLongString(trigger, arg)
  local name = arg.name;
  local test;
  local needle = trigger[name]
  local caseInsensitive = arg.canBeCaseInsensitive and trigger[name .. "_caseInsensitive"]
  if(trigger[name.."_operator"] == "==") then
    if caseInsensitive then
      test = ("(%s and (%s):lower() == (%s):lower())"):format(name, name, Private.QuotedString(needle))
    else
      test = ("(%s == %s)"):format(name, Private.QuotedString(needle))
    end
  elseif(trigger[name.."_operator"] == "find('%s')") then
    if caseInsensitive then
      test = ("(%s and %s:lower():find((%s):lower(), 1, true))"):format(name, name, Private.QuotedString(needle))
    else
      test = ("(%s and %s:find(%s, 1, true))"):format(name, name, Private.QuotedString(needle))
    end
  elseif(trigger[name.."_operator"] == "match('%s')") then
    if caseInsensitive then
      test = ("(%s and %s:lower():match((%s):lower()))"):format(name, name, Private.QuotedString(needle))
    else
      test = ("(%s and %s:match(%s))"):format(name, name, Private.QuotedString(needle))
    end
  end
  return test;
end

function TestForMultiSelect(trigger, arg)
  local name = arg.name;
  local test;
  if(trigger["use_"..name] == false) then -- multi selection
    test = "(";
    local any = false;
    if trigger[name] and trigger[name].multi then
      for value, _ in pairs(trigger[name].multi) do
        if not arg.test then
          test = test..name.."=="..(tonumber(value) or ("[["..value.."]]")).." or ";
        else
          test = test..arg.test:format(tonumber(value) or ("[["..value.."]]")).." or ";
        end
        any = true;
      end
    end
    if(any) then
      test = test:sub(1, -5);
    else
      test = "(false";
    end
    test = test..")";
  elseif(trigger["use_"..name]) then -- single selection
    local value = trigger[name] and trigger[name].single;
    if (not value) then
      test = "false";
      return test;
    end
    if not arg.test then
      test = trigger[name].single and "("..name.."=="..(tonumber(value) or ("[["..value.."]]"))..")";
    else
      test = trigger[name].single and "("..arg.test:format(tonumber(value) or ("[["..value.."]]"))..")";
    end
  end
  return test;
end

local function singleTest(arg, trigger, name, value, operator, use_exact)
  local number = tonumber(value)
  if(arg.type == "tristate") then
    return TestForTriState(trigger, arg);
  elseif(arg.type == "multiselect") then
    return TestForMultiSelect(trigger, arg);
  elseif(arg.type == "toggle") then
    return TestForToggle(trigger, arg);
  elseif (arg.type == "spell" or arg.type == "item") then
    if arg.test then
      if arg.showExactOption then
        return "("..arg.test:format(value, tostring(use_exact) or "false") ..")";
      else
        return "("..arg.test:format(value)..")";
      end
    else
      return "(".. name .." and "..name.."==" ..(number or ("\""..(tostring(value) or "").."\""))..")";
    end
  elseif(arg.test) then
    return "("..arg.test:format(tostring(value) or "")..")";
  elseif(arg.type == "longstring" and operator) then
    return TestForLongString(trigger, arg);
  elseif (arg.type == "string" or arg.type == "select") then
    return "(".. name .." and "..name.."==" ..(number or ("\""..(tostring(value) or "").."\""))..")";
  elseif (arg.type == "number") then
    return "(".. name .." and "..name..(operator or "==")..(number or 0) ..")";
  else
    -- Should be unused
    return "(".. name .." and "..name..(operator or "==")..(number or ("\""..(tostring(value) or 0).."\""))..")";
  end
end

function ConstructTest(trigger, arg, preambleGroups)
  local test
  local preamble
  local name = arg.name;

  if arg.preamble then
    if not arg.preambleGroup or not preambleGroups[arg.preambleGroup] then
      preamble = arg.preamble:format(trigger[name] or "")
    end
    if arg.preambleGroup then
      preambleGroups[arg.preambleGroup] = true
    end
  end

  if arg.hidden
    or arg.type == "tristate"
    or arg.type == "toggle"
    or (arg.type == "multiselect" and trigger["use_"..name] ~= nil)
    or ((trigger["use_"..name] or arg.required) and trigger[name])
  then
    if arg.multiEntry then
      if type(trigger[name]) == "table" and #trigger[name] > 0 then
        test = ""
        for i, value in ipairs(trigger[name]) do
          local operator = name and type(trigger[name.."_operator"]) == "table" and trigger[name.."_operator"][i]
          local use_exact = name and type(trigger["use_exact_" .. name]) == "table" and trigger["use_exact_" .. name][i]

          if arg.multiEntry.operator == "preamble" then
            preamble = preamble and (preamble .. "\n") or ""
            preamble = preamble .. arg.multiEntry.preambleAdd:format(value)
          else
            local single = singleTest(arg, trigger, name, value, operator, use_exact)
            if single then
              if test ~= "" then
                test = test .. arg.multiEntry.operator
              end
              test = test .. single
            end
          end
        end

        if arg.multiEntry.operator == "preamble" then
          test = arg.test
        end

        if test == "" then
          test = nil
        else
          test = "(" .. test .. ")"
        end
      end
    else
      local value = trigger[name]
      local operator = name and trigger[name.."_operator"]
      local use_exact = name and trigger["use_exact_" .. name]
      test = singleTest(arg, trigger, name, value, operator, use_exact)
    end
  end

  if not test or test == "(true)" then
    return nil, preamble
  end

  return test, preamble
end

function ConstructFunction(prototype, trigger)
  if (prototype.triggerFunction) then
    return prototype.triggerFunction(trigger);
  end

  local input;
  if (prototype.statesParameter) then
    if prototype.countEvents then
      input = {"state", "counter", "event"};
    else
      input = {"state", "event"};
    end
  else
    if prototype.countEvents then
      input = {"counter", "event"};
    else
      input = {"event"};
    end
  end

  local required = {};
  local tests = {};
  local debug = {};
  local store = {};
  local init;
  local preambles = "\n"
  local orConjunctionGroups = {}
  local preambleGroups = {}
  if(prototype.init) then
    init = prototype.init(trigger);
  else
    init = "";
  end
  for index, arg in pairs(prototype.args) do
    local enable = arg.type ~= "description";
    if(type(arg.enable) == "function") then
      enable = arg.enable(trigger);
    elseif type(arg.enable) == "boolean" then
      enable = arg.enable
    end
    if(enable) then
      local name = arg.name;
      if not(arg.name or arg.hidden) then
        tinsert(input, "_");
      else
        if(arg.init == "arg") then
          tinsert(input, name);
        elseif(arg.init) then
          init = init.."local "..name.." = "..arg.init.."\n";
        end
        if (arg.store) then
          tinsert(store, name);
        end
        local test, preamble = ConstructTest(trigger, arg, preambleGroups);
        if (test) then
          if(arg.required) then
            tinsert(required, test);
          else
            if arg.orConjunctionGroup then
              orConjunctionGroups[arg.orConjunctionGroup] = orConjunctionGroups[arg.orConjunctionGroup] or {}
              tinsert(orConjunctionGroups[arg.orConjunctionGroup], test)
            else
              tinsert(tests, test);
            end
          end
          if(arg.debug) then
            tinsert(debug, arg.debug:format(trigger[name]));
          end
        end
        if (preamble) then
          preambles = preambles .. preamble .. "\n"
        end
      end
    end
  end

  for _, orConjunctionGroup in pairs(orConjunctionGroups) do
    tinsert(tests, "("..table.concat(orConjunctionGroup, " or ")..")")
  end

  local ret = {preambles .. "return function("..tconcat(input, ", ")..")\n"}
  if init then
    table.insert(ret, init)
  end
  if #debug > 0 then
    table.insert(ret, tconcat(debug, "\n") or "")
  end

  table.insert(ret, "if("..((#required > 0) and tconcat(required, " and ").." and " or ""))
  table.insert(ret, #tests > 0 and tconcat(tests, " and ") or "true")
  table.insert(ret, ") then\n")
  if(#debug > 0) then
    table.insert("print('ret: true');\n")
  end

  if (prototype.statesParameter == "all") then
    table.insert(ret, "  state[cloneId] = state[cloneId] or {}\n")
    table.insert(ret, "  state = state[cloneId]\n")
    table.insert(ret, "  state.changed = true\n")
  end

  if prototype.countEvents then
    table.insert(ret, "  local count = counter:GetNext()\n")
    if trigger.use_count and type(trigger.count) == "string" and trigger.count ~= "" then
      table.insert(ret, "  local match = counter:Match()")
      table.insert(ret, "  if not match then return false end\n")
    end
    table.insert(ret, "  state.count = count\n")
    table.insert(ret, "  state.changed = true\n")
  end

  for _, v in ipairs(store) do
    table.insert(ret, "    if (state." .. v .. " ~= " .. v .. ") then\n")
    table.insert(ret, "      state." .. v .. " = " .. v .. "\n")
    table.insert(ret, "      state.changed = true\n")
    table.insert(ret, "    end\n")
  end
  table.insert(ret, "return true else return false end end")

  return table.concat(ret);
end

function Private.EndEvent(state)
  if state then
    if (state.show ~= false and state.show ~= nil) then
      state.show = false;
      state.changed = true;
    end
    return state.changed;
  else
    return false
  end
end

local function RunOverlayFuncs(event, state, id, errorHandler)
  state.additionalProgress = state.additionalProgress or {};
  local changed = false;
  for i, overlayFunc in ipairs(event.overlayFuncs) do
    state.additionalProgress[i] = state.additionalProgress[i] or {};
    local additionalProgress = state.additionalProgress[i];
    local ok, a, b, c = xpcall(overlayFunc, errorHandler or Private.GetErrorHandlerId(id, L["Overlay %s"]:format(i)), event.trigger, state);
    if (not ok) then
      additionalProgress.min = nil;
      additionalProgress.max = nil;
      additionalProgress.direction = nil;
      additionalProgress.width = nil;
      additionalProgress.offset = nil;
    elseif (type(a) == "string") then
      if (additionalProgress.direction ~= a) then
        additionalProgress.direction = a;
        changed = true;
      end
      if (additionalProgress.width ~= b) then
        additionalProgress.width = b;
        changed = true;
      end
      if (additionalProgress.offset ~= c) then
        additionalProgress.offset = c;
        changed = true;
      end
      additionalProgress.min = nil;
      additionalProgress.max = nil;
    else
      if (additionalProgress.min ~= a) then
        additionalProgress.min = a;
        changed = true;
      end
      if (additionalProgress.max ~= b) then
        additionalProgress.max = b;
        changed = true;
      end
      if additionalProgress.direction then
        changed = true
      end
      additionalProgress.direction = nil;
      additionalProgress.width = nil;
      additionalProgress.offset = nil;
    end

  end
  state.changed = changed or state.changed;
end

local function callFunctionForActivateEvent(func, trigger, state, property, errorHandler)
  if not func then
    return
  end
  local ok, value = xpcall(func, errorHandler, trigger)
  if ok then
    if state[property] ~= value then
      state[property] = value
      state.changed = true
    end
  end
end

---@type fun(id, triggernum, data, state, errorHandler)
---@return state
function Private.ActivateEvent(id, triggernum, data, state, errorHandler)
  local changed = state.changed or false;
  if (state.show ~= true) then
    state.show = true;
    changed = true;
  end
  if (data.duration) then
    local expirationTime = GetTime() + data.duration;
    if (state.expirationTime ~= expirationTime) then
      state.expirationTime = expirationTime;
      changed = true;
    end
    if (state.duration ~= data.duration) then
      state.duration = data.duration;
      changed = true;
    end
    if (state.progressType ~= "timed") then
      state.progressType = "timed";
      changed = true;
    end
    local autoHide = data.automaticAutoHide;
    if (state.value or state.total or state.inverse or state.autoHide ~= autoHide) then
      changed = true;
    end
    state.value = nil;
    state.total = nil;
    state.inverse = nil;
    state.autoHide = autoHide;
  elseif (data.durationFunc) then
    local ok, arg1, arg2, arg3, inverse = xpcall(data.durationFunc, errorHandler or Private.GetErrorHandlerId(id, L["Duration Function"]), data.trigger);
    arg1 = ok and type(arg1) == "number" and arg1 or 0;
    arg2 = ok and type(arg2) == "number" and arg2 or 0;


    if (state.inverse ~= inverse) then
      state.inverse = inverse;
      changed = true;
    end

    if (arg3) then
      if (state.progressType ~= "static") then
        state.progressType = "static";
        changed = true;
      end
      if (state.duration) then
        state.duration = nil;
        changed = true;
      end
      if (state.expirationTime) then
        state.expirationTime = nil;
        changed = true;
      end

      local autoHide = nil;
      if (state.autoHide ~= autoHide) then
        changed = true;
        state.autoHide = autoHide;
      end

      if (state.value ~= arg1) then
        state.value = arg1;
        changed = true;
      end
      if (state.total ~= arg2) then
        state.total = arg2;
        changed = true;
      end
    else
      if (state.progressType ~= "timed") then
        state.progressType = "timed";
        changed = true;
      end
      if (state.duration ~= arg1) then
        state.duration = arg1;
      end
      -- The Icon's SetCooldown requires that the **startTime** is positive, so ensure that
      -- the expirationTime is bigger than the duration
      if arg2 <= arg1 then
        arg2 = arg1
      end
      if (state.expirationTime ~= arg2) then
        state.expirationTime = arg2;
        changed = true;
      end
      local autoHide = data.automaticAutoHide and arg1 > 0.01;
      if (state.autoHide ~= autoHide) then
        changed = true;
        state.autoHide = autoHide;
      end
      if (state.value or state.total) then
        changed = true;
      end
      state.value = nil;
      state.total = nil;
    end
  end

  callFunctionForActivateEvent(data.nameFunc, data.trigger, state, "name", errorHandler or Private.GetErrorHandlerId(id, L["Name Function"]))
  callFunctionForActivateEvent(data.iconFunc, data.trigger, state, "icon", errorHandler or Private.GetErrorHandlerId(id, L["Icon Function"]))
  callFunctionForActivateEvent(data.textureFunc, data.trigger, state, "texture", errorHandler or Private.GetErrorHandlerId(id, L["Texture Function"]))
  callFunctionForActivateEvent(data.stacksFunc, data.trigger, state, "stacks", errorHandler or Private.GetErrorHandlerId(id, L["Stacks Function"]))

  if (data.overlayFuncs) then
    RunOverlayFuncs(data, state, id, errorHandler);
  end

  state.changed = state.changed or changed;

  return state.changed;
end

local function ignoreErrorHandler()

end

local function RunTriggerFunc(allStates, data, id, triggernum, event, arg1, arg2, ...)
  local optionsEvent = event == "OPTIONS";
  local errorHandler = (optionsEvent and data.ignoreOptionsEventErrors) and ignoreErrorHandler or Private.GetErrorHandlerId(id, L["Trigger %s"]:format(triggernum))
  local updateTriggerState = false;

  local unitForUnitTrigger
  local cloneIdForUnitTrigger

  if(data.triggerFunc) then
    local untriggerCheck = false;
    if (data.statesParameter == "full") then
      local ok, returnValue
      if data.counter then
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, allStates, data.counter, event, arg1, arg2, ...);
      else
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, allStates, event, arg1, arg2, ...);
      end
      if (ok and (returnValue or (returnValue ~= false and allStates:IsChanged()))) then
        updateTriggerState = true;
      end
      allStates:SetChanged()
      for key, state in pairs(allStates) do
        if (type(state) ~= "table") then
          errorHandler(string.format(L["All States table contains a non table at key: '%s'."], key))
          wipe(allStates)
          return
        end
      end
    elseif (data.statesParameter == "all") then
      local ok, returnValue
      if data.counter then
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, allStates, data.counter, event, arg1, arg2, ...);
      else
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, allStates, event, arg1, arg2, ...);
      end
      if( (ok and returnValue) or optionsEvent) then
        for id, state in pairs(allStates) do
          if (state.changed) then
            if (Private.ActivateEvent(id, triggernum, data, state)) then
              updateTriggerState = true;
            end
          end
        end
      else
        untriggerCheck = true;
      end
    elseif (data.statesParameter == "unit") then
      if arg1 then
        if Private.multiUnitUnits[data.trigger.unit] then
          if data.trigger.unit == "group" and IsInRaid() and Private.multiUnitUnits.party[arg1] then
            return
          end

          unitForUnitTrigger = arg1
          cloneIdForUnitTrigger = arg1
        else
          unitForUnitTrigger = data.trigger.unit
          cloneIdForUnitTrigger = ""
        end
        allStates[cloneIdForUnitTrigger] = allStates[cloneIdForUnitTrigger] or {};
        local state = allStates[cloneIdForUnitTrigger];
        local ok, returnValue
        if data.counter then
          ok, returnValue = xpcall(data.triggerFunc, errorHandler, state, data.counter, event, unitForUnitTrigger, arg1, arg2, ...);
        else
          ok, returnValue = xpcall(data.triggerFunc, errorHandler, state, event, unitForUnitTrigger, arg1, arg2, ...);
        end
        if (ok and returnValue) or optionsEvent then
          if(Private.ActivateEvent(id, triggernum, data, state)) then
            updateTriggerState = true;
          end
        else
          untriggerCheck = true;
        end
      end
    elseif (data.statesParameter == "one") then
      allStates[""] = allStates[""] or {};
      local state = allStates[""];
      local ok, returnValue
      if data.counter then
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, state, data.counter, event, arg1, arg2, ...);
      else
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, state, event, arg1, arg2, ...);
      end
      if (ok and returnValue) or optionsEvent then
        if(Private.ActivateEvent(id, triggernum, data, state, (optionsEvent and data.ignoreOptionsEventErrors) and ignoreErrorHandler or nil)) then
          updateTriggerState = true;
        end
      else
        untriggerCheck = true;
      end
    else
      local ok, returnValue
      if data.counter then
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, data.counter, event, arg1, arg2, ...);
      else
        ok, returnValue = xpcall(data.triggerFunc, errorHandler, event, arg1, arg2, ...);
      end
      if (ok and returnValue) or optionsEvent then
        allStates[""] = allStates[""] or {};
        local state = allStates[""];
        if(Private.ActivateEvent(id, triggernum, data, state, (optionsEvent and data.ignoreOptionsEventErrors) and ignoreErrorHandler or nil)) then
          updateTriggerState = true;
        end
      else
        untriggerCheck = true;
      end
    end
    if (untriggerCheck and not optionsEvent) then
      errorHandler = (optionsEvent and data.ignoreOptionsEventErrors) and ignoreErrorHandler or Private.GetErrorHandlerId(id, L["Untrigger %s"]:format(triggernum))
      if (data.statesParameter == "all") then
        if data.untriggerFunc then
          local ok, returnValue = xpcall(data.untriggerFunc, errorHandler, allStates, event, arg1, arg2, ...);
          if ok and returnValue then
            for id, state in pairs(allStates) do
              if (state.changed) then
                if (Private.EndEvent(state)) then
                  updateTriggerState = true;
                end
              end
            end
          end
        end
      elseif data.statesParameter == "unit" then
        if data.untriggerFunc then
          if arg1 then
            local state = allStates[cloneIdForUnitTrigger]
            if state then
              local ok, returnValue =  xpcall(data.untriggerFunc, errorHandler, state, event, unitForUnitTrigger, arg1, arg2, ...);
              if ok and returnValue then
                if (Private.EndEvent(state)) then
                  updateTriggerState = true;
                end
              end
            end
          end
        end
        if not updateTriggerState and not allStates[cloneIdForUnitTrigger].show then
          -- We added this state automatically, but the trigger didn't end up using it,
          -- so remove it again
          allStates[cloneIdForUnitTrigger] = nil
        end
      elseif (data.statesParameter == "one") then
        allStates[""] = allStates[""] or {};
        local state = allStates[""];
        if data.untriggerFunc then
          local ok, returnValue = xpcall(data.untriggerFunc, errorHandler, state, event, arg1, arg2, ...);
          if (ok and returnValue) then
            if (Private.EndEvent(state)) then
              updateTriggerState = true;
            end
          end
        end
      else
        if data.untriggerFunc then
          local ok, returnValue = xpcall(data.untriggerFunc, errorHandler, event, arg1, arg2, ...);
          if ok and returnValue then
            allStates[""] = allStates[""] or {};
            local state = allStates[""];
            if(Private.EndEvent(state)) then
              updateTriggerState = true;
            end
          end
        end
      end
    end
  end
  if updateTriggerState and watched_trigger_events[id] and watched_trigger_events[id][triggernum] then
    -- if this trigger's updates are requested to be sent into one of the Aura's custom triggers
    Private.AddToWatchedTriggerDelay(id, triggernum)
  end
  return updateTriggerState;
end

---ScanEvents may receive composed events like `event:spellId`
---For system profiling we want extract the event
---@param composedEvent string
---@return string
local function getGameEventFromComposedEvent(composedEvent)
  local separatorPosition = composedEvent:find(":", 1, true)
  return separatorPosition == nil and composedEvent or composedEvent:sub(1, separatorPosition - 1)
end

local scannerFrame = CreateFrame("Frame")
scannerFrame.queue = {}
scannerFrame:Hide()
scannerFrame:SetScript("OnUpdate", function(self)
  local todo = self.queue
  self.queue = {}
  for _, event in ipairs(todo) do
    event.func(unpack(event.args))
  end
  -- there's a chance that a joker dispatched an event in in trigger code,
  -- so the queue might already be populated
  -- in that case, we'll process next frame by declining to hide
  if #self.queue == 0 then
    self:Hide()
  end
end)

function scannerFrame:Queue(func, ...)
  tinsert(self.queue, {func = func, args = {...}})
  self:Show()
end

function Private.ScanEventsByID(event, id, ...)
  if loaded_events[event] then
    Private.ScanEvents(event, id, ...)
  end
  local eventWithID = event .. ":" .. id
  if loaded_events[eventWithID] then
    Private.ScanEvents(eventWithID, id, ...)
  end
end

function WeakAuras.ScanEventsByID(event, id, ...)
  scannerFrame:Queue(Private.ScanEventsByID, event, id, ...)
end

---@param event string
---@param arg1? any
---@param arg2? any
---@param ... any
function Private.ScanEvents(event, arg1, arg2, ...)
  local system = getGameEventFromComposedEvent(event)
  Private.StartProfileSystem("generictrigger " .. system)
  local event_list = loaded_events[event];
  if (not event_list) then
    Private.StopProfileSystem("generictrigger " .. system)
    return
  end
  if(event == "COMBAT_LOG_EVENT_UNFILTERED") then
    local arg1, arg2 = CombatLogGetCurrentEventInfo();

    event_list = event_list[arg2];
    if (not event_list) then
      Private.StopProfileSystem("generictrigger " .. system)
      return;
    end
    Private.ScanEventsInternal(event_list, event, CombatLogGetCurrentEventInfo());
  else
    Private.ScanEventsInternal(event_list, event, arg1, arg2, ...);
  end
  Private.StopProfileSystem("generictrigger " .. system)
end

function WeakAuras.ScanEvents(event, arg1, arg2, ...)
  if type(event) ~= "string" then
    return
  end
  scannerFrame:Queue(Private.ScanEvents, event, arg1, arg2, ...)
end

---@param event string
---@param unit UnitToken
---@param ... any
function Private.ScanUnitEvents(event, unit, ...)
  Private.StartProfileSystem("generictrigger " .. event .. " " .. unit)
  local unit_list = loaded_unit_events[unit]
  local inRaid = IsInRaid()
  if unit_list then
    local event_list = unit_list[event]
    if event_list then
      for id, triggers in pairs(event_list) do
        Private.StartProfileAura(id);
        Private.ActivateAuraEnvironment(id);
        local updateTriggerState = false;
        for triggernum, data in pairs(triggers) do
          if inRaid and Private.multiUnitUnits.party[unit]
          and events[id][triggernum].ignorePartyUnitsInRaid
          and events[id][triggernum].ignorePartyUnitsInRaid[event]
          then
            -- If the unit is a group unit, we don't want to run the trigger for every party member
          else
            local delay = GenericTrigger.GetDelay(data)
            if delay == 0 then
              local allStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum);
              if (RunTriggerFunc(allStates, data, id, triggernum, event, unit, ...)) then
                updateTriggerState = true;
              end
            else
              Private.RunTriggerFuncWithDelay(delay, id, triggernum, data, event, unit, ...)
            end
          end
        end
        if (updateTriggerState) then
          Private.UpdatedTriggerState(id);
        end
        Private.StopProfileAura(id);
        Private.ActivateAuraEnvironment(nil);
      end
    end
  end
  Private.StopProfileSystem("generictrigger " .. event .. " " .. unit)
end

function WeakAuras.ScanUnitEvents(event, unit, ...)
  scannerFrame:Queue(Private.ScanUnitEvents, event, unit, ...)
end

local function checkOnUpdateThrottle(data)
  if data.onUpdateThrottle then
    local now = GetTime()
    if not data.lastOnUpdate or (now - data.lastOnUpdate) >= data.onUpdateThrottle then
      data.lastOnUpdate = now
      return true
    end
    return false
  end
  return true
end

---@private
---@param event_list table<string>
---@param event string
---@param arg1? any
---@param arg2? any
---@param ... any
function Private.ScanEventsInternal(event_list, event, arg1, arg2, ... )
  for id, triggers in pairs(event_list) do
    Private.StartProfileAura(id);
    Private.ActivateAuraEnvironment(id);
    local updateTriggerState = false;
    for triggernum, data in pairs(triggers) do
      if event == "FRAME_UPDATE" then
        if checkOnUpdateThrottle(data) then
          local allStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum);
          if (RunTriggerFunc(allStates, data, id, triggernum, event, arg1, arg2, ...)) then
            updateTriggerState = true
          end
        end
      else
        local delay = GenericTrigger.GetDelay(data)
        if delay == 0 then
          local allStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum);
          if (RunTriggerFunc(allStates, data, id, triggernum, event, arg1, arg2, ...)) then
            updateTriggerState = true
          end
        else
          Private.RunTriggerFuncWithDelay(delay, id, triggernum, data, event, arg1, arg2, ...)
        end
      end
    end
    if (updateTriggerState) then
      Private.UpdatedTriggerState(id);
    end
    Private.StopProfileAura(id);
    Private.ActivateAuraEnvironment(nil);
  end
end

function WeakAuras.ScanEventsInternal(event_list, event, arg1, arg2, ... )
  scannerFrame:Queue(Private.ScanEventsInternal, event_list, event, arg1, arg2, ...)
end

do
  local function RunTriggerFuncForDelay(id, triggernum, data, event, ...)
    Private.StartProfileAura(id)
    Private.ActivateAuraEnvironment(id)
    local allStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum)
    if (RunTriggerFunc(allStates, data, id, triggernum, event, ...)) then
      Private.UpdatedTriggerState(id)
    end
    Private.StopProfileAura(id)
    Private.ActivateAuraEnvironment(nil)
    -- clear expired timers
    for i, t in ipairs_reverse(delayTimerEvents[id][triggernum]) do
      if t.ends <= GetTime() then
        table.remove(delayTimerEvents[id][triggernum], i)
      end
    end
  end

  ---@type fun(delay, id, triggernum, data, event, ...)
  function Private.RunTriggerFuncWithDelay(delay, id, triggernum, data, event, ...)
    delayTimerEvents[id] = delayTimerEvents[id] or {}
    delayTimerEvents[id][triggernum] = delayTimerEvents[id][triggernum] or {}
    local timerId = timer:ScheduleTimer(RunTriggerFuncForDelay, delay, id, triggernum, data, event, ...)
    tinsert(delayTimerEvents[id][triggernum], timerId)
  end
end

---@type fun(id)
function Private.CancelDelayedTrigger(id)
  if delayTimerEvents[id] then
    for triggernum, timers in pairs(delayTimerEvents[id]) do
      for _, timerId in ipairs(timers) do
        timer:CancelTimer(timerId)
      end
    end
    delayTimerEvents[id] = nil
  end
end

---@type fun()
function Private.CancelAllDelayedTriggers()
  for id in pairs(delayTimerEvents) do
    Private.CancelDelayedTrigger(id)
  end
end

---@type fun(id, watchedTriggernums)
function Private.ScanEventsWatchedTrigger(id, watchedTriggernums)
  if #watchedTriggernums == 0 then return end
  Private.StartProfileAura(id);
  Private.ActivateAuraEnvironment(id);
  local updateTriggerState = false

  for _, watchedTrigger in ipairs(watchedTriggernums) do
    if watched_trigger_events[id] and watched_trigger_events[id][watchedTrigger] then
      local updatedTriggerStates = WeakAuras.GetTriggerStateForTrigger(id, watchedTrigger)
      for observerTrigger in pairs(watched_trigger_events[id][watchedTrigger]) do
        local data = events and events[id] and events[id][observerTrigger]
        local allstates = WeakAuras.GetTriggerStateForTrigger(id, observerTrigger)
        if data and allstates and updatedTriggerStates then
          if RunTriggerFunc(allstates, data, id, observerTrigger, "TRIGGER", watchedTrigger, updatedTriggerStates) then
            updateTriggerState = true
          end
        end
      end
    end
  end
  if (updateTriggerState) then
    Private.UpdatedTriggerState(id)
  end
  Private.StopProfileAura(id)
  Private.ActivateAuraEnvironment(nil)
end

---@type fun(data: auraData, triggernum: number) : "timed"|boolean, boolean?
local function ProgressType(data, triggernum)
  local trigger = data.triggers[triggernum].trigger

  local prototype = GenericTrigger.GetPrototype(trigger)
  if prototype then
    if prototype.progressType then
      local progressType = prototype.progressType
      if type(progressType) == "function" then
        progressType = progressType(trigger)
      end
      return progressType, prototype.useModRate
    elseif prototype.timedrequired then
      return "timed"
    end
  elseif (trigger.type == "custom") then
    if trigger.custom_type == "event" and trigger.custom_hide == "timed" and trigger.duration then
      return "timed";
    elseif (trigger.customDuration and trigger.customDuration ~= "") then
      return "timed";
    elseif (trigger.custom_type == "stateupdate") then
      return false
    end
  end
  return false
end

---@type fun(data: auraData, triggernum: integer, state: state, eventData: table)
local function AddFakeInformation(data, triggernum, state, eventData)
  state.autoHide = false
  if ProgressType(data, triggernum) == "timed" and state.expirationTime == nil then
    state.progressType = "timed"
  end
  if state.progressType == "timed" then
    local expirationTime = state.expirationTime
    if expirationTime and type(expirationTime) == "number" and expirationTime ~= math.huge and expirationTime > GetTime() then
      return
    end
    state.progressType = "timed"
    state.expirationTime = GetTime() + 7
    state.duration = 7
  end
  if eventData.prototype and eventData.prototype.GetNameAndIcon then
    local name, icon = eventData.prototype.GetNameAndIcon(eventData.trigger)
    if state.name == nil then
      state.name = name
    end
    if state.icon == nil then
      state.icon = icon
    end
  end
end

---@type fun(id: auraId, triggernum: integer)
function GenericTrigger.CreateFakeStates(id, triggernum)
  local data = WeakAuras.GetData(id)
  local eventData = events[id][triggernum]

  Private.ActivateAuraEnvironment(id);
  local allStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum);

  local arg1
  if eventData.statesParameter == "unit" then
    local unit = eventData.trigger.unit
    if Private.multiUnitUnits[unit] then
      arg1 = next(Private.multiUnitUnits[unit])
    else
      arg1 = unit
    end
  end

  RunTriggerFunc(allStates, eventData, id, triggernum, "OPTIONS", arg1)

  local shown = 0
  for id, state in pairs(allStates) do
    if state.show then
      shown = shown + 1
    end

    AddFakeInformation(data, triggernum, state, eventData)
  end

  if shown == 0 then
    local state = {}
    GenericTrigger.CreateFallbackState(data, triggernum, state)
    allStates[""] = state

    AddFakeInformation(data, triggernum, state, eventData)
  end

  Private.ActivateAuraEnvironment(nil);
end

function GenericTrigger.ScanWithFakeEvent(id, fake)
  local updateTriggerState = false;
  Private.ActivateAuraEnvironment(id);
  for triggernum, event in pairs(events[id] or {}) do
    local allStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum);
    if (event.force_events) then
      if (type(event.force_events) == "string") then
        updateTriggerState = RunTriggerFunc(allStates, events[id][triggernum], id, triggernum, event.force_events) or updateTriggerState;
      elseif (type(event.force_events) == "table") then
        for index, event_args in pairs(event.force_events) do
          updateTriggerState = RunTriggerFunc(allStates, events[id][triggernum], id, triggernum, unpack(event_args)) or updateTriggerState;
        end
      elseif (type(event.force_events) == "boolean" and event.force_events) then
        for i, eventName in pairs(event.events) do
          updateTriggerState = RunTriggerFunc(allStates, events[id][triggernum], id, triggernum, eventName) or updateTriggerState;
        end
        for unit, unitData in pairs(event.unit_events) do
          for _, event in ipairs(unitData) do
            updateTriggerState = RunTriggerFunc(allStates, events[id][triggernum], id, triggernum, event, unit) or updateTriggerState
          end
        end
      end
    end
  end

  if (updateTriggerState) then
    Private.UpdatedTriggerState(id);
  end
  Private.ActivateAuraEnvironment(nil);
end

function HandleEvent(frame, event, arg1, arg2, ...)
  Private.StartProfileSystem("generictrigger " .. event);
  if event == "NAME_PLATE_UNIT_ADDED" then
    nameplateExists[arg1] = true
  elseif event == "NAME_PLATE_UNIT_REMOVED" then
    nameplateExists[arg1] = false
  end

  if not(WeakAuras.IsPaused()) then
    if(event == "COMBAT_LOG_EVENT_UNFILTERED") then
      Private.ScanEvents(event);
    else
      Private.ScanEvents(event, arg1, arg2, ...);
    end
  end
  if (event == "PLAYER_ENTERING_WORLD") then
    timer:ScheduleTimer(function()
      HandleEvent(frame, "WA_DELAYED_PLAYER_ENTERING_WORLD", arg1, arg2)
      Private.ScanForLoads(nil, "WA_DELAYED_PLAYER_ENTERING_WORLD")
      Private.StartProfileSystem("generictrigger WA_DELAYED_PLAYER_ENTERING_WORLD");
      Private.CheckCooldownReady();
      Private.StopProfileSystem("generictrigger WA_DELAYED_PLAYER_ENTERING_WORLD");
      Private.PreShowModels()
      if WeakAuras.IsRetail() then
        Private.CheckTalentsForLoad("WA_DELAYED_PLAYER_ENTERING_WORLD")
      end
    end,
    0.8);  -- Data not available

    timer:ScheduleTimer(function()
      Private.PreShowModels()
    end,
    4);  -- Data not available
  end
  Private.StopProfileSystem("generictrigger " .. event);
end

-- WORKAROUND https://github.com/Stanzilla/WoWUIBugs/issues/708
-- The game fires events for areanaX when it actually should be sending for boss(X+5)
local brokenUnitMap = {
  arena1 = "boss6",
  arena2 = "boss7",
  arena3 = "boss8",
  arena4 = "boss9",
  arena5 = "boss10"
}

function HandleUnitEvent(frame, event, unit, ...)
  Private.StartProfileSystem("generictrigger " .. event .. " " .. unit);
  if not(WeakAuras.IsPaused()) then
    if UnitIsUnit(unit, frame.unit)
       or (brokenUnitMap[unit] == frame.unit and not UnitExists(unit))
    then
      Private.ScanUnitEvents(event, frame.unit, ...);
    end
  end
  Private.StopProfileSystem("generictrigger " .. event .. " " .. unit);
end

function GenericTrigger.UnloadAll()
  wipe(loaded_auras);
  wipe(loaded_events);
  wipe(loaded_unit_events);
  Private.CancelAllDelayedTriggers();
  Private.UnregisterAllEveryFrameUpdate();
end

function GenericTrigger.UnloadDisplays(toUnload)
  for id in pairs(toUnload) do
    loaded_auras[id] = nil
    for eventname, events in pairs(loaded_events) do
      if(eventname == "COMBAT_LOG_EVENT_UNFILTERED") then
        for subeventname, subevents in pairs(events) do
          subevents[id] = nil;
        end
      else
        events[id] = nil;
      end
    end
    for unit, events in pairs(loaded_unit_events) do
      for eventname, auras in pairs(events) do
        auras[id] = nil;
      end
    end

    Private.CancelDelayedTrigger(id);
    Private.UnregisterEveryFrameUpdate(id);
  end
end

local genericTriggerRegisteredEvents = {};
local genericTriggerRegisteredUnitEvents = {};

---@class WeakAurasGenericTriggerFrame: FrameScriptObject
local frame = CreateFrame("Frame");
frame.unitFrames = {};
Private.frames["WeakAuras Generic Trigger Frame"] = frame;
frame:RegisterEvent("PLAYER_ENTERING_WORLD");
frame:RegisterEvent("NAME_PLATE_UNIT_ADDED")
frame:RegisterEvent("NAME_PLATE_UNIT_REMOVED")
genericTriggerRegisteredEvents["PLAYER_ENTERING_WORLD"] = true;
genericTriggerRegisteredEvents["NAME_PLATE_UNIT_ADDED"] = true;
genericTriggerRegisteredEvents["NAME_PLATE_UNIT_REMOVED"] = true;
frame:SetScript("OnEvent", HandleEvent);

function GenericTrigger.Delete(id)
  events[id] = nil
  watched_trigger_events[id] = nil
end

function GenericTrigger.Rename(oldid, newid)
  events[newid] = events[oldid];
  events[oldid] = nil;

  for eventname, events in pairs(loaded_events) do
    if(eventname == "COMBAT_LOG_EVENT_UNFILTERED") then
      for subeventname, subevents in pairs(events) do
        subevents[oldid] = subevents[newid];
        subevents[oldid] = nil;
      end
    else
      events[newid] = events[oldid];
      events[oldid] = nil;
    end
  end

  for unit, events in pairs(loaded_unit_events) do
    for eventname, auras in pairs(events) do
      auras[newid] = auras[oldid]
      auras[oldid] = nil
    end
  end

  watched_trigger_events[newid] = watched_trigger_events[oldid]
  watched_trigger_events[oldid] = nil

  Private.EveryFrameUpdateRename(oldid, newid)
end

local function MultiUnitLoop(Func, unit, includePets, ...)
  unit = string.lower(unit)
  if unit == "boss" then
    for i = 1, 10 do
      Func(unit..i, ...)
    end
  elseif unit == "arena" then
    for i = 1, 5 do
      Func(unit..i, ...)
    end
  elseif unit == "nameplate" then
    for i = 1, 40 do
      Func(unit..i, ...)
    end
  elseif unit == "group" then
    if includePets ~= "PetsOnly" then
      Func("player", ...)
    end
    if includePets ~= nil then
      Func("pet", ...)
    end
    for i = 1, 4 do
      if includePets ~= "PetsOnly" then
        Func("party"..i, ...)
      end
      if includePets ~= nil then
        Func("partypet"..i, ...)
      end
    end
    for i = 1, 40 do
      if includePets ~= "PetsOnly" then
        Func("raid"..i, ...)
      end
      if includePets ~= nil then
        Func("raidpet"..i, ...)
      end
    end
  elseif unit == "party" then
    if includePets ~= "PetsOnly" then
      Func("player", ...)
    end
    if includePets ~= nil then
      Func("pet", ...)
    end
    for i = 1, 4 do
      if includePets ~= "PetsOnly" then
        Func("party"..i, ...)
      end
      if includePets ~= nil then
        Func("partypet"..i, ...)
      end
    end
  elseif unit == "raid" then
    for i = 1, 40 do
      if includePets ~= "PetsOnly" then
        Func("raid"..i, ...)
      end
      if includePets ~= nil then
        Func("raidpet"..i, ...)
      end
    end
  else
    Func(unit, ...)
  end
end

function LoadEvent(id, triggernum, data)
  if data.events then
    for index, event in pairs(data.events) do
      loaded_events[event] = loaded_events[event] or {};
      if(event == "COMBAT_LOG_EVENT_UNFILTERED" and data.subevents) then
        for i, subevent in pairs(data.subevents) do
          loaded_events[event][subevent] = loaded_events[event][subevent] or {};
          loaded_events[event][subevent][id] = loaded_events[event][subevent][id] or {}
          loaded_events[event][subevent][id][triggernum] = data;
        end
      else
        loaded_events[event][id] = loaded_events[event][id] or {};
        loaded_events[event][id][triggernum] = data;
      end
    end
  end
  if (data.internal_events) then
    for index, event in pairs(data.internal_events) do
      loaded_events[event] = loaded_events[event] or {};
      loaded_events[event][id] = loaded_events[event][id] or {};
      loaded_events[event][id][triggernum] = data;
    end
  end
  -- this special internal_events function is run when aura load instead of when it is added
  if data.loadInternalEventFunc then
    local internal_events = data.loadInternalEventFunc(data.trigger)
    for index, event in pairs(internal_events) do
      loaded_events[event] = loaded_events[event] or {};
      loaded_events[event][id] = loaded_events[event][id] or {};
      loaded_events[event][id][triggernum] = data;
    end
  end
  if data.unit_events then
    local includePets = data.includePets
    for unit, events in pairs(data.unit_events) do
      unit = string.lower(unit)
      for index, event in pairs(events) do
        MultiUnitLoop(
          function(u)
            loaded_unit_events[u] = loaded_unit_events[u] or {};
            loaded_unit_events[u][event] = loaded_unit_events[u][event] or {};
            loaded_unit_events[u][event][id] = loaded_unit_events[u][event][id] or {}
            loaded_unit_events[u][event][id][triggernum] = data;
          end, unit, includePets
        )
      end
    end
  end

  if (data.loadFunc) then
    data.loadFunc(data.trigger);
  end
end

local function trueFunction()
  return true;
end

local eventsToRegister = {};
local unitEventsToRegister = {};
function GenericTrigger.LoadDisplays(toLoad, loadEvent, ...)
  for id in pairs(toLoad) do
    local register_for_frame_updates = false;
    if(events[id]) then
      loaded_auras[id] = true;
      for triggernum, data in pairs(events[id]) do
        if data.events then
          for index, event in pairs(data.events) do
            if (event == "FRAME_UPDATE") then
              register_for_frame_updates = true;
            elseif not genericTriggerRegisteredEvents[event] then
              eventsToRegister[event] = true;
            end
          end
        end
        if data.unit_events then
          local includePets = data.includePets
          for unit, events in pairs(data.unit_events) do
            for index, event in pairs(events) do
              MultiUnitLoop(
                function (u)
                  if not (genericTriggerRegisteredUnitEvents[u] and genericTriggerRegisteredUnitEvents[u][event]) then
                    unitEventsToRegister[u] = unitEventsToRegister[u] or {}
                    unitEventsToRegister[u][event] = true
                  end
                end, unit, includePets
              )
            end
          end
        end

        if data.counter then
          data.counter:Reset()
        end

        LoadEvent(id, triggernum, data);
      end
    end

    if(register_for_frame_updates) then
      Private.RegisterEveryFrameUpdate(id);
    else
      Private.UnregisterEveryFrameUpdate(id);
    end
  end

  for event in pairs(eventsToRegister) do
    xpcall(frame.RegisterEvent, trueFunction, frame, event)
    genericTriggerRegisteredEvents[event] = true;
  end

  for unit, events in pairs(unitEventsToRegister) do
    for event in pairs(events) do
      if not frame.unitFrames[unit] then
        frame.unitFrames[unit] = CreateFrame("Frame")
        frame.unitFrames[unit].unit = unit
        frame.unitFrames[unit]:SetScript("OnEvent", HandleUnitEvent);
      end
      xpcall(frame.unitFrames[unit].RegisterUnitEvent, trueFunction, frame.unitFrames[unit], event, unit)
      genericTriggerRegisteredUnitEvents[unit] = genericTriggerRegisteredUnitEvents[unit] or {};
      genericTriggerRegisteredUnitEvents[unit][event] = true;
    end
  end

  for id in pairs(toLoad) do
    GenericTrigger.ScanWithFakeEvent(id);
  end

  -- Replay events that lead to loading, if we weren't already registered for them
  if (eventsToRegister[loadEvent]) then
    Private.ScanEvents(loadEvent, ...);
  end
  local loadUnit = ...
  if loadUnit and unitEventsToRegister[loadUnit] and unitEventsToRegister[loadUnit][loadEvent] then
    Private.ScanUnitEvents(loadEvent, ...);
  end

  wipe(eventsToRegister);
  wipe(unitEventsToRegister);
end

function GenericTrigger.FinishLoadUnload()
end

do
  local function ParseCron(pattern)
    local tests = {}
    for test in pattern:gmatch("[^ ,]+") do
      local startString, endString, intervalString = test:match("(%d*)-?(%d*)/?(%d*)")
      local intervalNumber = tonumber(intervalString)
      local startNumber = startString == "" and 0 or tonumber(startString) or 0
      local endNumber = tonumber(endString)
      if not endNumber then
        endNumber = intervalNumber and math.huge or startNumber
      end
      intervalNumber = intervalNumber or 1

      tinsert(tests, {
        startNumber = startNumber,
        endNumber = endNumber,
        intervalNumber = intervalNumber,
        Match = function(self, count)
          return (count >= self.startNumber and count <= self.endNumber and (count - self.startNumber) % self.intervalNumber == 0)
        end
      })
    end
    return tests
  end

  function Private.ExecEnv.CreateTriggerCounter(pattern)
    local counter = {
      count = 0,
      tests = {

      },
      fastMatches = {
      },
      Reset = function(self)
        self.count = 0
      end,
      GetNext = function(self)
        self.count = self.count + 1
        return self.count
      end,
      SetCount = function(self, count)
        self.count = count
      end,
    }
    if pattern then
      counter.tests = ParseCron(pattern)
      counter.RunTests = function(self, count)
        for _, test in ipairs(self.tests) do
          if test:Match(count) then
            return true
          end
        end
        return false
      end

      for i = 0, 20 do
        counter.fastMatches[i] = counter.RunTests(counter, i)
      end

      counter.Match = function(self)
        if self.count <= 20 then
          return counter.fastMatches[self.count]
        end
        return self:RunTests(self.count)
      end

    else
      counter.Match = function(self)
        return true
      end
    end

    return counter
  end
end

--- Adds a display, creating all internal data structures for all triggers.
---@param data auraData
---@param region table
function GenericTrigger.Add(data, region)
  local id = data.id;
  events[id] = nil;
  watched_trigger_events[id] = nil

  local warnAboutCLEUEvents = false

  for triggernum, triggerData in ipairs(data.triggers) do
    local trigger, untrigger = triggerData.trigger, triggerData.untrigger
    local triggerType;
    if(trigger and type(trigger) == "table") then
      triggerType = trigger.type;
      if(Private.category_event_prototype[triggerType] or triggerType == "custom") then
        local triggerFuncStr, triggerFunc, untriggerFunc, statesParameter;
        local trigger_events = {};
        local internal_events = {};
        local trigger_unit_events = {};
        local includePets
        local trigger_subevents = {};
        local ignorePartyUnitsInRaid
        ---@type boolean|string|table
        local force_events = false;
        local durationFunc, overlayFuncs, nameFunc, iconFunc, textureFunc, stacksFunc, loadFunc, loadInternalEventFunc;
        local tsuConditionVariables;
        local prototype = nil
        local automaticAutoHide
        local duration
        local counter
        if(Private.category_event_prototype[triggerType]) then
          if not(trigger.event) then
            error("Improper arguments to WeakAuras.Add - trigger type is \"event\" but event is not defined");
          elseif not(event_prototypes[trigger.event]) then
            if(event_prototypes["Health"]) then
              trigger.event = "Health";
            else
              error("Improper arguments to WeakAuras.Add - no event prototype can be found for event type \""..trigger.event.."\" and default prototype reset failed.");
            end
          else
            if (trigger.event == "Combat Log") then
              if (not trigger.subeventPrefix) then
                trigger.subeventPrefix = ""
              end
              if (not trigger.subeventSuffix) then
                trigger.subeventSuffix = "";
              end
              if not(Private.subevent_actual_prefix_types[trigger.subeventPrefix]) then
                trigger.subeventSuffix = "";
              end
            end

            prototype = event_prototypes[trigger.event]
            triggerFuncStr = ConstructFunction(prototype, trigger);

            statesParameter = prototype.statesParameter;
            triggerFunc = Private.LoadFunction(triggerFuncStr, id);

            durationFunc = prototype.durationFunc;
            nameFunc = prototype.nameFunc;
            iconFunc = prototype.iconFunc;
            textureFunc = prototype.textureFunc;
            stacksFunc = prototype.stacksFunc;
            loadFunc = prototype.loadFunc;
            loadInternalEventFunc = prototype.loadInternalEventFunc;

            if (prototype.overlayFuncs) then
              overlayFuncs = {};
              local dest = 1;
              for i, v in ipairs(prototype.overlayFuncs) do
                local enable = true
                if type(v.enable) == "function" then
                  enable = v.enable(trigger)
                elseif type(v.enable) == "boolean" then
                  enable = v.enable
                end
                if enable then
                  overlayFuncs[dest] = v.func;
                  dest = dest + 1;
                end
              end
            end

            if (prototype.automaticrequired) then
              untriggerFunc = trueFunction
            elseif prototype.timedrequired then
              automaticAutoHide = true
              duration = tonumber(trigger.duration or "1")
            else
              WeakAuras.prettyPrint("Invalid Prototype found: " .. prototype.name)
            end

            if prototype.countEvents then
              if trigger.use_count and type(trigger.count) == "string" and trigger.count ~= "" then
                counter = Private.ExecEnv.CreateTriggerCounter(trigger.count)
              else
                counter = Private.ExecEnv.CreateTriggerCounter()
              end
            end

            if(prototype) then
              local trigger_all_events = prototype.events;
              internal_events = prototype.internal_events;
              force_events = prototype.force_events;
              if prototype.subevents then
                trigger_subevents = prototype.subevents
                if trigger_subevents and type(trigger_subevents) == "function" then
                  trigger_subevents = trigger_subevents(trigger, untrigger)
                end
              end

              if trigger.event == "Combat Log" and trigger.subeventPrefix and trigger.subeventSuffix then
                tinsert(trigger_subevents, trigger.subeventPrefix .. trigger.subeventSuffix)
              end

              if (type(trigger_all_events) == "function") then
                trigger_all_events = trigger_all_events(trigger, untrigger);
              end
              trigger_events = trigger_all_events.events
              trigger_unit_events = trigger_all_events.unit_events
              if (type(internal_events) == "function") then
                internal_events = internal_events(trigger, untrigger);
              end
              if (type(force_events) == "function") then
                force_events = force_events(trigger, untrigger)
              end

              if prototype.includePets then
                includePets = trigger.use_includePets == true and trigger.includePets or nil
              end
            end
          end
        else -- CUSTOM
          triggerFunc = WeakAuras.LoadFunction("return "..(trigger.custom or ""), data.id);
          if (trigger.custom_type == "stateupdate") then
            tsuConditionVariables = WeakAuras.LoadFunction("return function() return \n" .. (trigger.customVariables or "") .. "\n end", data.id);
            if not tsuConditionVariables then
              tsuConditionVariables = function() end
            end
          end

          if(trigger.custom_type == "status" or trigger.custom_type == "event" and trigger.custom_hide == "custom") then
            untriggerFunc = WeakAuras.LoadFunction("return "..(untrigger.custom or ""), data.id);
            if (not untriggerFunc) then
              untriggerFunc = trueFunction;
            end
          end

          if(trigger.custom_type ~= "stateupdate" and trigger.customDuration and trigger.customDuration ~= "") then
            durationFunc = WeakAuras.LoadFunction("return "..trigger.customDuration, data.id);
          end
          if(trigger.custom_type ~= "stateupdate") then
            overlayFuncs = {};
            for i = 1, 7 do
              local property = "customOverlay" .. i;
              if (trigger[property] and trigger[property] ~= "") then
                overlayFuncs[i] = WeakAuras.LoadFunction("return ".. trigger[property], data.id);
              end
            end
          end
          if(trigger.custom_type ~= "stateupdate" and trigger.customName and trigger.customName ~= "") then
            nameFunc = WeakAuras.LoadFunction("return "..trigger.customName, data.id);
          end
          if(trigger.custom_type ~= "stateupdate" and trigger.customIcon and trigger.customIcon ~= "") then
            iconFunc = WeakAuras.LoadFunction("return "..trigger.customIcon, data.id);
          end
          if(trigger.custom_type ~= "stateupdate" and trigger.customTexture and trigger.customTexture ~= "") then
            textureFunc = WeakAuras.LoadFunction("return "..trigger.customTexture, data.id);
          end
          if(trigger.custom_type ~= "stateupdate" and trigger.customStacks and trigger.customStacks ~= "") then
            stacksFunc = WeakAuras.LoadFunction("return "..trigger.customStacks, data.id);
          end

          if((trigger.custom_type == "status" or trigger.custom_type == "stateupdate") and trigger.check == "update") then
            trigger_events = {"FRAME_UPDATE"};
          else
            local rawEvents = WeakAuras.split(trigger.events);
            for index, event in pairs(rawEvents) do
              -- custom events in the form of event:unit1:unit2:unitX are registered with RegisterUnitEvent
              local trueEvent
              local hasParam = false
              local isCLEU = false
              local isTrigger = false
              local isUnitEvent = false
              if event == "CLEU" or event == "COMBAT_LOG_EVENT_UNFILTERED" then
                warnAboutCLEUEvents = true
              end
              for i in event:gmatch("[^:]+") do
                if not trueEvent then
                  trueEvent = string.upper(i)
                  isCLEU = trueEvent == "CLEU" or trueEvent == "COMBAT_LOG_EVENT_UNFILTERED"
                  isTrigger = trueEvent == "TRIGGER"
                elseif isCLEU then
                  local subevent = string.upper(i)
                  if Private.IsCLEUSubevent(subevent) then
                    tinsert(trigger_subevents, subevent)
                    hasParam = true
                  end
                elseif Private.InternalEventByIDList[trueEvent] then
                  tinsert(trigger_events, trueEvent..":"..i)
                elseif trueEvent:match("^UNIT_") or Private.UnitEventList[trueEvent] then
                  isUnitEvent = true

                  if string.lower(strsub(i, #i - 3)) == "pets" then
                    i = strsub(i, 1, #i-4)
                    includePets = "PlayersAndPets"
                  elseif string.lower(strsub(i, #i - 7)) == "petsonly" then
                    includePets = "PetsOnly"
                    i = strsub(i, 1, #i - 8)
                  elseif string.lower(i, #i - 5) == "group" then
                    ignorePartyUnitsInRaid = ignorePartyUnitsInRaid or {}
                    ignorePartyUnitsInRaid[trueEvent] = true
                  end

                  trigger_unit_events[i] = trigger_unit_events[i] or {}
                  tinsert(trigger_unit_events[i], trueEvent)
                elseif isTrigger then
                  local requestedTriggernum = tonumber(i)
                  if requestedTriggernum then
                    if watched_trigger_events[id] and watched_trigger_events[id][triggernum] and watched_trigger_events[id][triggernum][requestedTriggernum] then
                      -- if the request is reciprocal (2 custom triggers request each other which would cause a stack overflow) then prevent the reciprocal one being added.
                    elseif requestedTriggernum and requestedTriggernum ~= triggernum then
                      watched_trigger_events[id] = watched_trigger_events[id] or {}
                      watched_trigger_events[id][requestedTriggernum] = watched_trigger_events[id][requestedTriggernum] or {}
                      watched_trigger_events[id][requestedTriggernum][triggernum] = true
                    end
                  end
                end
              end
              if isCLEU then
                if hasParam then
                  tinsert(trigger_events, "COMBAT_LOG_EVENT_UNFILTERED")
                  -- We don't register CLEU events without parameters anymore
                end
              elseif isUnitEvent then
                -- not added to trigger_events
              elseif isTrigger then
                -- not added to trigger_events
              else
                tinsert(trigger_events, event)
              end
            end
          end
          if trigger.custom_type == "status" or trigger.custom_type == "stateupdate" then
            force_events = data.information.forceEvents or "STATUS"
          end
          if (trigger.custom_type == "stateupdate") then
            statesParameter = "full";
          end

          if(trigger.custom_type == "event" and trigger.custom_hide == "timed") then
            automaticAutoHide = true;
            if (not trigger.dynamicDuration) then
              duration = tonumber(trigger.duration);
            end
          end
        end

        events[id] = events[id] or {};
        events[id][triggernum] = {
          trigger = trigger,
          triggerFunc = triggerFunc,
          untriggerFunc = untriggerFunc,
          statesParameter = statesParameter,
          event = trigger.event,
          events = trigger_events,
          onUpdateThrottle = trigger.onUpdateThrottle,
          ignorePartyUnitsInRaid = ignorePartyUnitsInRaid,
          internal_events = internal_events,
          loadInternalEventFunc = loadInternalEventFunc,
          force_events = force_events,
          unit_events = trigger_unit_events,
          includePets = includePets,
          inverse = trigger.use_inverse,
          subevents = trigger_subevents,
          durationFunc = durationFunc,
          overlayFuncs = overlayFuncs,
          nameFunc = nameFunc,
          iconFunc = iconFunc,
          textureFunc = textureFunc,
          stacksFunc = stacksFunc,
          loadFunc = loadFunc,
          duration = duration,
          automaticAutoHide = automaticAutoHide,
          tsuConditionVariables = tsuConditionVariables,
          prototype = prototype,
          ignoreOptionsEventErrors = data.information.ignoreOptionsEventErrors,
          counter = counter
        };
      end
    end
  end

  if warnAboutCLEUEvents then
    Private.AuraWarnings.UpdateWarning(data.uid, "spammy_event_warning", "error",
                L["|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r\nCOMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.\nFind more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"])
  else
    Private.AuraWarnings.UpdateWarning(data.uid, "spammy_event_warning")
  end
end

do
  local update_clients = {};
  local update_clients_num = 0;
  local update_frame = nil
  Private.frames["Custom Trigger Every Frame Updater"] = update_frame;
  local updating = false;

  ---@type fun(id)
  function Private.RegisterEveryFrameUpdate(id)
    if not(update_clients[id]) then
      update_clients[id] = true;
      update_clients_num = update_clients_num + 1;
    end
    if not(update_frame) then
      update_frame = CreateFrame("Frame");
    end
    if not(updating) then
      update_frame:SetScript("OnUpdate", function(self, elapsed)
        if not(WeakAuras.IsPaused()) then
          Private.ScanEvents("FRAME_UPDATE", elapsed);
        end
      end);
      updating = true;
    end
  end

  ---@type fun(oldid, newid)
  function Private.EveryFrameUpdateRename(oldid, newid)
    update_clients[newid] = update_clients[oldid];
    update_clients[oldid] = nil;
  end

  ---@type fun(id)
  function Private.UnregisterEveryFrameUpdate(id)
    if(update_clients[id]) then
      update_clients[id] = nil;
      update_clients_num = update_clients_num - 1;
    end
    if(update_clients_num == 0 and update_frame and updating) then
      update_frame:SetScript("OnUpdate", nil);
      updating = false;
    end
  end

  ---@type fun()
  function Private.UnregisterAllEveryFrameUpdate()
    if (not update_frame) then
      return;
    end
    wipe(update_clients);
    update_clients_num = 0;
    update_frame:SetScript("OnUpdate", nil);
    updating = false;
  end
end


--#############################
--# Support code for triggers #
--#############################

-- Swing timer support code
do
  local mh = GetInventorySlotInfo("MainHandSlot")
  local oh = GetInventorySlotInfo("SecondaryHandSlot")
  local ranged = WeakAuras.IsClassicEra() and GetInventorySlotInfo("RangedSlot")

  local swingTimerFrame;
  local lastSwingMain, lastSwingOff, lastSwingRange;
  local swingDurationMain, swingDurationOff, swingDurationRange, mainSwingOffset;
  local mainTimer, offTimer, rangeTimer;
  local selfGUID;
  local mainSpeed, offSpeed = UnitAttackSpeed("player")
  local casting = false
  local skipNextAttack, skipNextAttackCount
  local isAttacking

  ---@param hand string
  ---@return number duration
  ---@return number expirationTime
  ---@return string? weaponName
  ---@return number? icon
  function WeakAuras.GetSwingTimerInfo(hand)
    if(hand == "main") then
      local itemId = GetInventoryItemID("player", mh);
      local name, _, _, _, _, _, _, _, _, icon = C_Item.GetItemInfo(itemId or 0);
      if(lastSwingMain) then
        return swingDurationMain, lastSwingMain + swingDurationMain - mainSwingOffset, name, icon;
      elseif WeakAuras.IsRetail() and lastSwingRange then
        return swingDurationRange, lastSwingRange + swingDurationRange, name, icon;
      else
        return 0, math.huge, name, icon;
      end
    elseif(hand == "off") then
      local itemId = GetInventoryItemID("player", oh);
      local name, _, _, _, _, _, _, _, _, icon = C_Item.GetItemInfo(itemId or 0);
      if(lastSwingOff) then
        return swingDurationOff, lastSwingOff + swingDurationOff, name, icon;
      else
        return 0, math.huge, name, icon;
      end
    elseif(hand == "ranged") then
      local itemId = GetInventoryItemID("player", ranged);
      local name, _, _, _, _, _, _, _, _, icon = C_Item.GetItemInfo(itemId or 0);
      if (lastSwingRange) then
        return swingDurationRange, lastSwingRange + swingDurationRange, name, icon;
      else
        return 0, math.huge, name, icon;
      end
    end

    return 0, math.huge;
  end

  local function swingTriggerUpdate()
    Private.ScanEvents("SWING_TIMER_UPDATE")
  end

  local function swingEnd(hand)
    if(hand == "main") then
      lastSwingMain, swingDurationMain, mainSwingOffset = nil, nil, nil;
    elseif(hand == "off") then
      lastSwingOff, swingDurationOff = nil, nil;
    elseif(hand == "ranged") then
      lastSwingRange, swingDurationRange = nil, nil;
    end
    swingTriggerUpdate()
  end

  local function swingStart(hand)
    mainSpeed, offSpeed = UnitAttackSpeed("player")
    offSpeed = offSpeed or 0
    local currentTime = GetTime()
    if hand == "main" then
      lastSwingMain = currentTime
      swingDurationMain = mainSpeed
      mainSwingOffset = 0
      if mainTimer then
        timer:CancelTimer(mainTimer)
      end
      if mainSpeed and mainSpeed > 0 then
        mainTimer = timer:ScheduleTimerFixed(swingEnd, mainSpeed, hand)
      else
        swingEnd(hand)
      end
    elseif hand == "off" then
      lastSwingOff = currentTime
      swingDurationOff = offSpeed
      if offTimer then
        timer:CancelTimer(offTimer)
      end
      if offSpeed and offSpeed > 0 then
        offTimer = timer:ScheduleTimerFixed(swingEnd, offSpeed, hand)
      else
        swingEnd(hand)
      end
    elseif hand == "ranged" then
      local rangeSpeed = UnitRangedDamage("player")
      lastSwingRange = currentTime
      swingDurationRange = rangeSpeed
      if rangeTimer then
        timer:CancelTimer(rangeTimer)
      end
      if rangeSpeed and rangeSpeed > 0 then
        rangeTimer = timer:ScheduleTimerFixed(swingEnd, rangeSpeed, hand)
      else
        swingEnd(hand)
      end
    end
  end

  local function swingTimerCLEUCheck(ts, event, _, sourceGUID, _, _, _, destGUID, _, _, _, ...)
    Private.StartProfileSystem("generictrigger swing");
    if(sourceGUID == selfGUID) then
      if event == "SPELL_EXTRA_ATTACKS" then
        skipNextAttack = ts
        skipNextAttackCount = select(4, ...)
      elseif(event == "SWING_DAMAGE" or event == "SWING_MISSED") then
        if tonumber(skipNextAttack) and (ts - skipNextAttack) < 0.04 and tonumber(skipNextAttackCount) then
          if skipNextAttackCount > 0 then
            skipNextAttackCount = skipNextAttackCount - 1
            return
          end
        end
        local isOffHand = select(event == "SWING_DAMAGE" and 10 or 2, ...);
        if not isOffHand then
          swingStart("main")
        elseif(isOffHand) then
          swingStart("off")
        end
        swingTriggerUpdate()
      end
    elseif (destGUID == selfGUID and (... == "PARRY" or select(4, ...) == "PARRY")) then
      if (lastSwingMain) then
        local timeLeft = lastSwingMain + swingDurationMain - GetTime() - (mainSwingOffset or 0);
        if (timeLeft > 0.2 * swingDurationMain) then
          local offset = 0.4 * swingDurationMain
          if (timeLeft - offset < 0.2 * swingDurationMain) then
            offset = timeLeft - 0.2 * swingDurationMain
          end
          timer:CancelTimer(mainTimer);
          mainTimer = timer:ScheduleTimerFixed(swingEnd, timeLeft - offset, "main");
          mainSwingOffset = (mainSwingOffset or 0) + offset
          swingTriggerUpdate()
        end
      end
    end
    Private.StopProfileSystem("generictrigger swing");
  end

  local function swingTimerCheck(event, unit, guid, spell)
    if event ~= "PLAYER_EQUIPMENT_CHANGED" and unit and unit ~= "player" then return end
    Private.StartProfileSystem("generictrigger swing");
    local now = GetTime()
    if event == "UNIT_ATTACK_SPEED" then
      local mainSpeedNew, offSpeedNew = UnitAttackSpeed("player")
      offSpeedNew = offSpeedNew or 0
      if lastSwingMain then
        if mainSpeedNew ~= mainSpeed then
          timer:CancelTimer(mainTimer)
          local multiplier = mainSpeedNew / mainSpeed
          local timeLeft = (lastSwingMain + swingDurationMain - now) * multiplier
          swingDurationMain = mainSpeedNew
          mainSwingOffset = (lastSwingMain + swingDurationMain) - (now + timeLeft)
          mainTimer = timer:ScheduleTimerFixed(swingEnd, timeLeft, "main")
        end
      end
      if lastSwingOff then
        if offSpeedNew ~= offSpeed then
          timer:CancelTimer(offTimer)
          local multiplier = offSpeedNew / mainSpeed
          local timeLeft = (lastSwingOff + swingDurationOff - now) * multiplier
          swingDurationOff = offSpeedNew
          offTimer = timer:ScheduleTimerFixed(swingEnd, timeLeft, "off")
        end
      end
      mainSpeed, offSpeed = mainSpeedNew, offSpeedNew
      swingTriggerUpdate()
    elseif casting and (event == "UNIT_SPELLCAST_INTERRUPTED" or event == "UNIT_SPELLCAST_FAILED") then
      casting = false
    elseif event == "PLAYER_EQUIPMENT_CHANGED" and isAttacking then
      swingStart("main")
      swingStart("off")
      swingStart("ranged")
      swingTriggerUpdate()
    elseif event == "UNIT_SPELLCAST_SUCCEEDED" then
      if Private.reset_swing_spells[spell] or casting then
        if casting then
          casting = false
        end
        -- check next frame
        swingTimerFrame:SetScript("OnUpdate", function(self)
          if isAttacking then
            swingStart("main")
            swingTriggerUpdate()
          end
          self:SetScript("OnUpdate", nil)
        end)
      end
      if Private.reset_ranged_swing_spells[spell] then
        if WeakAuras.IsClassicEra() then
          swingStart("ranged")
        else
          swingStart("main")
        end
        swingTriggerUpdate()
      end
    elseif event == "UNIT_SPELLCAST_START" then
      if not Private.noreset_swing_spells[spell] then
        -- pause swing timer
        casting = true
        lastSwingMain, swingDurationMain, mainSwingOffset = nil, nil, nil
        lastSwingOff, swingDurationOff = nil, nil
        swingTriggerUpdate()
      end
    elseif event == "PLAYER_ENTER_COMBAT" then
      isAttacking = true
    elseif event == "PLAYER_LEAVE_COMBAT" then
      isAttacking = nil
    end
    Private.StopProfileSystem("generictrigger swing");
  end

  ---@private
  function WeakAuras.InitSwingTimer()
    if not(swingTimerFrame) then
      swingTimerFrame = CreateFrame("Frame");
      swingTimerFrame:RegisterEvent("COMBAT_LOG_EVENT_UNFILTERED");
      swingTimerFrame:RegisterEvent("PLAYER_ENTER_COMBAT");
      swingTimerFrame:RegisterEvent("PLAYER_LEAVE_COMBAT");
      swingTimerFrame:RegisterEvent("PLAYER_EQUIPMENT_CHANGED");
      swingTimerFrame:RegisterUnitEvent("UNIT_ATTACK_SPEED", "player");
      swingTimerFrame:RegisterUnitEvent("UNIT_SPELLCAST_SUCCEEDED", "player");
      if WeakAuras.IsClassicEra() then
        swingTimerFrame:RegisterUnitEvent("UNIT_SPELLCAST_START", "player")
        swingTimerFrame:RegisterUnitEvent("UNIT_SPELLCAST_INTERRUPTED", "player")
        swingTimerFrame:RegisterUnitEvent("UNIT_SPELLCAST_FAILED", "player")
      end
      swingTimerFrame:SetScript("OnEvent",
        function(_, event, ...)
          if event == "COMBAT_LOG_EVENT_UNFILTERED" then
            swingTimerCLEUCheck(CombatLogGetCurrentEventInfo())
          else
            swingTimerCheck(event, ...)
          end
        end);
      selfGUID = UnitGUID("player");
    end
  end
end

-- CD/Rune/GCD support code
do
  local cdReadyFrame;

  local items = {};
  local itemCdDurs = {};
  local itemCdExps = {};
  local itemCdHandles = {};
  local itemCdEnabled = {};

  local itemSlots = {};
  local itemSlotsCdDurs = {};
  local itemSlotsCdExps = {};
  local itemSlotsCdHandles = {};
  local itemSlotsEnable = {};

  local runes = {};
  local runeCdDurs = {};
  local runeCdExps = {};
  local runeCdHandles = {};

  local gcdStart;
  local gcdDuration;
  local gcdSpellName;
  local gcdSpellIcon;
  local gcdEndCheck;
  local gcdModrate

  local shootStart
  local shootDuration

  local function GetRuneDuration()
    local runeDuration = -100;
    for id, _ in pairs(runes) do
      local _, duration = GetRuneCooldown(id);
      duration = duration or 0;
      runeDuration = duration > 0 and duration or runeDuration
    end
    return runeDuration
  end

  local function CheckGCD()
    local event;
    local startTime, duration, _, modRate
    if WeakAuras.IsClassicEra() then
      startTime, duration = GetSpellCooldown(29515);
      shootStart, shootDuration = GetSpellCooldown(5019)
    elseif GetSpellCooldown then
      startTime, duration, _, modRate = GetSpellCooldown(61304);
    else
      local spellCooldownInfo = C_Spell.GetSpellCooldown(61304);
      if spellCooldownInfo then
        startTime = spellCooldownInfo.startTime
        duration = spellCooldownInfo.duration
        modRate = spellCooldownInfo.modRate
      end
    end
    if(duration and duration > 0) then
      if not(gcdStart) then
        event = "GCD_START";
      elseif(gcdStart ~= startTime or gcdDuration ~= duration or gcdModrate ~= modRate) then
        event = "GCD_CHANGE";
      end
      gcdStart, gcdDuration, gcdModrate = startTime, duration, modRate
      local endCheck = startTime + duration + 0.1;
      if(gcdEndCheck ~= endCheck) then
        gcdEndCheck = endCheck;
        timer:ScheduleTimerFixed(CheckGCD, duration + 0.1);
      end
    else
      if(gcdStart) then
        event = "GCD_END"
      end
      gcdStart, gcdDuration, gcdModrate = nil, nil, nil;
      gcdSpellName, gcdSpellIcon = nil, nil;
      gcdEndCheck = 0;
    end
    if(event and not WeakAuras.IsPaused()) then
      Private.ScanEvents(event);
    end
  end

  local RecheckHandles = {
    expirationTime = {},
    handles = {},
    Recheck = function(self, id)
      self.handles[id] = nil
      self.expirationTime[id] = nil
      CheckGCD();
      Private.CheckSpellCooldown(id, GetRuneDuration())
    end,
    Schedule = function(self, expirationTime, id)
      if (not self.expirationTime[id] or expirationTime < self.expirationTime[id]) and expirationTime > 0 then
        self:Cancel(id)
        local duration = expirationTime - GetTime()
        if duration > 0 then
          self.handles[id] = timer:ScheduleTimerFixed(self.Recheck, duration, self, id)
          self.expirationTime[id] = expirationTime
        end
      end
    end,
    Cancel = function(self, id)
      if self.handles[id] then
        timer:CancelTimer(self.handles[id])
        self.handles[id] = nil
        self.expirationTime[id] = nil
      end
    end,
  }

  local function FetchSpellCooldown(self, id)
    if self.duration[id] and self.expirationTime[id] then
      return self.expirationTime[id] - self.duration[id], self.duration[id], false, self.readyTime[id], self.modRate[id] or 1.0
    elseif self.remainingTime[id] then
      return self.remainingTime[id], self.duration[id], true, self.readyTime[id], self.modRate[id] or 1.0
    end
    return 0, 0, nil, nil, 1.0
  end

  local function HandleSpell(self, id, startTime, duration, modRate, paused)
    local changed = false
    local nowReady = false
    local time = GetTime()
    if self.expirationTime[id] and self.expirationTime[id] <= time and self.expirationTime[id] ~= 0 then
      self.readyTime[id] = self.expirationTime[id]
      self.duration[id] = 0
      self.expirationTime[id] = 0
      changed = true
      nowReady = true
    end
    local endTime = startTime + duration;
    if endTime <= time then
      startTime = 0
      duration = 0
      endTime = 0
    end

    if paused then
      if self.duration[id] ~= duration then
        self.duration[id] = duration
        changed = true
      end
      if self.expirationTime[id] then
        self.expirationTime[id] = nil
        changed = true
      end

      if self.modRate[id] ~= modRate then
        self.modRate[id] = modRate
        changed = true
      end

      local remaining = startTime + duration - GetTime()
      if self.remainingTime[id] ~= remaining then
        self.remainingTime[id] = remaining
        changed = true
      end

      return changed, false
    end

    if duration > 0 then
      if (startTime == gcdStart and duration == gcdDuration)
          or (WeakAuras.IsClassicEra() and duration == shootDuration and startTime == shootStart)
      then
        -- GCD cooldown, this could mean that the spell reset!
        if self.expirationTime[id] and self.expirationTime[id] > endTime and self.expirationTime[id] ~= 0 then
          self.duration[id] = 0
          self.expirationTime[id] = 0
          if not self.readyTime[id] then
            self.readyTime[id] = time
          end
          changed = true
          nowReady = true
        end
        RecheckHandles:Schedule(endTime, id)
        return changed, nowReady
      end
    end

    if self.remainingTime[id] then
      self.remainingTime[id] = nil
      changed = true
    end

    if self.duration[id] ~= duration then
      self.duration[id] = duration
      changed = true
    end

    if self.expirationTime[id] ~= endTime then
      self.expirationTime[id] = endTime
      changed = true
      nowReady = endTime == 0
    end

    if duration == 0 then
      if not self.readyTime[id] then
        self.readyTime[id] = time
      end
    else
      self.readyTime[id] = nil
    end

    if self.modRate[id] ~= modRate then
      self.modRate[id] = modRate
      changed = true
    end

    RecheckHandles:Schedule(endTime, id)
    return changed, nowReady
  end

  ---@class SpellCDHandler
  ---@field duration table<number, number>
  ---@field expirationTime table<number, number>
  ---@field remainingTime table<number, number>
  ---@field readyTime table<number, number>
  ---@field modRate table<number, number>
  ---@field handles table<number, any>
  ---@field HandleSpell fun(self: SpellCDHandler, id: number, startTime: number?, duration: number?, modRate: number?, paused: boolean?)
  ---@field FetchSpellCooldown fun(self: SpellCDHandler, id: number): number, number, boolean, number, number
  local function CreateSpellCDHandler()
    local cd = {
      duration = {},
      expirationTime = {},
      remainingTime = {},
      readyTime = {},
      modRate = {},
      handles = {}, -- Share handles, and use lowest time to schedule
      HandleSpell = HandleSpell,
      FetchSpellCooldown = FetchSpellCooldown
    }
    return cd
  end


  --- @class PerSpellDetails
  --- @field known boolean? whether the spell is known by the player or not
  --- @field charges number? the number of charges as returned by GetSpellCharges
  --- @field chargesMax number? the number of max charges as returned by GetSpellCharges
  --- @field chargeGainTime number?
  --- @field chargeLostTime number?
  --- @field count number?
  --- @field name string
  --- @field icon number
  --- @field id number
  --- @field watched table<number, boolean>

  -- Basic details like name, icon, charges, times per effective spell id
  -- Also contains the mapping from effective spell id to watched
  --- @class SpellDetails
  --- @field private data table<number, PerSpellDetails>
  --- @field private watchedSpellIds table<number, table<boolean, table<boolean, number>>> --- Maps user spell id to effective spell id via useExact and followoverride
  --- @field private spellCds SpellCDHandler
  --- @field private spellCdsRune SpellCDHandler
  --- @field private spellCdsOnlyCooldown SpellCDHandler
  --- @field private spellCdsOnlyCooldownRune SpellCDHandler
  --- @field private spellCdsCharges SpellCDHandler
  --- @field private AddEffectiveSpellId fun(self: SpellDetails, effectiveSpellId: number, userSpellId: number)
  --- @field CheckSpellKnown fun(self: SpellDetails) Handles the SPELLS_CHANGED event (and intial setup)
  --- @field CheckSpellCooldowns fun(self: SpellDetails, runeDuration: number?)
  --- @field CheckSpellCooldown fun(self: SpellDetails, effectiveSpellId: number, runeDuration: number?)
  --- @field SendEventsForSpell fun(self: SpellDetails, effectiveSpellId: number, event: string, ...: any[])
  --- @field GetSpellCharges fun(self: SpellDetails, effectiveSpellId: number, ignoreSpellKnown: boolean): number?, number?, number?, number?, number?
  local SpellDetails = {
    -- The data per effective spellId
    data = {
    },
    -- The SpellDetails uses internally effective spell ids,
    -- But the api uses user spell ids, so we need to map in three places
    -- In the API, when SPELLS_CHANGED and when sending the events
    -- Contains the list of user spell ids we watch
    watchedSpellIds = {

    },

    -- Interprets the basic information to figure out whether an ability is on cd or not
    -- for th various different api variants we have
    -- This can probably be simplfied
    spellCds = CreateSpellCDHandler(),
    spellCdsRune = CreateSpellCDHandler(),
    spellCdsOnlyCooldown = CreateSpellCDHandler(),
    spellCdsOnlyCooldownRune = CreateSpellCDHandler(),
    spellCdsCharges = CreateSpellCDHandler(),

    -- Helper functions
    AddEffectiveSpellId = function(self, effectiveSpellId, userSpellId)
      if self.data[effectiveSpellId] then
        self.data[effectiveSpellId].watched[userSpellId] = (self.data[effectiveSpellId].watched[userSpellId] or 0) + 1
        return
      end

      local name, _, icon, _, _, _, spellId = Private.ExecEnv.GetSpellInfo(effectiveSpellId)
      self.data[effectiveSpellId] = {
        name = name,
        icon = icon,
        id = spellId,
        watched = {}
      }
      self.data[effectiveSpellId].watched[userSpellId] = 1

      local spellDetail = self.data[effectiveSpellId]
      spellDetail.known = WeakAuras.IsSpellKnownIncludingPet(effectiveSpellId)

      local charges, maxCharges, startTime, duration, unifiedCooldownBecauseRune,
            startTimeCooldown, durationCooldown, cooldownBecauseRune, startTimeCharges, durationCharges,
            spellCount, unifiedModRate, modRate, modRateCharges, paused
            = WeakAuras.GetSpellCooldownUnified(effectiveSpellId, GetRuneDuration());

      spellDetail.charges = charges
      spellDetail.chargesMax = maxCharges
      spellDetail.count = spellCount
      self.spellCds:HandleSpell(effectiveSpellId, startTime, duration, unifiedModRate, paused)
      if not unifiedCooldownBecauseRune then
        self.spellCdsRune:HandleSpell(effectiveSpellId, startTime, duration, unifiedModRate, paused)
      end
      self.spellCdsOnlyCooldown:HandleSpell(effectiveSpellId, startTimeCooldown, durationCooldown, modRate, paused)
      if not cooldownBecauseRune then
        self.spellCdsOnlyCooldownRune:HandleSpell(effectiveSpellId, startTimeCooldown, durationCooldown, modRate, paused)
      end
      self.spellCdsCharges:HandleSpell(effectiveSpellId, startTimeCharges, durationCharges, modRateCharges, paused)
    end,

    -- Actual api
    CheckSpellKnown = function(self)
      -- Check for spells whose effective spell id changed
      for userSpellId, watchedData in pairs(self.watchedSpellIds) do
        for useExact, useExactData in pairs(watchedData) do
          for followoverride, oldEffectiveSpellId in pairs(useExactData) do
            local newEffectiveSpellId = Private.ExecEnv.GetEffectiveSpellId(userSpellId, useExact, followoverride)

            if oldEffectiveSpellId ~= newEffectiveSpellId then
              -- The effective spell id has changed
              -- There are lots of cases to consider here:

              -- For the new effective spell id
              self:AddEffectiveSpellId(newEffectiveSpellId, userSpellId)

              local oldSpellDetail = self.data[oldEffectiveSpellId]
              local newSpellDetail = self.data[newEffectiveSpellId]

              -- Check whether we need to emit the SPELL_CHARGES_CHANGED or SPELL_COOLDOWN_READY events
              local chargesChanged = oldSpellDetail.charges ~= newSpellDetail.charges or oldSpellDetail.count ~= newSpellDetail.count
                or oldSpellDetail.chargesMax ~= newSpellDetail.maxCharges
              local oldCharge = oldSpellDetail.charges or oldSpellDetail.count or 0
              local newCharge = newSpellDetail.charges or newSpellDetail.count or 0
              local chargesDifference = newCharge - oldCharge

              local nowReady = not self.spellCdsOnlyCooldown.readyTime[oldEffectiveSpellId]
                               and self.spellCdsOnlyCooldown.readyTime[newEffectiveSpellId]

              -- For the old effective spell id
              -- * Remove the spell from watched
              -- * If we removed the last mapping, remove the spell details of the effective spell id
              if oldSpellDetail.watched[userSpellId] == 1 then
                oldSpellDetail.watched[userSpellId] = nil
                if next(self.data[oldEffectiveSpellId].watched) == nil then
                  self.data[oldEffectiveSpellId] = nil
                  RecheckHandles:Cancel(oldEffectiveSpellId)
                end
              else
                oldSpellDetail.watched[userSpellId] = oldSpellDetail.watched[userSpellId] - 1
              end

              -- Finally update the watchedSpellIds mapping
              self.watchedSpellIds[userSpellId][useExact][followoverride] = newEffectiveSpellId

              -- We only send events for the userSpellId, since only those get remapped
              Private.ScanEventsByID("SPELL_COOLDOWN_CHANGED", userSpellId, newEffectiveSpellId)
              if nowReady then
                Private.ScanEventsByID("SPELL_COOLDOWN_READY", userSpellId, newEffectiveSpellId)
              end
              if chargesChanged ~= 0 then
                Private.ScanEventsByID("SPELL_CHARGES_CHANGED", userSpellId, newEffectiveSpellId, chargesDifference, newCharge)
              end
            end
          end
        end
      end

      -- Check for changes in the effective spells
      local changed = {}
      for effectiveSpellId, spellDetailsData in pairs(self.data) do
        local known = WeakAuras.IsSpellKnownIncludingPet(effectiveSpellId)
        if (known ~= spellDetailsData.known) then
          spellDetailsData.known = known
          changed[effectiveSpellId] = true
        end

        local name, _, icon, _, _, _, spellId = Private.ExecEnv.GetSpellInfo(effectiveSpellId)
        if self.data[effectiveSpellId].name ~= name then
          self.data[effectiveSpellId].name = name
          changed[effectiveSpellId] = true
        end
        if self.data[effectiveSpellId].icon ~= icon then
          self.data[effectiveSpellId].icon = icon
          changed[effectiveSpellId] = true
        end
      end

      if not WeakAuras.IsPaused() then
        for id in pairs(changed) do
          self:SendEventsForSpell(id, "SPELL_COOLDOWN_CHANGED", id)
        end
      end
    end,

    CheckSpellCooldowns = function(self, runeDuration)
      for id, _ in pairs(self.data) do
        self:CheckSpellCooldown(id, runeDuration)
      end
    end,

    CheckSpellCooldown = function(self, effectiveSpellId, runeDuration)
      local charges, maxCharges, startTime, duration, unifiedCooldownBecauseRune,
        startTimeCooldown, durationCooldown, cooldownBecauseRune, startTimeCharges, durationCharges,
        spellCount, unifiedModRate, modRate, modRateCharges, paused
        = WeakAuras.GetSpellCooldownUnified(effectiveSpellId, runeDuration);

      local time = GetTime();

      local spellDetail = self.data[effectiveSpellId]

      local chargesChanged = spellDetail.charges ~= charges or spellDetail.count ~= spellCount
                            or spellDetail.chargesMax ~= maxCharges
      local chargesDifference = (charges or spellCount or 0) - (spellDetail.charges or spellDetail.count or 0)
      spellDetail.charges = charges
      spellDetail.chargesMax = maxCharges
      spellDetail.count = spellCount
      if chargesDifference ~= 0 then
        if chargesDifference > 0 then
          spellDetail.chargeGainTime = time
          spellDetail.chargeLostTime = nil
        else
          spellDetail.chargeGainTime = nil
          spellDetail.chargeLostTime = time
        end
      end

      local changed = false
      changed = self.spellCds:HandleSpell(effectiveSpellId, startTime, duration, unifiedModRate, paused) or changed
      if not unifiedCooldownBecauseRune then
        changed = self.spellCdsRune:HandleSpell(effectiveSpellId, startTime, duration, unifiedModRate, paused) or changed
      end
      local cdChanged, nowReady = self.spellCdsOnlyCooldown:HandleSpell(effectiveSpellId, startTimeCooldown, durationCooldown, modRate, paused)
      changed = cdChanged or changed
      if not cooldownBecauseRune then
        changed = self.spellCdsOnlyCooldownRune:HandleSpell(effectiveSpellId, startTimeCooldown, durationCooldown, modRate, paused) or changed
      end
      local chargeChanged = self.spellCdsCharges:HandleSpell(effectiveSpellId, startTimeCharges, durationCharges, modRateCharges)
      changed = chargeChanged or changed

      if not WeakAuras.IsPaused() then
        if nowReady then
          self:SendEventsForSpell(effectiveSpellId, "SPELL_COOLDOWN_READY", effectiveSpellId)
        end

        if changed or chargesChanged then
          self:SendEventsForSpell(effectiveSpellId, "SPELL_COOLDOWN_CHANGED", effectiveSpellId)
        end

        if (chargesDifference ~= 0 ) then
          self:SendEventsForSpell(effectiveSpellId, "SPELL_CHARGES_CHANGED", effectiveSpellId, chargesDifference, charges or spellCount or 0)
        end
      end
    end,

    WatchSpellCooldown = function(self, userSpellId, ignoreRunes, useExact, followoverride)
      if not(cdReadyFrame) then
        Private.InitCooldownReady();
      end

      if not userSpellId or userSpellId == 0 then
        return
      end

      useExact = useExact and true or false
      followoverride = followoverride and true or false

      if ignoreRunes and WeakAuras.IsCataOrMistsOrRetail() then
        for i = 1, 6 do
          WeakAuras.WatchRuneCooldown(i)
        end
      end

      local effectiveSpellId = Private.ExecEnv.GetEffectiveSpellId(userSpellId, useExact, followoverride)

      self.watchedSpellIds[userSpellId] = self.watchedSpellIds[userSpellId] or {}
      self.watchedSpellIds[userSpellId][useExact] = self.watchedSpellIds[userSpellId][useExact] or {}
      if self.watchedSpellIds[userSpellId][useExact][followoverride] == effectiveSpellId then
        -- We are already watching userSpellId in the exact useExact/followoverride mode, so there's
        -- nothing to do then
        return
      end

      -- We aren't watching userSpellId yet
      self.watchedSpellIds[userSpellId][useExact][followoverride] = effectiveSpellId
      self:AddEffectiveSpellId(effectiveSpellId, userSpellId)
    end,

    SendEventsForSpell = function(self, effectiveSpellId, event, ...)
      local watchedSpells = self.data[effectiveSpellId] and self.data[effectiveSpellId].watched
      Private.ScanEventsByID(event, effectiveSpellId, ...)
      if watchedSpells then
        for userSpellId in pairs(watchedSpells) do
          if userSpellId ~= effectiveSpellId then
            Private.ScanEventsByID(event, userSpellId, ...)
          end
        end
      end
    end,

    GetSpellCharges = function(self, effectiveSpellId, ignoreSpellKnown)
      local spellDetail = self.data[effectiveSpellId]
      if not spellDetail then
        return
      end

      if not spellDetail.known and not ignoreSpellKnown then
        return
      end
      return spellDetail.charges, spellDetail.chargesMax, spellDetail.count, spellDetail.chargeGainTime, spellDetail.chargeLostTime
    end,

    GetSpellCooldown = function(self, effectiveSpellId, ignoreRuneCD, showgcd, ignoreSpellKnown, track)
      if (not (self.data[effectiveSpellId] and self.data[effectiveSpellId].known) and not ignoreSpellKnown) then
        return;
      end
      local startTime, duration, paused, gcdCooldown, readyTime, modRate
      if track == "charges" then
        startTime, duration, paused, readyTime, modRate = self.spellCdsCharges:FetchSpellCooldown(effectiveSpellId)
      elseif track == "cooldown" then
        if ignoreRuneCD then
          startTime, duration, paused, readyTime, modRate = self.spellCdsOnlyCooldownRune:FetchSpellCooldown(effectiveSpellId)
        else
          startTime, duration, paused, readyTime, modRate = self.spellCdsOnlyCooldown:FetchSpellCooldown(effectiveSpellId)
        end
      elseif (ignoreRuneCD) then
        startTime, duration, paused, readyTime, modRate = self.spellCdsRune:FetchSpellCooldown(effectiveSpellId)
      else
        startTime, duration, paused, readyTime, modRate = self.spellCds:FetchSpellCooldown(effectiveSpellId)
      end

      if paused then
        return startTime, duration, false, readyTime, modRate, true
      end

      if (showgcd) then
        if ((gcdStart or 0) + (gcdDuration or 0) > startTime + duration) then
          if startTime == 0 then
            gcdCooldown = true
          end
          startTime = gcdStart;
          duration = gcdDuration;
          modRate = gcdModrate
        end
      end

      return startTime, duration, gcdCooldown, readyTime, modRate, false
    end
  }

  local mark_ACTIONBAR_UPDATE_COOLDOWN, mark_PLAYER_ENTERING_WORLD

  ---@type fun()
  function Private.InitCooldownReady()
    ---@class CooldownReadyFrame : FrameScriptObject
    cdReadyFrame = CreateFrame("Frame");
    cdReadyFrame.inWorld = 0
    Private.frames["Cooldown Trigger Handler"] = cdReadyFrame
    if WeakAuras.IsRetail() then
      cdReadyFrame:RegisterEvent("RUNE_POWER_UPDATE");
      cdReadyFrame:RegisterEvent("PLAYER_TALENT_UPDATE");
      cdReadyFrame:RegisterEvent("PLAYER_PVP_TALENT_UPDATE");
    else
      cdReadyFrame:RegisterEvent("CHARACTER_POINTS_CHANGED");
    end
    cdReadyFrame:RegisterEvent("SPELL_UPDATE_COOLDOWN");
    cdReadyFrame:RegisterEvent("SPELL_UPDATE_USABLE")
    cdReadyFrame:RegisterEvent("UNIT_SPELLCAST_SENT");
    cdReadyFrame:RegisterEvent("BAG_UPDATE_DELAYED");
    cdReadyFrame:RegisterUnitEvent("UNIT_INVENTORY_CHANGED", "player")
    cdReadyFrame:RegisterEvent("PLAYER_EQUIPMENT_CHANGED");
    cdReadyFrame:RegisterEvent("ACTIONBAR_UPDATE_COOLDOWN");
    cdReadyFrame:RegisterEvent("SPELLS_CHANGED");
    cdReadyFrame:RegisterEvent("PLAYER_ENTERING_WORLD");
    cdReadyFrame:RegisterEvent("PLAYER_LEAVING_WORLD")
    if WeakAuras.IsCataClassic() then
      cdReadyFrame:RegisterEvent("RUNE_POWER_UPDATE");
      cdReadyFrame:RegisterEvent("RUNE_TYPE_UPDATE");
    end
    cdReadyFrame.HandleEvent = function(self, event, ...)
      if (event == "PLAYER_ENTERING_WORLD") then
        cdReadyFrame.inWorld = GetTime()
      end
      if (event == "PLAYER_LEAVING_WORLD") then
        cdReadyFrame.inWorld = nil
      end
      if not cdReadyFrame.inWorld then
        return
      end

      if GetTime() - cdReadyFrame.inWorld < 2 then
        mark_PLAYER_ENTERING_WORLD = true
        cdReadyFrame:Show()
        return
      end
      if (event == "ACTIONBAR_UPDATE_COOLDOWN") then
        mark_ACTIONBAR_UPDATE_COOLDOWN = true
        cdReadyFrame:Show()
        return
      end

      Private.StartProfileSystem("generictrigger cd tracking");
      if type(event) == "number" then-- Called from OnUpdate!
        if mark_PLAYER_ENTERING_WORLD then
          SpellDetails:CheckSpellKnown()
          Private.CheckCooldownReady()
          Private.CheckItemSlotCooldowns()
          mark_PLAYER_ENTERING_WORLD = nil
          mark_ACTIONBAR_UPDATE_COOLDOWN = nil
        elseif mark_ACTIONBAR_UPDATE_COOLDOWN then
          Private.CheckCooldownReady()
          mark_ACTIONBAR_UPDATE_COOLDOWN = nil
        end
      elseif(event == "SPELL_UPDATE_COOLDOWN" or event == "RUNE_POWER_UPDATE"
        or event == "PLAYER_TALENT_UPDATE" or event == "PLAYER_PVP_TALENT_UPDATE"
        or event == "CHARACTER_POINTS_CHANGED" or event == "RUNE_TYPE_UPDATE")
        or event == "SPELL_UPDATE_USABLE"
      then
        local spellId = nil
        if event == "SPELL_UPDATE_COOLDOWN" then
          local arg1 = ...
          if arg1 and type(arg1) == "number" then
            spellId = arg1
            -- baseSpellId = arg2
          end
          mark_ACTIONBAR_UPDATE_COOLDOWN = nil
        end
        Private.CheckCooldownReady(spellId)
      elseif(event == "SPELLS_CHANGED") then
        SpellDetails:CheckSpellKnown()
        Private.CheckCooldownReady()
      elseif(event == "UNIT_SPELLCAST_SENT") then
        local unit, guid, castGUID, name = ...;
        if(unit == "player") then
          name = Private.ExecEnv.GetSpellName(name);
          if(gcdSpellName ~= name) then
            local icon = Private.ExecEnv.GetSpellIcon(name);
            gcdSpellName = name;
            gcdSpellIcon = icon;
            if not WeakAuras.IsPaused() then
              Private.ScanEvents("GCD_UPDATE")
            end
          end
        end
      elseif(event == "UNIT_INVENTORY_CHANGED" or event == "BAG_UPDATE_DELAYED" or event == "PLAYER_EQUIPMENT_CHANGED") then
        Private.CheckItemSlotCooldowns();
      end
      Private.StopProfileSystem("generictrigger cd tracking");
      if mark_PLAYER_ENTERING_WORLD == nil and mark_ACTIONBAR_UPDATE_COOLDOWN == nil then
        cdReadyFrame:Hide()
      else
        cdReadyFrame:Show()
      end
    end
    cdReadyFrame:Hide()
    cdReadyFrame:SetScript("OnEvent", cdReadyFrame.HandleEvent)
    cdReadyFrame:SetScript("OnUpdate", cdReadyFrame.HandleEvent)
  end

  ---@param id number
  ---@return number cooldownStart
  ---@return number cooldownDuration
  function WeakAuras.GetRuneCooldown(id)
    if(runes[id] and runeCdExps[id] and runeCdDurs[id]) then
      return runeCdExps[id] - runeCdDurs[id], runeCdDurs[id];
    else
      return 0, 0;
    end
  end

  local initEssenceCooldown = false
  local essenceCache = {{},{},{},{},{},{}}
  ---@private
  function WeakAuras.InitEssenceCooldown()
    if initEssenceCooldown then
      return true
    end
    local EssenceEnum = Enum.PowerType.Essence
    local lastFullValue = 0
    local lastTime = 0
    local essenceEventFrame = CreateFrame("Frame")
    essenceEventFrame:RegisterUnitEvent("UNIT_POWER_FREQUENT", "player")
    essenceEventFrame:RegisterUnitEvent("UNIT_MAXPOWER", "player")
    essenceEventFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
    essenceEventFrame:RegisterEvent("PLAYER_LEAVING_WORLD")
    local essenceEventHandler = function(self, event, unitTarget, powerType)
      if powerType and powerType ~= "ESSENCE" then
        return
      end
      local now = GetTime()
      if lastTime == now then
        return
      end
      Private.StartProfileSystem("generictrigger essence")
      local power = UnitPower("player", EssenceEnum)
      local total = UnitPowerMax("player", EssenceEnum)
      local peace = GetPowerRegenForPowerType(EssenceEnum)
      if peace == nil or peace == 0 then
        peace = 0.2
      end
      local duration = 1 / peace
      local partial = UnitPartialPower("player", EssenceEnum) / 1000

      if (partial == 0) then
        lastFullValue = now
      elseif power ~= total then
        -- UnitPartialPower is a rather poor api, which returns incorrect values
        -- This almost mirrors what the default ui does, in that the default ui
        -- starts an animation and only uses UnitPartialPower when that animation's
        -- progress differs from UnitPartialPower by 0.1
        -- This here uses a similar logic. We sync whenever partial is 0
        -- and then estimate based on that. And as long as that
        -- estimate is within 0.1 of UnitPartialPower we prefer the estimate
        local estimatedPartial = (now - lastFullValue) / duration
        estimatedPartial = estimatedPartial - floor(estimatedPartial)
        if abs(estimatedPartial - partial) < 0.1 then
          partial = estimatedPartial
        end
      end
      for i = 1, 6 do
        local essence = essenceCache[i]
        if i > total then
          essence.duration = nil
          essence.expirationTime = nil
          essence.remaining = nil
          essence.paused = nil
        elseif power >= i then
          essence.duration = duration
          essence.expirationTime = math.huge
          essence.remaining = 0
          essence.paused = true
        elseif power + 1 == i then
          essence.duration = duration
          essence.expirationTime = GetTime() + (1 - partial) * duration
          essence.paused = false
        else
          essence.duration = duration
          essence.expirationTime = GetTime() + (1 - partial) * duration + (i - 1 - power) * duration
          essence.remaining = duration
          essence.paused = false
        end
      end
      lastTime = now
      Private.StopProfileSystem("generictrigger essence")
      Private.ScanEvents("ESSENCE_UPDATE")
    end
    essenceEventFrame:SetScript("OnEvent", essenceEventHandler)
    essenceEventFrame:Show()

    essenceEventHandler()
    initEssenceCooldown = true
  end

  ---@param essence? number
  ---@return number|nil duration
  ---@return number|nil expirationTime
  ---@return number|nil remaining
  ---@return boolean|nil paused
  ---@return number|nil power
  ---@return number|nil total
  function WeakAuras.GetEssenceCooldown(essence)
    local power = UnitPower("player", Enum.PowerType.Essence)
    local total = UnitPowerMax("player", Enum.PowerType.Essence)
    if essence then
      local cache = essenceCache[essence]
      if cache and essence <= total then
        return cache.duration, cache.expirationTime, cache.remaining, cache.paused, power, total
      else
        return nil, nil, nil, nil, essence, total
      end
    else
      local cache = essenceCache[total]
      if cache and cache.duration then
        return total * cache.duration, cache.expirationTime, cache.remaining, cache.paused, power, total
      else
        return nil, nil, nil, nil, power, total
      end
    end
  end


  ---@param identifier string | number
  ---@return number? startTime, number? duration
  function WeakAuras.GetSpellLossOfControlCooldown(identifier)
    if WeakAuras.IsTWW() then
      return C_Spell.GetSpellLossOfControlCooldown(identifier)
    else
      return GetSpellLossOfControlCooldown(identifier)
    end
  end

  ---@param id string
  ---@param ignoreRuneCD boolean
  ---@param showgcd boolean
  ---@param ignoreSpellKnown boolean
  ---@param track boolean
  ---@return number? startTime
  ---@return number? duration
  ---@return number? gcdCooldown
  ---@return number? readyTime
  ---@return number? modRate
  ---@return boolean? paused
  function WeakAuras.GetSpellCooldown(id, ignoreRuneCD, showgcd, ignoreSpellKnown, track)
    return SpellDetails:GetSpellCooldown(id, ignoreRuneCD, showgcd, ignoreSpellKnown, track)
  end

  ---@param id string
  ---@param ignoreSpellKnown? boolean
  ---@return integer? charges
  ---@return integer? chargesMax
  ---@return integer? count
  ---@return number? chargeGainTime
  ---@return number? chargeLostTime
  function WeakAuras.GetSpellCharges(id, ignoreSpellKnown)
    return SpellDetails:GetSpellCharges(id, ignoreSpellKnown)
  end

  ---@param id string
  ---@param showgcd boolean
  ---@return number startTime
  ---@return number duration
  ---@return boolean enabled
  ---@return number gcdCooldown
  function WeakAuras.GetItemCooldown(id, showgcd)
    local startTime, duration, enabled, gcdCooldown;
    if(items[id] and itemCdExps[id] and itemCdDurs[id]) then
      startTime, duration, enabled = itemCdExps[id] - itemCdDurs[id], itemCdDurs[id], itemCdEnabled[id];
    else
      startTime, duration, enabled = 0, 0, itemCdEnabled[id] or 1;
    end
    if (showgcd) then
      if ((gcdStart or 0) + (gcdDuration or 0) > startTime + duration) then
        if startTime == 0 then
          gcdCooldown = true
        end
        startTime = gcdStart;
        duration = gcdDuration;
      end
    end
    return startTime, duration, enabled, gcdCooldown;
  end

  ---@return number duration
  ---@return number expirationTime
  ---@return string name
  ---@return number|string icon
  ---@return number modrate
  function WeakAuras.GetGCDInfo()
    if(gcdStart) then
      return gcdDuration, gcdStart + gcdDuration, gcdSpellName or "Invalid", gcdSpellIcon or "Interface\\Icons\\INV_Misc_QuestionMark", gcdModrate;
    else
      return 0, math.huge, gcdSpellName or "Invalid", gcdSpellIcon or "Interface\\Icons\\INV_Misc_QuestionMark", 1.0;
    end
  end

  ---@return number duration
  function WeakAuras.gcdDuration()
    return gcdDuration or 0;
  end

  ---@return string name
  function WeakAuras.GcdSpellName()
    return gcdSpellName;
  end

  ---@param id string
  ---@param showgcd boolean
  ---@return number startTime
  ---@return number duration
  ---@return boolean enabled
  ---@return number gcdCooldown
  function WeakAuras.GetItemSlotCooldown(id, showgcd)
    local startTime, duration, enabled, gcdCooldown;
    if(itemSlots[id] and itemSlotsCdExps[id] and itemSlotsCdDurs[id]) then
      startTime, duration, enabled = itemSlotsCdExps[id] - itemSlotsCdDurs[id], itemSlotsCdDurs[id], itemSlotsEnable[id];
    else
      startTime, duration, enabled = 0, 0, itemSlotsEnable[id];
    end

    if (showgcd) then
      if ((gcdStart or 0) + (gcdDuration or 0) > startTime + duration) then
        if startTime == 0 then
          gcdCooldown = true
        end
        startTime = gcdStart;
        duration = gcdDuration;
      end
    end
    return startTime, duration, enabled, gcdCooldown;
  end

  local function RuneCooldownFinished(id)
    runeCdHandles[id] = nil;
    runeCdDurs[id] = nil;
    runeCdExps[id] = nil;
    Private.ScanEvents("RUNE_COOLDOWN_READY", id);
  end

  local function ItemCooldownFinished(id)
    itemCdHandles[id] = nil;
    itemCdDurs[id] = nil;
    itemCdExps[id] = nil;
    itemCdEnabled[id] = 1;
    Private.ScanEventsByID("ITEM_COOLDOWN_READY", id);
  end

  local function ItemSlotCooldownFinished(id)
    itemSlotsCdHandles[id] = nil;
    itemSlotsCdDurs[id] = nil;
    itemSlotsCdExps[id] = nil;
    Private.ScanEventsByID("ITEM_SLOT_COOLDOWN_READY", id);
  end

  ---@type fun()
  ---@return number
  function Private.CheckRuneCooldown()
    local runeDuration = -100;
    for id, _ in pairs(runes) do
      local startTime, duration = GetRuneCooldown(id);
      startTime = startTime or 0;
      duration = duration or 0;
      runeDuration = duration > 0 and duration or runeDuration
      local time = GetTime();

      if(not startTime or startTime == 0) then
        startTime = 0
        duration = 0
      end

      if(duration > 0 and duration ~= WeakAuras.gcdDuration()) then
        -- On non-GCD cooldown
        local endTime = startTime + duration;

        if not(runeCdExps[id]) then
          -- New cooldown
          runeCdDurs[id] = duration;
          runeCdExps[id] = endTime;
          runeCdHandles[id] = timer:ScheduleTimerFixed(RuneCooldownFinished, endTime - time, id);
          Private.ScanEvents("RUNE_COOLDOWN_STARTED", id);
        elseif(runeCdExps[id] ~= endTime) then
          -- Cooldown is now different
          if(runeCdHandles[id]) then
            timer:CancelTimer(runeCdHandles[id]);
          end
          runeCdDurs[id] = duration;
          runeCdExps[id] = endTime;
          runeCdHandles[id] = timer:ScheduleTimerFixed(RuneCooldownFinished, endTime - time, id);
          Private.ScanEvents("RUNE_COOLDOWN_CHANGED", id);
        end
      elseif(duration > 0) then
      -- GCD, do nothing
      else
        if(runeCdExps[id]) then
          -- Somehow CheckCooldownReady caught the rune cooldown before the timer callback
          -- This shouldn't happen, but if it does, no problem
          if(runeCdHandles[id]) then
            timer:CancelTimer(runeCdHandles[id]);
          end
          RuneCooldownFinished(id);
        end
      end
    end
    return runeDuration;
  end

  local GetSpellCharges = GetSpellCharges or function(id)
    local chargeInfo = C_Spell.GetSpellCharges(id)
    if not chargeInfo then return end
    return chargeInfo.currentCharges, chargeInfo.maxCharges, chargeInfo.cooldownStartTime, chargeInfo.cooldownDuration, chargeInfo.chargeModRate
  end
  local GetSpellCount = GetSpellCount or C_Spell.GetSpellCastCount

  ---@param id string
  ---@param runeDuration? number
  function WeakAuras.GetSpellCooldownUnified(id, runeDuration)
    local startTimeCooldown, durationCooldown, enabled, modRate
    if GetSpellCooldown then
      startTimeCooldown, durationCooldown, enabled, modRate = GetSpellCooldown(id)
      if type(enabled) == "number" then
        enabled = enabled == 1 and true or false
      end
    else
      local spellCooldownInfo = C_Spell.GetSpellCooldown(id);
      if spellCooldownInfo then
        startTimeCooldown = spellCooldownInfo.startTime
        durationCooldown = spellCooldownInfo.duration
        enabled = spellCooldownInfo.isEnabled
        modRate = spellCooldownInfo.modRate
      end
    end

    local charges, maxCharges, startTimeCharges, durationCharges, modRateCharges = GetSpellCharges(id);

    startTimeCooldown = startTimeCooldown or 0;
    durationCooldown = durationCooldown or 0;

    startTimeCharges = startTimeCharges or 0;
    durationCharges = durationCharges or 0;

    modRate = modRate or 1.0;
    modRateCharges = modRateCharges or 1.0;

    -- WORKAROUND: Sometimes the API returns very high bogus numbers causing client freezes, discard them here. CurseForge issue #1008
    if (durationCooldown > 604800) then
      durationCooldown = 0;
      startTimeCooldown = 0;
    end

    if (startTimeCooldown > GetTime() + 2^31 / 1000) then
      -- WORKAROUND: WoW wraps around negative values with 2^32/1000
      -- So if we find a cooldown in the far future, then undo the wrapping
      startTimeCooldown = startTimeCooldown - 2^32 / 1000
    end

    -- Default to
    ---@type boolean?
    local unifiedCooldownBecauseRune = false
    ---@type boolean?
    local cooldownBecauseRune = false
    -- Paused cooldowns are:
    -- Spells like Presence of Mind/Nature's Swiftness that start their cooldown after the effect is consumed
    -- But also oddly some Evoker spells
    -- Presence of Might is on 0.0001 enabled == 0 cooldown while prepared
    -- For Evoker, using an empowered spell puts spells on pause. Some spells are put on an entirely bogus 0.5 paused cd
    -- Others the real cd (that continues ticking) is paused.
    -- We treat anything with less than 0.5 as not on cd, and hope for the best.
    if not enabled and durationCooldown <= 0.5 then
      startTimeCooldown, durationCooldown, enabled = 0, 0, true
    end

    local onNonGCDCD = durationCooldown and startTimeCooldown and durationCooldown > 0 and (durationCooldown ~= gcdDuration or startTimeCooldown ~= gcdStart);
    if (onNonGCDCD) then
      cooldownBecauseRune = runeDuration and durationCooldown and abs(durationCooldown - runeDuration) < 0.001;
      unifiedCooldownBecauseRune = cooldownBecauseRune
    end

    local startTime, duration, unifiedModRate = startTimeCooldown, durationCooldown, modRate
    if (charges == nil) then
      -- charges is nil if the spell has no charges.
      -- Nothing to do in that case
    elseif (charges == maxCharges) then
      -- At max charges,
      startTime, duration = 0, 0;
      startTimeCharges, durationCharges = 0, 0
    else
      -- Spells can return both information via GetSpellCooldown and GetSpellCharges
      -- E.g. Rune of Power see Github-Issue: #1060
      -- So if GetSpellCooldown returned a cooldown, use that one, if it's a "significant" cooldown
      --  Otherwise check GetSpellCharges
      -- A few abilities have a minor cooldown just to prevent the user from triggering it multiple times,
      -- ignore them since practically no one wants to see them
      if duration and duration <= 1.5 or (duration == gcdDuration and startTime == gcdStart) then
        startTime, duration, unifiedModRate = startTimeCharges, durationCharges, modRateCharges
        unifiedCooldownBecauseRune = false
      end
    end

    local count = GetSpellCount(id)

    return charges, maxCharges, startTime, duration, unifiedCooldownBecauseRune,
           startTimeCooldown, durationCooldown, cooldownBecauseRune, startTimeCharges, durationCharges,
           count, unifiedModRate, modRate, modRateCharges, not enabled
  end

  ---@type fun(id, runeDuration)
  function Private.CheckSpellCooldown(id, runeDuration)
    SpellDetails:CheckSpellCooldown(id, runeDuration)
  end

  ---@type fun()
  function Private.CheckItemCooldowns()
    for id, _ in pairs(items) do
      local startTime, duration, enabled = C_Container.GetItemCooldown(id);
      -- TODO: In 10.2.6 the apis return values changed from 1,0 for enabled to true, false
      -- We should adjust once its on all versions
      if enabled == false then
        enabled = 0
      elseif enabled == true then
        enabled = 1
      end
      if (duration == 0) then
        enabled = 1;
      end
      if (enabled == 0) then
        startTime, duration = 0, 0
      end

      local itemCdEnabledChanged = (itemCdEnabled[id] ~= enabled);
      itemCdEnabled[id] = enabled;
      startTime = startTime or 0;
      duration = duration or 0;
      local time = GetTime();

      -- We check against 1.5 and gcdDuration, as apparently the durations might not match exactly.
      -- But there shouldn't be any trinket with a actual cd of less than 1.5 anyway
      if(duration > 0 and duration > 1.5 and duration ~= WeakAuras.gcdDuration()) then
        -- On non-GCD cooldown
        local endTime = startTime + duration;

        if not(itemCdExps[id]) then
          -- New cooldown
          itemCdDurs[id] = duration;
          itemCdExps[id] = endTime;
          itemCdHandles[id] = timer:ScheduleTimerFixed(ItemCooldownFinished, endTime - time, id);
          if not WeakAuras.IsPaused() then
            Private.ScanEventsByID("ITEM_COOLDOWN_STARTED", id)
          end
          itemCdEnabledChanged = false;
        elseif(itemCdExps[id] ~= endTime) then
          -- Cooldown is now different
          if(itemCdHandles[id]) then
            timer:CancelTimer(itemCdHandles[id]);
          end
          itemCdDurs[id] = duration;
          itemCdExps[id] = endTime;
          itemCdHandles[id] = timer:ScheduleTimerFixed(ItemCooldownFinished, endTime - time, id);
          if not WeakAuras.IsPaused() then
            Private.ScanEventsByID("ITEM_COOLDOWN_CHANGED", id)
          end
          itemCdEnabledChanged = false;
        end
      elseif(duration > 0) then
      -- GCD, do nothing
      else
        if(itemCdExps[id]) then
          -- Somehow CheckCooldownReady caught the item cooldown before the timer callback
          -- This shouldn't happen, but if it does, no problem
          if(itemCdHandles[id]) then
            timer:CancelTimer(itemCdHandles[id]);
          end
          ItemCooldownFinished(id);
          itemCdEnabledChanged = false;
        end
      end
      if (itemCdEnabledChanged and not WeakAuras.IsPaused()) then
        Private.ScanEventsByID("ITEM_COOLDOWN_CHANGED", id);
      end
    end
  end

  ---@type fun()
  function Private.CheckItemSlotCooldowns()
    for id, itemId in pairs(itemSlots) do
      local startTime, duration, enable = GetInventoryItemCooldown("player", id);
      itemSlotsEnable[id] = enable;
      startTime = startTime or 0;
      duration = duration or 0;
      local time = GetTime();

      -- We check against 1.5 and gcdDuration, as apparently the durations might not match exactly.
      -- But there shouldn't be any trinket with a actual cd of less than 1.5 anyway
      if(duration > 0 and duration > 1.5 and duration ~= WeakAuras.gcdDuration()) then
        -- On non-GCD cooldown
        local endTime = startTime + duration;

        if not(itemSlotsCdExps[id]) then
          -- New cooldown
          itemSlotsCdDurs[id] = duration;
          itemSlotsCdExps[id] = endTime;
          itemSlotsCdHandles[id] = timer:ScheduleTimerFixed(ItemSlotCooldownFinished, endTime - time, id);
          if not WeakAuras.IsPaused() then
            Private.ScanEventsByID("ITEM_SLOT_COOLDOWN_STARTED", id)
          end
        elseif(itemSlotsCdExps[id] ~= endTime) then
          -- Cooldown is now different
          if(itemSlotsCdHandles[id]) then
            timer:CancelTimer(itemSlotsCdHandles[id]);
          end
          itemSlotsCdDurs[id] = duration;
          itemSlotsCdExps[id] = endTime;
          itemSlotsCdHandles[id] = timer:ScheduleTimerFixed(ItemSlotCooldownFinished, endTime - time, id);
          if not WeakAuras.IsPaused() then
            Private.ScanEventsByID("ITEM_SLOT_COOLDOWN_CHANGED", id)
          end
        end
      elseif(duration > 0) then
      -- GCD, do nothing
      else
        if(itemSlotsCdExps[id]) then
          -- Somehow CheckCooldownReady caught the item cooldown before the timer callback
          -- This shouldn't happen, but if it does, no problem
          if(itemSlotsCdHandles[id]) then
            timer:CancelTimer(itemSlotsCdHandles[id]);
          end
          ItemSlotCooldownFinished(id);
        end
      end

      local newItemId = GetInventoryItemID("player", id);
      if (itemId ~= newItemId) then
        if not WeakAuras.IsPaused() then
          Private.ScanEventsByID("ITEM_SLOT_COOLDOWN_ITEM_CHANGED", id)
        end
        itemSlots[id] = newItemId or 0;
      end
    end
  end

  ---@type fun(spell: number|string?)
  function Private.CheckCooldownReady(spell)
    CheckGCD();
    local runeDuration = Private.CheckRuneCooldown();
    if spell then
      if SpellDetails.data[spell] then
        SpellDetails:CheckSpellCooldown(spell, runeDuration)
      end
    else
      SpellDetails:CheckSpellCooldowns(runeDuration);
      Private.CheckItemCooldowns();
      Private.CheckItemSlotCooldowns();
    end
  end

  ---@private
  function WeakAuras.WatchGCD()
    if not(cdReadyFrame) then
      Private.InitCooldownReady();
    end
  end

  ---@private
  function WeakAuras.WatchRuneCooldown(id)
    if not(cdReadyFrame) then
      Private.InitCooldownReady();
    end

    if not id or id == 0 then return end

    if not(runes[id]) then
      runes[id] = true;
      local startTime, duration = GetRuneCooldown(id);

      if(not startTime or startTime == 0) then
        startTime = 0
        duration = 0
      end

      if(duration > 0 and duration ~= WeakAuras.gcdDuration()) then
        local time = GetTime();
        local endTime = startTime + duration;
        runeCdDurs[id] = duration;
        runeCdExps[id] = endTime;
        if not(runeCdHandles[id]) then
          runeCdHandles[id] = timer:ScheduleTimerFixed(RuneCooldownFinished, endTime - time, id);
        end
      end
    end
  end

  local GetOverrideSpell
  if WeakAuras.IsTWW() then
    GetOverrideSpell = C_Spell.GetOverrideSpell
  else
    GetOverrideSpell = FindSpellOverrideByID
  end

  function Private.ExecEnv.GetEffectiveSpellId(spellId, exactMatch, followoverride)
    if type(spellId) == "string" then
      spellId = select(7, Private.ExecEnv.GetSpellInfo(spellId))
    end
    if not exactMatch then
      local spellName = Private.ExecEnv.GetSpellName(spellId or "")
      if spellName then
        local spellIdForName = select(7, Private.ExecEnv.GetSpellInfo(spellName))
        if spellIdForName then
          spellId = spellIdForName
        end
      end
    end
    if followoverride then
      local override = spellId and GetOverrideSpell(spellId)
      if override then
        spellId = override
      end
    end

    return spellId
  end

  ---@private
  function WeakAuras.WatchSpellCooldown(id, ignoreRunes, useExact, followoverride)
    SpellDetails:WatchSpellCooldown(id, ignoreRunes, useExact, followoverride)
  end

  ---@private
  function WeakAuras.WatchItemCooldown(id)
    if not(cdReadyFrame) then
      Private.InitCooldownReady();
    end

    if not id or id == 0 then return end

    if not(items[id]) then
      items[id] = true;
      -- TODO: In 10.2.6 the apis return values changed from 1,0 for enabled to true, false
      -- We should adjust once its on all versions
      local startTime, duration, enabled = C_Container.GetItemCooldown(id);
      if (duration == 0) then
        enabled = 1;
      end
      if (enabled == 0) then
        startTime, duration = 0, 0
      end
      itemCdEnabled[id] = enabled;
      if(duration and duration > 0 and duration > 1.5 and duration ~= WeakAuras.gcdDuration()) then
        local time = GetTime();
        local endTime = startTime + duration;
        itemCdDurs[id] = duration;
        itemCdExps[id] = endTime;
        if not(itemCdHandles[id]) then
          itemCdHandles[id] = timer:ScheduleTimerFixed(ItemCooldownFinished, endTime - time, id);
        end
      end
    end
  end

  ---@private
  function WeakAuras.WatchItemSlotCooldown(id)
    if not(cdReadyFrame) then
      Private.InitCooldownReady();
    end

    if not id or id == 0 then return end

    if not(itemSlots[id]) then
      itemSlots[id] = GetInventoryItemID("player", id);
      local startTime, duration, enable = GetInventoryItemCooldown("player", id);
      itemSlotsEnable[id] = enable;
      if(duration > 0 and duration > 1.5 and duration ~= WeakAuras.gcdDuration()) then
        local time = GetTime();
        local endTime = startTime + duration;
        itemSlotsCdDurs[id] = duration;
        itemSlotsCdExps[id] = endTime;
        if not(itemSlotsCdHandles[id]) then
          itemSlotsCdHandles[id] = timer:ScheduleTimerFixed(ItemSlotCooldownFinished, endTime - time, id);
        end
      end
    end
  end
end

do
  local spellActivationSpells = {};
  local spellActivationSpellsCurrent = {};
  local spellActivationFrame;
  local function InitSpellActivation()
    spellActivationFrame = CreateFrame("Frame");
    Private.frames["Spell Activation"] = spellActivationFrame;
    spellActivationFrame:RegisterEvent("SPELL_ACTIVATION_OVERLAY_GLOW_SHOW");
    spellActivationFrame:RegisterEvent("SPELL_ACTIVATION_OVERLAY_GLOW_HIDE");
    spellActivationFrame:SetScript("OnEvent", function(self, event, spell)
      Private.StartProfileSystem("generictrigger spell activation");
      local spellName = Private.ExecEnv.GetSpellName(spell)
      if (spellActivationSpells[spell] or spellActivationSpells[spellName]) then
        local active = (event == "SPELL_ACTIVATION_OVERLAY_GLOW_SHOW")
        spellActivationSpellsCurrent[spell] = active
        spellActivationSpellsCurrent[spellName] = active
        if not WeakAuras.IsPaused() then
          Private.ScanEventsByID("WA_UPDATE_OVERLAY_GLOW", spell)
          Private.ScanEventsByID("WA_UPDATE_OVERLAY_GLOW", spellName)
        end
      end

      Private.StopProfileSystem("generictrigger spell activation");
    end);
  end

  ---@private
  function WeakAuras.WatchSpellActivation(id)
    if (not id) then
      return;
    end
    if (not spellActivationFrame) then
      InitSpellActivation();
    end
    spellActivationSpells[id] = true;
  end

  ---@param id string
  ---@return boolean overlayGlowActive
  function WeakAuras.SpellActivationActive(id)
    return spellActivationSpellsCurrent[id];
  end
end

local watchUnitChange

-- Nameplates only distinguish between friends and everyone else
---@param unit UnitToken
---@return string? reaction
function WeakAuras.GetPlayerReaction(unit)
  local r = UnitReaction("player", unit)
  if r then
    return r < 5 and "hostile" or "friendly"
  end
end

---@param unit UnitToken
function WeakAuras.WatchUnitChange(unit)
  unit = string.lower(unit)
  if not watchUnitChange then
    ---@class UnitChangeFrame: FrameScriptObject
    watchUnitChange = CreateFrame("Frame");
    watchUnitChange.trackedUnits = {}
    watchUnitChange.unitIdToGUID = {}
    watchUnitChange.GUIDToUnitIds = {}
    watchUnitChange.unitExists = {}
    watchUnitChange.unitRoles = {}
    watchUnitChange.unitRaidRole = {}
    watchUnitChange.inRaid = IsInRaid()
    watchUnitChange.nameplateFaction = {}
    watchUnitChange.raidmark = {}
    watchUnitChange.unitIsUnit = {}

    Private.frames["Unit Change Frame"] = watchUnitChange;
    watchUnitChange:RegisterEvent("PLAYER_TARGET_CHANGED")
    if not WeakAuras.IsClassicEra() then
      watchUnitChange:RegisterEvent("PLAYER_FOCUS_CHANGED")
      watchUnitChange:RegisterEvent("ARENA_OPPONENT_UPDATE")
    end
    watchUnitChange:RegisterEvent("PLAYER_ROLES_ASSIGNED")
    watchUnitChange:RegisterEvent("PLAYER_SOFT_ENEMY_CHANGED")
    watchUnitChange:RegisterEvent("PLAYER_SOFT_FRIEND_CHANGED")
    watchUnitChange:RegisterEvent("UNIT_TARGET");
    watchUnitChange:RegisterEvent("INSTANCE_ENCOUNTER_ENGAGE_UNIT");
    watchUnitChange:RegisterEvent("GROUP_ROSTER_UPDATE");
    watchUnitChange:RegisterEvent("NAME_PLATE_UNIT_ADDED")
    watchUnitChange:RegisterEvent("NAME_PLATE_UNIT_REMOVED")
    watchUnitChange:RegisterEvent("UNIT_FACTION")
    watchUnitChange:RegisterEvent("PLAYER_ENTERING_WORLD")
    watchUnitChange:RegisterEvent("UNIT_PET")
    watchUnitChange:RegisterEvent("RAID_TARGET_UPDATE")

    local function unitUpdate(unitA, eventsToSend)
      local oldUnitExists = watchUnitChange.unitExists[unitA]
      local oldGUID = watchUnitChange.unitIdToGUID[unitA]
      local newGUID = WeakAuras.UnitExistsFixed(unitA) and UnitGUID(unitA)
      local unitExists = UnitExists(unitA) -- UnitExistsFixed check both UnitExists and UnitGUID, but in edge cases we are interested in UnitExists
      if oldGUID ~= newGUID or oldUnitExists ~= unitExists then
        eventsToSend["UNIT_CHANGED_" .. unitA] = unitA
        if watchUnitChange.GUIDToUnitIds[oldGUID] then
          for unitB in pairs(watchUnitChange.GUIDToUnitIds[oldGUID]) do
            if unitA ~= unitB then
              eventsToSend["UNIT_IS_UNIT_CHANGED_" .. unitA .. "_" .. unitB] = unitA
              eventsToSend["UNIT_IS_UNIT_CHANGED_" .. unitB .. "_" .. unitA] = unitB
            end
          end
        end
        if watchUnitChange.GUIDToUnitIds[newGUID] then
          for unitB in pairs(watchUnitChange.GUIDToUnitIds[newGUID]) do
            if unitA ~= unitB then
              eventsToSend["UNIT_IS_UNIT_CHANGED_" .. unitA .. "_" .. unitB] = unitA
              eventsToSend["UNIT_IS_UNIT_CHANGED_" .. unitB .. "_" .. unitA] = unitB
            end
          end
        end
      end
      -- update data
      if oldGUID and watchUnitChange.GUIDToUnitIds[oldGUID] then
        watchUnitChange.GUIDToUnitIds[oldGUID][unitA] = nil
        if next(watchUnitChange.GUIDToUnitIds[oldGUID]) == nil then
          watchUnitChange.GUIDToUnitIds[oldGUID] = nil
        end
      end
      if newGUID then
        watchUnitChange.GUIDToUnitIds[newGUID] = watchUnitChange.GUIDToUnitIds[newGUID] or {}
        watchUnitChange.GUIDToUnitIds[newGUID][unitA] = true
      end
      watchUnitChange.unitIdToGUID[unitA] = newGUID
      watchUnitChange.unitExists[unitA] = unitExists
    end

    local function markerUpdate(unit, eventsToSend)
      local oldMarker = watchUnitChange.raidmark[unit]
      local newMarker = GetRaidTargetIndex(unit) or 0
      if newMarker ~= oldMarker then
        eventsToSend["UNIT_CHANGED_" .. unit] = unit
        watchUnitChange.raidmark[unit] = newMarker
      end
    end

    local function markerInit(unit)
      watchUnitChange.raidmark[unit] = GetRaidTargetIndex(unit) or 0
    end

    local function markerClear(unit)
      watchUnitChange.raidmark[unit] = nil
    end

    local function reactionUpdate(unit, eventsToSend)
      local oldReaction = watchUnitChange.nameplateFaction[unit]
      local newReaction = WeakAuras.GetPlayerReaction(unit)
      if oldReaction ~= newReaction then
        eventsToSend["UNIT_CHANGED_" .. unit] = unit
        watchUnitChange.nameplateFaction[unit] = newReaction
      end
    end

    local function reactionInit(unit)
      watchUnitChange.nameplateFaction[unit] = WeakAuras.GetPlayerReaction(unit)
    end

    local function reactionClear(unit)
      watchUnitChange.nameplateFaction[unit] = nil
    end

    local roleUpdate
    if WeakAuras.IsClassicEra() then
      function roleUpdate(unit, eventsToSend)
        -- For classic check both raid role and group role
        local oldRaidRole = watchUnitChange.unitRaidRole[unit]
        local newRaidRole = WeakAuras.UnitRaidRole(unit)
        if oldRaidRole ~= newRaidRole then
          eventsToSend["UNIT_ROLE_CHANGED_" .. unit] = unit
          watchUnitChange.unitRaidRole[unit] = newRaidRole
        end
        local oldRole = watchUnitChange.unitRoles[unit]
        local newRole = UnitGroupRolesAssigned(unit)
        if oldRole ~= newRole then
          eventsToSend["UNIT_ROLE_CHANGED_" .. unit] = unit
          watchUnitChange.unitRoles[unit] = newRole
        end
      end
    end
    if WeakAuras.IsCataOrMistsOrRetail() then
      function roleUpdate(unit, eventsToSend)
        local oldRole = watchUnitChange.unitRoles[unit]
        local newRole = UnitGroupRolesAssigned(unit)
        if oldRole ~= newRole then
          eventsToSend["UNIT_ROLE_CHANGED_" .. unit] = unit
          watchUnitChange.unitRoles[unit] = newRole
        end
      end
    end

    local function handleUnit(unit, eventsToSend, ...)
      if watchUnitChange.trackedUnits[unit] then
        local fn
        for i = 1, select("#", ...) do
          fn = select(i, ...)
          fn(unit, eventsToSend)
        end
      end
    end

    local handleEvent = {
      PLAYER_ENTERING_WORLD = function(_, eventsToSend)
        for unit in pairs(watchUnitChange.unitIdToGUID) do
          handleUnit(unit, eventsToSend, unitUpdate, markerUpdate, reactionUpdate)
        end
      end,
      NAME_PLATE_UNIT_ADDED = function(unit, eventsToSend)
        handleUnit(unit, eventsToSend, unitUpdate, markerInit, reactionInit)
      end,
      NAME_PLATE_UNIT_REMOVED = function(unit, eventsToSend)
        handleUnit(unit, eventsToSend, unitUpdate, markerClear, reactionClear)
      end,
      INSTANCE_ENCOUNTER_ENGAGE_UNIT = function(_, eventsToSend)
        for i = 1, 10 do
          handleUnit("boss" .. i, eventsToSend, unitUpdate, markerInit, reactionInit)
          handleUnit("boss" .. i .. "target", eventsToSend, unitUpdate, markerInit, reactionInit)
        end
      end,
      ARENA_OPPONENT_UPDATE = function(unit, eventsToSend)
        handleUnit(unit, eventsToSend, unitUpdate, markerInit, reactionInit)
        handleUnit(unit .. "target", eventsToSend, unitUpdate, markerInit, reactionInit)
      end,
      PLAYER_TARGET_CHANGED = function(_, eventsToSend)
        handleUnit("target", eventsToSend, unitUpdate, markerInit, reactionInit)
        handleUnit("targettarget", eventsToSend, unitUpdate, markerInit, reactionInit)
      end,
      PLAYER_FOCUS_CHANGED = function(_, eventsToSend)
        handleUnit("focus", eventsToSend, unitUpdate, markerInit, reactionInit)
        handleUnit("focustarget", eventsToSend, unitUpdate, markerInit, reactionInit)
      end,
      PLAYER_SOFT_ENEMY_CHANGED = function(_, eventsToSend)
        handleUnit("softenemy", eventsToSend, unitUpdate, markerInit, reactionInit)
        handleUnit("softenemytarget", eventsToSend, unitUpdate, markerInit, reactionInit)
      end,
      PLAYER_SOFT_FRIEND_CHANGED = function(_, eventsToSend)
        handleUnit("softfriend", eventsToSend, unitUpdate, markerInit, reactionInit)
        handleUnit("softfriendtarget", eventsToSend, unitUpdate, markerInit, reactionInit)
      end,
      RAID_TARGET_UPDATE = function(_, eventsToSend)
        for unit in pairs(watchUnitChange.raidmark) do
          handleUnit(unit, eventsToSend, markerUpdate)
        end
      end,
      UNIT_FACTION = function(unit, eventsToSend)
        handleUnit(unit, eventsToSend, reactionUpdate)
      end,
      UNIT_PET = function(unit, eventsToSend)
        local pet = WeakAuras.unitToPetUnit[unit]
        if pet and watchUnitChange.trackedUnits[pet] then
          eventsToSend["UNIT_CHANGED_" .. pet] = pet
        end
      end,
      PLAYER_ROLES_ASSIGNED = function(_, eventsToSend)
        for unit in pairs(Private.multiUnitUnits.group) do
          handleUnit(unit, eventsToSend, roleUpdate)
        end
      end,
      UNIT_TARGET = function(unit, eventsToSend)
        handleUnit(unit .. "target", eventsToSend, unitUpdate, markerInit, reactionInit)
      end,
      GROUP_ROSTER_UPDATE = function(_, eventsToSend)
        for unit in pairs(Private.multiUnitUnits.group) do
          handleUnit(unit, eventsToSend, unitUpdate, markerInit, reactionInit)
        end
        local inRaid = IsInRaid()
        local inRaidChanged = inRaid ~= watchUnitChange.inRaid
        if inRaidChanged then
          for unit in pairs(Private.multiUnitUnits.group) do
            if watchUnitChange.trackedUnits[unit] and watchUnitChange.unitIdToGUID[unit] then
              eventsToSend["UNIT_CHANGED_" .. unit] = unit
            end
          end
          watchUnitChange.inRaid = inRaid
        end
      end
    }

    watchUnitChange:SetScript("OnEvent", function(self, event, unit)
      Private.StartProfileSystem("generictrigger unit change");
      local eventsToSend = {}
      handleEvent[event](unit, eventsToSend)
      -- send events
      for event, unit in pairs(eventsToSend) do
        Private.ScanEvents(event, unit)
      end

      Private.StopProfileSystem("generictrigger unit change");
    end)
  end
  if watchUnitChange.trackedUnits[unit] then
    return
  end
  local guid = UnitGUID(unit)
  watchUnitChange.trackedUnits[unit] = true
  watchUnitChange.unitIdToGUID[unit] = WeakAuras.UnitExistsFixed(unit) and UnitGUID(unit)
  watchUnitChange.unitExists[unit] = UnitExists(unit)

  if guid then
    watchUnitChange.GUIDToUnitIds[guid] = watchUnitChange.GUIDToUnitIds[guid] or {}
    watchUnitChange.GUIDToUnitIds[guid][unit] = true
  end
  watchUnitChange.raidmark = watchUnitChange.raidmark or {}
  watchUnitChange.raidmark[unit] = GetRaidTargetIndex(unit) or 0
  watchUnitChange.inRaid = IsInRaid()
end

function WeakAuras.GetEquipmentSetInfo(itemSetName, partial)
  local bestMatchNumItems = 0;
  local bestMatchNumEquipped = 0;
  local bestMatchName = nil;
  local bestMatchIcon = nil;

  local equipmentSetIds = C_EquipmentSet.GetEquipmentSetIDs();
  for index, id in pairs(equipmentSetIds) do
    local name, icon, _, _, numItems, numEquipped = C_EquipmentSet.GetEquipmentSetInfo(id);
    if (itemSetName == nil or (name and itemSetName == name)) then
      if (name ~= nil) then
        local match = (not partial and numItems == numEquipped)
          or (partial and (numEquipped or 0) > bestMatchNumEquipped);
        if (match) then
          bestMatchNumEquipped = numEquipped;
          bestMatchNumItems = numItems;
          bestMatchName = name;
          bestMatchIcon = icon;
        end
      end
    end
  end
  return bestMatchName, bestMatchIcon, bestMatchNumEquipped, bestMatchNumItems;
end

-- Workaround Stagger's last tick not resulting in UNIT_ABSORB_AMOUNT_CHANGED
local staggerWatchFrame
function Private.WatchStagger()
  if not staggerWatchFrame then
    staggerWatchFrame = CreateFrame("FRAME")
    Private.frames["WeakAuras Stagger Frame"] = staggerWatchFrame

    if WeakAuras.IsRetail() then
      staggerWatchFrame:RegisterUnitEvent("UNIT_ABSORB_AMOUNT_CHANGED", "player")
      staggerWatchFrame:SetScript("OnEvent", function()
        Private.StartProfileSystem("stagger")
        local stagger = UnitStagger("player")
        if stagger > 0 then
          if not staggerWatchFrame.onupdate then
            staggerWatchFrame.onupdate = true
            staggerWatchFrame:SetScript("OnUpdate", function()
              Private.StartProfileSystem("stagger")
              local stagger = UnitStagger("player")
              if stagger ~= staggerWatchFrame.stagger then
                staggerWatchFrame.stagger = stagger
                Private.ScanEvents("WA_UNIT_STAGGER_CHANGED", "player", stagger)
              end
              if stagger == 0 then
                staggerWatchFrame:SetScript("OnUpdate", nil)
                staggerWatchFrame.onupdate = nil
              end
              Private.StopProfileSystem("stagger")
            end)
          end
        end

        if stagger ~= staggerWatchFrame.stagger then
          staggerWatchFrame.stagger = stagger
          Private.ScanEvents("WA_UNIT_STAGGER_CHANGED", "player", stagger)
        end
        Private.StopProfileSystem("stagger")
      end)
    elseif WeakAuras.IsMists() then
      -- On Mists Stagger has no events
      staggerWatchFrame:SetScript("OnUpdate", function()
        Private.StartProfileSystem("stagger")
        local stagger = UnitStagger("player")
        if stagger ~= staggerWatchFrame.stagger then
          staggerWatchFrame.stagger = stagger
          Private.ScanEvents("WA_UNIT_STAGGER_CHANGED", "player", stagger)
        end
        Private.StopProfileSystem("stagger")
      end)
    end
  end
end

function Private.ExecEnv.CheckTotemName(totemName, triggerTotemName, triggerTotemPattern, triggerTotemOperator)
  if not totemName or totemName == "" then
    return false
  end

  if triggerTotemName and #triggerTotemName > 0 and triggerTotemName ~= totemName then
    return false
  end

  if triggerTotemPattern and #triggerTotemPattern > 0 then
    if triggerTotemOperator == "==" then
      if totemName ~= triggerTotemPattern then
        return false
      end
    elseif triggerTotemOperator == "find('%s')" then
      if not totemName:find(triggerTotemPattern, 1, true) then
        return false
      end
    elseif triggerTotemOperator == "match('%s')" then
      if not totemName:match(triggerTotemPattern) then
        return false
      end
    end
  end

  return true
end

function Private.ExecEnv.CheckTotemIcon(totemIcon, triggerTotemIcon, operator)
  if not triggerTotemIcon then
    return true
  end
  return (totemIcon == triggerTotemIcon) == (operator == "==")
end

function Private.ExecEnv.CheckTotemSpellId(spellId, triggerSpellId, followoverride)
  if not triggerSpellId then
    return true
  end

  if spellId == triggerSpellId then
    return true
  end

  if followoverride then
    if spellId == FindSpellOverrideByID(triggerSpellId) then
      return true
    end
  end

  return false
end

-- Queueable Spells
if WeakAuras.IsClassicEra() then
  local queueableSpells
  local classQueueableSpells = {
    ["WARRIOR"] = {
      78,    -- Heroic Strike
      845,   -- Cleave
    },
    ["HUNTER"] = {
      2973,  -- Raptor Strike
    },
    ["DRUID"] = {
      6807,  -- Maul
    },
    ["DEATHKNIGHT"] = {
      56815, -- Rune Strike
    },
  }
  local class = select(2, UnitClass("player"))
  queueableSpells = classQueueableSpells[class]

  local queuedSpellFrame
  function WeakAuras.WatchForQueuedSpell()
    if not queuedSpellFrame then
      queuedSpellFrame = CreateFrame("Frame")
      Private.frames["Queued Spell Handler"] = queuedSpellFrame
      queuedSpellFrame:RegisterEvent("CURRENT_SPELL_CAST_CHANGED")

      queuedSpellFrame:SetScript("OnEvent", function(self, event)
        local newQueuedSpell
        if queueableSpells then
          for _, spellID in ipairs(queueableSpells) do
            -- Check the highest known rank
            local maxRank = select(7, Private.ExecEnv.GetSpellInfo(Private.ExecEnv.GetSpellName(spellID)))
            if IsCurrentSpell(maxRank) then
              newQueuedSpell = maxRank
              break
            end
          end
        end
        if newQueuedSpell ~= self.queuedSpell then
          self.queuedSpell = newQueuedSpell
          Private.ScanEvents("WA_UNIT_QUEUED_SPELL_CHANGED", "player")
        end
      end)
    end
  end

  ---@return integer? spellID
  function WeakAuras.GetQueuedSpell()
    return queuedSpellFrame and queuedSpellFrame.queuedSpell
  end
end

local GetSpellPowerCost = GetSpellPowerCost or C_Spell and C_Spell.GetSpellPowerCost

---@param powerTypeToCheck integer
---@return number? cost
function WeakAuras.GetSpellCost(powerTypeToCheck)
  local spellID = select(9, WeakAuras.UnitCastingInfo("player"))
  if WeakAuras.IsClassicEra() and not spellID then
    spellID = WeakAuras.GetQueuedSpell()
  end
  if spellID then
    local costTable = GetSpellPowerCost(spellID);
    if costTable then
      for _, costInfo in pairs(costTable) do
        -- When there is no required aura for a power cost, the API returns an aura ID of 0 and false for hasRequiredAura despite being valid.
        if costInfo.type == powerTypeToCheck and (costInfo.requiredAuraID == 0 or costInfo.hasRequiredAura) then
          return costInfo.cost;
        end
      end
    end
  end
end

-- Weapon Enchants
do
  local isCata = WeakAuras.IsCataClassic()

  local mh = GetInventorySlotInfo("MainHandSlot")
  local oh = GetInventorySlotInfo("SecondaryHandSlot")

  local mh_name, mh_shortenedName, mh_exp, mh_dur, mh_charges, mh_EnchantID;
  ---@type string?
  local mh_icon = GetInventoryItemTexture("player", mh) or "Interface\\Icons\\INV_Misc_QuestionMark"

  local oh_name, oh_shortenedName, oh_exp, oh_dur, oh_charges, oh_EnchantID;
  ---@type string?
  local oh_icon = GetInventoryItemTexture("player", oh) or "Interface\\Icons\\INV_Misc_QuestionMark"

  local rw, rw_icon, rw_exp, rw_dur, rw_name, rw_shortenedName, rw_charges, rw_EnchantID;
  ---@type string?
  if isCata then
    rw = GetInventorySlotInfo("RANGEDSLOT")
    rw_icon = GetInventoryItemTexture("player", rw) or "Interface\\Icons\\INV_Misc_QuestionMark"
  end

  local tenchFrame = nil
  Private.frames["Temporary Enchant Handler"] = tenchFrame;
  local tenchTip;

  ---@private
  function WeakAuras.TenchInit()
    if not(tenchFrame) then
      tenchFrame = CreateFrame("Frame");
      tenchFrame:RegisterEvent("PLAYER_ENTERING_WORLD");
      if WeakAuras.IsRetail() then
        tenchFrame:RegisterEvent("WEAPON_ENCHANT_CHANGED")
      end
      tenchFrame:RegisterUnitEvent("UNIT_INVENTORY_CHANGED", "player")
      if WeakAuras.IsClassicEra() then
        tenchFrame:RegisterEvent("PLAYER_EQUIPMENT_CHANGED");
      end

      local getTenchName
      if WeakAuras.IsRetail() then
        getTenchName = function(id)
          local tooltipData = C_TooltipInfo.GetInventoryItem("player", id)
          if tooltipData and tooltipData.lines then
            for _, line in ipairs(tooltipData.lines) do
              if line.leftText then
                -- Format based on ITEM_ENCHANT_TIME_LEFT_MIN, ITEM_ENCHANT_TIME_LEFT_SEC
                local _, _, name, shortenedName = line.leftText:find("^((.-) ?+?[VI%d]*) ?%(%d+%D.+%)$");
                if(name and name ~= "") then
                  return name, shortenedName;
                end
                _, _, name, shortenedName = line.leftText:find("^((.-) ?+?[VI%d]*)%%d+%D.+%$");
                if(name and name ~= "") then
                  return name, shortenedName;
                end
              end
            end
          end
        end
      else
        getTenchName = function(id)
          tenchTip = WeakAuras.GetHiddenTooltip();
          tenchTip:SetInventoryItem("player", id);
          local lines = { tenchTip:GetRegions() };
          for i,v in ipairs(lines) do
            if(v:GetObjectType() == "FontString") then
              local text = v:GetText();
              if(text) then
                local _, _, name, shortenedName = text:find("^((.-) ?+?[VI%d]*) ?%(%d+%D+%)$");
                if(name and name ~= "") then
                  return name, shortenedName;
                end
                _, _, name, shortenedName = text:find("^((.-) ?+?[VI%d]*)%%d+.%D%$");
                if(name and name ~= "") then
                  return name, shortenedName;
                end
              end
            end
          end

          return "Unknown", "Unknown";
        end
      end

      local function tenchUpdate()
        Private.StartProfileSystem("generictrigger temporary enchant");
        local _, mh_rem, oh_rem, rw_rem
        _, mh_rem, mh_charges, mh_EnchantID, _, oh_rem, oh_charges, oh_EnchantID, _, rw_rem, rw_charges, rw_EnchantID = GetWeaponEnchantInfo();
        local time = GetTime();
        local mh_exp_new = mh_rem and (time + (mh_rem / 1000));
        local oh_exp_new = oh_rem and (time + (oh_rem / 1000));
        local rw_exp_new = rw_rem and (time + (rw_rem / 1000));
        if(math.abs((mh_exp or 0) - (mh_exp_new or 0)) > 1) then
          mh_exp = mh_exp_new;
          mh_dur = mh_rem and mh_rem / 1000;
          if mh_exp then
            mh_name, mh_shortenedName = getTenchName(mh)
          else
            mh_name, mh_shortenedName = "None", "None"
          end
          mh_icon = GetInventoryItemTexture("player", mh)
        end
        if(math.abs((oh_exp or 0) - (oh_exp_new or 0)) > 1) then
          oh_exp = oh_exp_new;
          oh_dur = oh_rem and oh_rem / 1000;
          if oh_exp then
            oh_name, oh_shortenedName = getTenchName(oh)
          else
            oh_name, oh_shortenedName = "None", "None"
          end
          oh_icon = GetInventoryItemTexture("player", oh)
        end
        if isCata then
          if(math.abs((rw_exp or 0) - (rw_exp_new or 0)) > 1) then
            rw_exp = rw_exp_new;
            rw_dur = rw_rem and rw_rem / 1000;
            if rw_exp then
              rw_name, rw_shortenedName = getTenchName(rw)
            else
              rw_name, rw_shortenedName = "None", "None"
            end
            rw_icon = GetInventoryItemTexture("player", rw)
          end
        end
        Private.ScanEvents("TENCH_UPDATE");
        Private.StopProfileSystem("generictrigger temporary enchant");
      end

      tenchFrame:SetScript("OnEvent", function()
        Private.StartProfileSystem("generictrigger temporary enchant");
        timer:ScheduleTimer(tenchUpdate, 0.1)
        Private.StopProfileSystem("generictrigger temporary enchant");
      end);

      tenchUpdate();
    end
  end

  function WeakAuras.GetMHTenchInfo()
    return mh_exp, mh_dur, mh_name, mh_shortenedName, mh_icon, mh_charges, mh_EnchantID;
  end

  function WeakAuras.GetOHTenchInfo()
    return oh_exp, oh_dur, oh_name, oh_shortenedName, oh_icon, oh_charges, oh_EnchantID;
  end

  function WeakAuras.GetRangeTenchInfo()
    return rw_exp, rw_dur, rw_name, rw_shortenedName, rw_icon, rw_charges, rw_EnchantID;
  end
end

-- Pets
do
  local petFrame = nil
  Private.frames["Pet Use Handler"] = petFrame;
  ---@private
  function WeakAuras.WatchForPetDeath()
    if not(petFrame) then
      petFrame = CreateFrame("Frame");
      petFrame:RegisterUnitEvent("UNIT_PET", "player")
      petFrame:SetScript("OnEvent", function(event, unit)
        Private.StartProfileSystem("generictrigger pet update")
        Private.ScanEvents("PET_UPDATE", "pet")
        Private.StopProfileSystem("generictrigger pet update")
      end)
    end
  end
end

do
  local watchFrame
  function Private.WatchCOMBO_TARGET_CHANGED()
    if not watchFrame then
      watchFrame = CreateFrame("Frame")
      watchFrame:RegisterEvent("COMBO_TARGET_CHANGED")
      watchFrame:SetScript("OnEvent", function()
        Private.StartProfileSystem("generictrigger COMBO_TARGET_CHANGED")
        Private.ScanEvents("WA_COMBO_TARGET_CHANGED", "player")
        Private.StopProfileSystem("generictrigger COMBO_TARGET_CHANGED")
      end)
    end
  end
end

-- Cast Latency
do
  local castLatencyFrame

  ---@private
  function WeakAuras.WatchForCastLatency()
    if not castLatencyFrame then
      ---@class CastLatencyFrame: FrameScriptObject
      castLatencyFrame = CreateFrame("Frame")
      Private.frames["Cast Latency Handler"] = castLatencyFrame
      castLatencyFrame:RegisterEvent("CURRENT_SPELL_CAST_CHANGED")
      castLatencyFrame:RegisterUnitEvent("UNIT_SPELLCAST_START", "player")
      castLatencyFrame:RegisterUnitEvent("UNIT_SPELLCAST_CHANNEL_START", "player")
      castLatencyFrame:RegisterUnitEvent("UNIT_SPELLCAST_STOP", "player")
      castLatencyFrame:RegisterUnitEvent("UNIT_SPELLCAST_CHANNEL_STOP", "player")
      castLatencyFrame:RegisterUnitEvent("UNIT_SPELLCAST_INTERRUPTED", "player")
      castLatencyFrame:RegisterUnitEvent("UNIT_SPELLCAST_SUCCEEDED", "player")

      -- on dragonflight UNIT_SPELLCAST_EMPOWER_START and UNIT_SPELLCAST_EMPOWER_STOP OnEvent are
      -- triggered from cacheEmpoweredFrame after updating cache use by WeakAuras.UnitChannelInfo

      castLatencyFrame:SetScript("OnEvent", function(self, event, ...)
        if event == "CURRENT_SPELL_CAST_CHANGED" then
          castLatencyFrame.sendTime = GetTime()
          return
        end
        if event == "UNIT_SPELLCAST_SUCCEEDED" or event == "UNIT_SPELLCAST_STOP" or event == "UNIT_SPELLCAST_CHANNEL_STOP" or event == "UNIT_SPELLCAST_INTERRUPTED" then
          castLatencyFrame.sendTime = nil
          return
        end

        if castLatencyFrame.sendTime then
          castLatencyFrame.timeDiff = (GetTime() - castLatencyFrame.sendTime)
        else
          castLatencyFrame.timeDiff = nil
        end
      end)
    end
  end

  ---@return number castLatencyF
  function WeakAuras.GetCastLatency()
    return castLatencyFrame and castLatencyFrame.timeDiff or 0
  end

end

do
  local nameplateTargetFrame = nil
  local nameplateTargets = {}

  local function nameplateTargetOnEvent(self, event, unit)
    if event == "NAME_PLATE_UNIT_ADDED" then
      nameplateTargets[unit] = UnitGUID(unit.."-target") or true
    elseif event == "NAME_PLATE_UNIT_REMOVED" then
      nameplateTargets[unit] = nil
    end
  end

  local tick_throttle = 0.2
  local throttle_update = tick_throttle
  local function nameplateTargetOnUpdate(self, delta)
    throttle_update = throttle_update - delta
    if throttle_update < 0 then
      for unit, targetGUID in pairs(nameplateTargets) do
        local newTargetGUID = UnitGUID(unit.."-target")
        if (newTargetGUID == nil and targetGUID ~= true)
        or (newTargetGUID ~= nil and targetGUID ~= newTargetGUID)
        then
          nameplateTargets[unit] = newTargetGUID or true
          Private.ScanEvents("WA_UNIT_TARGET_NAME_PLATE", unit)
        end
      end
      throttle_update = tick_throttle
    end
  end

  Private.frames["Nameplate Target Handler"] = nameplateTargetFrame
  ---@private
  function WeakAuras.WatchForNameplateTargetChange()
    if not nameplateTargetFrame then
      nameplateTargetFrame = CreateFrame("Frame")
      nameplateTargetFrame:SetScript("OnUpdate", nameplateTargetOnUpdate)
      nameplateTargetFrame:RegisterEvent("NAME_PLATE_UNIT_ADDED")
      nameplateTargetFrame:RegisterEvent("NAME_PLATE_UNIT_REMOVED")
      nameplateTargetFrame:SetScript("OnEvent", nameplateTargetOnEvent)
    end
  end
end

-- Player Moving
do
  --- @class PlayerMovingFrame
  --- @field moving integer|nil
  --- @field speed integer|nil

  ---@type PlayerMovingFrame|Frame|nil
  local playerMovingFrame = nil

  local function PlayerMoveUpdate()
    Private.StartProfileSystem("generictrigger player moving");
    local moving = IsPlayerMoving()
    if (playerMovingFrame.moving ~= moving or playerMovingFrame.moving == nil) then
      playerMovingFrame.moving = moving
      Private.ScanEvents("PLAYER_MOVING_UPDATE")
    end

    local speed = GetUnitSpeed("player")
    if playerMovingFrame.speed ~= speed then
      playerMovingFrame.speed = speed
      Private.ScanEvents("PLAYER_MOVE_SPEED_UPDATE")
    end
    Private.StopProfileSystem("generictrigger player moving");
  end

  ---@private
  function WeakAuras.WatchForPlayerMoving()
    if not(playerMovingFrame) then
      playerMovingFrame = CreateFrame("Frame");
      --- @cast playerMovingFrame PlayerMovingFrame
      Private.frames["Player Moving Frame"] =  playerMovingFrame;
      playerMovingFrame.speed = GetUnitSpeed("player")
    end
    playerMovingFrame:SetScript("OnUpdate", PlayerMoveUpdate)
  end
end

-- combat assist next cast
if C_AssistedCombat and C_AssistedCombat.GetNextCastSpell then
  local assistedCombatFrame

  local function assistedCombatUpdate(self, elapsed)
    Private.StartProfileSystem("generictrigger assisted combat next cast")
    local nextCastSpell = C_AssistedCombat.GetNextCastSpell()
    if nextCastSpell ~= assistedCombatFrame.lastSpell then
      assistedCombatFrame.lastSpell = nextCastSpell
      Private.ScanEvents("WA_ASSISTED_COMBAT_NEXT_CAST", nextCastSpell)
    end
    Private.StopProfileSystem("generictrigger assisted combat next cast")
  end

  ---@private
  function WeakAuras.WatchForAssistedCombatNextCast()
    if not assistedCombatFrame then
      assistedCombatFrame = CreateFrame("Frame")
      Private.frames["Assisted Combat Next Cast Frame"] = assistedCombatFrame
      assistedCombatFrame.lastSpell = C_AssistedCombat.GetNextCastSpell()
    end
    assistedCombatFrame:SetScript("OnUpdate", assistedCombatUpdate)
  end
end

-- Item Count
local itemCountWatchFrame
---@private
function WeakAuras.RegisterItemCountWatch()
  if not itemCountWatchFrame then
    itemCountWatchFrame = CreateFrame("Frame")
    itemCountWatchFrame:RegisterEvent("ACTIONBAR_UPDATE_COOLDOWN")
    itemCountWatchFrame:RegisterEvent("BAG_UPDATE_DELAYED")
    local batchUpdateCount = function()
      itemCountWatchFrame:SetScript("OnUpdate", nil)
      Private.StartProfileSystem("generictrigger ITEM_COUNT_UPDATE")
      Private.ScanEvents("ITEM_COUNT_UPDATE")
      Private.StopProfileSystem("generictrigger ITEM_COUNT_UPDATE")
    end
    itemCountWatchFrame:SetScript("OnEvent", function(self, event)
      Private.StartProfileSystem("generictrigger itemCountFrame")
      if event == "ACTIONBAR_UPDATE_COOLDOWN" then
        -- WORKAROUND: Blizzard bug: refreshing healthstones from soulwell don't trigger BAG_UPDATE_DELAYED
        -- so, we fake it by listening to A_U_C and checking on next frame
        itemCountWatchFrame:SetScript("OnUpdate", batchUpdateCount)
      else
        -- if we *do* get a B_U_D, then cancel our fake one
        -- item count prototype already subscribes to this event so no need to also send an internal event
        itemCountWatchFrame:SetScript("OnUpdate", nil)
      end
      Private.StopProfileSystem("generictrigger itemCountFrame")
    end)
  end
end

-- LibSpecWrapper
-- We always register, because it's probably not that often called, and ScanEvents checks
-- early if anyone wants the event
if WeakAuras.IsCataOrMistsOrRetail() then
  Private.LibSpecWrapper.Register(function(unit)
    Private.ScanEvents("UNIT_SPEC_CHANGED_" .. unit, unit)
  end)
end

do
  local scheduled_scans = {};

  local function doScan(fireTime, event)
    scheduled_scans[event][fireTime] = nil;
    Private.ScanEvents(event);
  end
  function Private.ExecEnv.ScheduleScan(fireTime, event)
    event = event or "COOLDOWN_REMAINING_CHECK"
    scheduled_scans[event] = scheduled_scans[event] or {}
    if not(scheduled_scans[event][fireTime]) then
      scheduled_scans[event][fireTime] = timer:ScheduleTimerFixed(doScan, fireTime - GetTime() + 0.1, fireTime, event);
    end
  end
end

do
  local scheduled_scans = {};

  local function doCastScan(firetime, unit)
    scheduled_scans[unit][firetime] = nil;
    Private.ScanEvents("CAST_REMAINING_CHECK_" .. string.lower(unit), unit);
  end
  function Private.ExecEnv.ScheduleCastCheck(fireTime, unit)
    scheduled_scans[unit] = scheduled_scans[unit] or {}
    if not(scheduled_scans[unit][fireTime]) then
      scheduled_scans[unit][fireTime] = timer:ScheduleTimerFixed(doCastScan, fireTime - GetTime() + 0.1, fireTime, unit);
    end
  end
end

local uniqueId = 0;
---@return integer cloneId
function WeakAuras.GetUniqueCloneId()
  uniqueId = (uniqueId + 1) % 1000000;
  return uniqueId;
end

---@type fun(trigger: triggerData) : prototypeData?
function GenericTrigger.GetPrototype(trigger)
  if trigger.type and trigger.event then
    if Private.category_event_prototype[trigger.type] then
      return Private.event_prototypes[trigger.event]
    end
  end
end

---@type fun(data: auraData): number?
function GenericTrigger.GetDelay(data)
  if data.event then
    local prototype = GenericTrigger.GetPrototype(data.trigger)
    if prototype and prototype.delayEvents then
      local trigger = data.trigger
      if trigger.use_delay and type(trigger.delay) == "number" and trigger.delay > 0 then
        return trigger.delay
      end
    end
  end
  return 0
end

function GenericTrigger.GetTsuConditionVariables(id, triggernum)
  local ok, variables = xpcall(events[id][triggernum].tsuConditionVariables, Private.GetErrorHandlerId(id, L["Custom Variables"]));
  if ok then
    return variables
  end
end

---Returns a table containing the names of all overlays
---@param data auraData
---@param triggernum number
function GenericTrigger.GetOverlayInfo(data, triggernum)
  local result;

  local trigger = data.triggers[triggernum].trigger

  local prototype = GenericTrigger.GetPrototype(trigger)
  if (prototype and prototype.overlayFuncs) then
    result = {};
    local dest = 1;
    for i, v in ipairs(prototype.overlayFuncs) do
      local enable = true
      if type(v.enable) == "function" then
        enable = v.enable(trigger)
      elseif type(v.enable) == "boolean" then
        enable = v.enable
      end
      if enable then
        result[dest] = v.name;
        dest = dest + 1;
      end
    end
  end

  if (trigger.type == "custom") then
    if (trigger.custom_type == "stateupdate") then
      local count = 0;
      local variables = GenericTrigger.GetTsuConditionVariables(data.id, triggernum)
      if (type(variables) == "table") then
        if (type(variables.additionalProgress) == "table") then
          count = #variables.additionalProgress;
        elseif (type(variables.additionalProgress) == "number") then
          count = variables.additionalProgress;
        end
      else
        local allStates = setmetatable({}, Private.allstatesMetatable)
        Private.ActivateAuraEnvironment(data.id);
        RunTriggerFunc(allStates, events[data.id][triggernum], data.id, triggernum, "OPTIONS");
        Private.ActivateAuraEnvironment(nil);
        local count = 0;
        for id, state in pairs(allStates) do
          if (type(state.additionalProgress) == "table") then
            count = max(count, #state.additionalProgress);
          end
        end
      end

      count = min(count, 7);
      for i = 1, count do
        result = result or {};
        result[i] = string.format(L["Overlay %s"], i);
      end
    else
      for i = 1, 7 do
        local property = "customOverlay" .. i;
        if (trigger[property] and trigger[property] ~= "") then
          result = result or {};
          result[i] = string.format(L["Overlay %s"], i);
        end
      end
    end
  end

  return result;
end

---@type fun(data: auraData, triggernum: number): string?, string?
function GenericTrigger.GetNameAndIcon(data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  local icon, name
  local prototype = GenericTrigger.GetPrototype(trigger)
  if prototype then
    if prototype.GetNameAndIcon then
      return prototype.GetNameAndIcon(trigger)
    else
      if prototype.iconFunc then
        icon = prototype.iconFunc(trigger)
      end
      if prototype.nameFunc then
        name = prototype.nameFunc(trigger)
      end
    end
  end

  return name, icon
end

---Returns the type of tooltip to show for the trigger.
---@param data auraData
---@param triggernum number
---@return boolean|string
function GenericTrigger.CanHaveTooltip(data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  local prototype = GenericTrigger.GetPrototype(trigger)
  if prototype then
    if prototype.hasSpellID then
      return "spell";
    elseif prototype.hasItemID then
      return "item";
    end
  end

  if (trigger.type == "custom") then
    if (trigger.custom_type == "stateupdate") then
      return true;
    end
  end

  return false;
end

function GenericTrigger.SetToolTip(trigger, state)
  if (trigger.type == "custom" and trigger.custom_type == "stateupdate") then
    if (state.tooltip) then
      local lines = { strsplit("\n", state.tooltip) };
      GameTooltip:ClearLines();
      for i, line in ipairs(lines) do
        GameTooltip:AddLine(line, nil, nil, nil, state.tooltipWrap);
      end
      return true
    elseif (state.spellId) then
      GameTooltip:SetSpellByID(state.spellId);
      return true
    elseif (state.link) then
      GameTooltip:SetHyperlink(state.link);
      return true
    elseif (state.itemId) then
      GameTooltip:SetHyperlink("item:"..state.itemId..":0:0:0:0:0:0:0");
      return true
    elseif (state.unit and state.unitBuffIndex) then
      GameTooltip:SetUnitBuff(state.unit, state.unitBuffIndex, state.unitBuffFilter);
      return true
    elseif (state.unit and state.unitDebuffIndex) then
      GameTooltip:SetUnitDebuff(state.unit, state.unitDebuffIndex, state.unitDebuffFilter);
      return true
    elseif (state.unit and state.unitAuraIndex) then
      GameTooltip:SetUnitAura(state.unit, state.unitAuraIndex, state.unitAuraFilter)
      return true
    elseif (state.unit and state.unitAuraInstanceID and state.unitAuraFilter) then
      if state.unitAuraFilter == "HELPFUL" then
        GameTooltip:SetUnitBuffByAuraInstanceID(state.unit, state.unitAuraInstanceID, state.unitAuraFilter)
        return true
      elseif state.unitAuraFilter == "HARMFUL" then
        GameTooltip:SetUnitDebuffByAuraInstanceID(state.unit, state.unitAuraInstanceID, state.unitAuraFilter)
        return true
      end
    end
  end

  local prototype = GenericTrigger.GetPrototype(trigger)
  if prototype then
    if prototype.hasSpellID then
      GameTooltip:SetSpellByID(trigger.spellName or 0);
      return true
    elseif prototype.hasItemID then
      GameTooltip:SetHyperlink("item:"..(trigger.itemName or 0)..":0:0:0:0:0:0:0")
      return true
    end
  end
  return false
end

---@type fun(data: auraData, triggernum: number): table
function GenericTrigger.GetAdditionalProperties(data, triggernum)
  local trigger = data.triggers[triggernum].trigger
  local props = {}
  local prototype = GenericTrigger.GetPrototype(trigger)
  if prototype then
    for _, v in pairs(prototype.args) do
      local enable = true
      if(type(v.enable) == "function") then
        enable = v.enable(trigger)
      elseif type(v.enable) == "boolean" then
        enable = v.enable
      end
      if (enable and v.store and v.name and v.display and v.conditionType ~= "bool") then
        local formatter = v.formatter
        local formatterArgs = v.formatterArgs or {}
        if not formatter then
          if v.type == "unit" then
            formatter = "Unit"
            formatterArgs = { color = "class" }
          elseif v.type == "string" then
            formatter = "string"
          end
        end
        props[v.name] = { display = v.display, formatter = formatter, formatterArgs = formatterArgs }
      end
    end
    if prototype.countEvents then
      props.count = L["Count"]
    end
  else
    if (trigger.custom_type == "stateupdate") then
      local variables = GenericTrigger.GetTsuConditionVariables(data.id, triggernum)
      if (type(variables) == "table") then
        for var, varData in pairs(variables) do
          if (type(varData) == "table") then
            props[var] = { display = varData.display or var, formatter = varData.formatter, formatterArgs = varData.formatterArgs }
          end
        end
      end
    end
  end
  return props;
end

function GenericTrigger.GetProgressSources(data, triggernum, values)
  local variables = GenericTrigger.GetTriggerConditions(data, triggernum)
  if (type(variables) == "table") then
    for var, varData in pairs(variables) do
      if (type(varData) == "table") then
        if (varData.type == "number" or varData.type == "timer" or varData.type == "elapsedTimer")
           and not varData.noProgressSource
        then
          local modRateProperty = varData.modRate
          if not modRateProperty and varData.useModRate then
            modRateProperty = "modRate"
          end

          tinsert(values, {
            trigger = triggernum,
            property = var,
            type = varData.type,
            display = varData.display,
            total = varData.total,
            modRate = varData.modRate,
            inverse = varData.inverse,
            paused = varData.paused,
            remaining = varData.remaining
          })
        end
      end
    end
  end
end

local commonConditions = {
  expirationTime = {
    display = L["Remaining Duration"],
    type = "timer",
    total = "duration",
    inverse = "inverse",
    paused = "paused",
    remaining = "remaining",
  },
  expirationTimeModRate = {
    display = L["Remaining Duration"],
    type = "timer",
    total = "duration",
    modRate = "modRate",
    inverse = "inverse",
    paused = "paused",
    remaining = "remaining",
    useModRate = true
  },
  duration = {
    display = L["Total Duration"],
    type = "number",
    formatter = "Number",
  },
  durationModRate = {
    display = L["Total Duration"],
    type = "number",
    formatter = "Number",
    useModRate = true
  },
  paused = {
    display =L["Is Paused"],
    type = "bool",
    test = function(state, needle)
      return (state.paused and 1 or 0) == needle
    end
  },
  value = {
    display = L["Progress Value"],
    type = "number",
    total = "total"
  },
  total = {
    display = L["Progress Total"],
    type = "number",
  },
  stacks = {
    display = L["Stacks"],
    type = "number",
    formatter = "Number",
  },
  name = {
    display = L["Name"],
    type = "string"
  },
  itemInRange = {
    display = WeakAuras.newFeatureString .. L["Item in Range"],
    hidden = true,
    type = "bool",
    test = function(state, needle)
      if not state or not state.itemId or not state.show or not UnitExists('target') then
        return false
      end
      if InCombatLockdown() and not UnitCanAttack('player', 'target') then
        return false
      end
      return C_Item.IsItemInRange(state.itemId, 'target') == (needle == 1)
    end,
    events = Private.AddTargetConditionEvents({
      "WA_SPELL_RANGECHECK",
    })
  },
}

---@type fun(variables: table)
function Private.ExpandCustomVariables(variables)
  -- Make the life of tsu authors easier, by automatically filling in the details for
  -- expirationTime, duration, value, total, stacks, if those exists but aren't a table value
  -- By allowing a short-hand notation of just variable = type
  -- In addition to the long form of variable = { type = xyz, display = "desc"}
  for k, v in pairs(commonConditions) do
    if (variables[k] and type(variables[k]) ~= "table") then
      variables[k] = v;
    end
  end

  for k, v in pairs(variables) do
    if (type(v) == "string") then
      variables[k] = {
        display = k,
        type = v,
      };
    end
  end
end

function Private.GetTsuConditionVariablesExpanded(id, triggernum)
  if events[id][triggernum] and events[id][triggernum].tsuConditionVariables then
    Private.ActivateAuraEnvironment(id, nil, nil, nil, true)
    local result = GenericTrigger.GetTsuConditionVariables(id, triggernum)
    Private.ActivateAuraEnvironment(nil)
    if type(result) ~= "table" then
      return nil
    end
    Private.ExpandCustomVariables(result)
    -- Clean up, remove non table entries and check for a valid display name
    for k, v in pairs(result) do
      if type(v) ~= "table" then
        result[k] = nil
      elseif (v.display == nil or type(v.display) ~= "string") then
        if type(k) == "string" then
          v.display = k
        else
          result[k] = nil
        end
      end
    end

    return result
  end
end

function GenericTrigger.GetTriggerConditions(data, triggernum)
  local trigger = data.triggers[triggernum].trigger

  local prototype = GenericTrigger.GetPrototype(trigger)
  if prototype then
    local result = {};

    local progressType, modRated = ProgressType(data, triggernum);
    if progressType == "timed" then
      if modRated then
        result.expirationTime = commonConditions.expirationTimeModRate;
        result.duration = commonConditions.durationModRate;
      else
        result.expirationTime = commonConditions.expirationTime;
        result.duration = commonConditions.duration;
      end
      result.paused = commonConditions.paused
    end

    if progressType == "static" then
      result.value = commonConditions.value;
      result.total = commonConditions.total;
    end

    if prototype.stacksFunc then
      result.stacks = commonConditions.stacks;
    end

    if prototype.nameFunc then
      result.name = commonConditions.name;
    end

    if prototype.hasItemID then
      result.itemInRange = commonConditions.itemInRange
    end

    for _, v in pairs(prototype.args) do
      if (v.conditionType and v.name and v.display) then
        local enable = true;
        if (v.enable ~= nil) then
          if type(v.enable) == "function" then
            enable = v.enable(trigger);
          elseif type(v.enable) == "boolean" then
            enable = v.enable
          end
        end

        if (enable) then
          result[v.name] = {
            display = v.display,
            type = v.conditionType,
          }
          if (result[v.name].type == "select" or result[v.name].type == "unit") then
            if (v.conditionValues) then
              result[v.name].values = Private[v.conditionValues] or WeakAuras[v.conditionValues];
            else
              if type(v.values) == "function" then
                result[v.name].values = v.values()
              else
                result[v.name].values = Private[v.values] or WeakAuras[v.values];
              end
            end
          end
          if (v.conditionPreamble) then
            result[v.name].preamble = v.conditionPreamble;
          end
          if (v.conditionTest) then
            result[v.name].test = v.conditionTest;
          end
          if (v.conditionEvents) then
            result[v.name].events = v.conditionEvents;
          end
          if (v.operator_types) then
            result[v.name].operator_types = v.operator_types;
          end
          -- for ProgressSource
          if v.noProgressSource then
            result[v.name].noProgressSource = true
          end
          if v.progressTotal then
            result[v.name].total = v.progressTotal
          end
          if v.progressModRate then
            result[v.name].modRate = v.progressModRate
          end
          if v.progressInverse then
            result[v.name].inverse = v.progressInverse
          end
          if v.progressPaused then
            result[v.name].paused = v.progressPaused
          end
          if v.progressRemaining then
            result[v.name].remaining = v.progressRemaining
          end
        end
      end
    end

    if prototype.countEvents then
      result.count = {
        display = L["Count"],
        type = "number"
      }
    end

    return result;
  elseif(trigger.type == "custom") then
    if (trigger.custom_type == "status" or trigger.custom_type == "event") then
      local result = {};

      local canHaveDurationFunc = trigger.custom_type == "status" or (trigger.custom_type == "event" and (trigger.custom_hide ~= "timed" or trigger.dynamicDuration));

      if (canHaveDurationFunc and trigger.customDuration and trigger.customDuration ~= "") then
        result.expirationTime = commonConditions.expirationTime;
        result.duration = commonConditions.duration;
        result.value = commonConditions.value;
        result.total = commonConditions.total;
      end

      if (trigger.custom_type == "event" and trigger.custom_hide ~= "custom" and trigger.dynamicDuration ~= true) then
        -- This is the static duration of a event/timed trigger
        result.expirationTime = commonConditions.expirationTime;
        result.duration = commonConditions.duration;
      end

      if (trigger.customStacks and trigger.customStacks ~= "") then
        result.stacks = commonConditions.stacks;
      end

      if (trigger.customName and trigger.customName ~= "") then
        result.name = commonConditions.name;
      end

      return result;
    elseif (trigger.custom_type == "stateupdate") then
      return Private.GetTsuConditionVariablesExpanded(data.id, triggernum)
    end
  end

  return nil;
end

function GenericTrigger.CreateFallbackState(data, triggernum, state)
  state.show = true;
  state.changed = true;
  local event = events[data.id][triggernum];

  Private.ActivateAuraEnvironment(data.id, "", state);
  local trigger = data.triggers[triggernum].trigger

  if event.GetNameAndIcon then
    local ok, name, icon = xpcall(event.GetNameAndIcon, Private.GetErrorHandlerUid(data.uid, L["GetNameAndIcon Function (fallback state)"]), trigger);
    state.name = ok and name or nil;
    state.icon = ok and icon or nil;
  else
    if (event.nameFunc) then
      local ok, name = xpcall(event.nameFunc, Private.GetErrorHandlerUid(data.uid, L["Name Function (fallback state)"]), trigger);
      state.name = ok and name or nil;
    end
    if (event.iconFunc) then
      local ok, icon = xpcall(event.iconFunc, Private.GetErrorHandlerUid(data.uid, L["Icon Function (fallback state)"]), trigger);
      state.icon = ok and icon or nil;
    end
  end

  if (event.textureFunc ) then
    local ok, texture = xpcall(event.textureFunc, Private.GetErrorHandlerUid(data.uid, L["Texture Function (fallback state)"]), trigger);
    state.texture = ok and texture or nil;
  end

  if (event.stacksFunc) then
    local ok, stacks = xpcall(event.stacksFunc, Private.GetErrorHandlerUid(data.uid, L["Stacks Function (fallback state)"]), trigger);
    state.stacks = ok and stacks or nil;
  end

  if (event.durationFunc) then
    local ok, arg1, arg2, arg3, inverse = xpcall(event.durationFunc, Private.GetErrorHandlerUid(data.uid, L["Duration Function (fallback state)"]), trigger);
    if (not ok) then
      state.progressType = "timed";
      state.duration = 0;
      state.expirationTime = math.huge;
      state.value = nil;
      state.total = nil;
      Private.ActivateAuraEnvironment(nil)
      return;
    end
    arg1 = type(arg1) == "number" and arg1 or 0;
    arg2 = type(arg2) == "number" and arg2 or 0;

    if(type(arg3) == "string") then
      state.durationFunc = event.durationFunc;
    elseif (type(arg3) == "function") then
      state.durationFunc = arg3;
    else
      state.durationFunc = nil;
    end

    if (arg3) then
      state.progressType = "static";
      state.duration = nil;
      state.expirationTime = nil;
      state.value = arg1;
      state.total = arg2;
      state.inverse = inverse;
    else
      state.progressType = "timed";
      state.duration = arg1;
      state.expirationTime = arg2;
      state.autoHide = nil;
      state.value = nil;
      state.total = nil;
      state.inverse = inverse;
    end
  else
    state.progressType = "timed";
    state.duration = 0;
    state.expirationTime = math.huge;
    state.value = nil;
    state.total = nil;
  end
  if (event.overlayFuncs) then
    RunOverlayFuncs(event, state, data.id);
  end
  Private.ActivateAuraEnvironment(nil);
end

function GenericTrigger.GetName(triggerType)
  return Private.event_categories[triggerType].name
end

function GenericTrigger.GetTriggerDescription(data, triggernum, namestable)
  local trigger = data.triggers[triggernum].trigger
  local prototype = GenericTrigger.GetPrototype(trigger)
  if prototype then
    tinsert(namestable, {L["Trigger:"], (prototype.name or L["Undefined"])});
    if(trigger.event == "Combat Log" and trigger.subeventPrefix and trigger.subeventSuffix) then
      tinsert(namestable, {L["Message type:"], (Private.subevent_prefix_types[trigger.subeventPrefix] or L["Undefined"]).." "..(Private.subevent_suffix_types[trigger.subeventSuffix] or L["Undefined"])});
    end
  else
    tinsert(namestable, {L["Trigger:"], L["Custom"]});
  end
end

do
  -- Based on Code by DejaCharacterStats. Ugly code to figure out the GCD
  local class = select(2, UnitClass("player"))
  if class == "DEMONHUNTER"
    or class == "HUNTER" or class == "SHAMAN"
    or class == "MAGE" or class == "PRIEST" or class == "WARLOCK"
    or class == "DEATHKNIGHT" or class == "PALADIN" or class == "WARRIOR"
    or class == "EVOKER"
  then
    function WeakAuras.CalculatedGcdDuration()
      local haste = GetHaste()
      return max(0.75, 1.5 * 100 / (100+haste))
    end
  elseif class == "DRUID" then
    function WeakAuras.CalculatedGcdDuration()
      local id = GetShapeshiftFormID()
      local haste = GetHaste()
      return id == 1 and 1 or max(0.75, 1.5 * 100 / (100+haste))
    end
  elseif class == "MONK" then
    function WeakAuras.CalculatedGcdDuration()
      local spec = Private.ExecEnv.GetSpecialization()
      local primaryStat = select(6, Private.ExecEnv.GetSpecializationInfo(spec))
      if primaryStat == LE_UNIT_STAT_AGILITY then
        return 1
      end
      local haste = GetHaste()
      return max(0.75, 1.5 * 100 / (100+haste))
    end
  elseif class == "ROGUE" then
    function WeakAuras.CalculatedGcdDuration()
      return 1
    end
  end
end

local findIdInLink = function(id, itemLink, startPos)
  local findID = ":" .. tostring(id:trim())
  return itemLink:find(findID .. ":", startPos, true) or itemLink:find(findID .. "|", startPos, true)
end

---@param ids string
---@return boolean isItemBonusId
WeakAuras.CheckForItemBonusId = function(ids)
  for id in tostring(ids):gmatch('([^,]+)') do
    for slot in pairs(Private.item_slot_types) do
      local itemLink = GetInventoryItemLink('player', slot)
      if itemLink then
        local startPos = itemLink:find(":", 1, true)
        startPos = itemLink:find(":", startPos + 1 , true)
        if findIdInLink(id, itemLink, startPos) then
          return true
        end
      end
    end
  end
  return false
end

---@param ids string
---@param specificSlot? number
---@return string|nil id
---@return string|nil itemID
---@return string|nil itemName
---@return number|nil icon
---@return number|nil slot
---@return number|nil itemSlot
WeakAuras.GetBonusIdInfo = function(ids, specificSlot)
  local checkSlots = specificSlot and {[specificSlot] = true} or Private.item_slot_types
  for id in tostring(ids):gmatch('([^,]+)') do
    for slot in pairs(checkSlots) do
      local itemLink = GetInventoryItemLink('player', slot)
      if itemLink and findIdInLink(id, itemLink, 1) then
        local itemID, _, _, _, icon = C_Item.GetItemInfoInstant(itemLink)
        local itemName = itemLink:match("%[(.*)%]")
        return id, itemID, itemName, icon, slot, Private.item_slot_types[slot]
      end
    end
  end
end

---@param itemId string
---@param specificSlot? number
---@return boolean|nil isItemEquipped
WeakAuras.CheckForItemEquipped = function(itemId, specificSlot)
  if not specificSlot then
    return C_Item.IsEquippedItem(itemId or '')
  else
    local item = Item:CreateFromEquipmentSlot(specificSlot)
    if item and not item:IsItemEmpty() then
      return itemId == item:GetItemID()
    end
  end
end

Private.ExecEnv.GetItemSubClassInfo = function(i)
  local subClassId = i % 256
  local classId = (i - subClassId) / 256
  return C_Item.GetItemSubClassInfo(classId, subClassId)
end

Private.ExecEnv.IsEquippedItemType = function(itemType, itemSlot)
  if itemSlot then
    local itemId = GetInventoryItemID("player", itemSlot)
    if itemId then
      local triggerSubClassId = itemType % 256
      local triggerClassId = (itemType - triggerSubClassId) / 256
      local _, _, _, _, _, classId, subclassId = C_Item.GetItemInfoInstant(itemId)
      return classId == triggerClassId and subclassId == triggerSubClassId
    end
  else
    return C_Item.IsEquippedItemType(Private.ExecEnv.GetItemSubClassInfo(itemType) or '')
  end
end

---@return integer critChance
WeakAuras.GetCritChance = function()
  -- Based on what the wow paper doll does
  local spellCrit = 0
  for i = 2, MAX_SPELL_SCHOOLS or 7 do -- WORKAROUND: MAX_SPELL_SCHOOLS is nil on classic_era
    spellCrit = max(spellCrit, GetSpellCritChance(i))
  end
  return max(spellCrit, GetRangedCritChance(), GetCritChance())
end

---@return number hitChance
WeakAuras.GetHitChance = function()
  local melee = (GetCombatRatingBonus(CR_HIT_MELEE) or 0) + (GetHitModifier() or 0)
  local ranged = (GetCombatRatingBonus(CR_HIT_RANGED) or 0) + (GetHitModifier() or 0)
  local spell = (GetCombatRatingBonus(CR_HIT_SPELL) or 0) + (GetSpellHitModifier() or 0)
  return max(melee, ranged, spell)
end

---@type fun(trigger: triggerData)
---@return CurrencyInfo|nil
Private.GetCurrencyInfoForTrigger = function(trigger)
  if trigger.currencyId then
    local currencyId = tonumber(trigger.currencyId)
    if currencyId then
      return C_CurrencyInfo.GetCurrencyInfo(currencyId)
    end
  end
end

Private.ExecEnv.GetCurrencyAccountInfo = function(currencyId)
  local currencyInfo = C_CurrencyInfo.GetCurrencyInfo(currencyId)

  -- Gather currency data for account characters
  if WeakAuras.IsRetail() and currencyInfo and currencyInfo.isAccountTransferable then
    local dataReady = C_CurrencyInfo.IsAccountCharacterCurrencyDataReady()
    local accountCurrencyData = dataReady and C_CurrencyInfo.FetchCurrencyDataFromAccountCharacters(currencyId)

    if dataReady and accountCurrencyData then
      currencyInfo.accountQuantity = currencyInfo.quantity
      currencyInfo.realAccountQuantity = currencyInfo.quantity
      if currencyInfo.transferPercentage then
        currencyInfo.realCharacterQuantity = math.floor(currencyInfo.quantity * (currencyInfo.transferPercentage / 100))
      end

      currencyInfo.accountCurrencyData = accountCurrencyData
      for _, currencyData in ipairs(currencyInfo.accountCurrencyData) do
        if currencyData.quantity then
          if currencyInfo.transferPercentage then
            currencyData.realCharacterQuantity = math.floor(currencyData.quantity * (currencyInfo.transferPercentage / 100))
          end
          currencyInfo.realAccountQuantity = currencyInfo.realAccountQuantity + (currencyData.realCharacterQuantity or currencyData.quantity)
          currencyInfo.accountQuantity = currencyInfo.accountQuantity + currencyData.quantity
        end
      end
    else
      C_CurrencyInfo.RequestCurrencyDataForAccountCharacters()
    end
  end

  -- WORKAROUND https://github.com/WeakAuras/WeakAuras2/issues/5106
  if currencyInfo and WeakAuras.IsCataClassic() then
    if currencyInfo.quantityEarnedThisWeek then
      currencyInfo.quantityEarnedThisWeek = currencyInfo.quantityEarnedThisWeek / 100
    end
  end

  if currencyInfo then
    currencyInfo.capped = currencyInfo.maxQuantity and currencyInfo.maxQuantity > 0 and currencyInfo.quantity >= currencyInfo.maxQuantity
    currencyInfo.seasonCapped = currencyInfo.maxQuantity and currencyInfo.maxQuantity > 0 and currencyInfo.useTotalEarnedForMaxQty and currencyInfo.totalEarned >= currencyInfo.maxQuantity
    currencyInfo.weeklyCapped = currencyInfo.maxWeeklyQuantity and currencyInfo.maxWeeklyQuantity > 0 and currencyInfo.quantityEarnedThisWeek >= currencyInfo.maxWeeklyQuantity
  end

  if not currencyInfo then
    local testToken = C_CurrencyInfo.GetCurrencyInfo(1) --Currency Token Test Token 4
    if testToken then
      currencyInfo = testToken
      currencyInfo.iconFileID = "Interface\\Icons\\INV_Misc_QuestionMark" --We don't want the user to think their input was valid
    end
  end

  return currencyInfo or {}
end


local types = {}
tinsert(types, "custom")
for type in pairs(Private.category_event_prototype) do
  tinsert(types, type)
end

-- The Options/GenericTrigger.lua needs this table, since at the time
-- of registering the types the options code doesn't yet have access
-- to the Private table.

-- So for now make it simply a member of WeakAuras
WeakAuras.genericTriggerTypes = types

WeakAuras.RegisterTriggerSystem(types, GenericTrigger);


-- ========================================
-- File: WeakAuras/History.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras

local histRepo, migrationRepo
local function loadHistory()
  if not histRepo then
    histRepo = WeakAuras.LoadFromArchive("Repository", "history")
  end
  return histRepo
end

local function loadMigrations()
  if not migrationRepo then
    migrationRepo = WeakAuras.LoadFromArchive("Repository", "migration")
  end
  return migrationRepo
end

function Private.CleanArchive(historyCutoff, migrationCutoff)
  if type(historyCutoff) == "number" then
    local repo = loadHistory()
    local cutoffTime = time() - (historyCutoff * 86400)
    for uid, subStore in pairs(repo.stores) do
      -- Ideally we would just use Clean and not access the stores list directly,
      -- but that'd mean having Clean take a predicate which seems like overkill for the moment
      if not Private.GetDataByUID(uid) and subStore.timestamp < cutoffTime then
        repo:Drop(uid)
      end
    end
  end

  if type(migrationCutoff) == "number" then
    local repo = loadMigrations()
    repo:Clean(time() - (migrationCutoff * 86400))
  end
end

function Private.SetHistory(uid, data, source)
  if uid and data then
    local repo = loadHistory()
    data.source = source
    local hist = repo:Set(uid, data, true)
    return hist
  end
end

local function GetHistory(uid, load)
  return loadHistory():Get(uid, load)
end

function Private.RemoveHistory(uid)
  return loadHistory():Drop(uid)
end

function Private.RestoreFromHistory(uid)
  local _, histData = GetHistory(uid, true)
  if histData then
    WeakAuras.Add(histData)
  end
end

function Private.SetMigrationSnapshot(uid, oldData)
  if type(oldData) == "table" then
    local repo = loadMigrations()
    repo:Set(uid, oldData)
  end
end

function Private.GetMigrationSnapshot(uid)
  return loadMigrations():GetData(uid)
end


-- ========================================
-- File: WeakAuras/Init.lua
-- ========================================

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
WeakAuras = {}
---@type table<string, string>
WeakAuras.L = {}
Private.frames = {}

--- @alias uid string
--- @alias auraId string

--- @class state
--- @field id auraId
--- @field cloneId string?
--- @field show boolean?
--- @field changed boolean?
--- @field paused boolean?
--- @field remaining number?
--- @field autoHide boolean|string|nil
--- @field progressType "timed"|"static"|nil
--- @field expirationTime number?
--- @field duration number?
--- @field name any?
--- @field icon any?
--- @field value number?
--- @field total number?
--- @field inverse boolean?

--- @alias non_transmissable_field table<string, non_transmissable_field|boolean>

--- @class multiUnitUnits
--- @field nameplate table<string, boolean>
--- @field boss table<string, boolean>
--- @field arena table<string, boolean>
--- @field group table<string, boolean>
--- @field party table<string, boolean>
--- @field raid table<string, boolean>

--- @alias traverseFunction fun(): auraData

---@class WARegion : Frame
---@field state state
---@field states state[]
---@field regionType string
---@field FrameTick fun(self: WARegion)?
---@field UpdateValue fun(self: WARegion)?
---@field UpdateTime fun(self: WARegion)?
---@field Update fun(self: WARegion)?

--- @class Private
--- @field ActivateAuraEnvironment fun(id: auraId?, cloneId: string?, state: state?, states: state[]?, config: boolean?)
--- @field ActivateAuraEnvironmentForRegion fun(region: table, onlyConfig: boolean?)
--- @field AddToWatchedTriggerDelay fun(id: auraId, triggerNum: number)
--- @field anchor_frame_types table<anchorFrameTypes, string>
--- @field anchor_frame_types_group table<anchorFrameTypes, string>
--- @field anim_function_strings table<string, string>
--- @field anim_presets table<string, table>
--- @field AuraWarnings AuraWarnings
--- @field AuraEnvironmentWrappedSystem AuraEnvironmentWrappedSystem
--- @field callbacks callbacks
--- @field category_event_prototype table<string, table<string, string>>
--- @field CanHaveTooltip fun(data: auraData): boolean
--- @field CheckTalentsForLoad fun(event: string)
--- @field ContainsCustomPlaceHolder fun(input: string): boolean
--- @field ContainsAnyPlaceHolders fun(input: string): boolean
--- @field ContainsPlaceHolders fun(input: string, placeholders: string, checkDoublePercent?: boolean): boolean
--- @field CreateSubscribableObject fun(): SubscribableObject
--- @field clones table<auraId, table<string, table>>
--- @field customActionsFunctions table<auraId, table<string, function?>>
--- @field DebugLog debugLog
--- @field dynamic_texts table<string, table>
--- @field EndEvent fun(state: state): boolean?
--- @field EnsureRegion fun(id: auraId, cloneId: string?): WARegion
--- @field ExecEnv table
--- @field event_prototypes table<string, prototypeData>
--- @field event_categories table<string, {name: string, default: string }>
--- @field Features Features
--- @field FindUnusedId fun(prefix: string?): string
--- @field FixGroupChildrenOrderForGroup fun(data: auraData)
--- @field frames table<string, table>
--- @field function_strings table<string, string>
--- @field GetDataByUID fun(uid: uid): auraData
--- @field GetErrorHandlerId fun(id: auraId, context: string): function
--- @field GetErrorHandlerUid fun(uid: uid, context: string): function
--- @field GetRegionByUID fun(uid: uid, cloneId: string): Region
--- @field glow_types table<string, string>
--- @field inverse_point_types table<string, string>
--- @field IsCLEUSubevent fun(subevent: string): boolean
--- @field IsDragonriding fun(): boolean
--- @field IsGroupType fun(data: auraData): boolean
--- @field item_slot_types string[]
--- @field LibSpecWrapper LibSpecWrapper
--- @field linked table<auraId, number>
--- @field loaded table<auraId, boolean>
--- @field LoadFunction fun(input: string): function
--- @field LoadOptions fun(msg: string?): boolean
--- @field maxTimerDuration number
--- @field multiUnitUnits multiUnitUnits
--- @field non_transmissable_fields table<string, non_transmissable_field>
--- @field non_transmissable_fields_v2000 table<string, non_transmissable_field>
--- @field orientation_types table<string, string>
--- @field orientation_with_circle_types table<string, string>
--- @field ParseNumber fun (numString: string|number): number?, string?
--- @field PreShowModels fun()
--- @field PrintHelp fun()
--- @field QuotedString fun(input: string): string
--- @field regionOptions table<string, table>
--- @field regions table<auraId, table>
--- @field regionTypes table<string, table>
--- @field reset_ranged_swing_spells table<number, boolean>
--- @field reset_swing_spells table<number, boolean>
--- @field noreset_swing_spells table<number, boolean>
--- @field RunCustomTextFunc fun(region: table, f: function): string?
--- @field spark_rotation_types table<string, string>
--- @field spec_types string[]
--- @field spec_types_3 string[]
--- @field spec_types_2 string[]
--- @field StartProfileAura fun(id: auraId)
--- @field StartProfileSystem fun(system: string)
--- @field StopProfileAura fun(id: auraId)
--- @field StopProfileSystem fun(system: string)
--- @field subRegionOptions table<string, table>
--- @field subRegionTypes table<string, table>
--- @field tick_placement_modes table<string, string>
--- @field tinySecondFormat fun(value: string|number): string?
--- @field TraverseAll fun(data: auraData): traverseFunction, auraData
--- @field TraverseAllChildren fun(data: auraData): traverseFunction, auraData
--- @field TraverseGroups fun(data: auraData): traverseFunction, auraData
--- @field TraverseLeafs fun(data: auraData): traverseFunction, auraData
--- @field TraverseLeafsOrAura fun(data: auraData): traverseFunction, auraData
--- @field TraverseParents fun(data: auraData): traverseFunction, auraData
--- @field TraverseSubGroups fun(data: auraData): traverseFunction, auraData
--- @field triggerTypes table<string, table>
--- @field triggerTypesOptions table<string, any>
--- @field UIDtoID fun(uid: uid): auraId
--- @field UnitEventList table<string, boolean>
--- @field UnitPlayerControlledFixed fun(unit: string): boolean
--- @field UpdatedTriggerState fun(id: auraId)
--- @field validate fun(input: table, default:table)
--- @field watched_trigger_events table<auraId, table<integer, table<integer, boolean>>>
--- @field RegisterRegionType fun(regionType: string, createFunction: function, modifyFunction: function, defaults: table, properties: table|function|nil, validate: function?))

--- @alias triggerTypes
--- | "aura"
--- | "aura2"
--- | "custom"

--- @alias anchorFrameTypes
--- | "SCREEN"
--- | "PRD"
--- | "MOUSE"
--- | "SELECTFRAME"
--- | "NAMEPLATE"
--- | "UNITFRAME"
--- | "CUSTOM"

--- @class triggerData
--- @field buffShowOn string
--- @field debuffType string
--- @field essence number?
--- @field event string|nil
--- @field instance_size table|nil
--- @field itemName string?
--- @field itemSetName string?
--- @field itemTypeName table|nil
--- @field range number?l
--- @field realSpellName string?
--- @field rune number?
--- @field spellName string?
--- @field subeventPrefix string?
--- @field subeventSuffix string?
--- @field type triggerTypes
--- @field unit string?
--- @field use_alwaystrue boolean|nil
--- @field use_ignoreoverride boolean|nil
--- @field use_showOn boolean|nil

---@class prototypeDataArgs
---@field name string
---@field required boolean?
---@field display string
---@field type "unit"|nil
---@field init "string"|nil
---@field values any
---@field desc string?
---@field store boolean?
---@field test string?

---@class prototypeData
---@field durationFunc (fun(trigger: triggerData): number, number, boolean?)|nil
---@field init (fun(trigger: triggerData):string?)|nil
---@field useModRate boolean?
---@field timedrequired boolean?
---@field GetNameAndIcon (fun(trigger: triggerData): string?, string?)|nil
---@field iconFunc (fun(trigger: triggerData): string?)|nil
---@field loadFunc (fun(trigger: triggerData): nil)|nil
---@field nameFunc (fun(trigger: triggerData): string?)|nil
---@field events (fun(trigger: triggerData): table)|nil
---@field internal_events (fun(trigger: triggerData): table)|nil
---@field name string
---@field statesParameter "unit"|"one"|"all"|nil
---@field progressType "timed"|"static"|"none"

--- @class triggerUntriggerData
--- @field trigger triggerData
--- @field untrigger triggerData

--- @class conditionCheck
--- @field variable string
--- @field trigger number
--- @field checks conditionCheck[]|nil

--- @class conditionChanges
--- @field property string

--- @class conditionData
--- @field check conditionCheck
--- @field changes conditionChanges

--- @class subRegionData

--- @class actionData
--- @field do_glow boolean
--- @field do_message boolean
--- @field do_sound boolean
--- @field message string
--- @field message_type string


--- @class actions
--- @field start actionData
--- @field finish actionData

--- @class load
--- @field use_realm boolean
--- @field itemtypeequipped table
--- @field size table

--- @alias regionTypes
--- | "aurabar"
--- | "dynamicgroup"
--- | "fallback"
--- | "group"
--- | "icon"
--- | "model"
--- | "progresstexture"
--- | "stopmotion"
--- | "text"
--- | "texture"

--- @class information
--- @field forceEvents boolean|nil
--- @field ignoreOptionsEventErrors boolean|nil
--- @field groupOffset boolean|nil

--- @alias dynamicGroupCenterType
--- | "LR"
--- | "RL"
--- | "CLR"
--- | "CRL"

--- @alias dynamicGroupGridType
--- | "RU"
--- | "UR"
--- | "LU"
--- | "UL"
--- | "RD"
--- | "DR"
--- | "LD"
--- | "DL"
--- | "HD"
--- | "HU"
--- | "VR"
--- | "VL"
--- | "DH"
--- | "UH"
--- | "LV"
--- | "RV"
--- | "HV"
--- | "VH"

--- @alias dynamicGroupCircularTypes
--- | "RADIUS"
--- | "SPACING"

--- @alias ColorArray {[1]: number, [2]: number, [3]: number, [4]: number }

--- @class auraData
--- @field anchorFrameType anchorFrameTypes?
--- @field animate boolean?
--- @field arcLength number?
--- @field actions actions?
--- @field border boolean?
--- @field borderBackdrop string?
--- @field borderColor ColorArray?
--- @field borderEdge string?
--- @field borderOffset number?
--- @field borderInset number?
--- @field borderSize number?
--- @field centerType dynamicGroupCenterType?
--- @field conditions conditionData[]?
--- @field constantFactor dynamicGroupCircularTypes
--- @field controlledChildren auraId[]?
--- @field displayText string?
--- @field frameStrata number?
--- @field fullCircle boolean?
--- @field gridType dynamicGroupGridType?
--- @field gridWidth number?
--- @field rowSpace number?
--- @field columnSpace number?
--- @field grow string?
--- @field id auraId
--- @field internalVersion number
--- @field information information
--- @field load load
--- @field limit number?
--- @field orientation string?
--- @field parent auraId?
--- @field radius number?
--- @field rotation number?
--- @field regionType regionTypes
--- @field scale number?
--- @field selfPoint AnchorPoint
--- @field subRegions subRegionData?
--- @field triggers triggerUntriggerData[]
--- @field url string?
--- @field useLimit boolean?
--- @field xOffset number?
--- @field yOffset number?

--- @class LibCustomGlow-1.0
--- @field ButtonGlow_Start fun(frame: Frame)
--- @field ButtonGlow_Stop fun(frame: Frame)
--- @field AutoCastGlow_Start fun(frame: Frame)
--- @field AutoCastGlow_Stop fun(frame: Frame)
--- @field PixelGlow_Start fun(frame: Frame)
--- @field PixelGlow_Stop fun(frame: Frame)

--- @class LibGetFrame-1.0
--- @field GetUnitFrame fun(unit: string)
--- @field GetUnitNameplate fun(unit: string)
--- @field StartProfile fun()
--- @field StopProfile fun()
--- @field GetProfileData fun(): table

--- @class LibSerialize
--- @field SerializeEx fun(self: LibSerialize,options: table, input: any)
--- @field Deserialize fun(self: LibSerialize, input: string): table

--- @class LibDeflate
--- @field CompressDeflate fun(self: LibDeflate, input: string, options: table): string
--- @field EncodeForPrint fun(self: LibDeflate, input: string): string)
--- @field EncodeForWoWAddonChannel fun(self: LibDeflate, input: string): string
--- @field DecodeForPrint fun(self: LibDeflate, input: string): string
--- @field DecodeForWoWAddonChannel fun(self: LibDeflate, input: string): string
--- @field DecompressDeflate fun(self: LibDeflate, input: string): string

--- @class LibDBIcon-1.0
--- @field Hide fun(self: LibDBIcon-1.0, name: string)
--- @field Register fun(self: LibDBIcon-1.0, name: string, broker: table, options: table)
--- @field Show fun(self: LibDBIcon-1.0, name: string)

--- @class LibSharedMedia-3.0
--- @field Fetch fun(self: LibSharedMedia-3.0, mediaType: string, name: string)
--- @field HashTable fun(self: LibSharedMedia-3.0, mediaType: string): table<string, string>
--- @field Register fun(self: LibSharedMedia-3.0, mediaType: string, name: string, path: string|number, flags: number?)
--- @field RegisterCallback fun(self: LibSharedMedia-3.0, callbackType: string, callback: fun(_: any, mediaType: string, key: string))
--- @field LOCALE_BIT_western number
--- @field LOCALE_BIT_ruRU number

--- @class LibCompress
--- @field Decompress fun(self: LibCompress, input: string): string

--- @class AceTimer-3.0
--- @field Embed fun(self: AceTimer-3.0, t: table)

WeakAuras.normalWidth = 1.3
WeakAuras.halfWidth = WeakAuras.normalWidth / 2
WeakAuras.doubleWidth = WeakAuras.normalWidth * 2
local versionStringFromToc = C_AddOns.GetAddOnMetadata("WeakAuras", "Version")
local versionString = "5.20.5"
local buildTime = "20251009185141"

local flavorFromToc = C_AddOns.GetAddOnMetadata("WeakAuras", "X-Flavor")
local flavorFromTocToNumber = {
  Vanilla = 1,
  TBC = 2,
  Wrath = 3,
  Cata = 4,
  Mists = 5,
  Mainline = 10
}
local flavor = flavorFromTocToNumber[flavorFromToc]

if not versionString:find("beta", 1, true) then
  WeakAuras.buildType = "release"
else
  WeakAuras.buildType = "beta"
end

--[=[@alpha@
WeakAuras.buildType = "alpha"
--@end-alpha@]=]

--[=====[@experimental@
WeakAuras.buildType = "pr"
--@end-experimental@]=====]

--[==[@debug@
if versionStringFromToc == "5.20.5" then
  versionStringFromToc = "Dev"
  buildTime = "Dev"
  WeakAuras.buildType = "dev"
end
--@end-debug@]==]

WeakAuras.versionString = versionStringFromToc
WeakAuras.buildTime = buildTime
WeakAuras.newFeatureString = "|TInterface\\OptionsFrame\\UI-OptionsFrame-NewFeatureIcon:0|t"
WeakAuras.BuildInfo = select(4, GetBuildInfo())

---@return boolean result
function WeakAuras.IsClassicEra()
  return flavor == 1
end
-- save compatibility with old auras
WeakAuras.IsClassic = WeakAuras.IsClassicEra

---@return boolean result
function WeakAuras.IsCataClassic()
  return flavor == 4
end

---@return boolean result
function WeakAuras.IsMists()
  return flavor == 5
end

---@return boolean result
function WeakAuras.IsRetail()
  return flavor == 10
end

---@return boolean result
function WeakAuras.IsClassicOrCata()
  return WeakAuras.IsClassicEra() or WeakAuras.IsCataClassic()
end

---@return boolean result
function WeakAuras.IsClassicOrCataOrMists()
  return WeakAuras.IsClassicOrCata() or WeakAuras.IsMists()
end

---@return boolean result
function WeakAuras.IsCataOrMists()
  return WeakAuras.IsCataClassic() or WeakAuras.IsMists()
end

function WeakAuras.IsCataOrMistsOrRetail()
  return WeakAuras.IsCataClassic() or WeakAuras.IsMists() or WeakAuras.IsRetail()
end

---@return boolean result
function WeakAuras.IsMistsOrRetail()
  return WeakAuras.IsMists() or WeakAuras.IsRetail()
end

---@return boolean result
function WeakAuras.IsCataOrRetail()
  return WeakAuras.IsCataClassic() or WeakAuras.IsRetail()
end

---@return boolean result
function WeakAuras.IsTWW()
  return WeakAuras.BuildInfo >= 110000
end

---@param ... string
WeakAuras.prettyPrint = function(...)
  print("|cff9900ffWeakAuras:|r ", ...)
end

-- Force enable WeakAurasCompanion and Archive because some addon managers interfere with it
C_AddOns.EnableAddOn("WeakAurasCompanion")
C_AddOns.EnableAddOn("WeakAurasArchive")

local libsAreOk = true
do
  local StandAloneLibs = {
    "Archivist",
    "LibStub"
  }
  local LibStubLibs = {
    "CallbackHandler-1.0",
    "AceTimer-3.0",
    "AceSerializer-3.0",
    "AceComm-3.0",
    "LibSharedMedia-3.0",
    "LibDataBroker-1.1",
    "LibCompress",
    "SpellRange-1.0",
    "LibCustomGlow-1.0",
    "LibDBIcon-1.0",
    "LibGetFrame-1.0",
    "LibSerialize",
  }
  if WeakAuras.IsRetail() then
    tinsert(LibStubLibs, "LibSpecialization")
    AddonCompartmentFrame:RegisterAddon({
      text = AddonName,
      icon = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\icon.blp",
      registerForAnyClick = true,
      notCheckable = true,
      func = function(button, menuInputData, menu)
        local mouseButton = menuInputData.buttonName
        if mouseButton == "LeftButton" then
          if IsShiftKeyDown() then
            if not (WeakAuras.IsOptionsOpen()) then
              WeakAuras.Toggle()
            end
          else
            WeakAuras.OpenOptions()
          end
        elseif mouseButton == "MiddleButton" then
          WeakAuras.ToggleMinimap()
        else
          WeakAurasProfilingFrame:Toggle()
        end
      end,
      funcOnEnter = function(button)
        MenuUtil.ShowTooltip(button, function(tooltip)
          WeakAuras.GenerateTooltip(true, tooltip)
        end)
      end,
      funcOnLeave = function(button)
        MenuUtil.HideTooltip(button)
      end,
    })
  end
  for _, lib in ipairs(StandAloneLibs) do
    if not lib then
        libsAreOk = false
        WeakAuras.prettyPrint("Missing library:", lib)
    end
  end
  if LibStub then
    for _, lib in ipairs(LibStubLibs) do
        if not LibStub:GetLibrary(lib, true) then
          libsAreOk = false
          WeakAuras.prettyPrint("Missing library:", lib)
        end
    end
  else
    libsAreOk = false
  end
end

function WeakAuras.IsLibsOK()
  return libsAreOk
end

if not libsAreOk then
  C_Timer.After(1, function()
    WeakAuras.prettyPrint("WeakAuras is missing necessary libraries. Please reinstall a proper package.")
  end)
end

-- These function stubs are defined here to reduce the number of errors that occur if WeakAuras.lua fails to compile
--- @type fun(regionType: string, createFunction: function, modifyFunction: function, defaults: table, properties: table|function|nil, validate: function?))
function Private.RegisterRegionType(_, _, _ ,_)
end

---@type fun(regionType: string, createOptions: function, icon: string|function, displayName: string, createThumbnail: function?, modifyThumbnail: function?, description: string?, templates: table?, getAnchors: function?)
---@diagnostic disable-next-line: duplicate-set-field
function Private.RegisterRegionOptions(_, _ , _ ,_ )
end

function Private.StartProfileSystem(_)
end

function Private.StartProfileAura(_)
end

function Private.StopProfileSystem(_)
end

function Private.StopProfileAura(_)
end

---@type fun()
function Private.StartProfileUID()
end

---@type fun()
function Private.StopProfileUID()
end

Private.ExecEnv = {}

-- If WeakAuras shuts down due to being installed on the wrong target, keep the bindings from erroring
--- @type fun(type: string)
---@diagnostic disable-next-line: duplicate-set-field
function WeakAuras.StartProfile(_)
end

---@diagnostic disable-next-line: duplicate-set-field
function WeakAuras.StopProfile()
end

---@diagnostic disable-next-line: duplicate-set-field
function WeakAuras.PrintProfile()
end

function WeakAuras.CountWagoUpdates()
  -- XXX this is to work around the Companion app trying to use our stuff!
  return 0
end



-- ========================================
-- File: WeakAuras/Legendaries.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

-- Legendaries based on https://wow.tools/dbc/?dbc=runeforgelegendaryability
-- mapping legendary id to bonus id
local legendariesToBonusId = {
  [2] = 6823,
  [3] = 6828,
  [4] = 6829,
  [5] = 6830,
  [6] = 6831,
  [7] = 6832,
  [8] = 6937,
  [9] = 6834,
  [10] = 6931,
  [11] = 6932,
  [12] = 6933,
  [13] = 6934,
  [14] = 6926,
  [15] = 6927,
  [16] = 6928,
  [17] = 6936,
  [18] = 7041,
  [19] = 7052,
  [20] = 7043,
  [21] = 7044,
  [22] = 7218,
  [23] = 7050,
  [24] = 7051,
  [25] = 7219,
  [26] = 7045,
  [27] = 7046,
  [28] = 7047,
  [29] = 7048,
  [30] = 6953,
  [31] = 6954,
  [32] = 6947,
  [33] = 6948,
  [34] = 6940,
  [35] = 6941,
  [36] = 6943,
  [37] = 6942,
  [38] = 6944,
  [39] = 6945,
  [40] = 6946,
  [41] = 7160,
  [42] = 6949,
  [43] = 6950,
  [44] = 6951,
  [45] = 6952,
  [46] = 7086,
  [47] = 7085,
  [48] = 7110,
  [49] = 7084,
  [50] = 7087,
  [51] = 7088,
  [52] = 7107,
  [53] = 7108,
  [54] = 7109,
  [55] = 7091,
  [56] = 7090,
  [57] = 7089,
  [58] = 7092,
  [59] = 7093,
  [60] = 7094,
  [61] = 7095,
  [62] = 7096,
  [63] = 7097,
  [64] = 7098,
  [65] = 7099,
  [66] = 7003,
  [67] = 7004,
  [68] = 7005,
  [69] = 7006,
  [70] = 7007,
  [71] = 7008,
  [72] = 7009,
  [73] = 7010,
  [74] = 7011,
  [75] = 7012,
  [76] = 7013,
  [77] = 7014,
  [78] = 7015,
  [79] = 7016,
  [80] = 7017,
  [81] = 7018,
  [82] = 7184,
  [83] = 7082,
  [84] = 7080,
  [85] = 7081,
  [86] = 7076,
  [87] = 7077,
  [88] = 7078,
  [89] = 7079,
  [90] = 7075,
  [91] = 7073,
  [92] = 7074,
  [93] = 7072,
  [94] = 7070,
  [95] = 7068,
  [96] = 7071,
  [97] = 7069,
  [98] = 7053,
  [100] = 7055,
  [101] = 7056,
  [102] = 7128,
  [103] = 7059,
  [104] = 7057,
  [105] = 7058,
  [106] = 7060,
  [107] = 7061,
  [108] = 7062,
  [109] = 7063,
  [110] = 7067,
  [111] = 7066,
  [112] = 7065,
  [113] = 7064,
  [114] = 7114,
  [115] = 7113,
  [116] = 7112,
  [117] = 7111,
  [118] = 7115,
  [119] = 7116,
  [120] = 7117,
  [121] = 7118,
  [122] = 7122,
  [123] = 7121,
  [124] = 7120,
  [125] = 7119,
  [126] = 7123,
  [127] = 7124,
  [128] = 7125,
  [129] = 7126,
  [130] = 6985,
  [131] = 6986,
  [132] = 6987,
  [133] = 6988,
  [134] = 6989,
  [135] = 6990,
  [136] = 6991,
  [137] = 6992,
  [138] = 6993,
  [139] = 6994,
  [140] = 6995,
  [141] = 6996,
  [142] = 6997,
  [143] = 6998,
  [144] = 6999,
  [145] = 7000,
  [146] = 7161,
  [147] = 7002,
  [148] = 6975,
  [149] = 6972,
  [150] = 6976,
  [151] = 6978,
  [152] = 6979,
  [153] = 6980,
  [154] = 6984,
  [155] = 6977,
  [156] = 6974,
  [157] = 6973,
  [158] = 6981,
  [159] = 6982,
  [160] = 6983,
  [161] = 7162,
  [162] = 7025,
  [163] = 7026,
  [164] = 7027,
  [165] = 7028,
  [166] = 7029,
  [167] = 7030,
  [168] = 7031,
  [169] = 7032,
  [170] = 7033,
  [171] = 7034,
  [172] = 7035,
  [173] = 7036,
  [174] = 7037,
  [175] = 7038,
  [176] = 7039,
  [177] = 7040,
  [178] = 6955,
  [179] = 6971,
  [180] = 6958,
  [181] = 6959,
  [182] = 6962,
  [183] = 6960,
  [184] = 6961,
  [185] = 6970,
  [186] = 6963,
  [187] = 6964,
  [188] = 6965,
  [189] = 6966,
  [190] = 6956,
  [191] = 6957,
  [192] = 6967,
  [193] = 6969,
  [196] = 7054,
  [199] = 7100,
  [200] = 7101,
  [201] = 7102,
  [202] = 7103,
  [203] = 7104,
  [204] = 7105,
  [205] = 7106,
  [206] = 7159,
  -- Added in Patch 9.1.0:
  [210] = 7466,
  [211] = 7467,
  [212] = 7468,
  [213] = 7458,
  [214] = 7469,
  [215] = 7470,
  [216] = 7471,
  [217] = 7472,
  [218] = 7473,
  [220] = 7474,
  [221] = 7475,
  [222] = 7476,
  [223] = 7477,
  [224] = 7478,
  [226] = 7571,
  [228] = 7570,
  [229] = 7572,
  [230] = 7573,
  [231] = 7577,
  [234] = 7679,
  [235] = 7680,
  [236] = 7681,
  [237] = 7698,
  [238] = 7699,
  [239] = 7700,
  [240] = 7701,
  [241] = 7702,
  [242] = 7703,
  [243] = 7704,
  [244] = 7707,
  [246] = 7708,
  [247] = 7709,
  [248] = 7710,
  [249] = 7711,
  [250] = 7712,
  [251] = 7713,
  [252] = 7714,
  [253] = 7715,
  [254] = 7716,
  [255] = 7717,
  [256] = 7718,
  [257] = 7721,
  [258] = 7722,
  [259] = 7726,
  [260] = 7727,
  [261] = 7728,
  [262] = 7729,
  [263] = 7730,
  [264] = 8119,
  [267] = 8120,
  [268] = 8121,
  [269] = 8122,
  [270] = 8123,
  [271] = 8124,
  [272] = 8125,
  [273] = 8126,
  [274] = 8127,
  [275] = 8128,
  [276] = 8129,
  [277] = 8130,
}

local bonusIdToLegendary = {}
for k, v in pairs(legendariesToBonusId) do
  bonusIdToLegendary[v] = k
end

WeakAuras.GetLegendaryData = function(id)
  if not WeakAuras.IsRetail() then
    return ""
  end
  local legendaryID = bonusIdToLegendary[tonumber(id)]
  if legendaryID then
    local data = C_LegendaryCrafting.GetRuneforgePowerInfo(legendaryID)
    return data.name, data.iconFileID
  end
end



-- ========================================
-- File: WeakAuras/LibSpecializationWrapper.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
if not WeakAuras.IsCataOrMistsOrRetail() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

--- @class LibSpecialization
--- @field Register fun(self: LibSpecialization, name: string, callback: function)
--- @field MySpecialization fun(): number, string, string
local LibSpec = LibStub("LibSpecialization")

--- @alias specData {[1]: number, [2]: string, [3]: string, [4]: string}

--- @type table<string, specData>
local nameToSpecMap = {}

local nameToTalents = {}

--- @type table<string, string>
local nameToUnitMap = {
  [GetUnitName("player", true)] = "player"
}

--- @type function[]
local subscribers = {}

--- @class LibSpecWrapper
--- @field Register fun(callback: fun(unit: string))
--- @field SpecForUnit fun(unit: string): number?
--- @field SpecRolePositionForUnit fun(unit: string): number?, string?, string?
--- @field CheckTalentForUnit fun(unit: string, talentId: number): boolean?

Private.LibSpecWrapper = {
  Register = function(callback) end,
  SpecForUnit = function(unit) end,
  SpecRolePositionForUnit = function(unit) end,
  CheckTalentForUnit = function(unit) end,
}
if LibSpec then
  local frame = CreateFrame("Frame")
  frame:RegisterEvent("PLAYER_LOGIN")
  frame:RegisterEvent("GROUP_ROSTER_UPDATE")
  frame:SetScript("OnEvent", function()
    --- @type string
    local ownName = GetUnitName("player", true)

    nameToUnitMap = {}
    nameToUnitMap[ownName] = "player"

    if IsInRaid() then
      local max = GetNumGroupMembers()
      for i = 1, max do
        local name = GetUnitName(WeakAuras.raidUnits[i], true)
        nameToUnitMap[name] = WeakAuras.raidUnits[i]
      end
    else
      local max = GetNumSubgroupMembers()
      for i = 1, max do
        local name = GetUnitName(WeakAuras.partyUnits[i], true)
        nameToUnitMap[name] = WeakAuras.partyUnits[i]
      end
    end

    for name in pairs(nameToSpecMap) do
      if not nameToUnitMap[name] then
        nameToSpecMap[name] = nil
      end
    end
  end)

  --- LibSpecialization callback
  ---@param specId number
  ---@param role string
  ---@param position string
  ---@param sender string
  ---@param talentString string
  local function LibSpecCallback(specId, role, position, sender, talentString)
    if nameToSpecMap[sender]
       and nameToSpecMap[sender][1] == specId
       and nameToSpecMap[sender][2] == role
       and nameToSpecMap[sender][3] == position
       and nameToSpecMap[sender][4] == talentString
    then
      return
    end

    if not nameToUnitMap[sender] then
      return
    end

    nameToSpecMap[sender] = {specId, role, position, talentString}
    nameToTalents[sender] = nil
    for _, f in ipairs(subscribers) do
      f(nameToUnitMap[sender])
    end
  end

  local libSpecCallBackTable = {}
  LibSpec.RegisterGroup(libSpecCallBackTable, LibSpecCallback)

  function Private.LibSpecWrapper.Register(f)
    tinsert(subscribers, f)
  end

  function Private.LibSpecWrapper.SpecForUnit(unit)
    if UnitIsUnit(unit, "player") then
      return (LibSpec.MySpecialization())
    end

    if nameToSpecMap[GetUnitName(unit, true)] then
      return nameToSpecMap[GetUnitName(unit, true)][1]
    end
  end

  function Private.LibSpecWrapper.SpecRolePositionForUnit(unit)
    if UnitIsUnit(unit, "player") then
      return LibSpec.MySpecialization()
    end
    local data = nameToSpecMap[GetUnitName(unit, true)]
    if data then
      return unpack(data)
    else
      return nil
    end
  end

  local function ReadLoadoutHeader(importStream)
    local bitWidthHeaderVersion = 8
    local bitWidthSpecID = 16
    local headerBitWidth = bitWidthHeaderVersion + bitWidthSpecID + 128;

    local importStreamTotalBits = importStream:GetNumberOfBits();
    if( importStreamTotalBits < headerBitWidth) then
      return false, 0, 0, 0;
    end
    local serializationVersion = importStream:ExtractValue(bitWidthHeaderVersion);
    local specID = importStream:ExtractValue(bitWidthSpecID);

    -- treeHash is a 128bit hash, passed as an array of 16, 8-bit values
    local treeHash = {};
    for i=1,16,1 do
      treeHash[i] = importStream:ExtractValue(8);
    end
    return true, serializationVersion, specID, treeHash;
  end

  local validSerializationVersions = {
    [1] = true,
    [2] = true
  }

  if WeakAuras.IsRetail() then
    function Private.LibSpecWrapper.CheckTalentForUnit(unit, talentId)
      if UnitIsUnit(unit, "player") then
        return select(4, WeakAuras.GetTalentById(talentId))
      end
      local unitName = GetUnitName(unit, true)
      if not nameToTalents[unitName] then
        -- Parse Talent String once and store which talents are selected
        if not nameToSpecMap[unitName] then return nil end
        local talentString = nameToSpecMap[unitName][4]
        if not talentString then return nil end

        local importStream = CreateAndInitFromMixin(ImportDataStreamMixin, talentString)
        local headerValid, serializationVersion, specID, treeHash = ReadLoadoutHeader(importStream);
        local currentSerializationVersion = C_Traits.GetLoadoutSerializationVersion();
        if(not headerValid) then
          return nil
        end
        if(serializationVersion ~= currentSerializationVersion or not validSerializationVersions[serializationVersion]) then
          return nil
        end

        local treeID = C_ClassTalents.GetTraitTreeForSpec(specID)

        local results = {};
        local bitWidthRanksPurchased = 6

        local _, _, talentsData = Private.GetTalentData(specID)
        local treeNodes = C_Traits.GetTreeNodes(treeID);
        for _, nodeId in ipairs(treeNodes) do
          local nodeSelectedValue = importStream:ExtractValue(1)
          local isNodeSelected = nodeSelectedValue == 1
          local isPartiallyRanked = false
          local partialRanksPurchased = 0
          local isChoiceNode = false
          local choiceNodeSelection = 1

          if(isNodeSelected) then
            if serializationVersion == 2 then
              local nodePurchasedValue = importStream:ExtractValue(1)
              local isNodePurchased = nodePurchasedValue == 1
              if(isNodePurchased) then
                local isPartiallyRankedValue = importStream:ExtractValue(1)
                isPartiallyRanked = isPartiallyRankedValue == 1
                if(isPartiallyRanked) then
                  partialRanksPurchased = importStream:ExtractValue(bitWidthRanksPurchased)
                end
                local isChoiceNodeValue = importStream:ExtractValue(1)
                isChoiceNode = isChoiceNodeValue == 1
                if(isChoiceNode) then
                  choiceNodeSelection = importStream:ExtractValue(2) + 1
                end
              end
            else
              local isPartiallyRankedValue = importStream:ExtractValue(1)
              isPartiallyRanked = isPartiallyRankedValue == 1
              if(isPartiallyRanked) then
                partialRanksPurchased = importStream:ExtractValue(bitWidthRanksPurchased)
              end
              local isChoiceNodeValue = importStream:ExtractValue(1)
              isChoiceNode = isChoiceNodeValue == 1
              if(isChoiceNode) then
                choiceNodeSelection = importStream:ExtractValue(2) + 1
              end
            end
          end

          local talentData = talentsData and talentsData[nodeId] and talentsData[nodeId][choiceNodeSelection]
          if talentData then
            if isPartiallyRanked then
              results[talentData[1]] = partialRanksPurchased
            else
              results[talentData[1]] = nodeSelectedValue == 1 and talentData[5] or 0
            end
          end
          if isChoiceNode then
            local unselectedChoiceNodeIdx = choiceNodeSelection == 1 and 2 or 1
            local unselectedTalentData = talentsData and talentsData[nodeId] and talentsData[nodeId][unselectedChoiceNodeIdx]
            if unselectedTalentData then
              results[unselectedTalentData[1]] = 0
            end
          end
        end
        nameToTalents[unitName] = results
      end

      if nameToTalents[unitName] then
        return nameToTalents[unitName][talentId]
      end
    end
  elseif WeakAuras.IsMists() then
    local function cacheData(unitName)
      -- Parse Talent String once and store which talents are selected
      if not nameToSpecMap[unitName] then return nil end
      local JSONtalentString = nameToSpecMap[unitName][4]
      if not JSONtalentString then return nil end

      local talentsAndGlyphs = C_EncodingUtil.DeserializeJSON(JSONtalentString)
      if not talentsAndGlyphs then return nil end

      local results = {
        talents = {},
        glyphs = {}
      }

      for _, id in ipairs(talentsAndGlyphs.talents) do
        if id > 0 then
          results.talents[id] = true
        end
      end
      for _, id in ipairs(talentsAndGlyphs.glyphs) do
        if id > 0 then
          results.glyphs[id] = true
        end
      end
      nameToTalents[unitName] = results
    end

    function Private.LibSpecWrapper.CheckTalentForUnit(unit, talentId)
      if UnitIsUnit(unit, "player") then
        return select(4, WeakAuras.GetTalentById(talentId))
      end
      local unitName = GetUnitName(unit, true)
      if not nameToTalents[unitName] then
        cacheData(unitName)
      end

      if nameToTalents[unitName] then
        return nameToTalents[unitName].talents[talentId]
      end
    end

    function Private.LibSpecWrapper.CheckGlyphForUnit(unit, glyphId)
      local unitName = GetUnitName(unit, true)
      if not nameToTalents[unitName] then
        cacheData(unitName)
      end

      if nameToTalents[unitName] then
        return nameToTalents[unitName].glyphs[glyphId]
      end
    end
  end

else -- non retail
  function Private.LibSpecWrapper.Register(f)

  end

  function Private.LibSpecWrapper.SpecForUnit(unit)
    return nil
  end

  function Private.LibSpecWrapper.SpecRolePositionForUnit(unit)
    return nil
  end

  function Private.LibSpecWrapper.CheckTalentForUnit(unit)
    return nil
  end
end

-- Export for GenericTrigger
WeakAuras.SpecForUnit = Private.LibSpecWrapper.SpecForUnit
WeakAuras.SpecRolePositionForUnit = Private.LibSpecWrapper.SpecRolePositionForUnit
WeakAuras.CheckTalentForUnit = Private.LibSpecWrapper.CheckTalentForUnit

if Private.LibSpecWrapper.CheckGlyphForUnit then
  WeakAuras.CheckGlyphForUnit = Private.LibSpecWrapper.CheckGlyphForUnit
else
  WeakAuras.CheckGlyphForUnit = function() return nil end
end


-- ========================================
-- File: WeakAuras/Libs/AceComm-3.0/AceComm-3.0.lua
-- ========================================

--- **AceComm-3.0** allows you to send messages of unlimited length over the addon comm channels.
-- It'll automatically split the messages into multiple parts and rebuild them on the receiving end.\\
-- **ChatThrottleLib** is of course being used to avoid being disconnected by the server.
--
-- **AceComm-3.0** can be embeded into your addon, either explicitly by calling AceComm:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceComm itself.\\
-- It is recommended to embed AceComm, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceComm.
-- @class file
-- @name AceComm-3.0
-- @release $Id: AceComm-3.0.lua 1333 2024-05-05 16:24:39Z nevcairiel $

--[[ AceComm-3.0

TODO: Time out old data rotting around from dead senders? Not a HUGE deal since the number of possible sender names is somewhat limited.

]]

local CallbackHandler = LibStub("CallbackHandler-1.0")
local CTL = assert(ChatThrottleLib, "AceComm-3.0 requires ChatThrottleLib")

local MAJOR, MINOR = "AceComm-3.0", 14
local AceComm,oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceComm then return end

-- Lua APIs
local type, next, pairs, tostring = type, next, pairs, tostring
local strsub, strfind = string.sub, string.find
local match = string.match
local tinsert, tconcat = table.insert, table.concat
local error, assert = error, assert

-- WoW APIs
local Ambiguate = Ambiguate

AceComm.embeds = AceComm.embeds or {}

-- for my sanity and yours, let's give the message type bytes some names
local MSG_MULTI_FIRST = "\001"
local MSG_MULTI_NEXT  = "\002"
local MSG_MULTI_LAST  = "\003"
local MSG_ESCAPE = "\004"

-- remove old structures (pre WoW 4.0)
AceComm.multipart_origprefixes = nil
AceComm.multipart_reassemblers = nil

-- the multipart message spool: indexed by a combination of sender+distribution+
AceComm.multipart_spool = AceComm.multipart_spool or {}

--- Register for Addon Traffic on a specified prefix
-- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent), max 16 characters
-- @param method Callback to call on message reception: Function reference, or method name (string) to call on self. Defaults to "OnCommReceived"
function AceComm:RegisterComm(prefix, method)
	if method == nil then
		method = "OnCommReceived"
	end

	if #prefix > 16 then -- TODO: 15?
		error("AceComm:RegisterComm(prefix,method): prefix length is limited to 16 characters")
	end
	if C_ChatInfo then
		C_ChatInfo.RegisterAddonMessagePrefix(prefix)
	else
		RegisterAddonMessagePrefix(prefix)
	end

	return AceComm._RegisterComm(self, prefix, method)	-- created by CallbackHandler
end

local warnedPrefix=false

--- Send a message over the Addon Channel
-- @param prefix A printable character (\032-\255) classification of the message (typically AddonName or AddonNameEvent)
-- @param text Data to send, nils (\000) not allowed. Any length.
-- @param distribution Addon channel, e.g. "RAID", "GUILD", etc; see SendAddonMessage API
-- @param target Destination for some distributions; see SendAddonMessage API
-- @param prio OPTIONAL: ChatThrottleLib priority, "BULK", "NORMAL" or "ALERT". Defaults to "NORMAL".
-- @param callbackFn OPTIONAL: callback function to be called as each chunk is sent. receives 3 args: the user supplied arg (see next), the number of bytes sent so far, and the number of bytes total to send.
-- @param callbackArg: OPTIONAL: first arg to the callback function. nil will be passed if not specified.
function AceComm:SendCommMessage(prefix, text, distribution, target, prio, callbackFn, callbackArg)
	prio = prio or "NORMAL"	-- pasta's reference implementation had different prio for singlepart and multipart, but that's a very bad idea since that can easily lead to out-of-sequence delivery!
	if not( type(prefix)=="string" and
			type(text)=="string" and
			type(distribution)=="string" and
			(target==nil or type(target)=="string" or type(target)=="number") and
			(prio=="BULK" or prio=="NORMAL" or prio=="ALERT")
		) then
		error('Usage: SendCommMessage(addon, "prefix", "text", "distribution"[, "target"[, "prio"[, callbackFn, callbackarg]]])', 2)
	end

	local textlen = #text
	local maxtextlen = 255  -- Yes, the max is 255 even if the dev post said 256. I tested. Char 256+ get silently truncated. /Mikk, 20110327
	local queueName = prefix

	local ctlCallback = nil
	if callbackFn then
		ctlCallback = function(sent, sendResult)
			return callbackFn(callbackArg, sent, textlen, sendResult)
		end
	end

	local forceMultipart
	if match(text, "^[\001-\009]") then -- 4.1+: see if the first character is a control character
		-- we need to escape the first character with a \004
		if textlen+1 > maxtextlen then	-- would we go over the size limit?
			forceMultipart = true	-- just make it multipart, no escape problems then
		else
			text = "\004" .. text
		end
	end

	if not forceMultipart and textlen <= maxtextlen then
		-- fits all in one message
		CTL:SendAddonMessage(prio, prefix, text, distribution, target, queueName, ctlCallback, textlen)
	else
		maxtextlen = maxtextlen - 1	-- 1 extra byte for part indicator in prefix(4.0)/start of message(4.1)

		-- first part
		local chunk = strsub(text, 1, maxtextlen)
		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_FIRST..chunk, distribution, target, queueName, ctlCallback, maxtextlen)

		-- continuation
		local pos = 1+maxtextlen

		while pos+maxtextlen <= textlen do
			chunk = strsub(text, pos, pos+maxtextlen-1)
			CTL:SendAddonMessage(prio, prefix, MSG_MULTI_NEXT..chunk, distribution, target, queueName, ctlCallback, pos+maxtextlen-1)
			pos = pos + maxtextlen
		end

		-- final part
		chunk = strsub(text, pos)
		CTL:SendAddonMessage(prio, prefix, MSG_MULTI_LAST..chunk, distribution, target, queueName, ctlCallback, textlen)
	end
end


----------------------------------------
-- Message receiving
----------------------------------------

do
	local compost = setmetatable({}, {__mode = "k"})
	local function new()
		local t = next(compost)
		if t then
			compost[t]=nil
			for i=#t,3,-1 do	-- faster than pairs loop. don't even nil out 1/2 since they'll be overwritten
				t[i]=nil
			end
			return t
		end

		return {}
	end

	local function lostdatawarning(prefix,sender,where)
		DEFAULT_CHAT_FRAME:AddMessage(MAJOR..": Warning: lost network data regarding '"..tostring(prefix).."' from '"..tostring(sender).."' (in "..where..")")
	end

	function AceComm:OnReceiveMultipartFirst(prefix, message, distribution, sender)
		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
		local spool = AceComm.multipart_spool

		--[[
		if spool[key] then
			lostdatawarning(prefix,sender,"First")
			-- continue and overwrite
		end
		--]]

		spool[key] = message  -- plain string for now
	end

	function AceComm:OnReceiveMultipartNext(prefix, message, distribution, sender)
		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
		local spool = AceComm.multipart_spool
		local olddata = spool[key]

		if not olddata then
			--lostdatawarning(prefix,sender,"Next")
			return
		end

		if type(olddata)~="table" then
			-- ... but what we have is not a table. So make it one. (Pull a composted one if available)
			local t = new()
			t[1] = olddata    -- add old data as first string
			t[2] = message    -- and new message as second string
			spool[key] = t    -- and put the table in the spool instead of the old string
		else
			tinsert(olddata, message)
		end
	end

	function AceComm:OnReceiveMultipartLast(prefix, message, distribution, sender)
		local key = prefix.."\t"..distribution.."\t"..sender	-- a unique stream is defined by the prefix + distribution + sender
		local spool = AceComm.multipart_spool
		local olddata = spool[key]

		if not olddata then
			--lostdatawarning(prefix,sender,"End")
			return
		end

		spool[key] = nil

		if type(olddata) == "table" then
			-- if we've received a "next", the spooled data will be a table for rapid & garbage-free tconcat
			tinsert(olddata, message)
			AceComm.callbacks:Fire(prefix, tconcat(olddata, ""), distribution, sender)
			compost[olddata] = true
		else
			-- if we've only received a "first", the spooled data will still only be a string
			AceComm.callbacks:Fire(prefix, olddata..message, distribution, sender)
		end
	end
end






----------------------------------------
-- Embed CallbackHandler
----------------------------------------

if not AceComm.callbacks then
	AceComm.callbacks = CallbackHandler:New(AceComm,
						"_RegisterComm",
						"UnregisterComm",
						"UnregisterAllComm")
end

AceComm.callbacks.OnUsed = nil
AceComm.callbacks.OnUnused = nil

local function OnEvent(self, event, prefix, message, distribution, sender)
	if event == "CHAT_MSG_ADDON" then
		sender = Ambiguate(sender, "none")
		local control, rest = match(message, "^([\001-\009])(.*)")
		if control then
			if control==MSG_MULTI_FIRST then
				AceComm:OnReceiveMultipartFirst(prefix, rest, distribution, sender)
			elseif control==MSG_MULTI_NEXT then
				AceComm:OnReceiveMultipartNext(prefix, rest, distribution, sender)
			elseif control==MSG_MULTI_LAST then
				AceComm:OnReceiveMultipartLast(prefix, rest, distribution, sender)
			elseif control==MSG_ESCAPE then
				AceComm.callbacks:Fire(prefix, rest, distribution, sender)
			else
				-- unknown control character, ignore SILENTLY (dont warn unnecessarily about future extensions!)
			end
		else
			-- single part: fire it off immediately and let CallbackHandler decide if it's registered or not
			AceComm.callbacks:Fire(prefix, message, distribution, sender)
		end
	else
		assert(false, "Received "..tostring(event).." event?!")
	end
end

AceComm.frame = AceComm.frame or CreateFrame("Frame", "AceComm30Frame")
AceComm.frame:SetScript("OnEvent", OnEvent)
AceComm.frame:UnregisterAllEvents()
AceComm.frame:RegisterEvent("CHAT_MSG_ADDON")


----------------------------------------
-- Base library stuff
----------------------------------------

local mixins = {
	"RegisterComm",
	"UnregisterComm",
	"UnregisterAllComm",
	"SendCommMessage",
}

-- Embeds AceComm-3.0 into the target object making the functions from the mixins list available on target:..
-- @param target target object to embed AceComm-3.0 in
function AceComm:Embed(target)
	for k, v in pairs(mixins) do
		target[v] = self[v]
	end
	self.embeds[target] = true
	return target
end

function AceComm:OnEmbedDisable(target)
	target:UnregisterAllComm()
end

-- Update embeds
for target, v in pairs(AceComm.embeds) do
	AceComm:Embed(target)
end


-- ========================================
-- File: WeakAuras/Libs/AceComm-3.0/ChatThrottleLib.lua
-- ========================================

--
-- ChatThrottleLib by Mikk
--
-- Manages AddOn chat output to keep player from getting kicked off.
--
-- ChatThrottleLib:SendChatMessage/:SendAddonMessage functions that accept
-- a Priority ("BULK", "NORMAL", "ALERT") as well as prefix for SendChatMessage.
--
-- Priorities get an equal share of available bandwidth when fully loaded.
-- Communication channels are separated on extension+chattype+destination and
-- get round-robinned. (Destination only matters for whispers and channels,
-- obviously)
--
-- Will install hooks for SendChatMessage and SendAddonMessage to measure
-- bandwidth bypassing the library and use less bandwidth itself.
--
--
-- Fully embeddable library. Just copy this file into your addon directory,
-- add it to the .toc, and it's done.
--
-- Can run as a standalone addon also, but, really, just embed it! :-)
--
-- LICENSE: ChatThrottleLib is released into the Public Domain
--

local CTL_VERSION = 31

local _G = _G

if _G.ChatThrottleLib then
	if _G.ChatThrottleLib.version >= CTL_VERSION then
		-- There's already a newer (or same) version loaded. Buh-bye.
		return
	elseif not _G.ChatThrottleLib.securelyHooked then
		print("ChatThrottleLib: Warning: There's an ANCIENT ChatThrottleLib.lua (pre-wow 2.0, <v16) in an addon somewhere. Get the addon updated or copy in a newer ChatThrottleLib.lua (>=v16) in it!")
		-- ATTEMPT to unhook; this'll behave badly if someone else has hooked...
		-- ... and if someone has securehooked, they can kiss that goodbye too... >.<
		_G.SendChatMessage = _G.ChatThrottleLib.ORIG_SendChatMessage
		if _G.ChatThrottleLib.ORIG_SendAddonMessage then
			_G.SendAddonMessage = _G.ChatThrottleLib.ORIG_SendAddonMessage
		end
	end
	_G.ChatThrottleLib.ORIG_SendChatMessage = nil
	_G.ChatThrottleLib.ORIG_SendAddonMessage = nil
end

if not _G.ChatThrottleLib then
	_G.ChatThrottleLib = {}
end

ChatThrottleLib = _G.ChatThrottleLib  -- in case some addon does "local ChatThrottleLib" above us and we're copypasted (AceComm-2, sigh)
local ChatThrottleLib = _G.ChatThrottleLib

ChatThrottleLib.version = CTL_VERSION



------------------ TWEAKABLES -----------------

ChatThrottleLib.MAX_CPS = 800			  -- 2000 seems to be safe if NOTHING ELSE is happening. let's call it 800.
ChatThrottleLib.MSG_OVERHEAD = 40		-- Guesstimate overhead for sending a message; source+dest+chattype+protocolstuff

ChatThrottleLib.BURST = 4000				-- WoW's server buffer seems to be about 32KB. 8KB should be safe, but seen disconnects on _some_ servers. Using 4KB now.

ChatThrottleLib.MIN_FPS = 20				-- Reduce output CPS to half (and don't burst) if FPS drops below this value


local setmetatable = setmetatable
local table_remove = table.remove
local tostring = tostring
local GetTime = GetTime
local math_min = math.min
local math_max = math.max
local next = next
local strlen = string.len
local GetFramerate = GetFramerate
local unpack,type,pairs,wipe = unpack,type,pairs,table.wipe


-----------------------------------------------------------------------
-- Double-linked ring implementation

local Ring = {}
local RingMeta = { __index = Ring }

function Ring:New()
	local ret = {}
	setmetatable(ret, RingMeta)
	return ret
end

function Ring:Add(obj)	-- Append at the "far end" of the ring (aka just before the current position)
	if self.pos then
		obj.prev = self.pos.prev
		obj.prev.next = obj
		obj.next = self.pos
		obj.next.prev = obj
	else
		obj.next = obj
		obj.prev = obj
		self.pos = obj
	end
end

function Ring:Remove(obj)
	obj.next.prev = obj.prev
	obj.prev.next = obj.next
	if self.pos == obj then
		self.pos = obj.next
		if self.pos == obj then
			self.pos = nil
		end
	end
end

-- Note that this is local because there's no upgrade logic for existing ring
-- metatables, and this isn't present on rings created in versions older than
-- v25.
local function Ring_Link(self, other)  -- Move and append all contents of another ring to this ring
	if not self.pos then
		-- This ring is empty, so just transfer ownership.
		self.pos = other.pos
		other.pos = nil
	elseif other.pos then
		-- Our tail should point to their head, and their tail to our head.
		self.pos.prev.next, other.pos.prev.next = other.pos, self.pos
		-- Our head should point to their tail, and their head to our tail.
		self.pos.prev, other.pos.prev = other.pos.prev, self.pos.prev
		other.pos = nil
	end
end



-----------------------------------------------------------------------
-- Recycling bin for pipes
-- A pipe is a plain integer-indexed queue of messages
-- Pipes normally live in Rings of pipes  (3 rings total, one per priority)

ChatThrottleLib.PipeBin = nil -- pre-v19, drastically different
local PipeBin = setmetatable({}, {__mode="k"})

local function DelPipe(pipe)
	PipeBin[pipe] = true
end

local function NewPipe()
	local pipe = next(PipeBin)
	if pipe then
		wipe(pipe)
		PipeBin[pipe] = nil
		return pipe
	end
	return {}
end




-----------------------------------------------------------------------
-- Recycling bin for messages

ChatThrottleLib.MsgBin = nil -- pre-v19, drastically different
local MsgBin = setmetatable({}, {__mode="k"})

local function DelMsg(msg)
	msg[1] = nil
	-- there's more parameters, but they're very repetetive so the string pool doesn't suffer really, and it's faster to just not delete them.
	MsgBin[msg] = true
end

local function NewMsg()
	local msg = next(MsgBin)
	if msg then
		MsgBin[msg] = nil
		return msg
	end
	return {}
end


-----------------------------------------------------------------------
-- ChatThrottleLib:Init
-- Initialize queues, set up frame for OnUpdate, etc


function ChatThrottleLib:Init()

	-- Set up queues
	if not self.Prio then
		self.Prio = {}
		self.Prio["ALERT"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
		self.Prio["NORMAL"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
		self.Prio["BULK"] = { ByName = {}, Ring = Ring:New(), avail = 0 }
	end

	if not self.BlockedQueuesDelay then
		-- v25: Add blocked queues to rings to handle new client throttles.
		for _, Prio in pairs(self.Prio) do
			Prio.Blocked = Ring:New()
		end
	end

	-- v4: total send counters per priority
	for _, Prio in pairs(self.Prio) do
		Prio.nTotalSent = Prio.nTotalSent or 0
	end

	if not self.avail then
		self.avail = 0 -- v5
	end
	if not self.nTotalSent then
		self.nTotalSent = 0 -- v5
	end


	-- Set up a frame to get OnUpdate events
	if not self.Frame then
		self.Frame = CreateFrame("Frame")
		self.Frame:Hide()
	end
	self.Frame:SetScript("OnUpdate", self.OnUpdate)
	self.Frame:SetScript("OnEvent", self.OnEvent)	-- v11: Monitor P_E_W so we can throttle hard for a few seconds
	self.Frame:RegisterEvent("PLAYER_ENTERING_WORLD")
	self.OnUpdateDelay = 0
	self.BlockedQueuesDelay = 0
	self.LastAvailUpdate = GetTime()
	self.HardThrottlingBeginTime = GetTime()	-- v11: Throttle hard for a few seconds after startup

	-- Hook SendChatMessage and SendAddonMessage so we can measure unpiped traffic and avoid overloads (v7)
	if not self.securelyHooked then
		-- Use secure hooks as of v16. Old regular hook support yanked out in v21.
		self.securelyHooked = true
		--SendChatMessage
		if _G.C_ChatInfo and _G.C_ChatInfo.SendChatMessage then
			hooksecurefunc(_G.C_ChatInfo, "SendChatMessage", function(...)
				return ChatThrottleLib.Hook_SendChatMessage(...)
			end)
		else
			hooksecurefunc("SendChatMessage", function(...)
				return ChatThrottleLib.Hook_SendChatMessage(...)
			end)
		end
		--SendAddonMessage
		hooksecurefunc(_G.C_ChatInfo, "SendAddonMessage", function(...)
			return ChatThrottleLib.Hook_SendAddonMessage(...)
		end)
	end

	-- v26: Hook SendAddonMessageLogged for traffic logging
	if not self.securelyHookedLogged then
		self.securelyHookedLogged = true
		hooksecurefunc(_G.C_ChatInfo, "SendAddonMessageLogged", function(...)
			return ChatThrottleLib.Hook_SendAddonMessageLogged(...)
		end)
	end

	-- v29: Hook BNSendGameData for traffic logging
	if not self.securelyHookedBNGameData then
		self.securelyHookedBNGameData = true
		if _G.C_BattleNet and _G.C_BattleNet.SendGameData then
			hooksecurefunc(_G.C_BattleNet, "SendGameData", function(...)
				return ChatThrottleLib.Hook_BNSendGameData(...)
			end)
		else
			hooksecurefunc("BNSendGameData", function(...)
				return ChatThrottleLib.Hook_BNSendGameData(...)
			end)
		end
	end

	self.nBypass = 0
end


-----------------------------------------------------------------------
-- ChatThrottleLib.Hook_SendChatMessage / .Hook_SendAddonMessage

local bMyTraffic = false

function ChatThrottleLib.Hook_SendChatMessage(text, chattype, language, destination, ...)
	if bMyTraffic then
		return
	end
	local self = ChatThrottleLib
	local size = strlen(tostring(text or "")) + strlen(tostring(destination or "")) + self.MSG_OVERHEAD
	self.avail = self.avail - size
	self.nBypass = self.nBypass + size	-- just a statistic
end
function ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination, ...)
	if bMyTraffic then
		return
	end
	local self = ChatThrottleLib
	local size = tostring(text or ""):len() + tostring(prefix or ""):len();
	size = size + tostring(destination or ""):len() + self.MSG_OVERHEAD
	self.avail = self.avail - size
	self.nBypass = self.nBypass + size	-- just a statistic
end
function ChatThrottleLib.Hook_SendAddonMessageLogged(prefix, text, chattype, destination, ...)
	ChatThrottleLib.Hook_SendAddonMessage(prefix, text, chattype, destination, ...)
end
function ChatThrottleLib.Hook_BNSendGameData(destination, prefix, text)
	ChatThrottleLib.Hook_SendAddonMessage(prefix, text, "WHISPER", destination)
end



-----------------------------------------------------------------------
-- ChatThrottleLib:UpdateAvail
-- Update self.avail with how much bandwidth is currently available

function ChatThrottleLib:UpdateAvail()
	local now = GetTime()
	local MAX_CPS = self.MAX_CPS;
	local newavail = MAX_CPS * (now - self.LastAvailUpdate)
	local avail = self.avail

	if now - self.HardThrottlingBeginTime < 5 then
		-- First 5 seconds after startup/zoning: VERY hard clamping to avoid irritating the server rate limiter, it seems very cranky then
		avail = math_min(avail + (newavail*0.1), MAX_CPS*0.5)
		self.bChoking = true
	elseif GetFramerate() < self.MIN_FPS then		-- GetFrameRate call takes ~0.002 secs
		avail = math_min(MAX_CPS, avail + newavail*0.5)
		self.bChoking = true		-- just a statistic
	else
		avail = math_min(self.BURST, avail + newavail)
		self.bChoking = false
	end

	avail = math_max(avail, 0-(MAX_CPS*2))	-- Can go negative when someone is eating bandwidth past the lib. but we refuse to stay silent for more than 2 seconds; if they can do it, we can.

	self.avail = avail
	self.LastAvailUpdate = now

	return avail
end


-----------------------------------------------------------------------
-- Despooling logic
-- Reminder:
-- - We have 3 Priorities, each containing a "Ring" construct ...
-- - ... made up of N "Pipe"s (1 for each destination/pipename)
-- - and each pipe contains messages

local SendAddonMessageResult = Enum.SendAddonMessageResult or {
	Success = 0,
	AddonMessageThrottle = 3,
	NotInGroup = 5,
	ChannelThrottle = 8,
	GeneralError = 9,
}

local function MapToSendResult(ok, ...)
	local result

	if not ok then
		-- The send function itself errored; don't look at anything else.
		result = SendAddonMessageResult.GeneralError
	else
		-- Grab the last return value from the send function and remap
		-- it from a boolean to an enum code. If there are no results,
		-- assume success (true).

		result = select(-1, true, ...)

		if result == true then
			result = SendAddonMessageResult.Success
		elseif result == false then
			result = SendAddonMessageResult.GeneralError
		end
	end

	return result
end

local function IsThrottledSendResult(result)
	return result == SendAddonMessageResult.AddonMessageThrottle
end

-- A copy of this function exists in FrameXML, but for clarity it's here too.
local function CallErrorHandler(...)
	return geterrorhandler()(...)
end

local function PerformSend(sendFunction, ...)
	bMyTraffic = true
	local sendResult = MapToSendResult(xpcall(sendFunction, CallErrorHandler, ...))
	bMyTraffic = false
	return sendResult
end

function ChatThrottleLib:Despool(Prio)
	local ring = Prio.Ring
	while ring.pos and Prio.avail > ring.pos[1].nSize do
		local pipe = ring.pos
		local msg = pipe[1]
		local sendResult = PerformSend(msg.f, unpack(msg, 1, msg.n))

		if IsThrottledSendResult(sendResult) then
			-- Message was throttled; move the pipe into the blocked ring.
			Prio.Ring:Remove(pipe)
			Prio.Blocked:Add(pipe)
		else
			-- Dequeue message after submission.
			table_remove(pipe, 1)
			DelMsg(msg)

			if not pipe[1] then  -- did we remove last msg in this pipe?
				Prio.Ring:Remove(pipe)
				Prio.ByName[pipe.name] = nil
				DelPipe(pipe)
			else
				ring.pos = ring.pos.next
			end

			-- Update bandwidth counters on successful sends.
			local didSend = (sendResult == SendAddonMessageResult.Success)
			if didSend then
				Prio.avail = Prio.avail - msg.nSize
				Prio.nTotalSent = Prio.nTotalSent + msg.nSize
			end

			-- Notify caller of message submission.
			if msg.callbackFn then
				securecallfunction(msg.callbackFn, msg.callbackArg, didSend, sendResult)
			end
		end
	end
end


function ChatThrottleLib.OnEvent(this,event)
	-- v11: We know that the rate limiter is touchy after login. Assume that it's touchy after zoning, too.
	local self = ChatThrottleLib
	if event == "PLAYER_ENTERING_WORLD" then
		self.HardThrottlingBeginTime = GetTime()	-- Throttle hard for a few seconds after zoning
		self.avail = 0
	end
end


function ChatThrottleLib.OnUpdate(this,delay)
	local self = ChatThrottleLib

	self.OnUpdateDelay = self.OnUpdateDelay + delay
	self.BlockedQueuesDelay = self.BlockedQueuesDelay + delay
	if self.OnUpdateDelay < 0.08 then
		return
	end
	self.OnUpdateDelay = 0

	self:UpdateAvail()

	if self.avail < 0  then
		return -- argh. some bastard is spewing stuff past the lib. just bail early to save cpu.
	end

	-- Integrate blocked queues back into their rings periodically.
	if self.BlockedQueuesDelay >= 0.35 then
		for _, Prio in pairs(self.Prio) do
			Ring_Link(Prio.Ring, Prio.Blocked)
		end

		self.BlockedQueuesDelay = 0
	end

	-- See how many of our priorities have queued messages. This is split
	-- into two counters because priorities that consist only of blocked
	-- queues must keep our OnUpdate alive, but shouldn't count toward
	-- bandwidth distribution.
	local nSendablePrios = 0
	local nBlockedPrios = 0

	for prioname, Prio in pairs(self.Prio) do
		if Prio.Ring.pos then
			nSendablePrios = nSendablePrios + 1
		elseif Prio.Blocked.pos then
			nBlockedPrios = nBlockedPrios + 1
		end

		-- Collect unused bandwidth from priorities with nothing to send.
		if not Prio.Ring.pos then
			self.avail = self.avail + Prio.avail
			Prio.avail = 0
		end
	end

	-- Bandwidth reclamation may take us back over the burst cap.
	self.avail = math_min(self.avail, self.BURST)

	-- If we can't currently send on any priorities, stop processing early.
	if nSendablePrios == 0 then
		-- If we're completely out of data to send, disable queue processing.
		if nBlockedPrios == 0 then
			self.bQueueing = false
			self.Frame:Hide()
		end

		return
	end

	-- There's stuff queued. Hand out available bandwidth to priorities as needed and despool their queues
	local avail = self.avail / nSendablePrios
	self.avail = 0

	for prioname, Prio in pairs(self.Prio) do
		if Prio.Ring.pos then
			Prio.avail = Prio.avail + avail
			self:Despool(Prio)
		end
	end
end




-----------------------------------------------------------------------
-- Spooling logic

function ChatThrottleLib:Enqueue(prioname, pipename, msg)
	local Prio = self.Prio[prioname]
	local pipe = Prio.ByName[pipename]
	if not pipe then
		self.Frame:Show()
		pipe = NewPipe()
		pipe.name = pipename
		Prio.ByName[pipename] = pipe
		Prio.Ring:Add(pipe)
	end

	pipe[#pipe + 1] = msg

	self.bQueueing = true
end

function ChatThrottleLib:SendChatMessage(prio, prefix,   text, chattype, language, destination, queueName, callbackFn, callbackArg)
	if not self or not prio or not prefix or not text or not self.Prio[prio] then
		error('Usage: ChatThrottleLib:SendChatMessage("{BULK||NORMAL||ALERT}", "prefix", "text"[, "chattype"[, "language"[, "destination"]]]', 2)
	end
	if callbackFn and type(callbackFn)~="function" then
		error('ChatThrottleLib:ChatMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
	end

	local nSize = text:len()

	if nSize>255 then
		error("ChatThrottleLib:SendChatMessage(): message length cannot exceed 255 bytes", 2)
	end

	nSize = nSize + self.MSG_OVERHEAD

	-- Check if there's room in the global available bandwidth gauge to send directly
	if not self.bQueueing and nSize < self:UpdateAvail() then
		local sendResult = PerformSend(_G.C_ChatInfo.SendChatMessage or _G.SendChatMessage, text, chattype, language, destination)

		if not IsThrottledSendResult(sendResult) then
			local didSend = (sendResult == SendAddonMessageResult.Success)

			if didSend then
				self.avail = self.avail - nSize
				self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
			end

			if callbackFn then
				securecallfunction(callbackFn, callbackArg, didSend, sendResult)
			end

			return
		end
	end

	-- Message needs to be queued
	local msg = NewMsg()
	msg.f = _G.C_ChatInfo.SendChatMessage or _G.SendChatMessage
	msg[1] = text
	msg[2] = chattype or "SAY"
	msg[3] = language
	msg[4] = destination
	msg.n = 4
	msg.nSize = nSize
	msg.callbackFn = callbackFn
	msg.callbackArg = callbackArg

	self:Enqueue(prio, queueName or prefix, msg)
end


local function SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
	local nSize = #text + self.MSG_OVERHEAD

	-- Check if there's room in the global available bandwidth gauge to send directly
	if not self.bQueueing and nSize < self:UpdateAvail() then
		local sendResult = PerformSend(sendFunction, prefix, text, chattype, target)

		if not IsThrottledSendResult(sendResult) then
			local didSend = (sendResult == SendAddonMessageResult.Success)

			if didSend then
				self.avail = self.avail - nSize
				self.Prio[prio].nTotalSent = self.Prio[prio].nTotalSent + nSize
			end

			if callbackFn then
				securecallfunction(callbackFn, callbackArg, didSend, sendResult)
			end

			return
		end
	end

	-- Message needs to be queued
	local msg = NewMsg()
	msg.f = sendFunction
	msg[1] = prefix
	msg[2] = text
	msg[3] = chattype
	msg[4] = target
	msg.n = (target~=nil) and 4 or 3;
	msg.nSize = nSize
	msg.callbackFn = callbackFn
	msg.callbackArg = callbackArg

	self:Enqueue(prio, queueName or prefix, msg)
end


function ChatThrottleLib:SendAddonMessage(prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
	if not self or not prio or not prefix or not text or not chattype or not self.Prio[prio] then
		error('Usage: ChatThrottleLib:SendAddonMessage("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype"[, "target"])', 2)
	elseif callbackFn and type(callbackFn)~="function" then
		error('ChatThrottleLib:SendAddonMessage(): callbackFn: expected function, got '..type(callbackFn), 2)
	elseif #text>255 then
		error("ChatThrottleLib:SendAddonMessage(): message length cannot exceed 255 bytes", 2)
	end

	local sendFunction = _G.C_ChatInfo.SendAddonMessage
	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
end


function ChatThrottleLib:SendAddonMessageLogged(prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
	if not self or not prio or not prefix or not text or not chattype or not self.Prio[prio] then
		error('Usage: ChatThrottleLib:SendAddonMessageLogged("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype"[, "target"])', 2)
	elseif callbackFn and type(callbackFn)~="function" then
		error('ChatThrottleLib:SendAddonMessageLogged(): callbackFn: expected function, got '..type(callbackFn), 2)
	elseif #text>255 then
		error("ChatThrottleLib:SendAddonMessageLogged(): message length cannot exceed 255 bytes", 2)
	end

	local sendFunction = _G.C_ChatInfo.SendAddonMessageLogged
	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, target, queueName, callbackFn, callbackArg)
end

local function BNSendGameDataReordered(prefix, text, _, gameAccountID)
	local bnSendFunc = _G.C_BattleNet and _G.C_BattleNet.SendGameData or _G.BNSendGameData
	return bnSendFunc(gameAccountID, prefix, text)
end

function ChatThrottleLib:BNSendGameData(prio, prefix, text, chattype, gameAccountID, queueName, callbackFn, callbackArg)
	-- Note that this API is intentionally limited to 255 bytes of data
	-- for reasons of traffic fairness, which is less than the 4078 bytes
	-- BNSendGameData natively supports. Additionally, a chat type is required
	-- but must always be set to 'WHISPER' to match what is exposed by the
	-- receipt event.
	--
	-- If splitting messages, callers must also be aware that message
	-- delivery over BNSendGameData is unordered.

	if not self or not prio or not prefix or not text or not gameAccountID or not chattype or not self.Prio[prio] then
		error('Usage: ChatThrottleLib:BNSendGameData("{BULK||NORMAL||ALERT}", "prefix", "text", "chattype", gameAccountID)', 2)
	elseif callbackFn and type(callbackFn)~="function" then
		error('ChatThrottleLib:BNSendGameData(): callbackFn: expected function, got '..type(callbackFn), 2)
	elseif #text>255 then
		error("ChatThrottleLib:BNSendGameData(): message length cannot exceed 255 bytes", 2)
	elseif chattype ~= "WHISPER" then
		error("ChatThrottleLib:BNSendGameData(): chat type must be 'WHISPER'", 2)
	end

	local sendFunction = BNSendGameDataReordered
	SendAddonMessageInternal(self, sendFunction, prio, prefix, text, chattype, gameAccountID, queueName, callbackFn, callbackArg)
end


-----------------------------------------------------------------------
-- Get the ball rolling!

ChatThrottleLib:Init()

--[[ WoWBench debugging snippet
if(WOWB_VER) then
	local function SayTimer()
		print("SAY: "..GetTime().." "..arg1)
	end
	ChatThrottleLib.Frame:SetScript("OnEvent", SayTimer)
	ChatThrottleLib.Frame:RegisterEvent("CHAT_MSG_SAY")
end
]]




-- ========================================
-- File: WeakAuras/Libs/AceSerializer-3.0/AceSerializer-3.0.lua
-- ========================================

--- **AceSerializer-3.0** can serialize any variable (except functions or userdata) into a string format,
-- that can be send over the addon comm channel. AceSerializer was designed to keep all data intact, especially
-- very large numbers or floating point numbers, and table structures. The only caveat currently is, that multiple
-- references to the same table will be send individually.
--
-- **AceSerializer-3.0** can be embeded into your addon, either explicitly by calling AceSerializer:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceSerializer itself.\\
-- It is recommended to embed AceSerializer, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceSerializer.
-- @class file
-- @name AceSerializer-3.0
-- @release $Id: AceSerializer-3.0.lua 1284 2022-09-25 09:15:30Z nevcairiel $
local MAJOR,MINOR = "AceSerializer-3.0", 5
local AceSerializer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceSerializer then return end

-- Lua APIs
local strbyte, strchar, gsub, gmatch, format = string.byte, string.char, string.gsub, string.gmatch, string.format
local assert, error, pcall = assert, error, pcall
local type, tostring, tonumber = type, tostring, tonumber
local pairs, select, frexp = pairs, select, math.frexp
local tconcat = table.concat

-- quick copies of string representations of wonky numbers
local inf = math.huge

local serNaN  -- can't do this in 4.3, see ace3 ticket 268
local serInf, serInfMac = "1.#INF", "inf"
local serNegInf, serNegInfMac = "-1.#INF", "-inf"


-- Serialization functions

local function SerializeStringHelper(ch)	-- Used by SerializeValue for strings
	-- We use \126 ("~") as an escape character for all nonprints plus a few more
	local n = strbyte(ch)
	if n==30 then           -- v3 / ticket 115: catch a nonprint that ends up being "~^" when encoded... DOH
		return "\126\122"
	elseif n<=32 then 			-- nonprint + space
		return "\126"..strchar(n+64)
	elseif n==94 then		-- value separator
		return "\126\125"
	elseif n==126 then		-- our own escape character
		return "\126\124"
	elseif n==127 then		-- nonprint (DEL)
		return "\126\123"
	else
		assert(false)	-- can't be reached if caller uses a sane regex
	end
end

local function SerializeValue(v, res, nres)
	-- We use "^" as a value separator, followed by one byte for type indicator
	local t=type(v)

	if t=="string" then		-- ^S = string (escaped to remove nonprints, "^"s, etc)
		res[nres+1] = "^S"
		res[nres+2] = gsub(v,"[%c \94\126\127]", SerializeStringHelper)
		nres=nres+2

	elseif t=="number" then	-- ^N = number (just tostring()ed) or ^F (float components)
		local str = tostring(v)
		if tonumber(str)==v  --[[not in 4.3 or str==serNaN]] then
			-- translates just fine, transmit as-is
			res[nres+1] = "^N"
			res[nres+2] = str
			nres=nres+2
		elseif v == inf or v == -inf then
			res[nres+1] = "^N"
			res[nres+2] = v == inf and serInf or serNegInf
			nres=nres+2
		else
			local m,e = frexp(v)
			res[nres+1] = "^F"
			res[nres+2] = format("%.0f",m*2^53)	-- force mantissa to become integer (it's originally 0.5--0.9999)
			res[nres+3] = "^f"
			res[nres+4] = tostring(e-53)	-- adjust exponent to counteract mantissa manipulation
			nres=nres+4
		end

	elseif t=="table" then	-- ^T...^t = table (list of key,value pairs)
		nres=nres+1
		res[nres] = "^T"
		for key,value in pairs(v) do
			nres = SerializeValue(key, res, nres)
			nres = SerializeValue(value, res, nres)
		end
		nres=nres+1
		res[nres] = "^t"

	elseif t=="boolean" then	-- ^B = true, ^b = false
		nres=nres+1
		if v then
			res[nres] = "^B"	-- true
		else
			res[nres] = "^b"	-- false
		end

	elseif t=="nil" then		-- ^Z = nil (zero, "N" was taken :P)
		nres=nres+1
		res[nres] = "^Z"

	else
		error(MAJOR..": Cannot serialize a value of type '"..t.."'")	-- can't produce error on right level, this is wildly recursive
	end

	return nres
end



local serializeTbl = { "^1" }	-- "^1" = Hi, I'm data serialized by AceSerializer protocol rev 1

--- Serialize the data passed into the function.
-- Takes a list of values (strings, numbers, booleans, nils, tables)
-- and returns it in serialized form (a string).\\
-- May throw errors on invalid data types.
-- @param ... List of values to serialize
-- @return The data in its serialized form (string)
function AceSerializer:Serialize(...)
	local nres = 1

	for i=1,select("#", ...) do
		local v = select(i, ...)
		nres = SerializeValue(v, serializeTbl, nres)
	end

	serializeTbl[nres+1] = "^^"	-- "^^" = End of serialized data

	return tconcat(serializeTbl, "", 1, nres+1)
end

-- Deserialization functions
local function DeserializeStringHelper(escape)
	if escape<"~\122" then
		return strchar(strbyte(escape,2,2)-64)
	elseif escape=="~\122" then	-- v3 / ticket 115: special case encode since 30+64=94 ("^") - OOPS.
		return "\030"
	elseif escape=="~\123" then
		return "\127"
	elseif escape=="~\124" then
		return "\126"
	elseif escape=="~\125" then
		return "\94"
	end
	error("DeserializeStringHelper got called for '"..escape.."'?!?")  -- can't be reached unless regex is screwed up
end

local function DeserializeNumberHelper(number)
	--[[ not in 4.3 if number == serNaN then
		return 0/0
	else]]if number == serNegInf or number == serNegInfMac then
		return -inf
	elseif number == serInf or number == serInfMac then
		return inf
	else
		return tonumber(number)
	end
end

-- DeserializeValue: worker function for :Deserialize()
-- It works in two modes:
--   Main (top-level) mode: Deserialize a list of values and return them all
--   Recursive (table) mode: Deserialize only a single value (_may_ of course be another table with lots of subvalues in it)
--
-- The function _always_ works recursively due to having to build a list of values to return
--
-- Callers are expected to pcall(DeserializeValue) to trap errors

local function DeserializeValue(iter,single,ctl,data)

	if not single then
		ctl,data = iter()
	end

	if not ctl then
		error("Supplied data misses AceSerializer terminator ('^^')")
	end

	if ctl=="^^" then
		-- ignore extraneous data
		return
	end

	local res

	if ctl=="^S" then
		res = gsub(data, "~.", DeserializeStringHelper)
	elseif ctl=="^N" then
		res = DeserializeNumberHelper(data)
		if not res then
			error("Invalid serialized number: '"..tostring(data).."'")
		end
	elseif ctl=="^F" then     -- ^F<mantissa>^f<exponent>
		local ctl2,e = iter()
		if ctl2~="^f" then
			error("Invalid serialized floating-point number, expected '^f', not '"..tostring(ctl2).."'")
		end
		local m=tonumber(data)
		e=tonumber(e)
		if not (m and e) then
			error("Invalid serialized floating-point number, expected mantissa and exponent, got '"..tostring(m).."' and '"..tostring(e).."'")
		end
		res = m*(2^e)
	elseif ctl=="^B" then	-- yeah yeah ignore data portion
		res = true
	elseif ctl=="^b" then   -- yeah yeah ignore data portion
		res = false
	elseif ctl=="^Z" then	-- yeah yeah ignore data portion
		res = nil
	elseif ctl=="^T" then
		-- ignore ^T's data, future extensibility?
		res = {}
		local k,v
		while true do
			ctl,data = iter()
			if ctl=="^t" then break end	-- ignore ^t's data
			k = DeserializeValue(iter,true,ctl,data)
			if k==nil then
				error("Invalid AceSerializer table format (no table end marker)")
			end
			ctl,data = iter()
			v = DeserializeValue(iter,true,ctl,data)
			if v==nil then
				error("Invalid AceSerializer table format (no table end marker)")
			end
			res[k]=v
		end
	else
		error("Invalid AceSerializer control code '"..ctl.."'")
	end

	if not single then
		return res,DeserializeValue(iter)
	else
		return res
	end
end

--- Deserializes the data into its original values.
-- Accepts serialized data, ignoring all control characters and whitespace.
-- @param str The serialized data (from :Serialize)
-- @return true followed by a list of values, OR false followed by an error message
function AceSerializer:Deserialize(str)
	str = gsub(str, "[%c ]", "")	-- ignore all control characters; nice for embedding in email and stuff

	local iter = gmatch(str, "(^.)([^^]*)")	-- Any ^x followed by string of non-^
	local ctl,data = iter()
	if not ctl or ctl~="^1" then
		-- we purposefully ignore the data portion of the start code, it can be used as an extension mechanism
		return false, "Supplied data is not AceSerializer data (rev 1)"
	end

	return pcall(DeserializeValue, iter)
end


----------------------------------------
-- Base library stuff
----------------------------------------

AceSerializer.internals = {	-- for test scripts
	SerializeValue = SerializeValue,
	SerializeStringHelper = SerializeStringHelper,
}

local mixins = {
	"Serialize",
	"Deserialize",
}

AceSerializer.embeds = AceSerializer.embeds or {}

function AceSerializer:Embed(target)
	for k, v in pairs(mixins) do
		target[v] = self[v]
	end
	self.embeds[target] = true
	return target
end

-- Update embeds
for target, v in pairs(AceSerializer.embeds) do
	AceSerializer:Embed(target)
end


-- ========================================
-- File: WeakAuras/Libs/AceTimer-3.0/AceTimer-3.0.lua
-- ========================================

--- **AceTimer-3.0** provides a central facility for registering timers.
-- AceTimer supports one-shot timers and repeating timers. All timers are stored in an efficient
-- data structure that allows easy dispatching and fast rescheduling. Timers can be registered
-- or canceled at any time, even from within a running timer, without conflict or large overhead.\\
-- AceTimer is currently limited to firing timers at a frequency of 0.01s as this is what the WoW timer API
-- restricts us to.
--
-- All `:Schedule` functions will return a handle to the current timer, which you will need to store if you
-- need to cancel the timer you just registered.
--
-- **AceTimer-3.0** can be embeded into your addon, either explicitly by calling AceTimer:Embed(MyAddon) or by
-- specifying it as an embeded library in your AceAddon. All functions will be available on your addon object
-- and can be accessed directly, without having to explicitly call AceTimer itself.\\
-- It is recommended to embed AceTimer, otherwise you'll have to specify a custom `self` on all calls you
-- make into AceTimer.
-- @class file
-- @name AceTimer-3.0
-- @release $Id: AceTimer-3.0.lua 1342 2024-05-26 11:49:35Z nevcairiel $

local MAJOR, MINOR = "AceTimer-3.0", 17 -- Bump minor on changes
local AceTimer, oldminor = LibStub:NewLibrary(MAJOR, MINOR)

if not AceTimer then return end -- No upgrade needed
AceTimer.activeTimers = AceTimer.activeTimers or {} -- Active timer list
local activeTimers = AceTimer.activeTimers -- Upvalue our private data

-- Lua APIs
local type, unpack, next, error, select = type, unpack, next, error, select
-- WoW APIs
local GetTime, C_TimerAfter = GetTime, C_Timer.After

local function new(self, loop, func, delay, ...)
	if delay < 0.01 then
		delay = 0.01 -- Restrict to the lowest time that the C_Timer API allows us
	end

	local timer = {
		object = self,
		func = func,
		looping = loop,
		argsCount = select("#", ...),
		delay = delay,
		ends = GetTime() + delay,
		...
	}

	activeTimers[timer] = timer

	-- Create new timer closure to wrap the "timer" object
	timer.callback = function()
		if not timer.cancelled then
			if type(timer.func) == "string" then
				-- We manually set the unpack count to prevent issues with an arg set that contains nil and ends with nil
				-- e.g. local t = {1, 2, nil, 3, nil} print(#t) will result in 2, instead of 5. This fixes said issue.
				timer.object[timer.func](timer.object, unpack(timer, 1, timer.argsCount))
			else
				timer.func(unpack(timer, 1, timer.argsCount))
			end

			if timer.looping and not timer.cancelled then
				-- Compensate delay to get a perfect average delay, even if individual times don't match up perfectly
				-- due to fps differences
				local time = GetTime()
				local ndelay = timer.delay - (time - timer.ends)
				-- Ensure the delay doesn't go below the threshold
				if ndelay < 0.01 then ndelay = 0.01 end
				C_TimerAfter(ndelay, timer.callback)
				timer.ends = time + ndelay
			else
				activeTimers[timer.handle or timer] = nil
			end
		end
	end

	C_TimerAfter(delay, timer.callback)
	return timer
end

--- Schedule a new one-shot timer.
-- The timer will fire once in `delay` seconds, unless canceled before.
-- @param func Callback function for the timer pulse (funcref or method name).
-- @param delay Delay for the timer, in seconds.
-- @param ... An optional, unlimited amount of arguments to pass to the callback function.
-- @usage
-- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
--
-- function MyAddOn:OnEnable()
--   self:ScheduleTimer("TimerFeedback", 5)
-- end
--
-- function MyAddOn:TimerFeedback()
--   print("5 seconds passed")
-- end
function AceTimer:ScheduleTimer(func, delay, ...)
	if not func or not delay then
		error(MAJOR..": ScheduleTimer(callback, delay, args...): 'callback' and 'delay' must have set values.", 2)
	end
	if type(func) == "string" then
		if type(self) ~= "table" then
			error(MAJOR..": ScheduleTimer(callback, delay, args...): 'self' - must be a table.", 2)
		elseif not self[func] then
			error(MAJOR..": ScheduleTimer(callback, delay, args...): Tried to register '"..func.."' as the callback, but it doesn't exist in the module.", 2)
		end
	end
	return new(self, nil, func, delay, ...)
end

--- Schedule a repeating timer.
-- The timer will fire every `delay` seconds, until canceled.
-- @param func Callback function for the timer pulse (funcref or method name).
-- @param delay Delay for the timer, in seconds.
-- @param ... An optional, unlimited amount of arguments to pass to the callback function.
-- @usage
-- MyAddOn = LibStub("AceAddon-3.0"):NewAddon("MyAddOn", "AceTimer-3.0")
--
-- function MyAddOn:OnEnable()
--   self.timerCount = 0
--   self.testTimer = self:ScheduleRepeatingTimer("TimerFeedback", 5)
-- end
--
-- function MyAddOn:TimerFeedback()
--   self.timerCount = self.timerCount + 1
--   print(("%d seconds passed"):format(5 * self.timerCount))
--   -- run 30 seconds in total
--   if self.timerCount == 6 then
--     self:CancelTimer(self.testTimer)
--   end
-- end
function AceTimer:ScheduleRepeatingTimer(func, delay, ...)
	if not func or not delay then
		error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): 'callback' and 'delay' must have set values.", 2)
	end
	if type(func) == "string" then
		if type(self) ~= "table" then
			error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): 'self' - must be a table.", 2)
		elseif not self[func] then
			error(MAJOR..": ScheduleRepeatingTimer(callback, delay, args...): Tried to register '"..func.."' as the callback, but it doesn't exist in the module.", 2)
		end
	end
	return new(self, true, func, delay, ...)
end

--- Cancels a timer with the given id, registered by the same addon object as used for `:ScheduleTimer`
-- Both one-shot and repeating timers can be canceled with this function, as long as the `id` is valid
-- and the timer has not fired yet or was canceled before.
-- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
function AceTimer:CancelTimer(id)
	local timer = activeTimers[id]

	if not timer then
		return false
	else
		timer.cancelled = true
		activeTimers[id] = nil
		return true
	end
end

--- Cancels all timers registered to the current addon object ('self')
function AceTimer:CancelAllTimers()
	for k,v in next, activeTimers do
		if v.object == self then
			AceTimer.CancelTimer(self, k)
		end
	end
end

--- Returns the time left for a timer with the given id, registered by the current addon object ('self').
-- This function will return 0 when the id is invalid.
-- @param id The id of the timer, as returned by `:ScheduleTimer` or `:ScheduleRepeatingTimer`
-- @return The time left on the timer.
function AceTimer:TimeLeft(id)
	local timer = activeTimers[id]
	if not timer then
		return 0
	else
		return timer.ends - GetTime()
	end
end


-- ---------------------------------------------------------------------
-- Upgrading

-- Upgrade from old hash-bucket based timers to C_Timer.After timers.
if oldminor and oldminor < 10 then
	-- disable old timer logic
	AceTimer.frame:SetScript("OnUpdate", nil)
	AceTimer.frame:SetScript("OnEvent", nil)
	AceTimer.frame:UnregisterAllEvents()
	-- convert timers
	for object,timers in next, AceTimer.selfs do
		for handle,timer in next, timers do
			if type(timer) == "table" and timer.callback then
				local newTimer
				if timer.delay then
					newTimer = AceTimer.ScheduleRepeatingTimer(timer.object, timer.callback, timer.delay, timer.arg)
				else
					newTimer = AceTimer.ScheduleTimer(timer.object, timer.callback, timer.when - GetTime(), timer.arg)
				end
				-- Use the old handle for old timers
				activeTimers[newTimer] = nil
				activeTimers[handle] = newTimer
				newTimer.handle = handle
			end
		end
	end
	AceTimer.selfs = nil
	AceTimer.hash = nil
	AceTimer.debug = nil
elseif oldminor and oldminor < 17 then
	-- Upgrade from old animation based timers to C_Timer.After timers.
	AceTimer.inactiveTimers = nil
	AceTimer.frame = nil
	local oldTimers = AceTimer.activeTimers
	-- Clear old timer table and update upvalue
	AceTimer.activeTimers = {}
	activeTimers = AceTimer.activeTimers
	for handle, timer in next, oldTimers do
		local newTimer
		-- Stop the old timer animation
		local duration, elapsed = timer:GetDuration(), timer:GetElapsed()
		timer:GetParent():Stop()
		if timer.looping then
			newTimer = AceTimer.ScheduleRepeatingTimer(timer.object, timer.func, duration, unpack(timer.args, 1, timer.argsCount))
		else
			newTimer = AceTimer.ScheduleTimer(timer.object, timer.func, duration - elapsed, unpack(timer.args, 1, timer.argsCount))
		end
		-- Use the old handle for old timers
		activeTimers[newTimer] = nil
		activeTimers[handle] = newTimer
		newTimer.handle = handle
	end

	-- Migrate transitional handles
	if oldminor < 13 and AceTimer.hashCompatTable then
		for handle, id in next, AceTimer.hashCompatTable do
			local t = activeTimers[id]
			if t then
				activeTimers[id] = nil
				activeTimers[handle] = t
				t.handle = handle
			end
		end
		AceTimer.hashCompatTable = nil
	end
end

-- ---------------------------------------------------------------------
-- Embed handling

AceTimer.embeds = AceTimer.embeds or {}

local mixins = {
	"ScheduleTimer", "ScheduleRepeatingTimer",
	"CancelTimer", "CancelAllTimers",
	"TimeLeft"
}

function AceTimer:Embed(target)
	AceTimer.embeds[target] = true
	for _,v in next, mixins do
		target[v] = AceTimer[v]
	end
	return target
end

-- AceTimer:OnEmbedDisable(target)
-- target (object) - target object that AceTimer is embedded in.
--
-- cancel all timers registered for the object
function AceTimer:OnEmbedDisable(target)
	target:CancelAllTimers()
end

for addon in next, AceTimer.embeds do
	AceTimer:Embed(addon)
end


-- ========================================
-- File: WeakAuras/Libs/Archivist/Archivist.lua
-- ========================================

--[[
Archivist - Data management service for WoW Addons
Written in 2019 by Allen Faure (emptyrivers) afaure6@gmail.com

To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide.
This software is distributed without any warranty.
You should have received a copy of the CC0 Public Domain Dedication along with this software.
If not, see http://creativecommons.org/publicdomain/zero/1.0/.
]]

local embedder, namespace = ...
local addonName, Archivist = "Archivist", {}
-- Our only library!
local LibDeflate = LibStub("LibDeflate")

do -- boilerplate & static values
	Archivist.buildDate = "@build-time@"
	Archivist.version = "v1.0.8"
	--[==[@debug@
		Archivist.debug = true
	--@end-debug@]==]

	Archivist.prototypes = {}
	Archivist.storeMap = {}
	Archivist.activeStores = {}
	namespace.Archivist = Archivist
	local unloader = CreateFrame("FRAME")
	unloader:RegisterEvent("PLAYER_LOGOUT")
	unloader:SetScript("OnEvent", function()
		Archivist:DeInitialize()
	end)
	if embedder == "Archivist" then
		-- Archivist is installed as a standalone addon.
		-- The Archive is in the default location, ACHV_DB
		_G.Archivist = Archivist
		local loader = CreateFrame("frame")
		loader:RegisterEvent("ADDON_LOADED")
		loader:SetScript("OnEvent", function(self, _, addon)
			if addon == addonName then
				if type(ACHV_DB) ~= "table" then
					ACHV_DB = {}
				end
				Archivist:Initialize(ACHV_DB)
				self:UnregisterEvent("ADDON_LOADED")
			end
		end)
	end
end

function Archivist:Assert(valid, pattern, ...)
	if not valid then
		if pattern then
		error(pattern:format(...), 2)
		else
		error("Archivist encountered an unknown error.", 2)
		end
	end
end

function Archivist:Warn(valid, pattern, ...) -- Like assert, but doesn't interrupt execution
	if not valid and self.debug then
		if pattern then
			print(pattern:format(...), 2)
		else
			print("Archivist encountered an unknown warning.")
		end
		return true
	end
end

function Archivist:IsInitialized()
	return self.initialized
end

-- Give Archivist its archive to play with. Called automatically, unless Archivist has been embedded.
function Archivist:Initialize(sv)
	do -- arg validation
		self:Assert(not self:IsInitialized(), "Archivist has already been initialized.")
		self:Assert(type(sv) == "table", "Attempt to initialize Archivist SavedVariables with a %q instead of a table.", type(sv))
	end

	self.sv = sv
	self.initialized = true
	for id, prototype in pairs(self.prototypes) do
		self.sv[id] = self.sv[id] or {}
		if prototype.Init then
			prototype:Init()
		end
	end
end

-- Shut Archivist down
function Archivist:DeInitialize()
	if self:IsInitialized() then
		self.initialized = false
		self:CloseAllStores()
		self.sv = nil
	end
end

-- register a store type with Archivist
-- prototype fields:
--  id - unique identifier. Preferably also a descriptive name, like "simple" or "snapshot".
--  version - positive integer. Used for version control, in case any data migrations are needed. Registration will fail if the prototype is outdated.
--  Init - function (optional). If provided, executes exactly once per session, before any other methods are called.
--  Create - function (required). Create a brand new active store object.
--  Update - function (optional). Massage archived data into a format that Open can accept. Useful for data migrations.
--  Open - function (requried). Create from the provided data an active store object. Prototype may assume ownership of the provided data however it wishes.
--  Commit - function (required). Return an image of the data that should be archived.
--  Close - function (required). Release ownership of active store object. Optionally, return image of data to write into archive.
--  Delete - function (optional). If provided, called when a store is deleted. Useful for cleaning up sub stores.
-- Please note that Create, Open, Update (if provided), Commit, and Close may be called at any time if Archivist deems it necessary.
-- Thus, these methods should ideally be as close to purely functional as is practical, to minimize friction.
function Archivist:RegisterStoreType(prototype)
	do -- prototype validation
		self:Assert(type(prototype) == "table", "Invalid argument #1 to RegisterStoreType: Expected table, got %q instead.", type(prototype))
		-- prototype is now guaranteed to be indexable
		self:Assert(type(prototype.id) == "string", "Invalid prototype field 'id': Expected string, got %q instead.", type(prototype.id))
		self:Assert(type(prototype.version) == "number", "Invalid prototype field 'version': Expected number, got %q instead.", type(prototype.version))
		if self:Warn(prototype.version > 0 and prototype.version == math.floor(prototype.version),
			"Prototype %q version expected to be a positive integer, but got %d instead.", prototype.id, prototype.version) then
			return
		end
		local oldPrototype = self.prototypes[prototype.id]
		self:Assert(not oldPrototype or prototype.version >= oldPrototype.version, "Store type %q already exists with a higher version", oldPrototype and oldPrototype.version)
		-- prototype is now guaranteed to be either new or an Update to existing prototype
		self:Assert(prototype.Init == nil or type(prototype.Init) == "function", "Invalid prototype field 'Init': Expected function, got %q instead.", type(prototype.Init))
		self:Assert(type(prototype.Create) == "function", "Invalid prototype field 'Create': Expected function, got %q instead.", type(prototype.Create))
		self:Assert(type(prototype.Open) == "function", "Invalid prototype field 'Open': Expected function, got %q instead.", type(prototype.Open))
		self:Assert(prototype.Update == nil or type(prototype.Update) == "function", "Invalid prototype field 'Update': Expected function, got %q instead.", type(prototype.Update))
		self:Assert(type(prototype.Commit) == "function", "Invalid prototype field 'Commit': Expected function, got %q instead.", type(prototype.Commit))
		self:Assert(type(prototype.Close) == "function", "Invalid prototype field 'Close': Expected function, got %q instead.", type(prototype.Close))
		self:Assert(prototype.Delete == nil or type(prototype.Delete) == "function", "Invalid prototype field 'Delete': Expected function, got %q instead.", type(prototype.Delete))
		-- prototype is now guaranteed to have Init, Create, Open, Update functions, and is thus well-formed.
	end

	local oldPrototype = self.prototypes[prototype.id] -- need in case of closing active stores
	self.prototypes[prototype.id] = {
		id = prototype.id,
		version = prototype.version,
		Init = prototype.Init,
		Create = prototype.Create,
		Update = prototype.Update,
		Open = prototype.Open,
		Commit = prototype.Commit,
		Close = prototype.Close,
		Delete = prototype.Delete
	}
	self.activeStores[prototype.id] = self.activeStores[prototype.id] or {}
	if self:IsInitialized() then
		self.sv[prototype.id] = self.sv[prototype.id] or {}
		if prototype.Init then
			prototype:Init()
		end
		-- if prototype was previously registered, and Archivist is initialized, then there may be open stores of the old prototype.
		-- Close them, Update if necessary, then re-Open them with the new prototype.
		if oldPrototype then
			for storeID, store in pairs(self.activeStores[prototype.id]) do
				local image = oldPrototype:Close(store)
				local saved = self.sv[prototype.id][storeID]
				local shouldReArchive = image ~= nil
				if image == nil then
					image = saved.data
				end
				if prototype.Update then
					local newImage = prototype:Update(image, saved.version)
					if newImage ~= nil then
						image = newImage
						shouldReArchive = true
					end
					saved.version = prototype.version
				end
				self.activeStores[prototype.id][storeID] = prototype:Open(image)
				if shouldReArchive then
					-- a meaningful change to saved data has occurred.
					saved.data = self:Archive(image)
				end
			end
		end
	end
end

do -- function Archive:GenerateID()
	-- adapted from https://gist.github.com/jrus/3197011
	local function randomHex()
		return ('%x'):format(math.random(0, 0xf))
	end

	function Archivist:GenerateID()
		local template ='xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'
		return (template:gsub('x', randomHex))
	end
end

-- creates and opens a new store of the given store type and with the given id (if given)
-- store objects are lightly managed by Archivist. On PLAYER_LOGOUT, all open stores are Closed,
-- and the resultant data is compressed into the archive.
function Archivist:Create(storeType, id, ...)
	do -- arg validation
		self:Assert(type(storeType) == "string" and self.prototypes[storeType], "Store type must be registered before loading data.")
		self:Assert(id == nil or type(id) == "string" and not self.sv[storeType][id], "A store already exists with that id. Did you mean to call Archivist:Open?")
	end

	local store, image = self.prototypes[storeType]:Create(...)
	do -- ensure that store exists and is unique
		self:Assert(store ~= nil, "Failed to create a new store of type %q.", storeType)
		self:Assert(self.storeMap[store] == nil, "Store Type %q produced an store object already registered with Archivist instead of creating a new one.", storeType)
	end

	if id == nil then
		id = self:GenerateID()
	end

	self.activeStores[storeType][id] = store
	self.storeMap[store] = {
		id = id,
		prototype = self.prototypes[storeType],
		type = storeType
	}

	if image == nil then
		-- save initial image via Commit
		image = self.prototypes[storeType]:Commit(store)
	end
	self:Assert(image ~= nil, "Create Verb failed to generate initial image for archive.")
	self.sv[storeType][id] = {
		timestamp = time(),
		version = self.prototypes[storeType].version,
		data = self:Archive(image)
	}

	return store, id
end

-- clones archived data and/or active store object to newId
-- also provides an active store object of the cloned data if openStore is set
function Archivist:Clone(storeType, id, newId, openStore)
	do -- arg validation
		self:Assert(type(storeType) == "string" and self.prototypes[storeType], "Store type must be registered to clone a store.")
		self:Assert(type(id) == "string" and (self.sv[storeType][id] or self.activeStores[storeType][id]), "Unable to clone store: store not found.")
	end

	if type(newId) ~= "string" then
		newId = self:GenerateID()
	end

	self:Assert(not self.sv[storeType][newId], "Store with ID %q already exists. Choose a different ID.")
	if self.activeStores[storeType][id] then
		-- go ahead and commit active store
		self:Commit(storeType, id)
	end

	-- thankfully, strings are easy to copy
	self.sv[storeType][newId] = {
		version = self.prototypes[storeType].version,
		timestamp = time(),
		data = self.sv[storeType][id].data
	}
	if openStore then
		return self:Open(storeType, newId), newId
	else
		return nil, newId
	end
end

function Archivist:CloneStore(store, newId, openStore)
	self:Assert(self.storeMap[store], "Unrecognized store was provided.")
	local info = self.storeMap[store]
	return self:Clone(info.type, info.id, newId, openStore)
end

-- Closes store (if open), then deletes data from archive
-- Prototype is given opportunity to perform actions using image (usually, to delete other sub stores)
-- if store type is not registered, then force flag must be set in order to delete data,
-- to reduce the chance of accidents
function Archivist:Delete(storeType, id, force)
	do -- arg validation
		self:Warn(force or type(storeType == "string") and self.sv[storeType], "There are no stores to delete.")
		self:Assert(force or self.prototypes[storeType], "Store type should be registered before deleting a store. Call Delete again with arg #3 == true to override this.")
	end

	if id and storeType and self.sv[storeType] then
		if self.prototypes[storeType] and self.prototypes[storeType].Delete and self.sv[storeType][id] then
			local image = self.activeStores[storeType][id]
						 and self:Close(self.activeStores[storeType][id])
						 or self:DeArchive(self.sv[storeType][id].data)
			self.prototypes[storeType]:Delete(image)
		end
		self.sv[storeType][id] = nil
	end
end

function Archivist:DeleteStore(store)
	self:Assert(self.storeMap[store], "Unrecognized store was provided.")
	local info = self.storeMap[store]
	return self:Delete(info.type, info.id)
end

-- unpacks data in the archive into an active store object
-- if store is already active, then returns active store object
function Archivist:Open(storeType, id, ...)
	do -- arg validation
		self:Assert(type(storeType) == "string" and self.prototypes[storeType], "Store type must be registered before opening a store.")
		self:Assert(type(id) == "string" and (self.sv[storeType][id] or self.activeStores[storeType][id]), "Could not find a store with that ID. Did you mean to call Archivist:Create?")
	end

	local store = self.activeStores[storeType][id]
	if not store then
		local saved = self.sv[storeType][id]
		local data = self:DeArchive(saved.data)
		local prototype = self.prototypes[storeType]
		-- migrate data...
		if prototype.Update and prototype.version > saved.version then
			local newData = prototype:Update(data, saved.version)
			if newData ~= nil then
				saved.data = self:Archive(newData)
				saved.timestamp = time()
			end
			saved.version = prototype.version
		end
		-- create store object...
		store = prototype:Open(data, ...)
		-- cache it so that we can close it later..
		self.activeStores[storeType][id] = store
		self.storeMap[store] = {
			id = id,
			prototype = self.prototypes[storeType],
			type = storeType
		}
	end
	return store
end

-- DANGEROUS FUNCTION
-- Your data will be lost. All of it. No going back.
-- Don't say I didn't warn you
function Archivist:DeleteAll(storeType)
	if storeType then
		self.sv[storeType] = {}
		for id, store in pairs(self.activeStores[storeType]) do
			self.activeStores[storeType][id] = nil
			self.storeMap[store] = nil
		end
	else
		for id in pairs(self.prototypes) do
			self.sv[id] = {}
			self.activeStores[id] = {}
		end
		self.storeMap = {}
	end
end

-- deactivates store, with one last opportunity to commit data if the prototype chooses to do so
function Archivist:Close(storeType, id)
	do -- arg validation
		self:Assert(type(storeType) == "string" and self.prototypes[storeType], "Closing a store of an unregistered store type doesn't make sense.")
		self:Warn(type(id) == "string" and self.activeStores[storeType][id], "No store with that ID can be found.")
	end

	local store = self.activeStores[storeType][id]
	local saved = self.sv[storeType][id]
	if store then
		local image = self.prototypes[storeType]:Close(store)
		if image ~= nil then
			saved.data = self:Archive(image)
			saved.timestamp = time()
		end
		self.activeStores[storeType][id] = nil
		self.storeMap[store] = nil
	end
end

function Archivist:CloseStore(store)
	self:Assert(self.storeMap[store], "Unrecognized store was provided.")
	local info = self.storeMap[store]
	return self:Close(info.type, info.id)
end

function Archivist:CloseAllStores()
	for storeType, prototype in pairs(self.prototypes) do
		for id, store in pairs(self.activeStores[storeType]) do
			local image = prototype:Close(store)
			local saved = self.sv[storeType][id]
			self.activeStores[storeType] = nil
			if image then
				saved.data = self:Archive(image)
				saved.timestamp = time()
			end
		end
	end
end

-- archives an image of the store object
function Archivist:Commit(storeType, id)
	do -- arg validation
		self:Assert(type(storeType) == "string" and self.prototypes[storeType], "Committing a store of an unregistered store type doesn't make sense.")
		self:Assert(type(id) == "string" and self.activeStores[storeType][id], "No store with that ID can be found.")
	end

	local store = self.activeStores[storeType][id]
	local image = self.prototypes[storeType]:Commit(store)
	local saved = self.sv[storeType][id]
	if image ~= nil then
		saved.data = self:Archive(image)
		saved.timestamp = time()
	end
end

function Archivist:CommitStore(store)
	self:Assert(self.storeMap[store], "Unrecognized store was provided.")
	local info = self.storeMap[store]
	return self:Commit(info.type, info.id)
end

-- opens or creates a storeType, depending on what is appropriate
-- this is the main entry point for other addons who just want their saved data
function Archivist:Load(storeType, id)
	do -- arg validation
		self:Assert(type(storeType) == "string" and self.prototypes[storeType], "Store type must be registered before loading data.")
		self:Assert(id == nil or type(id) == "string", "Store ID must be a string if provided.")
	end

	if id == nil or not self.sv[storeType][id] then
		return self:Create(storeType, id)
	elseif self.activeStores[storeType][id] then
		return self.activeStores[storeType][id]
	else
		return self:Open(storeType, id)
	end
end

function Archivist:Check(storeType, id)
	do -- arg validation
		self:Assert(type(storeType) == "string", "Expected string for storeType, got %q.", type(storeType))
		self:Assert(type(id) == "string", "Expected string for storeID, got %q.", type(id))
	end
	if self.sv[storeType] and self.sv[storeType][id] then
		return true
	else
		return false
	end
end

do -- function Archivist:Archive(data)
	local tinsert, tconcat = table.insert, table.concat
	-- serialized string looks like
	-- <obj1>,<obj2>,...,<objN>,<value>
	-- (in most cases <value> will be just &1)
	-- <objN> is a series of 0 or more ^<value>:<value> pairs
	-- the contents of the string between ^ or : and the next magic character is a string,
	-- unless the first char is the magic #, in which case it is a number.
	-- @ becomes boolean true, $ becomes false
	-- &N is a reference to <objN>
	-- when deserializing, the result of <value> is our result
	local function replace(c) return "\\"..c end
	local function serialize(object)
		local seenObjects = {}
		local serializedObjects = {}
		local function inner(val)
			local valType = type(val)
			if valType == "boolean" then
				return val and "@" or "$"
			elseif valType == "number" then
				return "#" .. val
			elseif valType == "string" then
				-- escape all characters that might be confused as magic otherwise
				return (val:gsub("[\\&,^@$#:]", replace))
			elseif valType == "table" then
				if not seenObjects[val] then
					-- cross referencing is a thing. Not to hard to serialize but do be careful
					local index = #serializedObjects + 1
					seenObjects[val] = index
					local serialized = {}
					serializedObjects[index] = "" -- so that later inserts go to the correct spot
					for k,v in pairs(val) do
						local key, value = inner(k), inner(v)
						if key ~= nil and value ~= nil then
							tinsert(serialized, "^" .. inner(k))
							tinsert(serialized, ":" .. inner(v))
						end
					end
					serializedObjects[index] = tconcat(serialized)
				end
				return "&" .. seenObjects[val]
			end
		end
		tinsert(serializedObjects, inner(object))
		-- ensure that serialized data ends with a comma
		tinsert(serializedObjects, "")
		return tconcat(serializedObjects, ',')
	end

	function Archivist:Archive(data)
		local serialized = serialize(data)
		local compressed = LibDeflate:CompressDeflate(serialized)
		local encoded = LibDeflate:EncodeForPrint(compressed)
		return encoded
	end
end

do -- function Archivist:DeArchive(encoded)
	local escape2unused = {
		["\\"] = "\001",
		["&"] = "\002",
		[","] = "\003",
		["^"] = "\004",
		["@"] = "\005",
		["$"] = "\006",
		["#"] = "\007",
		[":"] = "\008",
	}
	local unused2Escape = tInvert(escape2unused)
	local unused = "[\001-\008]"
	local function unusify(c)
		return escape2unused[c] or c
	end
	local function escapify(c)
		return unused2Escape[c] or c
	end
	local function parse(value, objectList)
		local firstChar = value:sub(1,1)
		local remainder = value:sub(2)
		if firstChar == "@" then
			return true, "BOOL", remainder
		elseif firstChar == "$" then
			return false, "BOOL", remainder
		elseif firstChar == "#" then
			local num, rest = remainder:match("([^\\&,^@$#:]*)(.*)")
			return tonumber(num), "NUMBER", rest
		elseif firstChar == "^" then
			local str, rest = remainder:match("([^:^,]*)(.*)")
			local key = parse(str, objectList)
			return key, "KEY", rest
		elseif firstChar == ":" then
			local str, rest = remainder:match("([^:^,]*)(.*)")
			local val = parse(str, objectList)
			return val, "VALUE", rest
		elseif firstChar == "&" then
			local num, rest = remainder:match("([^\\&,^@$#:]*)(.*)")
			return objectList[tonumber(num)], "OBJECT", rest
		else
			local str, rest = value:match("([^\\&,^@$#:]*)(.*)")
			return str:gsub(unused, escapify), "STRING", rest
		end
	end
	local function deserialize(value)
		-- first, convert escaped magic characters to chars that we'll likely never find naturally
		value = value:gsub("\\([\\&,^@$#:])", unusify)
		-- then, split by comma to get a list of objects
		local serializedObjects = {}
		for piece in value:gmatch("([^,]*),") do
			table.insert(serializedObjects, piece)
		end
		local objects = {}
		-- create one empty object for each object in the list
		for i = 1, #serializedObjects - 1 do
			objects[i] = {}
		end
		for index = 1, #serializedObjects - 1 do
			local str = serializedObjects[index]
			local object = objects[index]
			local mode = "KEY"
			local key
			local newValue, valueType
			while #str > 0 do
				newValue, valueType, str = parse(str, objects)
				Archivist:Assert(valueType == mode, "Encountered unexpected token type while parsing object. Expected %q but got %q.", mode, valueType)
				if valueType == "KEY" then
					key = newValue
					mode = "VALUE"
				else
					mode = "KEY"
					object[key] = newValue
				end
			end
			Archivist:Assert(mode == "KEY", "Encountered end of serialized token unexpectedly.")
		end
		local deserialized, _, remainder = parse(serializedObjects[#serializedObjects], objects)
		Archivist:Assert(#remainder == 0, "Unexpected token at end of serialized string. Expected EOF, got %q.", remainder:sub(1,10))
		return deserialized
	end

	function Archivist:DeArchive(encoded)
		local compressed = LibDeflate:DecodeForPrint(encoded)
		local serialized = LibDeflate:DecompressDeflate(compressed)
		local data = deserialize(serialized)
		return data
	end
end


-- ========================================
-- File: WeakAuras/Libs/Archivist/libs/LibDeflate/LibDeflate.lua
-- ========================================

--[[--
LibDeflate 1.0.0-release <br>
Pure Lua compressor and decompressor with high compression ratio using
DEFLATE/zlib format.

@file LibDeflate.lua
@author Haoqian He (Github: SafeteeWoW; World of Warcraft: Safetyy-Illidan(US))
@copyright LibDeflate <2018> Haoqian He
@license GNU General Public License Version 3 or later

This library is implemented according to the following specifications. <br>
Report a bug if LibDeflate is not fully compliant with those specs. <br>
Both compressors and decompressors have been implemented in the library.<br>
1. RFC1950: DEFLATE Compressed Data Format Specification version 1.3 <br>
https://tools.ietf.org/html/rfc1951 <br>
2. RFC1951: ZLIB Compressed Data Format Specification version 3.3 <br>
https://tools.ietf.org/html/rfc1950 <br>

This library requires Lua 5.1/5.2/5.3 interpreter or LuaJIT v2.0+. <br>
This library does not have any dependencies. <br>
<br>
This file "LibDeflate.lua" is the only source file of
the library. <br>
Submit suggestions or report bugs to
https://github.com/safeteeWow/LibDeflate/issues
]]

--[[
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses/.

Credits:
1. zlib, by Jean-loup Gailly (compression) and Mark Adler (decompression).
	http://www.zlib.net/
	Licensed under zlib License. http://www.zlib.net/zlib_license.html
	For the compression algorithm.
2. puff, by Mark Adler. https://github.com/madler/zlib/tree/master/contrib/puff
	Licensed under zlib License. http://www.zlib.net/zlib_license.html
	For the decompression algorithm.
3. LibCompress, by jjsheets and Galmok of European Stormrage (Horde)
	https://www.wowace.com/projects/libcompress
	Licensed under GPLv2.
	https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
	For the code to create customized codec.
4. WeakAuras2,
	https://github.com/WeakAuras/WeakAuras2
	Licensed under GPLv2.
	For the 6bit encoding and decoding.
]]

--[[
	Curseforge auto-packaging replacements:

	Project Date: 2021-04-30T05:30:18Z
	Project Hash: b2924165b0be53fc68407fa5e4a293b0ff855f4d
	Project Version: v1.0.8
--]]

local LibDeflate

do
	-- Semantic version. all lowercase.
	-- Suffix can be alpha1, alpha2, beta1, beta2, rc1, rc2, etc.
	-- NOTE: Two version numbers needs to modify.
	-- 1. On the top of LibDeflate.lua
	-- 2. HERE
	local _VERSION = "1.0.0-release"

	local _COPYRIGHT =
	"LibDeflate ".._VERSION
	.." Copyright (C) 2018 Haoqian He."
	.." License GPLv3+: GNU GPL version 3 or later"

	-- Register in the World of Warcraft library "LibStub" if detected.
	if LibStub then
		local MAJOR, MINOR = "LibDeflate", -1
		-- When MAJOR is changed, I should name it as LibDeflate2
		local lib, minor = LibStub:GetLibrary(MAJOR, true)
		if lib and minor and minor >= MINOR then -- No need to update.
			return lib
		else -- Update or first time register
			LibDeflate = LibStub:NewLibrary(MAJOR, _VERSION)
			-- NOTE: It is important that new version has implemented
			-- all exported APIs and tables in the old version,
			-- so the old library is fully garbage collected,
			-- and we 100% ensure the backward compatibility.
		end
	else -- "LibStub" is not detected.
		LibDeflate = {}
	end

	LibDeflate._VERSION = _VERSION
	LibDeflate._COPYRIGHT = _COPYRIGHT
end

-- localize Lua api for faster access.
local assert = assert
local error = error
local pairs = pairs
local string_byte = string.byte
local string_char = string.char
local string_find = string.find
local string_gsub = string.gsub
local string_sub = string.sub
local table_concat = table.concat
local table_sort = table.sort
local tostring = tostring
local type = type

-- Converts i to 2^i, (0<=i<=32)
-- This is used to implement bit left shift and bit right shift.
-- "x >> y" in C:   "(x-x%_pow2[y])/_pow2[y]" in Lua
-- "x << y" in C:   "x*_pow2[y]" in Lua
local _pow2 = {}

-- Converts any byte to a character, (0<=byte<=255)
local _byte_to_char = {}

-- _reverseBitsTbl[len][val] stores the bit reverse of
-- the number with bit length "len" and value "val"
-- For example, decimal number 6 with bits length 5 is binary 00110
-- It's reverse is binary 01100,
-- which is decimal 12 and 12 == _reverseBitsTbl[5][6]
-- 1<=len<=9, 0<=val<=2^len-1
-- The reason for 1<=len<=9 is that the max of min bitlen of huffman code
-- of a huffman alphabet is 9?
local _reverse_bits_tbl = {}

-- Convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code (257<=code<=285)
local _length_to_deflate_code = {}

-- convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code extra bits.
local _length_to_deflate_extra_bits = {}

-- Convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code extra bit length.
local _length_to_deflate_extra_bitlen = {}

-- Convert a small LZ77 distance (1<=dist<=256) to a deflate code.
local _dist256_to_deflate_code = {}

-- Convert a small LZ77 distance (1<=dist<=256) to
-- a deflate distance code extra bits.
local _dist256_to_deflate_extra_bits = {}

-- Convert a small LZ77 distance (1<=dist<=256) to
-- a deflate distance code extra bit length.
local _dist256_to_deflate_extra_bitlen = {}

-- Convert a literal/LZ77_length deflate code to LZ77 base length
-- The key of the table is (code - 256), 257<=code<=285
local _literal_deflate_code_to_base_len = {
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258,
}

-- Convert a literal/LZ77_length deflate code to base LZ77 length extra bits
-- The key of the table is (code - 256), 257<=code<=285
local _literal_deflate_code_to_extra_bitlen = {
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,
}

-- Convert a distance deflate code to base LZ77 distance. (0<=code<=29)
local _dist_deflate_code_to_base_dist = {
	[0] = 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	8193, 12289, 16385, 24577,
}

-- Convert a distance deflate code to LZ77 bits length. (0<=code<=29)
local _dist_deflate_code_to_extra_bitlen = {
	[0] = 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
	7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
}

-- The code order of the first huffman header in the dynamic deflate block.
-- See the page 12 of RFC1951
local _rle_codes_huffman_bitlen_order = {16, 17, 18,
	0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
}

-- The following tables are used by fixed deflate block.
-- The value of these tables are assigned at the bottom of the source.

-- The huffman code of the literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_code

-- Convert huffman code of the literal/LZ77_length to deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_to_deflate_code

-- The bit length of the huffman code of literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_bitlen

-- The count of each bit length of the literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_bitlen_count

-- The huffman code of the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_code

-- Convert huffman code of the distance to deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_to_deflate_code

-- The bit length of the huffman code of the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_bitlen

-- The count of each bit length of the huffman code of
-- the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_bitlen_count

for i = 0, 255 do
	_byte_to_char[i] = string_char(i)
end

do
	local pow = 1
	for i = 0, 32 do
		_pow2[i] = pow
		pow = pow * 2
	end
end

for i = 1, 9 do
	_reverse_bits_tbl[i] = {}
	for j=0, _pow2[i+1]-1 do
		local reverse = 0
		local value = j
		for _ = 1, i do
			-- The following line is equivalent to "res | (code %2)" in C.
			reverse = reverse - reverse%2
				+ (((reverse%2==1) or (value % 2) == 1) and 1 or 0)
			value = (value-value%2)/2
			reverse = reverse * 2
		end
		_reverse_bits_tbl[i][j] = (reverse-reverse%2)/2
	end
end

-- The source code is written according to the pattern in the numbers
-- in RFC1951 Page10.
do
	local a = 18
	local b = 16
	local c = 265
	local bitlen = 1
	for len = 3, 258 do
		if len <= 10 then
			_length_to_deflate_code[len] = len + 254
			_length_to_deflate_extra_bitlen[len] = 0
		elseif len == 258 then
			_length_to_deflate_code[len] = 285
			_length_to_deflate_extra_bitlen[len] = 0
		else
			if len > a then
				a = a + b
				b = b * 2
				c = c + 4
				bitlen = bitlen + 1
			end
			local t = len-a-1+b/2
			_length_to_deflate_code[len] = (t-(t%(b/8)))/(b/8) + c
			_length_to_deflate_extra_bitlen[len] = bitlen
			_length_to_deflate_extra_bits[len] = t % (b/8)
		end
	end
end

-- The source code is written according to the pattern in the numbers
-- in RFC1951 Page11.
do
	_dist256_to_deflate_code[1] = 0
	_dist256_to_deflate_code[2] = 1
	_dist256_to_deflate_extra_bitlen[1] = 0
	_dist256_to_deflate_extra_bitlen[2] = 0

	local a = 3
	local b = 4
	local code = 2
	local bitlen = 0
	for dist = 3, 256 do
		if dist > b then
			a = a * 2
			b = b * 2
			code = code + 2
			bitlen = bitlen + 1
		end
		_dist256_to_deflate_code[dist] = (dist <= a) and code or (code+1)
		_dist256_to_deflate_extra_bitlen[dist] = (bitlen < 0) and 0 or bitlen
		if b >= 8 then
			_dist256_to_deflate_extra_bits[dist] = (dist-b/2-1) % (b/4)
		end
	end
end

--- Calculate the Adler-32 checksum of the string. <br>
-- See RFC1950 Page 9 https://tools.ietf.org/html/rfc1950 for the
-- definition of Adler-32 checksum.
-- @param str [string] the input string to calcuate its Adler-32 checksum.
-- @return [integer] The Adler-32 checksum, which is greater or equal to 0,
-- and less than 2^32 (4294967296).
function LibDeflate:Adler32(str)
	-- This function is loop unrolled by better performance.
	--
	-- Here is the minimum code:
	--
	-- local a = 1
	-- local b = 0
	-- for i=1, #str do
	-- 		local s = string.byte(str, i, i)
	-- 		a = (a+s)%65521
	-- 		b = (b+a)%65521
	-- 		end
	-- return b*65536+a
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:Adler32(str):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	local strlen = #str

	local i = 1
	local a = 1
	local b = 0
	while i <= strlen - 15 do
		local x1, x2, x3, x4, x5, x6, x7, x8,
			x9, x10, x11, x12, x13, x14, x15, x16 = string_byte(str, i, i+15)
		b = (b+16*a+16*x1+15*x2+14*x3+13*x4+12*x5+11*x6+10*x7+9*x8+8*x9
			+7*x10+6*x11+5*x12+4*x13+3*x14+2*x15+x16)%65521
		a = (a+x1+x2+x3+x4+x5+x6+x7+x8+x9+x10+x11+x12+x13+x14+x15+x16)%65521
		i =  i + 16
	end
	while (i <= strlen) do
		local x = string_byte(str, i, i)
		a = (a + x) % 65521
		b = (b + a) % 65521
		i = i + 1
	end
	return (b*65536+a) % 4294967296
end

-- Compare adler32 checksum.
-- adler32 should be compared with a mod to avoid sign problem
-- 4072834167 (unsigned) is the same adler32 as -222133129
local function IsEqualAdler32(actual, expected)
	return (actual % 4294967296) == (expected % 4294967296)
end

--- Create a preset dictionary.
--
-- This function is not fast, and the memory consumption of the produced
-- dictionary is about 50 times of the input string. Therefore, it is suggestted
-- to run this function only once in your program.
--
-- It is very important to know that if you do use a preset dictionary,
-- compressors and decompressors MUST USE THE SAME dictionary. That is,
-- dictionary must be created using the same string. If you update your program
-- with a new dictionary, people with the old version won't be able to transmit
-- data with people with the new version. Therefore, changing the dictionary
-- must be very careful.
--
-- The parameters "strlen" and "adler32" add a layer of verification to ensure
-- the parameter "str" is not modified unintentionally during the program
-- development.
--
-- @usage local dict_str = "1234567890"
--
-- -- print(dict_str:len(), LibDeflate:Adler32(dict_str))
-- -- Hardcode the print result below to verify it to avoid acciently
-- -- modification of 'str' during the program development.
-- -- string length: 10, Adler-32: 187433486,
-- -- Don't calculate string length and its Adler-32 at run-time.
--
-- local dict = LibDeflate:CreateDictionary(dict_str, 10, 187433486)
--
-- @param str [string] The string used as the preset dictionary. <br>
-- You should put stuffs that frequently appears in the dictionary
-- string and preferablely put more frequently appeared stuffs toward the end
-- of the string. <br>
-- Empty string and string longer than 32768 bytes are not allowed.
-- @param strlen [integer] The length of 'str'. Please pass in this parameter
-- as a hardcoded constant, in order to verify the content of 'str'. The value
-- of this parameter should be known before your program runs.
-- @param adler32 [integer] The Adler-32 checksum of 'str'. Please pass in this
-- parameter as a hardcoded constant, in order to verify the content of 'str'.
-- The value of this parameter should be known before your program runs.
-- @return  [table] The dictionary used for preset dictionary compression and
-- decompression.
-- @raise error if 'strlen' does not match the length of 'str',
-- or if 'adler32' does not match the Adler-32 checksum of 'str'.
function LibDeflate:CreateDictionary(str, strlen, adler32)
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	if type(strlen) ~= "number" then
		error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'strlen' - number expected got '%s'."):format(
			type(strlen)), 2)
	end
	if type(adler32) ~= "number" then
		error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'adler32' - number expected got '%s'."):format(
			type(adler32)), 2)
	end
	if strlen ~= #str then
		error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
				.." 'strlen' does not match the actual length of 'str'."
				.." 'strlen': %u, '#str': %u ."
				.." Please check if 'str' is modified unintentionally.")
			:format(strlen, #str))
	end
	if strlen == 0 then
		error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'str' - Empty string is not allowed."), 2)
	end
	if strlen > 32768 then
		error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
			.." 'str' - string longer than 32768 bytes is not allowed."
			 .." Got %d bytes."):format(strlen), 2)
	end
	local actual_adler32 = self:Adler32(str)
	if not IsEqualAdler32(adler32, actual_adler32) then
		error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):"
				.." 'adler32' does not match the actual adler32 of 'str'."
				.." 'adler32': %u, 'Adler32(str)': %u ."
				.." Please check if 'str' is modified unintentionally.")
			:format(adler32, actual_adler32))
	end

	local dictionary = {}
	dictionary.adler32 = adler32
	dictionary.hash_tables = {}
	dictionary.string_table = {}
	dictionary.strlen = strlen
	local string_table = dictionary.string_table
	local hash_tables = dictionary.hash_tables
	string_table[1] = string_byte(str, 1, 1)
	string_table[2] = string_byte(str, 2, 2)
	if strlen >= 3 then
		local i = 1
		local hash = string_table[1]*256+string_table[2]
		while i <= strlen - 2 - 3 do
			local x1, x2, x3, x4 = string_byte(str, i+2, i+5)
			string_table[i+2] = x1
			string_table[i+3] = x2
			string_table[i+4] = x3
			string_table[i+5] = x4
			hash = (hash*256+x1)%16777216
			local t = hash_tables[hash]
			if not t then t = {}; hash_tables[hash] = t end
			t[#t+1] = i-strlen
			i = i + 1
			hash = (hash*256+x2)%16777216
			t = hash_tables[hash]
			if not t then t = {}; hash_tables[hash] = t end
			t[#t+1] = i-strlen
			i = i + 1
			hash = (hash*256+x3)%16777216
			t = hash_tables[hash]
			if not t then t = {}; hash_tables[hash] = t end
			t[#t+1] = i-strlen
			i = i + 1
			hash = (hash*256+x4)%16777216
			t = hash_tables[hash]
			if not t then t = {}; hash_tables[hash] = t end
			t[#t+1] = i-strlen
			i = i + 1
		end
		while i <= strlen - 2 do
			local x = string_byte(str, i+2)
			string_table[i+2] = x
			hash = (hash*256+x)%16777216
			local t = hash_tables[hash]
			if not t then t = {}; hash_tables[hash] = t end
			t[#t+1] = i-strlen
			i = i + 1
		end
	end
	return dictionary
end

-- Check if the dictionary is valid.
-- @param dictionary The preset dictionary for compression and decompression.
-- @return true if valid, false if not valid.
-- @return if not valid, the error message.
local function IsValidDictionary(dictionary)
	if type(dictionary) ~= "table" then
		return false, ("'dictionary' - table expected got '%s'.")
			:format(type(dictionary))
	end
	if type(dictionary.adler32) ~= "number"
		or type(dictionary.string_table) ~= "table"
		or type(dictionary.strlen) ~= "number"
		or dictionary.strlen <= 0
		or dictionary.strlen > 32768
		or dictionary.strlen ~= #dictionary.string_table
		or type(dictionary.hash_tables) ~= "table"
		then
		return false, ("'dictionary' - corrupted dictionary.")
			:format(type(dictionary))
	end
	return true, ""
end

--[[
	key of the configuration table is the compression level,
	and its value stores the compression setting.
	These numbers come from zlib source code.

	Higher compression level usually means better compression.
	(Because LibDeflate uses a simplified version of zlib algorithm,
	there is no guarantee that higher compression level does not create
	bigger file than lower level, but I can say it's 99% likely)

	Be careful with the high compression level. This is a pure lua
	implementation compressor/decompressor, which is significant slower than
	a C/C++ equivalant compressor/decompressor. Very high compression level
	costs significant more CPU time, and usually compression size won't be
	significant smaller when you increase compression level by 1, when the
	level is already very high. Benchmark yourself if you can afford it.

	See also https://github.com/madler/zlib/blob/master/doc/algorithm.txt,
	https://github.com/madler/zlib/blob/master/deflate.c for more information.

	The meaning of each field:
	@field 1 use_lazy_evaluation:
		true/false. Whether the program uses lazy evaluation.
		See what is "lazy evaluation" in the link above.
		lazy_evaluation improves ratio, but relatively slow.
	@field 2 good_prev_length:
		Only effective if lazy is set, Only use 1/4 of max_chain,
		if prev length of lazy match is above this.
	@field 3 max_insert_length/max_lazy_match:
		If not using lazy evaluation,
		insert new strings in the hash table only if the match length is not
		greater than this length.
		If using lazy evaluation, only continue lazy evaluation,
		if previous match length is strictly smaller than this value.
	@field 4 nice_length:
		Number. Don't continue to go down the hash chain,
		if match length is above this.
	@field 5 max_chain:
		Number. The maximum number of hash chains we look.
--]]
local _compression_level_configs = {
	[0] = {false, nil, 0, 0, 0}, -- level 0, no compression
	[1] = {false, nil, 4, 8, 4}, -- level 1, similar to zlib level 1
	[2] = {false, nil, 5, 18, 8}, -- level 2, similar to zlib level 2
	[3] = {false, nil, 6, 32, 32},	-- level 3, similar to zlib level 3
	[4] = {true, 4,	4, 16, 16},	-- level 4, similar to zlib level 4
	[5] = {true, 8,	16,	32,	32}, -- level 5, similar to zlib level 5
	[6] = {true, 8,	16,	128, 128}, -- level 6, similar to zlib level 6
	[7] = {true, 8,	32,	128, 256}, -- (SLOW) level 7, similar to zlib level 7
	[8] = {true, 32, 128, 258, 1024} , --(SLOW) level 8,similar to zlib level 8
	[9] = {true, 32, 258, 258, 4096},
		-- (VERY SLOW) level 9, similar to zlib level 9
}

-- Check if the compression/decompression arguments is valid
-- @param str The input string.
-- @param check_dictionary if true, check if dictionary is valid.
-- @param dictionary The preset dictionary for compression and decompression.
-- @param check_configs if true, check if config is valid.
-- @param configs The compression configuration table
-- @return true if valid, false if not valid.
-- @return if not valid, the error message.
local function IsValidArguments(str,
	check_dictionary, dictionary,
	check_configs, configs)

	if type(str) ~= "string" then
		return false,
			("'str' - string expected got '%s'."):format(type(str))
	end
	if check_dictionary then
		local dict_valid, dict_err = IsValidDictionary(dictionary)
		if not dict_valid then
			return false, dict_err
		end
	end
	if check_configs then
		local type_configs = type(configs)
		if type_configs ~= "nil" and type_configs ~= "table" then
			return false,
			("'configs' - nil or table expected got '%s'.")
				:format(type(configs))
		end
		if type_configs == "table" then
			for k, v in pairs(configs) do
				if k ~= "level" and k ~= "strategy" then
					return false,
					("'configs' - unsupported table key in the configs: '%s'.")
					:format(k)
				elseif k == "level" and not _compression_level_configs[v] then
					return false,
					("'configs' - unsupported 'level': %s."):format(tostring(v))
				elseif k == "strategy" and v ~= "fixed" and v ~= "huffman_only"
						and v ~= "dynamic" then
						-- random_block_type is for testing purpose
					return false, ("'configs' - unsupported 'strategy': '%s'.")
						:format(tostring(v))
				end
			end
		end
	end
	return true, ""
end



--[[ --------------------------------------------------------------------------
	Compress code
--]] --------------------------------------------------------------------------

-- partial flush to save memory
local _FLUSH_MODE_MEMORY_CLEANUP = 0
-- full flush with partial bytes
local _FLUSH_MODE_OUTPUT = 1
-- write bytes to get to byte boundary
local _FLUSH_MODE_BYTE_BOUNDARY = 2
-- no flush, just get num of bits written so far
local _FLUSH_MODE_NO_FLUSH = 3

--[[
	Create an empty writer to easily write stuffs as the unit of bits.
	Return values:
	1. WriteBits(code, bitlen):
	2. WriteString(str):
	3. Flush(mode):
--]]
local function CreateWriter()
	local buffer_size = 0
	local cache = 0
	local cache_bitlen = 0
	local total_bitlen = 0
	local buffer = {}
	-- When buffer is big enough, flush into result_buffer to save memory.
	local result_buffer = {}

	-- Write bits with value "value" and bit length of "bitlen" into writer.
	-- @param value: The value being written
	-- @param bitlen: The bit length of "value"
	-- @return nil
	local function WriteBits(value, bitlen)
		cache = cache + value * _pow2[cache_bitlen]
		cache_bitlen = cache_bitlen + bitlen
		total_bitlen = total_bitlen + bitlen
		-- Only bulk to buffer every 4 bytes. This is quicker.
		if cache_bitlen >= 32 then
			buffer_size = buffer_size + 1
			buffer[buffer_size] =
				_byte_to_char[cache % 256]
				.._byte_to_char[((cache-cache%256)/256 % 256)]
				.._byte_to_char[((cache-cache%65536)/65536 % 256)]
				.._byte_to_char[((cache-cache%16777216)/16777216 % 256)]
			local rshift_mask = _pow2[32 - cache_bitlen + bitlen]
			cache = (value - value%rshift_mask)/rshift_mask
			cache_bitlen = cache_bitlen - 32
		end
	end

	-- Write the entire string into the writer.
	-- @param str The string being written
	-- @return nil
	local function WriteString(str)
		for _ = 1, cache_bitlen, 8 do
			buffer_size = buffer_size + 1
			buffer[buffer_size] = string_char(cache % 256)
			cache = (cache-cache%256)/256
		end
		cache_bitlen = 0
		buffer_size = buffer_size + 1
		buffer[buffer_size] = str
		total_bitlen = total_bitlen + #str*8
	end

	-- Flush current stuffs in the writer and return it.
	-- This operation will free most of the memory.
	-- @param mode See the descrtion of the constant and the source code.
	-- @return The total number of bits stored in the writer right now.
	-- for byte boundary mode, it includes the padding bits.
	-- for output mode, it does not include padding bits.
	-- @return Return the outputs if mode is output.
	local function FlushWriter(mode)
		if mode == _FLUSH_MODE_NO_FLUSH then
			return total_bitlen
		end

		if mode == _FLUSH_MODE_OUTPUT
			or mode == _FLUSH_MODE_BYTE_BOUNDARY then
			-- Full flush, also output cache.
			-- Need to pad some bits if cache_bitlen is not multiple of 8.
			local padding_bitlen = (8 - cache_bitlen % 8) % 8

			if cache_bitlen > 0 then
				-- padding with all 1 bits, mainly because "\000" is not
				-- good to be tranmitted. I do this so "\000" is a little bit
				-- less frequent.
				cache = cache - _pow2[cache_bitlen]
					+ _pow2[cache_bitlen+padding_bitlen]
				for _ = 1, cache_bitlen, 8 do
					buffer_size = buffer_size + 1
					buffer[buffer_size] = _byte_to_char[cache % 256]
					cache = (cache-cache%256)/256
				end

				cache = 0
				cache_bitlen = 0
			end
			if mode == _FLUSH_MODE_BYTE_BOUNDARY then
				total_bitlen = total_bitlen + padding_bitlen
				return total_bitlen
			end
		end

		local flushed = table_concat(buffer)
		buffer = {}
		buffer_size = 0
		result_buffer[#result_buffer+1] = flushed

		if mode == _FLUSH_MODE_MEMORY_CLEANUP then
			return total_bitlen
		else
			return total_bitlen, table_concat(result_buffer)
		end
	end

	return WriteBits, WriteString, FlushWriter
end

-- Push an element into a max heap
-- @param heap A max heap whose max element is at index 1.
-- @param e The element to be pushed. Assume element "e" is a table
--  and comparison is done via its first entry e[1]
-- @param heap_size current number of elements in the heap.
--  NOTE: There may be some garbage stored in
--  heap[heap_size+1], heap[heap_size+2], etc..
-- @return nil
local function MinHeapPush(heap, e, heap_size)
	heap_size = heap_size + 1
	heap[heap_size] = e
	local value = e[1]
	local pos = heap_size
	local parent_pos = (pos-pos%2)/2

	while (parent_pos >= 1 and heap[parent_pos][1] > value) do
		local t = heap[parent_pos]
		heap[parent_pos] = e
		heap[pos] = t
		pos = parent_pos
		parent_pos = (parent_pos-parent_pos%2)/2
	end
end

-- Pop an element from a max heap
-- @param heap A max heap whose max element is at index 1.
-- @param heap_size current number of elements in the heap.
-- @return the poped element
-- Note: This function does not change table size of "heap" to save CPU time.
local function MinHeapPop(heap, heap_size)
	local top = heap[1]
	local e = heap[heap_size]
	local value = e[1]
	heap[1] = e
	heap[heap_size] = top
	heap_size = heap_size - 1

	local pos = 1
	local left_child_pos = pos * 2
	local right_child_pos = left_child_pos + 1

	while (left_child_pos <= heap_size) do
		local left_child = heap[left_child_pos]
		if (right_child_pos <= heap_size
			and heap[right_child_pos][1] < left_child[1]) then
			local right_child = heap[right_child_pos]
			if right_child[1] < value then
				heap[right_child_pos] = e
				heap[pos] = right_child
				pos = right_child_pos
				left_child_pos = pos * 2
				right_child_pos = left_child_pos + 1
			else
				break
			end
		else
			if left_child[1] < value then
				heap[left_child_pos] = e
				heap[pos] = left_child
				pos = left_child_pos
				left_child_pos = pos * 2
				right_child_pos = left_child_pos + 1
			else
				break
			end
		end
	end

	return top
end

-- Deflate defines a special huffman tree, which is unique once the bit length
-- of huffman code of all symbols are known.
-- @param bitlen_count Number of symbols with a specific bitlen
-- @param symbol_bitlen The bit length of a symbol
-- @param max_symbol The max symbol among all symbols,
--		which is (number of symbols - 1)
-- @param max_bitlen The max huffman bit length among all symbols.
-- @return The huffman code of all symbols.
local function GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens
		, max_symbol, max_bitlen)
	local huffman_code = 0
	local next_codes = {}
	local symbol_huffman_codes = {}
	for bitlen = 1, max_bitlen do
		huffman_code = (huffman_code+(bitlen_counts[bitlen-1] or 0))*2
		next_codes[bitlen] = huffman_code
	end
	for symbol = 0, max_symbol do
		local bitlen = symbol_bitlens[symbol]
		if bitlen then
			huffman_code = next_codes[bitlen]
			next_codes[bitlen] = huffman_code + 1

			-- Reverse the bits of huffman code,
			-- because most signifant bits of huffman code
			-- is stored first into the compressed data.
			-- @see RFC1951 Page5 Section 3.1.1
			if bitlen <= 9 then -- Have cached reverse for small bitlen.
				symbol_huffman_codes[symbol] =
					_reverse_bits_tbl[bitlen][huffman_code]
			else
				local reverse = 0
				for _ = 1, bitlen do
					reverse = reverse - reverse%2
						+ (((reverse%2==1)
							or (huffman_code % 2) == 1) and 1 or 0)
					huffman_code = (huffman_code-huffman_code%2)/2
					reverse = reverse*2
				end
				symbol_huffman_codes[symbol] = (reverse-reverse%2)/2
			end
		end
	end
	return symbol_huffman_codes
end

-- A helper function to sort heap elements
-- a[1], b[1] is the huffman frequency
-- a[2], b[2] is the symbol value.
local function SortByFirstThenSecond(a, b)
	return a[1] < b[1] or
		(a[1] == b[1] and a[2] < b[2])
end

-- Calculate the huffman bit length and huffman code.
-- @param symbol_count: A table whose table key is the symbol, and table value
--		is the symbol frenquency (nil means 0 frequency).
-- @param max_bitlen: See description of return value.
-- @param max_symbol: The maximum symbol
-- @return a table whose key is the symbol, and the value is the huffman bit
--		bit length. We guarantee that all bit length <= max_bitlen.
--		For 0<=symbol<=max_symbol, table value could be nil if the frequency
--		of the symbol is 0 or nil.
-- @return a table whose key is the symbol, and the value is the huffman code.
-- @return a number indicating the maximum symbol whose bitlen is not 0.
local function GetHuffmanBitlenAndCode(symbol_counts, max_bitlen, max_symbol)
	local heap_size
	local max_non_zero_bitlen_symbol = -1
	local leafs = {}
	local heap = {}
	local symbol_bitlens = {}
	local symbol_codes = {}
	local bitlen_counts = {}

	--[[
		tree[1]: weight, temporarily used as parent and bitLengths
		tree[2]: symbol
		tree[3]: left child
		tree[4]: right child
	--]]
	local number_unique_symbols = 0
	for symbol, count in pairs(symbol_counts) do
		number_unique_symbols = number_unique_symbols + 1
		leafs[number_unique_symbols] = {count, symbol}
	end

	if (number_unique_symbols == 0) then
		-- no code.
		return {}, {}, -1
	elseif (number_unique_symbols == 1) then
		-- Only one code. In this case, its huffman code
		-- needs to be assigned as 0, and bit length is 1.
		-- This is the only case that the return result
		-- represents an imcomplete huffman tree.
		local symbol = leafs[1][2]
		symbol_bitlens[symbol] = 1
		symbol_codes[symbol] = 0
		return symbol_bitlens, symbol_codes, symbol
	else
		table_sort(leafs, SortByFirstThenSecond)
		heap_size = number_unique_symbols
		for i = 1, heap_size do
			heap[i] = leafs[i]
		end

		while (heap_size > 1) do
			-- Note: pop does not change table size of heap
			local leftChild = MinHeapPop(heap, heap_size)
			heap_size = heap_size - 1
			local rightChild = MinHeapPop(heap, heap_size)
			heap_size = heap_size - 1
			local newNode =
				{leftChild[1]+rightChild[1], -1, leftChild, rightChild}
			MinHeapPush(heap, newNode, heap_size)
			heap_size = heap_size + 1
		end

		-- Number of leafs whose bit length is greater than max_len.
		local number_bitlen_overflow = 0

		-- Calculate bit length of all nodes
		local fifo = {heap[1], 0, 0, 0} -- preallocate some spaces.
		local fifo_size = 1
		local index = 1
		heap[1][1] = 0
		while (index <= fifo_size) do -- Breath first search
			local e = fifo[index]
			local bitlen = e[1]
			local symbol = e[2]
			local left_child = e[3]
			local right_child = e[4]
			if left_child then
				fifo_size = fifo_size + 1
				fifo[fifo_size] = left_child
				left_child[1] = bitlen + 1
			end
			if right_child then
				fifo_size = fifo_size + 1
				fifo[fifo_size] = right_child
				right_child[1] = bitlen + 1
			end
			index = index + 1

			if (bitlen > max_bitlen) then
				number_bitlen_overflow = number_bitlen_overflow + 1
				bitlen = max_bitlen
			end
			if symbol >= 0 then
				symbol_bitlens[symbol] = bitlen
				max_non_zero_bitlen_symbol =
					(symbol > max_non_zero_bitlen_symbol)
					and symbol or max_non_zero_bitlen_symbol
				bitlen_counts[bitlen] = (bitlen_counts[bitlen] or 0) + 1
			end
		end

		-- Resolve bit length overflow
		-- @see ZLib/trees.c:gen_bitlen(s, desc), for reference
		if (number_bitlen_overflow > 0) then
			repeat
				local bitlen = max_bitlen - 1
				while ((bitlen_counts[bitlen] or 0) == 0) do
					bitlen = bitlen - 1
				end
				-- move one leaf down the tree
				bitlen_counts[bitlen] = bitlen_counts[bitlen] - 1
				-- move one overflow item as its brother
				bitlen_counts[bitlen+1] = (bitlen_counts[bitlen+1] or 0) + 2
				bitlen_counts[max_bitlen] = bitlen_counts[max_bitlen] - 1
				number_bitlen_overflow = number_bitlen_overflow - 2
			until (number_bitlen_overflow <= 0)

			index = 1
			for bitlen = max_bitlen, 1, -1 do
				local n = bitlen_counts[bitlen] or 0
				while (n > 0) do
					local symbol = leafs[index][2]
					symbol_bitlens[symbol] = bitlen
					n = n - 1
					index = index + 1
				end
			end
		end

		symbol_codes = GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens,
				max_symbol, max_bitlen)
		return symbol_bitlens, symbol_codes, max_non_zero_bitlen_symbol
	end
end

-- Calculate the first huffman header in the dynamic huffman block
-- @see RFC1951 Page 12
-- @param lcode_bitlen: The huffman bit length of literal/LZ77_length.
-- @param max_non_zero_bitlen_lcode: The maximum literal/LZ77_length symbol
--		whose huffman bit length is not zero.
-- @param dcode_bitlen: The huffman bit length of LZ77 distance.
-- @param max_non_zero_bitlen_dcode: The maximum LZ77 distance symbol
--		whose huffman bit length is not zero.
-- @return The run length encoded codes.
-- @return The extra bits. One entry for each rle code that needs extra bits.
--		(code == 16 or 17 or 18).
-- @return The count of appearance of each rle codes.
local function RunLengthEncodeHuffmanBitlen(
		lcode_bitlens,
		max_non_zero_bitlen_lcode,
		dcode_bitlens,
		max_non_zero_bitlen_dcode)
	local rle_code_tblsize = 0
	local rle_codes = {}
	local rle_code_counts = {}
	local rle_extra_bits_tblsize = 0
	local rle_extra_bits = {}
	local prev = nil
	local count = 0

	-- If there is no distance code, assume one distance code of bit length 0.
	-- RFC1951: One distance code of zero bits means that
	-- there are no distance codes used at all (the data is all literals).
	max_non_zero_bitlen_dcode = (max_non_zero_bitlen_dcode < 0)
			and 0 or max_non_zero_bitlen_dcode
	local max_code = max_non_zero_bitlen_lcode+max_non_zero_bitlen_dcode+1

	for code = 0, max_code+1 do
		local len = (code <= max_non_zero_bitlen_lcode)
			and (lcode_bitlens[code] or 0)
			or ((code <= max_code)
			and (dcode_bitlens[code-max_non_zero_bitlen_lcode-1] or 0) or nil)
		if len == prev then
			count = count + 1
			if len ~= 0 and count == 6 then
				rle_code_tblsize = rle_code_tblsize + 1
				rle_codes[rle_code_tblsize] = 16
				rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
				rle_extra_bits[rle_extra_bits_tblsize] = 3
				rle_code_counts[16] = (rle_code_counts[16] or 0) + 1
				count = 0
			elseif len == 0 and count == 138 then
				rle_code_tblsize = rle_code_tblsize + 1
				rle_codes[rle_code_tblsize] = 18
				rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
				rle_extra_bits[rle_extra_bits_tblsize] = 127
				rle_code_counts[18] = (rle_code_counts[18] or 0) + 1
				count = 0
			end
		else
			if count == 1 then
				rle_code_tblsize = rle_code_tblsize + 1
				rle_codes[rle_code_tblsize] = prev
				rle_code_counts[prev] = (rle_code_counts[prev] or 0) + 1
			elseif count == 2 then
				rle_code_tblsize = rle_code_tblsize + 1
				rle_codes[rle_code_tblsize] = prev
				rle_code_tblsize = rle_code_tblsize + 1
				rle_codes[rle_code_tblsize] = prev
				rle_code_counts[prev] = (rle_code_counts[prev] or 0) + 2
			elseif count >= 3 then
				rle_code_tblsize = rle_code_tblsize + 1
				local rleCode = (prev ~= 0) and 16 or (count <= 10 and 17 or 18)
				rle_codes[rle_code_tblsize] = rleCode
				rle_code_counts[rleCode] = (rle_code_counts[rleCode] or 0) + 1
				rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
				rle_extra_bits[rle_extra_bits_tblsize] =
					(count <= 10) and (count - 3) or (count - 11)
			end

			prev = len
			if len and len ~= 0 then
				rle_code_tblsize = rle_code_tblsize + 1
				rle_codes[rle_code_tblsize] = len
				rle_code_counts[len] = (rle_code_counts[len] or 0) + 1
				count = 0
			else
				count = 1
			end
		end
	end

	return rle_codes, rle_extra_bits, rle_code_counts
end

-- Load the string into a table, in order to speed up LZ77.
-- Loop unrolled 16 times to speed this function up.
-- @param str The string to be loaded.
-- @param t The load destination
-- @param start str[index] will be the first character to be loaded.
-- @param end str[index] will be the last character to be loaded
-- @param offset str[index] will be loaded into t[index-offset]
-- @return t
local function LoadStringToTable(str, t, start, stop, offset)
	local i = start - offset
	while i <= stop - 15 - offset do
		t[i], t[i+1], t[i+2], t[i+3], t[i+4], t[i+5], t[i+6], t[i+7], t[i+8],
		t[i+9], t[i+10], t[i+11], t[i+12], t[i+13], t[i+14], t[i+15] =
			string_byte(str, i + offset, i + 15 + offset)
		i = i + 16
	end
	while (i <= stop - offset) do
		t[i] = string_byte(str, i + offset, i + offset)
		i = i + 1
	end
	return t
end

-- Do LZ77 process. This function uses the majority of the CPU time.
-- @see zlib/deflate.c:deflate_fast(), zlib/deflate.c:deflate_slow()
-- @see https://github.com/madler/zlib/blob/master/doc/algorithm.txt
-- This function uses the algorithms used above. You should read the
-- algorithm.txt above to understand what is the hash function and the
-- lazy evaluation.
--
-- The special optimization used here is hash functions used here.
-- The hash function is just the multiplication of the three consective
-- characters. So if the hash matches, it guarantees 3 characters are matched.
-- This optimization can be implemented because Lua table is a hash table.
--
-- @param level integer that describes compression level.
-- @param string_table table that stores the value of string to be compressed.
--			The index of this table starts from 1.
--			The caller needs to make sure all values needed by this function
--			are loaded.
--			Assume "str" is the origin input string into the compressor
--			str[block_start]..str[block_end+3] needs to be loaded into
--			string_table[block_start-offset]..string_table[block_end-offset]
--			If dictionary is presented, the last 258 bytes of the dictionary
--			needs to be loaded into sing_table[-257..0]
--			(See more in the description of offset.)
-- @param hash_tables. The table key is the hash value (0<=hash<=16777216=256^3)
--			The table value is an array0 that stores the indexes of the
--			input data string to be compressed, such that
--			hash == str[index]*str[index+1]*str[index+2]
--			Indexes are ordered in this array.
-- @param block_start The indexes of the input data string to be compressed.
--				that starts the LZ77 block.
-- @param block_end The indexes of the input data string to be compressed.
--				that stores the LZ77 block.
-- @param offset str[index] is stored in string_table[index-offset],
--			This offset is mainly an optimization to limit the index
--			of string_table, so lua can access this table quicker.
-- @param dictionary See LibDeflate:CreateDictionary
-- @return literal/LZ77_length deflate codes.
-- @return the extra bits of literal/LZ77_length deflate codes.
-- @return the count of each literal/LZ77 deflate code.
-- @return LZ77 distance deflate codes.
-- @return the extra bits of LZ77 distance deflate codes.
-- @return the count of each LZ77 distance deflate code.
local function GetBlockLZ77Result(level, string_table, hash_tables, block_start,
		block_end, offset, dictionary)
	local config = _compression_level_configs[level]
	local config_use_lazy
		, config_good_prev_length
		, config_max_lazy_match
		, config_nice_length
		, config_max_hash_chain =
			config[1], config[2], config[3], config[4], config[5]

	local config_max_insert_length = (not config_use_lazy)
		and config_max_lazy_match or 2147483646
	local config_good_hash_chain =
		(config_max_hash_chain-config_max_hash_chain%4/4)

	local hash

	local dict_hash_tables
	local dict_string_table
	local dict_string_len = 0

	if dictionary then
		dict_hash_tables = dictionary.hash_tables
		dict_string_table = dictionary.string_table
		dict_string_len = dictionary.strlen
		assert(block_start == 1)
		if block_end >= block_start and dict_string_len >= 2 then
			hash = dict_string_table[dict_string_len-1]*65536
				+ dict_string_table[dict_string_len]*256 + string_table[1]
			local t = hash_tables[hash]
			if not t then t = {}; hash_tables[hash] = t end
			t[#t+1] = -1
		end
		if block_end >= block_start+1 and dict_string_len >= 1 then
			hash = dict_string_table[dict_string_len]*65536
				+ string_table[1]*256 + string_table[2]
			local t = hash_tables[hash]
			if not t then t = {}; hash_tables[hash] = t end
			t[#t+1] = 0
		end
	end

	hash = (string_table[block_start-offset] or 0)*256
		+ (string_table[block_start+1-offset] or 0)

	local lcodes = {}
	local lcode_tblsize = 0
	local lcodes_counts = {}
	local dcodes = {}
	local dcodes_tblsize = 0
	local dcodes_counts = {}

	local lextra_bits = {}
	local lextra_bits_tblsize = 0
	local dextra_bits = {}
	local dextra_bits_tblsize = 0

	local match_available = false
	local prev_len
	local prev_dist
	local cur_len = 0
	local cur_dist = 0

	local index = block_start
	local index_end = block_end + (config_use_lazy and 1 or 0)

	-- the zlib source code writes separate code for lazy evaluation and
	-- not lazy evaluation, which is easier to understand.
	-- I put them together, so it is a bit harder to understand.
	-- because I think this is easier for me to maintain it.
	while (index <= index_end) do
		local string_table_index = index - offset
		prev_len = cur_len
		prev_dist = cur_dist
		cur_len = 0

		hash = (hash*256+(string_table[string_table_index+2] or 0))%16777216

		local chain_index
		local cur_chain
		local hash_chain = hash_tables[hash]
		local chain_old_size
		if not hash_chain then
			chain_old_size = 0
			hash_chain = {}
			hash_tables[hash] = hash_chain
			if dict_hash_tables then
				cur_chain = dict_hash_tables[hash]
				chain_index = cur_chain and #cur_chain or 0
			else
				chain_index = 0
			end
		else
			chain_old_size = #hash_chain
			cur_chain = hash_chain
			chain_index = chain_old_size
		end

		if index <= block_end then
			hash_chain[chain_old_size+1] = index
		end

		if (chain_index > 0 and index + 2 <= block_end
			and (not config_use_lazy or prev_len < config_max_lazy_match)) then

			local depth =
				(config_use_lazy and prev_len >= config_good_prev_length)
				and config_good_hash_chain or config_max_hash_chain

			while chain_index >= 1 and depth > 0 do
				local prev = cur_chain[chain_index]

				if index - prev > 32768 then
					break
				end
				if prev < index then
					local j = 3

					if prev >= -257 then
						local prev_table_index = prev-offset
						-- NOTE for author:
						-- j < 258 and index + j <= block_end
						-- This is the right condition
						while (j < 258 and index + j <= block_end) do
							if (string_table[prev_table_index+j]
								== string_table[string_table_index+j]) then
								j = j + 1
							else
								break
							end
						end
					else
						local prev_table_index = dict_string_len+prev
						-- NOTE for author:
						-- j < 258 and index + j <= block_end
						-- This is the right condition
						while (j < 258 and index + j <= block_end) do
							if (dict_string_table[prev_table_index+j]
								== string_table[string_table_index+j]) then
								j = j + 1
							else
								break
							end
						end
					end
					if j > cur_len then
						cur_len = j
						cur_dist = index - prev
					end
					if cur_len >= config_nice_length then
						break
					end
				end

				chain_index = chain_index - 1
				depth = depth - 1
				if chain_index == 0 and prev > 0 and dict_hash_tables then
					cur_chain = dict_hash_tables[hash]
					chain_index = cur_chain and #cur_chain or 0
				end
			end
		end

		if not config_use_lazy then
			prev_len, prev_dist = cur_len, cur_dist
		end
		if ((not config_use_lazy or match_available)
			and (prev_len > 3 or (prev_len == 3 and prev_dist < 4096))
			and cur_len <= prev_len )then
			local code = _length_to_deflate_code[prev_len]
			local length_extra_bits_bitlen =
				_length_to_deflate_extra_bitlen[prev_len]
			local dist_code, dist_extra_bits_bitlen, dist_extra_bits
			if prev_dist <= 256 then -- have cached code for small distance.
				dist_code = _dist256_to_deflate_code[prev_dist]
				dist_extra_bits = _dist256_to_deflate_extra_bits[prev_dist]
				dist_extra_bits_bitlen =
					_dist256_to_deflate_extra_bitlen[prev_dist]
			else
				dist_code = 16
				dist_extra_bits_bitlen = 7
				local a = 384
				local b = 512

				while true do
					if prev_dist <= a then
						dist_extra_bits = (prev_dist-(b/2)-1) % (b/4)
						break
					elseif prev_dist <= b then
						dist_extra_bits = (prev_dist-(b/2)-1) % (b/4)
						dist_code = dist_code + 1
						break
					else
						dist_code = dist_code + 2
						dist_extra_bits_bitlen = dist_extra_bits_bitlen + 1
						a = a*2
						b = b*2
					end
				end
			end
			lcode_tblsize = lcode_tblsize + 1
			lcodes[lcode_tblsize] = code
			lcodes_counts[code] = (lcodes_counts[code] or 0) + 1

			dcodes_tblsize = dcodes_tblsize + 1
			dcodes[dcodes_tblsize] = dist_code
			dcodes_counts[dist_code] = (dcodes_counts[dist_code] or 0) + 1

			if length_extra_bits_bitlen > 0 then
				local lenExtraBits = _length_to_deflate_extra_bits[prev_len]
				lextra_bits_tblsize = lextra_bits_tblsize + 1
				lextra_bits[lextra_bits_tblsize] = lenExtraBits
			end
			if dist_extra_bits_bitlen > 0 then
				dextra_bits_tblsize = dextra_bits_tblsize + 1
				dextra_bits[dextra_bits_tblsize] = dist_extra_bits
			end

			for i=index+1, index+prev_len-(config_use_lazy and 2 or 1) do
				hash = (hash*256+(string_table[i-offset+2] or 0))%16777216
				if prev_len <= config_max_insert_length then
					hash_chain = hash_tables[hash]
					if not hash_chain then
						hash_chain = {}
						hash_tables[hash] = hash_chain
					end
					hash_chain[#hash_chain+1] = i
				end
			end
			index = index + prev_len - (config_use_lazy and 1 or 0)
			match_available = false
		elseif (not config_use_lazy) or match_available then
			local code = string_table[config_use_lazy
				and (string_table_index-1) or string_table_index]
			lcode_tblsize = lcode_tblsize + 1
			lcodes[lcode_tblsize] = code
			lcodes_counts[code] = (lcodes_counts[code] or 0) + 1
			index = index + 1
		else
			match_available = true
			index = index + 1
		end
	end

	-- Write "end of block" symbol
	lcode_tblsize = lcode_tblsize + 1
	lcodes[lcode_tblsize] = 256
	lcodes_counts[256] = (lcodes_counts[256] or 0) + 1

	return lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits
		, dcodes_counts
end

-- Get the header data of dynamic block.
-- @param lcodes_count The count of each literal/LZ77_length codes.
-- @param dcodes_count The count of each Lz77 distance codes.
-- @return a lots of stuffs.
-- @see RFC1951 Page 12
local function GetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)
	local lcodes_huffman_bitlens, lcodes_huffman_codes
		, max_non_zero_bitlen_lcode =
		GetHuffmanBitlenAndCode(lcodes_counts, 15, 285)
	local dcodes_huffman_bitlens, dcodes_huffman_codes
		, max_non_zero_bitlen_dcode =
		GetHuffmanBitlenAndCode(dcodes_counts, 15, 29)

	local rle_deflate_codes, rle_extra_bits, rle_codes_counts =
		RunLengthEncodeHuffmanBitlen(lcodes_huffman_bitlens
		,max_non_zero_bitlen_lcode, dcodes_huffman_bitlens
		, max_non_zero_bitlen_dcode)

	local rle_codes_huffman_bitlens, rle_codes_huffman_codes =
		GetHuffmanBitlenAndCode(rle_codes_counts, 7, 18)

	local HCLEN = 0
	for i = 1, 19 do
		local symbol = _rle_codes_huffman_bitlen_order[i]
		local length = rle_codes_huffman_bitlens[symbol] or 0
		if length ~= 0 then
			HCLEN = i
		end
	end

	HCLEN = HCLEN - 4
	local HLIT = max_non_zero_bitlen_lcode + 1 - 257
	local HDIST = max_non_zero_bitlen_dcode + 1 - 1
	if HDIST < 0 then HDIST = 0 end

	return HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens
		, rle_codes_huffman_codes, rle_deflate_codes, rle_extra_bits
		, lcodes_huffman_bitlens, lcodes_huffman_codes
		, dcodes_huffman_bitlens, dcodes_huffman_codes
end

-- Get the size of dynamic block without writing any bits into the writer.
-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()
-- @return the bit length of the dynamic block
local function GetDynamicHuffmanBlockSize(lcodes, dcodes, HCLEN
	, rle_codes_huffman_bitlens, rle_deflate_codes
	, lcodes_huffman_bitlens, dcodes_huffman_bitlens)

	local block_bitlen = 17 -- 1+2+5+5+4
	block_bitlen = block_bitlen + (HCLEN+4)*3

	for i = 1, #rle_deflate_codes do
		local code = rle_deflate_codes[i]
		block_bitlen = block_bitlen + rle_codes_huffman_bitlens[code]
		if code >= 16 then
			block_bitlen = block_bitlen +
			((code == 16) and 2 or (code == 17 and 3 or 7))
		end
	end

	local length_code_count = 0
	for i = 1, #lcodes do
		local code = lcodes[i]
		local huffman_bitlen = lcodes_huffman_bitlens[code]
		block_bitlen = block_bitlen + huffman_bitlen
		if code > 256 then -- Length code
			length_code_count = length_code_count + 1
			if code > 264 and code < 285 then -- Length code with extra bits
				local extra_bits_bitlen =
					_literal_deflate_code_to_extra_bitlen[code-256]
				block_bitlen = block_bitlen + extra_bits_bitlen
			end
			local dist_code = dcodes[length_code_count]
			local dist_huffman_bitlen = dcodes_huffman_bitlens[dist_code]
			block_bitlen = block_bitlen + dist_huffman_bitlen

			if dist_code > 3 then -- dist code with extra bits
				local dist_extra_bits_bitlen = (dist_code-dist_code%2)/2 - 1
				block_bitlen = block_bitlen + dist_extra_bits_bitlen
			end
		end
	end
	return block_bitlen
end

-- Write dynamic block.
-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()
local function CompressDynamicHuffmanBlock(WriteBits, is_last_block
		, lcodes, lextra_bits, dcodes, dextra_bits, HLIT, HDIST, HCLEN
		, rle_codes_huffman_bitlens, rle_codes_huffman_codes
		, rle_deflate_codes, rle_extra_bits
		, lcodes_huffman_bitlens, lcodes_huffman_codes
		, dcodes_huffman_bitlens, dcodes_huffman_codes)

	WriteBits(is_last_block and 1 or 0, 1) -- Last block identifier
	WriteBits(2, 2) -- Dynamic Huffman block identifier

	WriteBits(HLIT, 5)
	WriteBits(HDIST, 5)
	WriteBits(HCLEN, 4)

	for i = 1, HCLEN+4 do
		local symbol = _rle_codes_huffman_bitlen_order[i]
		local length = rle_codes_huffman_bitlens[symbol] or 0
		WriteBits(length, 3)
	end

	local rleExtraBitsIndex = 1
	for i=1, #rle_deflate_codes do
		local code = rle_deflate_codes[i]
		WriteBits(rle_codes_huffman_codes[code]
			, rle_codes_huffman_bitlens[code])
		if code >= 16 then
			local extraBits = rle_extra_bits[rleExtraBitsIndex]
			WriteBits(extraBits, (code == 16) and 2 or (code == 17 and 3 or 7))
			rleExtraBitsIndex = rleExtraBitsIndex + 1
		end
	end

	local length_code_count = 0
	local length_code_with_extra_count = 0
	local dist_code_with_extra_count = 0

	for i=1, #lcodes do
		local deflate_codee = lcodes[i]
		local huffman_code = lcodes_huffman_codes[deflate_codee]
		local huffman_bitlen = lcodes_huffman_bitlens[deflate_codee]
		WriteBits(huffman_code, huffman_bitlen)
		if deflate_codee > 256 then -- Length code
			length_code_count = length_code_count + 1
			if deflate_codee > 264 and deflate_codee < 285 then
				-- Length code with extra bits
				length_code_with_extra_count = length_code_with_extra_count + 1
				local extra_bits = lextra_bits[length_code_with_extra_count]
				local extra_bits_bitlen =
					_literal_deflate_code_to_extra_bitlen[deflate_codee-256]
				WriteBits(extra_bits, extra_bits_bitlen)
			end
			-- Write distance code
			local dist_deflate_code = dcodes[length_code_count]
			local dist_huffman_code = dcodes_huffman_codes[dist_deflate_code]
			local dist_huffman_bitlen =
				dcodes_huffman_bitlens[dist_deflate_code]
			WriteBits(dist_huffman_code, dist_huffman_bitlen)

			if dist_deflate_code > 3 then -- dist code with extra bits
				dist_code_with_extra_count = dist_code_with_extra_count + 1
				local dist_extra_bits = dextra_bits[dist_code_with_extra_count]
				local dist_extra_bits_bitlen =
					(dist_deflate_code-dist_deflate_code%2)/2 - 1
				WriteBits(dist_extra_bits, dist_extra_bits_bitlen)
			end
		end
	end
end

-- Get the size of fixed block without writing any bits into the writer.
-- @param lcodes literal/LZ77_length deflate codes
-- @param decodes LZ77 distance deflate codes
-- @return the bit length of the fixed block
local function GetFixedHuffmanBlockSize(lcodes, dcodes)
	local block_bitlen = 3
	local length_code_count = 0
	for i=1, #lcodes do
		local code = lcodes[i]
		local huffman_bitlen = _fix_block_literal_huffman_bitlen[code]
		block_bitlen = block_bitlen + huffman_bitlen
		if code > 256 then -- Length code
			length_code_count = length_code_count + 1
			if code > 264 and code < 285 then -- Length code with extra bits
				local extra_bits_bitlen =
					_literal_deflate_code_to_extra_bitlen[code-256]
				block_bitlen = block_bitlen + extra_bits_bitlen
			end
			local dist_code = dcodes[length_code_count]
			block_bitlen = block_bitlen + 5

			if dist_code > 3 then -- dist code with extra bits
				local dist_extra_bits_bitlen =
					(dist_code-dist_code%2)/2 - 1
				block_bitlen = block_bitlen + dist_extra_bits_bitlen
			end
		end
	end
	return block_bitlen
end

-- Write fixed block.
-- @param lcodes literal/LZ77_length deflate codes
-- @param decodes LZ77 distance deflate codes
local function CompressFixedHuffmanBlock(WriteBits, is_last_block,
		lcodes, lextra_bits, dcodes, dextra_bits)
	WriteBits(is_last_block and 1 or 0, 1) -- Last block identifier
	WriteBits(1, 2) -- Fixed Huffman block identifier
	local length_code_count = 0
	local length_code_with_extra_count = 0
	local dist_code_with_extra_count = 0
	for i=1, #lcodes do
		local deflate_code = lcodes[i]
		local huffman_code = _fix_block_literal_huffman_code[deflate_code]
		local huffman_bitlen = _fix_block_literal_huffman_bitlen[deflate_code]
		WriteBits(huffman_code, huffman_bitlen)
		if deflate_code > 256 then -- Length code
			length_code_count = length_code_count + 1
			if deflate_code > 264 and deflate_code < 285 then
				-- Length code with extra bits
				length_code_with_extra_count = length_code_with_extra_count + 1
				local extra_bits = lextra_bits[length_code_with_extra_count]
				local extra_bits_bitlen =
					_literal_deflate_code_to_extra_bitlen[deflate_code-256]
				WriteBits(extra_bits, extra_bits_bitlen)
			end
			-- Write distance code
			local dist_code = dcodes[length_code_count]
			local dist_huffman_code = _fix_block_dist_huffman_code[dist_code]
			WriteBits(dist_huffman_code, 5)

			if dist_code > 3 then -- dist code with extra bits
				dist_code_with_extra_count = dist_code_with_extra_count + 1
				local dist_extra_bits = dextra_bits[dist_code_with_extra_count]
				local dist_extra_bits_bitlen = (dist_code-dist_code%2)/2 - 1
				WriteBits(dist_extra_bits, dist_extra_bits_bitlen)
			end
		end
	end
end

-- Get the size of store block without writing any bits into the writer.
-- @param block_start The start index of the origin input string
-- @param block_end The end index of the origin input string
-- @param Total bit lens had been written into the compressed result before,
-- because store block needs to shift to byte boundary.
-- @return the bit length of the fixed block
local function GetStoreBlockSize(block_start, block_end, total_bitlen)
	assert(block_end-block_start+1 <= 65535)
	local block_bitlen = 3
	total_bitlen = total_bitlen + 3
	local padding_bitlen = (8-total_bitlen%8)%8
	block_bitlen = block_bitlen + padding_bitlen
	block_bitlen = block_bitlen + 32
	block_bitlen = block_bitlen + (block_end - block_start + 1) * 8
	return block_bitlen
end

-- Write the store block.
-- @param ... lots of stuffs
-- @return nil
local function CompressStoreBlock(WriteBits, WriteString, is_last_block, str
	, block_start, block_end, total_bitlen)
	assert(block_end-block_start+1 <= 65535)
	WriteBits(is_last_block and 1 or 0, 1) -- Last block identifer.
	WriteBits(0, 2) -- Store block identifier.
	total_bitlen = total_bitlen + 3
	local padding_bitlen = (8-total_bitlen%8)%8
	if padding_bitlen > 0 then
		WriteBits(_pow2[padding_bitlen]-1, padding_bitlen)
	end
	local size = block_end - block_start + 1
	WriteBits(size, 16)

	-- Write size's one's complement
	local comp = (255 - size % 256) + (255 - (size-size%256)/256)*256
	WriteBits(comp, 16)

	WriteString(str:sub(block_start, block_end))
end

-- Do the deflate
-- Currently using a simple way to determine the block size
-- (This is why the compression ratio is little bit worse than zlib when
-- the input size is very large
-- The first block is 64KB, the following block is 32KB.
-- After each block, there is a memory cleanup operation.
-- This is not a fast operation, but it is needed to save memory usage, so
-- the memory usage does not grow unboundly. If the data size is less than
-- 64KB, then memory cleanup won't happen.
-- This function determines whether to use store/fixed/dynamic blocks by
-- calculating the block size of each block type and chooses the smallest one.
local function Deflate(configs, WriteBits, WriteString, FlushWriter, str
	, dictionary)
	local string_table = {}
	local hash_tables = {}
	local is_last_block = nil
	local block_start
	local block_end
	local bitlen_written
	local total_bitlen = FlushWriter(_FLUSH_MODE_NO_FLUSH)
	local strlen = #str
	local offset

	local level
	local strategy
	if configs then
		if configs.level then
			level = configs.level
		end
		if configs.strategy then
			strategy = configs.strategy
		end
	end

	if not level then
		if strlen < 2048 then
			level = 7
		elseif strlen > 65536 then
			level = 3
		else
			level = 5
		end
	end

	while not is_last_block do
		if not block_start then
			block_start = 1
			block_end = 64*1024 - 1
			offset = 0
		else
			block_start = block_end + 1
			block_end = block_end + 32*1024
			offset = block_start - 32*1024 - 1
		end

		if block_end >= strlen then
			block_end = strlen
			is_last_block = true
		else
			is_last_block = false
		end

		local lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits
			, dcodes_counts

		local HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens
			, rle_codes_huffman_codes, rle_deflate_codes
			, rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes
			, dcodes_huffman_bitlens, dcodes_huffman_codes

		local dynamic_block_bitlen
		local fixed_block_bitlen
		local store_block_bitlen

		if level ~= 0 then

			-- GetBlockLZ77 needs block_start to block_end+3 to be loaded.
			LoadStringToTable(str, string_table, block_start, block_end + 3
				, offset)
			if block_start == 1 and dictionary then
				local dict_string_table = dictionary.string_table
				local dict_strlen = dictionary.strlen
				for i=0, (-dict_strlen+1)<-257
					and -257 or (-dict_strlen+1), -1 do
					string_table[i] = dict_string_table[dict_strlen+i]
				end
			end

			if strategy == "huffman_only" then
				lcodes = {}
				LoadStringToTable(str, lcodes, block_start, block_end
					, block_start-1)
				lextra_bits = {}
				lcodes_counts = {}
				lcodes[block_end - block_start+2] = 256 -- end of block
				for i=1, block_end - block_start+2 do
					local code = lcodes[i]
					lcodes_counts[code] = (lcodes_counts[code] or 0) + 1
				end
				dcodes = {}
				dextra_bits = {}
				dcodes_counts = {}
			else
				lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits
				, dcodes_counts = GetBlockLZ77Result(level, string_table
				, hash_tables, block_start, block_end, offset, dictionary
				)
			end

			HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens
				, rle_codes_huffman_codes, rle_deflate_codes
				, rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes
				, dcodes_huffman_bitlens, dcodes_huffman_codes =
				GetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)
			dynamic_block_bitlen = GetDynamicHuffmanBlockSize(
					lcodes, dcodes, HCLEN, rle_codes_huffman_bitlens
					, rle_deflate_codes, lcodes_huffman_bitlens
					, dcodes_huffman_bitlens)
			fixed_block_bitlen = GetFixedHuffmanBlockSize(lcodes, dcodes)
		end

		store_block_bitlen = GetStoreBlockSize(block_start, block_end
			, total_bitlen)

		local min_bitlen = store_block_bitlen
		min_bitlen = (fixed_block_bitlen and fixed_block_bitlen < min_bitlen)
			and fixed_block_bitlen or min_bitlen
		min_bitlen = (dynamic_block_bitlen
			and dynamic_block_bitlen < min_bitlen)
			and dynamic_block_bitlen or min_bitlen

		if level == 0 or (strategy ~= "fixed" and strategy ~= "dynamic" and
			store_block_bitlen == min_bitlen) then
			CompressStoreBlock(WriteBits, WriteString, is_last_block
				, str, block_start, block_end, total_bitlen)
			total_bitlen = total_bitlen + store_block_bitlen
		elseif strategy ~= "dynamic" and (
			strategy == "fixed" or fixed_block_bitlen == min_bitlen) then
			CompressFixedHuffmanBlock(WriteBits, is_last_block,
					lcodes, lextra_bits, dcodes, dextra_bits)
			total_bitlen = total_bitlen + fixed_block_bitlen
		elseif strategy == "dynamic" or dynamic_block_bitlen == min_bitlen then
			CompressDynamicHuffmanBlock(WriteBits, is_last_block, lcodes
				, lextra_bits, dcodes, dextra_bits, HLIT, HDIST, HCLEN
				, rle_codes_huffman_bitlens, rle_codes_huffman_codes
				, rle_deflate_codes, rle_extra_bits
				, lcodes_huffman_bitlens, lcodes_huffman_codes
				, dcodes_huffman_bitlens, dcodes_huffman_codes)
			total_bitlen = total_bitlen + dynamic_block_bitlen
		end

		if is_last_block then
			bitlen_written = FlushWriter(_FLUSH_MODE_NO_FLUSH)
		else
			bitlen_written = FlushWriter(_FLUSH_MODE_MEMORY_CLEANUP)
		end

		assert(bitlen_written == total_bitlen)

		-- Memory clean up, so memory consumption does not always grow linearly
		-- , even if input string is > 64K.
		-- Not a very efficient operation, but this operation won't happen
		-- when the input data size is less than 64K.
		if not is_last_block then
			local j
			if dictionary and block_start == 1 then
				j = 0
				while (string_table[j]) do
					string_table[j] = nil
					j = j - 1
				end
			end
			dictionary = nil
			j = 1
			for i = block_end-32767, block_end do
				string_table[j] = string_table[i-offset]
				j = j + 1
			end

			for k, t in pairs(hash_tables) do
				local tSize = #t
				if tSize > 0 and block_end+1 - t[1] > 32768 then
					if tSize == 1 then
						hash_tables[k] = nil
					else
						local new = {}
						local newSize = 0
						for i = 2, tSize do
							j = t[i]
							if block_end+1 - j <= 32768 then
								newSize = newSize + 1
								new[newSize] = j
							end
						end
						hash_tables[k] = new
					end
				end
			end
		end
	end
end

--- The description to compression configuration table. <br>
-- Any field can be nil to use its default. <br>
-- Table with keys other than those below is an invalid table.
-- @class table
-- @name compression_configs
-- @field level The compression level ranged from 0 to 9. 0 is no compression.
-- 9 is the slowest but best compression. Use nil for default level.
-- @field strategy The compression strategy. "fixed" to only use fixed deflate
-- compression block. "dynamic" to only use dynamic block. "huffman_only" to
-- do no LZ77 compression. Only do huffman compression.


-- @see LibDeflate:CompressDeflate(str, configs)
-- @see LibDeflate:CompressDeflateWithDict(str, dictionary, configs)
local function CompressDeflateInternal(str, dictionary, configs)
	local WriteBits, WriteString, FlushWriter = CreateWriter()
	Deflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)
	local total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)
	local padding_bitlen = (8-total_bitlen%8)%8
	return result, padding_bitlen
end

-- @see LibDeflate:CompressZlib
-- @see LibDeflate:CompressZlibWithDict
local function CompressZlibInternal(str, dictionary, configs)
	local WriteBits, WriteString, FlushWriter = CreateWriter()

	local CM = 8 -- Compression method
	local CINFO = 7 --Window Size = 32K
	local CMF = CINFO*16+CM
	WriteBits(CMF, 8)

	local FDIST = dictionary and 1 or 0
	local FLEVEL = 2 -- Default compression
	local FLG = FLEVEL*64+FDIST*32
	local FCHECK = (31-(CMF*256+FLG)%31)
	-- The FCHECK value must be such that CMF and FLG,
	-- when viewed as a 16-bit unsigned integer stored
	-- in MSB order (CMF*256 + FLG), is a multiple of 31.
	FLG = FLG + FCHECK
	WriteBits(FLG, 8)

	if FDIST == 1 then
		local adler32 = dictionary.adler32
		local byte0 = adler32 % 256
		adler32 = (adler32 - byte0) / 256
		local byte1 = adler32 % 256
		adler32 = (adler32 - byte1) / 256
		local byte2 = adler32 % 256
		adler32 = (adler32 - byte2) / 256
		local byte3 = adler32 % 256
		WriteBits(byte3, 8)
		WriteBits(byte2, 8)
		WriteBits(byte1, 8)
		WriteBits(byte0, 8)
	end

	Deflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)
	FlushWriter(_FLUSH_MODE_BYTE_BOUNDARY)

	local adler32 = LibDeflate:Adler32(str)

	-- Most significant byte first
	local byte3 = adler32%256
	adler32 = (adler32 - byte3) / 256
	local byte2 = adler32%256
	adler32 = (adler32 - byte2) / 256
	local byte1 = adler32%256
	adler32 = (adler32 - byte1) / 256
	local byte0 = adler32%256

	WriteBits(byte0, 8)
	WriteBits(byte1, 8)
	WriteBits(byte2, 8)
	WriteBits(byte3, 8)
	local total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)
	local padding_bitlen = (8-total_bitlen%8)%8
	return result, padding_bitlen
end

--- Compress using the raw deflate format.
-- @param str [string] The data to be compressed.
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- 0 <= bits < 8  <br>
-- This means the most significant "bits" of the last byte of the returned
-- compressed data are padding bits and they don't affect decompression.
-- You don't need to use this value unless you want to do some postprocessing
-- to the compressed data.
-- @see compression_configs
-- @see LibDeflate:DecompressDeflate
function LibDeflate:CompressDeflate(str, configs)
	local arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)
	if not arg_valid then
		error(("Usage: LibDeflate:CompressDeflate(str, configs): "
			..arg_err), 2)
	end
	return CompressDeflateInternal(str, nil, configs)
end

--- Compress using the raw deflate format with a preset dictionary.
-- @param str [string] The data to be compressed.
-- @param dictionary [table] The preset dictionary produced by
-- LibDeflate:CreateDictionary
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- 0 <= bits < 8  <br>
-- This means the most significant "bits" of the last byte of the returned
-- compressed data are padding bits and they don't affect decompression.
-- You don't need to use this value unless you want to do some postprocessing
-- to the compressed data.
-- @see compression_configs
-- @see LibDeflate:CreateDictionary
-- @see LibDeflate:DecompressDeflateWithDict
function LibDeflate:CompressDeflateWithDict(str, dictionary, configs)
	local arg_valid, arg_err = IsValidArguments(str, true, dictionary
		, true, configs)
	if not arg_valid then
		error(("Usage: LibDeflate:CompressDeflateWithDict"
			.."(str, dictionary, configs): "
			..arg_err), 2)
	end
	return CompressDeflateInternal(str, dictionary, configs)
end

--- Compress using the zlib format.
-- @param str [string] the data to be compressed.
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- Should always be 0.
-- Zlib formatted compressed data never has padding bits at the end.
-- @see compression_configs
-- @see LibDeflate:DecompressZlib
function LibDeflate:CompressZlib(str, configs)
	local arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)
	if not arg_valid then
		error(("Usage: LibDeflate:CompressZlib(str, configs): "
			..arg_err), 2)
	end
	return CompressZlibInternal(str, nil, configs)
end

--- Compress using the zlib format with a preset dictionary.
-- @param str [string] the data to be compressed.
-- @param dictionary [table] A preset dictionary produced
-- by LibDeflate:CreateDictionary()
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- Should always be 0.
-- Zlib formatted compressed data never has padding bits at the end.
-- @see compression_configs
-- @see LibDeflate:CreateDictionary
-- @see LibDeflate:DecompressZlibWithDict
function LibDeflate:CompressZlibWithDict(str, dictionary, configs)
	local arg_valid, arg_err = IsValidArguments(str, true, dictionary
		, true, configs)
	if not arg_valid then
		error(("Usage: LibDeflate:CompressZlibWithDict"
			.."(str, dictionary, configs): "
			..arg_err), 2)
	end
	return CompressZlibInternal(str, dictionary, configs)
end

--[[ --------------------------------------------------------------------------
	Decompress code
--]] --------------------------------------------------------------------------

--[[
	Create a reader to easily reader stuffs as the unit of bits.
	Return values:
	1. ReadBits(bitlen)
	2. ReadBytes(bytelen, buffer, buffer_size)
	3. Decode(huffman_bitlen_count, huffman_symbol, min_bitlen)
	4. ReaderBitlenLeft()
	5. SkipToByteBoundary()
--]]
local function CreateReader(input_string)
	local input = input_string
	local input_strlen = #input_string
	local input_next_byte_pos = 1
	local cache_bitlen = 0
	local cache = 0

	-- Read some bits.
	-- To improve speed, this function does not
	-- check if the input has been exhausted.
	-- Use ReaderBitlenLeft() < 0 to check it.
	-- @param bitlen the number of bits to read
	-- @return the data is read.
	local function ReadBits(bitlen)
		local rshift_mask = _pow2[bitlen]
		local code
		if bitlen <= cache_bitlen then
			code = cache % rshift_mask
			cache = (cache - code) / rshift_mask
			cache_bitlen = cache_bitlen - bitlen
		else -- Whether input has been exhausted is not checked.
			local lshift_mask = _pow2[cache_bitlen]
			local byte1, byte2, byte3, byte4 = string_byte(input
				, input_next_byte_pos, input_next_byte_pos+3)
			-- This requires lua number to be at least double ()
			cache = cache + ((byte1 or 0)+(byte2 or 0)*256
				+ (byte3 or 0)*65536+(byte4 or 0)*16777216)*lshift_mask
			input_next_byte_pos = input_next_byte_pos + 4
			cache_bitlen = cache_bitlen + 32 - bitlen
			code = cache % rshift_mask
			cache = (cache - code) / rshift_mask
		end
		return code
	end

	-- Read some bytes from the reader.
	-- Assume reader is on the byte boundary.
	-- @param bytelen The number of bytes to be read.
	-- @param buffer The byte read will be stored into this buffer.
	-- @param buffer_size The buffer will be modified starting from
	--	buffer[buffer_size+1], ending at buffer[buffer_size+bytelen-1]
	-- @return the new buffer_size
	local function ReadBytes(bytelen, buffer, buffer_size)
		assert(cache_bitlen % 8 == 0)

		local byte_from_cache = (cache_bitlen/8 < bytelen)
			and (cache_bitlen/8) or bytelen
		for _=1, byte_from_cache do
			local byte = cache % 256
			buffer_size = buffer_size + 1
			buffer[buffer_size] = string_char(byte)
			cache = (cache - byte) / 256
		end
		cache_bitlen = cache_bitlen - byte_from_cache*8
		bytelen = bytelen - byte_from_cache
		if (input_strlen - input_next_byte_pos - bytelen + 1) * 8
			+ cache_bitlen < 0 then
			return -1 -- out of input
		end
		for i=input_next_byte_pos, input_next_byte_pos+bytelen-1 do
			buffer_size = buffer_size + 1
			buffer[buffer_size] = string_sub(input, i, i)
		end

		input_next_byte_pos = input_next_byte_pos + bytelen
		return buffer_size
	end

	-- Decode huffman code
	-- To improve speed, this function does not check
	-- if the input has been exhausted.
	-- Use ReaderBitlenLeft() < 0 to check it.
	-- Credits for Mark Adler. This code is from puff:Decode()
	-- @see puff:Decode(...)
	-- @param huffman_bitlen_count
	-- @param huffman_symbol
	-- @param min_bitlen The minimum huffman bit length of all symbols
	-- @return The decoded deflate code.
	--	Negative value is returned if decoding fails.
	local function Decode(huffman_bitlen_counts, huffman_symbols, min_bitlen)
		local code = 0
		local first = 0
		local index = 0
		local count
		if min_bitlen > 0 then
			if cache_bitlen < 15 and input then
				local lshift_mask = _pow2[cache_bitlen]
				local byte1, byte2, byte3, byte4 =
					string_byte(input, input_next_byte_pos
					, input_next_byte_pos+3)
				-- This requires lua number to be at least double ()
				cache = cache + ((byte1 or 0)+(byte2 or 0)*256
					+(byte3 or 0)*65536+(byte4 or 0)*16777216)*lshift_mask
				input_next_byte_pos = input_next_byte_pos + 4
				cache_bitlen = cache_bitlen + 32
			end

			local rshift_mask = _pow2[min_bitlen]
			cache_bitlen = cache_bitlen - min_bitlen
			code = cache % rshift_mask
			cache = (cache - code) / rshift_mask
			-- Reverse the bits
			code = _reverse_bits_tbl[min_bitlen][code]

			count = huffman_bitlen_counts[min_bitlen]
			if code < count then
				return huffman_symbols[code]
			end
			index = count
			first = count * 2
			code = code * 2
		end

		for bitlen = min_bitlen+1, 15 do
			local bit
			bit = cache % 2
			cache = (cache - bit) / 2
			cache_bitlen = cache_bitlen - 1

			code = (bit==1) and (code + 1 - code % 2) or code
			count = huffman_bitlen_counts[bitlen] or 0
			local diff = code - first
			if diff < count then
				return huffman_symbols[index + diff]
			end
			index = index + count
			first = first + count
			first = first * 2
			code = code * 2
		end
		-- invalid literal/length or distance code
		-- in fixed or dynamic block (run out of code)
		return -10
	end

	local function ReaderBitlenLeft()
		return (input_strlen - input_next_byte_pos + 1) * 8 + cache_bitlen
	end

	local function SkipToByteBoundary()
		local skipped_bitlen = cache_bitlen%8
		local rshift_mask = _pow2[skipped_bitlen]
		cache_bitlen = cache_bitlen - skipped_bitlen
		cache = (cache - cache % rshift_mask) / rshift_mask
	end

	return ReadBits, ReadBytes, Decode, ReaderBitlenLeft, SkipToByteBoundary
end

-- Create a deflate state, so I can pass in less arguments to functions.
-- @param str the whole string to be decompressed.
-- @param dictionary The preset dictionary. nil if not provided.
--		This dictionary should be produced by LibDeflate:CreateDictionary(str)
-- @return The decomrpess state.
local function CreateDecompressState(str, dictionary)
	local ReadBits, ReadBytes, Decode, ReaderBitlenLeft
		, SkipToByteBoundary = CreateReader(str)
	local state =
	{
		ReadBits = ReadBits,
		ReadBytes = ReadBytes,
		Decode = Decode,
		ReaderBitlenLeft = ReaderBitlenLeft,
		SkipToByteBoundary = SkipToByteBoundary,
		buffer_size = 0,
		buffer = {},
		result_buffer = {},
		dictionary = dictionary,
	}
	return state
end

-- Get the stuffs needed to decode huffman codes
-- @see puff.c:construct(...)
-- @param huffman_bitlen The huffman bit length of the huffman codes.
-- @param max_symbol The maximum symbol
-- @param max_bitlen The min huffman bit length of all codes
-- @return zero or positive for success, negative for failure.
-- @return The count of each huffman bit length.
-- @return A table to convert huffman codes to deflate codes.
-- @return The minimum huffman bit length.
local function GetHuffmanForDecode(huffman_bitlens, max_symbol, max_bitlen)
	local huffman_bitlen_counts = {}
	local min_bitlen = max_bitlen
	for symbol = 0, max_symbol do
		local bitlen = huffman_bitlens[symbol] or 0
		min_bitlen = (bitlen > 0 and bitlen < min_bitlen)
			and bitlen or min_bitlen
		huffman_bitlen_counts[bitlen] = (huffman_bitlen_counts[bitlen] or 0)+1
	end

	if huffman_bitlen_counts[0] == max_symbol+1 then -- No Codes
		return 0, huffman_bitlen_counts, {}, 0 -- Complete, but decode will fail
	end

	local left = 1
	for len = 1, max_bitlen do
		left = left * 2
		left = left - (huffman_bitlen_counts[len] or 0)
		if left < 0 then
			return left -- Over-subscribed, return negative
		end
	end

	-- Generate offsets info symbol table for each length for sorting
	local offsets = {}
	offsets[1] = 0
	for len = 1, max_bitlen-1 do
		offsets[len + 1] = offsets[len] + (huffman_bitlen_counts[len] or 0)
	end

	local huffman_symbols = {}
	for symbol = 0, max_symbol do
		local bitlen = huffman_bitlens[symbol] or 0
		if bitlen ~= 0 then
			local offset = offsets[bitlen]
			huffman_symbols[offset] = symbol
			offsets[bitlen] = offsets[bitlen] + 1
		end
	end

	-- Return zero for complete set, positive for incomplete set.
	return left, huffman_bitlen_counts, huffman_symbols, min_bitlen
end

-- Decode a fixed or dynamic huffman blocks, excluding last block identifier
-- and block type identifer.
-- @see puff.c:codes()
-- @param state decompression state that will be modified by this function.
--	@see CreateDecompressState
-- @param ... Read the source code
-- @return 0 on success, other value on failure.
local function DecodeUntilEndOfBlock(state, lcodes_huffman_bitlens
	, lcodes_huffman_symbols, lcodes_huffman_min_bitlen
	, dcodes_huffman_bitlens, dcodes_huffman_symbols
	, dcodes_huffman_min_bitlen)
	local buffer, buffer_size, ReadBits, Decode, ReaderBitlenLeft
		, result_buffer =
		state.buffer, state.buffer_size, state.ReadBits, state.Decode
		, state.ReaderBitlenLeft, state.result_buffer
	local dictionary = state.dictionary
	local dict_string_table
	local dict_strlen

	local buffer_end = 1
	if dictionary and not buffer[0] then
		-- If there is a dictionary, copy the last 258 bytes into
		-- the string_table to make the copy in the main loop quicker.
		-- This is done only once per decompression.
		dict_string_table = dictionary.string_table
		dict_strlen = dictionary.strlen
		buffer_end = -dict_strlen + 1
		for i=0, (-dict_strlen+1)<-257 and -257 or (-dict_strlen+1), -1 do
			buffer[i] = _byte_to_char[dict_string_table[dict_strlen+i]]
		end
	end

	repeat
		local symbol = Decode(lcodes_huffman_bitlens
			, lcodes_huffman_symbols, lcodes_huffman_min_bitlen)
		if symbol < 0 or symbol > 285 then
		-- invalid literal/length or distance code in fixed or dynamic block
			return -10
		elseif symbol < 256 then -- Literal
			buffer_size = buffer_size + 1
			buffer[buffer_size] = _byte_to_char[symbol]
		elseif symbol > 256 then -- Length code
			symbol = symbol - 256
			local bitlen = _literal_deflate_code_to_base_len[symbol]
			bitlen = (symbol >= 8)
				 and (bitlen
				 + ReadBits(_literal_deflate_code_to_extra_bitlen[symbol]))
					or bitlen
			symbol = Decode(dcodes_huffman_bitlens, dcodes_huffman_symbols
				, dcodes_huffman_min_bitlen)
			if symbol < 0 or symbol > 29 then
			-- invalid literal/length or distance code in fixed or dynamic block
				return -10
			end
			local dist = _dist_deflate_code_to_base_dist[symbol]
			dist = (dist > 4) and (dist
				+ ReadBits(_dist_deflate_code_to_extra_bitlen[symbol])) or dist

			local char_buffer_index = buffer_size-dist+1
			if char_buffer_index < buffer_end then
			-- distance is too far back in fixed or dynamic block
				return -11
			end
			if char_buffer_index >= -257 then
				for _=1, bitlen do
					buffer_size = buffer_size + 1
					buffer[buffer_size] = buffer[char_buffer_index]
					char_buffer_index = char_buffer_index + 1
				end
			else
				char_buffer_index = dict_strlen + char_buffer_index
				for _=1, bitlen do
					buffer_size = buffer_size + 1
					buffer[buffer_size] =
					_byte_to_char[dict_string_table[char_buffer_index]]
					char_buffer_index = char_buffer_index + 1
				end
			end
		end

		if ReaderBitlenLeft() < 0 then
			return 2 -- available inflate data did not terminate
		end

		if buffer_size >= 65536 then
			result_buffer[#result_buffer+1] =
				table_concat(buffer, "", 1, 32768)
			for i=32769, buffer_size do
				buffer[i-32768] = buffer[i]
			end
			buffer_size = buffer_size - 32768
			buffer[buffer_size+1] = nil
			-- NOTE: buffer[32769..end] and buffer[-257..0] are not cleared.
			-- This is why "buffer_size" variable is needed.
		end
	until symbol == 256

	state.buffer_size = buffer_size

	return 0
end

-- Decompress a store block
-- @param state decompression state that will be modified by this function.
-- @return 0 if succeeds, other value if fails.
local function DecompressStoreBlock(state)
	local buffer, buffer_size, ReadBits, ReadBytes, ReaderBitlenLeft
		, SkipToByteBoundary, result_buffer =
		state.buffer, state.buffer_size, state.ReadBits, state.ReadBytes
		, state.ReaderBitlenLeft, state.SkipToByteBoundary, state.result_buffer

	SkipToByteBoundary()
	local bytelen = ReadBits(16)
	if ReaderBitlenLeft() < 0 then
		return 2 -- available inflate data did not terminate
	end
	local bytelenComp = ReadBits(16)
	if ReaderBitlenLeft() < 0 then
		return 2 -- available inflate data did not terminate
	end

	if bytelen % 256 + bytelenComp % 256 ~= 255 then
		return -2 -- Not one's complement
	end
	if (bytelen-bytelen % 256)/256
		+ (bytelenComp-bytelenComp % 256)/256 ~= 255 then
		return -2 -- Not one's complement
	end

	-- Note that ReadBytes will skip to the next byte boundary first.
	buffer_size = ReadBytes(bytelen, buffer, buffer_size)
	if buffer_size < 0 then
		return 2 -- available inflate data did not terminate
	end

	-- memory clean up when there are enough bytes in the buffer.
	if buffer_size >= 65536 then
		result_buffer[#result_buffer+1] = table_concat(buffer, "", 1, 32768)
		for i=32769, buffer_size do
			buffer[i-32768] = buffer[i]
		end
		buffer_size = buffer_size - 32768
		buffer[buffer_size+1] = nil
	end
	state.buffer_size = buffer_size
	return 0
end

-- Decompress a fixed block
-- @param state decompression state that will be modified by this function.
-- @return 0 if succeeds other value if fails.
local function DecompressFixBlock(state)
	return DecodeUntilEndOfBlock(state
		, _fix_block_literal_huffman_bitlen_count
		, _fix_block_literal_huffman_to_deflate_code, 7
		, _fix_block_dist_huffman_bitlen_count
		, _fix_block_dist_huffman_to_deflate_code, 5)
end

-- Decompress a dynamic block
-- @param state decompression state that will be modified by this function.
-- @return 0 if success, other value if fails.
local function DecompressDynamicBlock(state)
	local ReadBits, Decode = state.ReadBits, state.Decode
	local nlen = ReadBits(5) + 257
	local ndist = ReadBits(5) + 1
	local ncode = ReadBits(4) + 4
	if nlen > 286 or ndist > 30 then
		-- dynamic block code description: too many length or distance codes
		return -3
	end

	local rle_codes_huffman_bitlens = {}

	for i = 1, ncode do
		rle_codes_huffman_bitlens[_rle_codes_huffman_bitlen_order[i]] =
			ReadBits(3)
	end

	local rle_codes_err, rle_codes_huffman_bitlen_counts,
		rle_codes_huffman_symbols, rle_codes_huffman_min_bitlen =
		GetHuffmanForDecode(rle_codes_huffman_bitlens, 18, 7)
	if rle_codes_err ~= 0 then -- Require complete code set here
		-- dynamic block code description: code lengths codes incomplete
		return -4
	end

	local lcodes_huffman_bitlens = {}
	local dcodes_huffman_bitlens = {}
	-- Read length/literal and distance code length tables
	local index = 0
	while index < nlen + ndist do
		local symbol -- Decoded value
		local bitlen -- Last length to repeat

		symbol = Decode(rle_codes_huffman_bitlen_counts
			, rle_codes_huffman_symbols, rle_codes_huffman_min_bitlen)

		if symbol < 0 then
			return symbol -- Invalid symbol
		elseif symbol < 16 then
			if index < nlen then
				lcodes_huffman_bitlens[index] = symbol
			else
				dcodes_huffman_bitlens[index-nlen] = symbol
			end
			index = index + 1
		else
			bitlen = 0
			if symbol == 16 then
				if index == 0 then
					-- dynamic block code description: repeat lengths
					-- with no first length
					return -5
				end
				if index-1 < nlen then
					bitlen = lcodes_huffman_bitlens[index-1]
				else
					bitlen = dcodes_huffman_bitlens[index-nlen-1]
				end
				symbol = 3 + ReadBits(2)
			elseif symbol == 17 then -- Repeat zero 3..10 times
				symbol = 3 + ReadBits(3)
			else -- == 18, repeat zero 11.138 times
				symbol = 11 + ReadBits(7)
			end
			if index + symbol > nlen + ndist then
				-- dynamic block code description:
				-- repeat more than specified lengths
				return -6
			end
			while symbol > 0 do -- Repeat last or zero symbol times
				symbol = symbol - 1
				if index < nlen then
					lcodes_huffman_bitlens[index] = bitlen
				else
					dcodes_huffman_bitlens[index-nlen] = bitlen
				end
				index = index + 1
			end
		end
	end

	if (lcodes_huffman_bitlens[256] or 0) == 0 then
		-- dynamic block code description: missing end-of-block code
		return -9
	end

	local lcodes_err, lcodes_huffman_bitlen_counts
		, lcodes_huffman_symbols, lcodes_huffman_min_bitlen =
		GetHuffmanForDecode(lcodes_huffman_bitlens, nlen-1, 15)
	--dynamic block code description: invalid literal/length code lengths,
	-- Incomplete code ok only for single length 1 code
	if (lcodes_err ~=0 and (lcodes_err < 0
		or nlen ~= (lcodes_huffman_bitlen_counts[0] or 0)
			+(lcodes_huffman_bitlen_counts[1] or 0))) then
		return -7
	end

	local dcodes_err, dcodes_huffman_bitlen_counts
		, dcodes_huffman_symbols, dcodes_huffman_min_bitlen =
		GetHuffmanForDecode(dcodes_huffman_bitlens, ndist-1, 15)
	-- dynamic block code description: invalid distance code lengths,
	-- Incomplete code ok only for single length 1 code
	if (dcodes_err ~=0 and (dcodes_err < 0
		or ndist ~= (dcodes_huffman_bitlen_counts[0] or 0)
			+ (dcodes_huffman_bitlen_counts[1] or 0))) then
		return -8
	end

	-- Build buffman table for literal/length codes
	return DecodeUntilEndOfBlock(state, lcodes_huffman_bitlen_counts
		, lcodes_huffman_symbols, lcodes_huffman_min_bitlen
		, dcodes_huffman_bitlen_counts, dcodes_huffman_symbols
		, dcodes_huffman_min_bitlen)
end

-- Decompress a deflate stream
-- @param state: a decompression state
-- @return the decompressed string if succeeds. nil if fails.
local function Inflate(state)
	local ReadBits = state.ReadBits

	local is_last_block
	while not is_last_block do
		is_last_block = (ReadBits(1) == 1)
		local block_type = ReadBits(2)
		local status
		if block_type == 0 then
			status = DecompressStoreBlock(state)
		elseif block_type == 1 then
			status = DecompressFixBlock(state)
		elseif block_type == 2 then
			status = DecompressDynamicBlock(state)
		else
			return nil, -1 -- invalid block type (type == 3)
		end
		if status ~= 0 then
			return nil, status
		end
	end

	state.result_buffer[#state.result_buffer+1] =
		table_concat(state.buffer, "", 1, state.buffer_size)
	local result = table_concat(state.result_buffer)
	return result
end

-- @see LibDeflate:DecompressDeflate(str)
-- @see LibDeflate:DecompressDeflateWithDict(str, dictionary)
local function DecompressDeflateInternal(str, dictionary)
	local state = CreateDecompressState(str, dictionary)
	local result, status = Inflate(state)
	if not result then
		return nil, status
	end

	local bitlen_left = state.ReaderBitlenLeft()
	local bytelen_left = (bitlen_left - bitlen_left % 8) / 8
	return result, bytelen_left
end

-- @see LibDeflate:DecompressZlib(str)
-- @see LibDeflate:DecompressZlibWithDict(str)
local function DecompressZlibInternal(str, dictionary)
	local state = CreateDecompressState(str, dictionary)
	local ReadBits = state.ReadBits

	local CMF = ReadBits(8)
	if state.ReaderBitlenLeft() < 0 then
		return nil, 2 -- available inflate data did not terminate
	end
	local CM = CMF % 16
	local CINFO = (CMF - CM) / 16
	if CM ~= 8 then
		return nil, -12 -- invalid compression method
	end
	if CINFO > 7 then
		return nil, -13 -- invalid window size
	end

	local FLG = ReadBits(8)
	if state.ReaderBitlenLeft() < 0 then
		return nil, 2 -- available inflate data did not terminate
	end
	if (CMF*256+FLG)%31 ~= 0 then
		return nil, -14 -- invalid header checksum
	end

	local FDIST = ((FLG-FLG%32)/32 % 2)
	local FLEVEL = ((FLG-FLG%64)/64 % 4) -- luacheck: ignore FLEVEL

	if FDIST == 1 then
		if not dictionary then
			return nil, -16 -- need dictonary, but dictionary is not provided.
		end
		local byte3 = ReadBits(8)
		local byte2 = ReadBits(8)
		local byte1 = ReadBits(8)
		local byte0 = ReadBits(8)
		local actual_adler32 = byte3*16777216+byte2*65536+byte1*256+byte0
		if state.ReaderBitlenLeft() < 0 then
			return nil, 2 -- available inflate data did not terminate
		end
		if not IsEqualAdler32(actual_adler32, dictionary.adler32) then
			return nil, -17 -- dictionary adler32 does not match
		end
	end
	local result, status = Inflate(state)
	if not result then
		return nil, status
	end
	state.SkipToByteBoundary()

	local adler_byte0 = ReadBits(8)
	local adler_byte1 = ReadBits(8)
	local adler_byte2 = ReadBits(8)
	local adler_byte3 = ReadBits(8)
	if state.ReaderBitlenLeft() < 0 then
		return nil, 2 -- available inflate data did not terminate
	end

	local adler32_expected = adler_byte0*16777216
		+ adler_byte1*65536 + adler_byte2*256 + adler_byte3
	local adler32_actual = LibDeflate:Adler32(result)
	if not IsEqualAdler32(adler32_expected, adler32_actual) then
		return nil, -15 -- Adler32 checksum does not match
	end

	local bitlen_left = state.ReaderBitlenLeft()
	local bytelen_left = (bitlen_left - bitlen_left % 8) / 8
	return result, bytelen_left
end

--- Decompress a raw deflate compressed data.
-- @param str [string] The data to be decompressed.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressDeflate
function LibDeflate:DecompressDeflate(str)
	local arg_valid, arg_err = IsValidArguments(str)
	if not arg_valid then
		error(("Usage: LibDeflate:DecompressDeflate(str): "
			..arg_err), 2)
	end
	return DecompressDeflateInternal(str)
end

--- Decompress a raw deflate compressed data with a preset dictionary.
-- @param str [string] The data to be decompressed.
-- @param dictionary [table] The preset dictionary used by
-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.
-- Decompression and compression must use the same dictionary.
-- Otherwise wrong decompressed data could be produced without generating any
-- error.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressDeflateWithDict
function LibDeflate:DecompressDeflateWithDict(str, dictionary)
	local arg_valid, arg_err = IsValidArguments(str, true, dictionary)
	if not arg_valid then
		error(("Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): "
			..arg_err), 2)
	end
	return DecompressDeflateInternal(str, dictionary)
end

--- Decompress a zlib compressed data.
-- @param str [string] The data to be decompressed
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressZlib
function LibDeflate:DecompressZlib(str)
	local arg_valid, arg_err = IsValidArguments(str)
	if not arg_valid then
		error(("Usage: LibDeflate:DecompressZlib(str): "
			..arg_err), 2)
	end
	return DecompressZlibInternal(str)
end

--- Decompress a zlib compressed data with a preset dictionary.
-- @param str [string] The data to be decompressed
-- @param dictionary [table] The preset dictionary used by
-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.
-- Decompression and compression must use the same dictionary.
-- Otherwise wrong decompressed data could be produced without generating any
-- error.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressZlibWithDict
function LibDeflate:DecompressZlibWithDict(str, dictionary)
	local arg_valid, arg_err = IsValidArguments(str, true, dictionary)
	if not arg_valid then
		error(("Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): "
			..arg_err), 2)
	end
	return DecompressZlibInternal(str, dictionary)
end

-- Calculate the huffman code of fixed block
do
	_fix_block_literal_huffman_bitlen = {}
	for sym=0, 143 do
		_fix_block_literal_huffman_bitlen[sym] = 8
	end
	for sym=144, 255 do
		_fix_block_literal_huffman_bitlen[sym] = 9
	end
	for sym=256, 279 do
	    _fix_block_literal_huffman_bitlen[sym] = 7
	end
	for sym=280, 287 do
		_fix_block_literal_huffman_bitlen[sym] = 8
	end

	_fix_block_dist_huffman_bitlen = {}
	for dist=0, 31 do
		_fix_block_dist_huffman_bitlen[dist] = 5
	end
	local status
	status, _fix_block_literal_huffman_bitlen_count
		, _fix_block_literal_huffman_to_deflate_code =
		GetHuffmanForDecode(_fix_block_literal_huffman_bitlen, 287, 9)
	assert(status == 0)
	status, _fix_block_dist_huffman_bitlen_count,
		_fix_block_dist_huffman_to_deflate_code =
		GetHuffmanForDecode(_fix_block_dist_huffman_bitlen, 31, 5)
	assert(status == 0)

	_fix_block_literal_huffman_code =
		GetHuffmanCodeFromBitlen(_fix_block_literal_huffman_bitlen_count
		, _fix_block_literal_huffman_bitlen, 287, 9)
	_fix_block_dist_huffman_code =
		GetHuffmanCodeFromBitlen(_fix_block_dist_huffman_bitlen_count
		, _fix_block_dist_huffman_bitlen, 31, 5)
end

-- Encoding algorithms
-- Prefix encoding algorithm
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com
-- From LibCompress <https://www.wowace.com/projects/libcompress>,
-- which is licensed under GPLv2
-- The code has been modified by the author of LibDeflate.
------------------------------------------------------------------------------

-- to be able to match any requested byte value, the search
-- string must be preprocessed characters to escape with %:
-- ( ) . % + - * ? [ ] ^ $
-- "illegal" byte values:
-- 0 is replaces %z
local _gsub_escape_table = {
	["\000"] = "%z", ["("] = "%(", [")"] = "%)", ["."] = "%.",
	["%"] = "%%", ["+"] = "%+", ["-"] = "%-", ["*"] = "%*",
	["?"] = "%?", ["["] = "%[", ["]"] = "%]", ["^"] = "%^",
	["$"] = "%$",
}

local function escape_for_gsub(str)
	return str:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])", _gsub_escape_table)
end

--- Create a custom codec with encoder and decoder. <br>
-- This codec is used to convert an input string to make it not contain
-- some specific bytes.
-- This created codec and the parameters of this function do NOT take
-- localization into account. One byte (0-255) in the string is exactly one
-- character (0-255).
-- Credits to LibCompress.
-- @param reserved_chars [string] The created encoder will ensure encoded
-- data does not contain any single character in reserved_chars. This parameter
-- should be non-empty.
-- @param escape_chars [string] The escape character(s) used in the created
-- codec. The codec converts any character included in reserved\_chars /
-- escape\_chars / map\_chars to (one escape char + one character not in
-- reserved\_chars / escape\_chars / map\_chars).
-- You usually only need to provide a length-1 string for this parameter.
-- Length-2 string is only needed when
-- reserved\_chars + escape\_chars + map\_chars is longer than 127.
-- This parameter should be non-empty.
-- @param map_chars [string] The created encoder will map every
-- reserved\_chars:sub(i, i) (1 <= i <= #map\_chars) to map\_chars:sub(i, i).
-- This parameter CAN be empty string.
-- @return [table/nil] If the codec cannot be created, return nil.<br>
-- If the codec can be created according to the given
-- parameters, return the codec, which is a encode/decode table.
-- The table contains two functions: <br>
-- t:Encode(str) returns the encoded string. <br>
-- t:Decode(str) returns the decoded string if succeeds. nil if fails.
-- @return [nil/string] If the codec is successfully created, return nil.
-- If not, return a string that describes the reason why the codec cannot be
-- created.
-- @usage
-- -- Create an encoder/decoder that maps all "\000" to "\003",
-- -- and escape "\001" (and "\002" and "\003") properly
-- local codec = LibDeflate:CreateCodec("\000\001", "\002", "\003")
--
-- local encoded = codec:Encode(SOME_STRING)
-- -- "encoded" does not contain "\000" or "\001"
-- local decoded = codec:Decode(encoded)
-- -- assert(decoded == SOME_STRING)
function LibDeflate:CreateCodec(reserved_chars, escape_chars
	, map_chars)
	-- select a default escape character
	if type(reserved_chars) ~= "string"
		or type(escape_chars) ~= "string"
		or type(map_chars) ~= "string" then
			error(
				"Usage: LibDeflate:CreateCodec(reserved_chars,"
				.." escape_chars, map_chars):"
				.." All arguments must be string.", 2)
	end

	if escape_chars == "" then
		return nil, "No escape characters supplied."
	end
	if #reserved_chars < #map_chars then
		return nil, "The number of reserved characters must be"
			.." at least as many as the number of mapped chars."
	end
	if reserved_chars == "" then
		return nil, "No characters to encode."
	end

	local encode_bytes = reserved_chars..escape_chars..map_chars
	-- build list of bytes not available as a suffix to a prefix byte
	local taken = {}
	for i = 1, #encode_bytes do
		local byte = string_byte(encode_bytes, i, i)
		if taken[byte] then -- Modified by LibDeflate:
			return nil, "There must be no duplicate characters in the"
				.." concatenation of reserved_chars, escape_chars and"
				.." map_chars."
		end
		taken[byte] = true
	end

	-- Modified by LibDeflate:
	-- Store the patterns and replacement in tables for later use.
	-- This function is modified that loadstring() lua api is no longer used.
	local decode_patterns = {}
	local decode_repls = {}

	-- the encoding can be a single gsub
	-- , but the decoding can require multiple gsubs
	local encode_search = {}
	local encode_translate = {}

	-- map single byte to single byte
	if #map_chars > 0 then
		local decode_search = {}
		local decode_translate = {}
		for i = 1, #map_chars do
			local from = string_sub(reserved_chars, i, i)
			local to = string_sub(map_chars, i, i)
			encode_translate[from] = to
			encode_search[#encode_search+1] = from
			decode_translate[to] = from
			decode_search[#decode_search+1] = to
		end
		decode_patterns[#decode_patterns+1] =
			"([".. escape_for_gsub(table_concat(decode_search)).."])"
		decode_repls[#decode_repls+1] = decode_translate
	end

	local escape_char_index = 1
	local escape_char = string_sub(escape_chars
		, escape_char_index, escape_char_index)
	-- map single byte to double-byte
	local r = 0 -- suffix char value to the escapeChar

	local decode_search = {}
	local decode_translate = {}
	for i = 1, #encode_bytes do
		local c = string_sub(encode_bytes, i, i)
		if not encode_translate[c] then
			-- this loop will update escapeChar and r
			while r >= 256 or taken[r] do
			-- Bug in LibCompress r81
			-- while r < 256 and taken[r] do
				r = r + 1
				if r > 255 then -- switch to next escapeChar
					decode_patterns[#decode_patterns+1] =
						escape_for_gsub(escape_char)
						.."(["
						.. escape_for_gsub(table_concat(decode_search)).."])"
					decode_repls[#decode_repls+1] = decode_translate

					escape_char_index = escape_char_index + 1
					escape_char = string_sub(escape_chars, escape_char_index
						, escape_char_index)
					r = 0
					decode_search = {}
					decode_translate = {}

					-- Fixes Another bug in LibCompress r82.
					-- LibCompress checks this error condition
					-- right after "if r > 255 then"
					-- This is why error case should also be tested.
					if not escape_char or escape_char == "" then
						-- actually I don't need to check
						-- "not ecape_char", but what if Lua changes
						-- the behavior of string.sub() in the future?
						-- we are out of escape chars and we need more!
						return nil, "Out of escape characters."
					end
				end
			end

			local char_r = _byte_to_char[r]
			encode_translate[c] = escape_char..char_r
			encode_search[#encode_search+1] = c
			decode_translate[char_r] = c
			decode_search[#decode_search+1] = char_r
			r = r + 1
		end
		if i == #encode_bytes then
			decode_patterns[#decode_patterns+1] =
				escape_for_gsub(escape_char).."(["
				.. escape_for_gsub(table_concat(decode_search)).."])"
			decode_repls[#decode_repls+1] = decode_translate
		end
	end

	local codec = {}

	local encode_pattern = "(["
		.. escape_for_gsub(table_concat(encode_search)).."])"
	local encode_repl = encode_translate

	function codec:Encode(str)
		if type(str) ~= "string" then
			error(("Usage: codec:Encode(str):"
				.." 'str' - string expected got '%s'."):format(type(str)), 2)
		end
		return string_gsub(str, encode_pattern, encode_repl)
	end

	local decode_tblsize = #decode_patterns
	local decode_fail_pattern = "(["
		.. escape_for_gsub(reserved_chars).."])"

	function codec:Decode(str)
		if type(str) ~= "string" then
			error(("Usage: codec:Decode(str):"
				.." 'str' - string expected got '%s'."):format(type(str)), 2)
		end
		if string_find(str, decode_fail_pattern) then
			return nil
		end
		for i = 1, decode_tblsize do
			str = string_gsub(str, decode_patterns[i], decode_repls[i])
		end
		return str
	end

	return codec
end

local _addon_channel_codec

local function GenerateWoWAddonChannelCodec()
	return LibDeflate:CreateCodec("\000", "\001", "")
end

--- Encode the string to make it ready to be transmitted in World of
-- Warcraft addon channel. <br>
-- The encoded string is guaranteed to contain no NULL ("\000") character.
-- @param str [string] The string to be encoded.
-- @return The encoded string.
-- @see LibDeflate:DecodeForWoWAddonChannel
function LibDeflate:EncodeForWoWAddonChannel(str)
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:EncodeForWoWAddonChannel(str):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	if not _addon_channel_codec then
		_addon_channel_codec = GenerateWoWAddonChannelCodec()
	end
	return _addon_channel_codec:Encode(str)
end

--- Decode the string produced by LibDeflate:EncodeForWoWAddonChannel
-- @param str [string] The string to be decoded.
-- @return [string/nil] The decoded string if succeeds. nil if fails.
-- @see LibDeflate:EncodeForWoWAddonChannel
function LibDeflate:DecodeForWoWAddonChannel(str)
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:DecodeForWoWAddonChannel(str):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	if not _addon_channel_codec then
		_addon_channel_codec = GenerateWoWAddonChannelCodec()
	end
	return _addon_channel_codec:Decode(str)
end

-- For World of Warcraft Chat Channel Encoding
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com
-- From LibCompress <https://www.wowace.com/projects/libcompress>,
-- which is licensed under GPLv2
-- The code has been modified by the author of LibDeflate.
-- Following byte values are not allowed:
-- \000, s, S, \010, \013, \124, %
-- Because SendChatMessage will error
-- if an UTF8 multibyte character is incomplete,
-- all character values above 127 have to be encoded to avoid this.
-- This costs quite a bit of bandwidth (about 13-14%)
-- Also, because drunken status is unknown for the received
-- , strings used with SendChatMessage should be terminated with
-- an identifying byte value, after which the server MAY add "...hic!"
-- or as much as it can fit(!).
-- Pass the identifying byte as a reserved character to this function
-- to ensure the encoding doesn't contain that value.
-- or use this: local message, match = arg1:gsub("^(.*)\029.-$", "%1")
-- arg1 is message from channel, \029 is the string terminator
-- , but may be used in the encoded datastream as well. :-)
-- This encoding will expand data anywhere from:
-- 0% (average with pure ascii text)
-- 53.5% (average with random data valued zero to 255)
-- 100% (only encoding data that encodes to two bytes)
local function GenerateWoWChatChannelCodec()
	local r = {}
	for i = 128, 255 do
		r[#r+1] = _byte_to_char[i]
	end

	local reserved_chars = "sS\000\010\013\124%"..table_concat(r)
	return LibDeflate:CreateCodec(reserved_chars
		, "\029\031", "\015\020")
end

local _chat_channel_codec

--- Encode the string to make it ready to be transmitted in World of
-- Warcraft chat channel. <br>
-- See also https://wow.gamepedia.com/ValidChatMessageCharacters
-- @param str [string] The string to be encoded.
-- @return [string] The encoded string.
-- @see LibDeflate:DecodeForWoWChatChannel
function LibDeflate:EncodeForWoWChatChannel(str)
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:EncodeForWoWChatChannel(str):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	if not _chat_channel_codec then
		_chat_channel_codec = GenerateWoWChatChannelCodec()
	end
	return _chat_channel_codec:Encode(str)
end

--- Decode the string produced by LibDeflate:EncodeForWoWChatChannel.
-- @param str [string] The string to be decoded.
-- @return [string/nil] The decoded string if succeeds. nil if fails.
-- @see LibDeflate:EncodeForWoWChatChannel
function LibDeflate:DecodeForWoWChatChannel(str)
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:DecodeForWoWChatChannel(str):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	if not _chat_channel_codec then
		_chat_channel_codec = GenerateWoWChatChannelCodec()
	end
	return _chat_channel_codec:Decode(str)
end

-- Credits to WeakAuras <https://github.com/WeakAuras/WeakAuras2>,
-- and Galmok (galmok@gmail.com) for the 6 bit encoding algorithm.
-- The result of encoding will be 25% larger than the
-- origin string, but every single byte of the encoding result will be
-- printable characters as the following.
local _byte_to_6bit_char = {
	[0]="a", "b", "c", "d", "e", "f", "g", "h",
	"i", "j", "k", "l", "m", "n", "o", "p",
	"q", "r", "s", "t", "u", "v", "w", "x",
	"y", "z", "A", "B", "C", "D", "E", "F",
	"G", "H", "I", "J", "K", "L", "M", "N",
	"O", "P", "Q", "R", "S", "T", "U", "V",
	"W", "X", "Y", "Z", "0", "1", "2", "3",
	"4", "5", "6", "7", "8", "9", "(", ")",
}

local _6bit_to_byte = {
	[97]=0,[98]=1,[99]=2,[100]=3,[101]=4,[102]=5,[103]=6,[104]=7,
	[105]=8,[106]=9,[107]=10,[108]=11,[109]=12,[110]=13,[111]=14,[112]=15,
	[113]=16,[114]=17,[115]=18,[116]=19,[117]=20,[118]=21,[119]=22,[120]=23,
	[121]=24,[122]=25,[65]=26,[66]=27,[67]=28,[68]=29,[69]=30,[70]=31,
	[71]=32,[72]=33,[73]=34,[74]=35,[75]=36,[76]=37,[77]=38,[78]=39,
	[79]=40,[80]=41,[81]=42,[82]=43,[83]=44,[84]=45,[85]=46,[86]=47,
	[87]=48,[88]=49,[89]=50,[90]=51,[48]=52,[49]=53,[50]=54,[51]=55,
	[52]=56,[53]=57,[54]=58,[55]=59,[56]=60,[57]=61,[40]=62,[41]=63,
}

--- Encode the string to make it printable. <br>
--
-- Credis to WeakAuras2, this function is equivalant to the implementation
-- it is using right now. <br>
-- The encoded string will be 25% larger than the origin string. However, every
-- single byte of the encoded string will be one of 64 printable ASCII
-- characters, which are can be easier copied, pasted and displayed.
-- (26 lowercase letters, 26 uppercase letters, 10 numbers digits,
-- left parenthese, or right parenthese)
-- @param str [string] The string to be encoded.
-- @return [string] The encoded string.
function LibDeflate:EncodeForPrint(str)
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:EncodeForPrint(str):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	local strlen = #str
	local strlenMinus2 = strlen - 2
	local i = 1
	local buffer = {}
	local buffer_size = 0
	while i <= strlenMinus2 do
		local x1, x2, x3 = string_byte(str, i, i+2)
		i = i + 3
		local cache = x1+x2*256+x3*65536
		local b1 = cache % 64
		cache = (cache - b1) / 64
		local b2 = cache % 64
		cache = (cache - b2) / 64
		local b3 = cache % 64
		local b4 = (cache - b3) / 64
		buffer_size = buffer_size + 1
		buffer[buffer_size] =
			_byte_to_6bit_char[b1].._byte_to_6bit_char[b2]
			.._byte_to_6bit_char[b3].._byte_to_6bit_char[b4]
	end

	local cache = 0
	local cache_bitlen = 0
	while i <= strlen do
		local x = string_byte(str, i, i)
		cache = cache + x * _pow2[cache_bitlen]
		cache_bitlen = cache_bitlen + 8
		i = i + 1
	end
	while cache_bitlen > 0 do
		local bit6 = cache % 64
		buffer_size = buffer_size + 1
		buffer[buffer_size] = _byte_to_6bit_char[bit6]
		cache = (cache - bit6) / 64
		cache_bitlen = cache_bitlen - 6
	end

	return table_concat(buffer)
end

--- Decode the printable string produced by LibDeflate:EncodeForPrint.
-- "str" will have its prefixed and trailing control characters or space
-- removed before it is decoded, so it is easier to use if "str" comes form
-- user copy and paste with some prefixed or trailing spaces.
-- Then decode fails if the string contains any characters cant be produced by
-- LibDeflate:EncodeForPrint. That means, decode fails if the string contains a
-- characters NOT one of 26 lowercase letters, 26 uppercase letters,
-- 10 numbers digits, left parenthese, or right parenthese.
-- @param str [string] The string to be decoded
-- @return [string/nil] The decoded string if succeeds. nil if fails.
function LibDeflate:DecodeForPrint(str)
	if type(str) ~= "string" then
		error(("Usage: LibDeflate:DecodeForPrint(str):"
			.." 'str' - string expected got '%s'."):format(type(str)), 2)
	end
	str = str:gsub("^[%c ]+", "")
	str = str:gsub("[%c ]+$", "")

	local strlen = #str
	if strlen == 1 then
		return nil
	end
	local strlenMinus3 = strlen - 3
	local i = 1
	local buffer = {}
	local buffer_size = 0
	while i <= strlenMinus3 do
		local x1, x2, x3, x4 = string_byte(str, i, i+3)
		x1 = _6bit_to_byte[x1]
		x2 = _6bit_to_byte[x2]
		x3 = _6bit_to_byte[x3]
		x4 = _6bit_to_byte[x4]
		if not (x1 and x2 and x3 and x4) then
			return nil
		end
		i = i + 4
		local cache = x1+x2*64+x3*4096+x4*262144
		local b1 = cache % 256
		cache = (cache - b1) / 256
		local b2 = cache % 256
		local b3 = (cache - b2) / 256
		buffer_size = buffer_size + 1
		buffer[buffer_size] =
			_byte_to_char[b1].._byte_to_char[b2].._byte_to_char[b3]
	end

	local cache  = 0
	local cache_bitlen = 0
	while i <= strlen do
		local x = string_byte(str, i, i)
		x =  _6bit_to_byte[x]
		if not x then
			return nil
		end
		cache = cache + x * _pow2[cache_bitlen]
		cache_bitlen = cache_bitlen + 6
		i = i + 1
	end

	while cache_bitlen >= 8 do
		local byte = cache % 256
		buffer_size = buffer_size + 1
		buffer[buffer_size] = _byte_to_char[byte]
		cache = (cache - byte) / 256
		cache_bitlen = cache_bitlen - 8
	end

	return table_concat(buffer)
end

local function InternalClearCache()
	_chat_channel_codec = nil
	_addon_channel_codec = nil
end

-- For test. Don't use the functions in this table for real application.
-- Stuffs in this table is subject to change.
LibDeflate.internals = {
	LoadStringToTable = LoadStringToTable,
	IsValidDictionary = IsValidDictionary,
	IsEqualAdler32 = IsEqualAdler32,
	_byte_to_6bit_char = _byte_to_6bit_char,
	_6bit_to_byte = _6bit_to_byte,
	InternalClearCache = InternalClearCache,
}

--[[-- Commandline options
@class table
@name CommandlineOptions
@usage lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]
\-0    store only. no compression.
\-1    fastest compression.
\-9    slowest and best compression.
\-d    do decompression instead of compression.
\--dict <filename> specify the file that contains
the entire preset dictionary.
\-h    give this help.
\--strategy <fixed/huffman_only/dynamic> specify a special compression strategy.
\-v    print the version and copyright info.
\--zlib  use zlib format instead of raw deflate.
]]

-- currently no plan to support stdin and stdout.
-- Because Lua in Windows does not set stdout with binary mode.
if io and os and debug and _G.arg then
	local io = io
	local os = os
	local debug = debug
	local arg = _G.arg
	local debug_info = debug.getinfo(1)
	if debug_info.source == arg[0]
		or debug_info.short_src == arg[0] then
	-- We are indeed runnning THIS file from the commandline.
		local input
		local output
		local i = 1
		local status
		local is_zlib = false
		local is_decompress = false
		local level
		local strategy
		local dictionary
		while (arg[i]) do
			local a = arg[i]
			if a == "-h" then
				print(LibDeflate._COPYRIGHT
					.."\nUsage: lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\n"
					.."  -0    store only. no compression.\n"
					.."  -1    fastest compression.\n"
					.."  -9    slowest and best compression.\n"
					.."  -d    do decompression instead of compression.\n"
					.."  --dict <filename> specify the file that contains"
					.." the entire preset dictionary.\n"
					.."  -h    give this help.\n"
					.."  --strategy <fixed/huffman_only/dynamic>"
					.." specify a special compression strategy.\n"
					.."  -v    print the version and copyright info.\n"
					.."  --zlib  use zlib format instead of raw deflate.\n")
				os.exit(0)
			elseif a == "-v" then
				print(LibDeflate._COPYRIGHT)
				os.exit(0)
			elseif a:find("^%-[0-9]$") then
				level = tonumber(a:sub(2, 2))
			elseif a == "-d" then
				is_decompress = true
			elseif a == "--dict" then
				i = i + 1
				local dict_filename = arg[i]
				if not dict_filename then
					io.stderr:write("You must speicify the dict filename")
					os.exit(1)
				end
				local dict_file, dict_status = io.open(dict_filename, "rb")
				if not dict_file then
					io.stderr:write(
					("LibDeflate: Cannot read the dictionary file '%s': %s")
					:format(dict_filename, dict_status))
					os.exit(1)
				end
				local dict_str = dict_file:read("*all")
				dict_file:close()
				-- In your lua program, you should pass in adler32 as a CONSTANT
				-- , so it actually prevent you from modifying dictionary
				-- unintentionally during the program development. I do this
				-- here just because no convenient way to verify in commandline.
				dictionary = LibDeflate:CreateDictionary(dict_str,
					#dict_str, LibDeflate:Adler32(dict_str))
			elseif a == "--strategy" then
				-- Not sure if I should check error here
				-- If I do, redudant code.
				i = i + 1
				strategy = arg[i]
			elseif a == "--zlib" then
				is_zlib = true
			elseif a:find("^%-") then
				io.stderr:write(("LibDeflate: Invalid argument: %s")
						:format(a))
				os.exit(1)
			else
				if not input then
					input, status = io.open(a, "rb")
					if not input then
						io.stderr:write(
							("LibDeflate: Cannot read the file '%s': %s")
							:format(a, tostring(status)))
						os.exit(1)
					end
				elseif not output then
					output, status = io.open(a, "wb")
					if not output then
						io.stderr:write(
							("LibDeflate: Cannot write the file '%s': %s")
							:format(a, tostring(status)))
						os.exit(1)
					end
				end
			end
			i = i + 1
		end -- while (arg[i])

		if not input or not output then
			io.stderr:write("LibDeflate:"
				.." You must specify both input and output files.")
			os.exit(1)
		end

		local input_data = input:read("*all")
		local configs = {
			level = level,
			strategy = strategy,
		}
		local output_data
		if not is_decompress then
			if not is_zlib then
				if not dictionary then
					output_data =
					LibDeflate:CompressDeflate(input_data, configs)
				else
					output_data =
					LibDeflate:CompressDeflateWithDict(input_data, dictionary
						, configs)
				end
			else
				if not dictionary then
					output_data =
					LibDeflate:CompressZlib(input_data, configs)
				else
					output_data =
					LibDeflate:CompressZlibWithDict(input_data, dictionary
						, configs)
				end
			end
		else
			if not is_zlib then
				if not dictionary then
					output_data = LibDeflate:DecompressDeflate(input_data)
				else
					output_data = LibDeflate:DecompressDeflateWithDict(
						input_data, dictionary)
				end
			else
				if not dictionary then
					output_data = LibDeflate:DecompressZlib(input_data)
				else
					output_data = LibDeflate:DecompressZlibWithDict(
						input_data, dictionary)
				end
			end
		end

		if not output_data then
			io.stderr:write("LibDeflate: Decompress fails.")
			os.exit(1)
		end

		output:write(output_data)
		if input and input ~= io.stdin then
			input:close()
		end
		if output and output ~= io.stdout then
			output:close()
		end

		io.stderr:write(("Successfully writes %d bytes"):format(
			output_data:len()))
		os.exit(0)
	end
end

return LibDeflate


-- ========================================
-- File: WeakAuras/Libs/Archivist/libs/LibStub/LibStub.lua
-- ========================================

-- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/wiki/LibStub for more info
-- LibStub is hereby placed in the Public Domain Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 2  -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
local LibStub = _G[LIBSTUB_MAJOR]

if not LibStub or LibStub.minor < LIBSTUB_MINOR then
	LibStub = LibStub or {libs = {}, minors = {} }
	_G[LIBSTUB_MAJOR] = LibStub
	LibStub.minor = LIBSTUB_MINOR

	function LibStub:NewLibrary(major, minor)
		assert(type(major) == "string", "Bad argument #2 to `NewLibrary' (string expected)")
		minor = assert(tonumber(strmatch(minor, "%d+")), "Minor version must either be a number or contain a number.")

		local oldminor = self.minors[major]
		if oldminor and oldminor >= minor then return nil end
		self.minors[major], self.libs[major] = minor, self.libs[major] or {}
		return self.libs[major], oldminor
	end

	function LibStub:GetLibrary(major, silent)
		if not self.libs[major] and not silent then
			error(("Cannot find a library instance of %q."):format(tostring(major)), 2)
		end
		return self.libs[major], self.minors[major]
	end

	function LibStub:IterateLibraries() return pairs(self.libs) end
	setmetatable(LibStub, { __call = LibStub.GetLibrary })
end


-- ========================================
-- File: WeakAuras/Libs/Archivist/stores/RawData.lua
-- ========================================

--[[
Written in 2019 by Allen Faure (emptyrivers) afaure6@gmail.com

To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide.
This software is distributed without any warranty.
You should have received a copy of the CC0 Public Domain Dedication along with this software.
If not, see http://creativecommons.org/publicdomain/zero/1.0/.
]]

local Archivist = select(2, ...).Archivist

-- super simple data store that just holds data

local prototype = {
	id = "RawData",
	version = 1,
	Create = function(self, data)
		if type(data) ~= "table" then
			data = {}
		end
		return data, data
	end,
	Open = function(self, data) return data end,
	Commit = function(self, store) return store end,
	Close = function(self, store) return store end,
}

Archivist:RegisterStoreType(prototype)


-- ========================================
-- File: WeakAuras/Libs/Archivist/stores/ReadOnly.lua
-- ========================================

--[[
Written in 2019 by Allen Faure (emptyrivers) afaure6@gmail.com

To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide.
This software is distributed without any warranty.
You should have received a copy of the CC0 Public Domain Dedication along with this software.
If not, see http://creativecommons.org/publicdomain/zero/1.0/.
]]

local Archivist = select(2, ...).Archivist

--[[
ReadOnly store type. This is a modification of the RawData type
	so that it is impossible to *edit* a store once Created.
	Close and Commit both return nil, so the only data that
	will ever be archived is what is passed into Create.
	This is primarily useful as a perf optimization in superstores,
	where you might have large-ish data chunks which will never be updated.
	Note that it is an error to Create a ReadOnly store without passing any additional data in.
	This is because Archivist can't serialize a nil value.
	And besides, it wouldn't be very useful to archive a nil value
	that you couldn't ever update.
]]

local prototype = {
  id = "ReadOnly",
  version = 1,
  Create = function(self, data)
    Archivist:Assert(data ~= nil, "A ReadOnly store cannot be created with initial value of nil.")
    return data, data
  end,
  Open = function(self, data)
    return data
  end,
  Commit = function(self)
    return nil
  end,
  Close = function(self)
    return nil
  end,
}

Archivist:RegisterStoreType(prototype)


-- ========================================
-- File: WeakAuras/Libs/CallbackHandler-1.0/CallbackHandler-1.0.lua
-- ========================================

--[[ $Id: CallbackHandler-1.0.lua 26 2022-12-12 15:09:39Z nevcairiel $ ]]
local MAJOR, MINOR = "CallbackHandler-1.0", 8
local CallbackHandler = LibStub:NewLibrary(MAJOR, MINOR)

if not CallbackHandler then return end -- No upgrade needed

local meta = {__index = function(tbl, key) tbl[key] = {} return tbl[key] end}

-- Lua APIs
local securecallfunction, error = securecallfunction, error
local setmetatable, rawget = setmetatable, rawget
local next, select, pairs, type, tostring = next, select, pairs, type, tostring


local function Dispatch(handlers, ...)
	local index, method = next(handlers)
	if not method then return end
	repeat
		securecallfunction(method, ...)
		index, method = next(handlers, index)
	until not method
end

--------------------------------------------------------------------------
-- CallbackHandler:New
--
--   target            - target object to embed public APIs in
--   RegisterName      - name of the callback registration API, default "RegisterCallback"
--   UnregisterName    - name of the callback unregistration API, default "UnregisterCallback"
--   UnregisterAllName - name of the API to unregister all callbacks, default "UnregisterAllCallbacks". false == don't publish this API.

function CallbackHandler.New(_self, target, RegisterName, UnregisterName, UnregisterAllName)

	RegisterName = RegisterName or "RegisterCallback"
	UnregisterName = UnregisterName or "UnregisterCallback"
	if UnregisterAllName==nil then	-- false is used to indicate "don't want this method"
		UnregisterAllName = "UnregisterAllCallbacks"
	end

	-- we declare all objects and exported APIs inside this closure to quickly gain access
	-- to e.g. function names, the "target" parameter, etc


	-- Create the registry object
	local events = setmetatable({}, meta)
	local registry = { recurse=0, events=events }

	-- registry:Fire() - fires the given event/message into the registry
	function registry:Fire(eventname, ...)
		if not rawget(events, eventname) or not next(events[eventname]) then return end
		local oldrecurse = registry.recurse
		registry.recurse = oldrecurse + 1

		Dispatch(events[eventname], eventname, ...)

		registry.recurse = oldrecurse

		if registry.insertQueue and oldrecurse==0 then
			-- Something in one of our callbacks wanted to register more callbacks; they got queued
			for event,callbacks in pairs(registry.insertQueue) do
				local first = not rawget(events, event) or not next(events[event])	-- test for empty before. not test for one member after. that one member may have been overwritten.
				for object,func in pairs(callbacks) do
					events[event][object] = func
					-- fire OnUsed callback?
					if first and registry.OnUsed then
						registry.OnUsed(registry, target, event)
						first = nil
					end
				end
			end
			registry.insertQueue = nil
		end
	end

	-- Registration of a callback, handles:
	--   self["method"], leads to self["method"](self, ...)
	--   self with function ref, leads to functionref(...)
	--   "addonId" (instead of self) with function ref, leads to functionref(...)
	-- all with an optional arg, which, if present, gets passed as first argument (after self if present)
	target[RegisterName] = function(self, eventname, method, ... --[[actually just a single arg]])
		if type(eventname) ~= "string" then
			error("Usage: "..RegisterName.."(eventname, method[, arg]): 'eventname' - string expected.", 2)
		end

		method = method or eventname

		local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.

		if type(method) ~= "string" and type(method) ~= "function" then
			error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - string or function expected.", 2)
		end

		local regfunc

		if type(method) == "string" then
			-- self["method"] calling style
			if type(self) ~= "table" then
				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): self was not a table?", 2)
			elseif self==target then
				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): do not use Library:"..RegisterName.."(), use your own 'self'", 2)
			elseif type(self[method]) ~= "function" then
				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - method '"..tostring(method).."' not found on self.", 2)
			end

			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
				local arg=select(1,...)
				regfunc = function(...) self[method](self,arg,...) end
			else
				regfunc = function(...) self[method](self,...) end
			end
		else
			-- function ref with self=object or self="addonId" or self=thread
			if type(self)~="table" and type(self)~="string" and type(self)~="thread" then
				error("Usage: "..RegisterName.."(self or \"addonId\", eventname, method): 'self or addonId': table or string or thread expected.", 2)
			end

			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
				local arg=select(1,...)
				regfunc = function(...) method(arg,...) end
			else
				regfunc = method
			end
		end


		if events[eventname][self] or registry.recurse<1 then
		-- if registry.recurse<1 then
			-- we're overwriting an existing entry, or not currently recursing. just set it.
			events[eventname][self] = regfunc
			-- fire OnUsed callback?
			if registry.OnUsed and first then
				registry.OnUsed(registry, target, eventname)
			end
		else
			-- we're currently processing a callback in this registry, so delay the registration of this new entry!
			-- yes, we're a bit wasteful on garbage, but this is a fringe case, so we're picking low implementation overhead over garbage efficiency
			registry.insertQueue = registry.insertQueue or setmetatable({},meta)
			registry.insertQueue[eventname][self] = regfunc
		end
	end

	-- Unregister a callback
	target[UnregisterName] = function(self, eventname)
		if not self or self==target then
			error("Usage: "..UnregisterName.."(eventname): bad 'self'", 2)
		end
		if type(eventname) ~= "string" then
			error("Usage: "..UnregisterName.."(eventname): 'eventname' - string expected.", 2)
		end
		if rawget(events, eventname) and events[eventname][self] then
			events[eventname][self] = nil
			-- Fire OnUnused callback?
			if registry.OnUnused and not next(events[eventname]) then
				registry.OnUnused(registry, target, eventname)
			end
		end
		if registry.insertQueue and rawget(registry.insertQueue, eventname) and registry.insertQueue[eventname][self] then
			registry.insertQueue[eventname][self] = nil
		end
	end

	-- OPTIONAL: Unregister all callbacks for given selfs/addonIds
	if UnregisterAllName then
		target[UnregisterAllName] = function(...)
			if select("#",...)<1 then
				error("Usage: "..UnregisterAllName.."([whatFor]): missing 'self' or \"addonId\" to unregister events for.", 2)
			end
			if select("#",...)==1 and ...==target then
				error("Usage: "..UnregisterAllName.."([whatFor]): supply a meaningful 'self' or \"addonId\"", 2)
			end


			for i=1,select("#",...) do
				local self = select(i,...)
				if registry.insertQueue then
					for eventname, callbacks in pairs(registry.insertQueue) do
						if callbacks[self] then
							callbacks[self] = nil
						end
					end
				end
				for eventname, callbacks in pairs(events) do
					if callbacks[self] then
						callbacks[self] = nil
						-- Fire OnUnused callback?
						if registry.OnUnused and not next(callbacks) then
							registry.OnUnused(registry, target, eventname)
						end
					end
				end
			end
		end
	end

	return registry
end


-- CallbackHandler purposefully does NOT do explicit embedding. Nor does it
-- try to upgrade old implicit embeds since the system is selfcontained and
-- relies on closures to work.



-- ========================================
-- File: WeakAuras/Libs/Chomp/Internal.lua
-- ========================================

--[[
	 Justin Snelgrove

	Permission to use, copy, modify, and distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
	SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
	OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
	CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
]]

local VERSION = 32

if IsLoggedIn() then
	error(("Chomp Message Library (embedded: %s) cannot be loaded after login."):format((...)))
	return
end

local Chomp = LibStub:NewLibrary("Chomp", VERSION)

if not Chomp then
	return
end

Chomp.Internal = Chomp.Internal or __chomp_internal or CreateFrame("Frame")
Chomp.Internal.LOADING = true

local Internal = Chomp.Internal

Internal.callbacks = LibStub:GetLibrary("CallbackHandler-1.0"):New(Internal)

--[[
	INTERNAL TABLES
]]

if not Internal.Filter then
	Internal.Filter = {}
end

if not Internal.Prefixes then
	Internal.Prefixes = {}
end

if Internal.ErrorCallbacks then
	-- v18+: Use CallbackHandler internally; relocate any registered error
	--       callbacks to the registry.

	for _, callback in ipairs(Internal.ErrorCallbacks) do
		local event = "OnError"
		local func  = function(_, ...) return callback(...) end
		local owner = tostring(callback)

		Internal.RegisterCallback(owner, event, func)
	end

	Internal.ErrorCallbacks = nil
end

Internal.BITS = {
	SERIALIZE = 0x001,
	CODECV2   = 0x002,  -- Indicates the message should be processed with codec version 2. Relies upon VERSION16.
	UNUSED9   = 0x004,
	VERSION16 = 0x008,  -- Indicates v16+ of Chomp is in use from the sender.
	BROADCAST = 0x010,
	NOTUSED6  = 0x020,  -- This is unused but won't report as such on receipt; use sparingly!
	UNUSED5   = 0x040,
	UNUSED4   = 0x080,
	UNUSED3   = 0x100,
	UNUSED2   = 0x200,
	UNUSED1   = 0x400,
	DEPRECATE = 0x800,
}

Internal.KNOWN_BITS = 0

for purpose, bits in pairs(Internal.BITS) do
	if not purpose:find("UNUSED", nil, true) then
		Internal.KNOWN_BITS = bit.bor(Internal.KNOWN_BITS, bits)
	end
end

--[[
	HELPER FUNCTIONS
]]

local oneTimeError
local function HandleMessageIn(prefix, text, channel, sender, target, zoneChannelID, localID, name, instanceID)
	if not Internal.isReady then
		if not Internal.IncomingQueue then
			Internal.IncomingQueue = {}
		end
		local q = Internal.IncomingQueue
		q[#q + 1] = { prefix, text, channel, sender, target, zoneChannelID, localID, name, instanceID }
		return
	end

	local prefixData = Internal.Prefixes[prefix]
	if not prefixData then
		return
	end

	local bitField, sessionID, msgID, msgTotal, userText = text:match("^(%x%x%x)(%x%x%x)(%x%x%x)(%x%x%x)(.*)$")
	bitField = bitField and tonumber(bitField, 16) or 0
	sessionID = sessionID and tonumber(sessionID, 16) or -1
	msgID = msgID and tonumber(msgID, 16) or 1
	msgTotal = msgTotal and tonumber(msgTotal, 16) or 1

	if userText then
		text = userText
	end

	local method = channel:match("%:(%u+)$")
	if method == "BATTLENET" or method == "LOGGED" then
		text = Internal.DecodeQuotedPrintable(text, method == "LOGGED")
	end

	if bit.bor(bitField, Internal.KNOWN_BITS) ~= Internal.KNOWN_BITS or bit.band(bitField, Internal.BITS.DEPRECATE) == Internal.BITS.DEPRECATE then
		-- Uh, found an unknown bit, or a bit we're explicitly not to parse.
		if not oneTimeError then
			oneTimeError = true
			error("Chomp: Received an addon message that cannot be parsed, check your addons for updates. (This message will only display once per session, but there may be more unusable addon messages.)")
		end
		return
	end

	if not prefixData[sender] then
		prefixData[sender] = {}
	end

	local isBroadcast = bit.band(bitField, Internal.BITS.BROADCAST) == Internal.BITS.BROADCAST
	if isBroadcast then
		if not prefixData.broadcastPrefix then
			-- If the prefix doesn't want broadcast data, don't even parse
			-- further at all.
			return
		end
		if msgID == 1 then
			local broadcastTarget, broadcastText = text:match("^([^\058\127]*)[\058\127](.*)$")
			local ourName = Chomp.NameMergedRealm(UnitFullName("player"))
			if sender == ourName or broadcastTarget ~= "" and broadcastTarget ~= ourName then
				-- Not for us, quit processing.
				return
			else
				target = ourName
				text = broadcastText
			end
		elseif not prefixData[sender][sessionID] then
			-- Already determined this session ID is not for us, or we came in
			-- somewhere in the middle (and can't determine if it was for us).
			return
		else
			target = prefixData[sender][sessionID].broadcastTarget
		end
		-- Last but not least, fake the channel type.
		channel = channel:gsub("^[^%:]+", "WHISPER")
	end

	if prefixData.rawCallback then
		securecallfunction(prefixData.rawCallback, prefix, text, channel, sender, target, zoneChannelID, localID, name, instanceID, nil, nil, nil, sessionID, msgID, msgTotal, bitField)
	end

	local deserialize = bit.band(bitField, Internal.BITS.SERIALIZE) == Internal.BITS.SERIALIZE
	local fullMsgOnly = prefixData.fullMsgOnly or deserialize

	if not prefixData[sender][sessionID] then
		prefixData[sender][sessionID] = {}
		if isBroadcast then
			prefixData[sender][sessionID].broadcastTarget = target
		end
	end
	local buffer = prefixData[sender][sessionID]
	buffer[msgID] = text

	local runHandler = true
	for i = 1, msgTotal do
		if buffer[i] == nil then
			-- msgTotal has changed, either by virtue of being the first
			-- message or by correction in other side's calculations.
			buffer[i] = true
			runHandler = false
		elseif buffer[i] == true then
			-- Need to hold this message until we're ready to process.
			runHandler = false
		elseif runHandler and buffer[i] and (not fullMsgOnly or i == msgTotal) then
			local handlerData = buffer[i]
			-- This message is ready for processing.
			if fullMsgOnly then
				handlerData = table.concat(buffer)
				if deserialize then
					local success, original = pcall(Chomp.Deserialize, handlerData)
					if success then
						handlerData = original
					else
						handlerData = nil
					end
				end
			end
			if prefixData.validTypes[type(handlerData)] then
				securecallfunction(prefixData.callback, prefix, handlerData, channel, sender, target, zoneChannelID, localID, name, instanceID, nil, nil, nil, sessionID, msgID, msgTotal, bitField)
				Internal:TriggerEvent("OnMessageReceived", prefix, handlerData, channel, sender, target, zoneChannelID, localID, name, instanceID, nil, nil, nil, sessionID, msgID, msgTotal, bitField)
			end
			buffer[i] = false
			if i == msgTotal then
				-- Tidy up the garbage when we've processed the last
				-- pending message.
				prefixData[sender][sessionID] = nil
			end
		end
	end
end

local function ParseInGameMessage(prefix, text, kind, sender, target, zoneChannelID, localID, name, instanceID)
	if kind == "WHISPER" then
		target = Chomp.NameMergedRealm(target)
	end
	return prefix, text, kind, Chomp.NameMergedRealm(sender), target, zoneChannelID, localID, name, instanceID
end

local function ParseInGameMessageLogged(prefix, text, kind, sender, target, zoneChannelID, localID, name, instanceID)
	if kind == "WHISPER" then
		target = Chomp.NameMergedRealm(target)
	end
	return prefix, text, ("%s:LOGGED"):format(kind), Chomp.NameMergedRealm(sender), target, zoneChannelID, localID, name, instanceID
end

local function ParseBattleNetMessage(prefix, text, kind, bnetIDGameAccount)
	local name = Internal:GetBattleNetAccountName(bnetIDGameAccount)

	if not name then
		return
	end

	return prefix, text, ("%s:BATTLENET"):format(kind), name, Chomp.NameMergedRealm(UnitName("player")), 0, 0, "", 0
end

function Internal:TriggerEvent(event, ...)
	return self.callbacks:Fire(event, ...)
end

--[[
	FUNCTION HOOKS
]]

-- Hooks don't trigger if the hooked function errors, so there's no need to
-- check parameters, if those parameters cause errors (which most don't now).

local FILTER_PATTERN = ERR_CHAT_PLAYER_NOT_FOUND_S:format("(.+)")
local lastFilteredLineID = nil

if not Internal.MessageFilterKeyCache then
	Internal.MessageFilterKeyCache = {}
end

local function GenerateMessageFilterKey(target)
	-- Due to systemic issues across ourselves, LibMSP, TRP, etc. this
	-- filter has been hacked to only use the character name of the player
	-- and to discard the realm.

	local filterKey = string.split("-", target, 2)

	if string.utf8lower then
		filterKey = string.utf8lower(filterKey)
	else
		filterKey = string.lower(filterKey)
	end

	return filterKey
end

setmetatable(Internal.MessageFilterKeyCache, {
	__index = function(self, target)
		local filterKey = GenerateMessageFilterKey(target)
		self[target] = filterKey
		return filterKey
	end,
})

local function MessageEventFilter_SYSTEM (self, event, text, ...)
	local name = text:match(FILTER_PATTERN)
	if not name then
		return false
	end

	local filterKey = Internal.MessageFilterKeyCache[name]

	if not Internal.Filter[filterKey] or Internal.Filter[filterKey] < GetTime() then
		Internal.Filter[filterKey] = nil
		return false
	end

	local lineID = select(10, ...)

	if lineID ~= lastFilteredLineID then
		Internal:TriggerEvent("OnError", name)
		lastFilteredLineID = lineID
	end

	return true
end

local function HookSendAddonMessage(prefix, text, kind, target)
	if kind == "WHISPER" and target then
		local filterKey = Internal.MessageFilterKeyCache[target]
		Internal.Filter[filterKey] = GetTime() + (select(3, GetNetStats()) * 0.001) + 5.000
	end
end

local function HookSendAddonMessageLogged(prefix, text, kind, target)
	if kind == "WHISPER" and target then
		local filterKey = Internal.MessageFilterKeyCache[target]
		Internal.Filter[filterKey] = GetTime() + (select(3, GetNetStats()) * 0.001) + 5.000
	end
end

--[[
	BATTLE.NET WRAPPER API
]]

local function EnumerateFriendGameAccounts()
	local friendIndex  = 0
	local friendCount  = BNGetNumFriends()
	local accountIndex = 0
	local accountCount = 0

	local function NextGameAccount()
		repeat
			accountIndex = accountIndex + 1

			if accountIndex > accountCount then
				friendIndex  = friendIndex + 1
				accountIndex = 1
				accountCount = C_BattleNet.GetFriendNumGameAccounts(friendIndex)
			end
		until accountIndex <= accountCount or friendIndex > friendCount

		if friendIndex <= friendCount and accountIndex <= accountCount then
			return friendIndex, accountIndex, C_BattleNet.GetFriendGameAccountInfo(friendIndex, accountIndex)
		end
	end

	return NextGameAccount
end

local function CanExchangeWithGameAccount(account)
	if not account.isOnline then
		return false  -- Friend isn't even online.
	elseif account.clientProgram ~= BNET_CLIENT_WOW then
		return false  -- Friend isn't playing WoW. Imagine.
	elseif not account.isInCurrentRegion then
		return false
	end

	local characterName = account.characterName
	local realmName     = account.realmName and Chomp.NormalizeRealmName(account.realmName) or nil
	local factionName   = account.factionName

	if not characterName or characterName == "" or characterName == UNKNOWNOBJECT then
		return false  -- Character name is invalid.
	elseif not realmName or realmName == "" then
		return false  -- Realm name is invalid.
	elseif Internal.SameRealm[realmName] and factionName == UnitFactionGroup("player") then
		return false  -- This character is on the same faction and realm.
	else
		return true
	end
end

function Internal:UpdateBattleNetAccountData()
	self.bnetGameAccounts = {}

	if not BNFeaturesEnabledAndConnected() then
		return  -- Player isn't connected to Battle.net.
	elseif not IsLoggedIn() then
		return  -- Player hasn't yet logged in.
	end

	for _, _, account in EnumerateFriendGameAccounts() do
		if CanExchangeWithGameAccount(account) then
			local characterName = account.characterName
			local realmName = Chomp.NormalizeRealmName(account.realmName)
			local mergedName = Chomp.NameMergedRealm(characterName, realmName)

			self.bnetGameAccounts[mergedName] = account.gameAccountID
		end
	end
end

function Internal:GetBattleNetAccountName(senderAccountID)
	if not BNFeaturesEnabledAndConnected() then
		return nil  -- Player isn't connected to Battle.net.
	elseif not self.bnetGameAccounts then
		return nil  -- We have no game accounts to search.
	end

	for playerName, gameAccountID in pairs(self.bnetGameAccounts) do
		if gameAccountID == senderAccountID then
			return playerName
		end
	end

	return nil
end

function Internal:GetBattleNetAccountID(targetName)
	if not BNFeaturesEnabledAndConnected() then
		return nil  -- Player isn't connected to Battle.net.
	elseif not self.bnetGameAccounts then
		return nil  -- We have no game accounts to search.
	elseif UnitGUID(Ambiguate(targetName, "none")) then
		return nil  -- We think the player is in our group.
	end

	for playerName, gameAccountID in pairs(self.bnetGameAccounts) do
		if strcmputf8i(playerName, targetName) == 0 then
			return gameAccountID
		end
	end

	return nil
end

--[[
	FRAME SCRIPTS
]]

Internal:Hide()
Internal:RegisterEvent("ADDON_LOADED")
Internal:RegisterEvent("CHAT_MSG_ADDON")
Internal:RegisterEvent("CHAT_MSG_ADDON_LOGGED")
Internal:RegisterEvent("BN_CHAT_MSG_ADDON")
Internal:RegisterEvent("PLAYER_LOGIN")
Internal:RegisterEvent("PLAYER_LEAVING_WORLD")
Internal:RegisterEvent("PLAYER_ENTERING_WORLD")
Internal:RegisterEvent("BN_CONNECTED")
Internal:RegisterEvent("BN_DISCONNECTED")
Internal:RegisterEvent("BN_FRIEND_ACCOUNT_OFFLINE")
Internal:RegisterEvent("BN_FRIEND_ACCOUNT_ONLINE")
Internal:RegisterEvent("BN_FRIEND_INFO_CHANGED")
Internal:RegisterEvent("FRIENDLIST_UPDATE")

Internal:SetScript("OnEvent", function(self, event, ...)
	if event == "CHAT_MSG_ADDON" then
		HandleMessageIn(ParseInGameMessage(...))
	elseif event == "CHAT_MSG_ADDON_LOGGED" then
		HandleMessageIn(ParseInGameMessageLogged(...))
	elseif event == "BN_CHAT_MSG_ADDON" then
		HandleMessageIn(ParseBattleNetMessage(...))
	elseif event == "BN_CONNECTED"
		or event == "BN_DISCONNECTED"
		or event == "BN_FRIEND_ACCOUNT_OFFLINE"
		or event == "BN_FRIEND_ACCOUNT_ONLINE"
		or event == "BN_FRIEND_INFO_CHANGED"
		or event == "FRIENDLIST_UPDATE" then
		Internal:UpdateBattleNetAccountData()
	elseif event == "PLAYER_LOGIN" then
		_G.__chomp_internal = nil
		hooksecurefunc(C_ChatInfo, "SendAddonMessage", HookSendAddonMessage)
		hooksecurefunc(C_ChatInfo, "SendAddonMessageLogged", HookSendAddonMessageLogged)
		ChatFrame_AddMessageEventFilter("CHAT_MSG_SYSTEM", MessageEventFilter_SYSTEM)
		self.SameRealm = {}
		self.SameRealm[(Chomp.NormalizeRealmName(GetRealmName()))] = true
		for i, realm in ipairs(GetAutoCompleteRealms()) do
			self.SameRealm[(Chomp.NormalizeRealmName(realm))] = true
		end
		Internal.isReady = true
		if self.IncomingQueue then
			for i, q in ipairs(self.IncomingQueue) do
				HandleMessageIn(unpack(q, 1, 4))
			end
			self.IncomingQueue = nil
		end
		Internal:UpdateBattleNetAccountData()
	elseif event == "PLAYER_LEAVING_WORLD" then
		self.unloadTime = GetTime()
	elseif event == "PLAYER_ENTERING_WORLD" and self.unloadTime then
		local loadTime = GetTime() - self.unloadTime
		for filterKey, filterTime in pairs(self.Filter) do
			if filterTime >= self.unloadTime then
				self.Filter[filterKey] = filterTime + loadTime
			else
				self.Filter[filterKey] = nil
			end
		end
		self.unloadTime = nil
		Internal:UpdateBattleNetAccountData()
	elseif event == "ADDON_LOADED" then
		-- Tweak CTL's conservative estimates.
		if WOW_PROJECT_ID == WOW_PROJECT_MAINLINE then
			ChatThrottleLib.BURST = math.max(ChatThrottleLib.BURST, 6144)
			ChatThrottleLib.MAX_CPS = math.max(ChatThrottleLib.MAX_CPS, 2048)
			ChatThrottleLib.MSG_OVERHEAD = math.min(32, ChatThrottleLib.MSG_OVERHEAD)
		end
	end
end)

Internal.VERSION = VERSION

-- v18+: The future is now old man. These need to exist for compatibility, and
--       to prevent issues where pre-v18 versions would replace newer ones if
--       __chomp_internal were to just disappear.
--
--       Note that we still clear __chomp_internal once PLAYER_LOGIN has
--       fired, but we don't remove  access to it from the library table
--       because being able to inspect it at runtime is nice.

_G.__chomp_internal = Internal
_G.AddOn_Chomp = Chomp


-- ========================================
-- File: WeakAuras/Libs/Chomp/Public.lua
-- ========================================

--[[
	 Justin Snelgrove
	 Morgane Parize

	Permission to use, copy, modify, and distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
	SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
	OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
	CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
]]

local Chomp = LibStub:GetLibrary("Chomp", true)
local Internal = Chomp and Chomp.Internal or nil

if not Chomp or not Internal or not Internal.LOADING then
	return
end

local DEFAULT_PRIORITY = "NORMAL"
local PRIORITIES_HASH = { HIGH = true, MEDIUM = true, LOW = true }
local PRIORITY_TO_CTL = { LOW = "BULK", MEDIUM = "NORMAL", HIGH = "ALERT" }

function Chomp.SendAddonMessage(prefix, text, kind, target, priority, queue, callback, callbackArg)
	if type(prefix) ~= "string" then
		error("Chomp.SendAddonMessage: prefix: expected string, got " .. type(prefix), 2)
	elseif type(text) ~= "string" then
		error("Chomp.SendAddonMessage: text: expected string, got " .. type(text), 2)
	elseif kind == "WHISPER" and type(target) ~= "string" then
		error("Chomp.SendAddonMessage: target: expected string, got " .. type(target), 2)
	elseif kind == "CHANNEL" and type(target) ~= "number" then
		error("Chomp.SendAddonMessage: target: expected number, got " .. type(target), 2)
	elseif priority and not PRIORITIES_HASH[priority] then
		error("Chomp.SendAddonMessage: priority: expected \"HIGH\", \"MEDIUM\", \"LOW\", or nil, got " .. tostring(priority), 2)
	elseif queue and type(queue) ~= "string" then
		error("Chomp.SendAddonMessage: queue: expected string or nil, got " .. type(queue), 2)
	elseif callback and type(callback) ~= "function" then
		error("Chomp.SendAddonMessage: callback: expected function or nil, got " .. type(callback), 2)
	end

	local length = #text
	if length > 255 then
		error("Chomp.SendAddonMessage: text length cannot exceed 255 bytes", 2)
	elseif #prefix > 16 then
		error("Chomp.SendAddonMessage: prefix: length cannot exceed 16 bytes", 2)
	end

	if not kind then
		kind = "PARTY"
	else
		kind = kind:upper()
	end

	ChatThrottleLib:SendAddonMessage(PRIORITY_TO_CTL[priority] or DEFAULT_PRIORITY, prefix, text, kind, target, queue, callback, callbackArg)
end

function Chomp.SendAddonMessageLogged(prefix, text, kind, target, priority, queue, callback, callbackArg)
	if type(prefix) ~= "string" then
		error("Chomp.SendAddonMessageLogged: prefix: expected string, got " .. type(prefix), 2)
	elseif type(text) ~= "string" then
		error("Chomp.SendAddonMessageLogged: text: expected string, got " .. type(text), 2)
	elseif kind == "WHISPER" and type(target) ~= "string" then
		error("Chomp.SendAddonMessageLogged: target: expected string, got " .. type(target), 2)
	elseif kind == "CHANNEL" and type(target) ~= "number" then
		error("Chomp.SendAddonMessageLogged: target: expected number, got " .. type(target), 2)
	elseif priority and not PRIORITIES_HASH[priority] then
		error("Chomp.SendAddonMessageLogged: priority: expected \"HIGH\", \"MEDIUM\", \"LOW\", or nil, got " .. tostring(priority), 2)
	elseif queue and type(queue) ~= "string" then
		error("Chomp.SendAddonMessageLogged: queue: expected string or nil, got " .. type(queue), 2)
	elseif callback and type(callback) ~= "function" then
		error("Chomp.SendAddonMessageLogged: callback: expected function or nil, got " .. type(callback), 2)
	end

	local length = #text
	if length > 255 then
		error("Chomp.SendAddonMessageLogged: text length cannot exceed 255 bytes", 2)
	elseif #prefix > 16 then
		error("Chomp.SendAddonMessageLogged: prefix: length cannot exceed 16 bytes", 2)
	end

	if not kind then
		kind = "PARTY"
	else
		kind = kind:upper()
	end

	ChatThrottleLib:SendAddonMessageLogged(PRIORITY_TO_CTL[priority] or DEFAULT_PRIORITY, prefix, text, kind, target, queue, callback, callbackArg)
end

function Chomp.SendChatMessage(text, kind, language, target, priority, queue, callback, callbackArg)
	if type(text) ~= "string" then
		error("Chomp.SendChatMessage: text: expected string, got " .. type(text), 2)
	elseif language and type(language) ~= "string" and type(language) ~= "number" then
		error("Chomp.SendChatMessage: language: expected string or number, got " .. type(language), 2)
	elseif kind == "WHISPER" and type(target) ~= "string" then
		error("Chomp.SendChatMessage: target: expected string, got " .. type(target), 2)
	elseif kind == "CHANNEL" and type(target) ~= "number" then
		error("Chomp.SendChatMessage: target: expected number, got " .. type(target), 2)
	elseif priority and not PRIORITIES_HASH[priority] then
		error("Chomp.SendChatMessage: priority: expected \"HIGH\", \"MEDIUM\", \"LOW\", or nil, got " .. tostring(priority), 2)
	elseif queue and type(queue) ~= "string" then
		error("Chomp.SendChatMessage: queue: expected string or nil, got " .. type(queue), 2)
	elseif callback and type(callback) ~= "function" then
		error("Chomp.SendChatMessage: callback: expected function or nil, got " .. type(callback), 2)
	end

	local length = #text
	if length > 255 then
		error("Chomp.SendChatMessage: text length cannot exceed 255 bytes", 2)
	end

	if not kind then
		kind = "SAY"
	else
		kind = kind:upper()
	end

	ChatThrottleLib:SendChatMessage(PRIORITY_TO_CTL[priority] or DEFAULT_PRIORITY, "Chomp", text, kind, language, target, queue, callback, callbackArg)
end

function Chomp.BNSendGameData(bnetIDGameAccount, prefix, text, priority, queue, callback, callbackArg)
	if type(prefix) ~= "string" then
		error("Chomp.BNSendGameData: prefix: expected string, got " .. type(text), 2)
	elseif type(text) ~= "string" then
		error("Chomp.BNSendGameData: text: expected string, got " .. type(text), 2)
	elseif type(bnetIDGameAccount) ~= "number" then
		error("Chomp.BNSendGameData: bnetIDGameAccount: expected number, got " .. type(bnetIDGameAccount), 2)
	elseif priority and not PRIORITIES_HASH[priority] then
		error("Chomp.BNSendGameData: priority: expected \"HIGH\", \"MEDIUM\", \"LOW\", or nil, got " .. tostring(priority), 2)
	elseif queue and type(queue) ~= "string" then
		error("Chomp.BNSendGameData: queue: expected string or nil, got " .. type(queue), 2)
	elseif callback and type(callback) ~= "function" then
		error("Chomp.BNSendGameData: callback: expected function or nil, got " .. type(callback), 2)
	end

	local length = #text
	if length > 255 then
		error("Chomp.BNSendGameData: text: length cannot exceed 255 bytes", 2)
	elseif #prefix > 16 then
		error("Chomp.BNSendGameData: prefix: length cannot exceed 16 bytes", 2)
	end

	local kind = "WHISPER"
	ChatThrottleLib:BNSendGameData(PRIORITY_TO_CTL[priority] or DEFAULT_PRIORITY, prefix, text, kind, bnetIDGameAccount, queue, callback, callbackArg)
end

function Chomp.IsSending()
	-- v26+: Removed with no replacement.
	return false
end

local DEFAULT_SETTINGS = {
	fullMsgOnly = true,
	validTypes = {
		["string"] = true,
	},
}
function Chomp.RegisterAddonPrefix(prefix, callback, prefixSettings)
	local prefixType = type(prefix)
	if prefixType ~= "string" then
		error("Chomp.RegisterAddonPrefix: prefix: expected string, got " .. prefixType, 2)
	elseif prefixType == "string" and #prefix > 16 then
		error("Chomp.RegisterAddonPrefix: prefix: length cannot exceed 16 bytes", 2)
	elseif type(callback) ~= "function" then
		error("Chomp.RegisterAddonPrefix: callback: expected function, got " .. type(callback), 2)
	elseif prefixSettings and type(prefixSettings) ~= "table" then
		error("Chomp.RegisterAddonPrefix: prefixSettings: expected table or nil, got " .. type(prefixSettings), 2)
	end
	if not prefixSettings then
		prefixSettings = DEFAULT_SETTINGS
	end
	if prefixSettings.validTypes and type(prefixSettings.validTypes) ~= "table" then
		error("Chomp.RegisterAddonPrefix: prefixSettings.validTypes: expected table or nil, got " .. type(prefixSettings.validTypes), 2)
	elseif prefixSettings.rawCallback and type(prefixSettings.rawCallback) ~= "function" then
		error("Chomp.RegisterAddonPrefix: prefixSettings.rawCallback: expected function or nil, got " .. type(prefixSettings.rawCallback), 2)
	end
	local prefixData = Internal.Prefixes[prefix]
	if not prefixData then
		prefixData = {
			callback = callback,
			rawCallback = prefixSettings.rawCallback,
			fullMsgOnly = prefixSettings.fullMsgOnly,
			broadcastPrefix = prefixSettings.broadcastPrefix,
		}
		local validTypes = prefixSettings.validTypes or DEFAULT_SETTINGS.validTypes
		prefixData.validTypes = {}
		for dataType, func in pairs(Internal.Serialize) do
			if validTypes[dataType] then
				prefixData.validTypes[dataType] = true
			end
		end
		Internal.Prefixes[prefix] = prefixData
		if not C_ChatInfo.IsAddonMessagePrefixRegistered(prefix) then
			C_ChatInfo.RegisterAddonMessagePrefix(prefix)
		end
	else
		error("Chomp.RegisterAddonPrefix: prefix handler already registered, Chomp currently supports only one handler per prefix")
	end
end

function Chomp.IsAddonPrefixRegistered(prefix)
	return Internal.Prefixes[prefix] ~= nil
end

local nextSessionID = math.random(0, 4095)
local function SplitAndSend(sendFunc, maxSize, bitField, prefix, text, ...)
	local textLen = #text
	-- Subtract Chomp metadata from maximum size.
	maxSize = maxSize - 12
	local totalOffset = 0
	local msgID = 0
	local totalMsg = math.ceil(textLen / maxSize)
	local sessionID = nextSessionID
	nextSessionID = (nextSessionID + 1) % 4096
	local position = 1
	while position <= textLen do
		-- Only *need* to do a safe substring for encoded channels, but doing so
		-- always shouldn't hurt.
		local msgText, offset = Chomp.SafeSubString(text, position, position + maxSize - 1, textLen)
		if offset > 0 then
			-- Update total offset and total message number if needed.
			totalOffset = totalOffset + offset
			totalMsg = math.ceil((textLen + totalOffset) / maxSize)
		end
		msgID = msgID + 1
		msgText = ("%03X%03X%03X%03X%s"):format(bitField, sessionID, msgID, totalMsg, msgText)
		sendFunc(prefix, msgText, ...)
		position = position + maxSize - offset
	end
end

local function ToInGame(bitField, prefix, text, kind, target, priority, queue)
	return SplitAndSend(Chomp.SendAddonMessage, 255, bitField, prefix, text, kind, target, priority, queue)
end

local function ToInGameLogged(bitField, prefix, text, kind, target, priority, queue)
	return SplitAndSend(Chomp.SendAddonMessageLogged, 255, bitField, prefix, text, kind, target, priority, queue)
end

local function BNSendGameDataRearrange(prefix, text, bnetIDGameAccount, ...)
	return Chomp.BNSendGameData(bnetIDGameAccount, prefix, text, ...)
end

local function ToBattleNet(bitField, prefix, text, kind, bnetIDGameAccount, priority, queue)
	return SplitAndSend(BNSendGameDataRearrange, 255, bitField, prefix, text, bnetIDGameAccount, priority, queue)
end

local DEFAULT_OPTIONS = {}
function Chomp.SmartAddonMessage(prefix, data, kind, target, messageOptions)
	local prefixData = Internal.Prefixes[prefix]
	if not prefixData then
		error("Chomp.SmartAddonMessage: prefix: prefix has not been registered with Chomp", 2)
	elseif type(kind) ~= "string" then
		error("Chomp.SmartAddonMessage: kind: expected string, got " .. type(kind), 2)
	elseif kind == "WHISPER" and type(target) ~= "string" then
		error("Chomp.SmartAddonMessage: target: expected string, got " .. type(target), 2)
	elseif kind == "CHANNEL" and type(target) ~= "number" then
		error("Chomp.SmartAddonMessage: target: expected number, got " .. type(target), 2)
	elseif target and kind ~= "WHISPER" and kind ~= "CHANNEL" then
		error("Chomp.SmartAddonMessage: target: expected nil, got " .. type(target), 2)
	end

	if not messageOptions then
		messageOptions = DEFAULT_OPTIONS
	end

	local dataType = type(data)
	if not prefixData.validTypes[dataType] then
		error("Chomp.SmartAddonMessage: data: type not registered as valid: " .. dataType, 2)
	elseif dataType ~= "string" and not messageOptions.serialize then
		error("Chomp.SmartAddonMessage: data: no serialization requested, but serialization required for type: " .. dataType, 2)
	elseif messageOptions.priority and not PRIORITIES_HASH[messageOptions.priority] then
		error("Chomp.SmartAddonMessage: messageOptions.priority: expected \"HIGH\", \"MEDIUM\", or \"LOW\", got " .. tostring(messageOptions.priority), 2)
	elseif messageOptions.queue and type(messageOptions.queue) ~= "string" then
		error("Chomp.SmartAddonMessage: messageOptions.queue: expected string or nil, got " .. type(messageOptions.queue), 2)
	end

	local bitField = 0x000

	-- v32: Always set the VERSION16 and CODECV2 bits. Versions older than
	--      this will discard messages without these bits set. Once newer
	--      versions are widely distributed, we can stop setting these bits.
	bitField = bit.bor(bitField, Internal.BITS.VERSION16, Internal.BITS.CODECV2)

	if messageOptions.serialize then
		bitField = bit.bor(bitField, Internal.BITS.SERIALIZE)
		data = Chomp.Serialize(data)
	end
	if not messageOptions.binaryBlob then
		local permitted, reason = Chomp.CheckLoggedContents(data)
		if not permitted then
			error(("Chomp.SmartAddonMessage: data: messageOptions.binaryBlob not specified, but disallowed sequences found, code: %s"):format(reason), 2)
		end
	end

	if kind == "WHISPER" then
		target = Chomp.NameMergedRealm(target)
	end

	if kind == "WHISPER" then
		-- GetBattleNetAccountID() only returns an ID for crossfaction and
		-- crossrealm targets.
		local bnetIDGameAccount = Internal:GetBattleNetAccountID(target)
		if bnetIDGameAccount then
			ToBattleNet(bitField, prefix, Internal.EncodeQuotedPrintable(data, false), kind, bnetIDGameAccount, messageOptions.priority, messageOptions.queue)
			return "BATTLENET"
		end
	end

	if not messageOptions.binaryBlob then
		ToInGameLogged(bitField, prefix, Internal.EncodeQuotedPrintable(data, true), kind, target, messageOptions.priority, messageOptions.queue)
		return "LOGGED"
	end
	ToInGame(bitField, prefix, data, kind, target, messageOptions.priority, messageOptions.queue)
	return "UNLOGGED"
end

function Chomp.CheckReportGUID(prefix, guid)
	-- v26+: Removed with no replacement.
	return false
end

function Chomp.ReportGUID(prefix, guid, customMessage)
	-- v26+: Removed with no replacement.
	return false, ""
end

Chomp.Event = {
	OnMessageReceived = "OnMessageReceived",
	OnError = "OnError",
}

function Chomp.RegisterCallback(event, func, owner)
	if type(event) ~= "string" then
		error("Chomp.RegisterCallback: 'event' must be a string")
	elseif not Chomp.Event[event] then
		error(string.format("Chomp.RegisterCallback: event %q does not exist", event))
	elseif type(func) ~= "function" and type(func) ~= "table" then
		error("Chomp.RegisterCallback: 'func' must be callable")
	elseif type(owner) ~= "string" and type(owner) ~= "table" and type(owner) ~= "thread" then
		error("Chomp.RegisterCallback: 'owner' must be string, table, or coroutine")
	end

	Internal.RegisterCallback(owner, event, function(_, ...) return func(owner, ...) end)
end

function Chomp.UnregisterCallback(event, owner)
	if type(event) ~= "string" then
		error("Chomp.UnregisterCallback: 'event' must be a string")
	elseif not Chomp.Event[event] then
		error(string.format("Chomp.UnregisterCallback: event %q does not exist", event))
	elseif type(owner) ~= "string" and type(owner) ~= "table" and type(owner) ~= "thread" then
		error("Chomp.UnregisterCallback: 'owner' must be string, table, or coroutine")
	end

	Internal.UnregisterCallback(owner, event)
end

function Chomp.UnregisterAllCallbacks(owner)
	if type(owner) ~= "string" and type(owner) ~= "table" and type(owner) ~= "thread" then
		error("Chomp.UnregisterAllCallbacks: 'owner' must be string, table, or coroutine")
	end

	Internal.UnregisterAllCallbacks(owner)
end

function Chomp.RegisterErrorCallback(callback)
	-- v18+: RegisterErrorCallback is deprecated in favor of the generic
	--       RegisterCallback system.

	local event = "OnError"
	local func  = function(_, ...) return callback(...) end
	local owner = tostring(callback)

	Chomp.RegisterCallback(event, func, owner)

	return true
end

function Chomp.UnregisterErrorCallback(callback)
	-- v18+: UnregisterErrorCallback is deprecated in favor of the generic
	--       UnregisterCallback system.

	local event = "OnError"
	local owner = tostring(callback)

	Chomp.UnregisterCallback(event, owner)

	return true
end

-- v18+: Deprecated alias for the old typo'd function name.
Chomp.UnegisterErrorCallback = Chomp.UnregisterErrorCallback

function Chomp.GetBPS()
	return ChatThrottleLib.MAX_CPS, ChatThrottleLib.BURST
end

function Chomp.SetBPS(bps, burst)
	ChatThrottleLib.MAX_CPS = bps
	ChatThrottleLib.BURST = burst
end

function Chomp.GetVersion()
	return Internal.VERSION
end


-- ========================================
-- File: WeakAuras/Libs/Chomp/StringManip.lua
-- ========================================

--[[
	 Justin Snelgrove

	Permission to use, copy, modify, and distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
	SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
	OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
	CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
]]

local Chomp = LibStub:GetLibrary("Chomp", true)
local Internal = Chomp and Chomp.Internal or nil

if not Chomp or not Internal or not Internal.LOADING then
	return
end

local DECODE_PATTERN = "~(%x%x)"
local ESCAPE_CHAR = "~"
local ESCAPE_BYTE = string.byte(ESCAPE_CHAR)
local SAFE_BYTES = {
	[10] = true, -- newline
	[92] = true, -- backslash
	[124] = true, -- pipe
	[126] = true, -- tilde
}

local function DecodeSafeByte(b)
	local byteNum = tonumber(b, 16)
	if SAFE_BYTES[byteNum] then
		return string.char(byteNum)
	else
		return ("~%02X"):format(byteNum)
	end
end

local function EncodeCharToQuotedPrintable(c)
	return ("~%02X"):format(c:byte())
end

local function EncodeStringToQuotedPrintable(s)
	return (s:gsub(".", EncodeCharToQuotedPrintable))
end

local function EncodeTooManyContinuations(s1, s2)
	return s1 .. (s2:gsub(".", EncodeCharToQuotedPrintable))
end

function Chomp.NameMergedRealm(name, realm)
	if type(name) ~= "string" then
		error("Chomp.NameMergedRealm: name: expected string, got " .. type(name), 2)
	elseif name == "" then
		error("Chomp.NameMergedRealm: name: expected non-empty string", 2)
	end

	-- Normally you'd just return the full input name without reformatting,
	-- but Blizzard has started returning an occasional "Name-Realm Name"
	-- combination with spaces and hyphens in the realm name.
	local splitName, splitRealm = Chomp.NameSplitRealm(name)
	if not realm or realm == "" then
		if splitName and splitRealm then
			name = splitName
			realm = splitRealm
		else
			realm = GetRealmName()
		end
	elseif splitRealm then
		error("Chomp.NameMergedRealm: name already has a realm name, but realm name also provided")
	end

	return string.join("-", name, (Chomp.NormalizeRealmName(realm)))
end

function Chomp.NameSplitRealm(nameRealm)
	local name, realm = string.split("-", nameRealm, 2)

	if name and realm and realm ~= "" then
		return name, realm
	end
end

function Chomp.NormalizeRealmName(realmName)
	return (string.gsub(realmName, "[%s%-%.]", ""))
end

local Serialize = setmetatable({}, {
	__index = function(self) return self["default"] end
})

-- This is a meta-type used as a default handler for unknown value types
-- which always errors; no need to explicitly check types elsewhere.
Serialize["default"] = function(input)
	error("invalid type: " .. type(input))
end

Serialize["nil"] = function(input)
	return "nil"
end

function Serialize.boolean(input)
	return tostring(input)
end

function Serialize.number(input)
	return tostring(input)
end

function Serialize.string(input)
	return ("%q"):format(input)
end

local RESERVED_WORDS = tInvert({
	"and", "break", "do", "else", "elseif", "end", "false", "for", "function",
	"if", "in", "local", "nil", "not", "or", "repeat", "return", "then",
	"true", "until", "while",
});

function Serialize.table(input)
	-- These functions are called in loops, so upvalue them eagerly.
	local floor     = math.floor
	local strformat = string.format
	local strfind   = string.find
	local type      = type

	local output = {}

	-- Handle array parts of tables first from `t[1] .. t[n]` where `n` is
	-- the last index before the first nil value.
	local numArray = 0
	for i, v in ipairs(input) do
		output[i] = Serialize[type(v)](v)
		numArray = i
	end

	-- `n` is our current offset for additional entries in the table.
	local n = numArray

	-- Handle the remaining key/value pairs. We want to skip any integral keys
	-- that are within the `t[1] .. t[numArray]` range.
	for k, v in pairs(input) do
		local typeK, typeV = type(k), type(v)
		if typeK ~= "number" or k > numArray or k < 1 or k ~= floor(k) then
			n = n + 1

			if typeK == "string" and strfind(k, "^[a-zA-Z_][a-zA-Z0-9_]*$") and not RESERVED_WORDS[k] then
				-- Optimization for identifier-like string keys (no braces!).
				output[n] = strformat("%s=%s", k, Serialize[typeV](v))
			else
				output[n] = strformat("[%s]=%s", Serialize[typeK](k), Serialize[typeV](v))
			end
		end
	end

	return strformat("{%s}", table.concat(output, ","))
end

Internal.Serialize = Serialize

function Chomp.Serialize(object)
	local objectType = type(object)
	if not rawget(Serialize, type(object)) then
		error("Chomp.Serialize: object: expected serializable type, got " .. objectType, 2)
	end
	local success, serialized = pcall(Serialize[objectType], object)
	if not success then
		error("Chomp.Serialize: object: could not be serialized due to finding unserializable type", 2)
	end
	return serialized
end

local IsTableSafe
function IsTableSafe(t)
	for k,v in pairs(t) do
		local typeK, typeV = type(k), type(v)
		if not Serialize[typeK] or not Serialize[typeV] then
			return false
		elseif typeK == "table" and not IsTableSafe(k) then
			return false
		elseif typeV == "table" and not IsTableSafe(v) then
			return false
		end
	end
	return true
end

local function IsStringLoadSafe(str)
	local strbyte = string.byte
	local strfind = string.find

	local offset = 1
	local length = #str

	local inQuotedString = false

	repeat
		offset = strfind(str, [=[["\(]]=], offset)

		if not offset then
			break
		end

		local byte = strbyte(str, offset, offset)

		if byte == 0x22 then
			inQuotedString = not inQuotedString
		elseif inQuotedString and byte == 0x5c then
			-- Found backslash inside a string, skip next if it's a quote or
			-- another backslash.
			local next = strbyte(str, offset + 1, offset + 1)
			if next == 0x22 or next == 0x5c then
				offset = offset + 1
			end
		elseif not inQuotedString then
			-- Found either a backslash or left-paren outside a string.
			return false, string.format("unexpected character \"%1$s\" at offset %2$d", string.char(byte), offset)
		end

		offset = offset + 1
	until offset > length

	return true
end

local EMPTY_ENV = setmetatable({}, {
	__newindex = function() end,
	__metatable = false,
})

function Chomp.Deserialize(text)
	if type(text) ~= "string" then
		error("Chomp.Deserialize: text: expected string, got " .. type(text), 2)
	end

	local isSafe, reason = IsStringLoadSafe(text)
	if not isSafe then
		error("Chomp.Deserialize: text: " .. reason, 2)
	end

	local func, loadError = loadstring(("return %s"):format(text))
	if not func then
		error("Chomp.Deserialize: text: could not be deserialized: " .. tostring(loadError), 2)
	end

	setfenv(func, EMPTY_ENV)

	local retSuccess, ret = pcall(func)
	local retType = type(ret)

	if not retSuccess then
		error("Chomp.Deserialize: text: error while reading data", 2)
	elseif not Serialize[retType] then
		error("Chomp.Deserialize: text: deserialized to invalid type: " .. type(ret), 2)
	elseif retType == "table" and text:find("function", nil, true) and not IsTableSafe(ret) then
		error("Chomp.Deserialize: text: deserialized table included forbidden type", 2)
	end

	return ret
end

function Chomp.CheckLoggedContents(text)
	if type(text) ~= "string" then
		error("Chomp.CheckLoggedContents: text: expected string, got " .. type(text), 2)
	end
	if text:find("[%z\001-\009\011-\031\127]") then
		return false, "ASCII_CONTROL"
	elseif text:find("\229\141[\141\144]") then
		return false, "BLIZZ_ABUSIVE"
	elseif text:find("[\192\193\245-\255]") then
		return false, "UTF8_UNUSED_BYTE"
	elseif text:find("[\194-\244]+[\194-\244]") then
		return false, "UTF8_MULTIPLE_LEADING"
	elseif text:find("\224[\128-\159][\128-\191]") or text:find("\240[\128-\143][\128-\191][\128-\191]") or text:find("\244[\143-\191][\128-\191][\128-\191]") then
		return false, "UTF8_MALFORMED"
	elseif text:find("\237\158[\154-\191]") or text:find("\237[\159-\191][\128-\191]") then
		return false, "UTF16_RESERVED"
	elseif text:find("[\194-\244]%f[^\128-\191\194-\244]") or text:find("[\224-\244][\128-\191]%f[^\128-\191]") or text:find("[\240-\244][\128-\191][\128-\191]%f[^\128-\191]") then
		return false, "UTF8_MISSING_CONTINUATION"
	elseif text:find("%f[\128-\191\194-\244][\128-\191]+") then
		return false, "UTF8_MISSING_LEADING"
	elseif text:find("[\194-\223][\128-\191][\128-\191]+") or text:find("[\224-\239][\128-\191][\128-\191][\128-\191]+") or text:find("[\240-\244][\128-\191][\128-\191][\128-\191][\128-\191]+") then
		return false, "UTF8_EXTRA_CONTINUATION"
	elseif text:find("\239\191[\190\191]") then
		return false, "UNICODE_INVALID"
	end
	return true, nil
end

function Internal.EncodeQuotedPrintable(text, restrictBinary)
	-- First, the quoted-printable escape character.
	text = text:gsub(ESCAPE_CHAR, EncodeCharToQuotedPrintable)

	if not restrictBinary then
		-- Just NUL, which never works normally.
		text = text:gsub("%z", EncodeCharToQuotedPrintable)

		-- Bytes not used in UTF-8 ever.
		text = text:gsub("[\192\193\245-\255]", EncodeCharToQuotedPrintable)

		-- Multiple leading bytes.
		text = text:gsub("[\194-\244]+[\194-\244]", function(s)
			return (s:gsub(".", EncodeCharToQuotedPrintable, #s - 1))
		end)

		--- Unicode 11.0.0, Table 3-7 malformed UTF-8 byte sequences.
		text = text:gsub("\224[\128-\159][\128-\191]", EncodeStringToQuotedPrintable)
		text = text:gsub("\240[\128-\143][\128-\191][\128-\191]", EncodeStringToQuotedPrintable)
		text = text:gsub("\244[\143-\191][\128-\191][\128-\191]", EncodeStringToQuotedPrintable)

		-- UTF-16 reserved codepoints
		text = text:gsub("\237\158[\154-\191]", EncodeStringToQuotedPrintable)
		text = text:gsub("\237[\159-\191][\128-\191]", EncodeStringToQuotedPrintable)

		-- Unicode invalid codepoints
		text = text:gsub("\239\191[\190\191]", EncodeStringToQuotedPrintable)

		-- 2-4-byte leading bytes without enough continuation bytes.
		text = text:gsub("[\194-\244]%f[^\128-\191\194-\244]", EncodeCharToQuotedPrintable)
		-- 3-4-byte leading bytes without enough continuation bytes.
		text = text:gsub("[\224-\244][\128-\191]%f[^\128-\191]", EncodeStringToQuotedPrintable)
		-- 4-byte leading bytes without enough continuation bytes.
		text = text:gsub("[\240-\244][\128-\191][\128-\191]%f[^\128-\191]", EncodeStringToQuotedPrintable)

		-- Continuation bytes without leading bytes.
		text = text:gsub("%f[\128-\191\194-\244][\128-\191]+", EncodeStringToQuotedPrintable)

		-- 2-byte character with too many continuation bytes
		text = text:gsub("([\194-\223][\128-\191])([\128-\191]+)", EncodeTooManyContinuations)
		-- 3-byte character with too many continuation bytes
		text = text:gsub("([\224-\239][\128-\191][\128-\191])([\128-\191]+)", EncodeTooManyContinuations)
		-- 4-byte character with too many continuation bytes
		text = text:gsub("([\240-\244][\128-\191][\128-\191][\128-\191])([\128-\191]+)", EncodeTooManyContinuations)
	else
		-- Binary-restricted messages don't permit UI escape sequences.
		text = text:gsub("|", EncodeCharToQuotedPrintable)
		-- They're also picky about backslashes -- ex. \\n (literal \n) fails.
		text = text:gsub("\\", EncodeCharToQuotedPrintable)
		-- Newlines are truly necessary but not permitted.
		text = text:gsub("\010", EncodeCharToQuotedPrintable)
	end

	return text
end

function Chomp.EncodeQuotedPrintable(text)
	if type(text) ~= "string" then
		error("Chomp.EncodeQuotedPrintable: text: expected string, got " .. type(text), 2)
	end

	-- First, the quoted-printable escape character.
	text = text:gsub(ESCAPE_CHAR, EncodeCharToQuotedPrintable)

	-- Logged messages don't permit UI escape sequences.
	text = text:gsub("|", EncodeCharToQuotedPrintable)
	-- They're also picky about backslashes -- ex. \\n (literal \n) fails.
	text = text:gsub("\\", EncodeCharToQuotedPrintable)
	-- Some characters are considered abusive-by-default by Blizzard.
	text = text:gsub("\229\141[\141\144]", EncodeStringToQuotedPrintable)
	-- ASCII control characters. \009 and \127 are allowed for some reason.
	text = text:gsub("[%z\001-\008\010-\031]", EncodeCharToQuotedPrintable)

	-- Bytes not used in UTF-8 ever.
	text = text:gsub("[\192\193\245-\255]", EncodeCharToQuotedPrintable)

	-- Multiple leading bytes.
	text = text:gsub("[\194-\244]+[\194-\244]", function(s)
		return (s:gsub(".", EncodeCharToQuotedPrintable, #s - 1))
	end)

	--- Unicode 11.0.0, Table 3-7 malformed UTF-8 byte sequences.
	text = text:gsub("\224[\128-\159][\128-\191]", EncodeStringToQuotedPrintable)
	text = text:gsub("\240[\128-\143][\128-\191][\128-\191]", EncodeStringToQuotedPrintable)
	text = text:gsub("\244[\143-\191][\128-\191][\128-\191]", EncodeStringToQuotedPrintable)

	-- UTF-16 reserved codepoints
	text = text:gsub("\237\158[\154-\191]", EncodeStringToQuotedPrintable)
	text = text:gsub("\237[\159-\191][\128-\191]", EncodeStringToQuotedPrintable)

	-- Unicode invalid codepoints
	text = text:gsub("\239\191[\190\191]", EncodeStringToQuotedPrintable)

	-- 2-4-byte leading bytes without enough continuation bytes.
	text = text:gsub("[\194-\244]%f[^\128-\191\194-\244]", EncodeCharToQuotedPrintable)
	-- 3-4-byte leading bytes without enough continuation bytes.
	text = text:gsub("[\224-\244][\128-\191]%f[^\128-\191]", EncodeStringToQuotedPrintable)
	-- 4-byte leading bytes without enough continuation bytes.
	text = text:gsub("[\240-\244][\128-\191][\128-\191]%f[^\128-\191]", EncodeStringToQuotedPrintable)

	-- Continuation bytes without leading bytes.
	text = text:gsub("%f[\128-\191\194-\244][\128-\191]+", EncodeStringToQuotedPrintable)

	-- 2-byte character with too many continuation bytes
	text = text:gsub("([\194-\223][\128-\191])([\128-\191]+)", EncodeTooManyContinuations)
	-- 3-byte character with too many continuation bytes
	text = text:gsub("([\224-\239][\128-\191][\128-\191])([\128-\191]+)", EncodeTooManyContinuations)
	-- 4-byte character with too many continuation bytes
	text = text:gsub("([\240-\244][\128-\191][\128-\191][\128-\191])([\128-\191]+)", EncodeTooManyContinuations)

	return text
end

local function DecodeAnyByte(b)
	return string.char(tonumber(b, 16))
end

function Internal.DecodeQuotedPrintable(text, restrictBinary)
	local decodedText = text:gsub(DECODE_PATTERN, not restrictBinary and DecodeAnyByte or DecodeSafeByte)
	return decodedText
end

function Chomp.DecodeQuotedPrintable(text)
	if type(text) ~= "string" then
		error("Chomp.DecodeQuotedPrintable: text: expected string, got " .. type(text), 2)
	end

	local decodedText = text:gsub(DECODE_PATTERN, DecodeAnyByte)
	return decodedText
end

function Chomp.SafeSubString(text, first, last, textLen)
	if type(text) ~= "string" then
		error("Chomp.SafeSubString: text: expected string, got " .. type(text), 2)
	elseif type(first) ~= "number" then
		error("Chomp.SafeSubString: first: expected number, got " .. type(first), 2)
	elseif type(last) ~= "number" then
		error("Chomp.SafeSubString: last: expected number, got " .. type(last), 2)
	elseif textLen and type(textLen) ~= "number" then
		error("Chomp.SafeSubString: textLen: expected number or nil, got " .. type(textLen), 2)
	end

	local offset = 0
	if not textLen then
		textLen = #text
	end
	if first > textLen then
		error("Chomp.SafeSubString: first: starting index exceeds text length", 2)
	end
	if textLen > last then
		local b3, b2, b1 = text:byte(last - 2, last)
		if b1 == ESCAPE_BYTE or (b1 >= 194 and b1 <= 244) then
			offset = 1
		elseif b2 == ESCAPE_BYTE or (b2 >= 224 and b2 <= 244) then
			offset = 2
		elseif b3 >= 240 and b3 <= 244 then
			offset = 3
		end
	end
	return (text:sub(first, last - offset)), offset
end

function Chomp.InsensitiveStringEquals(a, b)
	if a == b then
		return true
	end

	if type(a) ~= "string" or type(b) ~= "string" then
		return false
	end

	return strcmputf8i(a, b) == 0
end


-- ========================================
-- File: WeakAuras/Libs/LibCompress/LibCompress.lua
-- ========================================

----------------------------------------------------------------------------------
--
-- LibCompress.lua
--
-- Authors: jjsheets and Galmok of European Stormrage (Horde)
-- Email : sheets.jeff@gmail.com and galmok@gmail.com
-- Licence: GPL version 2 (General Public License)
-- Revision: $Revision: 83 $
-- Date: $Date: 2018-07-03 14:33:48 +0000 (Tue, 03 Jul 2018) $
----------------------------------------------------------------------------------


local LibCompress = LibStub:NewLibrary("LibCompress", 90000 + tonumber(("$Revision: 83 $"):match("%d+")))

if not LibCompress then return end

-- list of codecs in this file:
-- \000 - Never used
-- \001 - Uncompressed
-- \002 - LZW
-- \003 - Huffman


-- local is faster than global
local CreateFrame = CreateFrame
local type = type
local tostring = tostring
local select = select
local next = next
local loadstring = loadstring
local setmetatable = setmetatable
local rawset = rawset
local assert = assert
local table_insert = table.insert
local table_remove = table.remove
local table_concat = table.concat
local string_char = string.char
local string_byte = string.byte
local string_len = string.len
local string_sub = string.sub
local unpack = unpack
local pairs = pairs
local math_modf = math.modf
local bit_band = bit.band
local bit_bor = bit.bor
local bit_bxor = bit.bxor
local bit_bnot = bit.bnot
local bit_lshift = bit.lshift
local bit_rshift = bit.rshift

--------------------------------------------------------------------------------
-- Cleanup

local tables = {} -- tables that may be cleaned have to be kept here
local tables_to_clean = {} -- list of tables by name (string) that may be reset to {} after a timeout

-- tables that may be erased
local function cleanup()
	for k,v in pairs(tables_to_clean) do
		tables[k] = {}
		tables_to_clean[k] = nil
	end
end

local timeout = -1
local function onUpdate(frame, elapsed)
	frame:Hide()
	timeout = timeout - elapsed
	if timeout <= 0 then
		cleanup()
	end
end

LibCompress.frame = LibCompress.frame or CreateFrame("frame", nil, UIParent) -- reuse the old frame
LibCompress.frame:SetScript("OnUpdate", onUpdate)
LibCompress.frame:Hide()

local function setCleanupTables(...)
	timeout = 15 -- empty tables after 15 seconds
	if not LibCompress.frame:IsShown() then
		LibCompress.frame:Show()
	end
	for i = 1, select("#",...) do
		tables_to_clean[(select(i, ...))] = true
	end
end

----------------------------------------------------------------------
----------------------------------------------------------------------
--
-- compression algorithms

--------------------------------------------------------------------------------
-- LZW codec
-- implemented by sheets.jeff@gmail.com

-- encode is used to uniquely encode a number into a sequence of bytes that can be decoded using decode()
-- the bytes returned by this do not contain "\000"
local bytes = {}
local function encode(x)
	for k = 1, #bytes do
		bytes[k] = nil
	end

	bytes[#bytes + 1] = x % 255
	x=math.floor(x/255)

	while x > 0 do
		bytes[#bytes + 1] = x % 255
		x=math.floor(x/255)
	end
	if #bytes == 1 and bytes[1] > 0 and bytes[1] < 250 then
		return string_char(bytes[1])
	else
		for i = 1, #bytes do
			bytes[i] = bytes[i] + 1
		end
		return string_char(256 - #bytes, unpack(bytes))
	end
end

--decode converts a unique character sequence into its equivalent number, from ss, beginning at the ith char.
-- returns the decoded number and the count of characters used in the decode process.
local function decode(ss, i)
	i = i or 1
	local a = string_byte(ss, i, i)
	if a > 249 then
		local r = 0
		a = 256 - a
		for n = i + a, i + 1, -1 do
			r = r * 255 + string_byte(ss, n, n) - 1
		end
		return r, a + 1
	else
		return a, 1
	end
end

-- Compresses the given uncompressed string.
-- Unless the uncompressed string starts with "\002", this is guaranteed to return a string equal to or smaller than
-- the passed string.
-- the returned string will only contain "\000" characters in rare circumstances, and will contain none if the
-- source string has none.
local dict = {}
function LibCompress:CompressLZW(uncompressed)
	if type(uncompressed) == "string" then
		local dict_size = 256
		for k in pairs(dict) do
			dict[k] = nil
		end

		local result = {"\002"}
		local w = ''
		local ressize = 1

		for i = 0, 255 do
			dict[string_char(i)] = i
		end

		for i = 1, #uncompressed do
			local c = uncompressed:sub(i, i)
			local wc = w..c
			if dict[wc] then
				w = wc
			else
				dict[wc] = dict_size
				dict_size = dict_size + 1
				local r = encode(dict[w])
				ressize = ressize + #r
				result[#result + 1] = r
				w = c
			end
		end

		if w then
			local r = encode(dict[w])
			ressize = ressize + #r
			result[#result + 1] = r
		end

		if (#uncompressed + 1) > ressize then
			return table_concat(result)
		else
			return string_char(1)..uncompressed
		end
	else
		return nil, "Can only compress strings"
	end
end

-- if the passed string is a compressed string, this will decompress it and return the decompressed string.
-- Otherwise it return an error message
-- compressed strings are marked by beginning with "\002"
function LibCompress:DecompressLZW(compressed)
	if type(compressed) == "string" then
		if compressed:sub(1, 1) ~= "\002" then
			return nil, "Can only decompress LZW compressed data ("..tostring(compressed:sub(1, 1))..")"
		end

		compressed = compressed:sub(2)
		local dict_size = 256

		for k in pairs(dict) do
			dict[k] = nil
		end

		for i = 0, 255 do
			dict[i] = string_char(i)
		end

		local result = {}
		local t = 1
		local delta, k
		k, delta = decode(compressed, t)
		t = t + delta
		result[#result + 1] = dict[k]

		local w = dict[k]
		local entry
		while t <= #compressed do
			k, delta = decode(compressed, t)
			t = t + delta
			entry = dict[k] or (w..w:sub(1, 1))
			result[#result + 1] = entry
			dict[dict_size] = w..entry:sub(1, 1)
			dict_size = dict_size + 1
			w = entry
		end
		return table_concat(result)
	else
		return nil, "Can only uncompress strings"
	end
end


--------------------------------------------------------------------------------
-- Huffman codec
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com

local function addCode(tree, bcode, length)
	if tree then
		tree.bcode = bcode
		tree.blength = length
		if tree.c1 then
			addCode(tree.c1, bit_bor(bcode, bit_lshift(1, length)), length + 1)
		end
		if tree.c2 then
			addCode(tree.c2, bcode, length + 1)
		end
	end
end

local function escape_code(code, length)
	local escaped_code = 0
	local b
	local l = 0
	for i = length -1, 0, - 1 do
		b = bit_band(code, bit_lshift(1, i)) == 0 and 0 or 1
		escaped_code = bit_lshift(escaped_code, 1 + b) + b
		l = l + b
	end
	if length + l > 32 then
		return nil, "escape overflow ("..(length + l)..")"
	end
	return escaped_code, length + l
end

tables.Huffman_compressed = {}
tables.Huffman_large_compressed = {}

local compressed_size = 0
local remainder
local remainder_length
local function addBits(tbl, code, length)
	if remainder_length+length >= 32 then
		-- we have at least 4 bytes to store; bulk it
		remainder = remainder + bit_lshift(code, remainder_length) -- this overflows! Top part of code is lost (but we handle it below)
		-- remainder now holds 4 full bytes to store. So lets do it.
		compressed_size = compressed_size + 1
		tbl[compressed_size] = string_char(bit_band(remainder, 255)) ..
			string_char(bit_band(bit_rshift(remainder, 8), 255)) ..
			string_char(bit_band(bit_rshift(remainder, 16), 255)) ..
			string_char(bit_band(bit_rshift(remainder, 24), 255))
		remainder = 0
		code = bit_rshift(code, 32 - remainder_length)
		length =  remainder_length + length - 32
		remainder_length = 0
	end
	if remainder_length+length >= 16 then
		-- we have at least 2 bytes to store; bulk it
		remainder = remainder + bit_lshift(code, remainder_length)
		remainder_length = length + remainder_length
		-- remainder now holds at least 2 full bytes to store. So lets do it.
		compressed_size = compressed_size + 1
		tbl[compressed_size] = string_char(bit_band(remainder, 255)) .. string_char(bit_band(bit_rshift(remainder, 8), 255))
		remainder = bit_rshift(remainder, 16)
		code = remainder
		length = remainder_length - 16
		remainder = 0
		remainder_length = 0
	end
	remainder = remainder + bit_lshift(code, remainder_length)
	remainder_length = length + remainder_length
	if remainder_length >= 8 then
		compressed_size = compressed_size + 1
		tbl[compressed_size] = string_char(bit_band(remainder, 255))
		remainder = bit_rshift(remainder, 8)
		remainder_length = remainder_length -8
	end
end

-- word size for this huffman algorithm is 8 bits (1 byte).
-- this means the best compression is representing 1 byte with 1 bit, i.e. compress to 0.125 of original size.
function LibCompress:CompressHuffman(uncompressed)
	if type(uncompressed) ~= "string" then
		return nil, "Can only compress strings"
	end
	if #uncompressed == 0 then
		return "\001"
	end

	-- make histogram
	local hist = {}
	-- don't have to use all data to make the histogram
	local uncompressed_size = string_len(uncompressed)
	local c
	for i = 1, uncompressed_size do
		c = string_byte(uncompressed, i)
		hist[c] = (hist[c] or 0) + 1
	end

	--Start with as many leaves as there are symbols.
	local leafs = {}
	local leaf
	local symbols = {}
	for symbol, weight in pairs(hist) do
		leaf = { symbol=string_char(symbol), weight=weight }
		symbols[symbol] = leaf
		table_insert(leafs, leaf)
	end

	-- Enqueue all leaf nodes into the first queue (by probability in increasing order,
	-- so that the least likely item is in the head of the queue).
	sort(leafs, function(a, b)
		if a.weight < b.weight then
			return true
		elseif a.weight > b.weight then
			return false
		else
			return nil
		end
	end)

	local nLeafs = #leafs

	-- create tree
	local huff = {}
	--While there is more than one node in the queues:
	local length, height, li, hi, leaf1, leaf2
	local newNode
	while (#leafs + #huff > 1) do
		-- Dequeue the two nodes with the lowest weight.
		-- Dequeue first
		if not next(huff) then
			li, leaf1 = next(leafs)
			table_remove(leafs, li)
		elseif not next(leafs) then
			hi, leaf1 = next(huff)
			table_remove(huff, hi)
		else
			li, length = next(leafs)
			hi, height = next(huff)
			if length.weight <= height.weight then
				leaf1 = length
				table_remove(leafs, li)
			else
				leaf1 = height
				table_remove(huff, hi)
			end
		end

		-- Dequeue second
		if not next(huff) then
			li, leaf2 = next(leafs)
			table_remove(leafs, li)
		elseif not next(leafs) then
			hi, leaf2 = next(huff)
			table_remove(huff, hi)
		else
			li, length = next(leafs)
			hi, height = next(huff)
			if length.weight <= height.weight then
				leaf2 = length
				table_remove(leafs, li)
			else
				leaf2 = height
				table_remove(huff, hi)
			end
		end

		--Create a new internal node, with the two just-removed nodes as children (either node can be either child) and the sum of their weights as the new weight.
		newNode = {
			c1 = leaf1,
			c2 = leaf2,
			weight = leaf1.weight + leaf2.weight
		}
		table_insert(huff,newNode)
	end

	if #leafs > 0 then
		li, length = next(leafs)
		table_insert(huff, length)
		table_remove(leafs, li)
	end
	huff = huff[1]

	-- assign codes to each symbol
	-- c1 = "0", c2 = "1"
	-- As a common convention, bit '0' represents following the left child and bit '1' represents following the right child.
	-- c1 = left, c2 = right

	addCode(huff, 0, 0)
	if huff then
		huff.bcode = 0
		huff.blength = 1
	end

	-- READING
	-- bitfield = 0
	-- bitfield_len = 0
	-- read byte1
	-- bitfield = bitfield + bit_lshift(byte1, bitfield_len)
	-- bitfield_len = bitfield_len + 8
	-- read byte2
	-- bitfield = bitfield + bit_lshift(byte2, bitfield_len)
	-- bitfield_len = bitfield_len + 8
	-- (use 5 bits)
	--	word = bit_band( bitfield, bit_lshift(1,5)-1)
	--	bitfield = bit_rshift( bitfield, 5)
	--	bitfield_len = bitfield_len - 5
	-- read byte3
	-- bitfield = bitfield + bit_lshift(byte3, bitfield_len)
	-- bitfield_len = bitfield_len + 8

	-- WRITING
	remainder = 0
	remainder_length = 0

	local compressed = tables.Huffman_compressed
	--compressed_size = 0

	-- first byte is version info. 0 = uncompressed, 1 = 8 - bit word huffman compressed
	compressed[1] = "\003"

	-- Header: byte 0 = #leafs, bytes 1-3 = size of uncompressed data
	-- max 2^24 bytes
	length = string_len(uncompressed)
	compressed[2] = string_char(bit_band(nLeafs -1, 255))	-- number of leafs
	compressed[3] = string_char(bit_band(length, 255))			-- bit 0-7
	compressed[4] = string_char(bit_band(bit_rshift(length, 8), 255))	-- bit 8-15
	compressed[5] = string_char(bit_band(bit_rshift(length, 16), 255))	-- bit 16-23
	compressed_size = 5

	-- create symbol/code map
	local escaped_code, escaped_code_len, success, msg
	for symbol, leaf in pairs(symbols) do
		addBits(compressed, symbol, 8)
		escaped_code, escaped_code_len = escape_code(leaf.bcode, leaf.blength)
		if not escaped_code then
			return nil, escaped_code_len
		end
		addBits(compressed, escaped_code, escaped_code_len)
		addBits(compressed, 3, 2)
	end

	-- create huffman code
	local large_compressed = tables.Huffman_large_compressed
	local large_compressed_size = 0
	local ulimit
	for i = 1, length, 200 do
		ulimit = length < (i + 199) and length or (i + 199)

		for sub_i = i, ulimit do
			c = string_byte(uncompressed, sub_i)
			addBits(compressed, symbols[c].bcode, symbols[c].blength)
		end

		large_compressed_size = large_compressed_size + 1
		large_compressed[large_compressed_size] = table_concat(compressed, "", 1, compressed_size)
		compressed_size = 0
	end

	-- add remaining bits (if any)
	if remainder_length > 0 then
		large_compressed_size = large_compressed_size + 1
		large_compressed[large_compressed_size] = string_char(remainder)
	end
	local compressed_string = table_concat(large_compressed, "", 1, large_compressed_size)

	-- is compression worth it? If not, return uncompressed data.
	if (#uncompressed + 1) <= #compressed_string then
		return "\001"..uncompressed
	end

	setCleanupTables("Huffman_compressed", "Huffman_large_compressed")
	return compressed_string
end

-- lookuptable (cached between calls)
local lshiftMask = {}
setmetatable(lshiftMask, {
	__index = function (t, k)
		local v = bit_lshift(1, k)
		rawset(t, k, v)
		return v
	end
})

-- lookuptable (cached between calls)
local lshiftMinusOneMask = {}
setmetatable(lshiftMinusOneMask, {
	__index = function (t, k)
		local v = bit_lshift(1, k) -  1
		rawset(t, k, v)
		return v
	end
})

local function bor64(valueA_high, valueA, valueB_high, valueB)
	return bit_bor(valueA_high, valueB_high),
		bit_bor(valueA, valueB)
end

local function band64(valueA_high, valueA, valueB_high, valueB)
	return bit_band(valueA_high, valueB_high),
		bit_band(valueA, valueB)
end

local function lshift64(value_high, value, lshift_amount)
	if lshift_amount == 0 then
		return value_high, value
	end
	if lshift_amount >= 64 then
		return 0, 0
	end
	if lshift_amount < 32 then
		return bit_bor(bit_lshift(value_high, lshift_amount), bit_rshift(value, 32-lshift_amount)),
			bit_lshift(value, lshift_amount)
	end
	-- 32-63 bit shift
	return bit_lshift(value, lshift_amount), -- builtin modulus 32 on shift amount
		0
end

local function rshift64(value_high, value, rshift_amount)
	if rshift_amount == 0 then
		return value_high, value
	end
	if rshift_amount >= 64 then
		return 0, 0
	end
	if rshift_amount < 32 then
		return bit_rshift(value_high, rshift_amount),
			bit_bor(bit_lshift(value_high, 32-rshift_amount), bit_rshift(value, rshift_amount))
	end
	-- 32-63 bit shift
	return 0,
		bit_rshift(value_high, rshift_amount)
end

local function getCode2(bitfield_high, bitfield, field_len)
	if field_len >= 2 then
		-- [bitfield_high..bitfield]: bit 0 is right most in bitfield. bit <field_len-1> is left most in bitfield_high
		local b1, b2, remainder_high, remainder
		for i = 0, field_len - 2 do
			b1 = i <= 31 and bit_band(bitfield, bit_lshift(1, i)) or bit_band(bitfield_high, bit_lshift(1, i)) -- for shifts, 32 = 0 (5 bit used)
			b2 = (i+1) <= 31 and bit_band(bitfield, bit_lshift(1, i+1)) or bit_band(bitfield_high, bit_lshift(1, i+1))
			if not (b1 == 0) and not (b2 == 0) then
				-- found 2 bits set right after each other (stop bits) with i pointing at the first stop bit
				-- return the two bitfields separated by the two stopbits (3 values for each: bitfield_high, bitfield, field_len)
				-- bits left: field_len - (i+2)
				remainder_high, remainder = rshift64(bitfield_high, bitfield, i+2)
				-- first bitfield is the lower part
				return (i-1) >= 32 and bit_band(bitfield_high, bit_lshift(1, i) - 1) or 0,
					i >= 32 and bitfield or bit_band(bitfield, bit_lshift(1, i) - 1),
					i,
					remainder_high,
					remainder,
					field_len-(i+2)
			end
		end
	end
	return nil
end

local function unescape_code(code, code_len)
	local unescaped_code = 0
	local b
	local l = 0
	local i = 0
	while i < code_len do
		b = bit_band( code, lshiftMask[i])
		if not (b == 0) then
			unescaped_code = bit_bor(unescaped_code, lshiftMask[l])
			i = i + 1
		end
		i = i + 1
		l = l + 1
	end
	return unescaped_code, l
end

tables.Huffman_uncompressed = {}
tables.Huffman_large_uncompressed = {} -- will always be as big as the largest string ever decompressed. Bad, but clearing it every time takes precious time.

function LibCompress:DecompressHuffman(compressed)
	if not type(compressed) == "string" then
		return nil, "Can only uncompress strings"
	end

	local compressed_size = #compressed
	--decode header
	local info_byte = string_byte(compressed)
	-- is data compressed
	if info_byte == 1 then
		return compressed:sub(2) --return uncompressed data
	end
	if not (info_byte == 3) then
		return nil, "Can only decompress Huffman compressed data ("..tostring(info_byte)..")"
	end

	local num_symbols = string_byte(string_sub(compressed, 2, 2)) + 1
	local c0 = string_byte(string_sub(compressed, 3, 3))
	local c1 = string_byte(string_sub(compressed, 4, 4))
	local c2 = string_byte(string_sub(compressed, 5, 5))
	local orig_size = c2 * 65536 + c1 * 256 + c0
	if orig_size == 0 then
		return ""
	end

	-- decode code -> symbol map
	local bitfield = 0
	local bitfield_high = 0
	local bitfield_len = 0
	local map = {} -- only table not reused in Huffman decode.
	setmetatable(map, {
		__index = function (t, k)
			local v = {}
			rawset(t, k, v)
			return v
		end
	})

	local i = 6 -- byte 1-5 are header bytes
	local c, cl
	local minCodeLen = 1000
	local maxCodeLen = 0
	local symbol, code_high, code, code_len, temp_high, temp, _bitfield_high, _bitfield, _bitfield_len
	local n = 0
	local state = 0 -- 0 = get symbol (8 bits),  1 = get code (varying bits, ends with 2 bits set)
	while n < num_symbols do
		if i > compressed_size then
			return nil, "Cannot decode map"
		end

		c = string_byte(compressed, i)
		temp_high, temp = lshift64(0, c, bitfield_len)
		bitfield_high, bitfield = bor64(bitfield_high, bitfield, temp_high, temp)
		bitfield_len = bitfield_len + 8

		if state == 0 then
			symbol = bit_band(bitfield, 255)
			bitfield_high, bitfield = rshift64(bitfield_high, bitfield, 8)
			bitfield_len = bitfield_len - 8
			state = 1 -- search for code now
		else
			code_high, code, code_len, _bitfield_high, _bitfield, _bitfield_len = getCode2(bitfield_high, bitfield, bitfield_len)
			if code_high then
				bitfield_high, bitfield, bitfield_len = _bitfield_high, _bitfield, _bitfield_len
				if code_len > 32 then
					return nil, "Unsupported symbol code length ("..code_len..")"
				end
				c, cl = unescape_code(code, code_len)
				map[cl][c] = string_char(symbol)
				minCodeLen = cl < minCodeLen and cl or minCodeLen
				maxCodeLen = cl > maxCodeLen and cl or maxCodeLen
				--print("symbol: "..string_char(symbol).."  code: "..tobinary(c, cl))
				n = n + 1
				state = 0 -- search for next symbol (if any)
			end
		end
		i = i + 1
	end

	-- don't create new subtables for entries not in the map. Waste of space.
	-- But do return an empty table to prevent runtime errors. (instead of returning nil)
	local mt = {}
	setmetatable(map, {
		__index = function (t, k)
			return mt
		end
	})

	local uncompressed = tables.Huffman_uncompressed
	local large_uncompressed = tables.Huffman_large_uncompressed
	local uncompressed_size = 0
	local large_uncompressed_size = 0
	local test_code
	local test_code_len = minCodeLen
	local dec_size = 0
	compressed_size = compressed_size + 1
	local temp_limit = 200 -- first limit of uncompressed data. large_uncompressed will hold strings of length 200
	temp_limit = temp_limit > orig_size and orig_size or temp_limit

	while true do
		if test_code_len <= bitfield_len then
			test_code = bit_band( bitfield, lshiftMinusOneMask[test_code_len])
			symbol = map[test_code_len][test_code]

			if symbol then
				uncompressed_size = uncompressed_size + 1
				uncompressed[uncompressed_size] = symbol
				dec_size = dec_size + 1
				if dec_size >= temp_limit then
					if dec_size >= orig_size then -- checked here for speed reasons
						break
					end
					-- process compressed bytes in smaller chunks
					large_uncompressed_size = large_uncompressed_size + 1
					large_uncompressed[large_uncompressed_size] = table_concat(uncompressed, "", 1, uncompressed_size)
					uncompressed_size = 0
					temp_limit = temp_limit + 200 -- repeated chunk size is 200 uncompressed bytes
					temp_limit = temp_limit > orig_size and orig_size or temp_limit
				end

				bitfield = bit_rshift(bitfield, test_code_len)
				bitfield_len = bitfield_len - test_code_len
				test_code_len = minCodeLen
			else
				test_code_len = test_code_len + 1
				if test_code_len > maxCodeLen then
					return nil, "Decompression error at "..tostring(i).."/"..tostring(#compressed)
				end
			end
		else
			c = string_byte(compressed, i)
			bitfield = bitfield + bit_lshift(c or 0, bitfield_len)
			bitfield_len = bitfield_len + 8
			if i > compressed_size then
				break
			end
			i = i + 1
		end
	end

	setCleanupTables("Huffman_uncompressed", "Huffman_large_uncompressed")
	return table_concat(large_uncompressed, "", 1, large_uncompressed_size)..table_concat(uncompressed, "", 1, uncompressed_size)
end

--------------------------------------------------------------------------------
-- Generic codec interface

function LibCompress:Store(uncompressed)
	if type(uncompressed) ~= "string" then
		return nil, "Can only compress strings"
	end
	return "\001"..uncompressed
end

function LibCompress:DecompressUncompressed(data)
	if type(data) ~= "string" then
		return nil, "Can only handle strings"
	end
	if string_byte(data) ~= 1 then
		return nil, "Can only handle uncompressed data"
	end
	return data:sub(2)
end

local compression_methods = {
	[2] = LibCompress.CompressLZW,
	[3] = LibCompress.CompressHuffman
}

local decompression_methods = {
	[1] = LibCompress.DecompressUncompressed,
	[2] = LibCompress.DecompressLZW,
	[3] = LibCompress.DecompressHuffman
}

-- try all compression codecs and return best result
function LibCompress:Compress(data)
	local method = next(compression_methods)
	local result = compression_methods[method](self, data)
	local n
	method = next(compression_methods, method)
	while method do
		n = compression_methods[method](self, data)
		if #n < #result then
			result = n
		end
		method = next(compression_methods, method)
	end
	return result
end

function LibCompress:Decompress(data)
	local header_info = string_byte(data)
	if decompression_methods[header_info] then
		return decompression_methods[header_info](self, data)
	else
		return nil, "Unknown compression method ("..tostring(header_info)..")"
	end
end

----------------------------------------------------------------------
----------------------------------------------------------------------
--
-- Encoding algorithms

--------------------------------------------------------------------------------
-- Prefix encoding algorithm
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com

--[[
	Howto: Encode and Decode:

	3 functions are supplied, 2 of them are variants of the first.  They return a table with functions to encode and decode text.

	table, msg = LibCompress:GetEncodeTable(reservedChars, escapeChars,  mapChars)

		reservedChars: The characters in this string will not appear in the encoded data.
		escapeChars: A string of characters used as escape-characters (don't supply more than needed). #escapeChars >= 1
		mapChars: First characters in reservedChars maps to first characters in mapChars.  (#mapChars <= #reservedChars)

	return value:
		table
			if nil then msg holds an error message, otherwise use like this:

			encoded_message = table:Encode(message)
			message = table:Decode(encoded_message)

	GetAddonEncodeTable: Sets up encoding for the addon channel (\000 is encoded)
	GetChatEncodeTable: Sets up encoding for the chat channel (many bytes encoded, see the function for details)

	Except for the mapped characters, all encoding will be with 1 escape character followed by 1 suffix, i.e. 2 bytes.
]]
-- to be able to match any requested byte value, the search string must be preprocessed
-- characters to escape with %:
-- ( ) . % + - * ? [ ] ^ $
-- "illegal" byte values:
-- 0 is replaces %z
local gsub_escape_table = {
	['\000'] = "%z",
	[('(')] = "%(",
	[(')')] = "%)",
	[('.')] = "%.",
	[('%')] = "%%",
	[('+')] = "%+",
	[('-')] = "%-",
	[('*')] = "%*",
	[('?')] = "%?",
	[('[')] = "%[",
	[(']')] = "%]",
	[('^')] = "%^",
	[('$')] = "%$"
}

local function escape_for_gsub(str)
	return str:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])",  gsub_escape_table)
end

function LibCompress:GetEncodeTable(reservedChars, escapeChars, mapChars)
	reservedChars = reservedChars or ""
	escapeChars = escapeChars or ""
	mapChars = mapChars or ""

	-- select a default escape character
	if escapeChars == "" then
		return nil, "No escape characters supplied"
	end

	if #reservedChars < #mapChars then
		return nil, "Number of reserved characters must be at least as many as the number of mapped chars"
	end

	if reservedChars == "" then
		return nil, "No characters to encode"
	end

	-- list of characters that must be encoded
	local encodeBytes = reservedChars..escapeChars..mapChars

	-- build list of bytes not available as a suffix to a prefix byte
	local taken = {}
	for i = 1, string_len(encodeBytes) do
		taken[string_sub(encodeBytes, i, i)] = true
	end

	-- allocate a table to hold encode/decode strings/functions
	local codecTable = {}

	-- the encoding can be a single gsub, but the decoding can require multiple gsubs
	local decode_func_string = {}

	local encode_search = {}
	local encode_translate = {}
	local encode_func
	local decode_search = {}
	local decode_translate = {}
	local decode_func
	local c, r, to, from
	local escapeCharIndex, escapeChar = 0

	-- map single byte to single byte
	if #mapChars > 0 then
		for i = 1, #mapChars do
			from = string_sub(reservedChars, i, i)
			to = string_sub(mapChars, i, i)
			encode_translate[from] = to
			table_insert(encode_search, from)
			decode_translate[to] = from
			table_insert(decode_search, to)
		end
		codecTable["decode_search"..tostring(escapeCharIndex)] = "([".. escape_for_gsub(table_concat(decode_search)).."])"
		codecTable["decode_translate"..tostring(escapeCharIndex)] = decode_translate
		table_insert(decode_func_string, "str = str:gsub(self.decode_search"..tostring(escapeCharIndex)..", self.decode_translate"..tostring(escapeCharIndex)..");")

	end

	-- map single byte to double-byte
	escapeCharIndex = escapeCharIndex + 1
	escapeChar = string_sub(escapeChars, escapeCharIndex, escapeCharIndex)
	r = 0 -- suffix char value to the escapeChar
	decode_search = {}
	decode_translate = {}
	for i = 1, string_len(encodeBytes) do
		c = string_sub(encodeBytes, i, i)
		if not encode_translate[c] then
			-- this loop will update escapeChar and r
			while r >= 256 or taken[string_char(r)] do
				r = r + 1
				if r > 255 then -- switch to next escapeChar
					codecTable["decode_search"..tostring(escapeCharIndex)] = escape_for_gsub(escapeChar).."([".. escape_for_gsub(table_concat(decode_search)).."])"
					codecTable["decode_translate"..tostring(escapeCharIndex)] = decode_translate
					table_insert(decode_func_string, "str = str:gsub(self.decode_search"..tostring(escapeCharIndex)..", self.decode_translate"..tostring(escapeCharIndex)..");")

					escapeCharIndex  = escapeCharIndex + 1
					escapeChar = string_sub(escapeChars, escapeCharIndex, escapeCharIndex)

					if escapeChar == "" then -- we are out of escape chars and we need more!
						return nil, "Out of escape characters"
					end

					r = 0
					decode_search = {}
					decode_translate = {}
				end
			end
			encode_translate[c] = escapeChar..string_char(r)
			table_insert(encode_search, c)
			decode_translate[string_char(r)] = c
			table_insert(decode_search, string_char(r))
			r = r + 1
		end
	end

	if r > 0 then
		codecTable["decode_search"..tostring(escapeCharIndex)] = escape_for_gsub(escapeChar).."([".. escape_for_gsub(table_concat(decode_search)).."])"
		codecTable["decode_translate"..tostring(escapeCharIndex)] = decode_translate
		table_insert(decode_func_string, "str = str:gsub(self.decode_search"..tostring(escapeCharIndex)..", self.decode_translate"..tostring(escapeCharIndex)..");")
	end

	-- change last line from "str = ...;" to "return ...;";
	decode_func_string[#decode_func_string] = decode_func_string[#decode_func_string]:gsub("str = (.*);", "return %1;")
	decode_func_string = "return function(self, str) "..table_concat(decode_func_string).." end"

	encode_search = "([".. escape_for_gsub(table_concat(encode_search)).."])"
	decode_search = escape_for_gsub(escapeChars).."([".. escape_for_gsub(table_concat(decode_search)).."])"

	encode_func = assert(loadstring("return function(self, str) return str:gsub(self.encode_search, self.encode_translate); end"))()
	decode_func = assert(loadstring(decode_func_string))()
	codecTable.encode_search = encode_search
	codecTable.encode_translate = encode_translate
	codecTable.Encode = encode_func
	codecTable.decode_search = decode_search
	codecTable.decode_translate = decode_translate
	codecTable.Decode = decode_func

	codecTable.decode_func_string = decode_func_string -- to be deleted
	return codecTable
end

-- Addons: Call this only once and reuse the returned table for all encodings/decodings.
function LibCompress:GetAddonEncodeTable(reservedChars, escapeChars, mapChars )
	reservedChars = reservedChars or ""
	escapeChars = escapeChars or ""
	mapChars = mapChars or ""
	-- Following byte values are not allowed:
	-- \000
	if escapeChars == "" then
		escapeChars = "\001"
	end
	return self:GetEncodeTable( (reservedChars or "").."\000", escapeChars, mapChars)
end

-- Addons: Call this only once and reuse the returned table for all encodings/decodings.
function LibCompress:GetChatEncodeTable(reservedChars, escapeChars, mapChars)
	reservedChars = reservedChars or ""
	escapeChars = escapeChars or ""
	mapChars = mapChars or ""
	-- Following byte values are not allowed:
	-- \000, s, S, \010, \013, \124, %
	-- Because SendChatMessage will error if an UTF8 multibyte character is incomplete,
	-- all character values above 127 have to be encoded to avoid this. This costs quite a bit of bandwidth (about 13-14%)
	-- Also, because drunken status is unknown for the received, strings used with SendChatMessage should be terminated with
	-- an identifying byte value, after which the server MAY add "...hic!" or as much as it can fit(!).
	-- Pass the identifying byte as a reserved character to this function to ensure the encoding doesn't contain that value.
	--  or use this: local message, match = arg1:gsub("^(.*)\029.-$", "%1")
	--  arg1 is message from channel, \029 is the string terminator, but may be used in the encoded datastream as well. :-)
	-- This encoding will expand data anywhere from:
	-- 0% (average with pure ascii text)
	-- 53.5% (average with random data valued zero to 255)
	-- 100% (only encoding data that encodes to two bytes)
	local r = {}

	for i = 128, 255 do
		table_insert(r, string_char(i))
	end

	reservedChars = "sS\000\010\013\124%"..table_concat(r)..(reservedChars or "")
	if escapeChars == "" then
		escapeChars = "\029\031"
	end

	if mapChars == "" then
		mapChars = "\015\020";
	end
	return self:GetEncodeTable(reservedChars, escapeChars, mapChars)
end

--------------------------------------------------------------------------------
-- 7 bit encoding algorithm
-- implemented by Galmok of European Stormrage (Horde), galmok@gmail.com

-- The encoded data holds values from 0 to 127 inclusive. Additional encoding may be necessary.
-- This algorithm isn't exactly fast and be used with care and consideration

tables.encode7bit = {}

function LibCompress:Encode7bit(str)
	local remainder = 0
	local remainder_length = 0
	local tbl = tables.encode7bit
	local encoded_size = 0
	local length = #str
	for i = 1, length do
		local code = string_byte(str, i)
		remainder = remainder + bit_lshift(code, remainder_length)
		remainder_length = 8 + remainder_length
		while remainder_length >= 7 do
			encoded_size = encoded_size + 1
			tbl[encoded_size] = string_char(bit_band(remainder, 127))
			remainder = bit_rshift(remainder, 7)
			remainder_length = remainder_length -7
		end
	end

	if remainder_length > 0 then
		encoded_size = encoded_size + 1
		tbl[encoded_size] = string_char(remainder)
	end
	setCleanupTables("encode7bit")
	return table_concat(tbl, "", 1, encoded_size)
end

tables.decode8bit = {}

function LibCompress:Decode7bit(str)
	local bit8 = tables.decode8bit
	local decoded_size = 0
	local ch
	local i = 1
	local bitfield_len = 0
	local bitfield = 0
	local length = #str
	while true do
		if bitfield_len >= 8 then
			decoded_size = decoded_size + 1
			bit8[decoded_size] = string_char(bit_band(bitfield, 255))
			bitfield = bit_rshift(bitfield, 8)
			bitfield_len = bitfield_len - 8
		end
		ch = string_byte(str, i)
		bitfield=bitfield + bit_lshift(ch or 0, bitfield_len)
		bitfield_len = bitfield_len + 7
		if i > length then
			break
		end
		i = i + 1
	end
	setCleanupTables("decode8bit")
	return table_concat(bit8, "", 1, decoded_size)
end

----------------------------------------------------------------------
----------------------------------------------------------------------
--
-- Checksum/hash algorithms

--------------------------------------------------------------------------------
-- FCS16/32 checksum algorithms
-- converted from C by Galmok of European Stormrage (Horde), galmok@gmail.com
-- usage:
-- 	code = LibCompress:fcs16init()
--	code = LibCompress:fcs16update(code, data1)
--	code = LibCompress:fcs16update(code, data2)
--	code = LibCompress:fcs16update(code, data...)
--	code = LibCompress:fcs16final(code)
--
--	data = string
--	fcs16 provides a 16 bit checksum, fcs32 provides a 32 bit checksum.


--[[/* The following copyright notice concerns only the FCS hash algorithm
---------------------------------------------------------------------------
Copyright (c) 2003, Dominik Reichl <dominik.reichl@t-online.de>, Germany.
All rights reserved.

Distributed under the terms of the GNU General Public License v2.

This software is provided 'as is' with no explicit or implied warranties
in respect of its properties, including, but not limited to, correctness
and/or fitness for purpose.
---------------------------------------------------------------------------
*/]]
--// FCS-16 algorithm implemented as described in RFC 1331
local FCSINIT16 = 65535
--// Fast 16 bit FCS lookup table
local fcs16tab = { [0]=0, 4489, 8978, 12955, 17956, 22445, 25910, 29887,
	35912, 40385, 44890, 48851, 51820, 56293, 59774, 63735,
	4225, 264, 13203, 8730, 22181, 18220, 30135, 25662,
	40137, 36160, 49115, 44626, 56045, 52068, 63999, 59510,
	8450, 12427, 528, 5017, 26406, 30383, 17460, 21949,
	44362, 48323, 36440, 40913, 60270, 64231, 51324, 55797,
	12675, 8202, 4753, 792, 30631, 26158, 21685, 17724,
	48587, 44098, 40665, 36688, 64495, 60006, 55549, 51572,
	16900, 21389, 24854, 28831, 1056, 5545, 10034, 14011,
	52812, 57285, 60766, 64727, 34920, 39393, 43898, 47859,
	21125, 17164, 29079, 24606, 5281, 1320, 14259, 9786,
	57037, 53060, 64991, 60502, 39145, 35168, 48123, 43634,
	25350, 29327, 16404, 20893, 9506, 13483, 1584, 6073,
	61262, 65223, 52316, 56789, 43370, 47331, 35448, 39921,
	29575, 25102, 20629, 16668, 13731, 9258, 5809, 1848,
	65487, 60998, 56541, 52564, 47595, 43106, 39673, 35696,
	33800, 38273, 42778, 46739, 49708, 54181, 57662, 61623,
	2112, 6601, 11090, 15067, 20068, 24557, 28022, 31999,
	38025, 34048, 47003, 42514, 53933, 49956, 61887, 57398,
	6337, 2376, 15315, 10842, 24293, 20332, 32247, 27774,
	42250, 46211, 34328, 38801, 58158, 62119, 49212, 53685,
	10562, 14539, 2640, 7129, 28518, 32495, 19572, 24061,
	46475, 41986, 38553, 34576, 62383, 57894, 53437, 49460,
	14787, 10314, 6865, 2904, 32743, 28270, 23797, 19836,
	50700, 55173, 58654, 62615, 32808, 37281, 41786, 45747,
	19012, 23501, 26966, 30943, 3168, 7657, 12146, 16123,
	54925, 50948, 62879, 58390, 37033, 33056, 46011, 41522,
	23237, 19276, 31191, 26718, 7393, 3432, 16371, 11898,
	59150, 63111, 50204, 54677, 41258, 45219, 33336, 37809,
	27462, 31439, 18516, 23005, 11618, 15595, 3696, 8185,
	63375, 58886, 54429, 50452, 45483, 40994, 37561, 33584,
	31687, 27214, 22741, 18780, 15843, 11370, 7921, 3960 }

function LibCompress:fcs16init()
	return FCSINIT16
end

function LibCompress:fcs16update(uFcs16, pBuffer)
	local length = string_len(pBuffer)
	for i = 1, length do
		uFcs16 = bit_bxor(bit_rshift(uFcs16,8), fcs16tab[bit_band(bit_bxor(uFcs16, string_byte(pBuffer, i)), 255)])
	end
	return uFcs16
end

function LibCompress:fcs16final(uFcs16)
	return bit_bxor(uFcs16,65535)
end
-- END OF FCS16

--[[/*
---------------------------------------------------------------------------
Copyright (c) 2003, Dominik Reichl <dominik.reichl@t-online.de>, Germany.
All rights reserved.

Distributed under the terms of the GNU General Public License v2.

This software is provided 'as is' with no explicit or implied warranties
in respect of its properties, including, but not limited to, correctness
and/or fitness for purpose.
---------------------------------------------------------------------------
*/]]

--// FCS-32 algorithm implemented as described in RFC 1331

local FCSINIT32 = -1

--// Fast 32 bit FCS lookup table
local fcs32tab = { [0] = 0, 1996959894, -301047508, -1727442502, 124634137, 1886057615, -379345611, -1637575261,
	249268274, 2044508324, -522852066, -1747789432, 162941995, 2125561021, -407360249, -1866523247,
	498536548, 1789927666, -205950648, -2067906082, 450548861, 1843258603, -187386543, -2083289657,
	325883990, 1684777152, -43845254, -1973040660, 335633487, 1661365465, -99664541, -1928851979,
	997073096, 1281953886, -715111964, -1570279054, 1006888145, 1258607687, -770865667, -1526024853,
	901097722, 1119000684, -608450090, -1396901568, 853044451, 1172266101, -589951537, -1412350631,
	651767980, 1373503546, -925412992, -1076862698, 565507253, 1454621731, -809855591, -1195530993,
	671266974, 1594198024, -972236366, -1324619484, 795835527, 1483230225, -1050600021, -1234817731,
	1994146192, 31158534, -1731059524, -271249366, 1907459465, 112637215, -1614814043, -390540237,
	2013776290, 251722036, -1777751922, -519137256, 2137656763, 141376813, -1855689577, -429695999,
	1802195444, 476864866, -2056965928, -228458418, 1812370925, 453092731, -2113342271, -183516073,
	1706088902, 314042704, -1950435094, -54949764, 1658658271, 366619977, -1932296973, -69972891,
	1303535960, 984961486, -1547960204, -725929758, 1256170817, 1037604311, -1529756563, -740887301,
	1131014506, 879679996, -1385723834, -631195440, 1141124467, 855842277, -1442165665, -586318647,
	1342533948, 654459306, -1106571248, -921952122, 1466479909, 544179635, -1184443383, -832445281,
	1591671054, 702138776, -1328506846, -942167884, 1504918807, 783551873, -1212326853, -1061524307,
	-306674912, -1698712650, 62317068, 1957810842, -355121351, -1647151185, 81470997, 1943803523,
	-480048366, -1805370492, 225274430, 2053790376, -468791541, -1828061283, 167816743, 2097651377,
	-267414716, -2029476910, 503444072, 1762050814, -144550051, -2140837941, 426522225, 1852507879,
	-19653770, -1982649376, 282753626, 1742555852, -105259153, -1900089351, 397917763, 1622183637,
	-690576408, -1580100738, 953729732, 1340076626, -776247311, -1497606297, 1068828381, 1219638859,
	-670225446, -1358292148, 906185462, 1090812512, -547295293, -1469587627, 829329135, 1181335161,
	-882789492, -1134132454, 628085408, 1382605366, -871598187, -1156888829, 570562233, 1426400815,
	-977650754, -1296233688, 733239954, 1555261956, -1026031705, -1244606671, 752459403, 1541320221,
	-1687895376, -328994266, 1969922972, 40735498, -1677130071, -351390145, 1913087877, 83908371,
	-1782625662, -491226604, 2075208622, 213261112, -1831694693, -438977011, 2094854071, 198958881,
	-2032938284, -237706686, 1759359992, 534414190, -2118248755, -155638181, 1873836001, 414664567,
	-2012718362, -15766928, 1711684554, 285281116, -1889165569, -127750551, 1634467795, 376229701,
	-1609899400, -686959890, 1308918612, 956543938, -1486412191, -799009033, 1231636301, 1047427035,
	-1362007478, -640263460, 1088359270, 936918000, -1447252397, -558129467, 1202900863, 817233897,
	-1111625188, -893730166, 1404277552, 615818150, -1160759803, -841546093, 1423857449, 601450431,
	-1285129682, -1000256840, 1567103746, 711928724, -1274298825, -1022587231, 1510334235, 755167117 }

function LibCompress:fcs32init()
	return FCSINIT32
end

function LibCompress:fcs32update(uFcs32, pBuffer)
	local length = string_len(pBuffer)
	for i = 1, length do
		uFcs32 = bit_bxor(bit_rshift(uFcs32, 8), fcs32tab[bit_band(bit_bxor(uFcs32, string_byte(pBuffer, i)), 255)])
	end
	return uFcs32
end

function LibCompress:fcs32final(uFcs32)
	return bit_bnot(uFcs32)
end

-- ========================================
-- File: WeakAuras/Libs/LibCustomGlow-1.0/LibCustomGlow-1.0.lua
-- ========================================

--[[
This library contains work of Hendrick "nevcairiel" Leppkes
https://www.wowace.com/projects/libbuttonglow-1-0
]]

-- luacheck: globals CreateFromMixins ObjectPoolMixin CreateTexturePool CreateFramePool

local MAJOR_VERSION = "LibCustomGlow-1.0"
local MINOR_VERSION = 21
if not LibStub then error(MAJOR_VERSION .. " requires LibStub.") end
local lib, oldversion = LibStub:NewLibrary(MAJOR_VERSION, MINOR_VERSION)
if not lib then return end
local Masque = LibStub("Masque", true)

local isRetail = WOW_PROJECT_ID == WOW_PROJECT_MAINLINE
local textureList = {
    empty = [[Interface\AdventureMap\BrokenIsles\AM_29]],
    white = [[Interface\BUTTONS\WHITE8X8]],
    shine = [[Interface\ItemSocketingFrame\UI-ItemSockets]]
}

local shineCoords = {0.3984375, 0.4453125, 0.40234375, 0.44921875}
if isRetail then
    textureList.shine = [[Interface\Artifacts\Artifacts]]
    shineCoords = {0.8115234375,0.9169921875,0.8798828125,0.9853515625}
end

function lib.RegisterTextures(texture,id)
    textureList[id] = texture
end

lib.glowList = {}
lib.startList = {}
lib.stopList = {}

local GlowParent = UIParent
local GlowMaskPool = {
    createFunc = function(self)
        return self.parent:CreateMaskTexture()
    end,
    resetFunc = function(self, mask)
        mask:Hide()
        mask:ClearAllPoints()
    end,
    AddObject = function(self, object)
        local dummy = true
        self.activeObjects[object] = dummy
        self.activeObjectCount = self.activeObjectCount + 1
    end,
    ReclaimObject = function(self, object)
        tinsert(self.inactiveObjects, object)
        self.activeObjects[object] = nil
        self.activeObjectCount = self.activeObjectCount - 1
    end,
    Release = function(self, object)
        local active = self.activeObjects[object] ~= nil
        if active then
            self:resetFunc(object)
            self:ReclaimObject(object)
        end
        return active
    end,
    Acquire = function(self)
        local object = tremove(self.inactiveObjects)
        local new = object == nil
        if new then
            object = self:createFunc()
            self:resetFunc(object, new)
        end
        self:AddObject(object)
        return object, new
    end,
    Init = function(self, parent)
        self.activeObjects = {}
        self.inactiveObjects = {}
        self.activeObjectCount = 0
        self.parent = parent
    end
}
GlowMaskPool:Init(GlowParent)

local TexPoolResetter = function(pool,tex)
    local maskNum = tex:GetNumMaskTextures()
    for i = maskNum , 1, -1 do
        tex:RemoveMaskTexture(tex:GetMaskTexture(i))
    end
    tex:Hide()
    tex:ClearAllPoints()
end
local GlowTexPool = CreateTexturePool(GlowParent ,"ARTWORK",7,nil,TexPoolResetter)
lib.GlowTexPool = GlowTexPool

local FramePoolResetter = function(framePool,frame)
    frame:SetScript("OnUpdate",nil)
    local parent = frame:GetParent()
    if parent[frame.name] then
        parent[frame.name] = nil
    end
    if frame.textures then
        for _, texture in pairs(frame.textures) do
            GlowTexPool:Release(texture)
        end
    end
    if frame.bg then
        GlowTexPool:Release(frame.bg)
        frame.bg = nil
    end
    if frame.masks then
        for _,mask in pairs(frame.masks) do
            GlowMaskPool:Release(mask)
        end
        frame.masks = nil
    end
    frame.textures = {}
    frame.info = {}
    frame.name = nil
    frame.timer = nil
    frame:Hide()
    frame:ClearAllPoints()
end
local GlowFramePool = CreateFramePool("Frame",GlowParent,nil,FramePoolResetter)
lib.GlowFramePool = GlowFramePool

local function addFrameAndTex(r,color,name,key,N,xOffset,yOffset,texture,texCoord,desaturated,frameLevel)
    key = key or ""
	frameLevel = frameLevel or 8
    if not r[name..key] then
        r[name..key] = GlowFramePool:Acquire()
        r[name..key]:SetParent(r)
        r[name..key].name = name..key
    end
    local f = r[name..key]
	f:SetFrameLevel(r:GetFrameLevel()+frameLevel)
    f:SetPoint("TOPLEFT",r,"TOPLEFT",-xOffset+0.05,yOffset+0.05)
    f:SetPoint("BOTTOMRIGHT",r,"BOTTOMRIGHT",xOffset,-yOffset+0.05)
    f:Show()

    if not f.textures then
        f.textures = {}
    end

    for i=1,N do
        if not f.textures[i] then
            f.textures[i] = GlowTexPool:Acquire()
            f.textures[i]:SetTexture(texture)
            f.textures[i]:SetTexCoord(texCoord[1],texCoord[2],texCoord[3],texCoord[4])
            f.textures[i]:SetDesaturated(desaturated)
            f.textures[i]:SetParent(f)
            f.textures[i]:SetDrawLayer("ARTWORK",7)
            if not isRetail and name == "_AutoCastGlow" then
                f.textures[i]:SetBlendMode("ADD")
            end
        end
        f.textures[i]:SetVertexColor(color[1],color[2],color[3],color[4])
        f.textures[i]:Show()
    end
    while #f.textures>N do
        GlowTexPool:Release(f.textures[#f.textures])
        table.remove(f.textures)
    end
end


--Pixel Glow Functions--
local pCalc1 = function(progress,s,th,p)
    local c
    if progress>p[3] or progress<p[0] then
        c = 0
    elseif progress>p[2] then
        c =s-th-(progress-p[2])/(p[3]-p[2])*(s-th)
    elseif progress>p[1] then
        c =s-th
    else
        c = (progress-p[0])/(p[1]-p[0])*(s-th)
    end
    return math.floor(c+0.5)
end

local pCalc2 = function(progress,s,th,p)
    local c
    if progress>p[3] then
        c = s-th-(progress-p[3])/(p[0]+1-p[3])*(s-th)
    elseif progress>p[2] then
        c = s-th
    elseif progress>p[1] then
        c = (progress-p[1])/(p[2]-p[1])*(s-th)
    elseif progress>p[0] then
        c = 0
    else
        c = s-th-(progress+1-p[3])/(p[0]+1-p[3])*(s-th)
    end
    return math.floor(c+0.5)
end

local  pUpdate = function(self,elapsed)
    self.timer = self.timer+elapsed/self.info.period
    if self.timer>1 or self.timer <-1 then
        self.timer = self.timer%1
    end
    local progress = self.timer
    local width,height = self:GetSize()
    if width ~= self.info.width or height ~= self.info.height then
        local perimeter = 2*(width+height)
        if not (perimeter>0) then
            return
        end
        self.info.width = width
        self.info.height = height
        self.info.pTLx = {
            [0] = (height+self.info.length/2)/perimeter,
            [1] = (height+width+self.info.length/2)/perimeter,
            [2] = (2*height+width-self.info.length/2)/perimeter,
            [3] = 1-self.info.length/2/perimeter
        }
        self.info.pTLy ={
            [0] = (height-self.info.length/2)/perimeter,
            [1] = (height+width+self.info.length/2)/perimeter,
            [2] = (height*2+width+self.info.length/2)/perimeter,
            [3] = 1-self.info.length/2/perimeter
        }
        self.info.pBRx ={
            [0] = self.info.length/2/perimeter,
            [1] = (height-self.info.length/2)/perimeter,
            [2] = (height+width-self.info.length/2)/perimeter,
            [3] = (height*2+width+self.info.length/2)/perimeter
        }
        self.info.pBRy ={
            [0] = self.info.length/2/perimeter,
            [1] = (height+self.info.length/2)/perimeter,
            [2] = (height+width-self.info.length/2)/perimeter,
            [3] = (height*2+width-self.info.length/2)/perimeter
        }
    end
    if self:IsShown() then
        if not (self.masks[1]:IsShown()) then
            self.masks[1]:Show()
            self.masks[1]:SetPoint("TOPLEFT",self,"TOPLEFT",self.info.th,-self.info.th)
            self.masks[1]:SetPoint("BOTTOMRIGHT",self,"BOTTOMRIGHT",-self.info.th,self.info.th)
        end
        if self.masks[2] and not(self.masks[2]:IsShown()) then
            self.masks[2]:Show()
            self.masks[2]:SetPoint("TOPLEFT",self,"TOPLEFT",self.info.th+1,-self.info.th-1)
            self.masks[2]:SetPoint("BOTTOMRIGHT",self,"BOTTOMRIGHT",-self.info.th-1,self.info.th+1)
        end
        if self.bg and not(self.bg:IsShown()) then
            self.bg:Show()
        end
        for k,line  in pairs(self.textures) do
            line:SetPoint("TOPLEFT",self,"TOPLEFT",pCalc1((progress+self.info.step*(k-1))%1,width,self.info.th,self.info.pTLx),-pCalc2((progress+self.info.step*(k-1))%1,height,self.info.th,self.info.pTLy))
            line:SetPoint("BOTTOMRIGHT",self,"TOPLEFT",self.info.th+pCalc2((progress+self.info.step*(k-1))%1,width,self.info.th,self.info.pBRx),-height+pCalc1((progress+self.info.step*(k-1))%1,height,self.info.th,self.info.pBRy))
        end
    end
end

function lib.PixelGlow_Start(r,color,N,frequency,length,th,xOffset,yOffset,border,key,frameLevel)
    if not r then
        return
    end
    if not color then
        color = {0.95,0.95,0.32,1}
    end

    if not(N and N>0) then
        N = 8
    end

    local period
    if frequency then
        if not(frequency>0 or frequency<0) then
            period = 4
        else
            period = 1/frequency
        end
    else
        period = 4
    end
    local width,height = r:GetSize()
    length = length or math.floor((width+height)*(2/N-0.1))
    length = min(length,min(width,height))
    th = th or 1
    xOffset = xOffset or 0
    yOffset = yOffset or 0
    key = key or ""

    addFrameAndTex(r,color,"_PixelGlow",key,N,xOffset,yOffset,textureList.white,{0,1,0,1},nil,frameLevel)
    local f = r["_PixelGlow"..key]
    if not f.masks then
        f.masks = {}
    end
    if not f.masks[1] then
        f.masks[1] = GlowMaskPool:Acquire()
        f.masks[1]:SetTexture(textureList.empty, "CLAMPTOWHITE","CLAMPTOWHITE")
        f.masks[1]:Show()
    end
    f.masks[1]:SetPoint("TOPLEFT",f,"TOPLEFT",th,-th)
    f.masks[1]:SetPoint("BOTTOMRIGHT",f,"BOTTOMRIGHT",-th,th)

    if not(border==false) then
        if not f.masks[2] then
            f.masks[2] = GlowMaskPool:Acquire()
            f.masks[2]:SetTexture(textureList.empty, "CLAMPTOWHITE","CLAMPTOWHITE")
        end
        f.masks[2]:SetPoint("TOPLEFT",f,"TOPLEFT",th+1,-th-1)
        f.masks[2]:SetPoint("BOTTOMRIGHT",f,"BOTTOMRIGHT",-th-1,th+1)

        if not f.bg then
            f.bg = GlowTexPool:Acquire()
            f.bg:SetColorTexture(0.1,0.1,0.1,0.8)
            f.bg:SetParent(f)
            f.bg:SetAllPoints(f)
            f.bg:SetDrawLayer("ARTWORK",6)
            f.bg:AddMaskTexture(f.masks[2])
        end
    else
        if f.bg then
            GlowTexPool:Release(f.bg)
            f.bg = nil
        end
        if f.masks[2] then
            GlowMaskPool:Release(f.masks[2])
            f.masks[2] = nil
        end
    end
    for _,tex in pairs(f.textures) do
        if tex:GetNumMaskTextures() < 1 then
            tex:AddMaskTexture(f.masks[1])
        end
    end
    f.timer = f.timer or 0
    f.info = f.info or {}
    f.info.step = 1/N
    f.info.period = period
    f.info.th = th
    if f.info.length ~= length then
        f.info.width = nil
        f.info.length = length
    end
    pUpdate(f, 0)
    f:SetScript("OnUpdate",pUpdate)
end

function lib.PixelGlow_Stop(r,key)
    if not r then
        return
    end
    key = key or ""
    if not r["_PixelGlow"..key] then
        return false
    else
        GlowFramePool:Release(r["_PixelGlow"..key])
    end
end

table.insert(lib.glowList, "Pixel Glow")
lib.startList["Pixel Glow"] = lib.PixelGlow_Start
lib.stopList["Pixel Glow"] = lib.PixelGlow_Stop


--Autocast Glow Functions--
local function acUpdate(self,elapsed)
    local width,height = self:GetSize()
    if width ~= self.info.width or height ~= self.info.height then
        if width*height == 0 then return end -- Avoid division by zero
        self.info.width = width
        self.info.height = height
        self.info.perimeter = 2*(width+height)
        self.info.bottomlim = height*2+width
        self.info.rightlim = height+width
        self.info.space = self.info.perimeter/self.info.N
    end

    local texIndex = 0;
    for k=1,4 do
        self.timer[k] = self.timer[k]+elapsed/(self.info.period*k)
        if self.timer[k] > 1 or self.timer[k] <-1 then
            self.timer[k] = self.timer[k]%1
        end
        for i = 1,self.info.N do
            texIndex = texIndex+1
            local position = (self.info.space*i+self.info.perimeter*self.timer[k])%self.info.perimeter
            if position>self.info.bottomlim then
                self.textures[texIndex]: SetPoint("CENTER",self,"BOTTOMRIGHT",-position+self.info.bottomlim,0)
            elseif position>self.info.rightlim then
                self.textures[texIndex]: SetPoint("CENTER",self,"TOPRIGHT",0,-position+self.info.rightlim)
            elseif position>self.info.height then
                self.textures[texIndex]: SetPoint("CENTER",self,"TOPLEFT",position-self.info.height,0)
            else
                self.textures[texIndex]: SetPoint("CENTER",self,"BOTTOMLEFT",0,position)
            end
        end
    end
end

function lib.AutoCastGlow_Start(r,color,N,frequency,scale,xOffset,yOffset,key,frameLevel)
    if not r then
        return
    end

    if not color then
        color = {0.95,0.95,0.32,1}
    end

    if not(N and N>0) then
        N = 4
    end

    local period
    if frequency then
        if not(frequency>0 or frequency<0) then
            period = 8
        else
            period = 1/frequency
        end
    else
        period = 8
    end
    scale = scale or 1
    xOffset = xOffset or 0
    yOffset = yOffset or 0
    key = key or ""

    addFrameAndTex(r,color,"_AutoCastGlow",key,N*4,xOffset,yOffset,textureList.shine,shineCoords, true, frameLevel)
    local f = r["_AutoCastGlow"..key]
    local sizes = {7,6,5,4}
    for k,size in pairs(sizes) do
        for i = 1,N do
            f.textures[i+N*(k-1)]:SetSize(size*scale,size*scale)
        end
    end
    f.timer = f.timer or {0,0,0,0}
    f.info = f.info or {}
    f.info.N = N
    f.info.period = period
    f:SetScript("OnUpdate",acUpdate)
    acUpdate(f, 0)
end

function lib.AutoCastGlow_Stop(r,key)
    if not r then
        return
    end

    key = key or ""
    if not r["_AutoCastGlow"..key] then
        return false
    else
        GlowFramePool:Release(r["_AutoCastGlow"..key])
    end
end

table.insert(lib.glowList, "Autocast Shine")
lib.startList["Autocast Shine"] = lib.AutoCastGlow_Start
lib.stopList["Autocast Shine"] = lib.AutoCastGlow_Stop

--Action Button Glow--
local function ButtonGlowResetter(framePool,frame)
    frame:SetScript("OnUpdate",nil)
    local parent = frame:GetParent()
    if parent._ButtonGlow then
        parent._ButtonGlow = nil
    end
    frame:Hide()
    frame:ClearAllPoints()
end
local ButtonGlowPool = CreateFramePool("Frame",GlowParent,nil,ButtonGlowResetter)
lib.ButtonGlowPool = ButtonGlowPool

local function CreateScaleAnim(group, target, order, duration, x, y, delay)
    local scale = group:CreateAnimation("Scale")
    scale:SetChildKey(target)
    scale:SetOrder(order)
    scale:SetDuration(duration)
    scale:SetScale(x, y)

    if delay then
        scale:SetStartDelay(delay)
    end
end

local function CreateAlphaAnim(group, target, order, duration, fromAlpha, toAlpha, delay, appear)
    local alpha = group:CreateAnimation("Alpha")
    alpha:SetChildKey(target)
    alpha:SetOrder(order)
    alpha:SetDuration(duration)
    alpha:SetFromAlpha(fromAlpha)
    alpha:SetToAlpha(toAlpha)
    if delay then
        alpha:SetStartDelay(delay)
    end
    if appear then
        table.insert(group.appear, alpha)
    else
        table.insert(group.fade, alpha)
    end
end

local function AnimIn_OnPlay(group)
    local frame = group:GetParent()
    local frameWidth, frameHeight = frame:GetSize()
    frame.spark:SetSize(frameWidth, frameHeight)
    frame.spark:SetAlpha(not(frame.color) and 1.0 or 0.3*frame.color[4])
    frame.innerGlow:SetSize(frameWidth / 2, frameHeight / 2)
    frame.innerGlow:SetAlpha(not(frame.color) and 1.0 or frame.color[4])
    frame.innerGlowOver:SetAlpha(not(frame.color) and 1.0 or frame.color[4])
    frame.outerGlow:SetSize(frameWidth * 2, frameHeight * 2)
    frame.outerGlow:SetAlpha(not(frame.color) and 1.0 or frame.color[4])
    frame.outerGlowOver:SetAlpha(not(frame.color) and 1.0 or frame.color[4])
    frame.ants:SetSize(frameWidth * 0.85, frameHeight * 0.85)
    frame.ants:SetAlpha(0)
    frame:Show()
end

local function AnimIn_OnFinished(group)
    local frame = group:GetParent()
    local frameWidth, frameHeight = frame:GetSize()
    frame.spark:SetAlpha(0)
    frame.innerGlow:SetAlpha(0)
    frame.innerGlow:SetSize(frameWidth, frameHeight)
    frame.innerGlowOver:SetAlpha(0.0)
    frame.outerGlow:SetSize(frameWidth, frameHeight)
    frame.outerGlowOver:SetAlpha(0.0)
    frame.outerGlowOver:SetSize(frameWidth, frameHeight)
    frame.ants:SetAlpha(not(frame.color) and 1.0 or frame.color[4])
end

local function AnimIn_OnStop(group)
    local frame = group:GetParent()
    local frameWidth, frameHeight = frame:GetSize()
    frame.spark:SetAlpha(0)
    frame.innerGlow:SetAlpha(0)
    frame.innerGlowOver:SetAlpha(0.0)
    frame.outerGlowOver:SetAlpha(0.0)
end

local function bgHide(self)
    if self.animOut:IsPlaying() then
        self.animOut:Stop()
        ButtonGlowPool:Release(self)
    end
end

local function bgUpdate(self, elapsed)
    AnimateTexCoords(self.ants, 256, 256, 48, 48, 22, elapsed, self.throttle);
    local cooldown = self:GetParent().cooldown;
    if(cooldown and cooldown:IsShown() and cooldown:GetCooldownDuration() > 3000) then
        self:SetAlpha(0.5);
    else
        self:SetAlpha(1.0);
    end
end

local function configureButtonGlow(f,alpha)
    f.spark = f:CreateTexture(nil, "BACKGROUND")
    f.spark:SetPoint("CENTER")
    f.spark:SetAlpha(0)
    f.spark:SetTexture([[Interface\SpellActivationOverlay\IconAlert]])
    f.spark:SetTexCoord(0.00781250, 0.61718750, 0.00390625, 0.26953125)

    -- inner glow
    f.innerGlow = f:CreateTexture(nil, "ARTWORK")
    f.innerGlow:SetPoint("CENTER")
    f.innerGlow:SetAlpha(0)
    f.innerGlow:SetTexture([[Interface\SpellActivationOverlay\IconAlert]])
    f.innerGlow:SetTexCoord(0.00781250, 0.50781250, 0.27734375, 0.52734375)

    -- inner glow over
    f.innerGlowOver = f:CreateTexture(nil, "ARTWORK")
    f.innerGlowOver:SetPoint("TOPLEFT", f.innerGlow, "TOPLEFT")
    f.innerGlowOver:SetPoint("BOTTOMRIGHT", f.innerGlow, "BOTTOMRIGHT")
    f.innerGlowOver:SetAlpha(0)
    f.innerGlowOver:SetTexture([[Interface\SpellActivationOverlay\IconAlert]])
    f.innerGlowOver:SetTexCoord(0.00781250, 0.50781250, 0.53515625, 0.78515625)

    -- outer glow
    f.outerGlow = f:CreateTexture(nil, "ARTWORK")
    f.outerGlow:SetPoint("CENTER")
    f.outerGlow:SetAlpha(0)
    f.outerGlow:SetTexture([[Interface\SpellActivationOverlay\IconAlert]])
    f.outerGlow:SetTexCoord(0.00781250, 0.50781250, 0.27734375, 0.52734375)

    -- outer glow over
    f.outerGlowOver = f:CreateTexture(nil, "ARTWORK")
    f.outerGlowOver:SetPoint("TOPLEFT", f.outerGlow, "TOPLEFT")
    f.outerGlowOver:SetPoint("BOTTOMRIGHT", f.outerGlow, "BOTTOMRIGHT")
    f.outerGlowOver:SetAlpha(0)
    f.outerGlowOver:SetTexture([[Interface\SpellActivationOverlay\IconAlert]])
    f.outerGlowOver:SetTexCoord(0.00781250, 0.50781250, 0.53515625, 0.78515625)

    -- ants
    f.ants = f:CreateTexture(nil, "OVERLAY")
    f.ants:SetPoint("CENTER")
    f.ants:SetAlpha(0)
    f.ants:SetTexture([[Interface\SpellActivationOverlay\IconAlertAnts]])

    f.animIn = f:CreateAnimationGroup()
    f.animIn.appear = {}
    f.animIn.fade = {}
    CreateScaleAnim(f.animIn, "spark",          1, 0.2, 1.5, 1.5)
    CreateAlphaAnim(f.animIn, "spark",          1, 0.2, 0, alpha, nil, true)
    CreateScaleAnim(f.animIn, "innerGlow",      1, 0.3, 2, 2)
    CreateScaleAnim(f.animIn, "innerGlowOver",  1, 0.3, 2, 2)
    CreateAlphaAnim(f.animIn, "innerGlowOver",  1, 0.3, alpha, 0, nil, false)
    CreateScaleAnim(f.animIn, "outerGlow",      1, 0.3, 0.5, 0.5)
    CreateScaleAnim(f.animIn, "outerGlowOver",  1, 0.3, 0.5, 0.5)
    CreateAlphaAnim(f.animIn, "outerGlowOver",  1, 0.3, alpha, 0, nil, false)
    CreateScaleAnim(f.animIn, "spark",          1, 0.2, 2/3, 2/3, 0.2)
    CreateAlphaAnim(f.animIn, "spark",          1, 0.2, alpha, 0, 0.2, false)
    CreateAlphaAnim(f.animIn, "innerGlow",      1, 0.2, alpha, 0, 0.3, false)
    CreateAlphaAnim(f.animIn, "ants",           1, 0.2, 0, alpha, 0.3, true)
    f.animIn:SetScript("OnPlay", AnimIn_OnPlay)
    f.animIn:SetScript("OnStop", AnimIn_OnStop)
    f.animIn:SetScript("OnFinished", AnimIn_OnFinished)

    f.animOut = f:CreateAnimationGroup()
    f.animOut.appear = {}
    f.animOut.fade = {}
    CreateAlphaAnim(f.animOut, "outerGlowOver", 1, 0.2, 0, alpha, nil, true)
    CreateAlphaAnim(f.animOut, "ants",          1, 0.2, alpha, 0, nil, false)
    CreateAlphaAnim(f.animOut, "outerGlowOver", 2, 0.2, alpha, 0, nil, false)
    CreateAlphaAnim(f.animOut, "outerGlow",     2, 0.2, alpha, 0, nil, false)
    f.animOut:SetScript("OnFinished", function(self) ButtonGlowPool:Release(self:GetParent())  end)

    f:SetScript("OnHide", bgHide)
end

local function updateAlphaAnim(f,alpha)
    for _,anim in pairs(f.animIn.appear) do
        anim:SetToAlpha(alpha)
    end
    for _,anim in pairs(f.animIn.fade) do
        anim:SetFromAlpha(alpha)
    end
    for _,anim in pairs(f.animOut.appear) do
        anim:SetToAlpha(alpha)
    end
    for _,anim in pairs(f.animOut.fade) do
        anim:SetFromAlpha(alpha)
    end
end

local ButtonGlowTextures = {["spark"] = true,["innerGlow"] = true,["innerGlowOver"] = true,["outerGlow"] = true,["outerGlowOver"] = true,["ants"] = true}

local function noZero(num)
    if num == 0 then
        return 0.001
    else
        return num
    end
end

function lib.ButtonGlow_Start(r,color,frequency,frameLevel)
    if not r then
        return
    end
	frameLevel = frameLevel or 8;
    local throttle
    if frequency and frequency > 0 then
        throttle = 0.25/frequency*0.01
    else
        throttle = 0.01
    end
    if r._ButtonGlow then
        local f = r._ButtonGlow
        local width,height = r:GetSize()
        f:SetFrameLevel(r:GetFrameLevel()+frameLevel)
        f:SetSize(width*1.4 , height*1.4)
        f:SetPoint("TOPLEFT", r, "TOPLEFT", -width * 0.2, height * 0.2)
        f:SetPoint("BOTTOMRIGHT", r, "BOTTOMRIGHT", width * 0.2, -height * 0.2)
        f.ants:SetSize(width*1.4*0.85, height*1.4*0.85)
		AnimIn_OnFinished(f.animIn)
		if f.animOut:IsPlaying() then
            f.animOut:Stop()
            f.animIn:Play()
        end

        if not(color) then
            for texture in pairs(ButtonGlowTextures) do
                f[texture]:SetDesaturated(nil)
                f[texture]:SetVertexColor(1,1,1)
                local alpha = math.min(f[texture]:GetAlpha()/noZero(f.color and f.color[4] or 1), 1)
                f[texture]:SetAlpha(alpha)
                updateAlphaAnim(f, 1)
            end
            f.color = false
        else
            for texture in pairs(ButtonGlowTextures) do
                f[texture]:SetDesaturated(1)
                f[texture]:SetVertexColor(color[1],color[2],color[3])
                local alpha = math.min(f[texture]:GetAlpha()/noZero(f.color and f.color[4] or 1)*color[4], 1)
                f[texture]:SetAlpha(alpha)
                updateAlphaAnim(f,color and color[4] or 1)
            end
            f.color = color
        end
        f.throttle = throttle
    else
        local f, new = ButtonGlowPool:Acquire()
        if new then
            configureButtonGlow(f,color and color[4] or 1)
        else
            updateAlphaAnim(f,color and color[4] or 1)
        end
        r._ButtonGlow = f
        local width,height = r:GetSize()
        f:SetParent(r)
        f:SetFrameLevel(r:GetFrameLevel()+frameLevel)
        f:SetSize(width * 1.4, height * 1.4)
        f:SetPoint("TOPLEFT", r, "TOPLEFT", -width * 0.2, height * 0.2)
        f:SetPoint("BOTTOMRIGHT", r, "BOTTOMRIGHT", width * 0.2, -height * 0.2)
        if not(color) then
            f.color = false
            for texture in pairs(ButtonGlowTextures) do
                f[texture]:SetDesaturated(nil)
                f[texture]:SetVertexColor(1,1,1)
            end
        else
            f.color = color
            for texture in pairs(ButtonGlowTextures) do
                f[texture]:SetDesaturated(1)
                f[texture]:SetVertexColor(color[1],color[2],color[3])
            end
        end
        f.throttle = throttle
        f:SetScript("OnUpdate", bgUpdate)

        f.animIn:Play()

        if Masque and Masque.UpdateSpellAlert and (not r.overlay or not issecurevariable(r, "overlay")) then
            local old_overlay = r.overlay
            r.overlay = f
            Masque:UpdateSpellAlert(r)
            r.overlay = old_overlay
        end
    end
end

function lib.ButtonGlow_Stop(r)
    if r._ButtonGlow then
        if r._ButtonGlow.animOut:IsPlaying() then
            -- Do nothing the animOut finishing will release
        elseif r._ButtonGlow.animIn:IsPlaying() then
            r._ButtonGlow.animIn:Stop()
            ButtonGlowPool:Release(r._ButtonGlow)
        elseif r:IsVisible() then
            r._ButtonGlow.animOut:Play()
        else
            ButtonGlowPool:Release(r._ButtonGlow)
        end
    end
end

table.insert(lib.glowList, "Action Button Glow")
lib.startList["Action Button Glow"] = lib.ButtonGlow_Start
lib.stopList["Action Button Glow"] = lib.ButtonGlow_Stop


-- ProcGlow

local function ProcGlowResetter(framePool, frame)
    frame:Hide()
    frame:ClearAllPoints()
    frame:SetScript("OnShow", nil)
    frame:SetScript("OnHide", nil)
    local parent = frame:GetParent()
    if frame.key and parent[frame.key] then
        parent[frame.key] = nil
    end
end

local ProcGlowPool = CreateFramePool("Frame", GlowParent, nil, ProcGlowResetter)
lib.ProcGlowPool = ProcGlowPool

local function InitProcGlow(f)
    f.ProcStart = f:CreateTexture(nil, "ARTWORK")
    f.ProcStart:SetBlendMode("ADD")
    f.ProcStart:SetAtlas("UI-HUD-ActionBar-Proc-Start-Flipbook")
    f.ProcStart:SetAlpha(1)
    f.ProcStart:SetSize(150, 150)
    f.ProcStart:SetPoint("CENTER")

    f.ProcLoop = f:CreateTexture(nil, "ARTWORK")
    f.ProcLoop:SetAtlas("UI-HUD-ActionBar-Proc-Loop-Flipbook")
    f.ProcLoop:SetAlpha(0)
    f.ProcLoop:SetAllPoints()

    f.ProcLoopAnim = f:CreateAnimationGroup()
    f.ProcLoopAnim:SetLooping("REPEAT")
    f.ProcLoopAnim:SetToFinalAlpha(true)

    local alphaRepeat = f.ProcLoopAnim:CreateAnimation("Alpha")
    alphaRepeat:SetChildKey("ProcLoop")
    alphaRepeat:SetFromAlpha(1)
    alphaRepeat:SetToAlpha(1)
    alphaRepeat:SetDuration(.001)
    alphaRepeat:SetOrder(0)
    f.ProcLoopAnim.alphaRepeat = alphaRepeat

    local flipbookRepeat = f.ProcLoopAnim:CreateAnimation("FlipBook")
    flipbookRepeat:SetChildKey("ProcLoop")
    flipbookRepeat:SetDuration(1)
    flipbookRepeat:SetOrder(0)
    flipbookRepeat:SetFlipBookRows(6)
    flipbookRepeat:SetFlipBookColumns(5)
    flipbookRepeat:SetFlipBookFrames(30)
    flipbookRepeat:SetFlipBookFrameWidth(0)
    flipbookRepeat:SetFlipBookFrameHeight(0)
    f.ProcLoopAnim.flipbookRepeat = flipbookRepeat

    f.ProcStartAnim = f:CreateAnimationGroup()
    f.ProcStartAnim:SetToFinalAlpha(true)

    local flipbookStartAlphaIn = f.ProcStartAnim:CreateAnimation("Alpha")
    flipbookStartAlphaIn:SetChildKey("ProcStart")
    flipbookStartAlphaIn:SetDuration(.001)
    flipbookStartAlphaIn:SetOrder(0)
    flipbookStartAlphaIn:SetFromAlpha(1)
    flipbookStartAlphaIn:SetToAlpha(1)

    local flipbookStart = f.ProcStartAnim:CreateAnimation("FlipBook")
    flipbookStart:SetChildKey("ProcStart")
    flipbookStart:SetDuration(0.7)
    flipbookStart:SetOrder(1)
    flipbookStart:SetFlipBookRows(6)
    flipbookStart:SetFlipBookColumns(5)
    flipbookStart:SetFlipBookFrames(30)
    flipbookStart:SetFlipBookFrameWidth(0)
    flipbookStart:SetFlipBookFrameHeight(0)

    local flipbookStartAlphaOut = f.ProcStartAnim:CreateAnimation("Alpha")
    flipbookStartAlphaOut:SetChildKey("ProcStart")
    flipbookStartAlphaOut:SetDuration(.001)
    flipbookStartAlphaOut:SetOrder(2)
    flipbookStartAlphaOut:SetFromAlpha(1)
    flipbookStartAlphaOut:SetToAlpha(0)

    f.ProcStartAnim.flipbookStart = flipbookStart
    f.ProcStartAnim:SetScript("OnFinished", function(self)
        self:GetParent().ProcLoopAnim:Play()
        self:GetParent().ProcLoop:Show()
    end)

end

local function SetupProcGlow(f, options)
    f.key = "_ProcGlow" .. options.key -- for resetter
    f:SetScript("OnHide", function(self)
        if self.ProcStartAnim:IsPlaying() then
            self.ProcStartAnim:Stop()
        end
        if self.ProcLoopAnim:IsPlaying() then
            self.ProcLoopAnim:Stop()
        end
    end)
    f:SetScript("OnShow", function(self)
        if self.startAnim then
            if not self.ProcStartAnim:IsPlaying() and not self.ProcLoopAnim:IsPlaying() then
                --[[
to future me:
i wish you'r ok, if you wonder where are this constants coming from, check:
https://github.com/Gethe/wow-ui-source/blob/eb4459c679a1bd8919cad92934ea83c4f5e77e8b/Interface/FrameXML/ActionButton.lua#L816
https://github.com/Gethe/wow-ui-source/blob/d8e8ebf572c3b28237cf83e8fc5c0583b5453a2b/Interface/FrameXML/ActionButtonTemplate.xml#L5-L14
                ]]
                local width, height = self:GetSize()
                self.ProcStart:SetSize((width / 42 * 150) / 1.4, (height / 42 * 150) / 1.4)
                self.ProcStart:Show()
                self.ProcLoop:Hide()
                self.ProcStartAnim:Play()
            end
        else
            if not self.ProcLoopAnim:IsPlaying() then
                self.ProcStart:Hide()
                self.ProcLoop:Show()
                self.ProcLoopAnim:Play()
            end
        end
    end)
    if not options.color then
        f.ProcStart:SetDesaturated(nil)
        f.ProcStart:SetVertexColor(1, 1, 1, 1)
        f.ProcLoop:SetDesaturated(nil)
        f.ProcLoop:SetVertexColor(1, 1, 1, 1)
    else
        f.ProcStart:SetDesaturated(1)
        f.ProcStart:SetVertexColor(options.color[1], options.color[2], options.color[3], options.color[4])
        f.ProcLoop:SetDesaturated(1)
        f.ProcLoop:SetVertexColor(options.color[1], options.color[2], options.color[3], options.color[4])
    end
    f.ProcLoopAnim.flipbookRepeat:SetDuration(options.duration)
    f.startAnim = options.startAnim
end

local ProcGlowDefaults = {
    frameLevel = 8,
    color = nil,
    startAnim = true,
    xOffset = 0,
    yOffset = 0,
    duration = 1,
    key = ""
}

function lib.ProcGlow_Start(r, options)
    if not r then
        return
    end
    options = options or {}
    setmetatable(options, { __index = ProcGlowDefaults })
    local key = "_ProcGlow" .. options.key
    local f, new
    if r[key] then
        f = r[key]
    else
        f, new = ProcGlowPool:Acquire()
        if new then
            InitProcGlow(f)
        end
        r[key] = f
    end
    f:SetParent(r)
    f:SetFrameLevel(r:GetFrameLevel() + options.frameLevel)

    local width, height = r:GetSize()
    local xOffset = options.xOffset + width * 0.2
    local yOffset = options.yOffset + height * 0.2
    f:SetPoint("TOPLEFT", r, "TOPLEFT", -xOffset, yOffset)
    f:SetPoint("BOTTOMRIGHT", r, "BOTTOMRIGHT", xOffset, -yOffset)

    SetupProcGlow(f, options)
    f:Show()
end

function lib.ProcGlow_Stop(r, key)
    key = key or ""
    local f = r["_ProcGlow" .. key]
    if f then
        ProcGlowPool:Release(f)
    end
end

table.insert(lib.glowList, "Proc Glow")
lib.startList["Proc Glow"] = lib.ProcGlow_Start
lib.stopList["Proc Glow"] = lib.ProcGlow_Stop


-- ========================================
-- File: WeakAuras/Libs/LibDBIcon-1.0/LibDBIcon-1.0.lua
-- ========================================

--@curseforge-project-slug: libdbicon-1-0@
-----------------------------------------------------------------------
-- LibDBIcon-1.0
--
-- Allows addons to easily create a lightweight minimap icon as an alternative to heavier LDB displays.
--

local DBICON10 = "LibDBIcon-1.0"
local DBICON10_MINOR = 55 -- Bump on changes
if not LibStub then error(DBICON10 .. " requires LibStub.") end
local ldb = LibStub("LibDataBroker-1.1", true)
if not ldb then error(DBICON10 .. " requires LibDataBroker-1.1.") end
local lib = LibStub:NewLibrary(DBICON10, DBICON10_MINOR)
if not lib then return end

lib.objects = lib.objects or {}
lib.callbackRegistered = lib.callbackRegistered or nil
lib.callbacks = lib.callbacks or LibStub("CallbackHandler-1.0"):New(lib)
lib.radius = lib.radius or 5
local next, Minimap, CreateFrame, AddonCompartmentFrame = next, Minimap, CreateFrame, AddonCompartmentFrame
lib.tooltip = lib.tooltip or CreateFrame("GameTooltip", "LibDBIconTooltip", UIParent, "GameTooltipTemplate")
local isDraggingButton = false

function lib:IconCallback(event, name, key, value)
	if lib.objects[name] then
		if key == "icon" then
			lib.objects[name].icon:SetTexture(value)
			if lib:IsButtonInCompartment(name) and lib:IsButtonCompartmentAvailable() then
				local addonList = AddonCompartmentFrame.registeredAddons
				for i =1, #addonList do
					if addonList[i].text == name then
						addonList[i].icon = value
						return
					end
				end
			end
		elseif key == "iconCoords" then
			lib.objects[name].icon:UpdateCoord()
		elseif key == "iconR" then
			local _, g, b = lib.objects[name].icon:GetVertexColor()
			lib.objects[name].icon:SetVertexColor(value, g, b)
		elseif key == "iconG" then
			local r, _, b = lib.objects[name].icon:GetVertexColor()
			lib.objects[name].icon:SetVertexColor(r, value, b)
		elseif key == "iconB" then
			local r, g = lib.objects[name].icon:GetVertexColor()
			lib.objects[name].icon:SetVertexColor(r, g, value)
		end
	end
end
if not lib.callbackRegistered then
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__icon", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconCoords", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconR", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconG", "IconCallback")
	ldb.RegisterCallback(lib, "LibDataBroker_AttributeChanged__iconB", "IconCallback")
	lib.callbackRegistered = true
end

local function getAnchors(frame)
	local x, y = frame:GetCenter()
	if not x or not y then return "CENTER" end
	local hhalf = (x > UIParent:GetWidth()*2/3) and "RIGHT" or (x < UIParent:GetWidth()/3) and "LEFT" or ""
	local vhalf = (y > UIParent:GetHeight()/2) and "TOP" or "BOTTOM"
	return vhalf..hhalf, frame, (vhalf == "TOP" and "BOTTOM" or "TOP")..hhalf
end

local function onEnter(self)
	if isDraggingButton then return end

	for _, button in next, lib.objects do
		if button.showOnMouseover then
			button.fadeOut:Stop()
			button:SetAlpha(1)
		end
	end

	local obj = self.dataObject
	if obj.OnTooltipShow then
		lib.tooltip:SetOwner(self, "ANCHOR_NONE")
		lib.tooltip:SetPoint(getAnchors(self))
		obj.OnTooltipShow(lib.tooltip)
		lib.tooltip:Show()
	elseif obj.OnEnter then
		obj.OnEnter(self)
	end
end

local function onLeave(self)
	lib.tooltip:Hide()

	if not isDraggingButton then
		for _, button in next, lib.objects do
			if button.showOnMouseover then
				button.fadeOut:Play()
			end
		end
	end

	local obj = self.dataObject
	if obj.OnLeave then
		obj.OnLeave(self)
	end
end

local function onEnterCompartment(self, menu)
	local buttonName = menu.text
	local object = lib.objects[buttonName]
	if object and object.dataObject then
		if object.dataObject.OnTooltipShow then
			lib.tooltip:SetOwner(self, "ANCHOR_NONE")
			lib.tooltip:SetPoint(getAnchors(self))
			object.dataObject.OnTooltipShow(lib.tooltip)
			lib.tooltip:Show()
		elseif object.dataObject.OnEnter then
			object.dataObject.OnEnter(self)
		end
	end
end

local function onLeaveCompartment(self, menu)
	lib.tooltip:Hide()

	local buttonName = menu.text
	local object = lib.objects[buttonName]
	if object and object.dataObject then
		if object.dataObject.OnLeave then
			object.dataObject.OnLeave(self)
		end
	end
end

--------------------------------------------------------------------------------

local onDragStart, updatePosition

do
	local minimapShapes = {
		["ROUND"] = {true, true, true, true},
		["SQUARE"] = {false, false, false, false},
		["CORNER-TOPLEFT"] = {false, false, false, true},
		["CORNER-TOPRIGHT"] = {false, false, true, false},
		["CORNER-BOTTOMLEFT"] = {false, true, false, false},
		["CORNER-BOTTOMRIGHT"] = {true, false, false, false},
		["SIDE-LEFT"] = {false, true, false, true},
		["SIDE-RIGHT"] = {true, false, true, false},
		["SIDE-TOP"] = {false, false, true, true},
		["SIDE-BOTTOM"] = {true, true, false, false},
		["TRICORNER-TOPLEFT"] = {false, true, true, true},
		["TRICORNER-TOPRIGHT"] = {true, false, true, true},
		["TRICORNER-BOTTOMLEFT"] = {true, true, false, true},
		["TRICORNER-BOTTOMRIGHT"] = {true, true, true, false},
	}

	local rad, cos, sin, sqrt, max, min = math.rad, math.cos, math.sin, math.sqrt, math.max, math.min
	function updatePosition(button, position)
		local angle = rad(position or 225)
		local x, y, q = cos(angle), sin(angle), 1
		if x < 0 then q = q + 1 end
		if y > 0 then q = q + 2 end
		local minimapShape = GetMinimapShape and GetMinimapShape() or "ROUND"
		local quadTable = minimapShapes[minimapShape]
		local w = (Minimap:GetWidth() / 2) + lib.radius
		local h = (Minimap:GetHeight() / 2) + lib.radius
		if quadTable[q] then
			x, y = x*w, y*h
		else
			local diagRadiusW = sqrt(2*(w)^2)-10
			local diagRadiusH = sqrt(2*(h)^2)-10
			x = max(-w, min(x*diagRadiusW, w))
			y = max(-h, min(y*diagRadiusH, h))
		end
		button:SetPoint("CENTER", Minimap, "CENTER", x, y)
	end
end

local function onClick(self, b)
	if self.dataObject.OnClick then
		self.dataObject.OnClick(self, b)
	end
end

local function onMouseDown(self)
	self.isMouseDown = true
	self.icon:UpdateCoord()
end

local function onMouseUp(self)
	self.isMouseDown = false
	self.icon:UpdateCoord()
end

do
	local deg, atan2 = math.deg, math.atan2
	local function onUpdate(self)
		local mx, my = Minimap:GetCenter()
		local px, py = GetCursorPosition()
		local scale = Minimap:GetEffectiveScale()
		px, py = px / scale, py / scale
		local pos = 225
		if self.db then
			pos = deg(atan2(py - my, px - mx)) % 360
			self.db.minimapPos = pos
		else
			pos = deg(atan2(py - my, px - mx)) % 360
			self.minimapPos = pos
		end
		updatePosition(self, pos)
	end

	function onDragStart(self)
		self:LockHighlight()
		self.isMouseDown = true
		self.icon:UpdateCoord()
		self:SetScript("OnUpdate", onUpdate)
		isDraggingButton = true
		lib.tooltip:Hide()
		for _, button in next, lib.objects do
			if button.showOnMouseover then
				button.fadeOut:Stop()
				button:SetAlpha(1)
			end
		end
	end
end

local function onDragStop(self)
	self:SetScript("OnUpdate", nil)
	self.isMouseDown = false
	self.icon:UpdateCoord()
	self:UnlockHighlight()
	isDraggingButton = false
	for _, button in next, lib.objects do
		if button.showOnMouseover then
			button.fadeOut:Play()
		end
	end
end

local defaultCoords = {0, 1, 0, 1}
local function updateCoord(self)
	local coords = self:GetParent().dataObject.iconCoords or defaultCoords
	local deltaX, deltaY = 0, 0
	if not self:GetParent().isMouseDown then
		deltaX = (coords[2] - coords[1]) * 0.05
		deltaY = (coords[4] - coords[3]) * 0.05
	end
	self:SetTexCoord(coords[1] + deltaX, coords[2] - deltaX, coords[3] + deltaY, coords[4] - deltaY)
end

local function createButton(name, object, db, customCompartmentIcon)
	local button = CreateFrame("Button", "LibDBIcon10_"..name, Minimap)
	button.dataObject = object
	button.db = db
	button:SetFrameStrata("MEDIUM")
	button:SetFixedFrameStrata(true)
	button:SetFrameLevel(8)
	button:SetFixedFrameLevel(true)
	button:SetSize(31, 31)
	button:RegisterForClicks("anyUp")
	button:RegisterForDrag("LeftButton")
	button:SetHighlightTexture(136477) --"Interface\\Minimap\\UI-Minimap-ZoomButton-Highlight"
	if WOW_PROJECT_ID == WOW_PROJECT_MAINLINE then
		local overlay = button:CreateTexture(nil, "OVERLAY")
		overlay:SetSize(50, 50)
		overlay:SetTexture(136430) --"Interface\\Minimap\\MiniMap-TrackingBorder"
		overlay:SetPoint("TOPLEFT", button, "TOPLEFT")
		local background = button:CreateTexture(nil, "BACKGROUND")
		background:SetSize(24, 24)
		background:SetTexture(136467) --"Interface\\Minimap\\UI-Minimap-Background"
		background:SetPoint("CENTER", button, "CENTER")
		local icon = button:CreateTexture(nil, "ARTWORK")
		icon:SetSize(18, 18)
		icon:SetTexture(object.icon)
		icon:SetPoint("CENTER", button, "CENTER")
		button.icon = icon
	else
		local overlay = button:CreateTexture(nil, "OVERLAY")
		overlay:SetSize(53, 53)
		overlay:SetTexture(136430) --"Interface\\Minimap\\MiniMap-TrackingBorder"
		overlay:SetPoint("TOPLEFT")
		local background = button:CreateTexture(nil, "BACKGROUND")
		background:SetSize(20, 20)
		background:SetTexture(136467) --"Interface\\Minimap\\UI-Minimap-Background"
		background:SetPoint("TOPLEFT", 7, -5)
		local icon = button:CreateTexture(nil, "ARTWORK")
		icon:SetSize(17, 17)
		icon:SetTexture(object.icon)
		icon:SetPoint("TOPLEFT", 7, -6)
		button.icon = icon
	end

	button.isMouseDown = false
	local r, g, b = button.icon:GetVertexColor()
	button.icon:SetVertexColor(object.iconR or r, object.iconG or g, object.iconB or b)

	button.icon.UpdateCoord = updateCoord
	button.icon:UpdateCoord()

	button:SetScript("OnEnter", onEnter)
	button:SetScript("OnLeave", onLeave)
	button:SetScript("OnClick", onClick)
	if not db or not db.lock then
		button:SetScript("OnDragStart", onDragStart)
		button:SetScript("OnDragStop", onDragStop)
	end
	button:SetScript("OnMouseDown", onMouseDown)
	button:SetScript("OnMouseUp", onMouseUp)

	button.fadeOut = button:CreateAnimationGroup()
	local animOut = button.fadeOut:CreateAnimation("Alpha")
	animOut:SetOrder(1)
	animOut:SetDuration(0.2)
	animOut:SetFromAlpha(1)
	animOut:SetToAlpha(0)
	animOut:SetStartDelay(1)
	button.fadeOut:SetToFinalAlpha(true)

	lib.objects[name] = button

	if lib.loggedIn then
		updatePosition(button, db and db.minimapPos)
		if not db or not db.hide then
			button:Show()
		else
			button:Hide()
		end
	end

	if db and db.showInCompartment then
		lib:AddButtonToCompartment(name, customCompartmentIcon)
	end
	lib.callbacks:Fire("LibDBIcon_IconCreated", button, name) -- Fire 'Icon Created' callback
end

-- Wait a bit with the initial positioning to let any GetMinimapShape addons
-- load up.
if not lib.loggedIn then
	local frame = CreateFrame("Frame")
	frame:SetScript("OnEvent", function(self)
		for _, button in next, lib.objects do
			updatePosition(button, button.db and button.db.minimapPos)
			if not button.db or not button.db.hide then
				button:Show()
			else
				button:Hide()
			end
		end
		lib.loggedIn = true
		self:SetScript("OnEvent", nil)
	end)
	frame:RegisterEvent("PLAYER_LOGIN")
end

do
	local function OnMinimapEnter()
		if isDraggingButton then return end
		for _, button in next, lib.objects do
			if button.showOnMouseover then
				button.fadeOut:Stop()
				button:SetAlpha(1)
			end
		end
	end
	local function OnMinimapLeave()
		if isDraggingButton then return end
		for _, button in next, lib.objects do
			if button.showOnMouseover then
				button.fadeOut:Play()
			end
		end
	end
	Minimap:HookScript("OnEnter", OnMinimapEnter)
	Minimap:HookScript("OnLeave", OnMinimapLeave)
end

--------------------------------------------------------------------------------
-- Button API
--

function lib:Register(name, object, db, customCompartmentIcon)
	if not object.icon then error("Can't register LDB objects without icons set!") end
	if lib:GetMinimapButton(name) then error(DBICON10.. ": Object '".. name .."' is already registered.") end
	createButton(name, object, db, customCompartmentIcon)
end

function lib:Lock(name)
	local button = lib:GetMinimapButton(name)
	if button then
		button:SetScript("OnDragStart", nil)
		button:SetScript("OnDragStop", nil)
		if button.db then
			button.db.lock = true
		end
	end
end

function lib:Unlock(name)
	local button = lib:GetMinimapButton(name)
	if button then
		button:SetScript("OnDragStart", onDragStart)
		button:SetScript("OnDragStop", onDragStop)
		if button.db then
			button.db.lock = nil
		end
	end
end

function lib:Hide(name)
	local button = lib:GetMinimapButton(name)
	if button then
		button:Hide()
	end
end

function lib:Show(name)
	local button = lib:GetMinimapButton(name)
	if button then
		button:Show()
		updatePosition(button, button.db and button.db.minimapPos or button.minimapPos)
	end
end

function lib:IsRegistered(name)
	return lib.objects[name] and true or false
end

function lib:Refresh(name, db)
	local button = lib:GetMinimapButton(name)
	if button then
		if db then
			button.db = db
		end
		updatePosition(button, button.db and button.db.minimapPos or button.minimapPos)
		if not button.db or not button.db.hide then
			button:Show()
		else
			button:Hide()
		end
		if not button.db or not button.db.lock then
			button:SetScript("OnDragStart", onDragStart)
			button:SetScript("OnDragStop", onDragStop)
		else
			button:SetScript("OnDragStart", nil)
			button:SetScript("OnDragStop", nil)
		end
	end
end

function lib:ShowOnEnter(name, value)
	local button = lib:GetMinimapButton(name)
	if button then
		if value then
			button.showOnMouseover = true
			button.fadeOut:Stop()
			button:SetAlpha(0)
		else
			button.showOnMouseover = false
			button.fadeOut:Stop()
			button:SetAlpha(1)
		end
	end
end

function lib:GetMinimapButton(name)
	return lib.objects[name]
end

function lib:GetButtonList()
	local t = {}
	for name in next, lib.objects do
		t[#t+1] = name
	end
	return t
end

function lib:SetButtonRadius(radius)
	if type(radius) == "number" then
		lib.radius = radius
		for _, button in next, lib.objects do
			updatePosition(button, button.db and button.db.minimapPos or button.minimapPos)
		end
	end
end

function lib:SetButtonToPosition(button, position)
	updatePosition(lib.objects[button] or button, position)
end

--------------------------------------------------------------------------------
-- Addon Compartment API
--

function lib:IsButtonCompartmentAvailable()
	if AddonCompartmentFrame then
		return true
	end
end

function lib:IsButtonInCompartment(buttonName)
	local object = lib.objects[buttonName]
	if object and object.db and object.db.showInCompartment then
		return true
	end
	return false
end

function lib:AddButtonToCompartment(buttonName, customIcon)
	if lib:IsButtonCompartmentAvailable() then
		local object = lib.objects[buttonName]
		if object and not object.compartmentData then
			if object.db then
				object.db.showInCompartment = true
			end
			object.compartmentData = {
				text = buttonName,
				icon = customIcon or object.dataObject.icon,
				notCheckable = true,
				registerForAnyClick = true,
				func = function(_, menuInputData, menu)
					object.dataObject.OnClick(menu, menuInputData.buttonName)
				end,
				funcOnEnter = onEnterCompartment,
				funcOnLeave = onLeaveCompartment,
			}
			AddonCompartmentFrame:RegisterAddon(object.compartmentData)
		end
	end
end

function lib:RemoveButtonFromCompartment(buttonName)
	if lib:IsButtonCompartmentAvailable() then
		local object = lib.objects[buttonName]
		if object and object.compartmentData then
			for i = 1, #AddonCompartmentFrame.registeredAddons do
				local entry = AddonCompartmentFrame.registeredAddons[i]
				if entry == object.compartmentData then
					object.compartmentData = nil
					if object.db then
						object.db.showInCompartment = nil
					end
					table.remove(AddonCompartmentFrame.registeredAddons, i)
					AddonCompartmentFrame:UpdateDisplay()
					return
				end
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Upgrades
--

for name, button in next, lib.objects do
	local db = button.db
	if not db or not db.lock then
		button:SetScript("OnDragStart", onDragStart)
		button:SetScript("OnDragStop", onDragStop)
	end
	button:SetScript("OnEnter", onEnter)
	button:SetScript("OnLeave", onLeave)
	button:SetScript("OnClick", onClick)
	button:SetScript("OnMouseDown", onMouseDown)
	button:SetScript("OnMouseUp", onMouseUp)

	if not button.fadeOut then -- Upgrade to 39
		button.fadeOut = button:CreateAnimationGroup()
		local animOut = button.fadeOut:CreateAnimation("Alpha")
		animOut:SetOrder(1)
		animOut:SetDuration(0.2)
		animOut:SetFromAlpha(1)
		animOut:SetToAlpha(0)
		animOut:SetStartDelay(1)
		button.fadeOut:SetToFinalAlpha(true)
	end
end
lib:SetButtonRadius(lib.radius) -- Upgrade to 40
if lib.notCreated then -- Upgrade to 50
	for name in next, lib.notCreated do
		createButton(name, lib.notCreated[name][1], lib.notCreated[name][2])
	end
	lib.notCreated = nil
end


-- ========================================
-- File: WeakAuras/Libs/LibDataBroker-1.1/LibDataBroker-1.1.lua
-- ========================================


assert(LibStub, "LibDataBroker-1.1 requires LibStub")
assert(LibStub:GetLibrary("CallbackHandler-1.0", true), "LibDataBroker-1.1 requires CallbackHandler-1.0")

local lib, oldminor = LibStub:NewLibrary("LibDataBroker-1.1", 4)
if not lib then return end
oldminor = oldminor or 0


lib.callbacks = lib.callbacks or LibStub:GetLibrary("CallbackHandler-1.0"):New(lib)
lib.attributestorage, lib.namestorage, lib.proxystorage = lib.attributestorage or {}, lib.namestorage or {}, lib.proxystorage or {}
local attributestorage, namestorage, callbacks = lib.attributestorage, lib.namestorage, lib.callbacks

if oldminor < 2 then
	lib.domt = {
		__metatable = "access denied",
		__index = function(self, key) return attributestorage[self] and attributestorage[self][key] end,
	}
end

if oldminor < 3 then
	lib.domt.__newindex = function(self, key, value)
		if not attributestorage[self] then attributestorage[self] = {} end
		if attributestorage[self][key] == value then return end
		attributestorage[self][key] = value
		local name = namestorage[self]
		if not name then return end
		callbacks:Fire("LibDataBroker_AttributeChanged", name, key, value, self)
		callbacks:Fire("LibDataBroker_AttributeChanged_"..name, name, key, value, self)
		callbacks:Fire("LibDataBroker_AttributeChanged_"..name.."_"..key, name, key, value, self)
		callbacks:Fire("LibDataBroker_AttributeChanged__"..key, name, key, value, self)
	end
end

if oldminor < 2 then
	function lib:NewDataObject(name, dataobj)
		if self.proxystorage[name] then return end

		if dataobj then
			assert(type(dataobj) == "table", "Invalid dataobj, must be nil or a table")
			self.attributestorage[dataobj] = {}
			for i,v in pairs(dataobj) do
				self.attributestorage[dataobj][i] = v
				dataobj[i] = nil
			end
		end
		dataobj = setmetatable(dataobj or {}, self.domt)
		self.proxystorage[name], self.namestorage[dataobj] = dataobj, name
		self.callbacks:Fire("LibDataBroker_DataObjectCreated", name, dataobj)
		return dataobj
	end
end

if oldminor < 1 then
	function lib:DataObjectIterator()
		return pairs(self.proxystorage)
	end

	function lib:GetDataObjectByName(dataobjectname)
		return self.proxystorage[dataobjectname]
	end

	function lib:GetNameByDataObject(dataobject)
		return self.namestorage[dataobject]
	end
end

if oldminor < 4 then
	local next = pairs(attributestorage)
	function lib:pairs(dataobject_or_name)
		local t = type(dataobject_or_name)
		assert(t == "string" or t == "table", "Usage: ldb:pairs('dataobjectname') or ldb:pairs(dataobject)")

		local dataobj = self.proxystorage[dataobject_or_name] or dataobject_or_name
		assert(attributestorage[dataobj], "Data object not found")

		return next, attributestorage[dataobj], nil
	end

	local ipairs_iter = ipairs(attributestorage)
	function lib:ipairs(dataobject_or_name)
		local t = type(dataobject_or_name)
		assert(t == "string" or t == "table", "Usage: ldb:ipairs('dataobjectname') or ldb:ipairs(dataobject)")

		local dataobj = self.proxystorage[dataobject_or_name] or dataobject_or_name
		assert(attributestorage[dataobj], "Data object not found")

		return ipairs_iter, attributestorage[dataobj], 0
	end
end


-- ========================================
-- File: WeakAuras/Libs/LibDeflate/LibDeflate.lua
-- ========================================

--[[--
LibDeflate 1.0.2-release <br>
Pure Lua compressor and decompressor with high compression ratio using
DEFLATE/zlib format.

@file LibDeflate.lua
@author Haoqian He (Github: SafeteeWoW; World of Warcraft: Safetyy-Illidan(US))
@copyright LibDeflate <2018-2021> Haoqian He
@license zlib License

This library is implemented according to the following specifications. <br>
Report a bug if LibDeflate is not fully compliant with those specs. <br>
Both compressors and decompressors have been implemented in the library.<br>
1. RFC1950: DEFLATE Compressed Data Format Specification version 1.3 <br>
https://tools.ietf.org/html/rfc1951 <br>
2. RFC1951: ZLIB Compressed Data Format Specification version 3.3 <br>
https://tools.ietf.org/html/rfc1950 <br>

This library requires Lua 5.1/5.2/5.3/5.4 interpreter or LuaJIT v2.0+. <br>
This library does not have any dependencies. <br>
<br>
This file "LibDeflate.lua" is the only source file of
the library. <br>
Submit suggestions or report bugs to
https://github.com/safeteeWow/LibDeflate/issues
]] --[[
zlib License

(C) 2018-2021 Haoqian He

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.

License History:
1. GNU General Public License Version 3 in v1.0.0 and earlier versions.
2. GNU Lesser General Public License Version 3 in v1.0.1
3. the zlib License since v1.0.2

Credits and Disclaimer:
This library rewrites the code from the algorithm
and the ideas of the following projects,
and uses their code to help to test the correctness of this library,
but their code is not included directly in the library itself.
Their original licenses shall be comply when used.

1. zlib, by Jean-loup Gailly (compression) and Mark Adler (decompression).
	http://www.zlib.net/
	Licensed under zlib License. http://www.zlib.net/zlib_license.html
	For the compression algorithm.
2. puff, by Mark Adler. https://github.com/madler/zlib/tree/master/contrib/puff
	Licensed under zlib License. http://www.zlib.net/zlib_license.html
	For the decompression algorithm.
3. LibCompress, by jjsheets and Galmok of European Stormrage (Horde)
	https://www.wowace.com/projects/libcompress
	Licensed under GPLv2.
	https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
	For the code to create customized codec.
4. WeakAuras2,
	https://github.com/WeakAuras/WeakAuras2
	Licensed under GPLv2.
	For the 6bit encoding and decoding.
]] --[[
	Curseforge auto-packaging replacements:

	Project Date: 2021-05-05T13:18:27Z
	Project Hash: afc3b78d12fb3bcfa6b21e5332031ad3d7572e19
	Project Version: afc3b78
--]] local LibDeflate

do
  -- Semantic version. all lowercase.
  -- Suffix can be alpha1, alpha2, beta1, beta2, rc1, rc2, etc.
  -- NOTE: Two version numbers needs to modify.
  -- 1. On the top of LibDeflate.lua
  -- 2. _VERSION
  -- 3. _MINOR

  -- version to store the official version of LibDeflate
  local _VERSION = "1.0.2-release"

  -- When MAJOR is changed, I should name it as LibDeflate2
  local _MAJOR = "LibDeflate"

  -- Update this whenever a new version, for LibStub version registration.
  -- 0 : v0.x
  -- 1 : v1.0.0
  -- 2 : v1.0.1
  -- 3 : v1.0.2
  local _MINOR = 3

  local _COPYRIGHT = "LibDeflate " .. _VERSION ..
                       " Copyright (C) 2018-2021 Haoqian He." ..
                       " Licensed under the zlib License"

  -- Register in the World of Warcraft library "LibStub" if detected.
  if LibStub then
    local lib, minor = LibStub:GetLibrary(_MAJOR, true)
    if lib and minor and minor >= _MINOR then -- No need to update.
      return lib
    else -- Update or first time register
      LibDeflate = LibStub:NewLibrary(_MAJOR, _MINOR)
      -- NOTE: It is important that new version has implemented
      -- all exported APIs and tables in the old version,
      -- so the old library is fully garbage collected,
      -- and we 100% ensure the backward compatibility.
    end
  else -- "LibStub" is not detected.
    LibDeflate = {}
  end

  LibDeflate._VERSION = _VERSION
  LibDeflate._MAJOR = _MAJOR
  LibDeflate._MINOR = _MINOR
  LibDeflate._COPYRIGHT = _COPYRIGHT
end

-- localize Lua api for faster access.
local assert = assert
local error = error
local pairs = pairs
local string_byte = string.byte
local string_char = string.char
local string_find = string.find
local string_gsub = string.gsub
local string_sub = string.sub
local table_concat = table.concat
local table_sort = table.sort
local tostring = tostring
local type = type

-- Converts i to 2^i, (0<=i<=32)
-- This is used to implement bit left shift and bit right shift.
-- "x >> y" in C:   "(x-x%_pow2[y])/_pow2[y]" in Lua
-- "x << y" in C:   "x*_pow2[y]" in Lua
local _pow2 = {}

-- Converts any byte to a character, (0<=byte<=255)
local _byte_to_char = {}

-- _reverseBitsTbl[len][val] stores the bit reverse of
-- the number with bit length "len" and value "val"
-- For example, decimal number 6 with bits length 5 is binary 00110
-- It's reverse is binary 01100,
-- which is decimal 12 and 12 == _reverseBitsTbl[5][6]
-- 1<=len<=9, 0<=val<=2^len-1
-- The reason for 1<=len<=9 is that the max of min bitlen of huffman code
-- of a huffman alphabet is 9?
local _reverse_bits_tbl = {}

-- Convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code (257<=code<=285)
local _length_to_deflate_code = {}

-- convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code extra bits.
local _length_to_deflate_extra_bits = {}

-- Convert a LZ77 length (3<=len<=258) to
-- a deflate literal/LZ77_length code extra bit length.
local _length_to_deflate_extra_bitlen = {}

-- Convert a small LZ77 distance (1<=dist<=256) to a deflate code.
local _dist256_to_deflate_code = {}

-- Convert a small LZ77 distance (1<=dist<=256) to
-- a deflate distance code extra bits.
local _dist256_to_deflate_extra_bits = {}

-- Convert a small LZ77 distance (1<=dist<=256) to
-- a deflate distance code extra bit length.
local _dist256_to_deflate_extra_bitlen = {}

-- Convert a literal/LZ77_length deflate code to LZ77 base length
-- The key of the table is (code - 256), 257<=code<=285
local _literal_deflate_code_to_base_len =
  {
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67,
    83, 99, 115, 131, 163, 195, 227, 258
  }

-- Convert a literal/LZ77_length deflate code to base LZ77 length extra bits
-- The key of the table is (code - 256), 257<=code<=285
local _literal_deflate_code_to_extra_bitlen =
  {
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0
  }

-- Convert a distance deflate code to base LZ77 distance. (0<=code<=29)
local _dist_deflate_code_to_base_dist = {
  [0] = 1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
}

-- Convert a distance deflate code to LZ77 bits length. (0<=code<=29)
local _dist_deflate_code_to_extra_bitlen =
  {
    [0] = 0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
  }

-- The code order of the first huffman header in the dynamic deflate block.
-- See the page 12 of RFC1951
local _rle_codes_huffman_bitlen_order = {
  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
}

-- The following tables are used by fixed deflate block.
-- The value of these tables are assigned at the bottom of the source.

-- The huffman code of the literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_code

-- Convert huffman code of the literal/LZ77_length to deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_to_deflate_code

-- The bit length of the huffman code of literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_bitlen

-- The count of each bit length of the literal/LZ77_length deflate codes,
-- in fixed deflate block.
local _fix_block_literal_huffman_bitlen_count

-- The huffman code of the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_code

-- Convert huffman code of the distance to deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_to_deflate_code

-- The bit length of the huffman code of the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_bitlen

-- The count of each bit length of the huffman code of
-- the distance deflate codes,
-- in fixed deflate block.
local _fix_block_dist_huffman_bitlen_count

for i = 0, 255 do _byte_to_char[i] = string_char(i) end

do
  local pow = 1
  for i = 0, 32 do
    _pow2[i] = pow
    pow = pow * 2
  end
end

for i = 1, 9 do
  _reverse_bits_tbl[i] = {}
  for j = 0, _pow2[i + 1] - 1 do
    local reverse = 0
    local value = j
    for _ = 1, i do
      -- The following line is equivalent to "res | (code %2)" in C.
      reverse = reverse - reverse % 2 +
                  (((reverse % 2 == 1) or (value % 2) == 1) and 1 or 0)
      value = (value - value % 2) / 2
      reverse = reverse * 2
    end
    _reverse_bits_tbl[i][j] = (reverse - reverse % 2) / 2
  end
end

-- The source code is written according to the pattern in the numbers
-- in RFC1951 Page10.
do
  local a = 18
  local b = 16
  local c = 265
  local bitlen = 1
  for len = 3, 258 do
    if len <= 10 then
      _length_to_deflate_code[len] = len + 254
      _length_to_deflate_extra_bitlen[len] = 0
    elseif len == 258 then
      _length_to_deflate_code[len] = 285
      _length_to_deflate_extra_bitlen[len] = 0
    else
      if len > a then
        a = a + b
        b = b * 2
        c = c + 4
        bitlen = bitlen + 1
      end
      local t = len - a - 1 + b / 2
      _length_to_deflate_code[len] = (t - (t % (b / 8))) / (b / 8) + c
      _length_to_deflate_extra_bitlen[len] = bitlen
      _length_to_deflate_extra_bits[len] = t % (b / 8)
    end
  end
end

-- The source code is written according to the pattern in the numbers
-- in RFC1951 Page11.
do
  _dist256_to_deflate_code[1] = 0
  _dist256_to_deflate_code[2] = 1
  _dist256_to_deflate_extra_bitlen[1] = 0
  _dist256_to_deflate_extra_bitlen[2] = 0

  local a = 3
  local b = 4
  local code = 2
  local bitlen = 0
  for dist = 3, 256 do
    if dist > b then
      a = a * 2
      b = b * 2
      code = code + 2
      bitlen = bitlen + 1
    end
    _dist256_to_deflate_code[dist] = (dist <= a) and code or (code + 1)
    _dist256_to_deflate_extra_bitlen[dist] = (bitlen < 0) and 0 or bitlen
    if b >= 8 then
      _dist256_to_deflate_extra_bits[dist] = (dist - b / 2 - 1) % (b / 4)
    end
  end
end

--- Calculate the Adler-32 checksum of the string. <br>
-- See RFC1950 Page 9 https://tools.ietf.org/html/rfc1950 for the
-- definition of Adler-32 checksum.
-- @param str [string] the input string to calcuate its Adler-32 checksum.
-- @return [integer] The Adler-32 checksum, which is greater or equal to 0,
-- and less than 2^32 (4294967296).
function LibDeflate:Adler32(str)
  -- This function is loop unrolled by better performance.
  --
  -- Here is the minimum code:
  --
  -- local a = 1
  -- local b = 0
  -- for i=1, #str do
  -- 		local s = string.byte(str, i, i)
  -- 		a = (a+s)%65521
  -- 		b = (b+a)%65521
  -- 		end
  -- return b*65536+a
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:Adler32(str):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  local strlen = #str

  local i = 1
  local a = 1
  local b = 0
  while i <= strlen - 15 do
    local x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16 =
      string_byte(str, i, i + 15)
    b =
      (b + 16 * a + 16 * x1 + 15 * x2 + 14 * x3 + 13 * x4 + 12 * x5 + 11 * x6 +
        10 * x7 + 9 * x8 + 8 * x9 + 7 * x10 + 6 * x11 + 5 * x12 + 4 * x13 + 3 *
        x14 + 2 * x15 + x16) % 65521
    a =
      (a + x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9 + x10 + x11 + x12 + x13 +
        x14 + x15 + x16) % 65521
    i = i + 16
  end
  while (i <= strlen) do
    local x = string_byte(str, i, i)
    a = (a + x) % 65521
    b = (b + a) % 65521
    i = i + 1
  end
  return (b * 65536 + a) % 4294967296
end

-- Compare adler32 checksum.
-- adler32 should be compared with a mod to avoid sign problem
-- 4072834167 (unsigned) is the same adler32 as -222133129
local function IsEqualAdler32(actual, expected)
  return (actual % 4294967296) == (expected % 4294967296)
end

--- Create a preset dictionary.
--
-- This function is not fast, and the memory consumption of the produced
-- dictionary is about 50 times of the input string. Therefore, it is suggestted
-- to run this function only once in your program.
--
-- It is very important to know that if you do use a preset dictionary,
-- compressors and decompressors MUST USE THE SAME dictionary. That is,
-- dictionary must be created using the same string. If you update your program
-- with a new dictionary, people with the old version won't be able to transmit
-- data with people with the new version. Therefore, changing the dictionary
-- must be very careful.
--
-- The parameters "strlen" and "adler32" add a layer of verification to ensure
-- the parameter "str" is not modified unintentionally during the program
-- development.
--
-- @usage local dict_str = "1234567890"
--
-- -- print(dict_str:len(), LibDeflate:Adler32(dict_str))
-- -- Hardcode the print result below to verify it to avoid acciently
-- -- modification of 'str' during the program development.
-- -- string length: 10, Adler-32: 187433486,
-- -- Don't calculate string length and its Adler-32 at run-time.
--
-- local dict = LibDeflate:CreateDictionary(dict_str, 10, 187433486)
--
-- @param str [string] The string used as the preset dictionary. <br>
-- You should put stuffs that frequently appears in the dictionary
-- string and preferablely put more frequently appeared stuffs toward the end
-- of the string. <br>
-- Empty string and string longer than 32768 bytes are not allowed.
-- @param strlen [integer] The length of 'str'. Please pass in this parameter
-- as a hardcoded constant, in order to verify the content of 'str'. The value
-- of this parameter should be known before your program runs.
-- @param adler32 [integer] The Adler-32 checksum of 'str'. Please pass in this
-- parameter as a hardcoded constant, in order to verify the content of 'str'.
-- The value of this parameter should be known before your program runs.
-- @return  [table] The dictionary used for preset dictionary compression and
-- decompression.
-- @raise error if 'strlen' does not match the length of 'str',
-- or if 'adler32' does not match the Adler-32 checksum of 'str'.
function LibDeflate:CreateDictionary(str, strlen, adler32)
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  if type(strlen) ~= "number" then
    error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):" ..
            " 'strlen' - number expected got '%s'."):format(type(strlen)), 2)
  end
  if type(adler32) ~= "number" then
    error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):" ..
            " 'adler32' - number expected got '%s'."):format(type(adler32)), 2)
  end
  if strlen ~= #str then
    error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):" ..
            " 'strlen' does not match the actual length of 'str'." ..
            " 'strlen': %u, '#str': %u ." ..
            " Please check if 'str' is modified unintentionally."):format(
            strlen, #str))
  end
  if strlen == 0 then
    error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):" ..
            " 'str' - Empty string is not allowed."), 2)
  end
  if strlen > 32768 then
    error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):" ..
            " 'str' - string longer than 32768 bytes is not allowed." ..
            " Got %d bytes."):format(strlen), 2)
  end
  local actual_adler32 = self:Adler32(str)
  if not IsEqualAdler32(adler32, actual_adler32) then
    error(("Usage: LibDeflate:CreateDictionary(str, strlen, adler32):" ..
            " 'adler32' does not match the actual adler32 of 'str'." ..
            " 'adler32': %u, 'Adler32(str)': %u ." ..
            " Please check if 'str' is modified unintentionally."):format(
            adler32, actual_adler32))
  end

  local dictionary = {}
  dictionary.adler32 = adler32
  dictionary.hash_tables = {}
  dictionary.string_table = {}
  dictionary.strlen = strlen
  local string_table = dictionary.string_table
  local hash_tables = dictionary.hash_tables
  string_table[1] = string_byte(str, 1, 1)
  string_table[2] = string_byte(str, 2, 2)
  if strlen >= 3 then
    local i = 1
    local hash = string_table[1] * 256 + string_table[2]
    while i <= strlen - 2 - 3 do
      local x1, x2, x3, x4 = string_byte(str, i + 2, i + 5)
      string_table[i + 2] = x1
      string_table[i + 3] = x2
      string_table[i + 4] = x3
      string_table[i + 5] = x4
      hash = (hash * 256 + x1) % 16777216
      local t = hash_tables[hash]
      if not t then
        t = {};
        hash_tables[hash] = t
      end
      t[#t + 1] = i - strlen
      i = i + 1
      hash = (hash * 256 + x2) % 16777216
      t = hash_tables[hash]
      if not t then
        t = {};
        hash_tables[hash] = t
      end
      t[#t + 1] = i - strlen
      i = i + 1
      hash = (hash * 256 + x3) % 16777216
      t = hash_tables[hash]
      if not t then
        t = {};
        hash_tables[hash] = t
      end
      t[#t + 1] = i - strlen
      i = i + 1
      hash = (hash * 256 + x4) % 16777216
      t = hash_tables[hash]
      if not t then
        t = {};
        hash_tables[hash] = t
      end
      t[#t + 1] = i - strlen
      i = i + 1
    end
    while i <= strlen - 2 do
      local x = string_byte(str, i + 2)
      string_table[i + 2] = x
      hash = (hash * 256 + x) % 16777216
      local t = hash_tables[hash]
      if not t then
        t = {};
        hash_tables[hash] = t
      end
      t[#t + 1] = i - strlen
      i = i + 1
    end
  end
  return dictionary
end

-- Check if the dictionary is valid.
-- @param dictionary The preset dictionary for compression and decompression.
-- @return true if valid, false if not valid.
-- @return if not valid, the error message.
local function IsValidDictionary(dictionary)
  if type(dictionary) ~= "table" then
    return false,
           ("'dictionary' - table expected got '%s'."):format(type(dictionary))
  end
  if type(dictionary.adler32) ~= "number" or type(dictionary.string_table) ~=
    "table" or type(dictionary.strlen) ~= "number" or dictionary.strlen <= 0 or
    dictionary.strlen > 32768 or dictionary.strlen ~= #dictionary.string_table or
    type(dictionary.hash_tables) ~= "table" then
    return false,
           ("'dictionary' - corrupted dictionary."):format(type(dictionary))
  end
  return true, ""
end

--[[
	key of the configuration table is the compression level,
	and its value stores the compression setting.
	These numbers come from zlib source code.

	Higher compression level usually means better compression.
	(Because LibDeflate uses a simplified version of zlib algorithm,
	there is no guarantee that higher compression level does not create
	bigger file than lower level, but I can say it's 99% likely)

	Be careful with the high compression level. This is a pure lua
	implementation compressor/decompressor, which is significant slower than
	a C/C++ equivalant compressor/decompressor. Very high compression level
	costs significant more CPU time, and usually compression size won't be
	significant smaller when you increase compression level by 1, when the
	level is already very high. Benchmark yourself if you can afford it.

	See also https://github.com/madler/zlib/blob/master/doc/algorithm.txt,
	https://github.com/madler/zlib/blob/master/deflate.c for more information.

	The meaning of each field:
	@field 1 use_lazy_evaluation:
		true/false. Whether the program uses lazy evaluation.
		See what is "lazy evaluation" in the link above.
		lazy_evaluation improves ratio, but relatively slow.
	@field 2 good_prev_length:
		Only effective if lazy is set, Only use 1/4 of max_chain,
		if prev length of lazy match is above this.
	@field 3 max_insert_length/max_lazy_match:
		If not using lazy evaluation,
		insert new strings in the hash table only if the match length is not
		greater than this length.
		If using lazy evaluation, only continue lazy evaluation,
		if previous match length is strictly smaller than this value.
	@field 4 nice_length:
		Number. Don't continue to go down the hash chain,
		if match length is above this.
	@field 5 max_chain:
		Number. The maximum number of hash chains we look.
--]]
local _compression_level_configs = {
  [0] = {false, nil, 0, 0, 0}, -- level 0, no compression
  [1] = {false, nil, 4, 8, 4}, -- level 1, similar to zlib level 1
  [2] = {false, nil, 5, 18, 8}, -- level 2, similar to zlib level 2
  [3] = {false, nil, 6, 32, 32}, -- level 3, similar to zlib level 3
  [4] = {true, 4, 4, 16, 16}, -- level 4, similar to zlib level 4
  [5] = {true, 8, 16, 32, 32}, -- level 5, similar to zlib level 5
  [6] = {true, 8, 16, 128, 128}, -- level 6, similar to zlib level 6
  [7] = {true, 8, 32, 128, 256}, -- (SLOW) level 7, similar to zlib level 7
  [8] = {true, 32, 128, 258, 1024}, -- (SLOW) level 8,similar to zlib level 8
  [9] = {true, 32, 258, 258, 4096}
  -- (VERY SLOW) level 9, similar to zlib level 9
}

-- Check if the compression/decompression arguments is valid
-- @param str The input string.
-- @param check_dictionary if true, check if dictionary is valid.
-- @param dictionary The preset dictionary for compression and decompression.
-- @param check_configs if true, check if config is valid.
-- @param configs The compression configuration table
-- @return true if valid, false if not valid.
-- @return if not valid, the error message.
local function IsValidArguments(str, check_dictionary, dictionary,
                                check_configs, configs)

  if type(str) ~= "string" then
    return false, ("'str' - string expected got '%s'."):format(type(str))
  end
  if check_dictionary then
    local dict_valid, dict_err = IsValidDictionary(dictionary)
    if not dict_valid then return false, dict_err end
  end
  if check_configs then
    local type_configs = type(configs)
    if type_configs ~= "nil" and type_configs ~= "table" then
      return false, ("'configs' - nil or table expected got '%s'."):format(
               type(configs))
    end
    if type_configs == "table" then
      for k, v in pairs(configs) do
        if k ~= "level" and k ~= "strategy" then
          return false,
                 ("'configs' - unsupported table key in the configs: '%s'."):format(
                   k)
        elseif k == "level" and not _compression_level_configs[v] then
          return false,
                 ("'configs' - unsupported 'level': %s."):format(tostring(v))
        elseif k == "strategy" and v ~= "fixed" and v ~= "huffman_only" and v ~=
          "dynamic" then
          -- random_block_type is for testing purpose
          return false, ("'configs' - unsupported 'strategy': '%s'."):format(
                   tostring(v))
        end
      end
    end
  end
  return true, ""
end

--[[ --------------------------------------------------------------------------
	Compress code
--]] --------------------------------------------------------------------------

-- partial flush to save memory
local _FLUSH_MODE_MEMORY_CLEANUP = 0
-- full flush with partial bytes
local _FLUSH_MODE_OUTPUT = 1
-- write bytes to get to byte boundary
local _FLUSH_MODE_BYTE_BOUNDARY = 2
-- no flush, just get num of bits written so far
local _FLUSH_MODE_NO_FLUSH = 3

--[[
	Create an empty writer to easily write stuffs as the unit of bits.
	Return values:
	1. WriteBits(code, bitlen):
	2. WriteString(str):
	3. Flush(mode):
--]]
local function CreateWriter()
  local buffer_size = 0
  local cache = 0
  local cache_bitlen = 0
  local total_bitlen = 0
  local buffer = {}
  -- When buffer is big enough, flush into result_buffer to save memory.
  local result_buffer = {}

  -- Write bits with value "value" and bit length of "bitlen" into writer.
  -- @param value: The value being written
  -- @param bitlen: The bit length of "value"
  -- @return nil
  local function WriteBits(value, bitlen)
    cache = cache + value * _pow2[cache_bitlen]
    cache_bitlen = cache_bitlen + bitlen
    total_bitlen = total_bitlen + bitlen
    -- Only bulk to buffer every 4 bytes. This is quicker.
    if cache_bitlen >= 32 then
      buffer_size = buffer_size + 1
      buffer[buffer_size] = _byte_to_char[cache % 256] ..
                              _byte_to_char[((cache - cache % 256) / 256 % 256)] ..
                              _byte_to_char[((cache - cache % 65536) / 65536 %
                                256)] ..
                              _byte_to_char[((cache - cache % 16777216) /
                                16777216 % 256)]
      local rshift_mask = _pow2[32 - cache_bitlen + bitlen]
      cache = (value - value % rshift_mask) / rshift_mask
      cache_bitlen = cache_bitlen - 32
    end
  end

  -- Write the entire string into the writer.
  -- @param str The string being written
  -- @return nil
  local function WriteString(str)
    for _ = 1, cache_bitlen, 8 do
      buffer_size = buffer_size + 1
      buffer[buffer_size] = string_char(cache % 256)
      cache = (cache - cache % 256) / 256
    end
    cache_bitlen = 0
    buffer_size = buffer_size + 1
    buffer[buffer_size] = str
    total_bitlen = total_bitlen + #str * 8
  end

  -- Flush current stuffs in the writer and return it.
  -- This operation will free most of the memory.
  -- @param mode See the descrtion of the constant and the source code.
  -- @return The total number of bits stored in the writer right now.
  -- for byte boundary mode, it includes the padding bits.
  -- for output mode, it does not include padding bits.
  -- @return Return the outputs if mode is output.
  local function FlushWriter(mode)
    if mode == _FLUSH_MODE_NO_FLUSH then return total_bitlen end

    if mode == _FLUSH_MODE_OUTPUT or mode == _FLUSH_MODE_BYTE_BOUNDARY then
      -- Full flush, also output cache.
      -- Need to pad some bits if cache_bitlen is not multiple of 8.
      local padding_bitlen = (8 - cache_bitlen % 8) % 8

      if cache_bitlen > 0 then
        -- padding with all 1 bits, mainly because "\000" is not
        -- good to be tranmitted. I do this so "\000" is a little bit
        -- less frequent.
        cache = cache - _pow2[cache_bitlen] +
                  _pow2[cache_bitlen + padding_bitlen]
        for _ = 1, cache_bitlen, 8 do
          buffer_size = buffer_size + 1
          buffer[buffer_size] = _byte_to_char[cache % 256]
          cache = (cache - cache % 256) / 256
        end

        cache = 0
        cache_bitlen = 0
      end
      if mode == _FLUSH_MODE_BYTE_BOUNDARY then
        total_bitlen = total_bitlen + padding_bitlen
        return total_bitlen
      end
    end

    local flushed = table_concat(buffer)
    buffer = {}
    buffer_size = 0
    result_buffer[#result_buffer + 1] = flushed

    if mode == _FLUSH_MODE_MEMORY_CLEANUP then
      return total_bitlen
    else
      return total_bitlen, table_concat(result_buffer)
    end
  end

  return WriteBits, WriteString, FlushWriter
end

-- Push an element into a max heap
-- @param heap A max heap whose max element is at index 1.
-- @param e The element to be pushed. Assume element "e" is a table
--  and comparison is done via its first entry e[1]
-- @param heap_size current number of elements in the heap.
--  NOTE: There may be some garbage stored in
--  heap[heap_size+1], heap[heap_size+2], etc..
-- @return nil
local function MinHeapPush(heap, e, heap_size)
  heap_size = heap_size + 1
  heap[heap_size] = e
  local value = e[1]
  local pos = heap_size
  local parent_pos = (pos - pos % 2) / 2

  while (parent_pos >= 1 and heap[parent_pos][1] > value) do
    local t = heap[parent_pos]
    heap[parent_pos] = e
    heap[pos] = t
    pos = parent_pos
    parent_pos = (parent_pos - parent_pos % 2) / 2
  end
end

-- Pop an element from a max heap
-- @param heap A max heap whose max element is at index 1.
-- @param heap_size current number of elements in the heap.
-- @return the poped element
-- Note: This function does not change table size of "heap" to save CPU time.
local function MinHeapPop(heap, heap_size)
  local top = heap[1]
  local e = heap[heap_size]
  local value = e[1]
  heap[1] = e
  heap[heap_size] = top
  heap_size = heap_size - 1

  local pos = 1
  local left_child_pos = pos * 2
  local right_child_pos = left_child_pos + 1

  while (left_child_pos <= heap_size) do
    local left_child = heap[left_child_pos]
    if (right_child_pos <= heap_size and heap[right_child_pos][1] <
      left_child[1]) then
      local right_child = heap[right_child_pos]
      if right_child[1] < value then
        heap[right_child_pos] = e
        heap[pos] = right_child
        pos = right_child_pos
        left_child_pos = pos * 2
        right_child_pos = left_child_pos + 1
      else
        break
      end
    else
      if left_child[1] < value then
        heap[left_child_pos] = e
        heap[pos] = left_child
        pos = left_child_pos
        left_child_pos = pos * 2
        right_child_pos = left_child_pos + 1
      else
        break
      end
    end
  end

  return top
end

-- Deflate defines a special huffman tree, which is unique once the bit length
-- of huffman code of all symbols are known.
-- @param bitlen_count Number of symbols with a specific bitlen
-- @param symbol_bitlen The bit length of a symbol
-- @param max_symbol The max symbol among all symbols,
--		which is (number of symbols - 1)
-- @param max_bitlen The max huffman bit length among all symbols.
-- @return The huffman code of all symbols.
local function GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens,
                                        max_symbol, max_bitlen)
  local huffman_code = 0
  local next_codes = {}
  local symbol_huffman_codes = {}
  for bitlen = 1, max_bitlen do
    huffman_code = (huffman_code + (bitlen_counts[bitlen - 1] or 0)) * 2
    next_codes[bitlen] = huffman_code
  end
  for symbol = 0, max_symbol do
    local bitlen = symbol_bitlens[symbol]
    if bitlen then
      huffman_code = next_codes[bitlen]
      next_codes[bitlen] = huffman_code + 1

      -- Reverse the bits of huffman code,
      -- because most signifant bits of huffman code
      -- is stored first into the compressed data.
      -- @see RFC1951 Page5 Section 3.1.1
      if bitlen <= 9 then -- Have cached reverse for small bitlen.
        symbol_huffman_codes[symbol] = _reverse_bits_tbl[bitlen][huffman_code]
      else
        local reverse = 0
        for _ = 1, bitlen do
          reverse = reverse - reverse % 2 +
                      (((reverse % 2 == 1) or (huffman_code % 2) == 1) and 1 or
                        0)
          huffman_code = (huffman_code - huffman_code % 2) / 2
          reverse = reverse * 2
        end
        symbol_huffman_codes[symbol] = (reverse - reverse % 2) / 2
      end
    end
  end
  return symbol_huffman_codes
end

-- A helper function to sort heap elements
-- a[1], b[1] is the huffman frequency
-- a[2], b[2] is the symbol value.
local function SortByFirstThenSecond(a, b)
  return a[1] < b[1] or (a[1] == b[1] and a[2] < b[2])
end

-- Calculate the huffman bit length and huffman code.
-- @param symbol_count: A table whose table key is the symbol, and table value
--		is the symbol frenquency (nil means 0 frequency).
-- @param max_bitlen: See description of return value.
-- @param max_symbol: The maximum symbol
-- @return a table whose key is the symbol, and the value is the huffman bit
--		bit length. We guarantee that all bit length <= max_bitlen.
--		For 0<=symbol<=max_symbol, table value could be nil if the frequency
--		of the symbol is 0 or nil.
-- @return a table whose key is the symbol, and the value is the huffman code.
-- @return a number indicating the maximum symbol whose bitlen is not 0.
local function GetHuffmanBitlenAndCode(symbol_counts, max_bitlen, max_symbol)
  local heap_size
  local max_non_zero_bitlen_symbol = -1
  local leafs = {}
  local heap = {}
  local symbol_bitlens = {}
  local symbol_codes = {}
  local bitlen_counts = {}

  --[[
		tree[1]: weight, temporarily used as parent and bitLengths
		tree[2]: symbol
		tree[3]: left child
		tree[4]: right child
	--]]
  local number_unique_symbols = 0
  for symbol, count in pairs(symbol_counts) do
    number_unique_symbols = number_unique_symbols + 1
    leafs[number_unique_symbols] = {count, symbol}
  end

  if (number_unique_symbols == 0) then
    -- no code.
    return {}, {}, -1
  elseif (number_unique_symbols == 1) then
    -- Only one code. In this case, its huffman code
    -- needs to be assigned as 0, and bit length is 1.
    -- This is the only case that the return result
    -- represents an imcomplete huffman tree.
    local symbol = leafs[1][2]
    symbol_bitlens[symbol] = 1
    symbol_codes[symbol] = 0
    return symbol_bitlens, symbol_codes, symbol
  else
    table_sort(leafs, SortByFirstThenSecond)
    heap_size = number_unique_symbols
    for i = 1, heap_size do heap[i] = leafs[i] end

    while (heap_size > 1) do
      -- Note: pop does not change table size of heap
      local leftChild = MinHeapPop(heap, heap_size)
      heap_size = heap_size - 1
      local rightChild = MinHeapPop(heap, heap_size)
      heap_size = heap_size - 1
      local newNode = {leftChild[1] + rightChild[1], -1, leftChild, rightChild}
      MinHeapPush(heap, newNode, heap_size)
      heap_size = heap_size + 1
    end

    -- Number of leafs whose bit length is greater than max_len.
    local number_bitlen_overflow = 0

    -- Calculate bit length of all nodes
    local fifo = {heap[1], 0, 0, 0} -- preallocate some spaces.
    local fifo_size = 1
    local index = 1
    heap[1][1] = 0
    while (index <= fifo_size) do -- Breath first search
      local e = fifo[index]
      local bitlen = e[1]
      local symbol = e[2]
      local left_child = e[3]
      local right_child = e[4]
      if left_child then
        fifo_size = fifo_size + 1
        fifo[fifo_size] = left_child
        left_child[1] = bitlen + 1
      end
      if right_child then
        fifo_size = fifo_size + 1
        fifo[fifo_size] = right_child
        right_child[1] = bitlen + 1
      end
      index = index + 1

      if (bitlen > max_bitlen) then
        number_bitlen_overflow = number_bitlen_overflow + 1
        bitlen = max_bitlen
      end
      if symbol >= 0 then
        symbol_bitlens[symbol] = bitlen
        max_non_zero_bitlen_symbol = (symbol > max_non_zero_bitlen_symbol) and
                                       symbol or max_non_zero_bitlen_symbol
        bitlen_counts[bitlen] = (bitlen_counts[bitlen] or 0) + 1
      end
    end

    -- Resolve bit length overflow
    -- @see ZLib/trees.c:gen_bitlen(s, desc), for reference
    if (number_bitlen_overflow > 0) then
      repeat
        local bitlen = max_bitlen - 1
        while ((bitlen_counts[bitlen] or 0) == 0) do bitlen = bitlen - 1 end
        -- move one leaf down the tree
        bitlen_counts[bitlen] = bitlen_counts[bitlen] - 1
        -- move one overflow item as its brother
        bitlen_counts[bitlen + 1] = (bitlen_counts[bitlen + 1] or 0) + 2
        bitlen_counts[max_bitlen] = bitlen_counts[max_bitlen] - 1
        number_bitlen_overflow = number_bitlen_overflow - 2
      until (number_bitlen_overflow <= 0)

      index = 1
      for bitlen = max_bitlen, 1, -1 do
        local n = bitlen_counts[bitlen] or 0
        while (n > 0) do
          local symbol = leafs[index][2]
          symbol_bitlens[symbol] = bitlen
          n = n - 1
          index = index + 1
        end
      end
    end

    symbol_codes = GetHuffmanCodeFromBitlen(bitlen_counts, symbol_bitlens,
                                            max_symbol, max_bitlen)
    return symbol_bitlens, symbol_codes, max_non_zero_bitlen_symbol
  end
end

-- Calculate the first huffman header in the dynamic huffman block
-- @see RFC1951 Page 12
-- @param lcode_bitlen: The huffman bit length of literal/LZ77_length.
-- @param max_non_zero_bitlen_lcode: The maximum literal/LZ77_length symbol
--		whose huffman bit length is not zero.
-- @param dcode_bitlen: The huffman bit length of LZ77 distance.
-- @param max_non_zero_bitlen_dcode: The maximum LZ77 distance symbol
--		whose huffman bit length is not zero.
-- @return The run length encoded codes.
-- @return The extra bits. One entry for each rle code that needs extra bits.
--		(code == 16 or 17 or 18).
-- @return The count of appearance of each rle codes.
local function RunLengthEncodeHuffmanBitlen(lcode_bitlens,
                                            max_non_zero_bitlen_lcode,
                                            dcode_bitlens,
                                            max_non_zero_bitlen_dcode)
  local rle_code_tblsize = 0
  local rle_codes = {}
  local rle_code_counts = {}
  local rle_extra_bits_tblsize = 0
  local rle_extra_bits = {}
  local prev = nil
  local count = 0

  -- If there is no distance code, assume one distance code of bit length 0.
  -- RFC1951: One distance code of zero bits means that
  -- there are no distance codes used at all (the data is all literals).
  max_non_zero_bitlen_dcode = (max_non_zero_bitlen_dcode < 0) and 0 or
                                max_non_zero_bitlen_dcode
  local max_code = max_non_zero_bitlen_lcode + max_non_zero_bitlen_dcode + 1

  for code = 0, max_code + 1 do
    local len = (code <= max_non_zero_bitlen_lcode) and
                  (lcode_bitlens[code] or 0) or ((code <= max_code) and
                  (dcode_bitlens[code - max_non_zero_bitlen_lcode - 1] or 0) or
                  nil)
    if len == prev then
      count = count + 1
      if len ~= 0 and count == 6 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[rle_code_tblsize] = 16
        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
        rle_extra_bits[rle_extra_bits_tblsize] = 3
        rle_code_counts[16] = (rle_code_counts[16] or 0) + 1
        count = 0
      elseif len == 0 and count == 138 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[rle_code_tblsize] = 18
        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
        rle_extra_bits[rle_extra_bits_tblsize] = 127
        rle_code_counts[18] = (rle_code_counts[18] or 0) + 1
        count = 0
      end
    else
      if count == 1 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[rle_code_tblsize] = prev
        rle_code_counts[prev] = (rle_code_counts[prev] or 0) + 1
      elseif count == 2 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[rle_code_tblsize] = prev
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[rle_code_tblsize] = prev
        rle_code_counts[prev] = (rle_code_counts[prev] or 0) + 2
      elseif count >= 3 then
        rle_code_tblsize = rle_code_tblsize + 1
        local rleCode = (prev ~= 0) and 16 or (count <= 10 and 17 or 18)
        rle_codes[rle_code_tblsize] = rleCode
        rle_code_counts[rleCode] = (rle_code_counts[rleCode] or 0) + 1
        rle_extra_bits_tblsize = rle_extra_bits_tblsize + 1
        rle_extra_bits[rle_extra_bits_tblsize] =
          (count <= 10) and (count - 3) or (count - 11)
      end

      prev = len
      if len and len ~= 0 then
        rle_code_tblsize = rle_code_tblsize + 1
        rle_codes[rle_code_tblsize] = len
        rle_code_counts[len] = (rle_code_counts[len] or 0) + 1
        count = 0
      else
        count = 1
      end
    end
  end

  return rle_codes, rle_extra_bits, rle_code_counts
end

-- Load the string into a table, in order to speed up LZ77.
-- Loop unrolled 16 times to speed this function up.
-- @param str The string to be loaded.
-- @param t The load destination
-- @param start str[index] will be the first character to be loaded.
-- @param end str[index] will be the last character to be loaded
-- @param offset str[index] will be loaded into t[index-offset]
-- @return t
local function LoadStringToTable(str, t, start, stop, offset)
  local i = start - offset
  while i <= stop - 15 - offset do
    t[i], t[i + 1], t[i + 2], t[i + 3], t[i + 4], t[i + 5], t[i + 6], t[i + 7], t[i +
      8], t[i + 9], t[i + 10], t[i + 11], t[i + 12], t[i + 13], t[i + 14], t[i +
      15] = string_byte(str, i + offset, i + 15 + offset)
    i = i + 16
  end
  while (i <= stop - offset) do
    t[i] = string_byte(str, i + offset, i + offset)
    i = i + 1
  end
  return t
end

-- Do LZ77 process. This function uses the majority of the CPU time.
-- @see zlib/deflate.c:deflate_fast(), zlib/deflate.c:deflate_slow()
-- @see https://github.com/madler/zlib/blob/master/doc/algorithm.txt
-- This function uses the algorithms used above. You should read the
-- algorithm.txt above to understand what is the hash function and the
-- lazy evaluation.
--
-- The special optimization used here is hash functions used here.
-- The hash function is just the multiplication of the three consective
-- characters. So if the hash matches, it guarantees 3 characters are matched.
-- This optimization can be implemented because Lua table is a hash table.
--
-- @param level integer that describes compression level.
-- @param string_table table that stores the value of string to be compressed.
--			The index of this table starts from 1.
--			The caller needs to make sure all values needed by this function
--			are loaded.
--			Assume "str" is the origin input string into the compressor
--			str[block_start]..str[block_end+3] needs to be loaded into
--			string_table[block_start-offset]..string_table[block_end-offset]
--			If dictionary is presented, the last 258 bytes of the dictionary
--			needs to be loaded into sing_table[-257..0]
--			(See more in the description of offset.)
-- @param hash_tables. The table key is the hash value (0<=hash<=16777216=256^3)
--			The table value is an array0 that stores the indexes of the
--			input data string to be compressed, such that
--			hash == str[index]*str[index+1]*str[index+2]
--			Indexes are ordered in this array.
-- @param block_start The indexes of the input data string to be compressed.
--				that starts the LZ77 block.
-- @param block_end The indexes of the input data string to be compressed.
--				that stores the LZ77 block.
-- @param offset str[index] is stored in string_table[index-offset],
--			This offset is mainly an optimization to limit the index
--			of string_table, so lua can access this table quicker.
-- @param dictionary See LibDeflate:CreateDictionary
-- @return literal/LZ77_length deflate codes.
-- @return the extra bits of literal/LZ77_length deflate codes.
-- @return the count of each literal/LZ77 deflate code.
-- @return LZ77 distance deflate codes.
-- @return the extra bits of LZ77 distance deflate codes.
-- @return the count of each LZ77 distance deflate code.
local function GetBlockLZ77Result(level, string_table, hash_tables, block_start,
                                  block_end, offset, dictionary)
  local config = _compression_level_configs[level]
  local config_use_lazy, config_good_prev_length, config_max_lazy_match,
        config_nice_length, config_max_hash_chain = config[1], config[2],
                                                    config[3], config[4],
                                                    config[5]

  local config_max_insert_length = (not config_use_lazy) and
                                     config_max_lazy_match or 2147483646
  local config_good_hash_chain =
    (config_max_hash_chain - config_max_hash_chain % 4 / 4)

  local hash

  local dict_hash_tables
  local dict_string_table
  local dict_string_len = 0

  if dictionary then
    dict_hash_tables = dictionary.hash_tables
    dict_string_table = dictionary.string_table
    dict_string_len = dictionary.strlen
    assert(block_start == 1)
    if block_end >= block_start and dict_string_len >= 2 then
      hash = dict_string_table[dict_string_len - 1] * 65536 +
               dict_string_table[dict_string_len] * 256 + string_table[1]
      local t = hash_tables[hash]
      if not t then
        t = {};
        hash_tables[hash] = t
      end
      t[#t + 1] = -1
    end
    if block_end >= block_start + 1 and dict_string_len >= 1 then
      hash =
        dict_string_table[dict_string_len] * 65536 + string_table[1] * 256 +
          string_table[2]
      local t = hash_tables[hash]
      if not t then
        t = {};
        hash_tables[hash] = t
      end
      t[#t + 1] = 0
    end
  end

  local dict_string_len_plus3 = dict_string_len + 3

  hash = (string_table[block_start - offset] or 0) * 256 +
           (string_table[block_start + 1 - offset] or 0)

  local lcodes = {}
  local lcode_tblsize = 0
  local lcodes_counts = {}
  local dcodes = {}
  local dcodes_tblsize = 0
  local dcodes_counts = {}

  local lextra_bits = {}
  local lextra_bits_tblsize = 0
  local dextra_bits = {}
  local dextra_bits_tblsize = 0

  local match_available = false
  local prev_len
  local prev_dist
  local cur_len = 0
  local cur_dist = 0

  local index = block_start
  local index_end = block_end + (config_use_lazy and 1 or 0)

  -- the zlib source code writes separate code for lazy evaluation and
  -- not lazy evaluation, which is easier to understand.
  -- I put them together, so it is a bit harder to understand.
  -- because I think this is easier for me to maintain it.
  while (index <= index_end) do
    local string_table_index = index - offset
    local offset_minus_three = offset - 3
    prev_len = cur_len
    prev_dist = cur_dist
    cur_len = 0

    hash = (hash * 256 + (string_table[string_table_index + 2] or 0)) % 16777216

    local chain_index
    local cur_chain
    local hash_chain = hash_tables[hash]
    local chain_old_size
    if not hash_chain then
      chain_old_size = 0
      hash_chain = {}
      hash_tables[hash] = hash_chain
      if dict_hash_tables then
        cur_chain = dict_hash_tables[hash]
        chain_index = cur_chain and #cur_chain or 0
      else
        chain_index = 0
      end
    else
      chain_old_size = #hash_chain
      cur_chain = hash_chain
      chain_index = chain_old_size
    end

    if index <= block_end then hash_chain[chain_old_size + 1] = index end

    if (chain_index > 0 and index + 2 <= block_end and
      (not config_use_lazy or prev_len < config_max_lazy_match)) then

      local depth =
        (config_use_lazy and prev_len >= config_good_prev_length) and
          config_good_hash_chain or config_max_hash_chain

      local max_len_minus_one = block_end - index
      max_len_minus_one = (max_len_minus_one >= 257) and 257 or
                            max_len_minus_one
      max_len_minus_one = max_len_minus_one + string_table_index
      local string_table_index_plus_three = string_table_index + 3

      while chain_index >= 1 and depth > 0 do
        local prev = cur_chain[chain_index]

        if index - prev > 32768 then break end
        if prev < index then
          local sj = string_table_index_plus_three

          if prev >= -257 then
            local pj = prev - offset_minus_three
            while (sj <= max_len_minus_one and string_table[pj] ==
              string_table[sj]) do
              sj = sj + 1
              pj = pj + 1
            end
          else
            local pj = dict_string_len_plus3 + prev
            while (sj <= max_len_minus_one and dict_string_table[pj] ==
              string_table[sj]) do
              sj = sj + 1
              pj = pj + 1
            end
          end
          local j = sj - string_table_index
          if j > cur_len then
            cur_len = j
            cur_dist = index - prev
          end
          if cur_len >= config_nice_length then break end
        end

        chain_index = chain_index - 1
        depth = depth - 1
        if chain_index == 0 and prev > 0 and dict_hash_tables then
          cur_chain = dict_hash_tables[hash]
          chain_index = cur_chain and #cur_chain or 0
        end
      end
    end

    if not config_use_lazy then prev_len, prev_dist = cur_len, cur_dist end
    if ((not config_use_lazy or match_available) and
      (prev_len > 3 or (prev_len == 3 and prev_dist < 4096)) and cur_len <=
      prev_len) then
      local code = _length_to_deflate_code[prev_len]
      local length_extra_bits_bitlen = _length_to_deflate_extra_bitlen[prev_len]
      local dist_code, dist_extra_bits_bitlen, dist_extra_bits
      if prev_dist <= 256 then -- have cached code for small distance.
        dist_code = _dist256_to_deflate_code[prev_dist]
        dist_extra_bits = _dist256_to_deflate_extra_bits[prev_dist]
        dist_extra_bits_bitlen = _dist256_to_deflate_extra_bitlen[prev_dist]
      else
        dist_code = 16
        dist_extra_bits_bitlen = 7
        local a = 384
        local b = 512

        while true do
          if prev_dist <= a then
            dist_extra_bits = (prev_dist - (b / 2) - 1) % (b / 4)
            break
          elseif prev_dist <= b then
            dist_extra_bits = (prev_dist - (b / 2) - 1) % (b / 4)
            dist_code = dist_code + 1
            break
          else
            dist_code = dist_code + 2
            dist_extra_bits_bitlen = dist_extra_bits_bitlen + 1
            a = a * 2
            b = b * 2
          end
        end
      end
      lcode_tblsize = lcode_tblsize + 1
      lcodes[lcode_tblsize] = code
      lcodes_counts[code] = (lcodes_counts[code] or 0) + 1

      dcodes_tblsize = dcodes_tblsize + 1
      dcodes[dcodes_tblsize] = dist_code
      dcodes_counts[dist_code] = (dcodes_counts[dist_code] or 0) + 1

      if length_extra_bits_bitlen > 0 then
        local lenExtraBits = _length_to_deflate_extra_bits[prev_len]
        lextra_bits_tblsize = lextra_bits_tblsize + 1
        lextra_bits[lextra_bits_tblsize] = lenExtraBits
      end
      if dist_extra_bits_bitlen > 0 then
        dextra_bits_tblsize = dextra_bits_tblsize + 1
        dextra_bits[dextra_bits_tblsize] = dist_extra_bits
      end

      for i = index + 1, index + prev_len - (config_use_lazy and 2 or 1) do
        hash = (hash * 256 + (string_table[i - offset + 2] or 0)) % 16777216
        if prev_len <= config_max_insert_length then
          hash_chain = hash_tables[hash]
          if not hash_chain then
            hash_chain = {}
            hash_tables[hash] = hash_chain
          end
          hash_chain[#hash_chain + 1] = i
        end
      end
      index = index + prev_len - (config_use_lazy and 1 or 0)
      match_available = false
    elseif (not config_use_lazy) or match_available then
      local code = string_table[config_use_lazy and (string_table_index - 1) or
                     string_table_index]
      lcode_tblsize = lcode_tblsize + 1
      lcodes[lcode_tblsize] = code
      lcodes_counts[code] = (lcodes_counts[code] or 0) + 1
      index = index + 1
    else
      match_available = true
      index = index + 1
    end
  end

  -- Write "end of block" symbol
  lcode_tblsize = lcode_tblsize + 1
  lcodes[lcode_tblsize] = 256
  lcodes_counts[256] = (lcodes_counts[256] or 0) + 1

  return lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits, dcodes_counts
end

-- Get the header data of dynamic block.
-- @param lcodes_count The count of each literal/LZ77_length codes.
-- @param dcodes_count The count of each Lz77 distance codes.
-- @return a lots of stuffs.
-- @see RFC1951 Page 12
local function GetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)
  local lcodes_huffman_bitlens, lcodes_huffman_codes, max_non_zero_bitlen_lcode =
    GetHuffmanBitlenAndCode(lcodes_counts, 15, 285)
  local dcodes_huffman_bitlens, dcodes_huffman_codes, max_non_zero_bitlen_dcode =
    GetHuffmanBitlenAndCode(dcodes_counts, 15, 29)

  local rle_deflate_codes, rle_extra_bits, rle_codes_counts =
    RunLengthEncodeHuffmanBitlen(lcodes_huffman_bitlens,
                                 max_non_zero_bitlen_lcode,
                                 dcodes_huffman_bitlens,
                                 max_non_zero_bitlen_dcode)

  local rle_codes_huffman_bitlens, rle_codes_huffman_codes =
    GetHuffmanBitlenAndCode(rle_codes_counts, 7, 18)

  local HCLEN = 0
  for i = 1, 19 do
    local symbol = _rle_codes_huffman_bitlen_order[i]
    local length = rle_codes_huffman_bitlens[symbol] or 0
    if length ~= 0 then HCLEN = i end
  end

  HCLEN = HCLEN - 4
  local HLIT = max_non_zero_bitlen_lcode + 1 - 257
  local HDIST = max_non_zero_bitlen_dcode + 1 - 1
  if HDIST < 0 then HDIST = 0 end

  return HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens, rle_codes_huffman_codes,
         rle_deflate_codes, rle_extra_bits, lcodes_huffman_bitlens,
         lcodes_huffman_codes, dcodes_huffman_bitlens, dcodes_huffman_codes
end

-- Get the size of dynamic block without writing any bits into the writer.
-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()
-- @return the bit length of the dynamic block
local function GetDynamicHuffmanBlockSize(lcodes, dcodes, HCLEN,
                                          rle_codes_huffman_bitlens,
                                          rle_deflate_codes,
                                          lcodes_huffman_bitlens,
                                          dcodes_huffman_bitlens)

  local block_bitlen = 17 -- 1+2+5+5+4
  block_bitlen = block_bitlen + (HCLEN + 4) * 3

  for i = 1, #rle_deflate_codes do
    local code = rle_deflate_codes[i]
    block_bitlen = block_bitlen + rle_codes_huffman_bitlens[code]
    if code >= 16 then
      block_bitlen = block_bitlen +
                       ((code == 16) and 2 or (code == 17 and 3 or 7))
    end
  end

  local length_code_count = 0
  for i = 1, #lcodes do
    local code = lcodes[i]
    local huffman_bitlen = lcodes_huffman_bitlens[code]
    block_bitlen = block_bitlen + huffman_bitlen
    if code > 256 then -- Length code
      length_code_count = length_code_count + 1
      if code > 264 and code < 285 then -- Length code with extra bits
        local extra_bits_bitlen = _literal_deflate_code_to_extra_bitlen[code -
                                    256]
        block_bitlen = block_bitlen + extra_bits_bitlen
      end
      local dist_code = dcodes[length_code_count]
      local dist_huffman_bitlen = dcodes_huffman_bitlens[dist_code]
      block_bitlen = block_bitlen + dist_huffman_bitlen

      if dist_code > 3 then -- dist code with extra bits
        local dist_extra_bits_bitlen = (dist_code - dist_code % 2) / 2 - 1
        block_bitlen = block_bitlen + dist_extra_bits_bitlen
      end
    end
  end
  return block_bitlen
end

-- Write dynamic block.
-- @param ... Read the source code of GetBlockDynamicHuffmanHeader()
local function CompressDynamicHuffmanBlock(WriteBits, is_last_block, lcodes,
                                           lextra_bits, dcodes, dextra_bits,
                                           HLIT, HDIST, HCLEN,
                                           rle_codes_huffman_bitlens,
                                           rle_codes_huffman_codes,
                                           rle_deflate_codes, rle_extra_bits,
                                           lcodes_huffman_bitlens,
                                           lcodes_huffman_codes,
                                           dcodes_huffman_bitlens,
                                           dcodes_huffman_codes)

  WriteBits(is_last_block and 1 or 0, 1) -- Last block identifier
  WriteBits(2, 2) -- Dynamic Huffman block identifier

  WriteBits(HLIT, 5)
  WriteBits(HDIST, 5)
  WriteBits(HCLEN, 4)

  for i = 1, HCLEN + 4 do
    local symbol = _rle_codes_huffman_bitlen_order[i]
    local length = rle_codes_huffman_bitlens[symbol] or 0
    WriteBits(length, 3)
  end

  local rleExtraBitsIndex = 1
  for i = 1, #rle_deflate_codes do
    local code = rle_deflate_codes[i]
    WriteBits(rle_codes_huffman_codes[code], rle_codes_huffman_bitlens[code])
    if code >= 16 then
      local extraBits = rle_extra_bits[rleExtraBitsIndex]
      WriteBits(extraBits, (code == 16) and 2 or (code == 17 and 3 or 7))
      rleExtraBitsIndex = rleExtraBitsIndex + 1
    end
  end

  local length_code_count = 0
  local length_code_with_extra_count = 0
  local dist_code_with_extra_count = 0

  for i = 1, #lcodes do
    local deflate_codee = lcodes[i]
    local huffman_code = lcodes_huffman_codes[deflate_codee]
    local huffman_bitlen = lcodes_huffman_bitlens[deflate_codee]
    WriteBits(huffman_code, huffman_bitlen)
    if deflate_codee > 256 then -- Length code
      length_code_count = length_code_count + 1
      if deflate_codee > 264 and deflate_codee < 285 then
        -- Length code with extra bits
        length_code_with_extra_count = length_code_with_extra_count + 1
        local extra_bits = lextra_bits[length_code_with_extra_count]
        local extra_bits_bitlen =
          _literal_deflate_code_to_extra_bitlen[deflate_codee - 256]
        WriteBits(extra_bits, extra_bits_bitlen)
      end
      -- Write distance code
      local dist_deflate_code = dcodes[length_code_count]
      local dist_huffman_code = dcodes_huffman_codes[dist_deflate_code]
      local dist_huffman_bitlen = dcodes_huffman_bitlens[dist_deflate_code]
      WriteBits(dist_huffman_code, dist_huffman_bitlen)

      if dist_deflate_code > 3 then -- dist code with extra bits
        dist_code_with_extra_count = dist_code_with_extra_count + 1
        local dist_extra_bits = dextra_bits[dist_code_with_extra_count]
        local dist_extra_bits_bitlen = (dist_deflate_code - dist_deflate_code %
                                         2) / 2 - 1
        WriteBits(dist_extra_bits, dist_extra_bits_bitlen)
      end
    end
  end
end

-- Get the size of fixed block without writing any bits into the writer.
-- @param lcodes literal/LZ77_length deflate codes
-- @param decodes LZ77 distance deflate codes
-- @return the bit length of the fixed block
local function GetFixedHuffmanBlockSize(lcodes, dcodes)
  local block_bitlen = 3
  local length_code_count = 0
  for i = 1, #lcodes do
    local code = lcodes[i]
    local huffman_bitlen = _fix_block_literal_huffman_bitlen[code]
    block_bitlen = block_bitlen + huffman_bitlen
    if code > 256 then -- Length code
      length_code_count = length_code_count + 1
      if code > 264 and code < 285 then -- Length code with extra bits
        local extra_bits_bitlen = _literal_deflate_code_to_extra_bitlen[code -
                                    256]
        block_bitlen = block_bitlen + extra_bits_bitlen
      end
      local dist_code = dcodes[length_code_count]
      block_bitlen = block_bitlen + 5

      if dist_code > 3 then -- dist code with extra bits
        local dist_extra_bits_bitlen = (dist_code - dist_code % 2) / 2 - 1
        block_bitlen = block_bitlen + dist_extra_bits_bitlen
      end
    end
  end
  return block_bitlen
end

-- Write fixed block.
-- @param lcodes literal/LZ77_length deflate codes
-- @param decodes LZ77 distance deflate codes
local function CompressFixedHuffmanBlock(WriteBits, is_last_block, lcodes,
                                         lextra_bits, dcodes, dextra_bits)
  WriteBits(is_last_block and 1 or 0, 1) -- Last block identifier
  WriteBits(1, 2) -- Fixed Huffman block identifier
  local length_code_count = 0
  local length_code_with_extra_count = 0
  local dist_code_with_extra_count = 0
  for i = 1, #lcodes do
    local deflate_code = lcodes[i]
    local huffman_code = _fix_block_literal_huffman_code[deflate_code]
    local huffman_bitlen = _fix_block_literal_huffman_bitlen[deflate_code]
    WriteBits(huffman_code, huffman_bitlen)
    if deflate_code > 256 then -- Length code
      length_code_count = length_code_count + 1
      if deflate_code > 264 and deflate_code < 285 then
        -- Length code with extra bits
        length_code_with_extra_count = length_code_with_extra_count + 1
        local extra_bits = lextra_bits[length_code_with_extra_count]
        local extra_bits_bitlen =
          _literal_deflate_code_to_extra_bitlen[deflate_code - 256]
        WriteBits(extra_bits, extra_bits_bitlen)
      end
      -- Write distance code
      local dist_code = dcodes[length_code_count]
      local dist_huffman_code = _fix_block_dist_huffman_code[dist_code]
      WriteBits(dist_huffman_code, 5)

      if dist_code > 3 then -- dist code with extra bits
        dist_code_with_extra_count = dist_code_with_extra_count + 1
        local dist_extra_bits = dextra_bits[dist_code_with_extra_count]
        local dist_extra_bits_bitlen = (dist_code - dist_code % 2) / 2 - 1
        WriteBits(dist_extra_bits, dist_extra_bits_bitlen)
      end
    end
  end
end

-- Get the size of store block without writing any bits into the writer.
-- @param block_start The start index of the origin input string
-- @param block_end The end index of the origin input string
-- @param Total bit lens had been written into the compressed result before,
-- because store block needs to shift to byte boundary.
-- @return the bit length of the fixed block
local function GetStoreBlockSize(block_start, block_end, total_bitlen)
  assert(block_end - block_start + 1 <= 65535)
  local block_bitlen = 3
  total_bitlen = total_bitlen + 3
  local padding_bitlen = (8 - total_bitlen % 8) % 8
  block_bitlen = block_bitlen + padding_bitlen
  block_bitlen = block_bitlen + 32
  block_bitlen = block_bitlen + (block_end - block_start + 1) * 8
  return block_bitlen
end

-- Write the store block.
-- @param ... lots of stuffs
-- @return nil
local function CompressStoreBlock(WriteBits, WriteString, is_last_block, str,
                                  block_start, block_end, total_bitlen)
  assert(block_end - block_start + 1 <= 65535)
  WriteBits(is_last_block and 1 or 0, 1) -- Last block identifer.
  WriteBits(0, 2) -- Store block identifier.
  total_bitlen = total_bitlen + 3
  local padding_bitlen = (8 - total_bitlen % 8) % 8
  if padding_bitlen > 0 then
    WriteBits(_pow2[padding_bitlen] - 1, padding_bitlen)
  end
  local size = block_end - block_start + 1
  WriteBits(size, 16)

  -- Write size's one's complement
  local comp = (255 - size % 256) + (255 - (size - size % 256) / 256) * 256
  WriteBits(comp, 16)

  WriteString(str:sub(block_start, block_end))
end

-- Do the deflate
-- Currently using a simple way to determine the block size
-- (This is why the compression ratio is little bit worse than zlib when
-- the input size is very large
-- The first block is 64KB, the following block is 32KB.
-- After each block, there is a memory cleanup operation.
-- This is not a fast operation, but it is needed to save memory usage, so
-- the memory usage does not grow unboundly. If the data size is less than
-- 64KB, then memory cleanup won't happen.
-- This function determines whether to use store/fixed/dynamic blocks by
-- calculating the block size of each block type and chooses the smallest one.
local function Deflate(configs, WriteBits, WriteString, FlushWriter, str,
                       dictionary)
  local string_table = {}
  local hash_tables = {}
  local is_last_block = nil
  local block_start
  local block_end
  local bitlen_written
  local total_bitlen = FlushWriter(_FLUSH_MODE_NO_FLUSH)
  local strlen = #str
  local offset

  local level
  local strategy
  if configs then
    if configs.level then level = configs.level end
    if configs.strategy then strategy = configs.strategy end
  end

  if not level then
    if strlen < 2048 then
      level = 7
    elseif strlen > 65536 then
      level = 3
    else
      level = 5
    end
  end

  while not is_last_block do
    if not block_start then
      block_start = 1
      block_end = 64 * 1024 - 1
      offset = 0
    else
      block_start = block_end + 1
      block_end = block_end + 32 * 1024
      offset = block_start - 32 * 1024 - 1
    end

    if block_end >= strlen then
      block_end = strlen
      is_last_block = true
    else
      is_last_block = false
    end

    local lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits, dcodes_counts

    local HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens,
          rle_codes_huffman_codes, rle_deflate_codes, rle_extra_bits,
          lcodes_huffman_bitlens, lcodes_huffman_codes, dcodes_huffman_bitlens,
          dcodes_huffman_codes

    local dynamic_block_bitlen
    local fixed_block_bitlen
    local store_block_bitlen

    if level ~= 0 then

      -- GetBlockLZ77 needs block_start to block_end+3 to be loaded.
      LoadStringToTable(str, string_table, block_start, block_end + 3, offset)
      if block_start == 1 and dictionary then
        local dict_string_table = dictionary.string_table
        local dict_strlen = dictionary.strlen
        for i = 0, (-dict_strlen + 1) < -257 and -257 or (-dict_strlen + 1), -1 do
          string_table[i] = dict_string_table[dict_strlen + i]
        end
      end

      if strategy == "huffman_only" then
        lcodes = {}
        LoadStringToTable(str, lcodes, block_start, block_end, block_start - 1)
        lextra_bits = {}
        lcodes_counts = {}
        lcodes[block_end - block_start + 2] = 256 -- end of block
        for i = 1, block_end - block_start + 2 do
          local code = lcodes[i]
          lcodes_counts[code] = (lcodes_counts[code] or 0) + 1
        end
        dcodes = {}
        dextra_bits = {}
        dcodes_counts = {}
      else
        lcodes, lextra_bits, lcodes_counts, dcodes, dextra_bits, dcodes_counts =
          GetBlockLZ77Result(level, string_table, hash_tables, block_start,
                             block_end, offset, dictionary)
      end

      -- LuaFormatter off
      HLIT, HDIST, HCLEN, rle_codes_huffman_bitlens, rle_codes_huffman_codes, rle_deflate_codes,
       rle_extra_bits, lcodes_huffman_bitlens, lcodes_huffman_codes, dcodes_huffman_bitlens, dcodes_huffman_codes =
      -- LuaFormatter on
      GetBlockDynamicHuffmanHeader(lcodes_counts, dcodes_counts)
      dynamic_block_bitlen = GetDynamicHuffmanBlockSize(lcodes, dcodes, HCLEN,
                                                        rle_codes_huffman_bitlens,
                                                        rle_deflate_codes,
                                                        lcodes_huffman_bitlens,
                                                        dcodes_huffman_bitlens)
      fixed_block_bitlen = GetFixedHuffmanBlockSize(lcodes, dcodes)
    end

    store_block_bitlen = GetStoreBlockSize(block_start, block_end, total_bitlen)

    local min_bitlen = store_block_bitlen
    min_bitlen = (fixed_block_bitlen and fixed_block_bitlen < min_bitlen) and
                   fixed_block_bitlen or min_bitlen
    min_bitlen =
      (dynamic_block_bitlen and dynamic_block_bitlen < min_bitlen) and
        dynamic_block_bitlen or min_bitlen

    if level == 0 or
      (strategy ~= "fixed" and strategy ~= "dynamic" and store_block_bitlen ==
        min_bitlen) then
      CompressStoreBlock(WriteBits, WriteString, is_last_block, str,
                         block_start, block_end, total_bitlen)
      total_bitlen = total_bitlen + store_block_bitlen
    elseif strategy ~= "dynamic" and
      (strategy == "fixed" or fixed_block_bitlen == min_bitlen) then
      CompressFixedHuffmanBlock(WriteBits, is_last_block, lcodes, lextra_bits,
                                dcodes, dextra_bits)
      total_bitlen = total_bitlen + fixed_block_bitlen
    elseif strategy == "dynamic" or dynamic_block_bitlen == min_bitlen then
      CompressDynamicHuffmanBlock(WriteBits, is_last_block, lcodes, lextra_bits,
                                  dcodes, dextra_bits, HLIT, HDIST, HCLEN,
                                  rle_codes_huffman_bitlens,
                                  rle_codes_huffman_codes, rle_deflate_codes,
                                  rle_extra_bits, lcodes_huffman_bitlens,
                                  lcodes_huffman_codes, dcodes_huffman_bitlens,
                                  dcodes_huffman_codes)
      total_bitlen = total_bitlen + dynamic_block_bitlen
    end

    if is_last_block then
      bitlen_written = FlushWriter(_FLUSH_MODE_NO_FLUSH)
    else
      bitlen_written = FlushWriter(_FLUSH_MODE_MEMORY_CLEANUP)
    end

    assert(bitlen_written == total_bitlen)

    -- Memory clean up, so memory consumption does not always grow linearly
    -- , even if input string is > 64K.
    -- Not a very efficient operation, but this operation won't happen
    -- when the input data size is less than 64K.
    if not is_last_block then
      local j
      if dictionary and block_start == 1 then
        j = 0
        while (string_table[j]) do
          string_table[j] = nil
          j = j - 1
        end
      end
      dictionary = nil
      j = 1
      for i = block_end - 32767, block_end do
        string_table[j] = string_table[i - offset]
        j = j + 1
      end

      for k, t in pairs(hash_tables) do
        local tSize = #t
        if tSize > 0 and block_end + 1 - t[1] > 32768 then
          if tSize == 1 then
            hash_tables[k] = nil
          else
            local new = {}
            local newSize = 0
            for i = 2, tSize do
              j = t[i]
              if block_end + 1 - j <= 32768 then
                newSize = newSize + 1
                new[newSize] = j
              end
            end
            hash_tables[k] = new
          end
        end
      end
    end
  end
end

--- The description to compression configuration table. <br>
-- Any field can be nil to use its default. <br>
-- Table with keys other than those below is an invalid table.
-- @class table
-- @name compression_configs
-- @field level The compression level ranged from 0 to 9. 0 is no compression.
-- 9 is the slowest but best compression. Use nil for default level.
-- @field strategy The compression strategy. "fixed" to only use fixed deflate
-- compression block. "dynamic" to only use dynamic block. "huffman_only" to
-- do no LZ77 compression. Only do huffman compression.

-- @see LibDeflate:CompressDeflate(str, configs)
-- @see LibDeflate:CompressDeflateWithDict(str, dictionary, configs)
local function CompressDeflateInternal(str, dictionary, configs)
  local WriteBits, WriteString, FlushWriter = CreateWriter()
  Deflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)
  local total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)
  local padding_bitlen = (8 - total_bitlen % 8) % 8
  return result, padding_bitlen
end

-- @see LibDeflate:CompressZlib
-- @see LibDeflate:CompressZlibWithDict
local function CompressZlibInternal(str, dictionary, configs)
  local WriteBits, WriteString, FlushWriter = CreateWriter()

  local CM = 8 -- Compression method
  local CINFO = 7 -- Window Size = 32K
  local CMF = CINFO * 16 + CM
  WriteBits(CMF, 8)

  local FDIST = dictionary and 1 or 0
  local FLEVEL = 2 -- Default compression
  local FLG = FLEVEL * 64 + FDIST * 32
  local FCHECK = (31 - (CMF * 256 + FLG) % 31)
  -- The FCHECK value must be such that CMF and FLG,
  -- when viewed as a 16-bit unsigned integer stored
  -- in MSB order (CMF*256 + FLG), is a multiple of 31.
  FLG = FLG + FCHECK
  WriteBits(FLG, 8)

  if FDIST == 1 then
    local adler32 = dictionary.adler32
    local byte0 = adler32 % 256
    adler32 = (adler32 - byte0) / 256
    local byte1 = adler32 % 256
    adler32 = (adler32 - byte1) / 256
    local byte2 = adler32 % 256
    adler32 = (adler32 - byte2) / 256
    local byte3 = adler32 % 256
    WriteBits(byte3, 8)
    WriteBits(byte2, 8)
    WriteBits(byte1, 8)
    WriteBits(byte0, 8)
  end

  Deflate(configs, WriteBits, WriteString, FlushWriter, str, dictionary)
  FlushWriter(_FLUSH_MODE_BYTE_BOUNDARY)

  local adler32 = LibDeflate:Adler32(str)

  -- Most significant byte first
  local byte3 = adler32 % 256
  adler32 = (adler32 - byte3) / 256
  local byte2 = adler32 % 256
  adler32 = (adler32 - byte2) / 256
  local byte1 = adler32 % 256
  adler32 = (adler32 - byte1) / 256
  local byte0 = adler32 % 256

  WriteBits(byte0, 8)
  WriteBits(byte1, 8)
  WriteBits(byte2, 8)
  WriteBits(byte3, 8)
  local total_bitlen, result = FlushWriter(_FLUSH_MODE_OUTPUT)
  local padding_bitlen = (8 - total_bitlen % 8) % 8
  return result, padding_bitlen
end

--- Compress using the raw deflate format.
-- @param str [string] The data to be compressed.
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- 0 <= bits < 8  <br>
-- This means the most significant "bits" of the last byte of the returned
-- compressed data are padding bits and they don't affect decompression.
-- You don't need to use this value unless you want to do some postprocessing
-- to the compressed data.
-- @see compression_configs
-- @see LibDeflate:DecompressDeflate
function LibDeflate:CompressDeflate(str, configs)
  local arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)
  if not arg_valid then
    error(("Usage: LibDeflate:CompressDeflate(str, configs): " .. arg_err), 2)
  end
  return CompressDeflateInternal(str, nil, configs)
end

--- Compress using the raw deflate format with a preset dictionary.
-- @param str [string] The data to be compressed.
-- @param dictionary [table] The preset dictionary produced by
-- LibDeflate:CreateDictionary
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- 0 <= bits < 8  <br>
-- This means the most significant "bits" of the last byte of the returned
-- compressed data are padding bits and they don't affect decompression.
-- You don't need to use this value unless you want to do some postprocessing
-- to the compressed data.
-- @see compression_configs
-- @see LibDeflate:CreateDictionary
-- @see LibDeflate:DecompressDeflateWithDict
function LibDeflate:CompressDeflateWithDict(str, dictionary, configs)
  local arg_valid, arg_err = IsValidArguments(str, true, dictionary, true,
                                              configs)
  if not arg_valid then
    error(("Usage: LibDeflate:CompressDeflateWithDict" ..
            "(str, dictionary, configs): " .. arg_err), 2)
  end
  return CompressDeflateInternal(str, dictionary, configs)
end

--- Compress using the zlib format.
-- @param str [string] the data to be compressed.
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- Should always be 0.
-- Zlib formatted compressed data never has padding bits at the end.
-- @see compression_configs
-- @see LibDeflate:DecompressZlib
function LibDeflate:CompressZlib(str, configs)
  local arg_valid, arg_err = IsValidArguments(str, false, nil, true, configs)
  if not arg_valid then
    error(("Usage: LibDeflate:CompressZlib(str, configs): " .. arg_err), 2)
  end
  return CompressZlibInternal(str, nil, configs)
end

--- Compress using the zlib format with a preset dictionary.
-- @param str [string] the data to be compressed.
-- @param dictionary [table] A preset dictionary produced
-- by LibDeflate:CreateDictionary()
-- @param configs [table/nil] The configuration table to control the compression
-- . If nil, use the default configuration.
-- @return [string] The compressed data.
-- @return [integer] The number of bits padded at the end of output.
-- Should always be 0.
-- Zlib formatted compressed data never has padding bits at the end.
-- @see compression_configs
-- @see LibDeflate:CreateDictionary
-- @see LibDeflate:DecompressZlibWithDict
function LibDeflate:CompressZlibWithDict(str, dictionary, configs)
  local arg_valid, arg_err = IsValidArguments(str, true, dictionary, true,
                                              configs)
  if not arg_valid then
    error(("Usage: LibDeflate:CompressZlibWithDict" ..
            "(str, dictionary, configs): " .. arg_err), 2)
  end
  return CompressZlibInternal(str, dictionary, configs)
end

--[[ --------------------------------------------------------------------------
	Decompress code
--]] --------------------------------------------------------------------------

--[[
	Create a reader to easily reader stuffs as the unit of bits.
	Return values:
	1. ReadBits(bitlen)
	2. ReadBytes(bytelen, buffer, buffer_size)
	3. Decode(huffman_bitlen_count, huffman_symbol, min_bitlen)
	4. ReaderBitlenLeft()
	5. SkipToByteBoundary()
--]]
local function CreateReader(input_string)
  local input = input_string
  local input_strlen = #input_string
  local input_next_byte_pos = 1
  local cache_bitlen = 0
  local cache = 0

  -- Read some bits.
  -- To improve speed, this function does not
  -- check if the input has been exhausted.
  -- Use ReaderBitlenLeft() < 0 to check it.
  -- @param bitlen the number of bits to read
  -- @return the data is read.
  local function ReadBits(bitlen)
    local rshift_mask = _pow2[bitlen]
    local code
    if bitlen <= cache_bitlen then
      code = cache % rshift_mask
      cache = (cache - code) / rshift_mask
      cache_bitlen = cache_bitlen - bitlen
    else -- Whether input has been exhausted is not checked.
      local lshift_mask = _pow2[cache_bitlen]
      local byte1, byte2, byte3, byte4 =
        string_byte(input, input_next_byte_pos, input_next_byte_pos + 3)
      -- This requires lua number to be at least double ()
      cache = cache +
                ((byte1 or 0) + (byte2 or 0) * 256 + (byte3 or 0) * 65536 +
                  (byte4 or 0) * 16777216) * lshift_mask
      input_next_byte_pos = input_next_byte_pos + 4
      cache_bitlen = cache_bitlen + 32 - bitlen
      code = cache % rshift_mask
      cache = (cache - code) / rshift_mask
    end
    return code
  end

  -- Read some bytes from the reader.
  -- Assume reader is on the byte boundary.
  -- @param bytelen The number of bytes to be read.
  -- @param buffer The byte read will be stored into this buffer.
  -- @param buffer_size The buffer will be modified starting from
  --	buffer[buffer_size+1], ending at buffer[buffer_size+bytelen-1]
  -- @return the new buffer_size
  local function ReadBytes(bytelen, buffer, buffer_size)
    assert(cache_bitlen % 8 == 0)

    local byte_from_cache =
      (cache_bitlen / 8 < bytelen) and (cache_bitlen / 8) or bytelen
    for _ = 1, byte_from_cache do
      local byte = cache % 256
      buffer_size = buffer_size + 1
      buffer[buffer_size] = string_char(byte)
      cache = (cache - byte) / 256
    end
    cache_bitlen = cache_bitlen - byte_from_cache * 8
    bytelen = bytelen - byte_from_cache
    if (input_strlen - input_next_byte_pos - bytelen + 1) * 8 + cache_bitlen < 0 then
      return -1 -- out of input
    end
    for i = input_next_byte_pos, input_next_byte_pos + bytelen - 1 do
      buffer_size = buffer_size + 1
      buffer[buffer_size] = string_sub(input, i, i)
    end

    input_next_byte_pos = input_next_byte_pos + bytelen
    return buffer_size
  end

  -- Decode huffman code
  -- To improve speed, this function does not check
  -- if the input has been exhausted.
  -- Use ReaderBitlenLeft() < 0 to check it.
  -- Credits for Mark Adler. This code is from puff:Decode()
  -- @see puff:Decode(...)
  -- @param huffman_bitlen_count
  -- @param huffman_symbol
  -- @param min_bitlen The minimum huffman bit length of all symbols
  -- @return The decoded deflate code.
  --	Negative value is returned if decoding fails.
  local function Decode(huffman_bitlen_counts, huffman_symbols, min_bitlen)
    local code = 0
    local first = 0
    local index = 0
    local count
    if min_bitlen > 0 then
      if cache_bitlen < 15 and input then
        local lshift_mask = _pow2[cache_bitlen]
        local byte1, byte2, byte3, byte4 =
          string_byte(input, input_next_byte_pos, input_next_byte_pos + 3)
        -- This requires lua number to be at least double ()
        cache = cache +
                  ((byte1 or 0) + (byte2 or 0) * 256 + (byte3 or 0) * 65536 +
                    (byte4 or 0) * 16777216) * lshift_mask
        input_next_byte_pos = input_next_byte_pos + 4
        cache_bitlen = cache_bitlen + 32
      end

      local rshift_mask = _pow2[min_bitlen]
      cache_bitlen = cache_bitlen - min_bitlen
      code = cache % rshift_mask
      cache = (cache - code) / rshift_mask
      -- Reverse the bits
      code = _reverse_bits_tbl[min_bitlen][code]

      count = huffman_bitlen_counts[min_bitlen]
      if code < count then return huffman_symbols[code] end
      index = count
      first = count * 2
      code = code * 2
    end

    for bitlen = min_bitlen + 1, 15 do
      local bit
      bit = cache % 2
      cache = (cache - bit) / 2
      cache_bitlen = cache_bitlen - 1

      code = (bit == 1) and (code + 1 - code % 2) or code
      count = huffman_bitlen_counts[bitlen] or 0
      local diff = code - first
      if diff < count then return huffman_symbols[index + diff] end
      index = index + count
      first = first + count
      first = first * 2
      code = code * 2
    end
    -- invalid literal/length or distance code
    -- in fixed or dynamic block (run out of code)
    return -10
  end

  local function ReaderBitlenLeft()
    return (input_strlen - input_next_byte_pos + 1) * 8 + cache_bitlen
  end

  local function SkipToByteBoundary()
    local skipped_bitlen = cache_bitlen % 8
    local rshift_mask = _pow2[skipped_bitlen]
    cache_bitlen = cache_bitlen - skipped_bitlen
    cache = (cache - cache % rshift_mask) / rshift_mask
  end

  return ReadBits, ReadBytes, Decode, ReaderBitlenLeft, SkipToByteBoundary
end

-- Create a deflate state, so I can pass in less arguments to functions.
-- @param str the whole string to be decompressed.
-- @param dictionary The preset dictionary. nil if not provided.
--		This dictionary should be produced by LibDeflate:CreateDictionary(str)
-- @return The decomrpess state.
local function CreateDecompressState(str, dictionary)
  local ReadBits, ReadBytes, Decode, ReaderBitlenLeft, SkipToByteBoundary =
    CreateReader(str)
  local state = {
    ReadBits = ReadBits,
    ReadBytes = ReadBytes,
    Decode = Decode,
    ReaderBitlenLeft = ReaderBitlenLeft,
    SkipToByteBoundary = SkipToByteBoundary,
    buffer_size = 0,
    buffer = {},
    result_buffer = {},
    dictionary = dictionary
  }
  return state
end

-- Get the stuffs needed to decode huffman codes
-- @see puff.c:construct(...)
-- @param huffman_bitlen The huffman bit length of the huffman codes.
-- @param max_symbol The maximum symbol
-- @param max_bitlen The min huffman bit length of all codes
-- @return zero or positive for success, negative for failure.
-- @return The count of each huffman bit length.
-- @return A table to convert huffman codes to deflate codes.
-- @return The minimum huffman bit length.
local function GetHuffmanForDecode(huffman_bitlens, max_symbol, max_bitlen)
  local huffman_bitlen_counts = {}
  local min_bitlen = max_bitlen
  for symbol = 0, max_symbol do
    local bitlen = huffman_bitlens[symbol] or 0
    min_bitlen = (bitlen > 0 and bitlen < min_bitlen) and bitlen or min_bitlen
    huffman_bitlen_counts[bitlen] = (huffman_bitlen_counts[bitlen] or 0) + 1
  end

  if huffman_bitlen_counts[0] == max_symbol + 1 then -- No Codes
    return 0, huffman_bitlen_counts, {}, 0 -- Complete, but decode will fail
  end

  local left = 1
  for len = 1, max_bitlen do
    left = left * 2
    left = left - (huffman_bitlen_counts[len] or 0)
    if left < 0 then
      return left -- Over-subscribed, return negative
    end
  end

  -- Generate offsets info symbol table for each length for sorting
  local offsets = {}
  offsets[1] = 0
  for len = 1, max_bitlen - 1 do
    offsets[len + 1] = offsets[len] + (huffman_bitlen_counts[len] or 0)
  end

  local huffman_symbols = {}
  for symbol = 0, max_symbol do
    local bitlen = huffman_bitlens[symbol] or 0
    if bitlen ~= 0 then
      local offset = offsets[bitlen]
      huffman_symbols[offset] = symbol
      offsets[bitlen] = offsets[bitlen] + 1
    end
  end

  -- Return zero for complete set, positive for incomplete set.
  return left, huffman_bitlen_counts, huffman_symbols, min_bitlen
end

-- Decode a fixed or dynamic huffman blocks, excluding last block identifier
-- and block type identifer.
-- @see puff.c:codes()
-- @param state decompression state that will be modified by this function.
--	@see CreateDecompressState
-- @param ... Read the source code
-- @return 0 on success, other value on failure.
local function DecodeUntilEndOfBlock(state, lcodes_huffman_bitlens,
                                     lcodes_huffman_symbols,
                                     lcodes_huffman_min_bitlen,
                                     dcodes_huffman_bitlens,
                                     dcodes_huffman_symbols,
                                     dcodes_huffman_min_bitlen)
  local buffer, buffer_size, ReadBits, Decode, ReaderBitlenLeft, result_buffer =
    state.buffer, state.buffer_size, state.ReadBits, state.Decode,
    state.ReaderBitlenLeft, state.result_buffer
  local dictionary = state.dictionary
  local dict_string_table
  local dict_strlen

  local buffer_end = 1
  if dictionary and not buffer[0] then
    -- If there is a dictionary, copy the last 258 bytes into
    -- the string_table to make the copy in the main loop quicker.
    -- This is done only once per decompression.
    dict_string_table = dictionary.string_table
    dict_strlen = dictionary.strlen
    buffer_end = -dict_strlen + 1
    for i = 0, (-dict_strlen + 1) < -257 and -257 or (-dict_strlen + 1), -1 do
      buffer[i] = _byte_to_char[dict_string_table[dict_strlen + i]]
    end
  end

  repeat
    local symbol = Decode(lcodes_huffman_bitlens, lcodes_huffman_symbols,
                          lcodes_huffman_min_bitlen)
    if symbol < 0 or symbol > 285 then
      -- invalid literal/length or distance code in fixed or dynamic block
      return -10
    elseif symbol < 256 then -- Literal
      buffer_size = buffer_size + 1
      buffer[buffer_size] = _byte_to_char[symbol]
    elseif symbol > 256 then -- Length code
      symbol = symbol - 256
      local bitlen = _literal_deflate_code_to_base_len[symbol]
      bitlen = (symbol >= 8) and
                 (bitlen +
                   ReadBits(_literal_deflate_code_to_extra_bitlen[symbol])) or
                 bitlen
      symbol = Decode(dcodes_huffman_bitlens, dcodes_huffman_symbols,
                      dcodes_huffman_min_bitlen)
      if symbol < 0 or symbol > 29 then
        -- invalid literal/length or distance code in fixed or dynamic block
        return -10
      end
      local dist = _dist_deflate_code_to_base_dist[symbol]
      dist = (dist > 4) and
               (dist + ReadBits(_dist_deflate_code_to_extra_bitlen[symbol])) or
               dist

      local char_buffer_index = buffer_size - dist + 1
      if char_buffer_index < buffer_end then
        -- distance is too far back in fixed or dynamic block
        return -11
      end
      if char_buffer_index >= -257 then
        for _ = 1, bitlen do
          buffer_size = buffer_size + 1
          buffer[buffer_size] = buffer[char_buffer_index]
          char_buffer_index = char_buffer_index + 1
        end
      else
        char_buffer_index = dict_strlen + char_buffer_index
        for _ = 1, bitlen do
          buffer_size = buffer_size + 1
          buffer[buffer_size] =
            _byte_to_char[dict_string_table[char_buffer_index]]
          char_buffer_index = char_buffer_index + 1
        end
      end
    end

    if ReaderBitlenLeft() < 0 then
      return 2 -- available inflate data did not terminate
    end

    if buffer_size >= 65536 then
      result_buffer[#result_buffer + 1] = table_concat(buffer, "", 1, 32768)
      for i = 32769, buffer_size do buffer[i - 32768] = buffer[i] end
      buffer_size = buffer_size - 32768
      buffer[buffer_size + 1] = nil
      -- NOTE: buffer[32769..end] and buffer[-257..0] are not cleared.
      -- This is why "buffer_size" variable is needed.
    end
  until symbol == 256

  state.buffer_size = buffer_size

  return 0
end

-- Decompress a store block
-- @param state decompression state that will be modified by this function.
-- @return 0 if succeeds, other value if fails.
local function DecompressStoreBlock(state)
  local buffer, buffer_size, ReadBits, ReadBytes, ReaderBitlenLeft,
        SkipToByteBoundary, result_buffer = state.buffer, state.buffer_size,
                                            state.ReadBits, state.ReadBytes,
                                            state.ReaderBitlenLeft,
                                            state.SkipToByteBoundary,
                                            state.result_buffer

  SkipToByteBoundary()
  local bytelen = ReadBits(16)
  if ReaderBitlenLeft() < 0 then
    return 2 -- available inflate data did not terminate
  end
  local bytelenComp = ReadBits(16)
  if ReaderBitlenLeft() < 0 then
    return 2 -- available inflate data did not terminate
  end

  if bytelen % 256 + bytelenComp % 256 ~= 255 then
    return -2 -- Not one's complement
  end
  if (bytelen - bytelen % 256) / 256 + (bytelenComp - bytelenComp % 256) / 256 ~=
    255 then
    return -2 -- Not one's complement
  end

  -- Note that ReadBytes will skip to the next byte boundary first.
  buffer_size = ReadBytes(bytelen, buffer, buffer_size)
  if buffer_size < 0 then
    return 2 -- available inflate data did not terminate
  end

  -- memory clean up when there are enough bytes in the buffer.
  if buffer_size >= 65536 then
    result_buffer[#result_buffer + 1] = table_concat(buffer, "", 1, 32768)
    for i = 32769, buffer_size do buffer[i - 32768] = buffer[i] end
    buffer_size = buffer_size - 32768
    buffer[buffer_size + 1] = nil
  end
  state.buffer_size = buffer_size
  return 0
end

-- Decompress a fixed block
-- @param state decompression state that will be modified by this function.
-- @return 0 if succeeds other value if fails.
local function DecompressFixBlock(state)
  return DecodeUntilEndOfBlock(state, _fix_block_literal_huffman_bitlen_count,
                               _fix_block_literal_huffman_to_deflate_code, 7,
                               _fix_block_dist_huffman_bitlen_count,
                               _fix_block_dist_huffman_to_deflate_code, 5)
end

-- Decompress a dynamic block
-- @param state decompression state that will be modified by this function.
-- @return 0 if success, other value if fails.
local function DecompressDynamicBlock(state)
  local ReadBits, Decode = state.ReadBits, state.Decode
  local nlen = ReadBits(5) + 257
  local ndist = ReadBits(5) + 1
  local ncode = ReadBits(4) + 4
  if nlen > 286 or ndist > 30 then
    -- dynamic block code description: too many length or distance codes
    return -3
  end

  local rle_codes_huffman_bitlens = {}

  for i = 1, ncode do
    rle_codes_huffman_bitlens[_rle_codes_huffman_bitlen_order[i]] = ReadBits(3)
  end

  local rle_codes_err, rle_codes_huffman_bitlen_counts,
        rle_codes_huffman_symbols, rle_codes_huffman_min_bitlen =
    GetHuffmanForDecode(rle_codes_huffman_bitlens, 18, 7)
  if rle_codes_err ~= 0 then -- Require complete code set here
    -- dynamic block code description: code lengths codes incomplete
    return -4
  end

  local lcodes_huffman_bitlens = {}
  local dcodes_huffman_bitlens = {}
  -- Read length/literal and distance code length tables
  local index = 0
  while index < nlen + ndist do
    local symbol -- Decoded value
    local bitlen -- Last length to repeat

    symbol = Decode(rle_codes_huffman_bitlen_counts, rle_codes_huffman_symbols,
                    rle_codes_huffman_min_bitlen)

    if symbol < 0 then
      return symbol -- Invalid symbol
    elseif symbol < 16 then
      if index < nlen then
        lcodes_huffman_bitlens[index] = symbol
      else
        dcodes_huffman_bitlens[index - nlen] = symbol
      end
      index = index + 1
    else
      bitlen = 0
      if symbol == 16 then
        if index == 0 then
          -- dynamic block code description: repeat lengths
          -- with no first length
          return -5
        end
        if index - 1 < nlen then
          bitlen = lcodes_huffman_bitlens[index - 1]
        else
          bitlen = dcodes_huffman_bitlens[index - nlen - 1]
        end
        symbol = 3 + ReadBits(2)
      elseif symbol == 17 then -- Repeat zero 3..10 times
        symbol = 3 + ReadBits(3)
      else -- == 18, repeat zero 11.138 times
        symbol = 11 + ReadBits(7)
      end
      if index + symbol > nlen + ndist then
        -- dynamic block code description:
        -- repeat more than specified lengths
        return -6
      end
      while symbol > 0 do -- Repeat last or zero symbol times
        symbol = symbol - 1
        if index < nlen then
          lcodes_huffman_bitlens[index] = bitlen
        else
          dcodes_huffman_bitlens[index - nlen] = bitlen
        end
        index = index + 1
      end
    end
  end

  if (lcodes_huffman_bitlens[256] or 0) == 0 then
    -- dynamic block code description: missing end-of-block code
    return -9
  end

  local lcodes_err, lcodes_huffman_bitlen_counts, lcodes_huffman_symbols,
        lcodes_huffman_min_bitlen = GetHuffmanForDecode(lcodes_huffman_bitlens,
                                                        nlen - 1, 15)
  -- dynamic block code description: invalid literal/length code lengths,
  -- Incomplete code ok only for single length 1 code
  if (lcodes_err ~= 0 and
    (lcodes_err < 0 or nlen ~= (lcodes_huffman_bitlen_counts[0] or 0) +
      (lcodes_huffman_bitlen_counts[1] or 0))) then return -7 end

  local dcodes_err, dcodes_huffman_bitlen_counts, dcodes_huffman_symbols,
        dcodes_huffman_min_bitlen = GetHuffmanForDecode(dcodes_huffman_bitlens,
                                                        ndist - 1, 15)
  -- dynamic block code description: invalid distance code lengths,
  -- Incomplete code ok only for single length 1 code
  if (dcodes_err ~= 0 and
    (dcodes_err < 0 or ndist ~= (dcodes_huffman_bitlen_counts[0] or 0) +
      (dcodes_huffman_bitlen_counts[1] or 0))) then return -8 end

  -- Build buffman table for literal/length codes
  return DecodeUntilEndOfBlock(state, lcodes_huffman_bitlen_counts,
                               lcodes_huffman_symbols,
                               lcodes_huffman_min_bitlen,
                               dcodes_huffman_bitlen_counts,
                               dcodes_huffman_symbols, dcodes_huffman_min_bitlen)
end

-- Decompress a deflate stream
-- @param state: a decompression state
-- @return the decompressed string if succeeds. nil if fails.
local function Inflate(state)
  local ReadBits = state.ReadBits

  local is_last_block
  while not is_last_block do
    is_last_block = (ReadBits(1) == 1)
    local block_type = ReadBits(2)
    local status
    if block_type == 0 then
      status = DecompressStoreBlock(state)
    elseif block_type == 1 then
      status = DecompressFixBlock(state)
    elseif block_type == 2 then
      status = DecompressDynamicBlock(state)
    else
      return nil, -1 -- invalid block type (type == 3)
    end
    if status ~= 0 then return nil, status end
  end

  state.result_buffer[#state.result_buffer + 1] =
    table_concat(state.buffer, "", 1, state.buffer_size)
  local result = table_concat(state.result_buffer)
  return result
end

-- @see LibDeflate:DecompressDeflate(str)
-- @see LibDeflate:DecompressDeflateWithDict(str, dictionary)
local function DecompressDeflateInternal(str, dictionary)
  local state = CreateDecompressState(str, dictionary)
  local result, status = Inflate(state)
  if not result then return nil, status end

  local bitlen_left = state.ReaderBitlenLeft()
  local bytelen_left = (bitlen_left - bitlen_left % 8) / 8
  return result, bytelen_left
end

-- @see LibDeflate:DecompressZlib(str)
-- @see LibDeflate:DecompressZlibWithDict(str)
local function DecompressZlibInternal(str, dictionary)
  local state = CreateDecompressState(str, dictionary)
  local ReadBits = state.ReadBits

  local CMF = ReadBits(8)
  if state.ReaderBitlenLeft() < 0 then
    return nil, 2 -- available inflate data did not terminate
  end
  local CM = CMF % 16
  local CINFO = (CMF - CM) / 16
  if CM ~= 8 then
    return nil, -12 -- invalid compression method
  end
  if CINFO > 7 then
    return nil, -13 -- invalid window size
  end

  local FLG = ReadBits(8)
  if state.ReaderBitlenLeft() < 0 then
    return nil, 2 -- available inflate data did not terminate
  end
  if (CMF * 256 + FLG) % 31 ~= 0 then
    return nil, -14 -- invalid header checksum
  end

  local FDIST = ((FLG - FLG % 32) / 32 % 2)
  local FLEVEL = ((FLG - FLG % 64) / 64 % 4) -- luacheck: ignore FLEVEL

  if FDIST == 1 then
    if not dictionary then
      return nil, -16 -- need dictonary, but dictionary is not provided.
    end
    local byte3 = ReadBits(8)
    local byte2 = ReadBits(8)
    local byte1 = ReadBits(8)
    local byte0 = ReadBits(8)
    local actual_adler32 = byte3 * 16777216 + byte2 * 65536 + byte1 * 256 +
                             byte0
    if state.ReaderBitlenLeft() < 0 then
      return nil, 2 -- available inflate data did not terminate
    end
    if not IsEqualAdler32(actual_adler32, dictionary.adler32) then
      return nil, -17 -- dictionary adler32 does not match
    end
  end
  local result, status = Inflate(state)
  if not result then return nil, status end
  state.SkipToByteBoundary()

  local adler_byte0 = ReadBits(8)
  local adler_byte1 = ReadBits(8)
  local adler_byte2 = ReadBits(8)
  local adler_byte3 = ReadBits(8)
  if state.ReaderBitlenLeft() < 0 then
    return nil, 2 -- available inflate data did not terminate
  end

  local adler32_expected = adler_byte0 * 16777216 + adler_byte1 * 65536 +
                             adler_byte2 * 256 + adler_byte3
  local adler32_actual = LibDeflate:Adler32(result)
  if not IsEqualAdler32(adler32_expected, adler32_actual) then
    return nil, -15 -- Adler32 checksum does not match
  end

  local bitlen_left = state.ReaderBitlenLeft()
  local bytelen_left = (bitlen_left - bitlen_left % 8) / 8
  return result, bytelen_left
end

--- Decompress a raw deflate compressed data.
-- @param str [string] The data to be decompressed.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressDeflate
function LibDeflate:DecompressDeflate(str)
  local arg_valid, arg_err = IsValidArguments(str)
  if not arg_valid then
    error(("Usage: LibDeflate:DecompressDeflate(str): " .. arg_err), 2)
  end
  return DecompressDeflateInternal(str)
end

--- Decompress a raw deflate compressed data with a preset dictionary.
-- @param str [string] The data to be decompressed.
-- @param dictionary [table] The preset dictionary used by
-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.
-- Decompression and compression must use the same dictionary.
-- Otherwise wrong decompressed data could be produced without generating any
-- error.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressDeflateWithDict
function LibDeflate:DecompressDeflateWithDict(str, dictionary)
  local arg_valid, arg_err = IsValidArguments(str, true, dictionary)
  if not arg_valid then
    error(("Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): " ..
            arg_err), 2)
  end
  return DecompressDeflateInternal(str, dictionary)
end

--- Decompress a zlib compressed data.
-- @param str [string] The data to be decompressed
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressZlib
function LibDeflate:DecompressZlib(str)
  local arg_valid, arg_err = IsValidArguments(str)
  if not arg_valid then
    error(("Usage: LibDeflate:DecompressZlib(str): " .. arg_err), 2)
  end
  return DecompressZlibInternal(str)
end

--- Decompress a zlib compressed data with a preset dictionary.
-- @param str [string] The data to be decompressed
-- @param dictionary [table] The preset dictionary used by
-- LibDeflate:CompressDeflateWithDict when the compressed data is produced.
-- Decompression and compression must use the same dictionary.
-- Otherwise wrong decompressed data could be produced without generating any
-- error.
-- @return [string/nil] If the decompression succeeds, return the decompressed
-- data. If the decompression fails, return nil. You should check if this return
-- value is non-nil to know if the decompression succeeds.
-- @return [integer] If the decompression succeeds, return the number of
-- unprocessed bytes in the input compressed data. This return value is a
-- positive integer if the input data is a valid compressed data appended by an
-- arbitary non-empty string. This return value is 0 if the input data does not
-- contain any extra bytes.<br>
-- If the decompression fails (The first return value of this function is nil),
-- this return value is undefined.
-- @see LibDeflate:CompressZlibWithDict
function LibDeflate:DecompressZlibWithDict(str, dictionary)
  local arg_valid, arg_err = IsValidArguments(str, true, dictionary)
  if not arg_valid then
    error(("Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): " ..
            arg_err), 2)
  end
  return DecompressZlibInternal(str, dictionary)
end

-- Calculate the huffman code of fixed block
do
  _fix_block_literal_huffman_bitlen = {}
  for sym = 0, 143 do _fix_block_literal_huffman_bitlen[sym] = 8 end
  for sym = 144, 255 do _fix_block_literal_huffman_bitlen[sym] = 9 end
  for sym = 256, 279 do _fix_block_literal_huffman_bitlen[sym] = 7 end
  for sym = 280, 287 do _fix_block_literal_huffman_bitlen[sym] = 8 end

  _fix_block_dist_huffman_bitlen = {}
  for dist = 0, 31 do _fix_block_dist_huffman_bitlen[dist] = 5 end
  local status
  status, _fix_block_literal_huffman_bitlen_count, _fix_block_literal_huffman_to_deflate_code =
    GetHuffmanForDecode(_fix_block_literal_huffman_bitlen, 287, 9)
  assert(status == 0)
  status, _fix_block_dist_huffman_bitlen_count, _fix_block_dist_huffman_to_deflate_code =
    GetHuffmanForDecode(_fix_block_dist_huffman_bitlen, 31, 5)
  assert(status == 0)

  _fix_block_literal_huffman_code = GetHuffmanCodeFromBitlen(
                                      _fix_block_literal_huffman_bitlen_count,
                                      _fix_block_literal_huffman_bitlen, 287, 9)
  _fix_block_dist_huffman_code = GetHuffmanCodeFromBitlen(
                                   _fix_block_dist_huffman_bitlen_count,
                                   _fix_block_dist_huffman_bitlen, 31, 5)
end

-- Prefix encoding algorithm
-- Credits to LibCompress.
-- The code has been rewritten by the author of LibDeflate.
------------------------------------------------------------------------------

-- to be able to match any requested byte value, the search
-- string must be preprocessed characters to escape with %:
-- ( ) . % + - * ? [ ] ^ $
-- "illegal" byte values:
-- 0 is replaces %z
local _gsub_escape_table = {
  ["\000"] = "%z",
  ["("] = "%(",
  [")"] = "%)",
  ["."] = "%.",
  ["%"] = "%%",
  ["+"] = "%+",
  ["-"] = "%-",
  ["*"] = "%*",
  ["?"] = "%?",
  ["["] = "%[",
  ["]"] = "%]",
  ["^"] = "%^",
  ["$"] = "%$"
}

local function escape_for_gsub(str)
  return str:gsub("([%z%(%)%.%%%+%-%*%?%[%]%^%$])", _gsub_escape_table)
end

--- Create a custom codec with encoder and decoder. <br>
-- This codec is used to convert an input string to make it not contain
-- some specific bytes.
-- This created codec and the parameters of this function do NOT take
-- localization into account. One byte (0-255) in the string is exactly one
-- character (0-255).
-- Credits to LibCompress.
-- The code has been rewritten by the author of LibDeflate. <br>
-- @param reserved_chars [string] The created encoder will ensure encoded
-- data does not contain any single character in reserved_chars. This parameter
-- should be non-empty.
-- @param escape_chars [string] The escape character(s) used in the created
-- codec. The codec converts any character included in reserved\_chars /
-- escape\_chars / map\_chars to (one escape char + one character not in
-- reserved\_chars / escape\_chars / map\_chars).
-- You usually only need to provide a length-1 string for this parameter.
-- Length-2 string is only needed when
-- reserved\_chars + escape\_chars + map\_chars is longer than 127.
-- This parameter should be non-empty.
-- @param map_chars [string] The created encoder will map every
-- reserved\_chars:sub(i, i) (1 <= i <= #map\_chars) to map\_chars:sub(i, i).
-- This parameter CAN be empty string.
-- @return [table/nil] If the codec cannot be created, return nil.<br>
-- If the codec can be created according to the given
-- parameters, return the codec, which is a encode/decode table.
-- The table contains two functions: <br>
-- t:Encode(str) returns the encoded string. <br>
-- t:Decode(str) returns the decoded string if succeeds. nil if fails.
-- @return [nil/string] If the codec is successfully created, return nil.
-- If not, return a string that describes the reason why the codec cannot be
-- created.
-- @usage
-- -- Create an encoder/decoder that maps all "\000" to "\003",
-- -- and escape "\001" (and "\002" and "\003") properly
-- local codec = LibDeflate:CreateCodec("\000\001", "\002", "\003")
--
-- local encoded = codec:Encode(SOME_STRING)
-- -- "encoded" does not contain "\000" or "\001"
-- local decoded = codec:Decode(encoded)
-- -- assert(decoded == SOME_STRING)
function LibDeflate:CreateCodec(reserved_chars, escape_chars, map_chars)
  if type(reserved_chars) ~= "string" or type(escape_chars) ~= "string" or
    type(map_chars) ~= "string" then
    error("Usage: LibDeflate:CreateCodec(reserved_chars," ..
            " escape_chars, map_chars):" .. " All arguments must be string.", 2)
  end

  if escape_chars == "" then return nil, "No escape characters supplied." end
  if #reserved_chars < #map_chars then
    return nil, "The number of reserved characters must be" ..
             " at least as many as the number of mapped chars."
  end
  if reserved_chars == "" then return nil, "No characters to encode." end

  local encode_bytes = reserved_chars .. escape_chars .. map_chars
  -- build list of bytes not available as a suffix to a prefix byte
  local taken = {}
  for i = 1, #encode_bytes do
    local byte = string_byte(encode_bytes, i, i)
    if taken[byte] then
      return nil, "There must be no duplicate characters in the" ..
               " concatenation of reserved_chars, escape_chars and" ..
               " map_chars."
    end
    taken[byte] = true
  end

  local decode_patterns = {}
  local decode_repls = {}

  -- the encoding can be a single gsub
  -- , but the decoding can require multiple gsubs
  local encode_search = {}
  local encode_translate = {}

  -- map single byte to single byte
  if #map_chars > 0 then
    local decode_search = {}
    local decode_translate = {}
    for i = 1, #map_chars do
      local from = string_sub(reserved_chars, i, i)
      local to = string_sub(map_chars, i, i)
      encode_translate[from] = to
      encode_search[#encode_search + 1] = from
      decode_translate[to] = from
      decode_search[#decode_search + 1] = to
    end
    decode_patterns[#decode_patterns + 1] =
      "([" .. escape_for_gsub(table_concat(decode_search)) .. "])"
    decode_repls[#decode_repls + 1] = decode_translate
  end

  local escape_char_index = 1
  local escape_char = string_sub(escape_chars, escape_char_index,
                                 escape_char_index)
  -- map single byte to double-byte
  local r = 0 -- suffix char value to the escapeChar

  local decode_search = {}
  local decode_translate = {}
  for i = 1, #encode_bytes do
    local c = string_sub(encode_bytes, i, i)
    if not encode_translate[c] then
      while r >= 256 or taken[r] do
        r = r + 1
        if r > 255 then -- switch to next escapeChar
          decode_patterns[#decode_patterns + 1] =
            escape_for_gsub(escape_char) .. "([" ..
              escape_for_gsub(table_concat(decode_search)) .. "])"
          decode_repls[#decode_repls + 1] = decode_translate

          escape_char_index = escape_char_index + 1
          escape_char = string_sub(escape_chars, escape_char_index,
                                   escape_char_index)
          r = 0
          decode_search = {}
          decode_translate = {}

          if not escape_char or escape_char == "" then
            -- actually I don't need to check
            -- "not ecape_char", but what if Lua changes
            -- the behavior of string.sub() in the future?
            -- we are out of escape chars and we need more!
            return nil, "Out of escape characters."
          end
        end
      end

      local char_r = _byte_to_char[r]
      encode_translate[c] = escape_char .. char_r
      encode_search[#encode_search + 1] = c
      decode_translate[char_r] = c
      decode_search[#decode_search + 1] = char_r
      r = r + 1
    end
    if i == #encode_bytes then
      decode_patterns[#decode_patterns + 1] =
        escape_for_gsub(escape_char) .. "([" ..
          escape_for_gsub(table_concat(decode_search)) .. "])"
      decode_repls[#decode_repls + 1] = decode_translate
    end
  end

  local codec = {}

  local encode_pattern = "([" .. escape_for_gsub(table_concat(encode_search)) ..
                           "])"
  local encode_repl = encode_translate

  function codec:Encode(str)
    if type(str) ~= "string" then
      error(
        ("Usage: codec:Encode(str):" .. " 'str' - string expected got '%s'."):format(
          type(str)), 2)
    end
    return string_gsub(str, encode_pattern, encode_repl)
  end

  local decode_tblsize = #decode_patterns
  local decode_fail_pattern = "([" .. escape_for_gsub(reserved_chars) .. "])"

  function codec:Decode(str)
    if type(str) ~= "string" then
      error(
        ("Usage: codec:Decode(str):" .. " 'str' - string expected got '%s'."):format(
          type(str)), 2)
    end
    if string_find(str, decode_fail_pattern) then return nil end
    for i = 1, decode_tblsize do
      str = string_gsub(str, decode_patterns[i], decode_repls[i])
    end
    return str
  end

  return codec
end

local _addon_channel_codec

local function GenerateWoWAddonChannelCodec()
  return LibDeflate:CreateCodec("\000", "\001", "")
end

--- Encode the string to make it ready to be transmitted in World of
-- Warcraft addon channel. <br>
-- The encoded string is guaranteed to contain no NULL ("\000") character.
-- @param str [string] The string to be encoded.
-- @return The encoded string.
-- @see LibDeflate:DecodeForWoWAddonChannel
function LibDeflate:EncodeForWoWAddonChannel(str)
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:EncodeForWoWAddonChannel(str):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  if not _addon_channel_codec then
    _addon_channel_codec = GenerateWoWAddonChannelCodec()
  end
  return _addon_channel_codec:Encode(str)
end

--- Decode the string produced by LibDeflate:EncodeForWoWAddonChannel
-- @param str [string] The string to be decoded.
-- @return [string/nil] The decoded string if succeeds. nil if fails.
-- @see LibDeflate:EncodeForWoWAddonChannel
function LibDeflate:DecodeForWoWAddonChannel(str)
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:DecodeForWoWAddonChannel(str):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  if not _addon_channel_codec then
    _addon_channel_codec = GenerateWoWAddonChannelCodec()
  end
  return _addon_channel_codec:Decode(str)
end

-- For World of Warcraft Chat Channel Encoding
-- Credits to LibCompress.
-- The code has been rewritten by the author of LibDeflate. <br>
-- Following byte values are not allowed:
-- \000, s, S, \010, \013, \124, %
-- Because SendChatMessage will error
-- if an UTF8 multibyte character is incomplete,
-- all character values above 127 have to be encoded to avoid this.
-- This costs quite a bit of bandwidth (about 13-14%)
-- Also, because drunken status is unknown for the received
-- , strings used with SendChatMessage should be terminated with
-- an identifying byte value, after which the server MAY add "...hic!"
-- or as much as it can fit(!).
-- Pass the identifying byte as a reserved character to this function
-- to ensure the encoding doesn't contain that value.
-- or use this: local message, match = arg1:gsub("^(.*)\029.-$", "%1")
-- arg1 is message from channel, \029 is the string terminator
-- , but may be used in the encoded datastream as well. :-)
-- This encoding will expand data anywhere from:
-- 0% (average with pure ascii text)
-- 53.5% (average with random data valued zero to 255)
-- 100% (only encoding data that encodes to two bytes)
local function GenerateWoWChatChannelCodec()
  local r = {}
  for i = 128, 255 do r[#r + 1] = _byte_to_char[i] end

  local reserved_chars = "sS\000\010\013\124%" .. table_concat(r)
  return LibDeflate:CreateCodec(reserved_chars, "\029\031", "\015\020")
end

local _chat_channel_codec

--- Encode the string to make it ready to be transmitted in World of
-- Warcraft chat channel. <br>
-- See also https://wow.gamepedia.com/ValidChatMessageCharacters
-- @param str [string] The string to be encoded.
-- @return [string] The encoded string.
-- @see LibDeflate:DecodeForWoWChatChannel
function LibDeflate:EncodeForWoWChatChannel(str)
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:EncodeForWoWChatChannel(str):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  if not _chat_channel_codec then
    _chat_channel_codec = GenerateWoWChatChannelCodec()
  end
  return _chat_channel_codec:Encode(str)
end

--- Decode the string produced by LibDeflate:EncodeForWoWChatChannel.
-- @param str [string] The string to be decoded.
-- @return [string/nil] The decoded string if succeeds. nil if fails.
-- @see LibDeflate:EncodeForWoWChatChannel
function LibDeflate:DecodeForWoWChatChannel(str)
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:DecodeForWoWChatChannel(str):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  if not _chat_channel_codec then
    _chat_channel_codec = GenerateWoWChatChannelCodec()
  end
  return _chat_channel_codec:Decode(str)
end

-- Credits to WeakAuras2 and Galmok for the 6 bit encoding algorithm.
-- The code has been rewritten by the author of LibDeflate.
-- The result of encoding will be 25% larger than the
-- origin string, but every single byte of the encoding result will be
-- printable characters as the following.
local _byte_to_6bit_char = {
  [0] = "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "(",
  ")"
}

local _6bit_to_byte = {
  [97] = 0,
  [98] = 1,
  [99] = 2,
  [100] = 3,
  [101] = 4,
  [102] = 5,
  [103] = 6,
  [104] = 7,
  [105] = 8,
  [106] = 9,
  [107] = 10,
  [108] = 11,
  [109] = 12,
  [110] = 13,
  [111] = 14,
  [112] = 15,
  [113] = 16,
  [114] = 17,
  [115] = 18,
  [116] = 19,
  [117] = 20,
  [118] = 21,
  [119] = 22,
  [120] = 23,
  [121] = 24,
  [122] = 25,
  [65] = 26,
  [66] = 27,
  [67] = 28,
  [68] = 29,
  [69] = 30,
  [70] = 31,
  [71] = 32,
  [72] = 33,
  [73] = 34,
  [74] = 35,
  [75] = 36,
  [76] = 37,
  [77] = 38,
  [78] = 39,
  [79] = 40,
  [80] = 41,
  [81] = 42,
  [82] = 43,
  [83] = 44,
  [84] = 45,
  [85] = 46,
  [86] = 47,
  [87] = 48,
  [88] = 49,
  [89] = 50,
  [90] = 51,
  [48] = 52,
  [49] = 53,
  [50] = 54,
  [51] = 55,
  [52] = 56,
  [53] = 57,
  [54] = 58,
  [55] = 59,
  [56] = 60,
  [57] = 61,
  [40] = 62,
  [41] = 63
}

--- Encode the string to make it printable. <br>
--
-- Credit to WeakAuras2, this function is equivalant to the implementation
-- it is using right now. <br>
-- The code has been rewritten by the author of LibDeflate. <br>
-- The encoded string will be 25% larger than the origin string. However, every
-- single byte of the encoded string will be one of 64 printable ASCII
-- characters, which are can be easier copied, pasted and displayed.
-- (26 lowercase letters, 26 uppercase letters, 10 numbers digits,
-- left parenthese, or right parenthese)
-- @param str [string] The string to be encoded.
-- @return [string] The encoded string.
function LibDeflate:EncodeForPrint(str)
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:EncodeForPrint(str):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  local strlen = #str
  local strlenMinus2 = strlen - 2
  local i = 1
  local buffer = {}
  local buffer_size = 0
  while i <= strlenMinus2 do
    local x1, x2, x3 = string_byte(str, i, i + 2)
    i = i + 3
    local cache = x1 + x2 * 256 + x3 * 65536
    local b1 = cache % 64
    cache = (cache - b1) / 64
    local b2 = cache % 64
    cache = (cache - b2) / 64
    local b3 = cache % 64
    local b4 = (cache - b3) / 64
    buffer_size = buffer_size + 1
    buffer[buffer_size] = _byte_to_6bit_char[b1] .. _byte_to_6bit_char[b2] ..
                            _byte_to_6bit_char[b3] .. _byte_to_6bit_char[b4]
  end

  local cache = 0
  local cache_bitlen = 0
  while i <= strlen do
    local x = string_byte(str, i, i)
    cache = cache + x * _pow2[cache_bitlen]
    cache_bitlen = cache_bitlen + 8
    i = i + 1
  end
  while cache_bitlen > 0 do
    local bit6 = cache % 64
    buffer_size = buffer_size + 1
    buffer[buffer_size] = _byte_to_6bit_char[bit6]
    cache = (cache - bit6) / 64
    cache_bitlen = cache_bitlen - 6
  end

  return table_concat(buffer)
end

--- Decode the printable string produced by LibDeflate:EncodeForPrint.
-- "str" will have its prefixed and trailing control characters or space
-- removed before it is decoded, so it is easier to use if "str" comes form
-- user copy and paste with some prefixed or trailing spaces.
-- Then decode fails if the string contains any characters cant be produced by
-- LibDeflate:EncodeForPrint. That means, decode fails if the string contains a
-- characters NOT one of 26 lowercase letters, 26 uppercase letters,
-- 10 numbers digits, left parenthese, or right parenthese.
-- @param str [string] The string to be decoded
-- @return [string/nil] The decoded string if succeeds. nil if fails.
function LibDeflate:DecodeForPrint(str)
  if type(str) ~= "string" then
    error(("Usage: LibDeflate:DecodeForPrint(str):" ..
            " 'str' - string expected got '%s'."):format(type(str)), 2)
  end
  str = str:gsub("^[%c ]+", "")
  str = str:gsub("[%c ]+$", "")

  local strlen = #str
  if strlen == 1 then return nil end
  local strlenMinus3 = strlen - 3
  local i = 1
  local buffer = {}
  local buffer_size = 0
  while i <= strlenMinus3 do
    local x1, x2, x3, x4 = string_byte(str, i, i + 3)
    x1 = _6bit_to_byte[x1]
    x2 = _6bit_to_byte[x2]
    x3 = _6bit_to_byte[x3]
    x4 = _6bit_to_byte[x4]
    if not (x1 and x2 and x3 and x4) then return nil end
    i = i + 4
    local cache = x1 + x2 * 64 + x3 * 4096 + x4 * 262144
    local b1 = cache % 256
    cache = (cache - b1) / 256
    local b2 = cache % 256
    local b3 = (cache - b2) / 256
    buffer_size = buffer_size + 1
    buffer[buffer_size] = _byte_to_char[b1] .. _byte_to_char[b2] ..
                            _byte_to_char[b3]
  end

  local cache = 0
  local cache_bitlen = 0
  while i <= strlen do
    local x = string_byte(str, i, i)
    x = _6bit_to_byte[x]
    if not x then return nil end
    cache = cache + x * _pow2[cache_bitlen]
    cache_bitlen = cache_bitlen + 6
    i = i + 1
  end

  while cache_bitlen >= 8 do
    local byte = cache % 256
    buffer_size = buffer_size + 1
    buffer[buffer_size] = _byte_to_char[byte]
    cache = (cache - byte) / 256
    cache_bitlen = cache_bitlen - 8
  end

  return table_concat(buffer)
end

local function InternalClearCache()
  _chat_channel_codec = nil
  _addon_channel_codec = nil
end

-- For test. Don't use the functions in this table for real application.
-- Stuffs in this table is subject to change.
LibDeflate.internals = {
  LoadStringToTable = LoadStringToTable,
  IsValidDictionary = IsValidDictionary,
  IsEqualAdler32 = IsEqualAdler32,
  _byte_to_6bit_char = _byte_to_6bit_char,
  _6bit_to_byte = _6bit_to_byte,
  InternalClearCache = InternalClearCache
}

--[[-- Commandline options
@class table
@name CommandlineOptions
@usage lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]
\-0    store only. no compression.
\-1    fastest compression.
\-9    slowest and best compression.
\-d    do decompression instead of compression.
\--dict <filename> specify the file that contains
the entire preset dictionary.
\-h    give this help.
\--strategy <fixed/huffman_only/dynamic> specify a special compression strategy.
\-v    print the version and copyright info.
\--zlib  use zlib format instead of raw deflate.
]]

-- currently no plan to support stdin and stdout.
-- Because Lua in Windows does not set stdout with binary mode.
if io and os and debug and _G.arg then
  local io = io
  local os = os
  local debug = debug
  local arg = _G.arg
  local debug_info = debug.getinfo(1)
  if debug_info.source == arg[0] or debug_info.short_src == arg[0] then
    -- We are indeed runnning THIS file from the commandline.
    local input
    local output
    local i = 1
    local status
    local is_zlib = false
    local is_decompress = false
    local level
    local strategy
    local dictionary
    while (arg[i]) do
      local a = arg[i]
      if a == "-h" then
        print(LibDeflate._COPYRIGHT ..
                "\nUsage: lua LibDeflate.lua [OPTION] [INPUT] [OUTPUT]\n" ..
                "  -0    store only. no compression.\n" ..
                "  -1    fastest compression.\n" ..
                "  -9    slowest and best compression.\n" ..
                "  -d    do decompression instead of compression.\n" ..
                "  --dict <filename> specify the file that contains" ..
                " the entire preset dictionary.\n" ..
                "  -h    give this help.\n" ..
                "  --strategy <fixed/huffman_only/dynamic>" ..
                " specify a special compression strategy.\n" ..
                "  -v    print the version and copyright info.\n" ..
                "  --zlib  use zlib format instead of raw deflate.\n")
        os.exit(0)
      elseif a == "-v" then
        print(LibDeflate._COPYRIGHT)
        os.exit(0)
      elseif a:find("^%-[0-9]$") then
        level = tonumber(a:sub(2, 2))
      elseif a == "-d" then
        is_decompress = true
      elseif a == "--dict" then
        i = i + 1
        local dict_filename = arg[i]
        if not dict_filename then
          io.stderr:write("You must speicify the dict filename")
          os.exit(1)
        end
        local dict_file, dict_status = io.open(dict_filename, "rb")
        if not dict_file then
          io.stderr:write(
            ("LibDeflate: Cannot read the dictionary file '%s': %s"):format(
              dict_filename, dict_status))
          os.exit(1)
        end
        local dict_str = dict_file:read("*all")
        dict_file:close()
        -- In your lua program, you should pass in adler32 as a CONSTANT
        -- , so it actually prevent you from modifying dictionary
        -- unintentionally during the program development. I do this
        -- here just because no convenient way to verify in commandline.
        dictionary = LibDeflate:CreateDictionary(dict_str, #dict_str,
                                                 LibDeflate:Adler32(dict_str))
      elseif a == "--strategy" then
        -- Not sure if I should check error here
        -- If I do, redudant code.
        i = i + 1
        strategy = arg[i]
      elseif a == "--zlib" then
        is_zlib = true
      elseif a:find("^%-") then
        io.stderr:write(("LibDeflate: Invalid argument: %s"):format(a))
        os.exit(1)
      else
        if not input then
          input, status = io.open(a, "rb")
          if not input then
            io.stderr:write(
              ("LibDeflate: Cannot read the file '%s': %s"):format(a, tostring(
                                                                     status)))
            os.exit(1)
          end
        elseif not output then
          output, status = io.open(a, "wb")
          if not output then
            io.stderr:write(
              ("LibDeflate: Cannot write the file '%s': %s"):format(a, tostring(
                                                                      status)))
            os.exit(1)
          end
        end
      end
      i = i + 1
    end -- while (arg[i])

    if not input or not output then
      io.stderr:write("LibDeflate:" ..
                        " You must specify both input and output files.")
      os.exit(1)
    end

    local input_data = input:read("*all")
    local configs = {level = level, strategy = strategy}
    local output_data
    if not is_decompress then
      if not is_zlib then
        if not dictionary then
          output_data = LibDeflate:CompressDeflate(input_data, configs)
        else
          output_data = LibDeflate:CompressDeflateWithDict(input_data,
                                                           dictionary, configs)
        end
      else
        if not dictionary then
          output_data = LibDeflate:CompressZlib(input_data, configs)
        else
          output_data = LibDeflate:CompressZlibWithDict(input_data, dictionary,
                                                        configs)
        end
      end
    else
      if not is_zlib then
        if not dictionary then
          output_data = LibDeflate:DecompressDeflate(input_data)
        else
          output_data = LibDeflate:DecompressDeflateWithDict(input_data,
                                                             dictionary)
        end
      else
        if not dictionary then
          output_data = LibDeflate:DecompressZlib(input_data)
        else
          output_data =
            LibDeflate:DecompressZlibWithDict(input_data, dictionary)
        end
      end
    end

    if not output_data then
      io.stderr:write("LibDeflate: Decompress fails.")
      os.exit(1)
    end

    output:write(output_data)
    if input and input ~= io.stdin then input:close() end
    if output and output ~= io.stdout then output:close() end

    io.stderr:write(("Successfully writes %d bytes"):format(output_data:len()))
    os.exit(0)
  end
end

return LibDeflate


-- ========================================
-- File: WeakAuras/Libs/LibDispel/LibDispel.lua
-- ========================================

local MAJOR, MINOR = "LibDispel-1.0", 20
assert(LibStub, MAJOR.." requires LibStub")

local lib = LibStub:NewLibrary(MAJOR, MINOR)
if not lib then return end

local next = next
local wipe = wipe
local type = type

local GetCVar = C_CVar.GetCVar
local SetCVar = C_CVar.SetCVar

local CopyTable = CopyTable
local CreateFrame = CreateFrame
local IsSpellInSpellBook = C_SpellBook.IsSpellInSpellBook or IsSpellKnownOrOverridesKnown
local IsSpellKnown = C_SpellBook.IsSpellKnown or IsPlayerSpell

local Retail = WOW_PROJECT_ID == WOW_PROJECT_MAINLINE
local Classic = WOW_PROJECT_ID == WOW_PROJECT_CLASSIC
local Mists = WOW_PROJECT_ID == WOW_PROJECT_MISTS_CLASSIC

local function GetList(name, data)
	local list = lib[name]
	if list then -- clear the existing list
		wipe(list)
	else
		list = {} -- create new list
		lib[name] = list -- add new list
	end

	if data then -- import color data
		for key, value in next, data do
			if type(value) == 'table' then
				list[key] = CopyTable(value)
			else
				list[key] = value
			end
		end
	end

	return list
end

local BadList = GetList('BadList') -- Spells that backfire when dispelled
local BleedList = GetList('BleedList') -- Contains spells classified as Bleeds
local BlockList = GetList('BlockList') -- Spells blocked from AuraHighlight
local DispelList = GetList('DispelList') -- List of types the player can dispel
local DebuffColors = GetList('DebuffTypeColor', _G.DebuffTypeColor)

-- These dont exist in Blizzards color table
DebuffColors.Bleed = { r = 1, g = 0.2, b = 0.6 }
DebuffColors.EnemyNPC = { r = 0.9, g = 0.1, b = 0.1 }
DebuffColors.BadDispel = { r = 0.05, g = 0.85, b = 0.94 }
DebuffColors.Stealable = { r = 0.93, g = 0.91, b = 0.55 }

if Retail then
	-- Bad to dispel spells
	BadList[34914] = "Vampiric Touch"		-- horrifies
	BadList[233490] = "Unstable Affliction"	-- silences

	-- Block spells from AuraHighlight
	BlockList[140546] = "Fully Mutated"
	BlockList[136184] = "Thick Bones"
	BlockList[136186] = "Clear Mind"
	BlockList[136182] = "Improved Synapses"
	BlockList[136180] = "Keen Eyesight"
	BlockList[105171] = "Deep Corruption"
	BlockList[108220] = "Deep Corruption"
	BlockList[116095] = "Disable" -- slow

	-- Bleed spells updated March 9th 2025 by Simpy for Patch 11.1
	--- Combined lists (without duplicates, filter requiring either main or effect bleed):
	----> Apply Aura
	-----> Mechanic Bleeding: https://www.wowhead.com/spells/mechanic:15?filter=109;6;0
	-----> Physical DoT
	------> Damage Type I
	-------> None: https://www.wowhead.com/spells/school:0?filter=29:40;3:1;0:0
	-------> Magic: https://www.wowhead.com/spells/school:0?filter=29:40;3:2;0:0
	-------> Melee: https://www.wowhead.com/spells/school:0?filter=29:40;3:3;0:0
	-------> Ranged: https://www.wowhead.com/spells/school:0?filter=29:40;3:4;0:0
	------> Damage Type II
	-------> None: https://www.wowhead.com/spells/school:0?filter=29:40;70:1;0:0
	-------> Magic: https://www.wowhead.com/spells/school:0?filter=29:40;70:2;0:0
	-------> Melee: https://www.wowhead.com/spells/school:0?filter=29:40;70:3;0:0
	-------> Ranged: https://www.wowhead.com/spells/school:0?filter=29:40;70:4;0:0

	BleedList[703] = "Garrote"
	BleedList[1079] = "Rip"
	BleedList[1943] = "Rupture"
	BleedList[3147] = "Rend Flesh"
	BleedList[5597] = "Serious Wound"
	BleedList[5598] = "Serious Wound"
	BleedList[8818] = "Garrote"
	BleedList[10266] = "Lung Puncture"
	BleedList[11977] = "Rend"
	BleedList[12054] = "Rend"
	BleedList[13318] = "Rend"
	BleedList[13443] = "Rend"
	BleedList[13445] = "Rend"
	BleedList[13738] = "Rend"
	BleedList[14087] = "Rend"
	BleedList[14118] = "Rend"
	BleedList[14331] = "Vicious Rend"
	BleedList[14874] = "Rupture"
	BleedList[14903] = "Rupture"
	BleedList[15583] = "Rupture"
	BleedList[15976] = "Puncture"
	BleedList[16095] = "Vicious Rend"
	BleedList[16393] = "Rend"
	BleedList[16403] = "Rend"
	BleedList[16406] = "Rend"
	BleedList[16509] = "Rend"
	BleedList[17153] = "Rend"
	BleedList[17504] = "Rend"
	BleedList[18075] = "Rend"
	BleedList[18078] = "Rend"
	BleedList[18106] = "Rend"
	BleedList[18200] = "Rend"
	BleedList[18202] = "Rend"
	BleedList[19771] = "Serrated Bite"
	BleedList[21949] = "Rend"
	BleedList[24192] = "Speed Slash"
	BleedList[24331] = "Rake"
	BleedList[24332] = "Rake"
	BleedList[27555] = "Shred"
	BleedList[27556] = "Rake"
	BleedList[27638] = "Rake"
	BleedList[28913] = "Flesh Rot"
	BleedList[29574] = "Rend"
	BleedList[29578] = "Rend"
	BleedList[29583] = "Impale"
	BleedList[29906] = "Ravage"
	BleedList[29935] = "Gaping Maw"
	BleedList[30285] = "Eagle Claw"
	BleedList[30639] = "Carnivorous Bite"
	BleedList[31041] = "Mangle"
	BleedList[31410] = "Coral Cut"
	BleedList[31956] = "Grievous Wound"
	BleedList[32019] = "Gore"
	BleedList[32901] = "Carnivorous Bite"
	BleedList[33865] = "Singe"
	BleedList[33912] = "Rip"
	BleedList[35144] = "Vicious Rend"
	BleedList[35318] = "Saw Blade"
	BleedList[35321] = "Gushing Wound"
	BleedList[36023] = "Deathblow"
	BleedList[36332] = "Rake"
	BleedList[36383] = "Carnivorous Bite"
	BleedList[36590] = "Rip"
	BleedList[36617] = "Gaping Maw"
	BleedList[36789] = "Diminish Soul"
	BleedList[36965] = "Rend"
	BleedList[36991] = "Rend"
	BleedList[37066] = "Garrote"
	BleedList[37123] = "Saw Blade"
	BleedList[37487] = "Blood Heal"
	BleedList[37641] = "Whirlwind"
	BleedList[37662] = "Rend"
	BleedList[37937] = "Flayed Flesh"
	BleedList[37973] = "Coral Cut"
	BleedList[38056] = "Flesh Rip"
	BleedList[38363] = "Gushing Wound"
	BleedList[38772] = "Grievous Wound"
	BleedList[38801] = "Grievous Wound"
	BleedList[38810] = "Gaping Maw"
	BleedList[38848] = "Diminish Soul"
	BleedList[39198] = "Carnivorous Bite"
	BleedList[39215] = "Gushing Wound"
	BleedList[39382] = "Carnivorous Bite"
	BleedList[40199] = "Flesh Rip"
	BleedList[41092] = "Carnivorous Bite"
	BleedList[41932] = "Carnivorous Bite"
	BleedList[42395] = "Lacerating Slash"
	BleedList[42397] = "Rend Flesh"
	BleedList[42658] = "Sic'em!"
	BleedList[43093] = "Grievous Throw"
	BleedList[43104] = "Deep Wound"
	BleedList[43153] = "Lynx Rush"
	BleedList[43246] = "Rend"
	BleedList[43931] = "Rend"
	BleedList[43937] = "Grievous Wound"
	BleedList[48130] = "Gore"
	BleedList[48261] = "Impale"
	BleedList[48286] = "Grievous Slash"
	BleedList[48374] = "Puncture Wound"
	BleedList[48880] = "Rend"
	BleedList[48920] = "Grievous Bite"
	BleedList[49678] = "Flesh Rot"
	BleedList[50729] = "Carnivorous Bite"
	BleedList[50871] = "Savage Rend"
	BleedList[51275] = "Gut Rip"
	BleedList[52401] = "Gut Rip"
	BleedList[52504] = "Lacerate"
	BleedList[52771] = "Wounding Strike"
	BleedList[52873] = "Open Wound"
	BleedList[53317] = "Rend"
	BleedList[53499] = "Rake"
	BleedList[53602] = "Dart"
	BleedList[54668] = "Rake"
	BleedList[54703] = "Rend"
	BleedList[54708] = "Rend"
	BleedList[55102] = "Determined Gore"
	BleedList[55249] = "Whirling Slash"
	BleedList[55250] = "Whirling Slash"
	BleedList[55276] = "Puncture"
	BleedList[55550] = "Jagged Knife"
	BleedList[55604] = "Death Plague"
	BleedList[55622] = "Impale"
	BleedList[55645] = "Death Plague"
	BleedList[57661] = "Rip"
	BleedList[58459] = "Impale"
	BleedList[58517] = "Grievous Wound"
	BleedList[58830] = "Wounding Strike"
	BleedList[58978] = "Impale"
	BleedList[59007] = "Flesh Rot"
	BleedList[59023] = "Puncturing Strike"
	BleedList[59239] = "Rend"
	BleedList[59256] = "Impale"
	BleedList[59262] = "Grievous Wound"
	BleedList[59264] = "Gore"
	BleedList[59268] = "Impale"
	BleedList[59269] = "Carnivorous Bite"
	BleedList[59343] = "Rend"
	BleedList[59349] = "Dart"
	BleedList[59444] = "Determined Gore"
	BleedList[59682] = "Grievous Wound"
	BleedList[59691] = "Rend"
	BleedList[59824] = "Whirling Slash"
	BleedList[59825] = "Whirling Slash"
	BleedList[59826] = "Puncture"
	BleedList[59881] = "Rake"
	BleedList[59989] = "Rip"
	BleedList[61164] = "Impale"
	BleedList[61896] = "Lacerate"
	BleedList[62318] = "Barbed Shot"
	BleedList[62331] = "Impale"
	BleedList[62418] = "Impale"
	BleedList[63468] = "Careful Aim"
	BleedList[64374] = "Savage Pounce"
	BleedList[64666] = "Savage Pounce"
	BleedList[65033] = "Constricting Rend"
	BleedList[65406] = "Rake"
	BleedList[66620] = "Old Wounds"
	BleedList[67280] = "Dagger Throw"
	BleedList[69203] = "Vicious Bite"
	BleedList[70278] = "Puncture Wound"
	BleedList[71926] = "Rip"
	BleedList[74846] = "Bleeding Wound"
	BleedList[75160] = "Bloody Rip"
	BleedList[75161] = "Spinning Rake"
	BleedList[75388] = "Rusty Cut"
	BleedList[75930] = "Mangle"
	BleedList[76507] = "Claw Puncture"
	BleedList[76524] = "Grievous Whirl"
	BleedList[76594] = "Rend"
	BleedList[78842] = "Carnivorous Bite"
	BleedList[78859] = "Elementium Spike Shield"
	BleedList[79444] = "Impale"
	BleedList[79828] = "Mangle"
	BleedList[79829] = "Rip"
	BleedList[80028] = "Bleeding Edge"
	BleedList[80051] = "Grievous Wound"
	BleedList[81043] = "Razor Slice"
	BleedList[81087] = "Puncture Wound"
	BleedList[81568] = "Spinning Slash"
	BleedList[81569] = "Spinning Slash"
	BleedList[81690] = "Scent of Blood"
	BleedList[82753] = "Ritual of Bloodletting"
	BleedList[82766] = "Eye Gouge"
	BleedList[83783] = "Impale"
	BleedList[84642] = "Puncture"
	BleedList[85415] = "Mangle"
	BleedList[87395] = "Serrated Slash"
	BleedList[89212] = "Eagle Claw"
	BleedList[90098] = "Axe to the Head"
	BleedList[91348] = "Tenderize"
	BleedList[93587] = "Ritual of Bloodletting"
	BleedList[93675] = "Mortal Wound"
	BleedList[95334] = "Elementium Spike Shield"
	BleedList[96570] = "Gaping Wound"
	BleedList[96592] = "Ravage"
	BleedList[96700] = "Ravage"
	BleedList[97357] = "Gaping Wound"
	BleedList[98282] = "Tiny Rend"
	BleedList[99100] = "Mangle"
	BleedList[102066] = "Flesh Rip"
	BleedList[102925] = "Garrote"
	BleedList[112896] = "Drain Blood"
	BleedList[113344] = "Bloodbath"
	BleedList[113855] = "Bleeding Wound"
	BleedList[114056] = "Bloody Mess"
	BleedList[114860] = "Rend"
	BleedList[114881] = "Hawk Rend"
	BleedList[115767] = "Deep Wounds"
	BleedList[115774] = "Vicious Wound"
	BleedList[115871] = "Rake"
	BleedList[118146] = "Lacerate"
	BleedList[119840] = "Serrated Blade"
	BleedList[120166] = "Serrated Blade"
	BleedList[120560] = "Rake"
	BleedList[120699] = "Lynx Rush"
	BleedList[121247] = "Impale"
	BleedList[121411] = "Crimson Tempest"
	BleedList[122962] = "Carnivorous Bite"
	BleedList[123422] = "Arterial Bleeding"
	BleedList[123852] = "Gored"
	BleedList[124015] = "Gored"
	BleedList[124296] = "Vicious Strikes"
	BleedList[124341] = "Bloodletting"
	BleedList[124678] = "Hacking Slash"
	BleedList[124800] = "Pinch Limb"
	BleedList[125099] = "Rake"
	BleedList[125206] = "Rend Flesh"
	BleedList[125431] = "Slice Bone"
	BleedList[125624] = "Vicious Rend"
	BleedList[126901] = "Mortal Rend"
	BleedList[126912] = "Grievous Whirl"
	BleedList[127872] = "Consume Flesh"
	BleedList[127987] = "Bleeding Bite"
	BleedList[128051] = "Serrated Slash"
	BleedList[128903] = "Garrote"
	BleedList[129463] = "Crane Kick"
	BleedList[129497] = "Pounced"
	BleedList[129537] = "Snap!"
	BleedList[130191] = "Rake"
	BleedList[130306] = "Ankle Bite"
	BleedList[130785] = "My Eye!"
	BleedList[130897] = "Vicious Bite"
	BleedList[131662] = "Vicious Stabbing"
	BleedList[133074] = "Puncture"
	BleedList[133081] = "Rip"
	BleedList[134691] = "Impale"
	BleedList[135528] = "Bleeding Wound"
	BleedList[135892] = "Razor Slice"
	BleedList[136654] = "Rending Charge"
	BleedList[136753] = "Slashing Talons"
	BleedList[137497] = "Garrote"
	BleedList[138956] = "Dark Bite"
	BleedList[139514] = "Bloodstorm"
	BleedList[140274] = "Vicious Wound"
	BleedList[140275] = "Rend"
	BleedList[140276] = "Rend"
	BleedList[140396] = "Rend"
	BleedList[143198] = "Garrote"
	BleedList[144113] = "Chomp"
	BleedList[144263] = "Rend"
	BleedList[144264] = "Rend"
	BleedList[144304] = "Rend"
	BleedList[144853] = "Carnivorous Bite"
	BleedList[145263] = "Chomp"
	BleedList[145417] = "Rupture"
	BleedList[146556] = "Pierce"
	BleedList[146927] = "Rend"
	BleedList[147396] = "Rake"
	BleedList[148033] = "Grapple"
	BleedList[148375] = "Brutal Hemorrhage"
	BleedList[150807] = "Traumatic Strike"
	BleedList[151092] = "Traumatic Strike"
	BleedList[151475] = "Drain Life"
	BleedList[152357] = "Rend"
	BleedList[152623] = "Rend"
	BleedList[152724] = "Lacerating Strike"
	BleedList[153897] = "Rending Cleave"
	BleedList[154489] = "Puncturing Horns"
	BleedList[154953] = "Internal Bleeding"
	BleedList[154960] = "Pinned Down"
	BleedList[155065] = "Ripping Claw"
	BleedList[155701] = "Serrated Slash"
	BleedList[155722] = "Rake"
	BleedList[157344] = "Vital Strike"
	BleedList[158020] = "Rearing Charge"
	BleedList[158150] = "Goring Swipe"
	BleedList[158341] = "Gushing Wounds"
	BleedList[158453] = "Rending Swipe"
	BleedList[158667] = "Warleader's Spear"
	BleedList[159238] = "Shattered Bleed"
	BleedList[161117] = "Puncturing Tusk"
	BleedList[161229] = "Pounce"
	BleedList[161765] = "Iron Axe"
	BleedList[162487] = "Steel Trap"
	BleedList[162516] = "Whirling Steel"
	BleedList[162921] = "Peck"
	BleedList[162951] = "Lacerating Spines"
	BleedList[163276] = "Shredded Tendons"
	BleedList[164218] = "Double Slash"
	BleedList[164323] = "Precise Strike"
	BleedList[164427] = "Ravage"
	BleedList[165308] = "Gushing Wound"
	BleedList[166185] = "Rending Slash"
	BleedList[166638] = "Gushing Wound"
	BleedList[166639] = "Item - Druid T17 Feral 4P Bonus Proc Driver"
	BleedList[166917] = "Savage"
	BleedList[167334] = "Windfang Bite"
	BleedList[167597] = "Rending Nails"
	BleedList[167978] = "Jagged Edge"
	BleedList[168097] = "Shredder Bomb"
	BleedList[168392] = "Fangs of the Predator"
	BleedList[169584] = "Serrated Spines"
	BleedList[170367] = "Vicious Throw"
	BleedList[170373] = "Razor Teeth"
	BleedList[170936] = "Talador Venom"
	BleedList[172019] = "Stingtail Venom"
	BleedList[172035] = "Thrash"
	BleedList[172139] = "Lacerating Bite"
	BleedList[172361] = "Puncturing Strike"
	BleedList[172366] = "Jagged Slash"
	BleedList[172657] = "Serrated Edge"
	BleedList[172889] = "Charging Slash"
	BleedList[173113] = "Hatchet Toss"
	BleedList[173278] = "Spinal Shards"
	BleedList[173299] = "Rip"
	BleedList[173307] = "Serrated Spear"
	BleedList[173378] = "Rending Bite"
	BleedList[173643] = "Drill Fist"
	BleedList[173876] = "Rending Claws"
	BleedList[174423] = "Pinning Spines"
	BleedList[174734] = "Axe to the Face!"
	BleedList[174820] = "Rending Claws"
	BleedList[175014] = "Rupture"
	BleedList[175151] = "Thousand Fangs"
	BleedList[175156] = "Painful Pinch"
	BleedList[175372] = "Sharp Teeth"
	BleedList[175461] = "Sadistic Slice"
	BleedList[175747] = "Big Sharp Nasty Claws"
	BleedList[176147] = "Ignite"
	BleedList[176256] = "Talon Sweep"
	BleedList[176575] = "Consume Flesh"
	BleedList[176695] = "Bone Fragments"
	BleedList[177337] = "Carnivorous Bite"
	BleedList[177422] = "Thrash"
	BleedList[181346] = "Lacerating Swipe"
	BleedList[181533] = "Jagged Blade"
	BleedList[182325] = "Phantasmal Wounds"
	BleedList[182330] = "Coral Cut"
	BleedList[182347] = "Impaling Coral"
	BleedList[182795] = "Primal Mangle"
	BleedList[182846] = "Thrash"
	BleedList[183025] = "Rending Lash"
	BleedList[183952] = "Shadow Claws"
	BleedList[184025] = "Rending Claws"
	BleedList[184090] = "Bloody Arc"
	BleedList[184175] = "Primal Rake"
	BleedList[185539] = "Rapid Rupture"
	BleedList[185698] = "Bloody Hack"
	BleedList[185855] = "Lacerate"
	BleedList[186191] = "Bloodletting Slash"
	BleedList[186365] = "Sweeping Blade"
	BleedList[186594] = "Laceration"
	BleedList[186639] = "Big Sharp Nasty Teeth"
	BleedList[186730] = "Exposed Wounds"
	BleedList[187647] = "Bloodletting Pounce"
	BleedList[188353] = "Rip"
	BleedList[189035] = "Barbed Cutlass"
	BleedList[191977] = "Impaling Spear"
	BleedList[192090] = "Thrash"
	BleedList[192131] = "Throw Spear"
	BleedList[192925] = "Blood of the Assassinated"
	BleedList[193092] = "Bloodletting Sweep"
	BleedList[193340] = "Fenri's Bite"
	BleedList[193585] = "Bound"
	BleedList[193639] = "Bone Chomp"
	BleedList[194636] = "Cursed Rend"
	BleedList[194639] = "Rending Claws"
	BleedList[194674] = "Barbed Spear"
	BleedList[195094] = "Coral Slash"
	BleedList[195279] = "Bind"
	BleedList[195506] = "Razorsharp Axe"
	BleedList[196111] = "Jagged Claws"
	BleedList[196122] = "Severing Swipe"
	BleedList[196189] = "Bloody Talons"
	BleedList[196313] = "Lacerating Talons"
	BleedList[196376] = "Grievous Tear"
	BleedList[196497] = "Ravenous Leap"
	BleedList[197359] = "Shred"
	BleedList[197381] = "Exposed Wounds"
	BleedList[197546] = "Brutal Glaive"
	BleedList[197863] = "Gore"
	BleedList[199108] = "Frantic Gore"
	BleedList[199146] = "Bucking Charge"
	BleedList[199337] = "Bear Trap"
	BleedList[199847] = "Grievous Wound"
	BleedList[200182] = "Festering Rip"
	BleedList[200620] = "Frantic Rip"
	BleedList[204175] = "Rend"
	BleedList[204179] = "Rend Flesh"
	BleedList[204968] = "Hemoraging Barbs"
	BleedList[205437] = "Laceration"
	BleedList[207662] = "Nightmare Wounds"
	BleedList[207690] = "Bloodlet"
	BleedList[208470] = "Necrotic Thrash"
	BleedList[208945] = "Mangle"
	BleedList[208946] = "Rip"
	BleedList[209336] = "Mangle"
	BleedList[209378] = "Whirling Blades"
	BleedList[209667] = "Blade Surge"
	BleedList[209858] = "Necrotic Wound"
	BleedList[210013] = "Bloodletting Slash"
	BleedList[210177] = "Spiked Shield"
	BleedList[210723] = "Ashamane's Frenzy"
	BleedList[211672] = "Mutilated Flesh"
	BleedList[211846] = "Bloodletting Lunge"
	BleedList[213431] = "Gnawing Eagle"
	BleedList[213537] = "Bloody Pin"
	BleedList[213824] = "Rending Pounce"
	BleedList[213933] = "Harpoon Swipe"
	BleedList[213990] = "Shard Bore"
	BleedList[214424] = "Gore"
	BleedList[214676] = "Razorsharp Teeth"
	BleedList[214967] = "Bloody Blade"
	BleedList[215442] = "Shred"
	BleedList[215506] = "Jagged Quills"
	BleedList[215537] = "Trauma"
	BleedList[215721] = "Gut Slash"
	BleedList[217023] = "Antler Gore"
	BleedList[217041] = "Shred"
	BleedList[217091] = "Puncturing Stab"
	BleedList[217142] = "Mangle"
	BleedList[217163] = "Rend"
	BleedList[217200] = "Barbed Shot"
	BleedList[217235] = "Rending Whirl"
	BleedList[217363] = "Ashamane's Frenzy"
	BleedList[217369] = "Rake"
	BleedList[217868] = "Impale"
	BleedList[218506] = "Jagged Slash"
	BleedList[219167] = "Chomp"
	BleedList[219240] = "Bloody Ricochet"
	BleedList[219339] = "Thrash"
	BleedList[219680] = "Impale"
	BleedList[220222] = "Rending Snap"
	BleedList[220874] = "Lacerate"
	BleedList[221352] = "Cut the Flank"
	BleedList[221422] = "Vicious Bite"
	BleedList[221759] = "Feathery Stab"
	BleedList[221770] = "Rend Flesh"
	BleedList[222491] = "Gutripper"
	BleedList[223111] = "Rake"
	BleedList[223572] = "Rend"
	BleedList[223954] = "Rake"
	BleedList[223967] = "Tear Flesh"
	BleedList[224435] = "Ashamane's Rip"
	BleedList[225484] = "Grievous Rip"
	BleedList[225963] = "Bloodthirsty Leap"
	BleedList[227742] = "Garrote"
	BleedList[228275] = "Rend"
	BleedList[228281] = "Rend"
	BleedList[228305] = "Unyielding Rend"
	BleedList[229127] = "Powershot"
	BleedList[229265] = "Garrote"
	BleedList[229923] = "Talon Rend"
	BleedList[230011] = "Cruel Garrote"
	BleedList[231003] = "Barbed Talons"
	BleedList[231998] = "Jagged Abrasion"
	BleedList[232135] = "Bloody Jab"
	BleedList[234052] = "Whirlwind"
	BleedList[235832] = "Bloodletting Strike"
	BleedList[237346] = "Rend"
	BleedList[238594] = "Ripper Blade"
	BleedList[238618] = "Fel Swipe"
	BleedList[238660] = "Wild Swipe"
	BleedList[240449] = "Grievous Wound"
	BleedList[240539] = "Wild Bite"
	BleedList[240559] = "Grievous Wound"
	BleedList[241070] = "Bloodletting Strike"
	BleedList[241092] = "Rend"
	BleedList[241212] = "Fel Slash"
	BleedList[241465] = "Coral Cut"
	BleedList[241644] = "Mangle"
	BleedList[242376] = "Puncturing Strike"
	BleedList[242828] = "Dire Thrash"
	BleedList[242931] = "Rake"
	BleedList[244040] = "Eskhandar's Rake"
	BleedList[246904] = "Smoldering Rend"
	BleedList[247932] = "Shrapnel Blast"
	BleedList[247949] = "Shrapnel Blast"
	BleedList[250393] = "Rake"
	BleedList[251332] = "Rip"
	BleedList[253384] = "Slaughter"
	BleedList[253516] = "Hexabite"
	BleedList[253610] = "Ripper Blade"
	BleedList[254280] = "Jagged Maw"
	BleedList[254575] = "Rend"
	BleedList[254901] = "Blood Frenzy"
	BleedList[255299] = "Bloodletting"
	BleedList[255434] = "Serrated Teeth"
	BleedList[255595] = "Chomp"
	BleedList[255627] = "Piercing Thrust"
	BleedList[255814] = "Rending Maul"
	BleedList[256077] = "Gore"
	BleedList[256314] = "Barbed Strike"
	BleedList[256363] = "Ripper Punch"
	BleedList[256476] = "Rending Whirl"
	BleedList[256709] = "Singing Steel"
	BleedList[256715] = "Jagged Maw"
	BleedList[256880] = "Bone Splinter"
	BleedList[256914] = "Barbed Blade"
	BleedList[256965] = "Thorned Barrage"
	BleedList[257036] = "Feral Charge"
	BleedList[257250] = "Bramblepelt"
	BleedList[257544] = "Jagged Cut"
	BleedList[257790] = "Gutripper"
	BleedList[257971] = "Leaping Thrash"
	BleedList[258058] = "Squeeze"
	BleedList[258075] = "Itchy Bite"
	BleedList[258143] = "Rending Claws"
	BleedList[258718] = "Scratched!"
	BleedList[258798] = "Razorsharp Teeth"
	BleedList[258825] = "Vampiric Bite"
	BleedList[259220] = "Barbed Net"
	BleedList[259328] = "Gory Whirl"
	BleedList[259382] = "Shell Slash"
	BleedList[259739] = "Stone Claws"
	BleedList[259873] = "Rip"
	BleedList[259983] = "Pierce"
	BleedList[260016] = "Itchy Bite"
	BleedList[260025] = "Rending Whirl"
	BleedList[260291] = "Rending Cut"
	BleedList[260400] = "Rend"
	BleedList[260455] = "Serrated Fangs"
	BleedList[260563] = "Gnaw"
	BleedList[260582] = "Gushing Wound"
	BleedList[260741] = "Jagged Nettles"
	BleedList[261882] = "Steel Jaw Trap"
	BleedList[261910] = "Cutting Slash"
	BleedList[262115] = "Deep Wounds"
	BleedList[262143] = "Ravenous Claws"
	BleedList[262557] = "Rake"
	BleedList[262677] = "Keelhaul"
	BleedList[262875] = "Papercut"
	BleedList[263144] = "Talon Slash"
	BleedList[263900] = "Rending Bite"
	BleedList[264145] = "Shatter"
	BleedList[264150] = "Shatter"
	BleedList[264210] = "Jagged Mandible"
	BleedList[264556] = "Tearing Strike"
	BleedList[264688] = "Goring Tusk"
	BleedList[265019] = "Savage Cleave"
	BleedList[265074] = "Rend"
	BleedList[265165] = "Charging Gore"
	BleedList[265232] = "Rend"
	BleedList[265341] = "Twin Cleave"
	BleedList[265377] = "Hooked Snare"
	BleedList[265533] = "Blood Maw"
	BleedList[265536] = "Rending Bite"
	BleedList[265948] = "Denticulated"
	BleedList[266035] = "Bone Splinter"
	BleedList[266191] = "Whirling Axe"
	BleedList[266231] = "Severing Axe"
	BleedList[266505] = "Rending Claw"
	BleedList[267064] = "Bleeding"
	BleedList[267080] = "Blight of G'huun"
	BleedList[267103] = "Blight of G'huun"
	BleedList[267441] = "Serrated Axe"
	BleedList[267523] = "Cutting Surge"
	BleedList[269576] = "Master Marksman"
	BleedList[269882] = "Overpowering Strike"
	BleedList[270084] = "Axe Barrage"
	BleedList[270139] = "Gore"
	BleedList[270343] = "Internal Bleeding"
	BleedList[270473] = "Serrated Arrows"
	BleedList[270487] = "Severing Blade"
	BleedList[270979] = "Rend and Tear"
	BleedList[270992] = "Rend Flesh"
	BleedList[271178] = "Ravaging Leap"
	BleedList[271798] = "Click"
	BleedList[272106] = "Rending Slash"
	BleedList[272273] = "Rending Cleave"
	BleedList[273436] = "Gore"
	BleedList[273632] = "Gaping Maw"
	BleedList[273794] = "Rezan's Fury"
	BleedList[273871] = "Shredding Claws"
	BleedList[273900] = "Bramble Swipe"
	BleedList[273909] = "Steelclaw Trap"
	BleedList[274089] = "Rend"
	BleedList[274389] = "Rat Traps"
	BleedList[274838] = "Feral Frenzy"
	BleedList[275090] = "Severing Swipe"
	BleedList[275570] = "Ravage"
	BleedList[275895] = "Rend of Kimbul"
	BleedList[276868] = "Impale"
	BleedList[276887] = "Hacking Slash"
	BleedList[277014] = "Bloody Maul"
	BleedList[277073] = "Jagged Blade"
	BleedList[277077] = "Big Sharp Nasty Teeth"
	BleedList[277309] = "Jagged Maw"
	BleedList[277431] = "Hunter Toxin"
	BleedList[277491] = "Crippling Strike"
	BleedList[277505] = "Spiked Shield"
	BleedList[277517] = "Serrated Slash"
	BleedList[277569] = "Bloodthirsty Rend"
	BleedList[277592] = "Blood Frenzy"
	BleedList[277794] = "Paw Swipe"
	BleedList[278139] = "Sharp Beak"
	BleedList[278175] = "Bramble Claw"
	BleedList[278396] = "Sever Artery"
	BleedList[278397] = "Slashing Talons"
	BleedList[278483] = "Toll"
	BleedList[278570] = "Boils and Sores"
	BleedList[278733] = "Deep Wound"
	BleedList[278866] = "Carve and Spit"
	BleedList[278950] = "Pouncing Claws"
	BleedList[279133] = "Rend"
	BleedList[279272] = "Puncturing Digit"
	BleedList[280286] = "Dagger in the Back"
	BleedList[280321] = "Garrote"
	BleedList[280940] = "Mangle"
	BleedList[281711] = "Cut of Death"
	BleedList[282444] = "Lacerating Claws"
	BleedList[282845] = "Bear Trap"
	BleedList[283419] = "Rend"
	BleedList[283667] = "Rupture"
	BleedList[283668] = "Crimson Tempest"
	BleedList[283700] = "Rake"
	BleedList[283708] = "Rip"
	BleedList[284158] = "Circular Saw"
	BleedList[285875] = "Rending Bite"
	BleedList[286269] = "Mangle"
	BleedList[288091] = "Gushing Wound"
	BleedList[288266] = "Mangle"
	BleedList[288516] = "Lacerating Swipe"
	BleedList[288535] = "Rip"
	BleedList[288539] = "Mangle"
	BleedList[289355] = "Smoldering Rend"
	BleedList[289373] = "Lacerating Pounce"
	BleedList[289848] = "Rending Claw"
	BleedList[292348] = "Bloodletting"
	BleedList[292611] = "Rake"
	BleedList[292626] = "Rip"
	BleedList[293670] = "Chainblade"
	BleedList[294617] = "Rupture"
	BleedList[294741] = "Saber Slash"
	BleedList[294901] = "Serrated Blades"
	BleedList[295008] = "Bloody Cleaver"
	BleedList[295929] = "Rats!"
	BleedList[295945] = "Rat Traps"
	BleedList[296777] = "Bleeding Wound"
	BleedList[297447] = "Sucking Teeth"
	BleedList[298029] = "Pincer Snap"
	BleedList[299474] = "Ripping Slash"
	BleedList[299502] = "Nanoslicer"
	BleedList[299923] = "Tear Flesh"
	BleedList[300610] = "Fanged Bite"
	BleedList[301061] = "Thrash"
	BleedList[301712] = "Pounce"
	BleedList[302295] = "Slicing Claw"
	BleedList[302474] = "Phantom Laceration"
	BleedList[302972] = "Rearing Charge"
	BleedList[303162] = "Carve Flesh"
	BleedList[303215] = "Shell Slash"
	BleedList[303501] = "Rending Strike"
	BleedList[304453] = "Hydra Maw"
	BleedList[308342] = "Bore"
	BleedList[308859] = "Carnivorous Bite"
	BleedList[308891] = "Jagged Chop"
	BleedList[308938] = "Lacerating Swipe"
	BleedList[309760] = "Raking Claws"
	BleedList[311122] = "Jagged Wound"
	BleedList[311744] = "Deep Wound"
	BleedList[311748] = "Lacerating Swipe"
	BleedList[313674] = "Jagged Wound"
	BleedList[313734] = "Ravaging Leap"
	BleedList[313747] = "Rend"
	BleedList[313957] = "Rend"
	BleedList[314130] = "Skewer"
	BleedList[314160] = "Penetrating Lance"
	BleedList[314454] = "Thrashing Lunge"
	BleedList[314531] = "Tear Flesh"
	BleedList[314568] = "Deep Wound"
	BleedList[314847] = "Decapitate"
	BleedList[314852] = "Rearing Charge"
	BleedList[315311] = "Ravage"
	BleedList[315711] = "Serrated Strike"
	BleedList[315805] = "Crippler"
	BleedList[316511] = "Scratch"
	BleedList[317561] = "Swooping Lunge"
	BleedList[317908] = "Razor Wing"
	BleedList[317916] = "Razor Clip"
	BleedList[318187] = "Gushing Wound"
	BleedList[319127] = "Gore"
	BleedList[319145] = "Rending Maul"
	BleedList[319275] = "Razor Wing"
	BleedList[319821] = "Regal Bite"
	BleedList[320007] = "Gash"
	BleedList[320147] = "Bleeding"
	BleedList[320200] = "Stitchneedle"
	BleedList[320617] = "Thrashing Whirl"
	BleedList[321043] = "Vital Slice"
	BleedList[321538] = "Bloodshed"
	BleedList[321807] = "Boneflay"
	BleedList[322429] = "Severing Slice"
	BleedList[322796] = "Wicked Gash"
	BleedList[322965] = "Tearing Bite"
	BleedList[323043] = "Bloodletting"
	BleedList[323406] = "Jagged Gash"
	BleedList[324073] = "Serrated Bone Spike"
	BleedList[324149] = "Flayed Shot"
	BleedList[324154] = "Dark Stride"
	BleedList[324447] = "Slashing Rend"
	BleedList[325021] = "Mistveil Tear"
	BleedList[325022] = "Jagged Swipe"
	BleedList[325037] = "Death Chakram"
	BleedList[326298] = "Bleeding Wound"
	BleedList[326586] = "Crimson Flurry"
	BleedList[327814] = "Wicked Gash"
	BleedList[328287] = "Heart Strike"
	BleedList[328897] = "Exsanguinated"
	BleedList[328910] = "Tantrum"
	BleedList[328940] = "Gore"
	BleedList[329293] = "Vorpal Wound"
	BleedList[329516] = "Swift Slash"
	BleedList[329563] = "Goring Swipe"
	BleedList[329609] = "Ravage"
	BleedList[329906] = "Carnage"
	BleedList[329986] = "Maul"
	BleedList[329990] = "Craggy Swipe"
	BleedList[330400] = "Bleeding Swipe"
	BleedList[330457] = "Ripping Strike"
	BleedList[330532] = "Jagged Quarrel"
	BleedList[330632] = "Maul"
	BleedList[331045] = "Talon Rake"
	BleedList[331066] = "Bursting Plumage"
	BleedList[331072] = "Talon Rake"
	BleedList[331340] = "Plague Swipe"
	BleedList[331415] = "Wicked Gash"
	BleedList[332168] = "Maul"
	BleedList[332610] = "Penetrating Insight"
	BleedList[332678] = "Gushing Wound"
	BleedList[332792] = "Gore"
	BleedList[332835] = "Ruthless Strikes"
	BleedList[332836] = "Chop"
	BleedList[333235] = "Horn Rush"
	BleedList[333250] = "Reaver"
	BleedList[333478] = "Gut Slice"
	BleedList[333861] = "Ricocheting Blade"
	BleedList[333985] = "Culling Strike"
	BleedList[334669] = "Tirnenn Wrath"
	BleedList[334960] = "Vicious Wound"
	BleedList[334971] = "Jagged Claws"
	BleedList[335105] = "Dinner Time"
	BleedList[336628] = "Eternal Polearm"
	BleedList[336810] = "Ragged Claws"
	BleedList[337349] = "Triple Thrash"
	BleedList[337729] = "Kerim's Laceration"
	BleedList[337892] = "Gore"
	BleedList[338935] = "Razor Petals"
	BleedList[339163] = "Wicked Gash"
	BleedList[339189] = "Chain Bleed"
	BleedList[339453] = "Darksworn Blast"
	BleedList[339789] = "Darksworn Blast"
	BleedList[339975] = "Grievous Strike"
	BleedList[340058] = "Heart Piercer"
	BleedList[340374] = "Bloody Tantrum"
	BleedList[340431] = "Mutilated Flesh"
	BleedList[341435] = "Lunge"
	BleedList[341475] = "Crimson Flurry"
	BleedList[341833] = "Rending Cleave"
	BleedList[341863] = "Bleeding Out"
	BleedList[342250] = "Jagged Swipe"
	BleedList[342391] = "Culling Cleave"
	BleedList[342464] = "Javelin Flurry"
	BleedList[342675] = "Bone Spear"
	BleedList[343159] = "Stone Claws"
	BleedList[343722] = "Crushing Bite"
	BleedList[344312] = "Serrated Edge"
	BleedList[344464] = "Shield Spike"
	BleedList[344993] = "Jagged Swipe"
	BleedList[345548] = "Spare Meat Hook"
	BleedList[346770] = "Grinding Bite"
	BleedList[346807] = "Rending Roar"
	BleedList[346823] = "Furious Cleave"
	BleedList[347227] = "Weighted Blade"
	BleedList[347716] = "Letter Opener"
	BleedList[347744] = "Quickblade"
	BleedList[347807] = "Barbed Arrow"
	BleedList[348074] = "Assailing Lance"
	BleedList[348385] = "Bloody Cleave"
	BleedList[348726] = "Lethal Shot"
	BleedList[350101] = "Chains of Damnation"
	BleedList[351119] = "Shuriken Blitz"
	BleedList[351976] = "Shredder"
	BleedList[353068] = "Razor Trap"
	BleedList[353466] = "Sadistic Glee"
	BleedList[353919] = "Rury's Sleepy Tantrum"
	BleedList[354334] = "Hook'd!"
	BleedList[355087] = "Piercing Quill"
	BleedList[355256] = "Rending Roar"
	BleedList[355416] = "Sharpened Hide"
	BleedList[355832] = "Quickblade"
	BleedList[356445] = "Sharpened Hide"
	BleedList[356620] = "Pouch of Razor Fragments"
	BleedList[356808] = "Spiked"
	BleedList[356923] = "Sever"
	BleedList[356925] = "Carnage"
	BleedList[357091] = "Cleave Flesh"
	BleedList[357192] = "Dark Flurry"
	BleedList[357239] = "Cleave Flesh"
	BleedList[357322] = "Night Glaive"
	BleedList[357665] = "Crystalline Flesh"
	BleedList[357827] = "Frantic Rip"
	BleedList[357938] = "Gnashing Teeth"
	BleedList[357953] = "Fanged Bite"
	BleedList[358197] = "Searing Scythe"
	BleedList[358224] = "Jagged Swipe"
	BleedList[359587] = "Bloody Peck"
	BleedList[359981] = "Rend"
	BleedList[360194] = "Deathmark"
	BleedList[360775] = "Puncture"
	BleedList[360826] = "Rupture"
	BleedList[360830] = "Garrote"
	BleedList[361024] = "Thief's Blade"
	BleedList[361042] = "Hardlight Assassination"
	BleedList[361049] = "Bleeding Gash"
	BleedList[361756] = "Death Chakram"
	BleedList[362149] = "Ascended Phalanx"
	BleedList[362194] = "Suffering"
	BleedList[362819] = "Rend"
	BleedList[363124] = "Hardlight Assassination"
	BleedList[363830] = "Sickle of the Lion"
	BleedList[363831] = "Bleeding Soul"
	BleedList[365336] = "Rending Bite"
	BleedList[365877] = "Jagged Blade"
	BleedList[366075] = "Bloody Peck"
	BleedList[366275] = "Rending Bite"
	BleedList[366884] = "Ripped Secrets"
	BleedList[367481] = "Bloody Bite"
	BleedList[367521] = "Bone Bolt"
	BleedList[367726] = "Lupine's Slash"
	BleedList[368401] = "Puncture"
	BleedList[368637] = "The Third Rune"
	BleedList[368651] = "Vicious Wound"
	BleedList[368701] = "Boon of Harvested Hope"
	BleedList[369408] = "Rending Slash"
	BleedList[369828] = "Chomp"
	BleedList[370742] = "Jagged Strike"
	BleedList[371472] = "Rake"
	BleedList[372224] = "Dragonbone Axe"
	BleedList[372397] = "Vicious Bite"
	BleedList[372404] = "Rend"
	BleedList[372474] = "Bloodletting"
	BleedList[372570] = "Bold Ambush"
	BleedList[372718] = "Earthen Shards"
	BleedList[372796] = "Blazing Rush"
	BleedList[372860] = "Searing Wounds"
	BleedList[373735] = "Dragon Strike"
	BleedList[373947] = "Rending Swipe"
	BleedList[374135] = "Gore"
	BleedList[374865] = "Rending Claw"
	BleedList[374892] = "Gore"
	BleedList[375201] = "Talon Rip"
	BleedList[375416] = "Bleeding"
	BleedList[375420] = "Woodchipper"
	BleedList[375475] = "Rending Bite"
	BleedList[375803] = "Mammoth Trap"
	BleedList[375893] = "Chakram"
	BleedList[375919] = "Severing Slice"
	BleedList[375937] = "Rending Strike"
	BleedList[376997] = "Savage Peck"
	BleedList[376999] = "Thrash"
	BleedList[377002] = "Thrash"
	BleedList[377344] = "Peck"
	BleedList[377609] = "Dragon Rend"
	BleedList[377732] = "Jagged Bite"
	BleedList[377854] = "Throat Gash"
	BleedList[378020] = "Gash Frenzy"
	BleedList[378118] = "Knocked Down"
	BleedList[378957] = "Spearhead"
	BleedList[378995] = "Deadly Rush"
	BleedList[381575] = "Lacerate"
	BleedList[381628] = "Internal Bleeding"
	BleedList[381672] = "Mutilated Flesh"
	BleedList[381692] = "Swift Stab"
	BleedList[384134] = "Pierce"
	BleedList[384148] = "Ensnaring Trap"
	BleedList[384366] = "Talon Rake"
	BleedList[384473] = "Skewer"
	BleedList[384575] = "Crippling Bite"
	BleedList[385042] = "Gushing Wound"
	BleedList[385060] = "Odyn's Fury"
	BleedList[385145] = "Chomp"
	BleedList[385363] = "Gore"
	BleedList[385511] = "Messy"
	BleedList[385638] = "Razor Fragments"
	BleedList[385834] = "Bloodthirsty Charge"
	BleedList[385905] = "Tailstrike"
	BleedList[386116] = "Messy"
	BleedList[386640] = "Tear Flesh"
	BleedList[387049] = "Shredding Bite"
	BleedList[387205] = "Beak Rend"
	BleedList[387473] = "Big Sharp Teeth"
	BleedList[387809] = "Splatter!"
	BleedList[388301] = "Savage Tear"
	BleedList[388377] = "Rending Slash"
	BleedList[388473] = "Feeding Frenzy"
	BleedList[388539] = "Rend"
	BleedList[388745] = "Slicing Claw"
	BleedList[388912] = "Severing Slash"
	BleedList[389505] = "Rending Slice"
	BleedList[389881] = "Spearhead"
	BleedList[390194] = "Rending Slash"
	BleedList[390583] = "Logcutter"
	BleedList[390834] = "Primal Rend"
	BleedList[391098] = "Puncturing Impalement"
	BleedList[391114] = "Cutting Winds"
	BleedList[391140] = "Frenzied Assault"
	BleedList[391308] = "Rending Swoop"
	BleedList[391356] = "Tear"
	BleedList[391725] = "Swooping Dive"
	BleedList[392006] = "Vicious Chomp"
	BleedList[392235] = "Furious Charge"
	BleedList[392236] = "Furious Charge"
	BleedList[392332] = "Horn Gore"
	BleedList[392341] = "Mighty Swipe"
	BleedList[392411] = "Beetle Thrust"
	BleedList[392416] = "Beetle Charge"
	BleedList[392734] = "Raking Slice"
	BleedList[392841] = "Hungry Chomp"
	BleedList[393426] = "Spear Swipe"
	BleedList[393444] = "Gushing Wound"
	BleedList[393718] = "Heartpiercer"
	BleedList[393817] = "Hardened Shards"
	BleedList[393820] = "Horn Swing"
	BleedList[394021] = "Mutilated Flesh"
	BleedList[394036] = "Serrated Bone Spike"
	BleedList[394063] = "Rend"
	BleedList[394371] = "Hit the Mark"
	BleedList[394628] = "Peck"
	BleedList[394647] = "Merciless Gore"
	BleedList[395827] = "Severing Gore"
	BleedList[395832] = "Jagged Cuts"
	BleedList[396007] = "Vicious Peck"
	BleedList[396093] = "Savage Leap"
	BleedList[396348] = "Dismember"
	BleedList[396353] = "Fatal Chomp"
	BleedList[396476] = "Rending Claw"
	BleedList[396639] = "Bloody Pounce"
	BleedList[396641] = "Rending Slash"
	BleedList[396674] = "Rupturing Slash"
	BleedList[396675] = "Hemorrhaging Rend"
	BleedList[396716] = "Splinterbark"
	BleedList[396807] = "Savage Gore"
	BleedList[397037] = "Slicing Winds"
	BleedList[397092] = "Impaling Horn"
	BleedList[397112] = "Primal Devastation"
	BleedList[397364] = "Thunderous Roar"
	BleedList[398392] = "Stomp"
	BleedList[398497] = "Rock Needle"
	BleedList[400050] = "Claw Rip"
	BleedList[400344] = "Spike Traps"
	BleedList[400941] = "Ragged Slash"
	BleedList[401370] = "Deep Claws"
	BleedList[403589] = "Gushing Wound"
	BleedList[403662] = "Garrote"
	BleedList[403790] = "Vicious Swipe"
	BleedList[404907] = "Rupturing Slash"
	BleedList[404945] = "Raking Slice"
	BleedList[404978] = "Devastating Rend"
	BleedList[405233] = "Thrash"
	BleedList[406183] = "Time Slash"
	BleedList[406215] = "Vicious Bite"
	BleedList[406365] = "Rending Charge"
	BleedList[406499] = "Ravening Leaps"
	BleedList[407120] = "Serrated Axe"
	BleedList[407313] = "Shrapnel"
	BleedList[411101] = "Artifact Shards"
	BleedList[411437] = "Brutal Lacerations"
	BleedList[411700] = "Slobbering Bite"
	BleedList[411924] = "Drilljaws"
	BleedList[412172] = "Ceaseless Nibbling"
	BleedList[412285] = "Stonebolt"
	BleedList[412505] = "Rending Cleave"
	BleedList[413131] = "Whirling Dagger"
	BleedList[413136] = "Whirling Dagger"
	BleedList[414340] = "Drenched Blades"
	BleedList[414466] = "Jagged Gills"
	BleedList[414506] = "Lacerate"
	BleedList[414552] = "Stonecrack"
	BleedList[416258] = "Stonebolt"
	BleedList[417751] = "Skewer"
	BleedList[417928] = "Burning Claws"
	BleedList[418009] = "Serrated Arrows"
	BleedList[418160] = "Sawblade-Storm"
	BleedList[418624] = "Rending Slash"
	BleedList[422466] = "Shadow Spines"
	BleedList[422683] = "Thrash"
	BleedList[423431] = "Crushing Blow"
	BleedList[424065] = "Umbral Destruction"
	BleedList[424414] = "Pierce Armor"
	BleedList[424426] = "Lunging Strike"
	BleedList[424493] = "Shadow Rupture"
	BleedList[425555] = "Crude Weapons"
	BleedList[426284] = "Finishing Wound"
	BleedList[426587] = "Bramble Burst"
	BleedList[426660] = "Razor Jaws"
	BleedList[427182] = "Bloody Pounce"
	BleedList[427621] = "Impale"
	BleedList[427635] = "Grievous Rip"
	BleedList[429233] = "Rezan's Fury"
	BleedList[431491] = "Tainted Slash"
	BleedList[432035] = "Slashing Menace"
	BleedList[432416] = "Treacherous Blow"
	BleedList[433825] = "Blood Feast"
	BleedList[434773] = "Mean Mug"
	BleedList[434860] = "Phase Blades"
	BleedList[438599] = "Bleeding Jab"
	BleedList[438975] = "Shredding Sting"
	BleedList[439037] = "Disembowel"
	BleedList[439468] = "Downward Trend"
	BleedList[439531] = "Bloodseeker Vines"
	BleedList[440107] = "Knife Throw"
	BleedList[440143] = "Feral Swipe"
	BleedList[440231] = "Cleaving Strikes"
	BleedList[440912] = "Lash"
	BleedList[441294] = "Jagged Strike"
	BleedList[441314] = "Lacerated Wound"
	BleedList[441413] = "Shredding Sting"
	BleedList[441812] = "Dreadful Wound"
	BleedList[443694] = "Crude Weapons"
	BleedList[443926] = "Ironweave Garrote"
	BleedList[444944] = "Talon Shred"
	BleedList[445184] = "Ambush"
	BleedList[445251] = "Rupturing Bite"
	BleedList[445311] = "Pincer Slice"
	BleedList[445497] = "Shred"
	BleedList[446535] = "Goring Charge"
	BleedList[447268] = "Skullsplitter"
	BleedList[447272] = "Hurl Spear"
	BleedList[448818] = "Scratch"
	BleedList[449585] = "Deep Cut"
	BleedList[449886] = "Deephunter's Bloody Hook"
	BleedList[449960] = "Fresh Cut"
	BleedList[450176] = "Jagged Slash"
	BleedList[450205] = "Clawing Pounce"
	BleedList[451177] = "Dreadful Wound"
	BleedList[451246] = "Jagged Slash"
	BleedList[452730] = "Domineering Gore"
	BleedList[452830] = "Gore Charge"
	BleedList[453031] = "Fury of the Roots"
	BleedList[453461] = "Caltrops"
	BleedList[453551] = "Bloodletting Rend"
	BleedList[453792] = "Brutal Strikes"
	BleedList[453919] = "Blood Frenzy"
	BleedList[453947] = "Jagged Maw"
	BleedList[454357] = "Piercing Spear"
	BleedList[454472] = "Gash Frenzy"
	BleedList[454539] = "Talon Swipe"
	BleedList[454587] = "Serrated Teeth"
	BleedList[454694] = "Headbutt"
	BleedList[454783] = "Devouring Rift"
	BleedList[454922] = "Slashing Claws"
	BleedList[454951] = "Skewer Flesh"
	BleedList[455543] = "Crushing Claws"
	BleedList[455815] = "Harvest Cabbage"
	BleedList[455896] = "Flurry of Steel"
	BleedList[455901] = "Gut Stab"
	BleedList[456145] = "Rake"
	BleedList[456147] = "Vicious Peck"
	BleedList[456265] = "Severing Thrash"
	BleedList[456284] = "Heroic Slash"
	BleedList[456516] = "Berserker Charge"
	BleedList[456851] = "Rock Needle"
	BleedList[457947] = "Limb-shredder Tornado"
	BleedList[458010] = "Deep Wounds"
	BleedList[458409] = "Goring Horn"
	BleedList[458771] = "Ravage"
	BleedList[459495] = "Soul Reaper"
	BleedList[459560] = "Laceration"
	BleedList[459753] = "Ravenous Leap"
	BleedList[459870] = "Merciless Blow"
	BleedList[461850] = "Piercing Fangs"
	BleedList[462018] = "Barbed Bolt"
	BleedList[463227] = "Splintered"
	BleedList[464064] = "Stab of Rubenstein"
	BleedList[464181] = "Bleeding"
	BleedList[464358] = "Rend"
	BleedList[464570] = "Toe-Slash"
	BleedList[465089] = "Shrapnel Blast"
	BleedList[465102] = "Sundering Bash"
	BleedList[465189] = "Grievous Thrashing"
	BleedList[465213] = "Bloody Slash"
	BleedList[465223] = "Blood Tithe"
	BleedList[465240] = "Blood Rush"
	BleedList[465247] = "Leg Rip"
	BleedList[465261] = "Perforate Flesh"
	BleedList[465271] = "Heart Shot"
	BleedList[465326] = "Rend Flesh"
	BleedList[466606] = "Serrated Bite"
	BleedList[467105] = "Ravenous Charge"
	BleedList[468229] = "Slashing Prices"
	BleedList[468457] = "Rend"
	BleedList[468631] = "Harpoon"
	BleedList[468873] = "Thrash"
	BleedList[468885] = "Rip"
	BleedList[468934] = "Rake"
	BleedList[469391] = "Perforating Wound"
	BleedList[469700] = "Stab"
	BleedList[470005] = "Vicious Bite"
	BleedList[470154] = "Latched On"
	BleedList[470241] = "Shred"
	BleedList[470383] = "Talon Shred"
	BleedList[470632] = "Rend"
	BleedList[470695] = "Mech-a-Zoomies"
	BleedList[470903] = "Phantom Strikes"
	BleedList[471076] = "Chomp"
	BleedList[471442] = "Rabid Charge"
	BleedList[471999] = "Rend Flesh"
	BleedList[472196] = "Rending Maul"
	BleedList[472855] = "Shred"
	BleedList[474201] = "Gore"
	BleedList[474271] = "Drillstrike"
	BleedList[1213141] = "Heavy Slash"
	BleedList[1213803] = "Nailed"
	BleedList[1213848] = "Wrecking Ball"
	BleedList[1214068] = "Grievous Bite"
	BleedList[1214653] = "Buzz-Saw"
	BleedList[1215411] = "Puncture"
	BleedList[1216056] = "Talon Shred"
	BleedList[1216467] = "Lacerated"
	BleedList[1217261] = "Screwed!"
	BleedList[1217375] = "Merciless Blow"
	BleedList[1217677] = "Flesh Wound"
	BleedList[1218140] = "Junksaws"
	BleedList[1218302] = "Punctured"
	BleedList[1219535] = "Rift Claws"
	BleedList[1221386] = "Spearhead"
	BleedList[1221475] = "Phantom Step"
	BleedList[1224343] = "Shattered Shards"
	BleedList[1226903] = "Harvesting Slice"
	BleedList[1227293] = "Gushing Wound"
	BleedList[1227962] = "Chomp"
	BleedList[1231311] = "Gore"
	BleedList[1232354] = "Talon Rake"
	BleedList[1235245] = "Ankle Bite"
	BleedList[1237602] = "Gushing Wound"
	BleedList[1239906] = "Phantom Strikes"
	BleedList[1248211] = "Phase Slash"
	BleedList[1253240] = "Corruption of the Engorged"
	BleedList[1255245] = "Twilight Slash"
end

function lib:GetDebuffTypeColor()
	return DebuffColors
end

function lib:GetBleedList()
	return BleedList
end

function lib:GetBadList()
	return BadList
end

function lib:GetBlockList()
	return BlockList
end

function lib:GetMyDispelTypes()
	return DispelList
end

function lib:IsDispellableByMe(debuffType)
	return DispelList[debuffType]
end

do
	local _, myClass = UnitClass("player")
	local WarlockPetSpells = {
		[89808] = "Singe"
	}

	if Classic then
		WarlockPetSpells[19505] = "Devour Magic Rank 1"
		WarlockPetSpells[19731] = "Devour Magic Rank 2"
		WarlockPetSpells[19734] = "Devour Magic Rank 3"
		WarlockPetSpells[19736] = "Devour Magic Rank 4"
		WarlockPetSpells[27276] = "Devour Magic Rank 5"
		WarlockPetSpells[27277] = "Devour Magic Rank 6"
		WarlockPetSpells[48011] = "Devour Magic Rank 7"
	else
		WarlockPetSpells[132411] = "Singe Magic" -- Grimoire of Sacrifice
	end

	local function CheckSpell(spellID, pet)
		return IsSpellInSpellBook(spellID, pet, true) and true or nil
	end

	local function CheckPetSpells()
		for spellID in next, WarlockPetSpells do
			if CheckSpell(spellID, Classic and true or 1) then
				return true
			end
		end
	end

	local function UpdateDispels(_, event, arg1)
		if event == 'CHARACTER_POINTS_CHANGED' and (not arg1 or arg1 > 0) then
			return -- Not interested in gained points from leveling
		end

		-- this will fix a problem where spells dont show as existing because they are 'hidden'
		local undoRanks = (Classic and GetCVar('ShowAllSpellRanks') ~= '1') and SetCVar('ShowAllSpellRanks', '1')

		if event == 'UNIT_PET' then
			DispelList.Magic = CheckPetSpells()
		elseif myClass == 'DRUID' then
			local cure = CheckSpell(88423) -- Nature's Cure Spell
			local corruption = CheckSpell(2782) -- Remove Corruption (retail), Remove Curse (classic)
			DispelList.Magic = cure
			DispelList.Poison = cure or (not Classic and corruption) or CheckSpell(2893) or CheckSpell(8946) -- Abolish Poison / Cure Poison
			DispelList.Curse = cure or corruption
		elseif myClass == 'MAGE' then
			local greater = CheckSpell(412113)
			DispelList.Curse = greater or CheckSpell(475) -- Remove Curse
			DispelList.Magic = greater
		elseif myClass == 'MONK' then
			local mwDetox = CheckSpell(115450) -- Detox (Mistweaver)
			local detox = (not Retail and mwDetox) or (Retail and (CheckSpell(218164) or IsSpellKnown(388874))) -- Detox (Brewmaster or Windwalker) or Improved Detox (Mistweaver)
			DispelList.Magic = mwDetox and (not Mists or CheckSpell(115451))
			DispelList.Disease = detox
			DispelList.Poison = detox
		elseif myClass == 'PALADIN' then
			local cleanse = CheckSpell(4987) -- Cleanse
			local purify = CheckSpell(1152) -- Purify
			local toxins = cleanse or purify or CheckSpell(213644) -- Cleanse Toxins
			DispelList.Magic = cleanse and (not Mists or CheckSpell(53551)) -- Sacred Cleansing
			DispelList.Poison = toxins
			DispelList.Disease = toxins
		elseif myClass == 'PRIEST' then
			local dispel = CheckSpell(527) -- Dispel Magic
			DispelList.Magic = dispel or CheckSpell(32375)
			DispelList.Disease = Retail and (IsSpellKnown(390632) or CheckSpell(213634)) or not Retail and (CheckSpell(552) or CheckSpell(528)) -- Purify Disease / Abolish Disease / Cure Disease
		elseif myClass == 'SHAMAN' then
			local purify = CheckSpell(77130) -- Purify Spirit
			local cleanse = purify or CheckSpell(51886) -- Cleanse Spirit (Retail/Mists)
			local toxins = (Retail and CheckSpell(383013)) or (Classic and CheckSpell(526)) -- Poison Cleansing Totem (Retail), Cure Poison (Classic)
			local cureDisease = Classic and CheckSpell(2870) -- Cure Disease
			local diseaseTotem = Classic and CheckSpell(8170) -- Disease Cleansing Totem

			DispelList.Magic = purify
			DispelList.Curse = cleanse
			DispelList.Poison = toxins
			DispelList.Disease = cureDisease or diseaseTotem
		elseif myClass == 'EVOKER' then
			local naturalize = CheckSpell(360823) -- Naturalize (Preservation)
			local expunge = CheckSpell(365585) -- Expunge (Devastation)
			local cauterizing = CheckSpell(374251) -- Cauterizing Flame
			local scouringFlame = CheckSpell(378438) -- Scouring Flame (PvP Talent)

			DispelList.Magic = naturalize or scouringFlame
			DispelList.Poison = naturalize or expunge or cauterizing
			DispelList.Disease = cauterizing
			DispelList.Curse = cauterizing
			DispelList.Bleed = cauterizing
		end

		if undoRanks then
			SetCVar('ShowAllSpellRanks', '0')
		end
	end

	-- setup events
	if not lib.frame then
		lib.frame = CreateFrame('Frame')
	else -- we are resetting it
		lib.frame:UnregisterAllEvents()
	end

	local frame = lib.frame
	frame:SetScript('OnEvent', UpdateDispels)
	frame:RegisterEvent('CHARACTER_POINTS_CHANGED')
	frame:RegisterEvent('LEARNED_SPELL_IN_TAB')
	frame:RegisterEvent('SPELLS_CHANGED')

	if not Classic then
		frame:RegisterEvent('PLAYER_TALENT_UPDATE')
	end

	if myClass == 'WARLOCK' then
		frame:RegisterUnitEvent('UNIT_PET', 'player')
	end
end


-- ========================================
-- File: WeakAuras/Libs/LibGetFrame-1.0/CallbackHandler-1.0/CallbackHandler-1.0.lua
-- ========================================

--[[ $Id: CallbackHandler-1.0.lua 22 2018-07-21 14:17:22Z nevcairiel $ ]]
local MAJOR, MINOR = "CallbackHandler-1.0", 7
local CallbackHandler = LibStub:NewLibrary(MAJOR, MINOR)

if not CallbackHandler then return end -- No upgrade needed

local meta = {__index = function(tbl, key) tbl[key] = {} return tbl[key] end}

-- Lua APIs
local tconcat = table.concat
local assert, error, loadstring = assert, error, loadstring
local setmetatable, rawset, rawget = setmetatable, rawset, rawget
local next, select, pairs, type, tostring = next, select, pairs, type, tostring

-- Global vars/functions that we don't upvalue since they might get hooked, or upgraded
-- List them here for Mikk's FindGlobals script
-- GLOBALS: geterrorhandler

local xpcall = xpcall

local function errorhandler(err)
	return geterrorhandler()(err)
end

local function Dispatch(handlers, ...)
	local index, method = next(handlers)
	if not method then return end
	repeat
		xpcall(method, errorhandler, ...)
		index, method = next(handlers, index)
	until not method
end

--------------------------------------------------------------------------
-- CallbackHandler:New
--
--   target            - target object to embed public APIs in
--   RegisterName      - name of the callback registration API, default "RegisterCallback"
--   UnregisterName    - name of the callback unregistration API, default "UnregisterCallback"
--   UnregisterAllName - name of the API to unregister all callbacks, default "UnregisterAllCallbacks". false == don't publish this API.

function CallbackHandler:New(target, RegisterName, UnregisterName, UnregisterAllName)

	RegisterName = RegisterName or "RegisterCallback"
	UnregisterName = UnregisterName or "UnregisterCallback"
	if UnregisterAllName==nil then	-- false is used to indicate "don't want this method"
		UnregisterAllName = "UnregisterAllCallbacks"
	end

	-- we declare all objects and exported APIs inside this closure to quickly gain access
	-- to e.g. function names, the "target" parameter, etc


	-- Create the registry object
	local events = setmetatable({}, meta)
	local registry = { recurse=0, events=events }

	-- registry:Fire() - fires the given event/message into the registry
	function registry:Fire(eventname, ...)
		if not rawget(events, eventname) or not next(events[eventname]) then return end
		local oldrecurse = registry.recurse
		registry.recurse = oldrecurse + 1

		Dispatch(events[eventname], eventname, ...)

		registry.recurse = oldrecurse

		if registry.insertQueue and oldrecurse==0 then
			-- Something in one of our callbacks wanted to register more callbacks; they got queued
			for eventname,callbacks in pairs(registry.insertQueue) do
				local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.
				for self,func in pairs(callbacks) do
					events[eventname][self] = func
					-- fire OnUsed callback?
					if first and registry.OnUsed then
						registry.OnUsed(registry, target, eventname)
						first = nil
					end
				end
			end
			registry.insertQueue = nil
		end
	end

	-- Registration of a callback, handles:
	--   self["method"], leads to self["method"](self, ...)
	--   self with function ref, leads to functionref(...)
	--   "addonId" (instead of self) with function ref, leads to functionref(...)
	-- all with an optional arg, which, if present, gets passed as first argument (after self if present)
	target[RegisterName] = function(self, eventname, method, ... --[[actually just a single arg]])
		if type(eventname) ~= "string" then
			error("Usage: "..RegisterName.."(eventname, method[, arg]): 'eventname' - string expected.", 2)
		end

		method = method or eventname

		local first = not rawget(events, eventname) or not next(events[eventname])	-- test for empty before. not test for one member after. that one member may have been overwritten.

		if type(method) ~= "string" and type(method) ~= "function" then
			error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - string or function expected.", 2)
		end

		local regfunc

		if type(method) == "string" then
			-- self["method"] calling style
			if type(self) ~= "table" then
				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): self was not a table?", 2)
			elseif self==target then
				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): do not use Library:"..RegisterName.."(), use your own 'self'", 2)
			elseif type(self[method]) ~= "function" then
				error("Usage: "..RegisterName.."(\"eventname\", \"methodname\"): 'methodname' - method '"..tostring(method).."' not found on self.", 2)
			end

			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
				local arg=select(1,...)
				regfunc = function(...) self[method](self,arg,...) end
			else
				regfunc = function(...) self[method](self,...) end
			end
		else
			-- function ref with self=object or self="addonId" or self=thread
			if type(self)~="table" and type(self)~="string" and type(self)~="thread" then
				error("Usage: "..RegisterName.."(self or \"addonId\", eventname, method): 'self or addonId': table or string or thread expected.", 2)
			end

			if select("#",...)>=1 then	-- this is not the same as testing for arg==nil!
				local arg=select(1,...)
				regfunc = function(...) method(arg,...) end
			else
				regfunc = method
			end
		end


		if events[eventname][self] or registry.recurse<1 then
		-- if registry.recurse<1 then
			-- we're overwriting an existing entry, or not currently recursing. just set it.
			events[eventname][self] = regfunc
			-- fire OnUsed callback?
			if registry.OnUsed and first then
				registry.OnUsed(registry, target, eventname)
			end
		else
			-- we're currently processing a callback in this registry, so delay the registration of this new entry!
			-- yes, we're a bit wasteful on garbage, but this is a fringe case, so we're picking low implementation overhead over garbage efficiency
			registry.insertQueue = registry.insertQueue or setmetatable({},meta)
			registry.insertQueue[eventname][self] = regfunc
		end
	end

	-- Unregister a callback
	target[UnregisterName] = function(self, eventname)
		if not self or self==target then
			error("Usage: "..UnregisterName.."(eventname): bad 'self'", 2)
		end
		if type(eventname) ~= "string" then
			error("Usage: "..UnregisterName.."(eventname): 'eventname' - string expected.", 2)
		end
		if rawget(events, eventname) and events[eventname][self] then
			events[eventname][self] = nil
			-- Fire OnUnused callback?
			if registry.OnUnused and not next(events[eventname]) then
				registry.OnUnused(registry, target, eventname)
			end
		end
		if registry.insertQueue and rawget(registry.insertQueue, eventname) and registry.insertQueue[eventname][self] then
			registry.insertQueue[eventname][self] = nil
		end
	end

	-- OPTIONAL: Unregister all callbacks for given selfs/addonIds
	if UnregisterAllName then
		target[UnregisterAllName] = function(...)
			if select("#",...)<1 then
				error("Usage: "..UnregisterAllName.."([whatFor]): missing 'self' or \"addonId\" to unregister events for.", 2)
			end
			if select("#",...)==1 and ...==target then
				error("Usage: "..UnregisterAllName.."([whatFor]): supply a meaningful 'self' or \"addonId\"", 2)
			end


			for i=1,select("#",...) do
				local self = select(i,...)
				if registry.insertQueue then
					for eventname, callbacks in pairs(registry.insertQueue) do
						if callbacks[self] then
							callbacks[self] = nil
						end
					end
				end
				for eventname, callbacks in pairs(events) do
					if callbacks[self] then
						callbacks[self] = nil
						-- Fire OnUnused callback?
						if registry.OnUnused and not next(callbacks) then
							registry.OnUnused(registry, target, eventname)
						end
					end
				end
			end
		end
	end

	return registry
end


-- CallbackHandler purposefully does NOT do explicit embedding. Nor does it
-- try to upgrade old implicit embeds since the system is selfcontained and
-- relies on closures to work.



-- ========================================
-- File: WeakAuras/Libs/LibGetFrame-1.0/LibGetFrame-1.0.lua
-- ========================================

local MAJOR_VERSION = "LibGetFrame-1.0"
local MINOR_VERSION = 69
if not LibStub then
  error(MAJOR_VERSION .. " requires LibStub.")
end
local lib = LibStub:NewLibrary(MAJOR_VERSION, MINOR_VERSION)
if not lib then
  return
end

lib.callbacks = lib.callbacks or LibStub("CallbackHandler-1.0"):New(lib)
local callbacks = lib.callbacks

local GetPlayerInfoByGUID, UnitExists, C_Timer, UnitIsUnit, SecureButton_GetUnit, C_AddOns =
  GetPlayerInfoByGUID, UnitExists, C_Timer, UnitIsUnit, SecureButton_GetUnit, C_AddOns
local tinsert, CopyTable, wipe = tinsert, CopyTable, wipe

local maxDepth = 50

local defaultFramePriorities = {
  -- raid frames
  "^Vd1", -- vuhdo
  "^Vd2", -- vuhdo
  "^Vd3", -- vuhdo
  "^Vd4", -- vuhdo
  "^Vd5", -- vuhdo
  "^Vd", -- vuhdo
  "^HealBot_HealUnit", -- healbot
  "^hbPet_HealUnit", -- healbot
  "^GridLayout", -- grid
  "^Grid2Layout", -- grid2
  "^NugRaid%d+UnitButton%d+", -- Aptechka
  "^PlexusLayout", -- plexus
  "^ElvUF_Raid%d*Group", -- elv
  "^oUF_bdGrid", -- bdgrid
  "^oUF_.-Raid", -- generic oUF
  "^LimeGroup", -- lime
  "^InvenRaidFrames3Group%dUnitButton", -- InvenRaidFrames3
  "^SUFHeaderraid", -- suf
  "^LUFHeaderraid", -- luf
  "^AshToAshUnit%d+Unit%d+", -- AshToAsh
  "^Cell", -- Cell
  "^XPerl_Raid_Grp", -- xperl
  -- party frames
  "^AleaUI_GroupHeader", -- Alea
  "^SUFHeaderparty", --suf
  "^LUFHeaderparty", --luf
  "^ElvUF_PartyGroup", -- elv
  "^oUF_.-Party", -- generic oUF
  "^PitBull4_Groups_Party", -- pitbull4
  "^XPerl_party%d", -- xperl
  "^CompactRaid", -- blizz
  "^CompactParty", -- blizz
  "^PartyFrame",
  -- boss frames
  "^ElvUF_Boss%d$", -- elv
  "^SUFHeaderbossUnitButton%d$", -- suf
  "^LUFHeaderbossUnitButton%d$", -- luf
  "^Boss%dTargetFrame$", -- blizz
  "^UUF_Boss%d$", -- unhalted
  -- player frame
  "^InvenUnitFrames_Player$",
  "^SUFUnitplayer$",
  "^LUFUnitplayer$",
  "^PitBull4_Frames_Player$",
  "^ElvUF_Player$",
  "^oUF_.-Player$",
  "^XPerl_Player$",
  "^UUF_Player$",
  "^PlayerFrame$",
}
local getDefaultFramePriorities = function()
  return CopyTable(defaultFramePriorities)
end
lib.getDefaultFramePriorities = getDefaultFramePriorities

local defaultPlayerFrames = {
  "^InvenUnitFrames_Player$",
  "^SUFUnitplayer$",
  "^LUFUnitplayer$",
  "^PitBull4_Frames_Player$",
  "^ElvUF_Player$",
  "^oUF_.-Player$",
  "^oUF_PlayerPlate$",
  "^XPerl_Player$",
  "^UUF_Player$",
  "^PlayerFrame$",
}
local getDefaultPlayerFrames = function()
  return CopyTable(defaultPlayerFrames)
end
lib.getDefaultPlayerFrames = getDefaultPlayerFrames
local defaultTargetFrames = {
  "^InvenUnitFrames_Target$",
  "^SUFUnittarget$",
  "^LUFUnittarget$",
  "^PitBull4_Frames_Target$",
  "^ElvUF_Target$",
  "^oUF_.-Target$",
  "^TargetFrame$",
  "^hbExtra_HealUnit$",
  "^UUF_Target$",
  "^XPerl_Target$"
}
local getDefaultTargetFrames = function()
  return CopyTable(defaultTargetFrames)
end
lib.getDefaultTargetFrames = getDefaultTargetFrames
local defaultTargettargetFrames = {
  "^InvenUnitFrames_TargetTarget$",
  "^SUFUnittargettarget$",
  "^LUFUnittargettarget$",
  "^PitBull4_Frames_Target's target$",
  "^ElvUF_TargetTarget$",
  "^oUF_.-TargetTarget$",
  "^oUF_ToT$",
  "^UUF_TargetTarget$",
  "^TargetTargetFrame$",
  "^XPerl_TargetTarget$",
  "^TargetFrameToT$"
}
local getDefaultTargettargetFrames = function()
  return CopyTable(defaultTargettargetFrames)
end
lib.getDefaultTargettargetFrames = getDefaultTargettargetFrames
local defaultPartyFrames = {
  "^InvenUnitFrames_Party%d",
  "^AleaUI_GroupHeader",
  "^SUFHeaderparty",
  "^LUFHeaderparty",
  "^ElvUF_PartyGroup",
  "^oUF_.-Party",
  "^PitBull4_Groups_Party",
  "^XPerl_party%d",
  "^PartyFrame",
  "^CompactParty",
}
local getDefaultPartyFrames = function()
  return CopyTable(defaultPartyFrames)
end
lib.getDefaultPartyFrames = getDefaultPartyFrames
local defaultPartyTargetFrames = {
  "SUFChildpartytarget%d",
  "XPerl_party%dtargetFrame"
}
local getDefaultPartyTargetFrames = function()
  return CopyTable(defaultPartyTargetFrames)
end
lib.getDefaultPartyTargetFrames = getDefaultPartyTargetFrames
local defaultFocusFrames = {
  "^InvenUnitFrames_Focus$",
  "^ElvUF_FocusTarget$",
  "^SUFUnitfocus$",
  "^LUFUnitfocus$",
  "^FocusFrame$",
  "^hbExtra_HealUnit$",
  "^UUF_Focus$",
  "^XPerl_Focus$"
}
local getDefaultFocusFrames = function()
  return CopyTable(defaultFocusFrames)
end
lib.getDefaultFocusFrames = getDefaultFocusFrames
local defaultRaidFrames = {
  "^Vd",
  "^HealBot_HealUnit",
  "^hbPet_HealUnit",
  "^GridLayout",
  "^Grid2Layout",
  "^PlexusLayout",
  "^InvenRaidFrames3Group%dUnitButton",
  "^ElvUF_Raid%d*Group",
  "^oUF_.-Raid",
  "^AshToAsh",
  "^Cell",
  "^LimeGroup",
  "^SUFHeaderraid",
  "^LUFHeaderraid",
  "^XPerl_Raid_Grp",
  "^CompactRaid",
}
local getDefaultRaidFrames = function()
  return CopyTable(defaultRaidFrames)
end
lib.getDefaultRaidFrames = getDefaultRaidFrames
local defaultBossFrames = {
  "^ElvUF_Boss%d$",
  "^SUFHeaderbossUnitButton%d$",
  "^LUFHeaderbossUnitButton%d$",
  "^UUF_Boss%d$",
  "^Boss%dTargetFrame$",
}
local getDefaultBossFrames = function()
  return CopyTable(defaultBossFrames)
end
lib.getDefaultBossFrames = getDefaultBossFrames

--
local CacheMonitorMixin = {}
function CacheMonitorMixin:Init(makeDiff)
  self.data = {}
  self.cache = {}
  if makeDiff then
    self.makeDiff = makeDiff
    self.added = {}
    self.updated = {}
    self.removed = {}
  end
end
-- fill cache, added, updated
function CacheMonitorMixin:Add(key, ...)
  local args = select("#", ...)
  if args > 1 then
    if self.makeDiff then
      if type(self.data[key]) == "table" then
        for i = 1, args do
          local arg = select(i, ...)
          if self.data[key][i] ~= arg then
            self.updated[key] = self.data[key]
            break
          end
        end
      else
        self.added[key] = true
      end
    end
    self.cache[key] = {...}
  else
    local value = ...
    if self.makeDiff then
      if self.data[key] ~= value then
        if self.data[key] == nil then
          self.added[key] = true
        else
          self.updated[key] = self.data[key]
        end
      end
    end
    self.cache[key] = value
  end
end
function CacheMonitorMixin:CalcRemoved()
  if not self.makeDiff then return end
  for key, value in pairs(self.data) do
    if self.cache[key] == nil then
      self.removed[key] = value
    end
  end
end
function CacheMonitorMixin:WriteCache()
  local tmp = self.data
  self.data = self.cache
  self.cache = tmp
  wipe(self.cache)
end
function CacheMonitorMixin:Reset()
  if self.makeDiff then
    wipe(self.updated)
    wipe(self.removed)
    wipe(self.added)
  end
end
--
local FrameToFrameName = {}   -- frame adress => frame name
local FrameToUnit = {}        -- frame adress => unitToken
Mixin(FrameToFrameName, CacheMonitorMixin)
Mixin(FrameToUnit, CacheMonitorMixin)
FrameToFrameName:Init()
FrameToUnit:Init(true)

local profiling = false
local profileData

local function doNothing()
end

local StartProfiling = doNothing
local StopProfiling = doNothing

local function _StartProfiling(id)
  if not profileData[id] then
    profileData[id] = {}
    profileData[id].count = 1
    profileData[id].start = debugprofilestop()
    profileData[id].elapsed = 0
    profileData[id].spike = 0
    return
  end

  if profileData[id].count == 0 then
    profileData[id].count = 1
    profileData[id].start = debugprofilestop()
  else
    profileData[id].count = profileData[id].count + 1
  end
end

local function _StopProfiling(id)
  profileData[id].count = profileData[id].count - 1
  if profileData[id].count == 0 then
    local elapsed = debugprofilestop() - profileData[id].start
    profileData[id].elapsed = profileData[id].elapsed + elapsed
    if elapsed > profileData[id].spike then
      profileData[id].spike = elapsed
    end
  end
end

function lib.StartProfile()
  if profiling then
    print(MAJOR_VERSION, " (StartProfile) Profiling already started")
    return false
  end
  profiling = true
  profileData = {}
  StartProfiling = _StartProfiling
  StopProfiling = _StopProfiling
end

function lib.StopProfile()
  if not profiling then
    print(MAJOR_VERSION, " (StopProfile) Profiling not running")
    return false
  end
  profiling = false
  StartProfiling = doNothing
  StopProfiling = doNothing
end

function lib.GetProfileData()
  return profileData or {}
end

-- if frame doesn't have a name, try to use the key from it's parent
local function recurseGetName(frame)
  local name = frame.GetName and frame:GetName() or nil
  if name then
    return name
  end
  local parent = frame.GetParent and frame:GetParent()
  if parent then
    local parentKey = frame.GetParentKey and frame:GetParentKey()
    if not parentKey then
      for key, child in pairs(parent) do
        if child == frame then
          parentKey = key
          break
        end
      end
    end
    if parentKey then
      return (recurseGetName(parent) or "") .. "." .. parentKey
    end
  end
end

local notAUnitFrameTypeAttribute = {
  cancelaura = true
}

local function ScanFrames(depth, frame, ...)
  coroutine.yield()
  if not frame then
    return
  end
  if depth < maxDepth and frame.IsForbidden and not frame:IsForbidden() then
    local frameType = frame:GetObjectType()
    if frameType == "Frame" or frameType == "Button" then
      ScanFrames(depth + 1, frame:GetChildren())
    end
    if frameType == "Button" then
      local typeAttribute = frame:GetAttribute("type")
      if not notAUnitFrameTypeAttribute[typeAttribute] then
        local unit = SecureButton_GetUnit(frame)
        if unit and frame:IsVisible() then
          local name = recurseGetName(frame)
          if name then
            FrameToFrameName:Add(frame, name)
            FrameToUnit:Add(frame, unit)
          end
        end
      end
    end
  end
  ScanFrames(depth, ...)
end

local status = "ready"
local co
local coroutineFrame = CreateFrame("Frame")
coroutineFrame:Hide()

local function doScanForUnitFrames()
  if not coroutineFrame:IsShown() then
    status = "scanning"
    co = coroutine.create(ScanFrames)
    coroutineFrame:Show()
  end
end

coroutineFrame:SetScript("OnUpdate", function()
  local start = debugprofilestop()
  -- Limit to 5ms per frame
  StartProfiling("scan frames")
  while debugprofilestop() - start < 5 and coroutine.status(co) ~= "dead" do
    coroutine.resume(co, 0, UIParent)
  end
  StopProfiling("scan frames")
  if coroutine.status(co) == "dead" then
    StartProfiling("callbacks")
    FrameToFrameName:WriteCache()
    FrameToUnit:CalcRemoved()
    FrameToUnit:WriteCache()
    StartProfiling("callback GETFRAME_REFRESH")
    callbacks:Fire("GETFRAME_REFRESH")
    StopProfiling("callback GETFRAME_REFRESH")
    -- FrameToUnit
    if next(FrameToUnit.added) then
      StartProfiling("callback FRAME_UNIT_ADDED")
      for frame in pairs(FrameToUnit.added) do
        callbacks:Fire("FRAME_UNIT_ADDED", frame, FrameToUnit.data[frame])
      end
      StopProfiling("callback FRAME_UNIT_ADDED")
    end
    if next(FrameToUnit.updated) then
      StartProfiling("callback FRAME_UNIT_UPDATE")
      for frame, previousUnit in pairs(FrameToUnit.updated) do
        callbacks:Fire("FRAME_UNIT_UPDATE", frame, FrameToUnit.data[frame], previousUnit)
      end
      StopProfiling("callback FRAME_UNIT_UPDATE")
    end
    if next(FrameToUnit.removed) then
      StartProfiling("callback FRAME_UNIT_REMOVED")
      for frame, unit in pairs(FrameToUnit.removed) do
        callbacks:Fire("FRAME_UNIT_REMOVED", frame, unit)
      end
      StopProfiling("callback FRAME_UNIT_REMOVED")
    end
    coroutineFrame:Hide()
    FrameToFrameName:Reset()
    FrameToUnit:Reset()
    StopProfiling("callbacks")
    if status == "scan_queued" then
      doScanForUnitFrames("queued")
    else
      status = "ready"
    end
  end
end)

local function ScanForUnitFrames(noDelay)
  if status == "ready" then
    if noDelay then
      doScanForUnitFrames()
    else
      status = "scan_delay"
      C_Timer.After(1, function()
        doScanForUnitFrames()
      end)
    end
  elseif status == "scanning" then
    status = "scan_queued"
  end
end

function lib.ScanForUnitFrames()
  ScanForUnitFrames(true)
end

local function isFrameFiltered(name, ignoredFrames)
  for _, filter in pairs(ignoredFrames) do
    if name:find(filter) then
      return true
    end
  end
  return false
end

local function GetUnitFrames(target, ignoredFrames)
  if not UnitExists(target) then
    if type(target) ~= "string" then
      return
    end
    if target:find("Player") then
      target = select(6, GetPlayerInfoByGUID(target))
    else
      target = target:gsub(" .*", "")
    end
    if not UnitExists(target) then
      return
    end
  end

  local frames
  for frame, frameName in pairs(FrameToFrameName.data) do
    local unit = SecureButton_GetUnit(frame)
    if unit and UnitIsUnit(unit, target) and not isFrameFiltered(frameName, ignoredFrames) then
      frames = frames or {}
      frames[frame] = frameName
    end
  end
  return frames
end

local function ElvuiWorkaround(frame)
  if C_AddOns.IsAddOnLoaded("ElvUI") and frame and frame:GetName() and frame:GetName():find("^ElvUF_") and frame.Health then
    return frame.Health
  else
    return frame
  end
end

local function CellGetUnitFrames(target, frames, framePriorities)
  if not C_AddOns.IsAddOnLoaded("Cell") or not Cell.GetUnitFramesForLGF then
    return frames
  end
  return Cell.GetUnitFramesForLGF(target, frames, framePriorities)
end

local defaultOptions = {
  framePriorities = defaultFramePriorities,
  ignorePlayerFrame = true,
  ignoreTargetFrame = true,
  ignoreTargettargetFrame = true,
  ignorePartyFrame = false,
  ignorePartyTargetFrame = true,
  ignoreFocusFrame = true,
  ignoreRaidFrame = false,
  ignoreBossFrame = false,
  playerFrames = defaultPlayerFrames,
  targetFrames = defaultTargetFrames,
  targettargetFrames = defaultTargettargetFrames,
  partyFrames = defaultPartyFrames,
  partyTargetFrames = defaultPartyTargetFrames,
  focusFrames = defaultFocusFrames,
  raidFrames = defaultRaidFrames,
  bossFrames = defaultBossFrames,
  ignoreFrames = {
    "PitBull4_Frames_Target's target's target",
    "ElvUF_PartyGroup%dUnitButton%dTarget",
    "RavenOverlay",
    "AshToAshUnit%d+ShadowGroupHeaderUnitButton%d+",
    "InvenUnitFrames_TargetTargetTarget",
    "CellQuickCastButton",
  },
  skipCellOverrides = false,
  returnAll = false,
}
local getDefaultOptions = function()
  return CopyTable(defaultOptions)
end
lib.getDefaultOptions = getDefaultOptions

local IterateGroupMembers = function(reversed, forceParty)
  local unit = (not forceParty and IsInRaid()) and 'raid' or 'party'
  local numGroupMembers = unit == 'party' and GetNumSubgroupMembers() or GetNumGroupMembers()
  local i = reversed and numGroupMembers or (unit == 'party' and 0 or 1)
  return function()
    local ret
    if i == 0 and unit == 'party' then
      ret = 'player'
    elseif i <= numGroupMembers and i > 0 then
      ret = unit .. i
    end
    i = i + (reversed and -1 or 1)
    return ret
  end
end

local unitPetState = {} -- track if unit's pet exists

local saveGetUnitFrame
local function fixGetUnitFrameIntegrity()
  lib.GetUnitFrame = saveGetUnitFrame
  lib.GetFrame = saveGetUnitFrame
  if WeakAuras and WeakAuras.GetUnitFrame then
    WeakAuras.GetUnitFrame = saveGetUnitFrame
  end
end

local GetFramesCacheListener
local function Init(noDelay)
  GetFramesCacheListener = CreateFrame("Frame")
  GetFramesCacheListener:RegisterEvent("PLAYER_REGEN_DISABLED")
  GetFramesCacheListener:RegisterEvent("PLAYER_REGEN_ENABLED")
  GetFramesCacheListener:RegisterEvent("PLAYER_ENTERING_WORLD")
  GetFramesCacheListener:RegisterEvent("GROUP_ROSTER_UPDATE")
  GetFramesCacheListener:RegisterEvent("UNIT_PET")
  GetFramesCacheListener:RegisterEvent("INSTANCE_ENCOUNTER_ENGAGE_UNIT")
  GetFramesCacheListener:SetScript("OnEvent", function(self, event, unit, ...)
    fixGetUnitFrameIntegrity()
    if event == "GROUP_ROSTER_UPDATE" then
      wipe(unitPetState)
      for member in IterateGroupMembers() do
        unitPetState[member] = UnitExists(member .. "pet") and true or nil
      end
    end
    if event == "UNIT_PET" then
      if not (UnitIsUnit("player", unit) or UnitInParty(unit) or UnitInRaid(unit)) then
        return
      end
      -- skip if unit's pet existance has not changed
      local exists = UnitExists(unit .. "pet") and true or nil
      if unitPetState[unit] == exists then
        return
      else
        unitPetState[unit] = exists
      end
    end
    ScanForUnitFrames(false)
  end)
  ScanForUnitFrames(noDelay)
end

function lib.GetUnitFrame(target, opt)
  if type(GetFramesCacheListener) ~= "table" then
    Init(true)
  end
  local defaultOpt
  if not opt then
    opt = {}
    defaultOpt = true
  end
  setmetatable(opt, { __index = defaultOptions })

  if not target then
    return
  end

  local ignoredFrames = CopyTable(opt.ignoreFrames)
  if opt.ignorePlayerFrame then
    for _, v in pairs(opt.playerFrames) do
      tinsert(ignoredFrames, v)
    end
  end
  if opt.ignoreTargetFrame and not (defaultOpt and target == "target") then
    for _, v in pairs(opt.targetFrames) do
      tinsert(ignoredFrames, v)
    end
  end
  if opt.ignoreTargettargetFrame and not (defaultOpt and target == "targettarget") then
    for _, v in pairs(opt.targettargetFrames) do
      tinsert(ignoredFrames, v)
    end
  end
  if opt.ignorePartyFrame then
    for _, v in pairs(opt.partyFrames) do
      tinsert(ignoredFrames, v)
    end
  end
  if opt.ignorePartyTargetFrame then
    for _, v in pairs(opt.partyTargetFrames) do
      tinsert(ignoredFrames, v)
    end
  end
  if opt.ignoreFocusFrame and not (defaultOpt and target == "focus") then
    for _, v in pairs(opt.focusFrames) do
      tinsert(ignoredFrames, v)
    end
  end
  if opt.ignoreRaidFrame then
    for _, v in pairs(opt.raidFrames) do
      tinsert(ignoredFrames, v)
    end
  end
  if opt.ignoreBossFrame then
    for _, v in pairs(opt.bossFrames) do
      tinsert(ignoredFrames, v)
    end
  end

  local frames = GetUnitFrames(target, ignoredFrames)

  if not (opt.ignoreRaidFrame or opt.skipCellOverrides) then
    frames = CellGetUnitFrames(target, frames, opt.framePriorities)
  end

  if not frames then
    return
  end

  if not opt.returnAll then
    for i = 1, #opt.framePriorities do
      for frame, frameName in pairs(frames) do
        if frameName:find(opt.framePriorities[i]) then
          return ElvuiWorkaround(frame)
        end
      end
    end
    local next = next
    return ElvuiWorkaround(next(frames))
  else
    for frame in pairs(frames) do
      frames[frame] = ElvuiWorkaround(frame)
    end
    return frames
  end
end
saveGetUnitFrame = lib.GetUnitFrame
lib.GetFrame = lib.GetUnitFrame -- compatibility

-- nameplates
function lib.GetUnitNameplate(unit)
  if not unit then
    return
  end
  local nameplate = C_NamePlate.GetNamePlateForUnit(unit)
  if nameplate then
    -- credit to Exality for https://wago.io/explosiveorbs
    if nameplate.unitFrame and nameplate.unitFrame.Health then
      -- elvui
      return nameplate.unitFrame.Health
    elseif nameplate.unitFramePlater then
      -- plater
      -- use plater anchor frame (with fallback options).
      return nameplate.PlaterAnchorFrame or nameplate.unitFramePlater.healthBar or (nameplate.UnitFrame and nameplate.UnitFrame.healthBar) or nameplate
    elseif nameplate.kui and nameplate.kui.HealthBar then
      -- kui
      return nameplate.kui.HealthBar
    elseif nameplate.extended and nameplate.extended.visual and nameplate.extended.visual.healthbar then
      -- tidyplates
      return nameplate.extended.visual.healthbar
    elseif nameplate.TPFrame and nameplate.TPFrame.visual and nameplate.TPFrame.visual.healthbar then
      -- tidyplates: threat plates
      return nameplate.TPFrame.visual.healthbar
    elseif nameplate.unitFrame and nameplate.unitFrame.Health then
      -- bdui nameplates
      return nameplate.unitFrame.Health
    elseif nameplate.ouf and nameplate.ouf.Health then
      -- bdNameplates
      return nameplate.ouf.Health
    elseif nameplate.slab and nameplate.slab.components and nameplate.slab.components.healthBar and nameplate.slab.components.healthBar.frame then
      -- Slab
      return nameplate.slab.components.healthBar.frame
    elseif nameplate.UnitFrame and nameplate.UnitFrame.healthBar then
      -- default
      return nameplate.UnitFrame.healthBar
    else
      return nameplate
    end
  end
end


-- ========================================
-- File: WeakAuras/Libs/LibGetFrame-1.0/LibStub/LibStub.lua
-- ========================================

-- $Id: LibStub.lua 103 2014-10-16 03:02:50Z mikk $
-- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/addons/libstub/ for more info
-- LibStub is hereby placed in the Public Domain
-- Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 2  -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
local LibStub = _G[LIBSTUB_MAJOR]

-- Check to see is this version of the stub is obsolete
if not LibStub or LibStub.minor < LIBSTUB_MINOR then
	LibStub = LibStub or {libs = {}, minors = {} }
	_G[LIBSTUB_MAJOR] = LibStub
	LibStub.minor = LIBSTUB_MINOR
	
	-- LibStub:NewLibrary(major, minor)
	-- major (string) - the major version of the library
	-- minor (string or number ) - the minor version of the library
	-- 
	-- returns nil if a newer or same version of the lib is already present
	-- returns empty library object or old library object if upgrade is needed
	function LibStub:NewLibrary(major, minor)
		assert(type(major) == "string", "Bad argument #2 to `NewLibrary' (string expected)")
		minor = assert(tonumber(strmatch(minor, "%d+")), "Minor version must either be a number or contain a number.")
		
		local oldminor = self.minors[major]
		if oldminor and oldminor >= minor then return nil end
		self.minors[major], self.libs[major] = minor, self.libs[major] or {}
		return self.libs[major], oldminor
	end
	
	-- LibStub:GetLibrary(major, [silent])
	-- major (string) - the major version of the library
	-- silent (boolean) - if true, library is optional, silently return nil if its not found
	--
	-- throws an error if the library can not be found (except silent is set)
	-- returns the library object if found
	function LibStub:GetLibrary(major, silent)
		if not self.libs[major] and not silent then
			error(("Cannot find a library instance of %q."):format(tostring(major)), 2)
		end
		return self.libs[major], self.minors[major]
	end
	
	-- LibStub:IterateLibraries()
	-- 
	-- Returns an iterator for the currently registered libraries
	function LibStub:IterateLibraries() 
		return pairs(self.libs) 
	end
	
	setmetatable(LibStub, { __call = LibStub.GetLibrary })
end


-- ========================================
-- File: WeakAuras/Libs/LibGetFrame-1.0/LibStub/tests/test.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()

local lib, oldMinor = LibStub:NewLibrary("Pants", 1) -- make a new thingy
assert(lib) -- should return the library table
assert(not oldMinor) -- should not return the old minor, since it didn't exist

-- the following is to create data and then be able to check if the same data exists after the fact
function lib:MyMethod()
end
local MyMethod = lib.MyMethod
lib.MyTable = {}
local MyTable = lib.MyTable

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 1) -- try to register a library with the same version, should silently fail
assert(not newLib) -- should not return since out of date

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 0) -- try to register a library with a previous, should silently fail
assert(not newLib) -- should not return since out of date

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 2) -- register a new version
assert(newLib) -- library table
assert(rawequal(newLib, lib)) -- should be the same reference as the previous
assert(newOldMinor == 1) -- should return the minor version of the previous version

assert(rawequal(lib.MyMethod, MyMethod)) -- verify that values were saved
assert(rawequal(lib.MyTable, MyTable)) -- verify that values were saved

local newLib, newOldMinor = LibStub:NewLibrary("Pants", "Blah 3 Blah") -- register a new version with a string minor version (instead of a number)
assert(newLib) -- library table
assert(newOldMinor == 2) -- previous version was 2

local newLib, newOldMinor = LibStub:NewLibrary("Pants", "Blah 4 and please ignore 15 Blah") -- register a new version with a string minor version (instead of a number)
assert(newLib)
assert(newOldMinor == 3) -- previous version was 3 (even though it gave a string)

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 5) -- register a new library, using a normal number instead of a string
assert(newLib)
assert(newOldMinor == 4) -- previous version was 4 (even though it gave a string)

-- ========================================
-- File: WeakAuras/Libs/LibGetFrame-1.0/LibStub/tests/test2.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()

for major, library in LibStub:IterateLibraries() do
	-- check that MyLib doesn't exist yet, by iterating through all the libraries
	assert(major ~= "MyLib")
end

assert(not LibStub:GetLibrary("MyLib", true)) -- check that MyLib doesn't exist yet by direct checking
assert(not pcall(LibStub.GetLibrary, LibStub, "MyLib")) -- don't silently fail, thus it should raise an error.
local lib = LibStub:NewLibrary("MyLib", 1) -- create the lib
assert(lib) -- check it exists
assert(rawequal(LibStub:GetLibrary("MyLib"), lib)) -- verify that :GetLibrary("MyLib") properly equals the lib reference

assert(LibStub:NewLibrary("MyLib", 2))	-- create a new version

local count=0
for major, library in LibStub:IterateLibraries() do
	-- check that MyLib exists somewhere in the libraries, by iterating through all the libraries
	if major == "MyLib" then -- we found it!
		count = count +1
		assert(rawequal(library, lib)) -- verify that the references are equal
	end
end
assert(count == 1) -- verify that we actually found it, and only once


-- ========================================
-- File: WeakAuras/Libs/LibGetFrame-1.0/LibStub/tests/test3.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()

local proxy = newproxy() -- non-string

assert(not pcall(LibStub.NewLibrary, LibStub, proxy, 1)) -- should error, proxy is not a string, it's userdata
local success, ret = pcall(LibStub.GetLibrary, proxy, true)
assert(not success or not ret) -- either error because proxy is not a string or because it's not actually registered.

assert(not pcall(LibStub.NewLibrary, LibStub, "Something", "No number in here")) -- should error, minor has no string in it.

assert(not LibStub:GetLibrary("Something", true)) -- shouldn't've created it from the above statement

-- ========================================
-- File: WeakAuras/Libs/LibGetFrame-1.0/LibStub/tests/test4.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()


-- Pretend like loaded libstub is old and doesn't have :IterateLibraries
assert(LibStub.minor)
LibStub.minor = LibStub.minor - 0.0001
LibStub.IterateLibraries = nil

loadfile("../LibStub.lua")()

assert(type(LibStub.IterateLibraries)=="function")


-- Now pretend that we're the same version -- :IterateLibraries should NOT be re-created
LibStub.IterateLibraries = 123

loadfile("../LibStub.lua")()

assert(LibStub.IterateLibraries == 123)


-- Now pretend that a newer version is loaded -- :IterateLibraries should NOT be re-created
LibStub.minor = LibStub.minor + 0.0001

loadfile("../LibStub.lua")()

assert(LibStub.IterateLibraries == 123)


-- Again with a huge number
LibStub.minor = LibStub.minor + 1234567890

loadfile("../LibStub.lua")()

assert(LibStub.IterateLibraries == 123)


print("OK")

-- ========================================
-- File: WeakAuras/Libs/LibRangeCheck-3.0/LibRangeCheck-3.0.lua
-- ========================================

--[[
Name: LibRangeCheck-3.0
Author(s): mitch0, WoWUIDev Community
Website: https://www.curseforge.com/wow/addons/librangecheck-3-0
Description: A range checking library based on interact distances and spell ranges
Dependencies: LibStub
License: MIT
]]

--- LibRangeCheck-3.0 provides an easy way to check for ranges and get suitable range checking functions for specific ranges.\\
-- The checkers use spell and item range checks, or interact based checks for special units where those two cannot be used.\\
-- The lib handles the refreshing of checker lists in case talents / spells change and in some special cases when equipment changes (for example some of the mage pvp gloves change the range of the Fire Blast spell), and also handles the caching of items used for item-based range checks.\\
-- A callback is provided for those interested in checker changes.
-- @usage
-- local rc = LibStub("LibRangeCheck-3.0")
--
-- rc.RegisterCallback(self, rc.CHECKERS_CHANGED, function() print("need to refresh my stored checkers") end)
--
-- local minRange, maxRange = rc:GetRange('target')
-- if not minRange then
--     print("cannot get range estimate for target")
-- elseif not maxRange then
--     print("target is over " .. minRange .. " yards")
-- else
--     print("target is between " .. minRange .. " and " .. maxRange .. " yards")
-- end
--
-- local meleeChecker = rc:GetFriendMaxChecker(rc.MeleeRange) or rc:GetFriendMinChecker(rc.MeleeRange) -- use the closest checker (MinChecker) if no valid Melee checker is found
-- for i = 1, 4 do
--     -- TODO: check if unit is valid, etc
--     if meleeChecker("party" .. i) then
--         print("Party member " .. i .. " is in Melee range")
--     end
-- end
--
-- local safeDistanceChecker = rc:GetHarmMinChecker(30)
-- -- negate the result of the checker!
-- local isSafelyAway = not safeDistanceChecker('target')
--
-- @class file
-- @name LibRangeCheck-3.0
local MAJOR_VERSION = "LibRangeCheck-3.0"
local MINOR_VERSION = 28

---@class lib
local lib, oldminor = LibStub:NewLibrary(MAJOR_VERSION, MINOR_VERSION)
if not lib then
  return
end

local isRetail = WOW_PROJECT_ID == WOW_PROJECT_MAINLINE
local isEra = WOW_PROJECT_ID == WOW_PROJECT_CLASSIC
local isCata = WOW_PROJECT_ID == WOW_PROJECT_CATACLYSM_CLASSIC

local InCombatLockdownRestriction = function(unit) return InCombatLockdown() and not UnitCanAttack("player", unit) end

local _G = _G
local next = next
local sort = sort
local type = type
local wipe = wipe
local print = print
local pairs = pairs
local ipairs = ipairs
local tinsert = tinsert
local tremove = tremove
local tostring = tostring
local setmetatable = setmetatable
local BOOKTYPE_SPELL = BOOKTYPE_SPELL or Enum.SpellBookSpellBank.Player
local GetSpellBookItemName = GetSpellBookItemName or C_SpellBook.GetSpellBookItemName
local C_Item = C_Item
local UnitCanAttack = UnitCanAttack
local UnitCanAssist = UnitCanAssist
local UnitExists = UnitExists
local UnitIsUnit = UnitIsUnit
local UnitGUID = UnitGUID
local UnitIsDeadOrGhost = UnitIsDeadOrGhost
local CheckInteractDistance = CheckInteractDistance
local IsSpellBookItemInRange = _G.IsSpellInRange or function(index, spellBank, unit)
  local result = C_Spell.IsSpellInRange(index, unit)
  if result == true then
    return 1
  elseif result == false then
    return 0
  end
  return nil
end
local spellTypes = {"SPELL", "FUTURESPELL", "PETACTION", "FLYOUT"}
local GetSpellBookItemInfo = _G.GetSpellBookItemInfo or function(index, spellBank)
  if type(spellBank) == "string" then
    spellBank = (spellBank == "spell") and Enum.SpellBookSpellBank.Player or Enum.SpellBookSpellBank.Pet;
  end
  local info = C_SpellBook.GetSpellBookItemInfo(index, spellBank)
  --map spell-type
  if info and spellTypes[info.itemType or 0] then
    return spellTypes[info.itemType or 0] or "None", info.spellID, info
  end
end
local UnitClass = UnitClass
local UnitRace = UnitRace
local GetInventoryItemLink = GetInventoryItemLink
local GetTime = GetTime
local HandSlotId = GetInventorySlotInfo("HANDSSLOT")
local math_floor = math.floor
local UnitIsVisible = UnitIsVisible

local GetSpellInfo = GetSpellInfo or function(spellID)
  if not spellID then
    return nil;
  end

  local spellInfo = C_Spell.GetSpellInfo(spellID);
  if spellInfo then
    return spellInfo.name, nil, spellInfo.iconID, spellInfo.castTime, spellInfo.minRange, spellInfo.maxRange, spellInfo.spellID, spellInfo.originalIconID;
  end
end

local GetNumSpellTabs = GetNumSpellTabs or C_SpellBook.GetNumSpellBookSkillLines
local GetSpellTabInfo = GetSpellTabInfo or function(index)
  local skillLineInfo = C_SpellBook.GetSpellBookSkillLineInfo(index);
  if skillLineInfo then
    return skillLineInfo.name,
        skillLineInfo.iconID,
        skillLineInfo.itemIndexOffset,
        skillLineInfo.numSpellBookItems,
        skillLineInfo.isGuild,
        skillLineInfo.offSpecID,
        skillLineInfo.shouldHide,
        skillLineInfo.specID;
  end
end

-- << STATIC CONFIG

local UpdateDelay = 0.5
local ItemRequestTimeout = 10.0

-- interact distance based checks. ranges are based on my own measurements (thanks for all the folks who helped me with this)
local DefaultInteractList = {
  --  [1] = 28, -- Compare Achievements
  --  [2] = 9,  -- Trade
  [3] = 8, -- Duel
  [4] = 28, -- Follow
  --  [5] = 7,  -- unknown
}

-- interact list overrides for races
local InteractLists = {
  Tauren = {
    --  [2] = 7,
    [3] = 6,
    [4] = 25,
  },
  Scourge = {
    --  [2] = 8,
    [3] = 7,
    [4] = 27,
  },
}

local MeleeRange = 2
local FriendSpells, HarmSpells, ResSpells, PetSpells = {}, {}, {}, {}

for _, n in ipairs({ "EVOKER", "DEATHKNIGHT", "DEMONHUNTER", "DRUID", "HUNTER", "SHAMAN", "MAGE", "PALADIN", "PRIEST", "WARLOCK", "WARRIOR", "MONK", "ROGUE" }) do
  FriendSpells[n], HarmSpells[n], ResSpells[n], PetSpells[n] = {}, {}, {}, {}
end

-- Evoker
tinsert(HarmSpells.EVOKER, 362969) -- Azure Strike (25 yards)

tinsert(FriendSpells.EVOKER, 355913) -- Emerald Blossom (25 yards)
tinsert(FriendSpells.EVOKER, 361469) -- Living Flame (25 yards)
tinsert(FriendSpells.EVOKER, 360823) -- Naturalize (Preservation) (30 yards)

tinsert(ResSpells.EVOKER, 361227) -- Return (40 yards)

-- Death Knights
tinsert(HarmSpells.DEATHKNIGHT, 49576) -- Death Grip (30 yards)
tinsert(HarmSpells.DEATHKNIGHT, 47541) -- Death Coil (Unholy) (40 yards)

tinsert(ResSpells.DEATHKNIGHT, 61999) -- Raise Ally (40 yards)

-- Demon Hunters
tinsert(HarmSpells.DEMONHUNTER, 185123) -- Throw Glaive (Havoc) (30 yards)
tinsert(HarmSpells.DEMONHUNTER, 183752) -- Consume Magic (20 yards)
tinsert(HarmSpells.DEMONHUNTER, 204021) -- Fiery Brand (Vengeance) (30 yards)

-- Druids
tinsert(FriendSpells.DRUID, 8936) -- Regrowth (40 yards, level 3)
tinsert(FriendSpells.DRUID, 774) -- Rejuvenation (Restoration) (40 yards, level 10)
tinsert(FriendSpells.DRUID, 2782) -- Remove Corruption (Restoration) (40 yards, level 19)
tinsert(FriendSpells.DRUID, 88423) -- Natures Cure (Restoration) (40 yards, level 19)

if not isRetail then
  tinsert(FriendSpells.DRUID, 5185) -- Healing Touch (40 yards, level 1, rank 1)
end

tinsert(HarmSpells.DRUID, 5176) -- Wrath (40 yards)
tinsert(HarmSpells.DRUID, 339) -- Entangling Roots (35 yards)
tinsert(HarmSpells.DRUID, 6795) -- Growl (30 yards)
tinsert(HarmSpells.DRUID, 33786) -- Cyclone (20 yards)
tinsert(HarmSpells.DRUID, 22568) -- Ferocious Bite (Melee Range)
tinsert(HarmSpells.DRUID, 8921) -- Moonfire (40 yards, level 2)

tinsert(ResSpells.DRUID, 50769) -- Revive (40 yards, level 14)
tinsert(ResSpells.DRUID, 20484) -- Rebirth (40 yards, level 29)

-- Hunters
tinsert(HarmSpells.HUNTER, 466930) -- Black Arrow (40 yards)
tinsert(HarmSpells.HUNTER, 75) -- Auto Shot (40 yards)

if not isRetail then
  tinsert(HarmSpells.HUNTER, 2764) -- Throw (30 yards, level 1)
end

tinsert(PetSpells.HUNTER, 136) -- Mend Pet (45 yards)

-- Mages
tinsert(FriendSpells.MAGE, 1459) -- Arcane Intellect (40 yards, level 8)
tinsert(FriendSpells.MAGE, 475) -- Remove Curse (40 yards, level 28)

if not isRetail then
  tinsert(FriendSpells.MAGE, 130) -- Slow Fall (40 yards, level 12)
end

tinsert(HarmSpells.MAGE, 44614) -- Flurry (40 yards)
tinsert(HarmSpells.MAGE, 5019) -- Shoot (30 yards)
tinsert(HarmSpells.MAGE, 118) -- Polymorph (30 yards)
tinsert(HarmSpells.MAGE, 116) -- Frostbolt (40 yards)
tinsert(HarmSpells.MAGE, 133) -- Fireball (40 yards)
tinsert(HarmSpells.MAGE, 44425) -- Arcane Barrage (40 yards)

-- Monks
tinsert(FriendSpells.MONK, 115450) -- Detox (40 yards)
tinsert(FriendSpells.MONK, 115546) -- Provoke (30 yards)
tinsert(FriendSpells.MONK, 116670) -- Vivify (40 yards)

tinsert(HarmSpells.MONK, 115546) -- Provoke (30 yards)
tinsert(HarmSpells.MONK, 115078) -- Paralysis (20 yards)
tinsert(HarmSpells.MONK, 100780) -- Tiger Palm (Melee Range)
tinsert(HarmSpells.MONK, 117952) -- Crackling Jade Lightning (40 yards)

tinsert(ResSpells.MONK, 115178) -- Resuscitate (40 yards, level 13)

-- Paladins
tinsert(FriendSpells.PALADIN, 19750) -- Flash of Light (40 yards, level 4)
tinsert(FriendSpells.PALADIN, 85673) -- Word of Glory (40 yards, level 7)
tinsert(FriendSpells.PALADIN, 4987) -- Cleanse (Holy) (40 yards, level 12)
tinsert(FriendSpells.PALADIN, 213644) -- Cleanse Toxins (Protection, Retribution) (40 yards, level 12)

if not isRetail then
  tinsert(FriendSpells.PALADIN, 635) -- Holy Light (40 yards, level 1, rank 1)
end

tinsert(HarmSpells.PALADIN, 853) -- Hammer of Justice (10 yards)
tinsert(HarmSpells.PALADIN, 35395) -- Crusader Strike (Melee Range)
tinsert(HarmSpells.PALADIN, 62124) -- Hand of Reckoning (30 yards)
tinsert(HarmSpells.PALADIN, 183218) -- Hand of Hindrance (30 yards)
tinsert(HarmSpells.PALADIN, 20271) -- Judgement (30 yards)
tinsert(HarmSpells.PALADIN, 20473) -- Holy Shock (40 yards)

tinsert(ResSpells.PALADIN, 7328) -- Redemption (40 yards)

-- Priests
if isRetail then
  tinsert(FriendSpells.PRIEST, 21562) -- Power Word: Fortitude (40 yards, level 6) [use first to fix Kyrian boon/fae soulshape]
  tinsert(FriendSpells.PRIEST, 17) -- Power Word: Shield (40 yards, level 4)
else -- PWS is group only in classic, use lesser heal as main spell check
  tinsert(FriendSpells.PRIEST, 2050) -- Lesser Heal (40 yards, level 1, rank 1)
end

tinsert(FriendSpells.PRIEST, 527) -- Purify / Dispel Magic (40 yards retail, 30 yards tbc, level 18, rank 1)
tinsert(FriendSpells.PRIEST, 2061) -- Flash Heal (40 yards, level 3 retail, level 20 tbc)

tinsert(HarmSpells.PRIEST, 589) -- Shadow Word: Pain (40 yards)
if isEra then
  tinsert(HarmSpells.PRIEST, 18807) -- Mind Flay (20-24 yards)
end
tinsert(HarmSpells.PRIEST, 8092) -- Mind Blast (40 yards)
tinsert(HarmSpells.PRIEST, 585) -- Smite (40 yards)
tinsert(HarmSpells.PRIEST, 5019) -- Shoot (30 yards)

if not isRetail then
  tinsert(HarmSpells.PRIEST, 8092) -- Mindblast (30 yards, level 10)
end

tinsert(ResSpells.PRIEST, 2006) -- Resurrection (40 yards, level 10)

-- Rogues
if isRetail then
  tinsert(FriendSpells.ROGUE, 36554) -- Shadowstep (Assassination, Subtlety) (25 yards, level 18) -- works on friendly in retail
  tinsert(FriendSpells.ROGUE, 921) -- Pick Pocket (10 yards, level 24) -- this works for range, keep it in friendly as well for retail but on classic this is melee range and will return min 0 range 0
else
  tinsert(HarmSpells.ROGUE, 2764) -- Throw (30 yards)
end

tinsert(HarmSpells.ROGUE, 185565) -- Poisoned Knife (Assassination) (30 yards, level 29)
tinsert(HarmSpells.ROGUE, 36554) -- Shadowstep (Assassination, Subtlety) (25 yards, level 18)
tinsert(HarmSpells.ROGUE, 185763) -- Pistol Shot (Outlaw) (20 yards)
tinsert(HarmSpells.ROGUE, 2094) -- Blind (15 yards)
tinsert(HarmSpells.ROGUE, 921) -- Pick Pocket (10 yards, level 24)

-- Shamans
tinsert(FriendSpells.SHAMAN, 546) -- Water Walking (30 yards)
tinsert(FriendSpells.SHAMAN, 8004) -- Healing Surge (Resto, Elemental) (40 yards)
tinsert(FriendSpells.SHAMAN, 188070) -- Healing Surge (Enhancement) (40 yards)

if not isRetail then
  tinsert(FriendSpells.SHAMAN, 331) -- Healing Wave (40 yards, level 1, rank 1)
  tinsert(FriendSpells.SHAMAN, 526) -- Cure Poison (40 yards, level 16)
  tinsert(FriendSpells.SHAMAN, 2870) -- Cure Disease (40 yards, level 22)
end

tinsert(HarmSpells.SHAMAN, 370) -- Purge (30 yards)
tinsert(HarmSpells.SHAMAN, 8042) -- Earth Shock (40 yards)
tinsert(HarmSpells.SHAMAN, 117014) -- Elemental Blast (40 yards)
tinsert(HarmSpells.SHAMAN, 188196) -- Lightning Bolt (40 yards)
tinsert(HarmSpells.SHAMAN, 73899) -- Primal Strike (Melee Range)

if not isRetail then
  tinsert(HarmSpells.SHAMAN, 403) -- Lightning Bolt (30 yards, level 1, rank 1)
  tinsert(HarmSpells.SHAMAN, 8042) -- Earth Shock (20 yards, level 4, rank 1)
end

tinsert(ResSpells.SHAMAN, 2008) -- Ancestral Spirit (40 yards, level 13)

-- Warriors
tinsert(HarmSpells.WARRIOR, 355) -- Taunt (30 yards)
tinsert(HarmSpells.WARRIOR, 5246) -- Intimidating Shout (Arms, Fury) (8 yards)
tinsert(HarmSpells.WARRIOR, 100) -- Charge (Arms, Fury) (8-25 yards)

if not isRetail then
  tinsert(HarmSpells.WARRIOR, 2764) -- Throw (30 yards, level 1, 5-30 range)
end

-- Warlocks
if isEra then
  tinsert(FriendSpells.WARLOCK, 132) -- Detect Invisibility (30 yards, level 26)
else
  tinsert(FriendSpells.WARLOCK, 20707) -- Soulstone (40 yards) ~ this can be precasted so leave it in friendly as well as res
end
tinsert(FriendSpells.WARLOCK, 5697) -- Unending Breath (30 yards)

if isRetail then
  tinsert(HarmSpells.WARLOCK, 234153) -- Drain Life (40 yards, level 9)
  tinsert(HarmSpells.WARLOCK, 198590) -- Drain Soul (40 yards, level 15)
  tinsert(HarmSpells.WARLOCK, 232670) -- Shadow Bolt (40 yards)
else
  tinsert(HarmSpells.WARLOCK, 172) -- Corruption (30/33/36 yards, level 4, rank 1)
  tinsert(HarmSpells.WARLOCK, 348) -- Immolate (30/33/36 yards, level 1, rank 1)
  tinsert(HarmSpells.WARLOCK, 17877) -- Shadowburn (Destruction) (20/22/24 yards, rank 1)
  tinsert(HarmSpells.WARLOCK, 18223) -- Curse of Exhaustion (Affliction) (30/33/36/35/38/42 yards)
  tinsert(HarmSpells.WARLOCK, 689) -- Drain Life (Affliction) (20/22/24 yards, level 14, rank 1)
end
if isEra then
  tinsert(HarmSpells.WARLOCK, 403677) -- Master Channeler (Affliction) (20/22/24 yards, level 14, rank 1)
  tinsert(HarmSpells.WARLOCK, 426320) -- Shadowflame (30/33/36/39/42 yards, level 14, rank 1)
end

tinsert(HarmSpells.WARLOCK, 5019) -- Shoot (30 yards)
tinsert(HarmSpells.WARLOCK, 686) -- Shadow Bolt (Demonology, Affliction) (40 yards)
tinsert(HarmSpells.WARLOCK, 5782) -- Fear (30 yards)

if not isEra then
  tinsert(ResSpells.WARLOCK, 20707) -- Soulstone (40 yards)
end

tinsert(PetSpells.WARLOCK, 755) -- Health Funnel (45 yards)

-- Items

local FriendItems
if isEra then
  FriendItems = {
    [5] = {
      1970,   -- Restoring Balm
      8149,   -- Voodoo Charm
      15826,  -- Curative Animal Salve
      16308,  -- Northridge Crowbar
      16991,  -- Triage Bandage
      17117,  -- Rat Catcher's Flute
      20403,  -- Proxy of Nozdormu
      22259,  -- Unbestowed Friendship Bracelet
      208855, -- Rainbow Fin Albacore Chum
      209027, -- Crab Treats
      209057, -- Prototype Engine
      213036, -- Water of Elune'ara
      221199, -- Satyrweed Tincture
      225943, -- Rancid Hunk of Flesh
    },
    [10] = {
      17626,  -- Frostwolf Muzzle
      17689,  -- Stormpike Training Collar
      21267,  -- Toasting Goblet
      23164,  -- Bubbly Beverage
      226207, -- Echo of Anastari
      226208, -- Echo of Barthilas
      226209, -- Echo of Dathrohan
      226210, -- Echo of Maleki
      226211, -- Echo of Nerub'enkan
      226212, -- Echo of Ramstein
      226213, -- Echo of Rivendare
      226214, -- Echo of Willey
    },
    [15] = {
      1251,   -- Linen Bandage
      2581,   -- Heavy Linen Bandage
      3530,   -- Wool Bandage
      3531,   -- Heavy Wool Bandage
      6450,   -- Silk Bandage
      6451,   -- Heavy Silk Bandage
      8544,   -- Mageweave Bandage
      8545,   -- Heavy Mageweave Bandage
      14529,  -- Runecloth Bandage
      14530,  -- Heavy Runecloth Bandage
      19066,  -- Warsong Gulch Runecloth Bandage
      19067,  -- Warsong Gulch Mageweave Bandage
      19068,  -- Warsong Gulch Silk Bandage
      19307,  -- Alterac Heavy Runecloth Bandage
      20065,  -- Arathi Basin Mageweave Bandage
      20066,  -- Arathi Basin Runecloth Bandage
      20067,  -- Arathi Basin Silk Bandage
      20232,  -- Defiler's Mageweave Bandage
      20234,  -- Defiler's Runecloth Bandage
      20235,  -- Defiler's Silk Bandage
      20237,  -- Highlander's Mageweave Bandage
      20243,  -- Highlander's Runecloth Bandage
      20244,  -- Highlander's Silk Bandage
      23684,  -- Crystal Infused Bandage
      232433, -- Dense Runecloth Bandage
    },
    [20] = {
      12450,  -- Juju Flurry
      12451,  -- Juju Power
      12455,  -- Juju Ember
      12457,  -- Juju Chill
      12458,  -- Juju Guile
      12460,  -- Juju Might
      17757,  -- Amulet of Spirits
      21519,  -- Mistletoe
      219963, -- Deputization Authorization: Duskwood Mission I
      219965, -- Deputization Authorization: Duskwood Mission II
      219983, -- Deputization Authorization: Duskwood Mission III
      219984, -- Deputization Authorization: Duskwood Mission IV
      219985, -- Deputization Authorization: Duskwood Mission V
      219986, -- Deputization Authorization: Duskwood Mission VI
      219987, -- Deputization Authorization: Duskwood Mission VII
      219988, -- Deputization Authorization: Duskwood Mission VIII
      219989, -- Deputization Authorization: Duskwood Mission IX
      219990, -- Deputization Authorization: Duskwood Mission X
      219991, -- Deputization Authorization: Duskwood Mission XI
      219992, -- Deputization Authorization: Duskwood Mission XII
      219993, -- Deputization Authorization: Duskwood Mission XIII
      219994, -- Deputization Authorization: Duskwood Mission XIV
      219995, -- Deputization Authorization: Duskwood Mission XV
      219996, -- Deputization Authorization: Duskwood Mission XVI
      219997, -- Deputization Authorization: Duskwood Mission XVII
      219998, -- Deputization Authorization: Duskwood Mission XVIII
      220053, -- Deputization Authorization: Ashenvale Mission I
      220054, -- Deputization Authorization: Ashenvale Mission II
      220055, -- Deputization Authorization: Ashenvale Mission III
      220056, -- Deputization Authorization: Ashenvale Mission IV
      220057, -- Deputization Authorization: Ashenvale Mission V
      220058, -- Deputization Authorization: Ashenvale Mission VI
      220059, -- Deputization Authorization: Ashenvale Mission VII
      220060, -- Deputization Authorization: Ashenvale Mission VIII
      220061, -- Deputization Authorization: Ashenvale Mission IX
      220062, -- Deputization Authorization: Ashenvale Mission X
      220063, -- Deputization Authorization: Ashenvale Mission XI
      220064, -- Deputization Authorization: Ashenvale Mission XII
      220065, -- Deputization Authorization: Ashenvale Mission XIII
      220066, -- Deputization Authorization: Ashenvale Mission XIV
      220067, -- Deputization Authorization: Ashenvale Mission XV
      220068, -- Deputization Authorization: Ashenvale Mission XVI
      220069, -- Deputization Authorization: Ashenvale Mission XVII
      220070, -- Deputization Authorization: Ashenvale Mission XVIII
      220071, -- Deputization Authorization: Hinterlands Mission I
      220072, -- Deputization Authorization: Hinterlands Mission II
      220073, -- Deputization Authorization: Hinterlands Mission III
      220074, -- Deputization Authorization: Hinterlands Mission IV
      220075, -- Deputization Authorization: Hinterlands Mission V
      220076, -- Deputization Authorization: Hinterlands Mission VI
      220077, -- Deputization Authorization: Hinterlands Mission VII
      220078, -- Deputization Authorization: Hinterlands Mission VIII
      220079, -- Deputization Authorization: Hinterlands Mission IX
      220080, -- Deputization Authorization: Hinterlands Mission X
      220081, -- Deputization Authorization: Hinterlands Mission XI
      220082, -- Deputization Authorization: Hinterlands Mission XII
      220083, -- Deputization Authorization: Hinterlands Mission XIII
      220084, -- Deputization Authorization: Hinterlands Mission XIV
      220085, -- Deputization Authorization: Hinterlands Mission XV
      220086, -- Deputization Authorization: Hinterlands Mission XVI
      220087, -- Deputization Authorization: Hinterlands Mission XVII
      220088, -- Deputization Authorization: Hinterlands Mission XVIII
      220089, -- Deputization Authorization: Feralas Mission I
      220090, -- Deputization Authorization: Feralas Mission II
      220091, -- Deputization Authorization: Feralas Mission III
      220092, -- Deputization Authorization: Feralas Mission IV
      220093, -- Deputization Authorization: Feralas Mission V
      220094, -- Deputization Authorization: Feralas Mission VI
      220095, -- Deputization Authorization: Feralas Mission VII
      220096, -- Deputization Authorization: Feralas Mission VIII
      220097, -- Deputization Authorization: Feralas Mission IX
      220098, -- Deputization Authorization: Feralas Mission X
      220099, -- Deputization Authorization: Feralas Mission XI
      220100, -- Deputization Authorization: Feralas Mission XII
      220101, -- Deputization Authorization: Feralas Mission XIII
      220102, -- Deputization Authorization: Feralas Mission XIV
      220103, -- Deputization Authorization: Feralas Mission XV
      220104, -- Deputization Authorization: Feralas Mission XVI
      220105, -- Deputization Authorization: Feralas Mission XVII
      220106, -- Deputization Authorization: Feralas Mission XVIII
      220792, -- Scroll of Spatial Mending
      223168, -- Worldcore Fragment
      223171, -- Scroll of Geomancy
      224806, -- Legion Portal Tuner
      224893, -- Overcharged Portal Tuner
      231298, -- Scroll of Lesser Spatial Mending
      231836, -- Glowing Scroll of Spatial Mending
      232344, -- Vick's VIP Pass
    },
    [25] = {
      13289,  -- Egan's Blaster
    },
    [30] = {
      954,    -- Scroll of Strength
      955,    -- Scroll of Intellect
      1180,   -- Scroll of Stamina
      1181,   -- Scroll of Spirit
      1477,   -- Scroll of Agility II
      1478,   -- Scroll of Protection II
      1711,   -- Scroll of Stamina II
      1712,   -- Scroll of Spirit II
      1851,   -- Cleansing Water
      1912,   -- Deprecated Reed Pipe
      2289,   -- Scroll of Strength II
      2290,   -- Scroll of Intellect II
      2948,   -- Deprecated Talisman of Cleansing
      3012,   -- Scroll of Agility
      3013,   -- Scroll of Protection
      4381,   -- Minor Recombobulator
      4419,   -- Scroll of Intellect III
      4421,   -- Scroll of Protection III
      4422,   -- Scroll of Stamina III
      4424,   -- Scroll of Spirit III
      4425,   -- Scroll of Agility III
      4426,   -- Scroll of Strength III
      4444,   -- Black Husk Shield
      5232,   -- Minor Soulstone
      5613,   -- Staff of the Purifier
      6452,   -- Anti-Venom
      6453,   -- Strong Anti-Venom
      10305,  -- Scroll of Protection IV
      10306,  -- Scroll of Spirit IV
      10307,  -- Scroll of Stamina IV
      10308,  -- Scroll of Intellect IV
      10309,  -- Scroll of Agility IV
      10310,  -- Scroll of Strength IV
      11563,  -- Crystal Force
      11564,  -- Crystal Ward
      11567,  -- Crystal Spire
      16892,  -- Lesser Soulstone
      16893,  -- Soulstone
      16895,  -- Greater Soulstone
      16896,  -- Major Soulstone
      17202,  -- Snowball
      17310,  -- Aspect of Neptulon
      18637,  -- Major Recombobulator
      19440,  -- Powerful Anti-Venom
      20908,  -- Festival of Nian Firework
      21038,  -- Hardpacked Snowball
      21713,  -- Elune's Candle
      22200,  -- Silver Shafted Arrow
      22206,  -- Bouquet of Red Roses
      22218,  -- Handful of Rose Petals
    },
    [35] = {
      18904,  -- Zorbin's Ultra-Shrinker
    },
    [40] = {
      1713,   -- Ankh of Life
      5205,   -- Sprouted Frond
      5323,   -- Everglow Lantern
      8346,   -- Gauntlets of the Sea
      11562,  -- Crystal Restore
      18640,  -- Happy Fun Rock
      18662,  -- Heavy Leather Ball
      213349, -- Gniodine Pill Bottle
      216500, -- Bloodbonded Grove Talisman
      216503, -- Bloodstorm Jewel
      216517, -- Sanguine Sanctuary
      216607, -- Bloodlight Offering
      230280, -- Aegis of Preservation
    },
    [45] = {
      221316, -- Premo's Poise-Demanding Uniform
    },
    [50] = {
      221315, -- Rainbow Generator
    },
    [100] = {
      5418,   -- Weapon of Mass Destruction (test)
      17162,  -- Eric Test Item A
      23715,  -- Permanent Lung Juice Cocktail
      23718,  -- Permanent Ground Scorpok Assay
      23719,  -- Permanent Cerebral Cortex Compound
      23721,  -- Permanent Gizzard Gum
      23722,  -- Permanent R.O.I.D.S.
      227685, -- Modified Shadow Scalpel
    },
    -- [50000] = {
    --   228227, -- Scroll of Overwhelming Power
    -- },
  }
elseif isCata then
  FriendItems = {
    [3] = {
      42732,  -- Everfrost Razor
    },
    [5] = {
      1970,   -- Restoring Balm
      8149,   -- Voodoo Charm
      15826,  -- Curative Animal Salve
      16991,  -- Triage Bandage
      17117,  -- Rat Catcher's Flute
      20403,  -- Proxy of Nozdormu
      22259,  -- Unbestowed Friendship Bracelet
      23485,  -- Empty Birdcage
      23659,  -- Fel-Tainted Morsels
      33310,  -- The Sergeant's Machete
      33342,  -- The Brave's Machete
      33563,  -- Forsaken Banner
      34954,  -- Torp's Kodo Snaffle
      34973,  -- Re-Cursive Transmatter Injection
      35116,  -- The Ultrasonic Screwdriver
      35401,  -- The Greatmother's Soulcatcher
      35736,  -- Bounty Hunter's Cage
      36771,  -- Sturdy Crates
      36786,  -- Bark of the Walkers
      36956,  -- Liquid Fire of Elune
      37187,  -- Container of Rats
      37202,  -- Onslaught Riding Crop
      37568,  -- Renewing Tourniquet
      37576,  -- Renewing Bandage
      38330,  -- Crusader's Bandage
      38467,  -- Softknuckle Poker
      38627,  -- Mammoth Harness
      38676,  -- Whisker of Har'koa
      38731,  -- Ahunae's Knife
      40587,  -- Darkmender's Tincture
      45001,  -- Medicated Salve
      45080,  -- Large Femur
      49743,  -- Sten's First Aid Kit
      49948,  -- Calder's Bonesaw
      50471,  -- The Heartbreaker
      50742,  -- Tara's Tar Scraper
      50746,  -- Tara's Tar Scraper
      52014,  -- Herb-Soaked Bandages
      52271,  -- Northwatch Manacles
      52712,  -- Remote Control Fireworks
      53120,  -- Bottled Bileberry Brew
      56837,  -- Sturdy Manacles
      58502,  -- Explosive Bonding Compound
      58885,  -- Rockslide Reagent
      58955,  -- Razgar's Fillet Knife
      58965,  -- Deepvein's Patch Kit
      61302,  -- Light-Touched Blades
      63150,  -- Shovel
      63427,  -- Worgsaw
      65667,  -- Shovel of Mercy
      67232,  -- Sullah's Pygmy Pen
      71978,  -- Darkmoon Bandage
      72110,  -- Battered Wrench
    },
    [7] = {
      61323,  -- Ruby Seeds
      62899,  -- Enchanted Imp Sack
      63350,  -- Razor-Sharp Scorpid Barb
    },
    [8] = {
      29052,  -- Warp Nether Extractor
      33278,  -- Burning Torch
      34368,  -- Attuned Crystal Cores
      35943,  -- Jeremiah's Tools
      37932,  -- Miner's Lantern
      56821,  -- Oil Extrusion Pump
      68678,  -- Child Safety Harness
    },
    [10] = {
      17626,  -- Frostwolf Muzzle
      17689,  -- Stormpike Training Collar
      21267,  -- Toasting Goblet
      22896,  -- Healing Crystal
      22962,  -- Inoculating Crystal
      23164,  -- Bubbly Beverage
      30656,  -- Protovoltaic Magneto Collector
      32321,  -- Sparrowhawk Net
      33418,  -- Tillinghast's Plague Canister
      34083,  -- Awakening Rod
      34250,  -- Skill: Throw Bullet
      35293,  -- Cenarion Horn
      36859,  -- Snow of Eternal Slumber
      37307,  -- Purified Ashes of Vordrassil
      38697,  -- Jungle Punch Sample
      40551,  -- Gore Bladder
      41988,  -- Telluric Poultice
      42164,  -- Hodir's Horn
      43059,  -- Drakuru's Last Wish
      44576,  -- Bright Flare
      47033,  -- Light-Blessed Relic
      50131,  -- Snagglebolt's Air Analyzer
      52709,  -- Gnomish Playback Device
      52819,  -- Frostgale Crystal
      53009,  -- Juniper Berries
      54215,  -- Vol'jin's War Drums
      54462,  -- Moanah's Baitstick
      54463,  -- Flameseer's Staff
      56012,  -- Stone Knife of Sealing
      56222,  -- Runes of Return
      58167,  -- Spirit Totem
      58200,  -- Techno-Grenade
      58203,  -- Paintinator
      60382,  -- Mylra's Knife
      60870,  -- Barrel of Explosive Ale
      62057,  -- Teleport Beacon
      62326,  -- Heavy Manacles
      62541,  -- Heavy Manacles
      64312,  -- Totem of Freedom
      67249,  -- Viewpoint Equalizer
      68677,  -- Moldy Lunch
      68679,  -- Goblin Gas Tank
      68682,  -- Inflatable Lifesaver
      69240,  -- Enchanted Salve
    },
    [15] = {
      1251,   -- Linen Bandage
      2581,   -- Heavy Linen Bandage
      3530,   -- Wool Bandage
      3531,   -- Heavy Wool Bandage
      6450,   -- Silk Bandage
      6451,   -- Heavy Silk Bandage
      8544,   -- Mageweave Bandage
      8545,   -- Heavy Mageweave Bandage
      14529,  -- Runecloth Bandage
      14530,  -- Heavy Runecloth Bandage
      19066,  -- Warsong Gulch Runecloth Bandage
      19067,  -- Warsong Gulch Mageweave Bandage
      19068,  -- Warsong Gulch Silk Bandage
      19307,  -- Alterac Heavy Runecloth Bandage
      20065,  -- Arathi Basin Mageweave Bandage
      20066,  -- Arathi Basin Runecloth Bandage
      20067,  -- Arathi Basin Silk Bandage
      20232,  -- Defiler's Mageweave Bandage
      20234,  -- Defiler's Runecloth Bandage
      20235,  -- Defiler's Silk Bandage
      20237,  -- Highlander's Mageweave Bandage
      20243,  -- Highlander's Runecloth Bandage
      20244,  -- Highlander's Silk Bandage
      21990,  -- Netherweave Bandage
      21991,  -- Heavy Netherweave Bandage
      30651,  -- Dertrok's First Wand
      30652,  -- Dertrok's Second Wand
      30653,  -- Dertrok's Third Wand
      30654,  -- Dertrok's Fourth Wand
      31129,  -- Blackwhelp Net
      32907,  -- Wolpertinger Net
      33621,  -- Plague Spray
      34721,  -- Frostweave Bandage
      34722,  -- Heavy Frostweave Bandage
      36764,  -- Shard of the Earth
      38573,  -- RJR Rifle
      38640,  -- Dense Frostweave Bandage
      38641,  -- Deprecated Frostweave Bandage [PH]
      38643,  -- Thick Frostweave Bandage
      39268,  -- Medallion of Mam'toth
      44646,  -- Dalaran Bandage
      44959,  -- Soothing Totem
      46722,  -- Grol'dom Net
      52481,  -- Blastshadow's Soulstone
      53049,  -- Embersilk Bandage
      53050,  -- Heavy Embersilk Bandage
      53051,  -- Dense Embersilk Bandage
      53101,  -- Tessina's Wisp Call
      53104,  -- Tessina's Hippogryph Call
      53105,  -- Tessina's Treant Call
      54851,  -- Anemone Chemical Application Device
      56180,  -- Duarn's Net UNUSED
      56184,  -- Duarn's Net
      58169,  -- Elementium Grapple Line
      58966,  -- Jesana's Faerie Dragon Call
      58967,  -- Jesana's Giant Call
      63391,  -- Baradin's Wardens Bandage
      64995,  -- Hellscream's Reach Bandage
    },
    [20] = {
      17757,  -- Amulet of Spirits
      21519,  -- Mistletoe
      22473,  -- Antheol's Disciplinary Rod
      23394,  -- Healing Salve
      23693,  -- Carinda's Scroll of Retribution
      29817,  -- Talbuk Tagger
      29818,  -- Energy Field Modulator
      30175,  -- Gor'drek's Ointment
      32424,  -- Blade's Edge Ogre Brew
      33088,  -- Brogg's Totem
      34127,  -- Tasty Reef Fish
      34257,  -- Fel Siphon
      34711,  -- Core of Malice
      34869,  -- Warsong Banner
      36796,  -- Gavrock's Runebreaker
      36827,  -- Blood Gem
      36835,  -- Unholy Gem
      36847,  -- Frost Gem
      37708,  -- Stick
      39157,  -- Scepter of Suggestion
      39206,  -- Scepter of Empowerment
      39238,  -- Scepter of Command
      39577,  -- Rejek's Blade
      39651,  -- Venture Co. Explosives
      39664,  -- Scepter of Domination
      40397,  -- Lifeblood Gem
      42624,  -- Battered Storm Hammer
      42894,  -- Horn of Elemental Fury
      43206,  -- War Horn of Acherus
      43315,  -- Sigil of the Ebon Blade
      44817,  -- The Mischief Maker
      44975,  -- Orb of Elune
      46363,  -- Lifebringer Sapling
      48104,  -- The Refleshifier
      49202,  -- Black Gunpowder Keg
      50053,  -- Bloodtalon Lasso
      52044,  -- Bilgewater Cartel Promotional Delicacy Morsels
      52073,  -- Bramblestaff
      52484,  -- Kaja'Cola Zero-One
      52566,  -- Motivate-a-Tron
      53107,  -- Flameseer's Staff
      55141,  -- Spiralung
      55158,  -- Fake Treasure
      55230,  -- Soul Stick
      56798,  -- Jin'Zil's Voodoo Stick
      57920,  -- Revantusk War Drums
      58177,  -- Earthen Ring Proclamation
      63079,  -- Titanium Shackles
      63426,  -- Lethality Analyzer
      67241,  -- Sullah's Camel Harness
      68606,  -- Murloc Leash
      68607,  -- Candy Cleanser
      71085,  -- Runestaff of Nordrassil
    },
    [25] = {
      13289,  -- Egan's Blaster
      31463,  -- Zezzak's Shard
      32966,  -- DEBUG - Headless Horseman - Start Fire
      34979,  -- Pouch of Crushed Bloodspore
      46885,  -- Weighted Net
      56247,  -- Box of Crossbow Bolts
    },
    [30] = {
      954,    -- Scroll of Strength
      955,    -- Scroll of Intellect
      1180,   -- Scroll of Stamina
      1181,   -- Scroll of Spirit
      1477,   -- Scroll of Agility II
      1478,   -- Scroll of Protection II
      1711,   -- Scroll of Stamina II
      1712,   -- Scroll of Spirit II
      1912,   -- Deprecated Reed Pipe
      2289,   -- Scroll of Strength II
      2290,   -- Scroll of Intellect II
      3012,   -- Scroll of Agility
      3013,   -- Scroll of Protection
      4381,   -- Minor Recombobulator
      4419,   -- Scroll of Intellect III
      4421,   -- Scroll of Protection III
      4422,   -- Scroll of Stamina III
      4424,   -- Scroll of Spirit III
      4425,   -- Scroll of Agility III
      4426,   -- Scroll of Strength III
      4444,   -- Black Husk Shield
      5613,   -- Staff of the Purifier
      6452,   -- Anti-Venom
      6453,   -- Strong Anti-Venom
      10305,  -- Scroll of Protection IV
      10306,  -- Scroll of Spirit IV
      10307,  -- Scroll of Stamina IV
      10308,  -- Scroll of Intellect IV
      10309,  -- Scroll of Agility IV
      10310,  -- Scroll of Strength IV
      11567,  -- Crystal Spire
      17202,  -- Snowball
      17310,  -- Aspect of Neptulon
      18637,  -- Major Recombobulator
      19440,  -- Powerful Anti-Venom
      20908,  -- Festival of Nian Firework
      21713,  -- Elune's Candle
      22200,  -- Silver Shafted Arrow
      22206,  -- Bouquet of Red Roses
      22218,  -- Handful of Rose Petals
      23337,  -- Cenarion Antidote
      27498,  -- Scroll of Agility V
      27499,  -- Scroll of Intellect V
      27500,  -- Scroll of Protection V
      27501,  -- Scroll of Spirit V
      27502,  -- Scroll of Stamina V
      27503,  -- Scroll of Strength V
      31437,  -- Medicinal Drake Essence
      31828,  -- Ritual Prayer Beads
      32680,  -- Booterang
      32960,  -- Elekk Dispersion Ray
      33108,  -- Ooze Buster
      33457,  -- Scroll of Agility VI
      33458,  -- Scroll of Intellect VI
      33459,  -- Scroll of Protection VI
      33460,  -- Scroll of Spirit VI
      33461,  -- Scroll of Stamina VI
      33462,  -- Scroll of Strength VI
      33865,  -- Amani Hex Stick
      34068,  -- Weighted Jack-o'-Lantern
      34191,  -- Handful of Snowflakes
      34598,  -- The King's Empty Conch
      34684,  -- Handful of Summer Petals
      35557,  -- Huge Snowball
      36732,  -- Potent Explosive Charges
      37091,  -- Scroll of Intellect VII
      37092,  -- Scroll of Intellect VIII
      37093,  -- Scroll of Stamina VII
      37094,  -- Scroll of Stamina VIII
      37097,  -- Scroll of Spirit VII
      37098,  -- Scroll of Spirit VIII
      38515,  -- Tangled Skein Thrower
      40686,  -- U.D.E.D.
      40917,  -- Lord-Commander's Nullifier
      42774,  -- Arngrim's Tooth
      43463,  -- Scroll of Agility VII
      43464,  -- Scroll of Agility VIII
      43465,  -- Scroll of Strength VII
      43466,  -- Scroll of Strength VIII
      43467,  -- Scroll of Protection VII
      43468,  -- Scroll of Protection VIII
      44414,  -- Soul Lash
      44653,  -- Volatile Acid
      44731,  -- Bouquet of Ebon Roses
      44915,  -- Elune's Candle
      45073,  -- Spring Flowers
      49138,  -- Bottle of Leeches
      49199,  -- Infernal Power Core
      49219,  -- Infernal Power Core
      49882,  -- Soothing Seeds
      50163,  -- Lovely Rose
      52710,  -- Enchanted Conch
      52715,  -- Butcherbot Control Gizmo
      56069,  -- Alliance Weapon Crate
      56227,  -- Enchanted Conch
      57172,  -- Attuned Runestone of Binding
      58935,  -- Gryphon Chow
      60861,  -- Holy Thurible
      63303,  -- Scroll of Agility IX
      63304,  -- Scroll of Strength IX
      63305,  -- Scroll of Intellect IX
      63306,  -- Scroll of Stamina IX
      63307,  -- Scroll of Spirit IX
      63308,  -- Scroll of Protection IX
      64637,  -- Tanrir's Overcharged Totem
      69825,  -- Essence Gatherer
    },
    [35] = {
      16103,  -- Test Enchant Boots Stamina
      18904,  -- Zorbin's Ultra-Shrinker
      24501,  -- Gordawg's Boulder
      35121,  -- Wolf Bait
      41505,  -- Thorim's Charm of Earth
      44890,  -- To'kini's Blowgun
      49028,  -- Nitro-Potassium Bananas
      56576,  -- Orb of Suggestion
    },
    [40] = {
      1713,   -- Ankh of Life
      5323,   -- Everglow Lantern
      8346,   -- Gauntlets of the Sea
      11562,  -- Crystal Restore
      18640,  -- Happy Fun Rock
      18662,  -- Heavy Leather Ball
      24541,  -- Medicinal Swamp Moss
      31088,  -- Tainted Core
      33081,  -- Voodoo Skull
      33581,  -- Vrykul Insult
      34255,  -- Razorthorn Flayer Gland
      34471,  -- Vial of the Sunwell
      34494,  -- Paper Zeppelin
      37438,  -- Rod of Compulsion
      38266,  -- Rotund Relic
      38308,  -- Ethereal Essence Sphere
      38332,  -- Modified Mojo
      39305,  -- Tiki Hex Remover
      39615,  -- Crusader Parachute
      40532,  -- Living Ice Crystals
      44114,  -- Old Spices
      44222,  -- Dart Gun
      44228,  -- Baby Spice
      44804,  -- Indalamar's Debuffer
      44812,  -- Turkey Shooter
      44832,  -- Squirt Gun [PH]
      50354,  -- Bauble of True Blood
      50430,  -- Scraps of Rotting Meat
      50726,  -- Bauble of True Blood
      52490,  -- Stardust
      53794,  -- Rendel's Bridle
      55165,  -- Enchanted Sea Snack
      56136,  -- Corrupted Egg Shell
      56169,  -- Breathstone
      56463,  -- Corrupted Egg Shell
      60490,  -- The Axe of Earthly Sundering
      60808,  -- Mutant Bush Chicken Cage
      65162,  -- Emergency Pool Pony
      71627,  -- Throwing Starfish
    },
    [45] = {
      28369,  -- Battery Recharging Blaster
      32698,  -- Wrangling Rope
      34691,  -- Arcane Binder
      49647,  -- Drum of the Soothed Earth
      52059,  -- Murloc Leash
      52833,  -- Modified Soul Orb
      62794,  -- Licensed Proton Accelerator Cannon
    },
    [60] = {
      32825,  -- Soul Cannon
      34111,  -- Trained Rock Falcon
      34121,  -- Trained Rock Falcon
      37877,  -- Silver Feather
      37887,  -- Seeds of Nature's Wrath
      50851,  -- Pulsing Life Crystal
    },
    [70] = {
      41265,  -- Eyesore Blaster
    },
    [80] = {
      28131,  -- Reaver Buster Launcher
      35278,  -- Reinforced Net
      35506,  -- Raelorasz's Spear
      42769,  -- Spear of Hodir
      50031,  -- Tomusa's Hook
      62775,  -- Barbed Fleshhook
      63092,  -- Wyrmhunter Hooks
      63104,  -- Elemental Nullifier
      63393,  -- Shoulder-Mounted Drake-Dropper
    },
    [100] = {
      17162,  -- Eric Test Item A
      23715,  -- Permanent Lung Juice Cocktail
      23718,  -- Permanent Ground Scorpok Assay
      23719,  -- Permanent Cerebral Cortex Compound
      23721,  -- Permanent Gizzard Gum
      23722,  -- Permanent R.O.I.D.S.
      28025,  -- Video Mount
      29877,  -- Indalamar's Super Hot
      34151,  -- Player, Draenei/Tauren
      34152,  -- Player, Dwarf/Orc
      34153,  -- Player, Gnome/Blood Elf
      34154,  -- Player, Human/Undead
      34155,  -- Player, Troll/Night Elf
      41058,  -- Hyldnir Harpoon
      44212,  -- SGM-3
    },
    [150] = {
      46954,  -- Flaming Spears
    },
    -- [50000] = {
    --   5418,   -- Weapon of Mass Destruction (test)
    --   28261,  -- Video Invis
    --   29025,  -- [UNUSED]Triangulation Device
    --   33001,  -- Reflective Dust
    -- },
  }
else
  FriendItems = {
    [2] = {
      168948, -- Dried Kelp
      194718, -- Premium Salamander Feed
    },
    [3] = {
      42732,  -- Everfrost Razor
      200469, -- Khadgar's Disenchanting Rod
    },
    [4] = {
      129055, -- Shoe Shine Kit
    },
    [5] = {
      1970,   -- Restoring Balm
      8149,   -- Voodoo Charm
      15826,  -- Curative Animal Salve
      16991,  -- Triage Bandage
      17117,  -- Rat Catcher's Flute
      20403,  -- Proxy of Nozdormu
      22259,  -- Unbestowed Friendship Bracelet
      23485,  -- Empty Birdcage
      23659,  -- Fel-Tainted Morsels
      33310,  -- The Sergeant's Machete
      33342,  -- The Brave's Machete
      33563,  -- Forsaken Banner
      34954,  -- Torp's Kodo Snaffle
      34973,  -- Re-Cursive Transmatter Injection
      35116,  -- The Ultrasonic Screwdriver
      35401,  -- The Greatmother's Soulcatcher
      35736,  -- Bounty Hunter's Cage
      36771,  -- Sturdy Crates
      36786,  -- Bark of the Walkers
      36956,  -- Liquid Fire of Elune
      37187,  -- Container of Rats
      37202,  -- Onslaught Riding Crop
      37568,  -- Renewing Tourniquet
      37576,  -- Renewing Bandage
      38330,  -- Crusader's Bandage
      38467,  -- Softknuckle Poker
      38627,  -- Mammoth Harness
      38676,  -- Whisker of Har'koa
      38731,  -- Ahunae's Knife
      40587,  -- Darkmender's Tincture
      45001,  -- Medicated Salve
      45080,  -- Large Femur
      49948,  -- Calder's Bonesaw
      50471,  -- The Heartbreaker
      50742,  -- Tara's Tar Scraper
      50746,  -- Tara's Tar Scraper
      52014,  -- Herb-Soaked Bandages
      52271,  -- Northwatch Manacles
      52712,  -- Remote Control Fireworks
      53120,  -- Bottled Bileberry Brew
      56837,  -- Sturdy Manacles
      58502,  -- Explosive Bonding Compound
      58885,  -- Rockslide Reagent
      58955,  -- Razgar's Fillet Knife
      58965,  -- Deepvein's Patch Kit
      61302,  -- Light-Touched Blades
      63150,  -- Shovel
      63427,  -- Worgsaw
      65667,  -- Shovel of Mercy
      67232,  -- Sullah's Pygmy Pen
      71978,  -- Darkmoon Bandage
      72110,  -- Battered Wrench
      79021,  -- Ken-Ken's Mask
      79057,  -- Ken-Ken's Mask
      79102,  -- Green Cabbage Seeds
      79819,  -- Dit Da Jow
      79932,  -- Qu Mo Mask
      80302,  -- EZ-Gro Green Cabbage Seeds
      80590,  -- Juicycrunch Carrot Seeds
      80591,  -- Scallion Seeds
      80592,  -- Mogu Pumpkin Seeds
      80593,  -- Red Blossom Leek Seeds
      80594,  -- Pink Turnip Seeds
      80595,  -- White Turnip Seeds
      85215,  -- Snakeroot Seed
      85216,  -- Enigma Seed
      85217,  -- Magebulb Seed
      85219,  -- Ominous Seed
      85267,  -- Autumn Blossom Sapling
      85268,  -- Spring Blossom Sapling
      85269,  -- Winter Blossom Sapling
      89197,  -- Windshear Cactus Seed
      89202,  -- Raptorleaf Seed
      89233,  -- Songbell Seed
      89326,  -- Witchberry Seeds
      89328,  -- Jade Squash Seeds
      89329,  -- Striped Melon Seeds
      89880,  -- Dented Shovel
      91806,  -- Unstable Portal Shard
      114835, -- Rooby Reat
      120293, -- Lukewarm Yak Roast Broth
      133065, -- Tony Mourdain's Cleaver
      136605, -- Solendra's Compassion
      137299, -- Nightborne Spellblade
      139463, -- Felbat Toxin Salve
      142065, -- Dusk Lily Sigil
      142262, -- Electrified Key
      143597, -- Fruit of the Arcan'dor
      143773, -- Contagion Counteragent
      150759, -- Restorative Balm
      151563, -- Hallowed Prayer Effigy
      151570, -- Lightbound Crystal
      151624, -- Y'mera's Arcanocrystal
      152472, -- Chieftain's Salve
      152630, -- Ranah's Watering Can
      152971, -- Talisman of the Prophet
      152995, -- Sacred Stone
      153049, -- Scroll of Purging
      153112, -- Scroll of Purging
      153496, -- Tasty Treats
      153513, -- Cleansing Tonic
      156518, -- Lucille's Sewing Needle
      156532, -- Inquisitor's Regalia
      157771, -- Holy Water
      158678, -- Antivenom
      159470, -- Faithless Scimitar
      159782, -- Milk Pail
      160045, -- Antidote Salve
      160429, -- Rope and Hook
      160433, -- Bandages
      160559, -- Scroll of Purification
      160561, -- Goldfield's Knife
      160571, -- Lucille's Sewing Needle
      160585, -- Soulcaller Scroll
      161247, -- Marshal's Regalia
      162450, -- Portal Orb
      162589, -- Alexxi's Foolproof Remedy
      163607, -- Lucille's Sewing Needle
      163720, -- Mildenhall Growth Formula
      163740, -- Drust Ritual Knife
      166972, -- Emergency Powerpack
      166973, -- Emergency Repair Kit
      167041, -- Coiled Current Culler
      168410, -- First Aid Kit
      169653, -- Potion of Mental Clarity
      172020, -- Battered Weapon
      173013, -- Bag of Faerie Dust
      173148, -- Steel Cleaver
      174197, -- Loremaster's Notebook
      174326, -- Rough Burlap Bandages
      177817, -- Voodoo Powder
      180613, -- Fragile Humility Scroll
      181364, -- Cluster of Seeds
      183689, -- Crusader's Dressing
      183698, -- Torturer's Key
      183797, -- Crusader's Dressing
      184622, -- Stygian Hammer
      186445, -- Mikanikos' Restorative Contraption
      186448, -- Mikanikos' Restorative Contraption
      186695, -- Lovely Pet Bandage
      187504, -- Mikanikos' Restorative Contraption
      192467, -- Bandages
      192795, -- Rejuvenating Draught
      194052, -- Forlorn Funeral Pall
      194434, -- Pungent Salve
      197805, -- Suspicious Persons Scanner
      202874, -- Healing Draught
      203731, -- Enchanted Bandage
      208124, -- The Dreamer's Essence
      208738, -- Ephemeral Pear
      208985, -- Silly Hat
      213539, -- Nebb's Poultice
      215145, -- Remembrance Stone
      216687, -- Cobbled Together Bandage
      217159, -- Nebb's Improved Poultice
      219385, -- Antiparalytic Serum
      224799, -- Nizrek's potion
    },
    [6] = {
      164766, -- Iwen's Enchanting Rod
      219525, -- Globe of Nourishment
    },
    [7] = {
      61323,  -- Ruby Seeds
      62899,  -- Enchanted Imp Sack
      63350,  -- Razor-Sharp Scorpid Barb
      88589,  -- Cremating Torch
      153249, -- Y'mera's Attuning Crystal
    },
    [8] = {
      33278,  -- Burning Torch
      34368,  -- Attuned Crystal Cores
      35943,  -- Jeremiah's Tools
      37932,  -- Miner's Lantern
      56821,  -- Oil Extrusion Pump
      82311,  -- Zouchin Rations
      82787,  -- Citron-Infused Bandages
      84242,  -- Shado-Pan Bandages
      128776, -- Red Wooden Sled
      152730, -- Sumber's Totem
    },
    [10] = {
      17626,  -- Frostwolf Muzzle
      17689,  -- Stormpike Training Collar
      21267,  -- Toasting Goblet
      22962,  -- Inoculating Crystal
      30656,  -- Protovoltaic Magneto Collector
      32321,  -- Sparrowhawk Net
      33418,  -- Tillinghast's Plague Canister
      34083,  -- Awakening Rod
      35293,  -- Cenarion Horn
      36859,  -- Snow of Eternal Slumber
      37307,  -- Purified Ashes of Vordrassil
      38697,  -- Jungle Punch Sample
      40551,  -- Gore Bladder
      41988,  -- Telluric Poultice
      42164,  -- Hodir's Horn
      43059,  -- Drakuru's Last Wish
      44576,  -- Bright Flare
      47033,  -- Light-Blessed Relic
      50131,  -- Snagglebolt's Air Analyzer
      52709,  -- Gnomish Playback Device
      52819,  -- Frostgale Crystal
      53009,  -- Juniper Berries
      54215,  -- Vol'jin's War Drums
      54462,  -- Moanah's Baitstick
      54463,  -- Flameseer's Staff
      56012,  -- Stone Knife of Sealing
      56222,  -- Runes of Return
      58167,  -- Spirit Totem
      58200,  -- Techno-Grenade
      58203,  -- Paintinator
      60382,  -- Mylra's Knife
      60870,  -- Barrel of Explosive Ale
      62057,  -- Teleport Beacon
      62326,  -- Heavy Manacles
      62541,  -- Heavy Manacles
      64312,  -- Totem of Freedom
      67249,  -- Viewpoint Equalizer
      68679,  -- Goblin Gas Tank
      69240,  -- Enchanted Salve
      78947,  -- Silken Rope
      79884,  -- Bucket of Slicky Water
      80220,  -- Forest Remedy
      81177,  -- Pandaren Healing Draught
      82381,  -- Yak's Milk Flask
      90067,  -- B. F. F. Necklace
      106958, -- Winterwasp Antidote
      106987, -- Sigil of Karabor
      107656, -- Kaz's Disturbing Crate
      112321, -- Enchanted Dust
      118418, -- Mug of Rousing Coffee
      119440, -- Training Shoes
      124100, -- Moonwater Vial
      129190, -- Rope of Friendship
      132877, -- Eye of Azzorok
      136386, -- Bloodstone
      140314, -- Crab Shank
      152278, -- Cracked Wand
      153537, -- Animate Sphere
      153565, -- Shackles
      156549, -- Writ of Sacrifice
      158190, -- Target Marker
      158907, -- Moonstone Pendant
      158908, -- Moonstone Weapon
      166701, -- Warbeast Kraal Dinner Bell
      166784, -- Narassin's Soul Gem
      166785, -- Detoxified Blight Grenade
      168053, -- Unusually Wise Hermit Crab
      168811, -- Wand of Absorption
      168891, -- Cursed Lover's Ring
      169860, -- Tiny Dapper Hat
      169943, -- Little Princess Cap
      169944, -- Minuscule Fez
      170161, -- Unusually Wise Hermit Crab
      172955, -- Gormherd Branch
      173870, -- Fading Glimmerdust
      174323, -- Torch
      175063, -- Aqir Egg Cluster
      184292, -- Ancient Elethium Coin
      184314, -- Broker Device
      187943, -- Fae Net
      191375, -- Delicate Suspension of Spores
      191376, -- Delicate Suspension of Spores
      191377, -- Delicate Suspension of Spores
      193917, -- Rejuvenating Draught
      202096, -- Armaments of the Scale
      202112, -- Crystal Shattering Armaments
      202271, -- Pouch of Gold Coins
      202714, -- M.U.S.T
      205045, -- B.B.F. Fist
      207632, -- Dream-Attuned Crystal
      219469, -- Fog Beast Tracker
      223322, -- Hannan's Scythe
    },
    [12] = {
      208068, -- Rotten Delicious
    },
    [15] = {
      1251,   -- Linen Bandage
      2581,   -- Heavy Linen Bandage
      3530,   -- Wool Bandage
      3531,   -- Heavy Wool Bandage
      6450,   -- Silk Bandage
      6451,   -- Heavy Silk Bandage
      8544,   -- Mageweave Bandage
      8545,   -- Heavy Mageweave Bandage
      14529,  -- Runecloth Bandage
      14530,  -- Heavy Runecloth Bandage
      19066,  -- Warsong Gulch Runecloth Bandage
      19067,  -- Warsong Gulch Mageweave Bandage
      19068,  -- Warsong Gulch Silk Bandage
      19307,  -- Alterac Heavy Runecloth Bandage
      20065,  -- Arathi Basin Mageweave Bandage
      20066,  -- Arathi Basin Runecloth Bandage
      20067,  -- Arathi Basin Silk Bandage
      20232,  -- Defiler's Mageweave Bandage
      20234,  -- Defiler's Runecloth Bandage
      20235,  -- Defiler's Silk Bandage
      20237,  -- Highlander's Mageweave Bandage
      20243,  -- Highlander's Runecloth Bandage
      20244,  -- Highlander's Silk Bandage
      21990,  -- Netherweave Bandage
      21991,  -- Heavy Netherweave Bandage
      30651,  -- Dertrok's First Wand
      30652,  -- Dertrok's Second Wand
      30653,  -- Dertrok's Third Wand
      30654,  -- Dertrok's Fourth Wand
      31129,  -- Blackwhelp Net
      32907,  -- Wolpertinger Net
      33621,  -- Plague Spray
      34721,  -- Frostweave Bandage
      34722,  -- Heavy Frostweave Bandage
      36764,  -- Shard of the Earth
      38573,  -- RJR Rifle
      39268,  -- Medallion of Mam'toth
      44646,  -- Dalaran Bandage
      44959,  -- Soothing Totem
      46722,  -- Grol'dom Net
      52481,  -- Blastshadow's Soulstone
      53049,  -- Embersilk Bandage
      53050,  -- Heavy Embersilk Bandage
      53051,  -- Dense Embersilk Bandage
      53101,  -- Tessina's Wisp Call
      53104,  -- Tessina's Hippogryph Call
      53105,  -- Tessina's Treant Call
      54851,  -- Anemone Chemical Application Device
      56184,  -- Duarn's Net
      58169,  -- Elementium Grapple Line
      58966,  -- Jesana's Faerie Dragon Call
      58967,  -- Jesana's Giant Call
      63391,  -- Baradin's Wardens Bandage
      64995,  -- Hellscream's Reach Bandage
      72985,  -- Windwool Bandage
      72986,  -- Heavy Windwool Bandage
      79027,  -- Saltback Meat
      82829,  -- Windwool Bandage
      111603, -- Antiseptic Bandage
      115475, -- Vial of Untested Serum
      115497, -- Ashran Bandage
      115533, -- Vial of Refined Serum
      133940, -- Silkweave Bandage
      133942, -- Silkweave Splint
      136653, -- Silvery Salve
      143636, -- Arcane Splint
      144228, -- Dino Mojo
      146971, -- Yseralline Poultice
      147445, -- Ancient Draught of Regeneration
      152395, -- Counter Spell Charm
      152613, -- Sar'jun's Torch
      158381, -- Tidespray Linen Bandage
      158382, -- Deep Sea Bandage
      158935, -- Depleted Soul Shard
      161333, -- Ultra-Safe Electrified Alpaca Lasso
      165762, -- Embiggifier Core
      165815, -- Tranquilizer Dart
      173191, -- Heavy Shrouded Cloth Bandage
      173192, -- Shrouded Cloth Bandage
      173691, -- Anima Drainer
      179359, -- Sinstone Fragment
      179921, -- Hydra Gutter
      179978, -- Infused Animacones
      179983, -- Infused Animacones
      186102, -- Lady Moonberry's Wand
      186569, -- Angry Needler Nest
      189384, -- Ornithological Medical Kit
      193064, -- Smoke Diffuser
      194048, -- Wildercloth Bandage
      194049, -- Wildercloth Bandage
      194050, -- Wildercloth Bandage
      197928, -- Captivating Cap
      211943, -- Scarlet Silk Bandage
      215133, -- Binding of Binding
      219322, -- Malodorous Philter
      219323, -- Gelatinous Unguent
      219324, -- Roiling Elixir
      224194, -- Fashion Frenzy Ribbon
      224440, -- Weavercloth Bandage
      224441, -- Weavercloth Bandage
      224442, -- Weavercloth Bandage
    },
    [20] = {
      17757,  -- Amulet of Spirits
      21519,  -- Mistletoe
      22473,  -- Antheol's Disciplinary Rod
      23394,  -- Healing Salve
      23693,  -- Carinda's Scroll of Retribution
      29817,  -- Talbuk Tagger
      29818,  -- Energy Field Modulator
      30175,  -- Gor'drek's Ointment
      33088,  -- Brogg's Totem
      34127,  -- Tasty Reef Fish
      34257,  -- Fel Siphon
      34711,  -- Core of Malice
      34869,  -- Warsong Banner
      36796,  -- Gavrock's Runebreaker
      36827,  -- Blood Gem
      36835,  -- Unholy Gem
      36847,  -- Frost Gem
      37708,  -- Stick
      39157,  -- Scepter of Suggestion
      39206,  -- Scepter of Empowerment
      39238,  -- Scepter of Command
      39577,  -- Rejek's Blade
      39651,  -- Venture Co. Explosives
      39664,  -- Scepter of Domination
      40397,  -- Lifeblood Gem
      42624,  -- Battered Storm Hammer
      42894,  -- Horn of Elemental Fury
      43206,  -- War Horn of Acherus
      43315,  -- Sigil of the Ebon Blade
      44817,  -- The Mischief Maker
      44975,  -- Orb of Elune
      46363,  -- Lifebringer Sapling
      48104,  -- The Refleshifier
      49202,  -- Black Gunpowder Keg
      52044,  -- Bilgewater Cartel Promotional Delicacy Morsels
      52073,  -- Bramblestaff
      52484,  -- Kaja'Cola Zero-One
      52566,  -- Motivate-a-Tron
      53107,  -- Flameseer's Staff
      55141,  -- Spiralung
      55158,  -- Fake Treasure
      55230,  -- Soul Stick
      56798,  -- Jin'Zil's Voodoo Stick
      57920,  -- Revantusk War Drums
      58177,  -- Earthen Ring Proclamation
      63079,  -- Titanium Shackles
      63426,  -- Lethality Analyzer
      67241,  -- Sullah's Camel Harness
      68606,  -- Murloc Leash
      71085,  -- Runestaff of Nordrassil
      77475,  -- Stack of Mantras
      85884,  -- Sonic Emitter
      87558,  -- Ella's Brew
      87763,  -- Ella's Brew
      88487,  -- Volatile Orb
      88587,  -- Iron Belly Spirits
      91902,  -- Universal Remote
      93180,  -- Re-Configured Remote
      93751,  -- Blessed Torch
      103786, -- \"Dapper Gentleman\" Costume
      103789, -- \"Little Princess\" Costume
      103795, -- \"Dread Pirate\" Costume
      103797, -- Big Pink Bow
      110508, -- \"Fragrant\" Pheromone Fish
      114967, -- Torch
      116172, -- Perky Blaster
      116810, -- \"Mad Alchemist\" Costume
      116811, -- \"Lil' Starlet\" Costume
      116812, -- \"Yipp-Saron\" Costume
      118414, -- Awesomefish
      118415, -- Grieferfish
      118511, -- Tyfish
      124506, -- Vial of Fel Cleansing
      127707, -- Indestructible Bone
      128634, -- Mysterious Brew
      128650, -- \"Merry Munchkin\" Costume
      130260, -- Thaedris's Elixir
      134119, -- Overloaded Collar
      134824, -- \"Sir Pugsington\" Costume
      134860, -- Peddlefeet's Buffing Creme
      142260, -- Arcane Nullifier
      142494, -- Purple Blossom
      142495, -- Fake Teeth
      142496, -- Dirty Spoon
      142497, -- Tiny Pack
      143865, -- Abyssal Crest
      147886, -- Battle Token
      151135, -- Stein of Grog
      151763, -- Crab Trap
      151912, -- Shroud of Arcane Echoes
      152590, -- Wicker Charm
      158174, -- Battleworn Armor Kit
      162140, -- Battleworn Armor Kit
      162631, -- Souvenir Tiki Tumbler
      163172, -- Green Glowing Puffer
      163516, -- Blue Glowing Puffer
      163517, -- Red Glowing Puffer
      163518, -- Purple Glowing Puffer
      163520, -- Orange Glowing Puffer
      163521, -- Yellow Glowing Puffer
      167071, -- Mechano-Treat
      167091, -- Maedin's Scroll
      168122, -- NRG-100
      168525, -- Poison Globule
      173534, -- Gormherd Branch
      174749, -- Bone Splinter
      183105, -- Tormentor's Rod
      184505, -- \"Adorable Ascended\" Costume
      184506, -- \"Flying Faerie\" Costume
      186094, -- Siphoning Device
      187708, -- Broken Helm
      187816, -- Irresistible Goop
      187839, -- Tonal Jammer
      188002, -- Broken Helm
      188697, -- Kinematic Micro-Life Recalibrator
      189449, -- Jiro Scan
      189479, -- Chromatic Rosid
      189561, -- Tame Prime: Orixal
      189572, -- Tame Prime: Hadeon the Stonebreaker
      189573, -- Tame Prime: Garudeon
      191408, -- Explosive Pie
      191682, -- Explosive Pie
      191854, -- Briny Seawater
      191865, -- Bottle of Briny Seawater
      192477, -- [PH] Primalist Keystone
      192743, -- Wild Bushfruit
      194447, -- Totem of Respite
      202310, -- Defective Doomsday Device
      202875, -- Snail Lasso
      203706, -- Hurricane Scepter
      205980, -- Snail Lasso
      208884, -- Root Restoration Fruit
      211535, -- Scroll of Shattering
      223312, -- Trusty Hat
      223316, -- Trusty Hat
      229413, -- \"Dogg-Saron\" Costume
    },
    [25] = {
      13289,  -- Egan's Blaster
      31463,  -- Zezzak's Shard
      34979,  -- Pouch of Crushed Bloodspore
      46885,  -- Weighted Net
      56247,  -- Box of Crossbow Bolts
      74771,  -- Staff of Pei-Zhi
      117013, -- Wand of Lightning Shield
      152983, -- Bundle of Ranishu \"Food\"
      153012, -- Poisoned Mojo Flask
      169308, -- Chain of Suffering
      170540, -- Ravenous Anima Cell
      185775, -- Codex of Renewed Vigor
      198088, -- Darkmoon Deck: Dance
      198478, -- Darkmoon Deck Box: Dance
      204274, -- Ancient Memories
      204808, -- Empowered Temporal Gossamer
      208846, -- Restored Dreamleaf
      209349, -- Lydiara's Notes on Rune Reagents
      210010, -- Erden's Notes on Symbiotic Spores
      210011, -- Shalasar's Notes on Sophic Magic
      210199, -- Tattered Dreamleaf
      210881, -- Cunning Charm
      228996, -- Relic of Crystal Connections
    },
    [30] = {
      954,    -- Scroll of Strength
      955,    -- Scroll of Intellect
      1180,   -- Scroll of Stamina
      1181,   -- Scroll of Versatility
      1477,   -- Scroll of Agility II
      1478,   -- Scroll of Protection II
      1711,   -- Scroll of Stamina II
      1712,   -- Scroll of Versatility II
      2289,   -- Scroll of Strength II
      2290,   -- Scroll of Intellect II
      3012,   -- Scroll of Agility
      3013,   -- Scroll of Protection
      4381,   -- Minor Recombobulator
      4419,   -- Scroll of Intellect III
      4421,   -- Scroll of Protection III
      4422,   -- Scroll of Stamina III
      4424,   -- Scroll of Versatility III
      4425,   -- Scroll of Agility III
      4426,   -- Scroll of Strength III
      4444,   -- Black Husk Shield
      5613,   -- Staff of the Purifier
      6452,   -- Anti-Venom
      6453,   -- Strong Anti-Venom
      10305,  -- Scroll of Protection IV
      10306,  -- Scroll of Versatility IV
      10307,  -- Scroll of Stamina IV
      10308,  -- Scroll of Intellect IV
      10309,  -- Scroll of Agility IV
      10310,  -- Scroll of Strength IV
      11567,  -- Crystal Spire
      17202,  -- Snowball
      17310,  -- Aspect of Neptulon
      18637,  -- Major Recombobulator
      19440,  -- Powerful Anti-Venom
      21713,  -- Elune's Candle
      22200,  -- Silver Shafted Arrow
      22218,  -- Handful of Rose Petals
      23337,  -- Cenarion Antidote
      27498,  -- Scroll of Agility V
      27499,  -- Scroll of Intellect V
      27500,  -- Scroll of Protection V
      27501,  -- Scroll of Versatility V
      27502,  -- Scroll of Stamina V
      27503,  -- Scroll of Strength V
      31437,  -- Medicinal Drake Essence
      31828,  -- Ritual Prayer Beads
      32680,  -- Booterang
      32960,  -- Elekk Dispersion Ray
      33108,  -- Ooze Buster
      33457,  -- Scroll of Agility VI
      33458,  -- Scroll of Intellect VI
      33459,  -- Scroll of Protection VI
      33460,  -- Scroll of Versatility VI
      33461,  -- Scroll of Stamina VI
      33462,  -- Scroll of Strength VI
      33865,  -- Amani Hex Stick
      34068,  -- Weighted Jack-o'-Lantern
      34191,  -- Handful of Snowflakes
      34598,  -- The King's Empty Conch
      34684,  -- Handful of Summer Petals
      35557,  -- Huge Snowball
      36732,  -- Potent Explosive Charges
      37091,  -- Scroll of Intellect VII
      37092,  -- Scroll of Intellect VIII
      37093,  -- Scroll of Stamina VII
      37094,  -- Scroll of Stamina VIII
      37097,  -- Scroll of Versatility VII
      37098,  -- Scroll of Versatility VIII
      38515,  -- Tangled Skein Thrower
      40686,  -- U.D.E.D.
      40917,  -- Lord-Commander's Nullifier
      42774,  -- Arngrim's Tooth
      43463,  -- Scroll of Agility VII
      43464,  -- Scroll of Agility VIII
      43465,  -- Scroll of Strength VII
      43466,  -- Scroll of Strength VIII
      43467,  -- Scroll of Protection VII
      43468,  -- Scroll of Protection VIII
      44653,  -- Volatile Acid
      44915,  -- Elune's Candle
      45073,  -- Spring Flowers
      49138,  -- Bottle of Leeches
      49199,  -- Infernal Power Core
      49882,  -- Soothing Seeds
      50163,  -- Lovely Rose
      52710,  -- Enchanted Conch
      52715,  -- Butcherbot Control Gizmo
      56069,  -- Alliance Weapon Crate
      56227,  -- Enchanted Conch
      57172,  -- Attuned Runestone of Binding
      58935,  -- Gryphon Chow
      60861,  -- Holy Thurible
      63303,  -- Scroll of Agility IX
      63304,  -- Scroll of Strength IX
      63305,  -- Scroll of Intellect IX
      63306,  -- Scroll of Stamina IX
      63307,  -- Scroll of Versatility IX
      63308,  -- Scroll of Protection IX
      64637,  -- Tanrir's Overcharged Totem
      69825,  -- Essence Gatherer
      80337,  -- Ken-Ken's Mask
      85231,  -- Bag of Clams
      86589,  -- Ai-Li's Skymirror
      88580,  -- Ken-Ken's Mask
      92019,  -- The Bilgewater Molotov
      110490, -- Larry Bugged Item
      110492, -- Flamewrought Jewel
      116648, -- Manufactured Love Prism
      116651, -- True Love Prism
      118179, -- Talbuk Lasso
      118181, -- Clefthoof Lasso
      118182, -- Wolf Lasso
      118183, -- Riverbeast Lasso
      118184, -- Elekk Lasso
      118185, -- Boar Lasso
      118283, -- Wolf Lasso
      118284, -- Talbuk Lasso
      118285, -- Riverbeast Lasso
      118286, -- Elekk Lasso
      118287, -- Clefthoof Lasso
      118288, -- Boar Lasso
      118643, -- Huge Crate of Weapons
      119083, -- Fruit Basket
      128632, -- Savage Snowball
      128648, -- Yellow Snowball
      136339, -- Spellstone of Kel'danath
      138026, -- Empowered Charging Device
      138733, -- Shadescale Manipulator
      139427, -- Wild Mana Wand
      143863, -- Fel Exfoliator
      147420, -- Pebble
      153219, -- Squished Demon Eye
      156665, -- Bag of Transmutation Stones
      156831, -- Bag of Transmutation Stones
      158332, -- Zeth'jir Channeling Rod
      160307, -- Raal's Hexing Stick
      160525, -- Tongo's Head
      166230, -- Re-Discombobulator
      166797, -- Star Topaz
      168407, -- Friendship Net
      168947, -- Scroll of Bursting Power
      169209, -- Scroll of Bursting Power
      169446, -- Water Filled Bladder
      169673, -- Blue Paint Filled Bladder
      169674, -- Green Paint Filled Bladder
      169675, -- Orange Paint Filled Bladder
      173358, -- Invitations
      173693, -- Jar of Maggots
      173888, -- Shard of Self Sacrifice
      178873, -- Concentrated Anima Vial
      183944, -- Heron Net
      188692, -- Pouch of Ebon Rose Petals
      188693, -- Pouch of Red Rose Petals
      189454, -- Feather-Plucker 3300
      192471, -- Arch Instructor's Wand
      193736, -- Water's Beating Heart
      193757, -- Ruby Whelp Shell
      193892, -- Wish's Whistle
      194122, -- Sour Apple
      194712, -- Empty Duck Trap
      194731, -- Illusion Parchment: Magma Missile
      194733, -- Illusion Parchment: Aqua Torrent
      194734, -- Illusion Parchment: Whirling Breeze
      194735, -- Illusion Parchment: Arcane Burst
      194736, -- Illusion Parchment: Chilling Wind
      194738, -- Illusion Parchment: Shadow Orb
      194818, -- Proto-Drake Wrangler Rope
      200120, -- Irideus' Power Core
      202270, -- [DNT] Twice-Woven Rope
      204473, -- Element Siphoner
      205688, -- Glutinous Glitterscale Glob
      206160, -- Madam Shadow's Grimoire
      210755, -- Silent Mark of the Dreamsaber
      210764, -- Silent Mark of the Dreamtalon
      210766, -- Silent Mark of the Umbraclaw
      210767, -- Silent Mark of the Dreamstag
      212602, -- Titan Emitter
      215142, -- Freydrin's Shillelagh
      215158, -- Freydrin's Shillelagh
      218124, -- Element Extractor
      223220, -- Kaheti All-Purpose Cleanser
      224026, -- Storm Vessel
      225887, -- Titan Emitter
    },
    [35] = {
      18904,  -- Zorbin's Ultra-Shrinker
      24501,  -- Gordawg's Boulder
      35121,  -- Wolf Bait
      41505,  -- Thorim's Charm of Earth
      44890,  -- To'kini's Blowgun
      49028,  -- Nitro-Potassium Bananas
      56576,  -- Orb of Suggestion
      151363, -- Ticker's Rocket Launcher
      180899, -- Riding Hook
      193212, -- Marmoni Rescue Pack
    },
    [38] = {
      140786, -- Ley Spider Eggs
    },
    [40] = {
      1713,   -- Ankh of Life
      5232,   -- Soulstone
      5323,   -- Everglow Lantern
      8346,   -- Gauntlets of the Sea
      11562,  -- Crystal Restore
      18640,  -- Happy Fun Rock
      18662,  -- Heavy Leather Ball
      31088,  -- Tainted Core
      33081,  -- Voodoo Skull
      33581,  -- Vrykul Insult
      34255,  -- Razorthorn Flayer Gland
      34471,  -- Vial of the Sunwell
      34494,  -- Paper Zeppelin
      37438,  -- Rod of Compulsion
      38266,  -- Rotund Relic
      38308,  -- Ethereal Essence Sphere
      38332,  -- Modified Mojo
      39305,  -- Tiki Hex Remover
      39615,  -- Crusader Parachute
      40532,  -- Living Ice Crystals
      44114,  -- Old Spices
      44222,  -- Dart Gun
      44228,  -- Baby Spice
      44812,  -- Turkey Shooter
      50354,  -- Bauble of True Blood
      50430,  -- Scraps of Rotting Meat
      50726,  -- Bauble of True Blood
      52490,  -- Stardust
      53794,  -- Rendel's Bridle
      55165,  -- Enchanted Sea Snack
      56136,  -- Corrupted Egg Shell
      56169,  -- Breathstone
      56463,  -- Corrupted Egg Shell
      60490,  -- The Axe of Earthly Sundering
      60808,  -- Mutant Bush Chicken Cage
      65162,  -- Emergency Pool Pony
      71627,  -- Throwing Starfish
      74612,  -- Red Panda Lasso
      82468,  -- Yak Lasso
      90883,  -- The Pigskin
      90888,  -- Special Edition Foot Ball
      92965,  -- Rotten Fruit
      92980,  -- Friendly Favor
      93668,  -- Saur Fetish
      94525,  -- Stolen Relic of Zuldazar
      95763,  -- Stolen Relic of Zuldazar
      96135,  -- Stolen Relic of Zuldazar
      96507,  -- Stolen Relic of Zuldazar
      96879,  -- Stolen Relic of Zuldazar
      104323, -- The Swineskin
      104324, -- Foot Ball
      110426, -- Goblin Hot Potato
      110506, -- Parasitic Starfish
      114926, -- Restorative Goldcap
      116400, -- Silver-Plated Turkey Shooter
      116759, -- Blixthraz's Frightening Grudgesolver
      118190, -- Blixthraz's Frightening Grudgesolver
      118236, -- Counterfeit Coin
      119159, -- Happy Fun Skull
      128505, -- Celebration Wand - Murloc
      128506, -- Celebration Wand - Gnoll
      128772, -- Branch of the Runewood
      132511, -- Pump-Action Bandage Gun
      133305, -- Corrupted Egg Shell
      133462, -- Vial of the Sunwell
      133706, -- Mossgill Bait
      133928, -- Prototype Pump-Action Bandage Gun
      133998, -- Rainbow Generator
      133999, -- Inert Crystal
      136927, -- Scarlet Confessional Book
      137462, -- Jewel of Insatiable Desire
      138884, -- Throwing Sausage
      139333, -- Horn of Cenarius
      139882, -- Vial of Hippogryph Pheromones
      141005, -- Vial of Hippogryph Pheromones
      141306, -- Wisp in a Bottle
      141411, -- Translocation Anomaly Neutralization Crystal
      147882, -- Celebration Wand - Trogg
      147883, -- Celebration Wand - Quilboar
      152574, -- Corbyn's Beacon
      152996, -- Vrykul Toy Boat
      153182, -- Holy Lightsphere
      153483, -- Modified Blood Fetish
      153571, -- Poisoned Blow Dart
      153675, -- Scroll of Capsizing
      155567, -- Mr. Munchykins
      155569, -- Mayor Striggs
      156528, -- Titan Manipulator
      156649, -- Zandalari Effigy Amulet
      156868, -- Crawg Poison Gland
      158320, -- Revitalizing Voodoo Totem
      159882, -- Bug Zapper
      160649, -- Inoculating Extract
      163741, -- Magic Fun Rock
      165702, -- Shard of Vesara
      167863, -- Pillar of the Drowned Cabal
      167865, -- Void Stone
      168012, -- Apexis Focusing Shard
      169152, -- Empty Beehive
      169305, -- Aquipotent Nautilus
      169311, -- Ashvane's Razor Coral
      169490, -- Relic of the Black Empire
      173379, -- Purify Stone
      174007, -- Purifying Draught
      174927, -- Zan-Tien Lasso
      175733, -- Brimming Ember Shard
      178495, -- Shattered Helm of Domination
      178496, -- Baron's Warhorn
      178530, -- Wreath-A-Rang
      180953, -- Soultwinning Scepter
      181360, -- Brimming Ember Shard
      182653, -- Larion Treats
      183599, -- Tossable Head
      183808, -- Leashed Construct
      184017, -- Bargast's Leash
      184313, -- Shattered Helm of Domination
      184841, -- Lyre of Sacred Purpose
      185720, -- Draka's Battlehorn
      186421, -- Forbidden Necromantic Tome
      186474, -- Korayn's Javelin
      188761, -- Happy Fun Sphere
      191044, -- Spider Squasher
      193678, -- Miniature Singing Stone
      193826, -- Trusty Dragonkin Rake
      193856, -- Flowery's Rake
      198047, -- Kul Tiran Red
      198081, -- Caregiver's Charm
      201815, -- Cloak of Many Faces
      203714, -- Ward of Faceless Ire
      204343, -- Trusty Dragonkin Rake
      204388, -- Draconic Cauterizing Magma
      204714, -- Satchel of Healing Spores
      207390, -- Delve Ring
      211000, -- Cunning Charm
      217929, -- Timeless Scroll of Cleansing
      219306, -- Burin of the Candle King
      225656, -- Goldenglow Censer
    },
    [45] = {
      28369,  -- Battery Recharging Blaster
      32698,  -- Wrangling Rope
      34691,  -- Arcane Binder
      49647,  -- Drum of the Soothed Earth
      52059,  -- Murloc Leash
      52833,  -- Modified Soul Orb
      62794,  -- Licensed Proton Accelerator Cannon
      88377,  -- Turnip Paint \"Gun\"
      207057, -- Gift of the White War Wolf
      207083, -- Gift of the Ravenous Black Gryphon
    },
    [46] = {
      219320, -- Viscous Coaglam
    },
    [50] = {
      110009, -- Leaf of the Ancient Protectors
      116139, -- Haunting Memento
      147006, -- Archive of Faith
      147007, -- The Deceiver's Grand Design
      151957, -- Ishkar's Felshield Emitter
      151958, -- Tarratus Keystone
      160443, -- The Glaive of Vol'jin
      160557, -- Pungent Onion
      161452, -- The Glaive of Vol'jin
      165578, -- Mirror of Entwined Fate
      182451, -- Glimmerdust's Grand Design
      184020, -- Tuft of Smoldering Plumage
      184029, -- Manabound Mirror
      207084, -- Auebry's Marker Pistol
      212175, -- Draconic Commendation
    },
    [55] = {
      74637,  -- Kiryn's Poison Vial
    },
    [60] = {
      32825,  -- Soul Cannon
      34111,  -- Trained Rock Falcon
      34121,  -- Trained Rock Falcon
      37877,  -- Silver Feather
      37887,  -- Seeds of Nature's Wrath
      50851,  -- Pulsing Life Crystal
      127030, -- Granny's Flare Grenades
      153679, -- Tether Shot
      156928, -- Tether Shot
      169279, -- Pedram's Marker Pistol
    },
    [70] = {
      41265,  -- Eyesore Blaster
      202642, -- Proto-Killing Spear
    },
    [80] = {
      35278,  -- Reinforced Net
      35506,  -- Raelorasz's Spear
      42769,  -- Spear of Hodir
      50031,  -- Tomusa's Hook
      62775,  -- Barbed Fleshhook
      63092,  -- Wyrmhunter Hooks
      63104,  -- Elemental Nullifier
      63393,  -- Shoulder-Mounted Drake-Dropper
      152572, -- Sezahjin's Trusty Vulture Bow
      152610, -- Sur'jan's Grappling Hook
      159761, -- Grappling Hook
      168253, -- Fathom Hook
      185742, -- Mawsworn Chains
      194891, -- Arcane Hook
    },
    [90] = {
      133925, -- Fel Lash
    },
    [100] = {
      41058,  -- Hyldnir Harpoon
      44212,  -- SGM-3
      83134,  -- Bronze Claws
      109082, -- Barbed Harpoon
      160739, -- Goblin Rocket Launcher
      161422, -- Magister Umbric's Void Shard
      200549, -- Restored Titan Artifact
      202020, -- Chasing Storm
      210223, -- Unstable Element
      222976, -- Flame-Tempered Harpoon
    },
    [120] = {
      160988, -- Goblin Incendiary Rocket Launcher
      168430, -- Clobberbottom's Boomer
      169681, -- BOOM-TASTIC 3000
      211963, -- Ceiling Sweeper
    },
    [150] = {
      46954,  -- Flaming Spears
      153204, -- All-Seer's Eye
      192750, -- Black Iron Javelin
    },
    [200] = {
      75208,  -- Rancher's Lariat
      86546,  -- Sky Crystal
      89163,  -- Requisitioned Firework Launcher
      152657, -- Target Designator
    },
    -- [50000] = {
    --   130867, -- Tag Toy
    --   136403, -- Staff of Four Winds
    --   146406, -- Vantus Rune: Tomb of Sargeras
    --   151610, -- Vantus Rune: Antorus, the Burning Throne
    --   153673, -- Vantus Rune: Uldir
    --   165692, -- Vantus Rune: Battle of Dazar'alor
    --   165733, -- Vantus Rune: Crucible of Storms
    --   168624, -- Vantus Rune: The Eternal Palace
    --   171203, -- Vantus Rune: Ny'alotha, the Waking City
    --   173067, -- Vantus Rune: Castle Nathria
    --   186662, -- Vantus Rune: Sanctum of Domination
    --   187805, -- Vantus Rune: Sepulcher of the First Ones
    --   189584, -- Sepulcher's Savior
    --   198491, -- Vantus Rune: Vault of the Incarnates
    --   198492, -- Vantus Rune: Vault of the Incarnates
    --   198493, -- Vantus Rune: Vault of the Incarnates
    --   204858, -- Vantus Rune: Aberrus, the Shadowed Crucible
    --   204859, -- Vantus Rune: Aberrus, the Shadowed Crucible
    --   204860, -- Vantus Rune: Aberrus, the Shadowed Crucible
    --   210247, -- Vantus Rune: Amirdrassil, the Dream's Hope
    --   210248, -- Vantus Rune: Amirdrassil, the Dream's Hope
    --   210249, -- Vantus Rune: Amirdrassil, the Dream's Hope
    -- },
  }
end

local HarmItems
if isEra then
  HarmItems = {
    [5] = {
      8149,   -- Voodoo Charm
      15826,  -- Curative Animal Salve
      16308,  -- Northridge Crowbar
      17117,  -- Rat Catcher's Flute
      22259,  -- Unbestowed Friendship Bracelet
      22432,  -- Devilsaur Barb
      206466, -- Prairie Crown
      208760, -- Glade Crown
      208855, -- Rainbow Fin Albacore Chum
      209027, -- Crab Treats
      209057, -- Prototype Engine
      213036, -- Water of Elune'ara
      221199, -- Satyrweed Tincture
      225943, -- Rancid Hunk of Flesh
    },
    [10] = {
      9606,   -- Treant Muisek Vessel
      9618,   -- Wildkin Muisek Vessel
      9619,   -- Hippogryph Muisek Vessel
      9620,   -- Faerie Dragon Muisek Vessel
      9621,   -- Mountain Giant Muisek Vessel
      10699,  -- Yeh'kinya's Bramble
      17626,  -- Frostwolf Muzzle
      17689,  -- Stormpike Training Collar
      226472, -- Stratholme Shadow Jar
    },
    [15] = {
      4559,   -- CHU's QUEST ITEM
    },
    [20] = {
      1191,   -- Bag of Marbles
      2012,   -- Deprecated Phylactery of Rot
      4388,   -- Discombobulator Ray
      10645,  -- Gnomish Death Ray
      13892,  -- Kodo Kombobulator
      17757,  -- Amulet of Spirits
      18209,  -- Energized Sparkplug
      22048,  -- Lord Valthalak's Amulet
      202251, -- Bag of Pet Treats
      227936, -- Diplomat Ring
      232344, -- Vick's VIP Pass
    },
    [25] = {
      13289,  -- Egan's Blaster
    },
    [30] = {
      835,    -- Large Rope Net
      1404,   -- Tidal Charm
      1434,   -- Glowing Wax Stick
      1444,   -- Deprecated Inferno Stone
      1472,   -- Deprecated Polished Lakestone Charm
      1704,   -- Deprecated Cold Basilisk Eye
      1854,   -- Deprecated Brooch of the Night Watch
      1914,   -- Deprecated Miniature Silver Hammer
      1995,   -- Deprecated Cat's Paw
      2091,   -- Magic Dust
      3434,   -- Slumber Sand
      3441,   -- Deprecated Crippling Agent
      4479,   -- Burning Charm
      4480,   -- Thundering Charm
      4481,   -- Cresting Charm
      4941,   -- Really Sticky Glue
      5079,   -- Cold Basilisk Eye
      5457,   -- Severed Voodoo Claw
      6436,   -- Burning Gem
      7344,   -- Torch of Holy Flame
      7734,   -- Six Demon Bag
      9328,   -- Super Snapper FX
      9394,   -- Horned Viking Helmet
      10588,  -- Goblin Rocket Helmet
      10716,  -- Gnomish Shrink Ray
      10720,  -- Gnomish Net-o-Matic Projector
      11170,  -- Deprecated Silver Totem of Aquementas
      11522,  -- Silver Totem of Aquementas
      11565,  -- Crystal Yield
      12288,  -- Encased Corrupt Ooze
      12646,  -- Infus Emerald
      12647,  -- Felhas Ruby
      13213,  -- Smolderweb's Eye
      13509,  -- Clutch of Foresight
      13514,  -- Wail of the Banshee
      17202,  -- Snowball
      17310,  -- Aspect of Neptulon
      20084,  -- Hunting Net
      20908,  -- Festival of Nian Firework
      21038,  -- Hardpacked Snowball
      21713,  -- Elune's Candle
      22200,  -- Silver Shafted Arrow
      22206,  -- Bouquet of Red Roses
      22218,  -- Handful of Rose Petals
      220649, -- Merithra's Inheritence
      228576, -- Smolderweb's Eye
      233226, -- Ancient Zandalarian Rope
    },
    [35] = {
      996,    -- Ring of Righteous Flame (TEST)
      1258,   -- Bind On Use Test Item
      1399,   -- Magic Candle
      1402,   -- Brimstone
      8688,   -- Bind On Acquire Test Item
      18904,  -- Zorbin's Ultra-Shrinker
      220568, -- Temple Explorer's Gun Axe
      233216, -- Freez-O-Matic Ray
    },
    [40] = {
      4945,   -- Faintly Glowing Skull
      8348,   -- Helm of Fire
      191414, -- Skeletal Artifact
      208773, -- Fishing Harpoon
      208843, -- Battle Totem
      209047, -- Gnarled Harpoon
    },
    [45] = {
      221316, -- Premo's Poise-Demanding Uniform
    },
    [100] = {
      5418,   -- Weapon of Mass Destruction (test)
      17162,  -- Eric Test Item A
      23715,  -- Permanent Lung Juice Cocktail
      23718,  -- Permanent Ground Scorpok Assay
      23719,  -- Permanent Cerebral Cortex Compound
      23721,  -- Permanent Gizzard Gum
      23722,  -- Permanent R.O.I.D.S.
      227685, -- Modified Shadow Scalpel
    },
    -- [50000] = {
    --   228227, -- Scroll of Overwhelming Power
    -- },
  }
elseif isCata then
  HarmItems = {
    [3] = {
      42732,  -- Everfrost Razor
    },
    [5] = {
      8149,   -- Voodoo Charm
      15826,  -- Curative Animal Salve
      17117,  -- Rat Catcher's Flute
      22259,  -- Unbestowed Friendship Bracelet
      22432,  -- Devilsaur Barb
      23485,  -- Empty Birdcage
      23659,  -- Fel-Tainted Morsels
      33310,  -- The Sergeant's Machete
      33342,  -- The Brave's Machete
      33554,  -- Grick's Bonesaw
      33563,  -- Forsaken Banner
      33806,  -- Runeseeking Pick
      34954,  -- Torp's Kodo Snaffle
      34973,  -- Re-Cursive Transmatter Injection
      35116,  -- The Ultrasonic Screwdriver
      35401,  -- The Greatmother's Soulcatcher
      35736,  -- Bounty Hunter's Cage
      36771,  -- Sturdy Crates
      36786,  -- Bark of the Walkers
      36956,  -- Liquid Fire of Elune
      37045,  -- Kilian's Camera
      37125,  -- Rokar's Camera
      37187,  -- Container of Rats
      37202,  -- Onslaught Riding Crop
      37568,  -- Renewing Tourniquet
      37576,  -- Renewing Bandage
      38330,  -- Crusader's Bandage
      38467,  -- Softknuckle Poker
      38627,  -- Mammoth Harness
      38676,  -- Whisker of Har'koa
      38731,  -- Ahunae's Knife
      40587,  -- Darkmender's Tincture
      45001,  -- Medicated Salve
      45080,  -- Large Femur
      49743,  -- Sten's First Aid Kit
      49948,  -- Calder's Bonesaw
      50742,  -- Tara's Tar Scraper
      50746,  -- Tara's Tar Scraper
      52014,  -- Herb-Soaked Bandages
      52271,  -- Northwatch Manacles
      52712,  -- Remote Control Fireworks
      53120,  -- Bottled Bileberry Brew
      56837,  -- Sturdy Manacles
      58502,  -- Explosive Bonding Compound
      58885,  -- Rockslide Reagent
      58955,  -- Razgar's Fillet Knife
      58965,  -- Deepvein's Patch Kit
      61302,  -- Light-Touched Blades
      63150,  -- Shovel
      63427,  -- Worgsaw
      65667,  -- Shovel of Mercy
      67232,  -- Sullah's Pygmy Pen
      71978,  -- Darkmoon Bandage
      72110,  -- Battered Wrench
    },
    [7] = {
      61323,  -- Ruby Seeds
      62899,  -- Enchanted Imp Sack
      63350,  -- Razor-Sharp Scorpid Barb
    },
    [8] = {
      29052,  -- Warp Nether Extractor
      33278,  -- Burning Torch
      34368,  -- Attuned Crystal Cores
      35943,  -- Jeremiah's Tools
      37932,  -- Miner's Lantern
      56821,  -- Oil Extrusion Pump
      68678,  -- Child Safety Harness
    },
    [10] = {
      9606,   -- Treant Muisek Vessel
      9618,   -- Beast Muisek Vessel
      9619,   -- Hippogryph Muisek Vessel
      9620,   -- Faerie Dragon Muisek Vessel
      9621,   -- Mountain Giant Muisek Vessel
      10699,  -- Yeh'kinya's Bramble
      17626,  -- Frostwolf Muzzle
      17689,  -- Stormpike Training Collar
      22896,  -- Healing Crystal
      22962,  -- Inoculating Crystal
      28547,  -- Elemental Power Extractor
      30656,  -- Protovoltaic Magneto Collector
      32321,  -- Sparrowhawk Net
      33418,  -- Tillinghast's Plague Canister
      34083,  -- Awakening Rod
      34250,  -- Skill: Throw Bullet
      35293,  -- Cenarion Horn
      36859,  -- Snow of Eternal Slumber
      37307,  -- Purified Ashes of Vordrassil
      38697,  -- Jungle Punch Sample
      40551,  -- Gore Bladder
      41988,  -- Telluric Poultice
      42164,  -- Hodir's Horn
      43059,  -- Drakuru's Last Wish
      44576,  -- Bright Flare
      47033,  -- Light-Blessed Relic
      50131,  -- Snagglebolt's Air Analyzer
      52709,  -- Gnomish Playback Device
      52819,  -- Frostgale Crystal
      53009,  -- Juniper Berries
      54215,  -- Vol'jin's War Drums
      54462,  -- Moanah's Baitstick
      54463,  -- Flameseer's Staff
      56012,  -- Stone Knife of Sealing
      56222,  -- Runes of Return
      56794,  -- Subjugator Devo's Whip
      58167,  -- Spirit Totem
      58200,  -- Techno-Grenade
      58203,  -- Paintinator
      60382,  -- Mylra's Knife
      60870,  -- Barrel of Explosive Ale
      62057,  -- Teleport Beacon
      62326,  -- Heavy Manacles
      62541,  -- Heavy Manacles
      64312,  -- Totem of Freedom
      67249,  -- Viewpoint Equalizer
      68677,  -- Moldy Lunch
      68679,  -- Goblin Gas Tank
      68682,  -- Inflatable Lifesaver
      69240,  -- Enchanted Salve
    },
    [15] = {
      30651,  -- Dertrok's First Wand
      30652,  -- Dertrok's Second Wand
      30653,  -- Dertrok's Third Wand
      30654,  -- Dertrok's Fourth Wand
      31129,  -- Blackwhelp Net
      32907,  -- Wolpertinger Net
      33069,  -- Sturdy Rope
      33621,  -- Plague Spray
      36764,  -- Shard of the Earth
      38573,  -- RJR Rifle
      39268,  -- Medallion of Mam'toth
      42480,  -- Ebon Blade Banner
      44959,  -- Soothing Totem
      46722,  -- Grol'dom Net
      50741,  -- Vile Fumigator's Mask
      52481,  -- Blastshadow's Soulstone
      53101,  -- Tessina's Wisp Call
      53104,  -- Tessina's Hippogryph Call
      53105,  -- Tessina's Treant Call
      54455,  -- Paint Bomb
      56180,  -- Duarn's Net UNUSED
      56184,  -- Duarn's Net
      58169,  -- Elementium Grapple Line
      58966,  -- Jesana's Faerie Dragon Call
      58967,  -- Jesana's Giant Call
    },
    [20] = {
      1191,   -- Bag of Marbles
      4388,   -- Discombobulator Ray
      10645,  -- Gnomish Death Ray
      13892,  -- Kodo Kombobulator
      17757,  -- Amulet of Spirits
      18209,  -- Energized Sparkplug
      22048,  -- Lord Valthalak's Amulet
      22473,  -- Antheol's Disciplinary Rod
      22783,  -- Sunwell Blade
      22784,  -- Sunwell Orb
      23394,  -- Healing Salve
      23655,  -- Elven Manacles
      23693,  -- Carinda's Scroll of Retribution
      29513,  -- Staff of the Dreghood Elders
      29817,  -- Talbuk Tagger
      29818,  -- Energy Field Modulator
      30175,  -- Gor'drek's Ointment
      30259,  -- Voren'thal's Presence
      31518,  -- Exorcism Feather
      31678,  -- Mental Interference Rod
      32424,  -- Blade's Edge Ogre Brew
      33088,  -- Brogg's Totem
      33796,  -- Rune of Command
      34127,  -- Tasty Reef Fish
      34257,  -- Fel Siphon
      34711,  -- Core of Malice
      34869,  -- Warsong Banner
      36796,  -- Gavrock's Runebreaker
      36827,  -- Blood Gem
      36835,  -- Unholy Gem
      36847,  -- Frost Gem
      37708,  -- Stick
      39157,  -- Scepter of Suggestion
      39206,  -- Scepter of Empowerment
      39238,  -- Scepter of Command
      39577,  -- Rejek's Blade
      39651,  -- Venture Co. Explosives
      39664,  -- Scepter of Domination
      40397,  -- Lifeblood Gem
      42624,  -- Battered Storm Hammer
      42894,  -- Horn of Elemental Fury
      43206,  -- War Horn of Acherus
      43315,  -- Sigil of the Ebon Blade
      44889,  -- Blessed Herb Bundle
      44975,  -- Orb of Elune
      46363,  -- Lifebringer Sapling
      48104,  -- The Refleshifier
      49202,  -- Black Gunpowder Keg
      50053,  -- Bloodtalon Lasso
      52044,  -- Bilgewater Cartel Promotional Delicacy Morsels
      52073,  -- Bramblestaff
      52484,  -- Kaja'Cola Zero-One
      52566,  -- Motivate-a-Tron
      53107,  -- Flameseer's Staff
      55141,  -- Spiralung
      55158,  -- Fake Treasure
      55230,  -- Soul Stick
      56798,  -- Jin'Zil's Voodoo Stick
      57920,  -- Revantusk War Drums
      58177,  -- Earthen Ring Proclamation
      63079,  -- Titanium Shackles
      63426,  -- Lethality Analyzer
      67241,  -- Sullah's Camel Harness
      68606,  -- Murloc Leash
      68607,  -- Candy Cleanser
      71085,  -- Runestaff of Nordrassil
    },
    [25] = {
      13289,  -- Egan's Blaster
      24268,  -- Netherweave Net
      31463,  -- Zezzak's Shard
      32408,  -- Naj'entus Spine
      32966,  -- DEBUG - Headless Horseman - Start Fire
      34979,  -- Pouch of Crushed Bloodspore
      46885,  -- Weighted Net
      49649,  -- Impaling Spine
      50307,  -- Infernal Spear
      55049,  -- Fang of Goldrinn
      55050,  -- Fang of Lo'Gosh
    },
    [30] = {
      835,    -- Large Rope Net
      1399,   -- Magic Candle
      1404,   -- Tidal Charm
      1434,   -- Glowing Wax Stick
      1472,   -- Deprecated Polished Lakestone Charm
      1704,   -- Deprecated Cold Basilisk Eye
      1854,   -- Deprecated Brooch of the Night Watch
      1914,   -- Deprecated Miniature Silver Hammer
      1995,   -- Deprecated Cat's Paw
      2091,   -- Magic Dust
      3434,   -- Slumber Sand
      3441,   -- Deprecated Crippling Agent
      4479,   -- Burning Charm
      4480,   -- Thundering Charm
      4481,   -- Cresting Charm
      4941,   -- Really Sticky Glue
      5079,   -- Cold Basilisk Eye
      5457,   -- Severed Voodoo Claw
      6436,   -- Burning Gem
      7734,   -- Six Demon Bag
      9328,   -- Super Snapper FX
      9394,   -- Horned Viking Helmet
      10588,  -- Goblin Rocket Helmet
      10716,  -- Gnomish Shrink Ray
      10720,  -- Gnomish Net-o-Matic Projector
      11170,  -- Deprecated Silver Totem of Aquementas
      11522,  -- Silver Totem of Aquementas
      11565,  -- Crystal Yield
      12288,  -- Encased Corrupt Ooze
      12646,  -- Infus Emerald
      12647,  -- Felhas Ruby
      13213,  -- Smolderweb's Eye
      13509,  -- Clutch of Foresight
      13514,  -- Wail of the Banshee
      17202,  -- Snowball
      17310,  -- Aspect of Neptulon
      20084,  -- Hunting Net
      20908,  -- Festival of Nian Firework
      21038,  -- Hardpacked Snowball
      21713,  -- Elune's Candle
      22200,  -- Silver Shafted Arrow
      22206,  -- Bouquet of Red Roses
      22218,  -- Handful of Rose Petals
      23337,  -- Cenarion Antidote
      23417,  -- Sanctified Crystal
      23835,  -- Gnomish Poultryizer
      23995,  -- Murloc Tagger
      30811,  -- Scroll of Demonic Unbanishing
      30854,  -- Book of Fel Names
      31403,  -- Sablemane's Sleeping Powder
      31809,  -- Evergrove Wand
      31828,  -- Ritual Prayer Beads
      32680,  -- Booterang
      32960,  -- Elekk Dispersion Ray
      33108,  -- Ooze Buster
      33606,  -- Lurielle's Pendant
      33607,  -- Enchanted Ice Core
      33865,  -- Amani Hex Stick
      34068,  -- Weighted Jack-o'-Lantern
      34191,  -- Handful of Snowflakes
      34598,  -- The King's Empty Conch
      34684,  -- Handful of Summer Petals
      35557,  -- Huge Snowball
      36732,  -- Potent Explosive Charges
      38331,  -- Emerald Quill DEPRECATED
      38515,  -- Tangled Skein Thrower
      40686,  -- U.D.E.D.
      40917,  -- Lord-Commander's Nullifier
      41121,  -- Gnomish Lightning Generator
      42774,  -- Arngrim's Tooth
      43166,  -- The Bone Witch's Amulet
      43663,  -- Stormbound Tome
      44246,  -- Orb of Illusion
      44414,  -- Soul Lash
      44653,  -- Volatile Acid
      44731,  -- Bouquet of Ebon Roses
      44915,  -- Elune's Candle
      45073,  -- Spring Flowers
      49138,  -- Bottle of Leeches
      49199,  -- Infernal Power Core
      49219,  -- Infernal Power Core
      49882,  -- Soothing Seeds
      50163,  -- Lovely Rose
      52710,  -- Enchanted Conch
      52715,  -- Butcherbot Control Gizmo
      56069,  -- Alliance Weapon Crate
      56227,  -- Enchanted Conch
      57172,  -- Attuned Runestone of Binding
      58935,  -- Gryphon Chow
      60861,  -- Holy Thurible
      64637,  -- Tanrir's Overcharged Totem
      69825,  -- Essence Gatherer
    },
    [35] = {
      16103,  -- Test Enchant Boots Stamina
      18904,  -- Zorbin's Ultra-Shrinker
      24269,  -- Heavy Netherweave Net
      24501,  -- Gordawg's Boulder
      35121,  -- Wolf Bait
      39158,  -- Quetz'lun's Hexxing Stick
      41505,  -- Thorim's Charm of Earth
      41509,  -- Frostweave Net
      44890,  -- To'kini's Blowgun
      49028,  -- Nitro-Potassium Bananas
      54442,  -- Embersilk Net
      56576,  -- Orb of Suggestion
    },
    [40] = {
      996,    -- Ring of Righteous Flame (TEST)
      1258,   -- Bind On Use Test Item
      2012,   -- Deprecated Phylactery of Rot
      4945,   -- Faintly Glowing Skull
      8688,   -- Bind On Acquire Test Item
      24420,  -- Unique Equippable Test Item
      28767,  -- The Decapitator
      33581,  -- Vrykul Insult
      34255,  -- Razorthorn Flayer Gland
      37438,  -- Rod of Compulsion
      38332,  -- Modified Mojo
      38380,  -- Zul'Drak Rat
      39615,  -- Crusader Parachute
      44114,  -- Old Spices
      44222,  -- Dart Gun
      44228,  -- Baby Spice
      44804,  -- Indalamar's Debuffer
      44812,  -- Turkey Shooter
      44832,  -- Squirt Gun [PH]
      50430,  -- Scraps of Rotting Meat
      52490,  -- Stardust
      53794,  -- Rendel's Bridle
      55165,  -- Enchanted Sea Snack
      56169,  -- Breathstone
      56847,  -- Chelsea's Nightmare
      60490,  -- The Axe of Earthly Sundering
      60808,  -- Mutant Bush Chicken Cage
      65162,  -- Emergency Pool Pony
      65357,  -- Rainbow Generator
      69826,  -- Glacial Grenade
      69832,  -- Burd Sticker
      206272, -- Holy Hand Grenade
    },
    [45] = {
      23836,  -- Goblin Rocket Launcher
      28369,  -- Battery Recharging Blaster
      32698,  -- Wrangling Rope
      34691,  -- Arcane Binder
      34812,  -- Crafty's Ultra-Advanced Proto-Typical Shortening Blaster
      35352,  -- Sage's Lightning Rod
      35485,  -- Goblin Rocket Launcher [PH]
      35499,  -- Ninja Grenade [PH]
      49647,  -- Drum of the Soothed Earth
      52059,  -- Murloc Leash
      52833,  -- Modified Soul Orb
      62794,  -- Licensed Proton Accelerator Cannon
      64445,  -- Banshee Mirror
    },
    [60] = {
      32825,  -- Soul Cannon
      34111,  -- Trained Rock Falcon
      34121,  -- Trained Rock Falcon
      37877,  -- Silver Feather
      37887,  -- Seeds of Nature's Wrath
      49700,  -- SFG
      50851,  -- Pulsing Life Crystal
      52043,  -- Bootzooka
    },
    [70] = {
      41265,  -- Eyesore Blaster
    },
    [80] = {
      28131,  -- Reaver Buster Launcher
      35278,  -- Reinforced Net
      35506,  -- Raelorasz's Spear
      42769,  -- Spear of Hodir
      49596,  -- Cryomatic 16
      50031,  -- Tomusa's Hook
      62775,  -- Barbed Fleshhook
      63092,  -- Wyrmhunter Hooks
      63104,  -- Elemental Nullifier
      63393,  -- Shoulder-Mounted Drake-Dropper
    },
    [100] = {
      17162,  -- Eric Test Item A
      23715,  -- Permanent Lung Juice Cocktail
      23718,  -- Permanent Ground Scorpok Assay
      23719,  -- Permanent Cerebral Cortex Compound
      23721,  -- Permanent Gizzard Gum
      23722,  -- Permanent R.O.I.D.S.
      28025,  -- Video Mount
      29877,  -- Indalamar's Super Hot
      30292,  -- My Little Friend
      33119,  -- Malister's Frost Wand
      34151,  -- Player, Draenei/Tauren
      34152,  -- Player, Dwarf/Orc
      34153,  -- Player, Gnome/Blood Elf
      34154,  -- Player, Human/Undead
      34155,  -- Player, Troll/Night Elf
      41058,  -- Hyldnir Harpoon
      44212,  -- SGM-3
    },
    [150] = {
      46954,  -- Flaming Spears
    },
    -- [50000] = {
    --   5418,   -- Weapon of Mass Destruction (test)
    --   28261,  -- Video Invis
    --   29025,  -- [UNUSED]Triangulation Device
    --   34026,  -- Feathered Charm
    -- },
  }
else
  HarmItems = {
    [2] = {
      168948, -- Dried Kelp
      194718, -- Premium Salamander Feed
    },
    [3] = {
      42732,  -- Everfrost Razor
      200469, -- Khadgar's Disenchanting Rod
    },
    [4] = {
      129055, -- Shoe Shine Kit
    },
    [5] = {
      8149,   -- Voodoo Charm
      15826,  -- Curative Animal Salve
      17117,  -- Rat Catcher's Flute
      22259,  -- Unbestowed Friendship Bracelet
      22432,  -- Devilsaur Barb
      23485,  -- Empty Birdcage
      23659,  -- Fel-Tainted Morsels
      33310,  -- The Sergeant's Machete
      33342,  -- The Brave's Machete
      33554,  -- Grick's Bonesaw
      33563,  -- Forsaken Banner
      33806,  -- Runeseeking Pick
      34954,  -- Torp's Kodo Snaffle
      34973,  -- Re-Cursive Transmatter Injection
      35116,  -- The Ultrasonic Screwdriver
      35401,  -- The Greatmother's Soulcatcher
      35736,  -- Bounty Hunter's Cage
      36771,  -- Sturdy Crates
      36786,  -- Bark of the Walkers
      36956,  -- Liquid Fire of Elune
      37045,  -- Kilian's Camera
      37125,  -- Rokar's Camera
      37187,  -- Container of Rats
      37202,  -- Onslaught Riding Crop
      37568,  -- Renewing Tourniquet
      37576,  -- Renewing Bandage
      38330,  -- Crusader's Bandage
      38467,  -- Softknuckle Poker
      38627,  -- Mammoth Harness
      38676,  -- Whisker of Har'koa
      38731,  -- Ahunae's Knife
      40587,  -- Darkmender's Tincture
      45001,  -- Medicated Salve
      45080,  -- Large Femur
      49948,  -- Calder's Bonesaw
      50742,  -- Tara's Tar Scraper
      50746,  -- Tara's Tar Scraper
      52014,  -- Herb-Soaked Bandages
      52271,  -- Northwatch Manacles
      52712,  -- Remote Control Fireworks
      53120,  -- Bottled Bileberry Brew
      56837,  -- Sturdy Manacles
      58502,  -- Explosive Bonding Compound
      58885,  -- Rockslide Reagent
      58955,  -- Razgar's Fillet Knife
      58965,  -- Deepvein's Patch Kit
      61302,  -- Light-Touched Blades
      63150,  -- Shovel
      63427,  -- Worgsaw
      65667,  -- Shovel of Mercy
      67232,  -- Sullah's Pygmy Pen
      71978,  -- Darkmoon Bandage
      72110,  -- Battered Wrench
      79021,  -- Ken-Ken's Mask
      79057,  -- Ken-Ken's Mask
      79102,  -- Green Cabbage Seeds
      79819,  -- Dit Da Jow
      79932,  -- Qu Mo Mask
      80302,  -- EZ-Gro Green Cabbage Seeds
      80590,  -- Juicycrunch Carrot Seeds
      80591,  -- Scallion Seeds
      80592,  -- Mogu Pumpkin Seeds
      80593,  -- Red Blossom Leek Seeds
      80594,  -- Pink Turnip Seeds
      80595,  -- White Turnip Seeds
      85215,  -- Snakeroot Seed
      85216,  -- Enigma Seed
      85217,  -- Magebulb Seed
      85219,  -- Ominous Seed
      85267,  -- Autumn Blossom Sapling
      85268,  -- Spring Blossom Sapling
      85269,  -- Winter Blossom Sapling
      89197,  -- Windshear Cactus Seed
      89202,  -- Raptorleaf Seed
      89233,  -- Songbell Seed
      89326,  -- Witchberry Seeds
      89328,  -- Jade Squash Seeds
      89329,  -- Striped Melon Seeds
      89880,  -- Dented Shovel
      91806,  -- Unstable Portal Shard
      114835, -- Rooby Reat
      133065, -- Tony Mourdain's Cleaver
      136605, -- Solendra's Compassion
      137299, -- Nightborne Spellblade
      139463, -- Felbat Toxin Salve
      142065, -- Dusk Lily Sigil
      142262, -- Electrified Key
      143597, -- Fruit of the Arcan'dor
      143773, -- Contagion Counteragent
      150759, -- Restorative Balm
      151563, -- Hallowed Prayer Effigy
      151570, -- Lightbound Crystal
      151624, -- Y'mera's Arcanocrystal
      152472, -- Chieftain's Salve
      152630, -- Ranah's Watering Can
      152971, -- Talisman of the Prophet
      152995, -- Sacred Stone
      153049, -- Scroll of Purging
      153112, -- Scroll of Purging
      153496, -- Tasty Treats
      153513, -- Cleansing Tonic
      156518, -- Lucille's Sewing Needle
      156532, -- Inquisitor's Regalia
      157771, -- Holy Water
      158678, -- Antivenom
      159470, -- Faithless Scimitar
      159782, -- Milk Pail
      160045, -- Antidote Salve
      160429, -- Rope and Hook
      160433, -- Bandages
      160559, -- Scroll of Purification
      160561, -- Goldfield's Knife
      160571, -- Lucille's Sewing Needle
      160585, -- Soulcaller Scroll
      161247, -- Marshal's Regalia
      162450, -- Portal Orb
      162589, -- Alexxi's Foolproof Remedy
      163607, -- Lucille's Sewing Needle
      163720, -- Mildenhall Growth Formula
      163740, -- Drust Ritual Knife
      166972, -- Emergency Powerpack
      166973, -- Emergency Repair Kit
      167041, -- Coiled Current Culler
      168410, -- First Aid Kit
      169653, -- Potion of Mental Clarity
      172020, -- Battered Weapon
      173013, -- Bag of Faerie Dust
      173148, -- Steel Cleaver
      174197, -- Loremaster's Notebook
      174326, -- Rough Burlap Bandages
      177817, -- Voodoo Powder
      180613, -- Fragile Humility Scroll
      181364, -- Cluster of Seeds
      183689, -- Crusader's Dressing
      183698, -- Torturer's Key
      183797, -- Crusader's Dressing
      184622, -- Stygian Hammer
      186445, -- Mikanikos' Restorative Contraption
      186448, -- Mikanikos' Restorative Contraption
      186695, -- Lovely Pet Bandage
      187504, -- Mikanikos' Restorative Contraption
      192467, -- Bandages
      192795, -- Rejuvenating Draught
      194052, -- Forlorn Funeral Pall
      194434, -- Pungent Salve
      197805, -- Suspicious Persons Scanner
      202874, -- Healing Draught
      208124, -- The Dreamer's Essence
      208738, -- Ephemeral Pear
      208985, -- Silly Hat
      213539, -- Nebb's Poultice
      215145, -- Remembrance Stone
      216687, -- Cobbled Together Bandage
      217159, -- Nebb's Improved Poultice
      219385, -- Antiparalytic Serum
      224799, -- Nizrek's potion
    },
    [6] = {
      200868, -- Integrated Primal Fire
      206964, -- Paracausal Fragment of Doomhammer
      207024, -- Paracausal Fragment of Shalamayne
      207165, -- Bandolier of Twisted Blades
      207783, -- Cruel Dreamcarver
      212449, -- Sikran's Endless Arsenal
      219915, -- Foul Behemoth's Chelicera
    },
    [6] = {
      164766, -- Iwen's Enchanting Rod
      219525, -- Globe of Nourishment
    },
    [7] = {
      61323,  -- Ruby Seeds
      62899,  -- Enchanted Imp Sack
      63350,  -- Razor-Sharp Scorpid Barb
      153249, -- Y'mera's Attuning Crystal
    },
    [8] = {
      33278,  -- Burning Torch
      34368,  -- Attuned Crystal Cores
      35943,  -- Jeremiah's Tools
      37932,  -- Miner's Lantern
      56821,  -- Oil Extrusion Pump
      82311,  -- Zouchin Rations
      128776, -- Red Wooden Sled
      152730, -- Sumber's Totem
      178751, -- Spare Meat Hook
      178901, -- Vineseed
    },
    [9] = {
      212453, -- Skyterror's Corrosive Organ
    },
    [10] = {
      9606,   -- Treant Muisek Vessel
      9618,   -- Beast Muisek Vessel
      9619,   -- Hippogryph Muisek Vessel
      9620,   -- Faerie Dragon Muisek Vessel
      9621,   -- Mountain Giant Muisek Vessel
      10699,  -- Yeh'kinya's Bramble
      17626,  -- Frostwolf Muzzle
      17689,  -- Stormpike Training Collar
      22962,  -- Inoculating Crystal
      28547,  -- Elemental Power Extractor
      30656,  -- Protovoltaic Magneto Collector
      32321,  -- Sparrowhawk Net
      33418,  -- Tillinghast's Plague Canister
      34083,  -- Awakening Rod
      35293,  -- Cenarion Horn
      36859,  -- Snow of Eternal Slumber
      37307,  -- Purified Ashes of Vordrassil
      38697,  -- Jungle Punch Sample
      40551,  -- Gore Bladder
      41988,  -- Telluric Poultice
      42164,  -- Hodir's Horn
      43059,  -- Drakuru's Last Wish
      44576,  -- Bright Flare
      47033,  -- Light-Blessed Relic
      50131,  -- Snagglebolt's Air Analyzer
      52709,  -- Gnomish Playback Device
      52819,  -- Frostgale Crystal
      53009,  -- Juniper Berries
      54215,  -- Vol'jin's War Drums
      54462,  -- Moanah's Baitstick
      54463,  -- Flameseer's Staff
      56012,  -- Stone Knife of Sealing
      56222,  -- Runes of Return
      56794,  -- Subjugator Devo's Whip
      58167,  -- Spirit Totem
      58200,  -- Techno-Grenade
      58203,  -- Paintinator
      60382,  -- Mylra's Knife
      60870,  -- Barrel of Explosive Ale
      62057,  -- Teleport Beacon
      62326,  -- Heavy Manacles
      62541,  -- Heavy Manacles
      64312,  -- Totem of Freedom
      67249,  -- Viewpoint Equalizer
      68679,  -- Goblin Gas Tank
      69240,  -- Enchanted Salve
      78947,  -- Silken Rope
      79884,  -- Bucket of Slicky Water
      80220,  -- Forest Remedy
      81177,  -- Pandaren Healing Draught
      82381,  -- Yak's Milk Flask
      86536,  -- Wu Kao Dart of Lethargy
      90067,  -- B. F. F. Necklace
      106958, -- Winterwasp Antidote
      106987, -- Sigil of Karabor
      107656, -- Kaz's Disturbing Crate
      112321, -- Enchanted Dust
      118418, -- Mug of Rousing Coffee
      119440, -- Training Shoes
      124100, -- Moonwater Vial
      129190, -- Rope of Friendship
      132877, -- Eye of Azzorok
      136386, -- Bloodstone
      139584, -- Sticky Bombs
      152278, -- Cracked Wand
      153537, -- Animate Sphere
      153565, -- Shackles
      156549, -- Writ of Sacrifice
      158190, -- Target Marker
      158907, -- Moonstone Pendant
      158908, -- Moonstone Weapon
      166784, -- Narassin's Soul Gem
      166785, -- Detoxified Blight Grenade
      168053, -- Unusually Wise Hermit Crab
      168811, -- Wand of Absorption
      169860, -- Tiny Dapper Hat
      169943, -- Little Princess Cap
      169944, -- Minuscule Fez
      170161, -- Unusually Wise Hermit Crab
      172955, -- Gormherd Branch
      173870, -- Fading Glimmerdust
      174040, -- Chains of Regret
      174323, -- Torch
      175063, -- Aqir Egg Cluster
      184292, -- Ancient Elethium Coin
      184314, -- Broker Device
      187943, -- Fae Net
      193917, -- Rejuvenating Draught
      202096, -- Armaments of the Scale
      202112, -- Crystal Shattering Armaments
      202271, -- Pouch of Gold Coins
      202714, -- M.U.S.T
      205045, -- B.B.F. Fist
      205276, -- Deepflayer Lure
      207632, -- Dream-Attuned Crystal
      219469, -- Fog Beast Tracker
      223322, -- Hannan's Scythe
    },
    [12] = {
      208068, -- Rotten Delicious
    },
    [15] = {
      30651,  -- Dertrok's First Wand
      30652,  -- Dertrok's Second Wand
      30653,  -- Dertrok's Third Wand
      30654,  -- Dertrok's Fourth Wand
      31129,  -- Blackwhelp Net
      32907,  -- Wolpertinger Net
      33069,  -- Sturdy Rope
      33621,  -- Plague Spray
      36764,  -- Shard of the Earth
      38573,  -- RJR Rifle
      39268,  -- Medallion of Mam'toth
      42480,  -- Ebon Blade Banner
      44959,  -- Soothing Totem
      46722,  -- Grol'dom Net
      50741,  -- Vile Fumigator's Mask
      52481,  -- Blastshadow's Soulstone
      53101,  -- Tessina's Wisp Call
      53104,  -- Tessina's Hippogryph Call
      53105,  -- Tessina's Treant Call
      54455,  -- Paint Bomb
      56184,  -- Duarn's Net
      58169,  -- Elementium Grapple Line
      58966,  -- Jesana's Faerie Dragon Call
      58967,  -- Jesana's Giant Call
      79027,  -- Saltback Meat
      115475, -- Vial of Untested Serum
      115533, -- Vial of Refined Serum
      152395, -- Counter Spell Charm
      152613, -- Sar'jun's Torch
      153024, -- Scroll of Combustion
      158935, -- Depleted Soul Shard
      161333, -- Ultra-Safe Electrified Alpaca Lasso
      165723, -- Embiggifier Core
      165762, -- Embiggifier Core
      165815, -- Tranquilizer Dart
      170557, -- Re-Sizer v9.0.1
      173691, -- Anima Drainer
      178051, -- Re-Sizer v9.0.1
      179359, -- Sinstone Fragment
      179921, -- Hydra Gutter
      179978, -- Infused Animacones
      179983, -- Infused Animacones
      186089, -- Niya's Staff
      186102, -- Lady Moonberry's Wand
      186199, -- Lady Moonberry's Wand
      186569, -- Angry Needler Nest
      188252, -- Chains of Domination
      189384, -- Ornithological Medical Kit
      193064, -- Smoke Diffuser
      197928, -- Captivating Cap
      219322, -- Malodorous Philter
      219323, -- Gelatinous Unguent
      219324, -- Roiling Elixir
      224194, -- Fashion Frenzy Ribbon
    },
    [20] = {
      1191,   -- Bag of Marbles
      4388,   -- Discombobulator Ray
      10645,  -- Gnomish Death Ray
      13892,  -- Kodo Kombobulator
      17757,  -- Amulet of Spirits
      22048,  -- Lord Valthalak's Amulet
      22473,  -- Antheol's Disciplinary Rod
      22783,  -- Sunwell Blade
      22784,  -- Sunwell Orb
      23394,  -- Healing Salve
      23693,  -- Carinda's Scroll of Retribution
      29513,  -- Staff of the Dreghood Elders
      29817,  -- Talbuk Tagger
      29818,  -- Energy Field Modulator
      30175,  -- Gor'drek's Ointment
      30259,  -- Voren'thal's Presence
      31518,  -- Exorcism Feather
      31678,  -- Mental Interference Rod
      33088,  -- Brogg's Totem
      33796,  -- Rune of Command
      34127,  -- Tasty Reef Fish
      34257,  -- Fel Siphon
      34711,  -- Core of Malice
      34869,  -- Warsong Banner
      36796,  -- Gavrock's Runebreaker
      36827,  -- Blood Gem
      36835,  -- Unholy Gem
      36847,  -- Frost Gem
      37708,  -- Stick
      39157,  -- Scepter of Suggestion
      39206,  -- Scepter of Empowerment
      39238,  -- Scepter of Command
      39577,  -- Rejek's Blade
      39651,  -- Venture Co. Explosives
      39664,  -- Scepter of Domination
      40397,  -- Lifeblood Gem
      42624,  -- Battered Storm Hammer
      42894,  -- Horn of Elemental Fury
      43206,  -- War Horn of Acherus
      43315,  -- Sigil of the Ebon Blade
      44889,  -- Blessed Herb Bundle
      44975,  -- Orb of Elune
      46363,  -- Lifebringer Sapling
      48104,  -- The Refleshifier
      49202,  -- Black Gunpowder Keg
      52044,  -- Bilgewater Cartel Promotional Delicacy Morsels
      52073,  -- Bramblestaff
      52484,  -- Kaja'Cola Zero-One
      52566,  -- Motivate-a-Tron
      53107,  -- Flameseer's Staff
      55141,  -- Spiralung
      55158,  -- Fake Treasure
      55230,  -- Soul Stick
      56798,  -- Jin'Zil's Voodoo Stick
      57920,  -- Revantusk War Drums
      58177,  -- Earthen Ring Proclamation
      63079,  -- Titanium Shackles
      63426,  -- Lethality Analyzer
      67241,  -- Sullah's Camel Harness
      68606,  -- Murloc Leash
      71085,  -- Runestaff of Nordrassil
      77475,  -- Stack of Mantras
      80074,  -- Celestial Jade
      85884,  -- Sonic Emitter
      87558,  -- Ella's Brew
      87763,  -- Ella's Brew
      91902,  -- Universal Remote
      93180,  -- Re-Configured Remote
      93751,  -- Blessed Torch
      93806,  -- Resonance Siphon
      94123,  -- Attuned Crystal
      102464, -- Black Ash
      103786, -- \"Dapper Gentleman\" Costume
      103789, -- \"Little Princess\" Costume
      103795, -- \"Dread Pirate\" Costume
      103797, -- Big Pink Bow
      114967, -- Torch
      116172, -- Perky Blaster
      116810, -- \"Mad Alchemist\" Costume
      116811, -- \"Lil' Starlet\" Costume
      116812, -- \"Yipp-Saron\" Costume
      118414, -- Awesomefish
      118415, -- Grieferfish
      118511, -- Tyfish
      118905, -- Sinister Spores
      124506, -- Vial of Fel Cleansing
      127707, -- Indestructible Bone
      128634, -- Mysterious Brew
      128650, -- \"Merry Munchkin\" Costume
      130260, -- Thaedris's Elixir
      131760, -- Cleansing Ritual Focus
      133647, -- Gift of Radiance
      134119, -- Overloaded Collar
      134824, -- \"Sir Pugsington\" Costume
      134860, -- Peddlefeet's Buffing Creme
      137538, -- Orb of Torment
      142260, -- Arcane Nullifier
      142494, -- Purple Blossom
      142495, -- Fake Teeth
      142496, -- Dirty Spoon
      142497, -- Tiny Pack
      151135, -- Stein of Grog
      151763, -- Crab Trap
      152590, -- Wicker Charm
      153350, -- Repurposed Gilnean Staff
      162631, -- Souvenir Tiki Tumbler
      166230, -- Re-Discombobulator
      167071, -- Mechano-Treat
      167091, -- Maedin's Scroll
      168122, -- NRG-100
      168525, -- Poison Globule
      169069, -- Wraps of Electrostatic Potential
      173534, -- Gormherd Branch
      174749, -- Bone Splinter
      178940, -- Vashj's Signal
      183105, -- Tormentor's Rod
      184505, -- \"Adorable Ascended\" Costume
      184506, -- \"Flying Faerie\" Costume
      186094, -- Siphoning Device
      187708, -- Broken Helm
      187816, -- Irresistible Goop
      187839, -- Tonal Jammer
      188002, -- Broken Helm
      188697, -- Kinematic Micro-Life Recalibrator
      189449, -- Jiro Scan
      189479, -- Chromatic Rosid
      189561, -- Tame Prime: Orixal
      189572, -- Tame Prime: Hadeon the Stonebreaker
      189573, -- Tame Prime: Garudeon
      191408, -- Explosive Pie
      191682, -- Explosive Pie
      191854, -- Briny Seawater
      191865, -- Bottle of Briny Seawater
      192477, -- [PH] Primalist Keystone
      192743, -- Wild Bushfruit
      194447, -- Totem of Respite
      198355, -- Tyrhold Conduit
      202613, -- Zaqali Chaos Grapnel
      202875, -- Snail Lasso
      203383, -- Notes on Dragonkin Equality
      203390, -- Maldra's Ring of Elemental Binding
      203706, -- Hurricane Scepter
      205980, -- Snail Lasso
      208884, -- Root Restoration Fruit
      211535, -- Scroll of Shattering
      229413, -- \"Dogg-Saron\" Costume
    },
    [25] = {
      13289,  -- Egan's Blaster
      24268,  -- Netherweave Net
      31463,  -- Zezzak's Shard
      32408,  -- Naj'entus Spine
      34979,  -- Pouch of Crushed Bloodspore
      46885,  -- Weighted Net
      49649,  -- Impaling Spine
      50307,  -- Infernal Spear
      55049,  -- Fang of Goldrinn
      55050,  -- Fang of Lo'Gosh
      74771,  -- Staff of Pei-Zhi
      86567,  -- Yaungol Wind Chime
      104298, -- Ordon Death Chime
      117013, -- Wand of Lightning Shield
      117015, -- Wand of Mana Stealing
      153012, -- Poisoned Mojo Flask
      170540, -- Ravenous Anima Cell
      195519, -- Kharnalex, The First Light
      198088, -- Darkmoon Deck: Dance
      198478, -- Darkmoon Deck Box: Dance
      202855, -- Maldra's Ring of Elemental Binding
      204274, -- Ancient Memories
      204808, -- Empowered Temporal Gossamer
      206448, -- Fyr'alath the Dreamrender
      208846, -- Restored Dreamleaf
      209349, -- Lydiara's Notes on Rune Reagents
      210010, -- Erden's Notes on Symbiotic Spores
      210011, -- Shalasar's Notes on Sophic Magic
      210199, -- Tattered Dreamleaf
      210881, -- Cunning Charm
      228996, -- Relic of Crystal Connections
    },
    [30] = {
      835,    -- Large Rope Net
      1399,   -- Magic Candle
      1434,   -- Glowing Wax Stick
      4479,   -- Burning Charm
      4480,   -- Thundering Charm
      4481,   -- Cresting Charm
      4941,   -- Really Sticky Glue
      5079,   -- Cold Basilisk Eye
      5457,   -- Severed Voodoo Claw
      6436,   -- Burning Gem
      7734,   -- Six Demon Bag
      9328,   -- Super Snapper FX
      10716,  -- Gnomish Shrink Ray
      10720,  -- Gnomish Net-o-Matic Projector
      11522,  -- Silver Totem of Aquementas
      11565,  -- Crystal Yield
      12288,  -- Encased Corrupt Ooze
      12646,  -- Infus Emerald
      12647,  -- Felhas Ruby
      13213,  -- Smolderweb's Eye
      13514,  -- Wail of the Banshee
      17202,  -- Snowball
      17310,  -- Aspect of Neptulon
      21038,  -- Hardpacked Snowball
      21713,  -- Elune's Candle
      22200,  -- Silver Shafted Arrow
      22218,  -- Handful of Rose Petals
      23337,  -- Cenarion Antidote
      23417,  -- Sanctified Crystal
      23835,  -- Gnomish Poultryizer
      23995,  -- Murloc Tagger
      30811,  -- Scroll of Demonic Unbanishing
      30854,  -- Book of Fel Names
      31403,  -- Sablemane's Sleeping Powder
      31809,  -- Evergrove Wand
      31828,  -- Ritual Prayer Beads
      32680,  -- Booterang
      32960,  -- Elekk Dispersion Ray
      33108,  -- Ooze Buster
      33606,  -- Lurielle's Pendant
      33607,  -- Enchanted Ice Core
      33865,  -- Amani Hex Stick
      34068,  -- Weighted Jack-o'-Lantern
      34191,  -- Handful of Snowflakes
      34598,  -- The King's Empty Conch
      34684,  -- Handful of Summer Petals
      35557,  -- Huge Snowball
      36732,  -- Potent Explosive Charges
      38515,  -- Tangled Skein Thrower
      40354,  -- Monster Slayer's Kit
      40686,  -- U.D.E.D.
      40917,  -- Lord-Commander's Nullifier
      41121,  -- Gnomish Lightning Generator
      42774,  -- Arngrim's Tooth
      43166,  -- The Bone Witch's Amulet
      43663,  -- Stormbound Tome
      44246,  -- Orb of Illusion
      44653,  -- Volatile Acid
      44915,  -- Elune's Candle
      45073,  -- Spring Flowers
      49138,  -- Bottle of Leeches
      49199,  -- Infernal Power Core
      49882,  -- Soothing Seeds
      50163,  -- Lovely Rose
      52710,  -- Enchanted Conch
      52715,  -- Butcherbot Control Gizmo
      56069,  -- Alliance Weapon Crate
      56227,  -- Enchanted Conch
      57172,  -- Attuned Runestone of Binding
      58935,  -- Gryphon Chow
      60861,  -- Holy Thurible
      64637,  -- Tanrir's Overcharged Totem
      69825,  -- Essence Gatherer
      80337,  -- Ken-Ken's Mask
      85231,  -- Bag of Clams
      86589,  -- Ai-Li's Skymirror
      92019,  -- The Bilgewater Molotov
      93159,  -- Enchanted Sleeping Dust
      101677, -- Thunderlord Grapple
      110490, -- Larry Bugged Item
      110492, -- Flamewrought Jewel
      114983, -- Sticky Grenade Launcher
      116119, -- Ango'rosh Sorcerer Stone
      116648, -- Manufactured Love Prism
      116651, -- True Love Prism
      117438, -- Gnomish Net Launcher
      118179, -- Talbuk Lasso
      118181, -- Clefthoof Lasso
      118182, -- Wolf Lasso
      118183, -- Riverbeast Lasso
      118184, -- Elekk Lasso
      118185, -- Boar Lasso
      118283, -- Wolf Lasso
      118284, -- Talbuk Lasso
      118285, -- Riverbeast Lasso
      118286, -- Elekk Lasso
      118287, -- Clefthoof Lasso
      118288, -- Boar Lasso
      118643, -- Huge Crate of Weapons
      119083, -- Fruit Basket
      122120, -- Gaze of the Darkmoon
      128632, -- Savage Snowball
      128648, -- Yellow Snowball
      130233, -- Sorcerous Shadowruby Pendant
      133580, -- Brutarg's Sword Tip
      133585, -- Judgment of the Naaru
      136339, -- Spellstone of Kel'danath
      138026, -- Empowered Charging Device
      138733, -- Shadescale Manipulator
      139427, -- Wild Mana Wand
      143863, -- Fel Exfoliator
      147023, -- Leviathan's Hunger
      147420, -- Pebble
      153219, -- Squished Demon Eye
      155823, -- Icy Snowball
      156665, -- Bag of Transmutation Stones
      156831, -- Bag of Transmutation Stones
      156868, -- Crawg Poison Gland
      158332, -- Zeth'jir Channeling Rod
      160307, -- Raal's Hexing Stick
      160525, -- Tongo's Head
      168407, -- Friendship Net
      168947, -- Scroll of Bursting Power
      169209, -- Scroll of Bursting Power
      169446, -- Water Filled Bladder
      169673, -- Blue Paint Filled Bladder
      169674, -- Green Paint Filled Bladder
      169675, -- Orange Paint Filled Bladder
      173157, -- Vial of Caustic Goo
      173358, -- Invitations
      173693, -- Jar of Maggots
      177839, -- Anima Siphon
      178873, -- Concentrated Anima Vial
      180446, -- Curiously Corrosive Concoction
      180661, -- Darktower Parchments: Affliction Most Foul
      180678, -- Peck Acorn
      180688, -- Infused Remnant of Light
      180689, -- Pocket Embers
      180874, -- Gargon Whistle
      183602, -- Sticky Webbing
      183944, -- Heron Net
      185946, -- Long Tail Dynarats
      186431, -- Ebonsoul Vise
      186679, -- Scroll of Domination
      187186, -- Orb of Deception
      188261, -- Intrusive Thoughtcage
      188268, -- Architect's Ingenuity Core
      188692, -- Pouch of Ebon Rose Petals
      188693, -- Pouch of Red Rose Petals
      189454, -- Feather-Plucker 3300
      189862, -- Gavel of the First Arbiter
      192471, -- Arch Instructor's Wand
      193757, -- Ruby Whelp Shell
      193892, -- Wish's Whistle
      194122, -- Sour Apple
      194712, -- Empty Duck Trap
      194731, -- Illusion Parchment: Magma Missile
      194733, -- Illusion Parchment: Aqua Torrent
      194734, -- Illusion Parchment: Whirling Breeze
      194735, -- Illusion Parchment: Arcane Burst
      194736, -- Illusion Parchment: Chilling Wind
      194738, -- Illusion Parchment: Shadow Orb
      194818, -- Proto-Drake Wrangler Rope
      198087, -- Darkmoon Deck: Rime
      198477, -- Darkmoon Deck Box: Rime
      200120, -- Irideus' Power Core
      202270, -- [DNT] Twice-Woven Rope
      204473, -- Element Siphoner
      206160, -- Madam Shadow's Grimoire
      209996, -- Tethercoil Rune
      210755, -- Silent Mark of the Dreamsaber
      210764, -- Silent Mark of the Dreamtalon
      210766, -- Silent Mark of the Umbraclaw
      210767, -- Silent Mark of the Dreamstag
      211302, -- Slumberfruit
      212602, -- Titan Emitter
      215142, -- Freydrin's Shillelagh
      215158, -- Freydrin's Shillelagh
      218124, -- Element Extractor
      223220, -- Kaheti All-Purpose Cleanser
      224026, -- Storm Vessel
      225200, -- Alcor's Sunrazor
      225887, -- Titan Emitter
    },
    [35] = {
      18904,  -- Zorbin's Ultra-Shrinker
      24269,  -- Heavy Netherweave Net
      24501,  -- Gordawg's Boulder
      35121,  -- Wolf Bait
      39158,  -- Quetz'lun's Hexxing Stick
      41505,  -- Thorim's Charm of Earth
      41509,  -- Frostweave Net
      44890,  -- To'kini's Blowgun
      49028,  -- Nitro-Potassium Bananas
      54442,  -- Embersilk Net
      56576,  -- Orb of Suggestion
      88378,  -- Mothallus' Spinneret
      119216, -- Super Sticky Glitter Bomb
      151363, -- Ticker's Rocket Launcher
      180899, -- Riding Hook
      193212, -- Marmoni Rescue Pack
    },
    [38] = {
      140786, -- Ley Spider Eggs
    },
    [40] = {
      4945,   -- Faintly Glowing Skull
      28767,  -- The Decapitator
      33581,  -- Vrykul Insult
      34255,  -- Razorthorn Flayer Gland
      37438,  -- Rod of Compulsion
      38332,  -- Modified Mojo
      38380,  -- Zul'Drak Rat
      39615,  -- Crusader Parachute
      44114,  -- Old Spices
      44222,  -- Dart Gun
      44228,  -- Baby Spice
      44812,  -- Turkey Shooter
      50430,  -- Scraps of Rotting Meat
      52490,  -- Stardust
      53794,  -- Rendel's Bridle
      55165,  -- Enchanted Sea Snack
      56169,  -- Breathstone
      56847,  -- Chelsea's Nightmare
      60490,  -- The Axe of Earthly Sundering
      60808,  -- Mutant Bush Chicken Cage
      65162,  -- Emergency Pool Pony
      69832,  -- Burd Sticker
      74612,  -- Red Panda Lasso
      82468,  -- Yak Lasso
      88577,  -- Explosive Barrel
      88590,  -- Nurong's Gun
      93668,  -- Saur Fetish
      108903, -- Tiny Iron Star
      114125, -- Preserved Discombobulator Ray
      114926, -- Restorative Goldcap
      116400, -- Silver-Plated Turkey Shooter
      116759, -- Blixthraz's Frightening Grudgesolver
      118007, -- Mecha-Blast Rocket
      118190, -- Blixthraz's Frightening Grudgesolver
      118199, -- Poison Cask
      118616, -- Olaf's Shield
      124224, -- Mirror of the Blademaster
      128505, -- Celebration Wand - Murloc
      128506, -- Celebration Wand - Gnoll
      128772, -- Branch of the Runewood
      132500, -- Blink-Trigger Headgun
      132501, -- Tactical Headgun
      132502, -- Bolt-Action Headgun
      132503, -- Reinforced Headgun
      132504, -- Semi-Automagic Cranial Cannon
      132505, -- Sawed-Off Cranial Cannon
      132506, -- Double-Barreled Cranial Cannon
      132507, -- Ironsight Cranial Cannon
      132510, -- Gunpowder Charge
      133706, -- Mossgill Bait
      133761, -- Flintlocke's Headgun Prototype
      133775, -- Gunpowder Charges
      133928, -- Prototype Pump-Action Bandage Gun
      133998, -- Rainbow Generator
      133999, -- Inert Crystal
      137329, -- Figurehead of the Naglfar
      138116, -- Throwing Torch
      139589, -- Poisoned Throwing Knives
      139882, -- Vial of Hippogryph Pheromones
      141005, -- Vial of Hippogryph Pheromones
      141306, -- Wisp in a Bottle
      141411, -- Translocation Anomaly Neutralization Crystal
      142173, -- Ring of Collapsing Futures
      144331, -- Tailored Skullblasters
      144332, -- Rugged Skullblasters
      144333, -- Chain Skullblasters
      144334, -- Heavy Skullblasters
      147882, -- Celebration Wand - Trogg
      147883, -- Celebration Wand - Quilboar
      151368, -- Experimental Alchemy Reagent
      151369, -- Lightning Absorption Capsule
      151370, -- Military Explosives
      152574, -- Corbyn's Beacon
      153483, -- Modified Blood Fetish
      153571, -- Poisoned Blow Dart
      153675, -- Scroll of Capsizing
      156528, -- Titan Manipulator
      156649, -- Zandalari Effigy Amulet
      159796, -- Meatification Potion
      159882, -- Bug Zapper
      160052, -- Flour Bomb
      160659, -- Hunting Rifle
      160753, -- Sanguinating Totem
      160833, -- Fetish of the Tormented Mind
      165702, -- Shard of Vesara
      165806, -- Sinister Gladiator's Maledict
      167013, -- Fiery Brinestone Shard
      167018, -- Azure Brinestone Shard
      167019, -- Violet Brinestone Shard
      167383, -- Notorious Gladiator's Maledict
      168012, -- Apexis Focusing Shard
      168271, -- Stolen Ramkahen Banner
      169305, -- Aquipotent Nautilus
      169307, -- Vision of Demise
      169311, -- Ashvane's Razor Coral
      169490, -- Relic of the Black Empire
      169769, -- Remote Guidance Device
      169816, -- Quasi-Faceted Scanner
      169858, -- \"Bee Bee\" Gun
      170252, -- Pouch of Gangrenous Spores
      171373, -- Introspection
      172672, -- Corrupted Gladiator's Maledict
      173069, -- Darkmoon Deck: Putrescence
      173087, -- Darkmoon Deck: Voracity
      174927, -- Zan-Tien Lasso
      175732, -- Tablet of Despair
      175733, -- Brimming Ember Shard
      177836, -- Wingpierce Javelin
      178495, -- Shattered Helm of Domination
      178496, -- Baron's Warhorn
      178567, -- Kein's Runeblade
      178809, -- Soulletting Ruby
      178810, -- Vial of Spectral Essence
      178826, -- Sunblood Amethyst
      179535, -- Crumbling Pride Extractors
      179613, -- Extra Sticky Spidey Webs
      179938, -- Crumbling Pride Extractors
      179939, -- Wriggling Spider Sac
      180117, -- Empyreal Ordnance
      180708, -- Mirror of Despair
      181357, -- Tablet of Despair
      181360, -- Brimming Ember Shard
      182653, -- Larion Treats
      184313, -- Shattered Helm of Domination
      185720, -- Draka's Battlehorn
      186421, -- Forbidden Necromantic Tome
      186474, -- Korayn's Javelin
      188254, -- Grim Eclipse
      188265, -- Cache of Acquired Treasures
      191044, -- Spider Squasher
      191372, -- Residual Neural Channeling Agent
      191373, -- Residual Neural Channeling Agent
      191374, -- Residual Neural Channeling Agent
      193826, -- Trusty Dragonkin Rake
      193856, -- Flowery's Rake
      194308, -- Manic Grieftorch
      194872, -- Darkmoon Deck Box: Inferno
      198047, -- Kul Tiran Red
      198086, -- Darkmoon Deck: Inferno
      201815, -- Cloak of Many Faces
      204343, -- Trusty Dragonkin Rake
      205224, -- Just a Rock
      208321, -- Iridal, the Earth's Master
      211000, -- Cunning Charm
      212257, -- Potion of Unwavering Focus
      212258, -- Potion of Unwavering Focus
      212259, -- Potion of Unwavering Focus
      212325, -- QA Potion of Unwavering Focus
      212450, -- Swarmlord's Authority
      212963, -- Fleeting Potion of Unwavering Focus
      212964, -- Fleeting Potion of Unwavering Focus
      212965, -- Fleeting Potion of Unwavering Focus
      213629, -- Debugger Hat
      224047, -- Water Blast
      225651, -- Kaheti Shadeweaver's Emblem
    },
    [45] = {
      23836,  -- Goblin Rocket Launcher
      28369,  -- Battery Recharging Blaster
      32698,  -- Wrangling Rope
      34691,  -- Arcane Binder
      34812,  -- Crafty's Ultra-Advanced Proto-Typical Shortening Blaster
      35352,  -- Sage's Lightning Rod
      49647,  -- Drum of the Soothed Earth
      52059,  -- Murloc Leash
      52833,  -- Modified Soul Orb
      62794,  -- Licensed Proton Accelerator Cannon
      64445,  -- Banshee Mirror
      167870, -- G99.99 Landshark
      179719, -- Anima Lure
      194304, -- Iceblood Deathsnare
      194310, -- Desperate Invoker's Codex
      203963, -- Beacon to the Beyond
      207057, -- Gift of the White War Wolf
      207083, -- Gift of the Ravenous Black Gryphon
      208615, -- Nymue's Unraveling Spindle
      208616, -- Dreambinder, Loom of the Great Cycle
    },
    [46] = {
      202610, -- Dragonfire Bomb Dispenser
    },
    [50] = {
      116139, -- Haunting Memento
      129372, -- Spymaster Jenri's Scope
      134836, -- Trident
      147017, -- Tarnished Sentinel Medallion
      147019, -- Tome of Unraveling Sanity
      151960, -- Carafe of Searing Light
      151970, -- Vitality Resonator
      155565, -- Trunksy
      158216, -- Living Oil Canister
      159624, -- Rotcrusted Voodoo Doll
      160443, -- The Glaive of Vol'jin
      160557, -- Pungent Onion
      161452, -- The Glaive of Vol'jin
      165576, -- Tidestorm Codex
      168905, -- Shiver Venom Relic
      173944, -- Forbidden Obsidian Claw
      184021, -- Glyph of Assimilation
      184030, -- Dreadfire Vessel
      186422, -- Tome of Monstrous Constructions
      186437, -- Relic of the Frozen Wastes
      207084, -- Auebry's Marker Pistol
      208389, -- Spear of the Wilds
      211344, -- Miniaturizer
      212454, -- Mad Queen's Mandate
      219313, -- Mereldar's Toll
    },
    [55] = {
      74637,  -- Kiryn's Poison Vial
    },
    [60] = {
      32825,  -- Soul Cannon
      34111,  -- Trained Rock Falcon
      34121,  -- Trained Rock Falcon
      37877,  -- Silver Feather
      37887,  -- Seeds of Nature's Wrath
      49700,  -- SFG
      50851,  -- Pulsing Life Crystal
      52043,  -- Bootzooka
      127030, -- Granny's Flare Grenades
      153679, -- Tether Shot
      155822, -- Sedative Quill
      156516, -- Sedative Quill
      156928, -- Tether Shot
      169279, -- Pedram's Marker Pistol
      183165, -- Mawsworn Crossbow
      192436, -- Ruby Spear
      209999, -- Lydiara's Rune of Shadowbinding
    },
    [70] = {
      41265,  -- Eyesore Blaster
      202642, -- Proto-Killing Spear
    },
    [75] = {
      185949, -- Korayn's Spear
    },
    [80] = {
      35278,  -- Reinforced Net
      35506,  -- Raelorasz's Spear
      42769,  -- Spear of Hodir
      49596,  -- Cryomatic 16
      50031,  -- Tomusa's Hook
      62775,  -- Barbed Fleshhook
      63092,  -- Wyrmhunter Hooks
      63104,  -- Elemental Nullifier
      63393,  -- Shoulder-Mounted Drake-Dropper
      152572, -- Sezahjin's Trusty Vulture Bow
      152610, -- Sur'jan's Grappling Hook
      159761, -- Grappling Hook
      168253, -- Fathom Hook
      185742, -- Mawsworn Chains
      185829, -- Trueheart Spear
      194891, -- Arcane Hook
    },
    [90] = {
      133925, -- Fel Lash
    },
    [100] = {
      33119,  -- Malister's Frost Wand
      41058,  -- Hyldnir Harpoon
      44212,  -- SGM-3
      83134,  -- Bronze Claws
      109082, -- Barbed Harpoon
      144227, -- Soul of Frost
      151307, -- Void Stalker's Contract
      160739, -- Goblin Rocket Launcher
      161422, -- Magister Umbric's Void Shard
      163604, -- Net-o-Matic 5000
      222976, -- Flame-Tempered Harpoon
    },
    [120] = {
      160988, -- Goblin Incendiary Rocket Launcher
      168430, -- Clobberbottom's Boomer
      169681, -- BOOM-TASTIC 3000
      211963, -- Ceiling Sweeper
    },
    [150] = {
      42986,  -- The RP-GG
      46954,  -- Flaming Spears
      153204, -- All-Seer's Eye
      154893, -- Faithless Trapper's Spear
      192750, -- Black Iron Javelin
    },
    [200] = {
      75208,  -- Rancher's Lariat
      86546,  -- Sky Crystal
      89163,  -- Requisitioned Firework Launcher
      152657, -- Target Designator
    },
    [300] = {
      201414, -- Qalashi Wingshredder
    },
    -- [50000] = {
    --   34026,  -- Feathered Charm
    --   130867, -- Tag Toy
    --   136403, -- Staff of Four Winds
    --   146406, -- Vantus Rune: Tomb of Sargeras
    --   151610, -- Vantus Rune: Antorus, the Burning Throne
    --   153673, -- Vantus Rune: Uldir
    --   165692, -- Vantus Rune: Battle of Dazar'alor
    --   165733, -- Vantus Rune: Crucible of Storms
    --   168624, -- Vantus Rune: The Eternal Palace
    --   171203, -- Vantus Rune: Ny'alotha, the Waking City
    --   173067, -- Vantus Rune: Castle Nathria
    --   186662, -- Vantus Rune: Sanctum of Domination
    --   187805, -- Vantus Rune: Sepulcher of the First Ones
    --   189584, -- Sepulcher's Savior
    --   198491, -- Vantus Rune: Vault of the Incarnates
    --   198492, -- Vantus Rune: Vault of the Incarnates
    --   198493, -- Vantus Rune: Vault of the Incarnates
    --   204858, -- Vantus Rune: Aberrus, the Shadowed Crucible
    --   204859, -- Vantus Rune: Aberrus, the Shadowed Crucible
    --   204860, -- Vantus Rune: Aberrus, the Shadowed Crucible
    --   210247, -- Vantus Rune: Amirdrassil, the Dream's Hope
    --   210248, -- Vantus Rune: Amirdrassil, the Dream's Hope
    --   210249, -- Vantus Rune: Amirdrassil, the Dream's Hope
    --   226034, -- Vantus Rune: Nerub-ar Palace
    --   226035, -- Vantus Rune: Nerub-ar Palace
    --   226036, -- Vantus Rune: Nerub-ar Palace
    -- },
  }
end

-- This could've been done by checking player race as well and creating tables for those, but it's easier like this
for _, v in pairs(FriendSpells) do
  tinsert(v, 28880) -- Gift of the Naaru (40 yards)
end

-- >> END OF STATIC CONFIG

-- temporary stuff

local pendingItemRequest = {}
local itemRequestTimeoutAt = {}
local foundNewItems
local cacheAllItems
local friendItemRequests
local harmItemRequests
local lastUpdate = 0

local checkers_Spell = setmetatable({}, {
  __index = function(t, spellIdx)
    local func = function(unit)
      if IsSpellBookItemInRange(spellIdx, BOOKTYPE_SPELL, unit) == 1 then
        return true
      end
    end
    t[spellIdx] = func
    return func
  end,
})
local checkers_SpellWithMin = {} -- see getCheckerForSpellWithMinRange()
local checkers_Item = setmetatable({}, {
  __index = function(t, item)
    local func = function(unit, skipInCombatCheck)
      if not skipInCombatCheck and InCombatLockdownRestriction(unit) then
        return nil
      else
        return C_Item.IsItemInRange(item, unit) or nil
      end
    end
    t[item] = func
    return func
  end,
})
local checkers_Interact = setmetatable({}, {
  __index = function(t, index)
    local func = function(unit, skipInCombatCheck)
      if not skipInCombatCheck and InCombatLockdownRestriction(unit) then
        return nil
      else
        return CheckInteractDistance(unit, index) and true or false
      end
    end
    t[index] = func
    return func
  end,
})

-- helper functions
local function copyTable(src, dst)
  if type(dst) ~= "table" then
    dst = {}
  end
  if type(src) == "table" then
    for k, v in pairs(src) do
      if type(v) == "table" then
        v = copyTable(v, dst[k])
      end
      dst[k] = v
    end
  end
  return dst
end

local function initItemRequests(cacheAll)
  friendItemRequests = copyTable(FriendItems)
  harmItemRequests = copyTable(HarmItems)
  cacheAllItems = cacheAll
  foundNewItems = nil
end

local function getNumSpells()
  local _, _, offset, numSpells = GetSpellTabInfo(GetNumSpellTabs())
  if not offset or not numSpells then
    return 0
  end
  return offset + numSpells
end

-- return the spellIndex of the given spell by scanning the spellbook
local function findSpellIdx(spellName)
  if not spellName or spellName == "" then
    return nil
  end
  for i = 1, getNumSpells() do
    local spell = GetSpellBookItemName(i, BOOKTYPE_SPELL)
    if spell == spellName then
      local spellType, spellID, spellInfo = GetSpellBookItemInfo(i, BOOKTYPE_SPELL)
      if spellInfo then -- new API output available
        if Enum.SpellBookItemType and spellInfo.itemType == Enum.SpellBookItemType.Spell and not spellInfo.isOffSpec then -- retail - filter for only active spec "SPELL"
          return spellID
        end
      elseif spellType == "SPELL" then -- classic/era
        return i
      end
    end
  end
  return nil
end

local function fixRange(range)
  if range then
    return math_floor(range + 0.5)
  end
end

local function getSpellData(sid)
  local name, _, _, _, minRange, range = GetSpellInfo(sid)
  return name, fixRange(minRange), fixRange(range), findSpellIdx(name)
end

local function findMinRangeChecker(origMinRange, origRange, spellList, interactLists)
  for i = 1, #spellList do
    local sid = spellList[i]
    local name, minRange, range, spellIdx = getSpellData(sid)
    if range and spellIdx and origMinRange <= range and range <= origRange and minRange == 0 then
      return checkers_Spell[spellIdx]
    end
  end
  for index, range in pairs(interactLists) do
    if origMinRange <= range and range <= origRange then
      return checkers_Interact[index]
    end
  end
end

local function getCheckerForSpellWithMinRange(spellIdx, minRange, range, spellList, interactLists)
  local checker = checkers_SpellWithMin[spellIdx]
  if checker then
    return checker
  end
  local minRangeChecker = findMinRangeChecker(minRange, range, spellList, interactLists)
  if minRangeChecker then
    checker = function(unit)
      if IsSpellBookItemInRange(spellIdx, BOOKTYPE_SPELL, unit) == 1 then
        return true
      elseif minRangeChecker(unit) then
        return true, true
      end
    end
    checkers_SpellWithMin[spellIdx] = checker
    return checker
  end
end

-- minRange should be nil if there's no minRange, not 0
local function addChecker(t, range, minRange, checker, info)
  local rc = { ["range"] = range, ["minRange"] = minRange, ["checker"] = checker, ["info"] = info }
  for i = 1, #t do
    local v = t[i]
    if rc.range == v.range then
      return
    end
    if rc.range > v.range then
      tinsert(t, i, rc)
      return
    end
  end
  tinsert(t, rc)
end

local function createCheckerList(spellList, itemList, interactList)
  local res, resInCombat = {}, {}
  if itemList then
    for range, items in pairs(itemList) do
      for i = 1, #items do
        local item = items[i]
        if Item:CreateFromItemID(item):IsItemDataCached() and C_Item.GetItemInfo(item) then
          addChecker(res, range, nil, checkers_Item[item], "item:" .. item)
          break
        end
      end
    end
  end

  if interactList and not next(res) then
    for index, range in pairs(interactList) do
      addChecker(res, range, nil, checkers_Interact[index], "interact:" .. index)
    end
  end

  if spellList then
    for i = 1, #spellList do
      local sid = spellList[i]
      local name, minRange, range, spellIdx = getSpellData(sid)
      if spellIdx and range then
        -- print("### spell: " .. tostring(name) .. ", " .. tostring(minRange) .. " - " ..  tostring(range))

        if minRange == 0 then -- getRange() expects minRange to be nil in this case
          minRange = nil
        end

        if range == 0 then
          range = MeleeRange
        end

        if minRange then
          local checker = getCheckerForSpellWithMinRange(spellIdx, minRange, range, spellList, interactList)
          if checker then
            addChecker(res, range, minRange, checker, "spell:" .. sid .. ":" .. tostring(name))
            addChecker(resInCombat, range, minRange, checker, "spell:" .. sid .. ":" .. tostring(name))
          end
        else
          addChecker(res, range, minRange, checkers_Spell[spellIdx], "spell:" .. sid .. ":" .. tostring(name))
          addChecker(resInCombat, range, minRange, checkers_Spell[spellIdx], "spell:" .. sid .. ":" .. tostring(name))
        end
      end
    end
  end

  return res, resInCombat
end

local rangeCache = {}

local function resetRangeCache()
  wipe(rangeCache)
end

local function invalidateRangeCache(maxAge)
  local currentTime = GetTime()
  for k, v in pairs(rangeCache) do
    -- if the entry is older than maxAge, clear this data from the cache
    if v.updateTime + maxAge < currentTime then
      rangeCache[k] = nil
    end
  end
end

-- returns minRange, maxRange  or nil
local function getRangeWithCheckerList(unit, checkerList)
  local lo, hi = 1, #checkerList
  while lo <= hi do
    local mid = math_floor((lo + hi) / 2)
    local rc = checkerList[mid]
    if rc.checker(unit, true) then
      lo = mid + 1
    else
      hi = mid - 1
    end
  end
  if #checkerList == 0 then
    return nil, nil
  elseif lo > #checkerList then
    return 0, checkerList[#checkerList].range
  elseif lo <= 1 then
    return checkerList[1].range, nil
  else
    return checkerList[lo].range, checkerList[lo - 1].range
  end
end

local function getRange(unit, noItems)
  local canAssist = UnitCanAssist("player", unit)
  if UnitIsDeadOrGhost(unit) then
    if canAssist then
      return getRangeWithCheckerList(unit, InCombatLockdownRestriction(unit) and lib.resRCInCombat or lib.resRC)
    else
      return getRangeWithCheckerList(unit, InCombatLockdownRestriction(unit) and lib.miscRCInCombat or lib.miscRC)
    end
  end

  if UnitCanAttack("player", unit) then
    return getRangeWithCheckerList(unit, noItems and lib.harmNoItemsRC or lib.harmRC)
  elseif UnitIsUnit("pet", unit) then
    if InCombatLockdownRestriction(unit) then
      local minRange, maxRange = getRangeWithCheckerList(unit, noItems and lib.friendNoItemsRCInCombat or lib.friendRCInCombat)
      if minRange or maxRange then
        return minRange, maxRange
      else
        return getRangeWithCheckerList(unit, lib.petRCInCombat)
      end
    else
      local minRange, maxRange = getRangeWithCheckerList(unit, noItems and lib.friendNoItemsRC or lib.friendRC)
      if minRange or maxRange then
        return minRange, maxRange
      else
        return getRangeWithCheckerList(unit, lib.petRC)
      end
    end
  elseif canAssist then
    if InCombatLockdownRestriction(unit) then
      return getRangeWithCheckerList(unit, noItems and lib.friendNoItemsRCInCombat or lib.friendRCInCombat)
    else
      return getRangeWithCheckerList(unit, noItems and lib.friendNoItemsRC or lib.friendRC)
    end
  else
    return getRangeWithCheckerList(unit, InCombatLockdownRestriction(unit) and lib.miscRCInCombat or lib.miscRC)
  end
end

local function getCachedRange(unit, noItems, maxCacheAge)
  -- maxCacheAge has a default of 0.1 and a maximum of 1 second
  maxCacheAge = maxCacheAge or 0.1
  maxCacheAge = maxCacheAge > 1 and 1 or maxCacheAge

  -- compose cache key out of unit guid and noItems
  local guid = UnitGUID(unit)
  local cacheKey = guid .. (noItems and "-1" or "-0")
  local cacheItem = rangeCache[cacheKey]

  local currentTime = GetTime()

  -- if then cache item is valid return it
  if cacheItem and cacheItem.updateTime + maxCacheAge > currentTime then
    return cacheItem.minRange, cacheItem.maxRange
  end

  -- otherwise create a new or update the existing cache item
  local result = cacheItem or {}
  result.minRange, result.maxRange = getRange(unit, noItems)
  result.updateTime = currentTime
  rangeCache[cacheKey] = result
  return result.minRange, result.maxRange
end

local function updateList(origList, newList)
  if #origList ~= #newList then
    wipe(origList)
    copyTable(newList, origList)
    return true
  end
  for i = 1, #origList do
    if origList[i].range ~= newList[i].range or origList[i].checker ~= newList[i].checker then
      wipe(origList)
      copyTable(newList, origList)
      return true
    end
  end
end

local function updateCheckers(origList, origList2, newList, newList2)
  local changed = updateList(origList, newList)
  changed = updateList(origList2, newList2) or changed
  return changed
end

local function rcIterator(checkerList)
  local curr = #checkerList
  return function()
    local rc = checkerList[curr]
    if not rc then
      return nil
    end
    curr = curr - 1
    return rc.range, rc.checker
  end
end

local function getMinChecker(checkerList, range)
  local checker, checkerRange
  for i = 1, #checkerList do
    local rc = checkerList[i]
    if rc.range < range then
      return checker, checkerRange
    end
    checker, checkerRange = rc.checker, rc.range
  end
  return checker, checkerRange
end

local function getMaxChecker(checkerList, range)
  for i = 1, #checkerList do
    local rc = checkerList[i]
    if rc.range <= range then
      return rc.checker, rc.range
    end
  end
end

local function getChecker(checkerList, range)
  for i = 1, #checkerList do
    local rc = checkerList[i]
    if rc.range == range then
      return rc.checker
    end
  end
end

local function null() end

local function createSmartChecker(friendChecker, harmChecker, miscChecker)
  miscChecker = miscChecker or null
  friendChecker = friendChecker or miscChecker
  harmChecker = harmChecker or miscChecker
  return function(unit)
    if not UnitExists(unit) then
      return nil
    end
    if UnitIsDeadOrGhost(unit) then
      return miscChecker(unit)
    end
    if UnitCanAttack("player", unit) then
      return harmChecker(unit)
    elseif UnitCanAssist("player", unit) then
      return friendChecker(unit)
    else
      return miscChecker(unit)
    end
  end
end

local minItemChecker = function(item)
  if C_Item.GetItemInfo(item) then
    return function(unit)
      return C_Item.IsItemInRange(item, unit)
    end
  end
end

-- OK, here comes the actual lib

-- pre-initialize the checkerLists here so that we can return some meaningful result even if
-- someone manages to call us before we're properly initialized. miscRC should be independent of
-- race/class/talents, so it's safe to initialize it here
-- friendRC and harmRC will be properly initialized later when we have all the necessary data for them
lib.checkerCache_Spell = lib.checkerCache_Spell or {}
lib.checkerCache_Item = lib.checkerCache_Item or {}
lib.miscRC = createCheckerList(nil, nil, DefaultInteractList)
lib.miscRCInCombat = {}
lib.friendRC = createCheckerList(nil, nil, DefaultInteractList)
lib.friendRCInCombat = {}
lib.harmRC = createCheckerList(nil, nil, DefaultInteractList)
lib.harmRCInCombat = {}
lib.resRC = createCheckerList(nil, nil, DefaultInteractList)
lib.resRCInCombat = {}
lib.petRC = createCheckerList(nil, nil, DefaultInteractList)
lib.petRCInCombat = {}
lib.friendNoItemsRC = createCheckerList(nil, nil, DefaultInteractList)
lib.friendNoItemsRCInCombat = {}
lib.harmNoItemsRC = createCheckerList(nil, nil, DefaultInteractList)
lib.harmNoItemsRCInCombat = {}

lib.failedItemRequests = {}

-- << Public API

--- The callback name that is fired when checkers are changed.
-- @field
lib.CHECKERS_CHANGED = "CHECKERS_CHANGED"
-- "export" it, maybe someone will need it for formatting
--- Constant for Melee range (2yd).
-- @field
lib.MeleeRange = MeleeRange

function lib:findSpellIndex(spell)
  if type(spell) == "number" then
    spell = GetSpellInfo(spell)
  end
  return findSpellIdx(spell)
end

-- returns the range estimate as a string
-- deprecated, use :getRange(unit) instead and build your own strings
-- @param checkVisible if set to true, then a UnitIsVisible check is made, and **nil** is returned if the unit is not visible
function lib:getRangeAsString(unit, checkVisible, showOutOfRange)
  local minRange, maxRange = self:getRange(unit, checkVisible)
  if not minRange then
    return nil
  end
  if not maxRange then
    return showOutOfRange and minRange .. " +" or nil
  end
  return minRange .. " - " .. maxRange
end

-- initialize RangeCheck if not yet initialized or if "forced"
function lib:init(forced)
  if self.initialized and not forced then
    return
  end
  self.initialized = true
  local _, playerClass = UnitClass("player")
  local _, playerRace = UnitRace("player")

  local interactList = InteractLists[playerRace] or DefaultInteractList
  self.handSlotItem = GetInventoryItemLink("player", HandSlotId)
  local changed = false
  if updateCheckers(self.friendRC, self.friendRCInCombat, createCheckerList(FriendSpells[playerClass], FriendItems, interactList)) then
    changed = true
  end
  if updateCheckers(self.harmRC, self.harmRCInCombat, createCheckerList(HarmSpells[playerClass], HarmItems, interactList)) then
    changed = true
  end
  if updateCheckers(self.friendNoItemsRC, self.friendNoItemsRCInCombat, createCheckerList(FriendSpells[playerClass], nil, interactList)) then
    changed = true
  end
  if updateCheckers(self.harmNoItemsRC, self.harmNoItemsRCInCombat, createCheckerList(HarmSpells[playerClass], nil, interactList)) then
    changed = true
  end
  if updateCheckers(self.miscRC, self.miscRCInCombat, createCheckerList(nil, nil, interactList)) then
    changed = true
  end
  if updateCheckers(self.resRC, self.resRCInCombat, createCheckerList(ResSpells[playerClass], nil, interactList)) then
    changed = true
  end
  if updateCheckers(self.petRC, self.petRCInCombat, createCheckerList(PetSpells[playerClass], nil, interactList)) then
    changed = true
  end
  if changed and self.callbacks then
    self.callbacks:Fire(self.CHECKERS_CHANGED)
  end
end

--- Return an iterator for checkers usable on friendly units as (**range**, **checker**) pairs.
-- @param inCombat if true, only checkers that can be used in combat ar returned
function lib:GetFriendCheckers(inCombat)
  return rcIterator(inCombat and self.friendRCInCombat or self.friendRC)
end

--- Return an iterator for checkers usable on friendly units as (**range**, **checker**) pairs.
-- @param inCombat if true, only checkers that can be used in combat ar returned
function lib:GetFriendCheckersNoItems(inCombat)
  return rcIterator(inCombat and self.friendNoItemsRCInCombat or self.friendNoItemsRC)
end


--- Return an iterator for checkers usable on enemy units as (**range**, **checker**) pairs.
-- @param inCombat if true, only checkers that can be used in combat ar returned
function lib:GetHarmCheckers(inCombat)
  return rcIterator(inCombat and self.harmRCInCombat or self.harmRC)
end


--- Return an iterator for checkers usable on enemy units as (**range**, **checker**) pairs.
-- @param inCombat if true, only checkers that can be used in combat ar returned
function lib:GetHarmCheckersNoItems(inCombat)
  return rcIterator(inCombat and self.harmNoItemsRCInCombat or self.harmNoItemsRC)
end


--- Return an iterator for checkers usable on miscellaneous units as (**range**, **checker**) pairs.  These units are neither enemy nor friendly, such as people in sanctuaries or corpses.
-- @param inCombat if true, only checkers that can be used in combat ar returned
function lib:GetMiscCheckers(inCombat)
  return rcIterator(inCombat and self.miscRCInCombat or self.miscRC)
end

--- Return a checker suitable for out-of-range checking on friendly units, that is, a checker whose range is equal or larger than the requested range.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker**, **range** pair or **nil** if no suitable checker is available. **range** is the actual range the returned **checker** checks for.
function lib:GetFriendMinChecker(range, inCombat)
  return getMinChecker(inCombat and self.friendRCInCombat or self.friendRC , range)
end

--- Return a checker suitable for out-of-range checking on enemy units, that is, a checker whose range is equal or larger than the requested range.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker**, **range** pair or **nil** if no suitable checker is available. **range** is the actual range the returned **checker** checks for.
function lib:GetHarmMinChecker(range, inCombat)
  return getMinChecker(inCombat and self.harmRCInCombat or self.harmRC, range)
end

--- Return a checker suitable for out-of-range checking on miscellaneous units, that is, a checker whose range is equal or larger than the requested range.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker**, **range** pair or **nil** if no suitable checker is available. **range** is the actual range the returned **checker** checks for.
function lib:GetMiscMinChecker(range, inCombat)
  return getMinChecker(inCombat and self.miscRCInCombat or self.miscRC, range)
end

--- Return a checker suitable for in-range checking on friendly units, that is, a checker whose range is equal or smaller than the requested range.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker**, **range** pair or **nil** if no suitable checker is available. **range** is the actual range the returned **checker** checks for.
function lib:GetFriendMaxChecker(range, inCombat)
  return getMaxChecker(inCombat and self.friendRCInCombat or self.friendRC, range)
end

--- Return a checker suitable for in-range checking on enemy units, that is, a checker whose range is equal or smaller than the requested range.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker**, **range** pair or **nil** if no suitable checker is available. **range** is the actual range the returned **checker** checks for.
function lib:GetHarmMaxChecker(range, inCombat)
  return getMaxChecker(inCombat and self.harmRCInCombat or self.harmRC, range)
end

--- Return a checker suitable for in-range checking on miscellaneous units, that is, a checker whose range is equal or smaller than the requested range.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker**, **range** pair or **nil** if no suitable checker is available. **range** is the actual range the returned **checker** checks for.
function lib:GetMiscMaxChecker(range, inCombat)
  return getMaxChecker(inCombat and self.miscRCInCombat and self.miscRC, range)
end

--- Return a checker for the given range for friendly units.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker** function or **nil** if no suitable checker is available.
function lib:GetFriendChecker(range, inCombat)
  return getChecker(inCombat and self.friendRCInCombat or self.friendRC, range)
end

--- Return a checker for the given range for enemy units.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker** function or **nil** if no suitable checker is available.
function lib:GetHarmChecker(range, inCombat)
  return getChecker(inCombat and self.harmRCInCombat or self.harmRC, range)
end

--- Return a checker for the given range for miscellaneous units.
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker** function or **nil** if no suitable checker is available.
function lib:GetMiscChecker(range, inCombat)
  return getChecker(inCombat and self.miscRCInCombat or self.miscRC, range)
end

--- Return a checker suitable for out-of-range checking that checks the unit type and calls the appropriate checker (friend/harm/misc).
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker** function.
function lib:GetSmartMinChecker(range, inCombat)
  if inCombat then
    return createSmartChecker(getMinChecker(self.friendRCInCombat, range),
                              getMinChecker(self.harmRCInCombat, range),
                              getMinChecker(self.miscRCInCombat, range))
  else
    return createSmartChecker(getMinChecker(self.friendRC, range),
                              getMinChecker(self.harmRC, range),
                              getMinChecker(self.miscRC, range))
  end
end

--- Return a checker suitable for in-range checking that checks the unit type and calls the appropriate checker (friend/harm/misc).
-- @param range the range to check for.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker** function.
function lib:GetSmartMaxChecker(range, inCombat)
  if inCombat then
    return createSmartChecker(getMaxChecker(self.friendRCInCombat, range),
                              getMaxChecker(self.harmRCInCombat, range),
                              getMaxChecker(self.miscRCInCombat, range))
  else
    return createSmartChecker(getMaxChecker(self.friendRC, range),
                              getMaxChecker(self.harmRC, range),
                              getMaxChecker(self.miscRC, range))
  end
end

--- Return a checker for the given range that checks the unit type and calls the appropriate checker (friend/harm/misc).
-- @param range the range to check for.
-- @param fallback optional fallback function that gets called as fallback(unit) if a checker is not available for the given type (friend/harm/misc) at the requested range. The default fallback function return nil.
-- @param inCombat if true, only checkers that can be used in combat ar returned
-- @return **checker** function.
function lib:GetSmartChecker(range, fallback, inCombat)
  if inCombat then
    return createSmartChecker(getChecker(self.friendRCInCombat, range) or fallback,
                              getChecker(self.harmRCInCombat, range) or fallback,
                              getChecker(self.miscRCInCombat, range) or fallback)
  else
    return createSmartChecker(getChecker(self.friendRC, range) or fallback,
                              getChecker(self.harmRC, range) or fallback,
                              getChecker(self.miscRC, range) or fallback)
  end
end

--- Get a range estimate as **minRange**, **maxRange**.
-- @param unit the target unit to check range to.
-- @param checkVisible if set to true, then a UnitIsVisible check is made, and **nil** is returned if the unit is not visible
-- @param noItems if set to true, no items and only spells are being used for the range check
-- @param maxCacheAge the timespan a cached range value is considered valid (default 0.1 seconds, maximum 1 second)
-- @return **minRange**, **maxRange** pair if a range estimate could be determined, **nil** otherwise. **maxRange** is **nil** if **unit** is further away than the highest possible range we can check.
-- Includes checks for unit validity and friendly/enemy status.
-- @usage
-- local rc = LibStub("LibRangeCheck-3.0")
-- local minRange, maxRange = rc:GetRange('target')
-- local minRangeIfVisible, maxRangeIfVisible = rc:GetRange('target', true)
function lib:GetRange(unit, checkVisible, noItems, maxCacheAge)
  if not UnitExists(unit) then
    return nil
  end

  if checkVisible and not UnitIsVisible(unit) then
    return nil
  end

  return getCachedRange(unit, noItems, maxCacheAge)
end

-- keep this for compatibility
lib.getRange = lib.GetRange

-- >> Public API

function lib:OnEvent(event, ...)
  if type(self[event]) == "function" then
    self[event](self, event, ...)
  end
end

function lib:LEARNED_SPELL_IN_TAB()
  self:scheduleInit()
end

function lib:CHARACTER_POINTS_CHANGED()
  self:scheduleInit()
end

function lib:PLAYER_TALENT_UPDATE()
  self:scheduleInit()
end

function lib:SPELLS_CHANGED()
  self:scheduleInit()
end

function lib:CVAR_UPDATE(_, cvar)
  if cvar == "ShowAllSpellRanks" then
    self:scheduleInit()
  end
end

function lib:UNIT_INVENTORY_CHANGED(event, unit)
  if self.initialized and unit == "player" and self.handSlotItem ~= GetInventoryItemLink("player", HandSlotId) then
    self:scheduleInit()
  end
end

function lib:UNIT_AURA(event, unit)
  if self.initialized and unit == "player" then
    self:scheduleAuraCheck()
  end
end

function lib:GET_ITEM_INFO_RECEIVED(event, item, success)
  -- print("### GET_ITEM_INFO_RECEIVED: " .. tostring(item) .. ", " .. tostring(success))
  if pendingItemRequest[item] then
    pendingItemRequest[item] = nil
    itemRequestTimeoutAt[item] = nil
    if not success then
      self.failedItemRequests[item] = true
    end
    lastUpdate = UpdateDelay
  end
end

function lib:processItemRequests(itemRequests)
  while true do
    local range, items = next(itemRequests)
    if not range then
      return
    end
    while true do
      local i, item = next(items)
      if not i then
        itemRequests[range] = nil
        break
      elseif Item:CreateFromItemID(item):IsItemEmpty() or self.failedItemRequests[item] then
        -- print("### processItemRequests: failed: " .. tostring(item))
        tremove(items, i)
      elseif pendingItemRequest[item] and GetTime() < itemRequestTimeoutAt[item] then
        return true -- still waiting for server response
      elseif C_Item.GetItemInfo(item) then
        -- print("### processItemRequests: found: " .. tostring(item))
        foundNewItems = true
        itemRequestTimeoutAt[item] = nil
        pendingItemRequest[item] = nil
        if not cacheAllItems then
          itemRequests[range] = nil
          break
        end
        tremove(items, i)
      elseif not itemRequestTimeoutAt[item] then
        -- print("### processItemRequests: waiting: " .. tostring(item))
        itemRequestTimeoutAt[item] = GetTime() + ItemRequestTimeout
        pendingItemRequest[item] = true
        if not self.frame:IsEventRegistered("GET_ITEM_INFO_RECEIVED") then
          self.frame:RegisterEvent("GET_ITEM_INFO_RECEIVED")
        end
        return true
      elseif GetTime() >= itemRequestTimeoutAt[item] then
        -- print("### processItemRequests: timeout: " .. tostring(item))
        if cacheAllItems then
          print(MAJOR_VERSION .. ": timeout for item: " .. tostring(item))
        end
        self.failedItemRequests[item] = true
        itemRequestTimeoutAt[item] = nil
        pendingItemRequest[item] = nil
        tremove(items, i)
      else
        return true -- still waiting for server response
      end
    end
  end
end

function lib:initialOnUpdate()
  self:init()
  if friendItemRequests then
    if self:processItemRequests(friendItemRequests) then
      return
    end
    friendItemRequests = nil
  end
  if harmItemRequests then
    if self:processItemRequests(harmItemRequests) then
      return
    end
    harmItemRequests = nil
  end
  if foundNewItems then
    self:init(true)
    foundNewItems = nil
  end
  if cacheAllItems then
    print(MAJOR_VERSION .. ": finished cache")
    cacheAllItems = nil
  end
  self.frame:Hide()
  self.frame:UnregisterEvent("GET_ITEM_INFO_RECEIVED")
end

function lib:scheduleInit()
  self.initialized = nil
  lastUpdate = 0
  self.frame:Show()
end

function lib:scheduleAuraCheck()
  lastUpdate = UpdateDelay
  self.frame:Show()
end


-- << load-time initialization

function lib:activate()
  if not self.frame then
    local frame = CreateFrame("Frame")
    self.frame = frame

    frame:RegisterEvent("LEARNED_SPELL_IN_TAB")
    frame:RegisterEvent("CHARACTER_POINTS_CHANGED")
    frame:RegisterEvent("SPELLS_CHANGED")

    if isEra or isCata then
      frame:RegisterEvent("CVAR_UPDATE")
    end

    if isRetail or isCata then
      frame:RegisterEvent("PLAYER_TALENT_UPDATE")
    end

    local _, playerClass = UnitClass("player")
    if playerClass == "MAGE" or playerClass == "SHAMAN" then
      -- Mage and Shaman gladiator gloves modify spell ranges
      frame:RegisterUnitEvent("UNIT_INVENTORY_CHANGED", "player")
    end
  end

  if not self.cacheResetTimer then
    self.cacheResetTimer = C_Timer.NewTicker(5, function()
      invalidateRangeCache(5)
    end)
  end

  initItemRequests()

  self.frame:SetScript("OnEvent", function(_, ...)
    self:OnEvent(...)
  end)
  self.frame:SetScript("OnUpdate", function(_, elapsed)
    lastUpdate = lastUpdate + elapsed
    if lastUpdate < UpdateDelay then
      return
    end
    lastUpdate = 0
    self:initialOnUpdate()
  end)

  self:scheduleInit()
end

--- BEGIN CallbackHandler stuff

do
  --- Register a callback to get called when checkers are updated
  -- @class function
  -- @name lib.RegisterCallback
  -- @usage
  -- rc.RegisterCallback(self, rc.CHECKERS_CHANGED, "myCallback")
  -- -- or
  -- rc.RegisterCallback(self, "CHECKERS_CHANGED", someCallbackFunction)
  -- @see CallbackHandler-1.0 documentation for more details
  lib.RegisterCallback = lib.RegisterCallback
    or function(...)
      local CBH = LibStub("CallbackHandler-1.0")
      lib.RegisterCallback = nil -- extra safety, we shouldn't get this far if CBH is not found, but better an error later than an infinite recursion now
      lib.callbacks = CBH:New(lib)
      -- ok, CBH hopefully injected or new shiny RegisterCallback
      return lib.RegisterCallback(...)
    end
end

--- END CallbackHandler stuff

lib:activate()


-- ========================================
-- File: WeakAuras/Libs/LibSerialize/LibSerialize.lua
-- ========================================

--[[
Copyright (c) 2020 Ross Nichols

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Credits:
The following projects served as inspiration for aspects of this project:

1. LibDeflate, by Haoqian He. https://github.com/SafeteeWoW/LibDeflate
    For the CreateReader/CreateWriter functions.
2. lua-MessagePack, by Franois Perrad. https://framagit.org/fperrad/lua-MessagePack
    For the mechanism for packing/unpacking floats and ints.
3. LibQuestieSerializer, by aero. https://github.com/AeroScripts/LibQuestieSerializer
    For the basis of the implementation, and initial inspiration.
]]


-- Latest version can be found at https://github.com/rossnichols/LibSerialize.

--[[
# LibSerialize

LibSerialize is a Lua library for efficiently serializing/deserializing arbitrary values.
It supports serializing nils, numbers, booleans, strings, and tables containing these types.

It is best paired with [LibDeflate](https://github.com/safeteeWow/LibDeflate), to compress
the serialized output and optionally encode it for World of Warcraft addon or chat channels.
IMPORTANT: if you decide not to compress the output and plan on transmitting over an addon
channel, it still needs to be encoded, but encoding via `LibDeflate:EncodeForWoWAddonChannel()`
or `LibCompress:GetAddonEncodeTable()` will likely inflate the size of the serialization
by a considerable amount. See the usage below for an alternative.

Note that serialization and compression are sensitive to the specifics of your data set.
You should experiment with the available libraries (LibSerialize, AceSerializer, LibDeflate,
LibCompress, etc.) to determine which combination works best for you.


## Usage:

```lua
-- Dependencies: AceAddon-3.0, AceComm-3.0, LibSerialize, LibDeflate
MyAddon = LibStub("AceAddon-3.0"):NewAddon("MyAddon", "AceComm-3.0")
local LibSerialize = LibStub("LibSerialize")
local LibDeflate = LibStub("LibDeflate")

function MyAddon:OnEnable()
    self:RegisterComm("MyPrefix")
end

-- With compression (recommended):
function MyAddon:Transmit(data)
    local serialized = LibSerialize:Serialize(data)
    local compressed = LibDeflate:CompressDeflate(serialized)
    local encoded = LibDeflate:EncodeForWoWAddonChannel(compressed)
    self:SendCommMessage("MyPrefix", encoded, "WHISPER", UnitName("player"))
end

function MyAddon:OnCommReceived(prefix, payload, distribution, sender)
    local decoded = LibDeflate:DecodeForWoWAddonChannel(payload)
    if not decoded then return end
    local decompressed = LibDeflate:DecompressDeflate(decoded)
    if not decompressed then return end
    local success, data = LibSerialize:Deserialize(decompressed)
    if not success then return end

    -- Handle `data`
end

-- Without compression (custom codec):
MyAddon._codec = LibDeflate:CreateCodec("\000", "\255", "")
function MyAddon:Transmit(data)
    local serialized = LibSerialize:Serialize(data)
    local encoded = self._codec:Encode(serialized)
    self:SendCommMessage("MyPrefix", encoded, "WHISPER", UnitName("player"))
end
function MyAddon:OnCommReceived(prefix, payload, distribution, sender)
    local decoded = self._codec:Decode(payload)
    if not decoded then return end
    local success, data = LibSerialize:Deserialize(decoded)
    if not success then return end

    -- Handle `data`
end
```


## API:
* **`LibSerialize:SerializeEx(opts, ...)`**

    Arguments:
    * `opts`: options (see below)
    * `...`: a variable number of serializable values

    Returns:
    * result: `...` serialized as a string

* **`LibSerialize:Serialize(...)`**

    Arguments:
    * `...`: a variable number of serializable values

    Returns:
    * `result`: `...` serialized as a string

    Calls `SerializeEx(opts, ...)` with the default options (see below)

* **`LibSerialize:Deserialize(input)`**

    Arguments:
    * `input`: a string previously returned from `LibSerialize:Serialize()`

    Returns:
    * `success`: a boolean indicating if deserialization was successful
    * `...`: the deserialized value(s), or a string containing the encountered Lua error

* **`LibSerialize:DeserializeValue(input)`**

    Arguments:
    * `input`: a string previously returned from `LibSerialize:Serialize()`

    Returns:
    * `...`: the deserialized value(s)

* **`LibSerialize:IsSerializableType(...)`**

    Arguments:
    * `...`: a variable number of values

    Returns:
    * `result`: true if all of the values' types are serializable.

    Note that if you pass a table, it will be considered serializable
    even if it contains unserializable keys or values. Only the types
    of the arguments are checked.

`Serialize()` will raise a Lua error if the input cannot be serialized.
This will occur if any of the following exceed 16777215: any string length,
any table key count, number of unique strings, number of unique tables.
It will also occur by default if any unserializable types are encountered,
though that behavior may be disabled (see options).

`Deserialize()` and `DeserializeValue()` are equivalent, except the latter
returns the deserialization result directly and will not catch any Lua
errors that may occur when deserializing invalid input.

Note that none of the serialization/deseriazation methods support reentrancy,
and modifying tables during the serialization process is unspecified and
should be avoided. Table serialization is multi-phased and assumes a consistent
state for the key/value pairs across the phases.


## Options:
The following serialization options are supported:
* `errorOnUnserializableType`: `boolean` (default true)
  * `true`: unserializable types will raise a Lua error
  * `false`: unserializable types will be ignored. If it's a table key or value,
     the key/value pair will be skipped. If it's one of the arguments to the
     call to SerializeEx(), it will be replaced with `nil`.
* `filter`: `function(t, k, v) => boolean` (default nil)
  * If specified, the function will be called on every key/value pair in every
    table encountered during serialization. The function must return true for
    the pair to be serialized. It may be called multiple times on a table for
    the same key/value pair. See notes on reeentrancy and table modification.

If an option is unspecified in the table, then its default will be used.
This means that if an option `foo` defaults to true, then:
* `myOpts.foo = false`: option `foo` is false
* `myOpts.foo = nil`: option `foo` is true


## Customizing table serialization:
For any serialized table, LibSerialize will check for the presence of a
metatable key `__LibSerialize`. It will be interpreted as a table with
the following possible keys:
* `filter`: `function(t, k, v) => boolean`
  * If specified, the function will be called on every key/value pair in that
    table. The function must return true for the pair to be serialized. It may
    be called multiple times on a table for the same key/value pair. See notes
    on reeentrancy and table modification. If combined with the `filter` option,
    both functions must return true.


## Examples:
1. `LibSerialize:Serialize()` supports variadic arguments and arbitrary key types,
   maintaining a consistent internal table identity.
    ```lua
    local t = { "test", [false] = {} }
    t[ t[false] ] = "hello"
    local serialized = LibSerialize:Serialize(t, "extra")
    local success, tab, str = LibSerialize:Deserialize(serialized)
    assert(success)
    assert(tab[1] == "test")
    assert(tab[ tab[false] ] == "hello")
    assert(str == "extra")
    ```

2. Normally, unserializable types raise an error when encountered during serialization,
   but that behavior can be disabled in order to silently ignore them instead.
    ```lua
    local serialized = LibSerialize:SerializeEx(
        { errorOnUnserializableType = false },
        print, { a = 1, b = print })
    local success, fn, tab = LibSerialize:Deserialize(serialized)
    assert(success)
    assert(fn == nil)
    assert(tab.a == 1)
    assert(tab.b == nil)
    ```

3. Tables may reference themselves recursively and will still be serialized properly.
    ```lua
    local t = { a = 1 }
    t.t = t
    t[t] = "test"
    local serialized = LibSerialize:Serialize(t)
    local success, tab = LibSerialize:Deserialize(serialized)
    assert(success)
    assert(tab.t.t.t.t.t.t.a == 1)
    assert(tab[tab.t] == "test")
    ```

4. You may specify a global filter that applies to all tables encountered during
   serialization, and to individual tables via their metatable.
    ```lua
    local t = { a = 1, b = print, c = 3 }
    local nested = { a = 1, b = print, c = 3 }
    t.nested = nested
    setmetatable(nested, { __LibSerialize = {
        filter = function(t, k, v) return k ~= "c" end
    }})
    local opts = {
        filter = function(t, k, v) return LibSerialize:IsSerializableType(k, v) end
    }
    local serialized = LibSerialize:SerializeEx(opts, t)
    local success, tab = LibSerialize:Deserialize(serialized)
    assert(success)
    assert(tab.a == 1)
    assert(tab.b == nil)
    assert(tab.c == 3)
    assert(tab.nested.a == 1)
    assert(tab.nested.b == nil)
    assert(tab.nested.c == nil)
    ```


## Encoding format:
Every object is encoded as a type byte followed by type-dependent payload.

For numbers, the payload is the number itself, using a number of bytes
appropriate for the number. Small numbers can be embedded directly into
the type byte, optionally with an additional byte following for more
possible values. Negative numbers are encoded as their absolute value,
with the type byte indicating that it is negative. Floats are decomposed
into their eight bytes, unless serializing as a string is shorter.

For strings and tables, the length/count is also encoded so that the
payload doesn't need a special terminator. Small counts can be embedded
directly into the type byte, whereas larger counts are encoded directly
following the type byte, before the payload.

Strings are stored directly, with no transformations. Tables are stored
in one of three ways, depending on their layout:
* Array-like: all keys are numbers starting from 1 and increasing by 1.
    Only the table's values are encoded.
* Map-like: the table has no array-like keys.
    The table is encoded as key-value pairs.
* Mixed: the table has both map-like and array-like keys.
    The table is encoded first with the values of the array-like keys,
    followed by key-value pairs for the map-like keys. For this version,
    two counts are encoded, one each for the two different portions.

Strings and tables are also tracked as they are encountered, to detect reuse.
If a string or table is reused, it is encoded instead as an index into the
tracking table for that type. Strings must be >2 bytes in length to be tracked.
Tables may reference themselves recursively.


#### Type byte:
The type byte uses the following formats to implement the above:

* `NNNN NNN1`: a 7 bit non-negative int
* `CCCC TT10`: a 2 bit type index and 4 bit count (strlen, #tab, etc.)
    * Followed by the type-dependent payload
* `NNNN S100`: the lower four bits of a 12 bit int and 1 bit for its sign
    * Followed by a byte for the upper bits
* `TTTT T000`: a 5 bit type index
    * Followed by the type-dependent payload, including count(s) if needed
--]]

local MAJOR, MINOR = "LibSerialize", 1
local LibSerialize
if LibStub then
    LibSerialize = LibStub:NewLibrary(MAJOR, MINOR)
    if not LibSerialize then return end -- This version is already loaded.
else
    LibSerialize = {}
end

local assert = assert
local error = error
local pcall = pcall
local print = print
local getmetatable = getmetatable
local pairs = pairs
local ipairs = ipairs
local select = select
local unpack = unpack
local type = type
local tostring = tostring
local tonumber = tonumber
local max = math.max
local frexp = math.frexp
local ldexp = math.ldexp
local floor = math.floor
local math_modf = math.modf
local math_huge = math.huge
local string_byte = string.byte
local string_char = string.char
local string_sub = string.sub
local table_concat = table.concat
local table_insert = table.insert

local defaultOptions = {
    errorOnUnserializableType = true
}

local canSerializeFnOptions = {
    errorOnUnserializableType = false
}


--[[---------------------------------------------------------------------------
    Helper functions.
--]]---------------------------------------------------------------------------

-- Returns the number of bytes required to store the value,
-- up to a maximum of three. Errors if three bytes is insufficient.
local function GetRequiredBytes(value)
    if value < 256 then return 1 end
    if value < 65536 then return 2 end
    if value < 16777216 then return 3 end
    error("Object limit exceeded")
end

-- Returns the number of bytes required to store the value,
-- though always returning seven if four bytes is insufficient.
-- Doubles have room for 53bit numbers, so seven bits max.
local function GetRequiredBytesNumber(value)
    if value < 256 then return 1 end
    if value < 65536 then return 2 end
    if value < 16777216 then return 3 end
    if value < 4294967296 then return 4 end
    return 7
end

-- Returns whether the value (a number) is fractional,
-- as opposed to a whole number.
local function IsFractional(value)
    local _, fract = math_modf(value)
    return fract ~= 0
end

-- Prints args to the chat window. To enable debug statements,
-- do a find/replace in this file with "-- DebugPrint(" for "DebugPrint(",
-- or the reverse to disable them again.
local DebugPrint = function(...)
    print(...)
    -- ABGP:WriteLogged("SERIALIZE", table_concat({tostringall(...)}, " "))
end


--[[---------------------------------------------------------------------------
    Helpers for reading/writing streams of bytes from/to a string
--]]---------------------------------------------------------------------------

-- Creates a writer to lazily construct a string over multiple writes.
-- Return values:
-- 1. WriteString(str)
-- 2. Flush()
local function CreateWriter()
    local bufferSize = 0
    local buffer = {}

    -- Write the entire string into the writer.
    local function WriteString(str)
        -- DebugPrint("Writing string:", str, #str)
        bufferSize = bufferSize + 1
        buffer[bufferSize] = str
    end

    -- Return a string built from the previous calls to WriteString.
    local function FlushWriter()
        local flushed = table_concat(buffer, "", 1, bufferSize)
        bufferSize = 0
        return flushed
    end

    return WriteString, FlushWriter
end

-- Creates a reader to sequentially read bytes from the input string.
-- Return values:
-- 1. ReadBytes(bytelen)
-- 2. ReaderBytesLeft()
local function CreateReader(input)
    local input = input
    local inputLen = #input
    local nextPos = 1

    -- Read some bytes from the reader.
    -- @param bytelen The number of bytes to be read.
    -- @return the bytes as a string
    local function ReadBytes(bytelen)
        local result = string_sub(input, nextPos, nextPos + bytelen - 1)
        nextPos = nextPos + bytelen
        return result
    end

    local function ReaderBytesLeft()
        return inputLen - nextPos + 1
    end

    return ReadBytes, ReaderBytesLeft
end


--[[---------------------------------------------------------------------------
    Helpers for serializing/deserializing numbers (ints and floats)
--]]---------------------------------------------------------------------------

local function FloatToString(n)
    local sign = 0
    if n < 0.0 then
        sign = 0x80
        n = -n
    end
    local mant, expo = frexp(n)
    if mant ~= mant then -- nan
        return string_char(0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
    elseif mant == math_huge or expo > 0x400 then
        if sign == 0 then -- inf
            return string_char(0x7F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
        else -- -inf
            return string_char(0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
        end
    elseif (mant == 0.0 and expo == 0) or expo < -0x3FE then -- zero
        return string_char(sign, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)
    else
        expo = expo + 0x3FE
        mant = floor((mant * 2.0 - 1.0) * ldexp(0.5, 53))
        return string_char(sign + floor(expo / 0x10),
                           (expo % 0x10) * 0x10 + floor(mant / 281474976710656),
                           floor(mant / 1099511627776) % 256,
                           floor(mant / 4294967296) % 256,
                           floor(mant / 16777216) % 256,
                           floor(mant / 65536) % 256,
                           floor(mant / 256) % 256,
                           mant % 256)
    end
end

local function StringToFloat(str)
    local b1, b2, b3, b4, b5, b6, b7, b8 = string_byte(str, 1, 8)
    local sign = b1 > 0x7F
    local expo = (b1 % 0x80) * 0x10 + floor(b2 / 0x10)
    local mant = ((((((b2 % 0x10) * 256 + b3) * 256 + b4) * 256 + b5) * 256 + b6) * 256 + b7) * 256 + b8
    if sign then
        sign = -1
    else
        sign = 1
    end
    local n
    if mant == 0 and expo == 0 then
        n = sign * 0.0
    elseif expo == 0x7FF then
        if mant == 0 then
            n = sign * math_huge
        else
            n = 0.0/0.0
        end
    else
        n = sign * ldexp(1.0 + mant / 4503599627370496.0, expo - 0x3FF)
    end
    return n
end

local function IntToString(n, required)
    if required == 1 then
        return string_char(n)
    elseif required == 2 then
        return string_char(floor(n / 256),
                           n % 256)
    elseif required == 3 then
        return string_char(floor(n / 65536),
                           floor(n / 256) % 256,
                           n % 256)
    elseif required == 4 then
        return string_char(floor(n / 16777216),
                           floor(n / 65536) % 256,
                           floor(n / 256) % 256,
                           n % 256)
    elseif required == 7 then
        return string_char(floor(n / 281474976710656) % 256,
                           floor(n / 1099511627776) % 256,
                           floor(n / 4294967296) % 256,
                           floor(n / 16777216) % 256,
                           floor(n / 65536) % 256,
                           floor(n / 256) % 256,
                           n % 256)
    end

    error("Invalid required bytes: " .. required)
end

local function StringToInt(str, required)
    if required == 1 then
        return string_byte(str)
    elseif required == 2 then
        local b1, b2 = string_byte(str, 1, 2)
        return b1 * 256 + b2
    elseif required == 3 then
        local b1, b2, b3 = string_byte(str, 1, 3)
        return (b1 * 256 + b2) * 256 + b3
    elseif required == 4 then
        local b1, b2, b3, b4 = string_byte(str, 1, 4)
        return ((b1 * 256 + b2) * 256 + b3) * 256 + b4
    elseif required == 7 then
        local b1, b2, b3, b4, b5, b6, b7, b8 = 0, string_byte(str, 1, 7)
        return ((((((b1 * 256 + b2) * 256 + b3) * 256 + b4) * 256 + b5) * 256 + b6) * 256 + b7) * 256 + b8
    end

    error("Invalid required bytes: " .. required)
end


--[[---------------------------------------------------------------------------
    Object reuse:
    As strings/tables are serialized or deserialized, they are stored in this lookup
    table in case they're encountered again, at which point they can be referenced
    by their index into this table rather than repeating the string contents.
--]]---------------------------------------------------------------------------

local refsDirty = false
local stringRefs = {}
local tableRefs = {}

function LibSerialize:_AddReference(refs, value)
    refsDirty = true

    local ref = #refs + 1
    refs[ref] = value
    refs[value] = ref
end

function LibSerialize:_ClearReferences()
    if refsDirty then
        stringRefs = {}
        tableRefs = {}
    end
end


--[[---------------------------------------------------------------------------
    Read (deserialization) support.
--]]---------------------------------------------------------------------------

function LibSerialize:_ReadObject()
    local value = self:_ReadByte()

    if value % 2 == 1 then
        -- Number embedded in the top 7 bits.
        local num = (value - 1) / 2
        -- DebugPrint("Found embedded number (1byte):", value, num)
        return num
    end

    if value % 4 == 2 then
        -- Type with embedded count. Extract both.
        -- The type is in bits 3-4, count in 5-8.
        local typ = (value - 2) / 4
        local count = (typ - typ % 4) / 4
        typ = typ % 4
        -- DebugPrint("Found type with embedded count:", value, typ, count)
        return self._EmbeddedReaderTable[typ](self, count)
    end

    if value % 8 == 4 then
        -- Number embedded in the top 4 bits, plus an additional byte's worth (so 12 bits).
        -- If bit 4 is set, the number is negative.
        local packed = self:_ReadByte() * 256 + value
        local num
        if value % 16 == 12 then
            num = -(packed - 12) / 16
        else
            num = (packed - 4) / 16
        end
        -- DebugPrint("Found embedded number (2bytes):", value, packed, num)
        return num
    end

    -- Otherwise, the type index is embedded in the upper 5 bits.
    local typ = value / 8
    -- DebugPrint("Found type:", value, typ)
    return self._ReaderTable[typ](self)
end

function LibSerialize:_ReadTable(entryCount, value)
    -- DebugPrint("Extracting keys/values for table:", entryCount)

    if value == nil then
        value = {}
        self:_AddReference(tableRefs, value)
    end

    for i = 1, entryCount do
        local k, v = self:_ReadPair(self._ReadObject)
        value[k] = v
    end

    return value
end

function LibSerialize:_ReadArray(entryCount, value)
    -- DebugPrint("Extracting values for array:", entryCount)

    if value == nil then
        value = {}
        self:_AddReference(tableRefs, value)
    end

    for i = 1, entryCount do
        value[i] = self:_ReadObject()
    end

    return value
end

function LibSerialize:_ReadMixed(arrayCount, mapCount)
    -- DebugPrint("Extracting values for mixed table:", arrayCount, mapCount)

    local value = {}
    self:_AddReference(tableRefs, value)

    self:_ReadArray(arrayCount, value)
    self:_ReadTable(mapCount, value)

    return value
end

function LibSerialize:_ReadString(len)
    -- DebugPrint("Reading string,", len)

    local value = self._readBytes(len)
    if len > 2 then
        self:_AddReference(stringRefs, value)
    end
    return value
end

function LibSerialize:_ReadByte()
    -- DebugPrint("Reading byte")

    return self:_ReadInt(1)
end

function LibSerialize:_ReadInt(required)
    -- DebugPrint("Reading int", required)

    return StringToInt(self._readBytes(required), required)
end

function LibSerialize:_ReadPair(fn, ...)
    local first = fn(self, ...)
    local second = fn(self, ...)
    return first, second
end

local embeddedIndexShift = 4
local embeddedCountShift = 16
LibSerialize._EmbeddedIndex = {
    STRING = 0,
    TABLE = 1,
    ARRAY = 2,
    MIXED = 3,
}
LibSerialize._EmbeddedReaderTable = {
    [LibSerialize._EmbeddedIndex.STRING] = function(self, c) return self:_ReadString(c) end,
    [LibSerialize._EmbeddedIndex.TABLE] =  function(self, c) return self:_ReadTable(c) end,
    [LibSerialize._EmbeddedIndex.ARRAY] =  function(self, c) return self:_ReadArray(c) end,
    -- For MIXED, the 4-bit count contains two 2-bit counts that are one less than the true count.
    [LibSerialize._EmbeddedIndex.MIXED] =  function(self, c) return self:_ReadMixed((c % 4) + 1, floor(c / 4) + 1) end,
}

local readerIndexShift = 8
LibSerialize._ReaderIndex = {
    NIL = 0,

    NUM_16_POS = 1,
    NUM_16_NEG = 2,
    NUM_24_POS = 3,
    NUM_24_NEG = 4,
    NUM_32_POS = 5,
    NUM_32_NEG = 6,
    NUM_64_POS = 7,
    NUM_64_NEG = 8,
    NUM_FLOAT = 9,
    NUM_FLOATSTR_POS = 10,
    NUM_FLOATSTR_NEG = 11,

    BOOL_T = 12,
    BOOL_F = 13,

    STR_8 = 14,
    STR_16 = 15,
    STR_24 = 16,

    TABLE_8 = 17,
    TABLE_16 = 18,
    TABLE_24 = 19,

    ARRAY_8 = 20,
    ARRAY_16 = 21,
    ARRAY_24 = 22,

    MIXED_8 = 23,
    MIXED_16 = 24,
    MIXED_24 = 25,

    STRINGREF_8 = 26,
    STRINGREF_16 = 27,
    STRINGREF_24 = 28,

    TABLEREF_8 = 29,
    TABLEREF_16 = 30,
    TABLEREF_24 = 31,
}
LibSerialize._ReaderTable = {
    -- Nil
    [LibSerialize._ReaderIndex.NIL]  = function(self) return nil end,

    -- Numbers (ones requiring <=12 bits are handled separately)
    [LibSerialize._ReaderIndex.NUM_16_POS] = function(self) return self:_ReadInt(2) end,
    [LibSerialize._ReaderIndex.NUM_16_NEG] = function(self) return -self:_ReadInt(2) end,
    [LibSerialize._ReaderIndex.NUM_24_POS] = function(self) return self:_ReadInt(3) end,
    [LibSerialize._ReaderIndex.NUM_24_NEG] = function(self) return -self:_ReadInt(3) end,
    [LibSerialize._ReaderIndex.NUM_32_POS] = function(self) return self:_ReadInt(4) end,
    [LibSerialize._ReaderIndex.NUM_32_NEG] = function(self) return -self:_ReadInt(4) end,
    [LibSerialize._ReaderIndex.NUM_64_POS] = function(self) return self:_ReadInt(7) end,
    [LibSerialize._ReaderIndex.NUM_64_NEG] = function(self) return -self:_ReadInt(7) end,
    [LibSerialize._ReaderIndex.NUM_FLOAT]  = function(self) return StringToFloat(self._readBytes(8)) end,
    [LibSerialize._ReaderIndex.NUM_FLOATSTR_POS]  = function(self) return tonumber(self._readBytes(self:_ReadByte())) end,
    [LibSerialize._ReaderIndex.NUM_FLOATSTR_NEG]  = function(self) return -tonumber(self._readBytes(self:_ReadByte())) end,

    -- Booleans
    [LibSerialize._ReaderIndex.BOOL_T] = function(self) return true end,
    [LibSerialize._ReaderIndex.BOOL_F] = function(self) return false end,

    -- Strings (encoded as size + buffer)
    [LibSerialize._ReaderIndex.STR_8]  = function(self) return self:_ReadString(self:_ReadByte()) end,
    [LibSerialize._ReaderIndex.STR_16] = function(self) return self:_ReadString(self:_ReadInt(2)) end,
    [LibSerialize._ReaderIndex.STR_24] = function(self) return self:_ReadString(self:_ReadInt(3)) end,

    -- Tables (encoded as count + key/value pairs)
    [LibSerialize._ReaderIndex.TABLE_8]  = function(self) return self:_ReadTable(self:_ReadByte()) end,
    [LibSerialize._ReaderIndex.TABLE_16] = function(self) return self:_ReadTable(self:_ReadInt(2)) end,
    [LibSerialize._ReaderIndex.TABLE_24] = function(self) return self:_ReadTable(self:_ReadInt(3)) end,

    -- Arrays (encoded as count + values)
    [LibSerialize._ReaderIndex.ARRAY_8]  = function(self) return self:_ReadArray(self:_ReadByte()) end,
    [LibSerialize._ReaderIndex.ARRAY_16] = function(self) return self:_ReadArray(self:_ReadInt(2)) end,
    [LibSerialize._ReaderIndex.ARRAY_24] = function(self) return self:_ReadArray(self:_ReadInt(3)) end,

    -- Mixed arrays/maps (encoded as arrayCount + mapCount + arrayValues + key/value pairs)
    [LibSerialize._ReaderIndex.MIXED_8]  = function(self) return self:_ReadMixed(self:_ReadPair(self._ReadByte)) end,
    [LibSerialize._ReaderIndex.MIXED_16] = function(self) return self:_ReadMixed(self:_ReadPair(self._ReadInt, 2)) end,
    [LibSerialize._ReaderIndex.MIXED_24] = function(self) return self:_ReadMixed(self:_ReadPair(self._ReadInt, 3)) end,

    -- Previously referenced strings
    [LibSerialize._ReaderIndex.STRINGREF_8]  = function(self) return stringRefs[self:_ReadByte()] end,
    [LibSerialize._ReaderIndex.STRINGREF_16] = function(self) return stringRefs[self:_ReadInt(2)] end,
    [LibSerialize._ReaderIndex.STRINGREF_24] = function(self) return stringRefs[self:_ReadInt(3)] end,

    -- Previously referenced tables
    [LibSerialize._ReaderIndex.TABLEREF_8]  = function(self) return tableRefs[self:_ReadByte()] end,
    [LibSerialize._ReaderIndex.TABLEREF_16] = function(self) return tableRefs[self:_ReadInt(2)] end,
    [LibSerialize._ReaderIndex.TABLEREF_24] = function(self) return tableRefs[self:_ReadInt(3)] end,
}


--[[---------------------------------------------------------------------------
    Write (serialization) support.
--]]---------------------------------------------------------------------------

-- Returns the appropriate function from the writer table for the object's type.
-- If the object's type isn't supported and opts.errorOnUnserializableType is true,
-- then an error will be raised.
function LibSerialize:_GetWriteFn(obj, opts)
    local typ = type(obj)
    local writeFn = self._WriterTable[typ]
    if not writeFn and opts.errorOnUnserializableType then
        error(("Unhandled type: %s"):format(typ))
    end

    return writeFn
end

-- Returns true if all of the variadic arguments are serializable.
-- Note that _GetWriteFn will raise a Lua error if it finds an
-- unserializable type, unless this behavior is suppressed via options.
function LibSerialize:_CanSerialize(opts, ...)
    for i = 1, select("#", ...) do
        local obj = select(i, ...)
        local writeFn = self:_GetWriteFn(obj, opts)
        if not writeFn then
            return false
        end
    end

    return true
end

-- Returns true if the table's key/value pair should be serialized.
-- Both filter functions (if present) must return true, and the
-- key/value types must be serializable. Note that _CanSerialize
-- will raise a Lua error if it finds an unserializable type, unless
-- this behavior is suppressed via options.
function LibSerialize:_ShouldSerialize(t, k, v, opts, filterFn)
    return (not opts.filter or opts.filter(t, k, v)) and
           (not filterFn or filterFn(t, k, v)) and
           self:_CanSerialize(opts, k, v)
end

-- Note that _GetWriteFn will raise a Lua error if it finds an
-- unserializable type, unless this behavior is suppressed via options.
function LibSerialize:_WriteObject(obj, opts)
    local writeFn = self:_GetWriteFn(obj, opts)
    if not writeFn then
        return false
    end

    writeFn(self, obj, opts)
    return true
end

function LibSerialize:_WriteByte(value)
    self:_WriteInt(value, 1)
end

function LibSerialize:_WriteInt(n, threshold)
    self._writeString(IntToString(n, threshold))
end

-- Lookup tables to map the number of required bytes to the
-- appropriate reader table index.
local numberIndices = {
    [2] = LibSerialize._ReaderIndex.NUM_16_POS,
    [3] = LibSerialize._ReaderIndex.NUM_24_POS,
    [4] = LibSerialize._ReaderIndex.NUM_32_POS,
    [7] = LibSerialize._ReaderIndex.NUM_64_POS,
}
local stringIndices = {
    [1] = LibSerialize._ReaderIndex.STR_8,
    [2] = LibSerialize._ReaderIndex.STR_16,
    [3] = LibSerialize._ReaderIndex.STR_24,
}
local tableIndices = {
    [1] = LibSerialize._ReaderIndex.TABLE_8,
    [2] = LibSerialize._ReaderIndex.TABLE_16,
    [3] = LibSerialize._ReaderIndex.TABLE_24,
}
local arrayIndices = {
    [1] = LibSerialize._ReaderIndex.ARRAY_8,
    [2] = LibSerialize._ReaderIndex.ARRAY_16,
    [3] = LibSerialize._ReaderIndex.ARRAY_24,
}
local mixedIndices = {
    [1] = LibSerialize._ReaderIndex.MIXED_8,
    [2] = LibSerialize._ReaderIndex.MIXED_16,
    [3] = LibSerialize._ReaderIndex.MIXED_24,
}
local stringRefIndices = {
    [1] = LibSerialize._ReaderIndex.STRINGREF_8,
    [2] = LibSerialize._ReaderIndex.STRINGREF_16,
    [3] = LibSerialize._ReaderIndex.STRINGREF_24,
}
local tableRefIndices = {
    [1] = LibSerialize._ReaderIndex.TABLEREF_8,
    [2] = LibSerialize._ReaderIndex.TABLEREF_16,
    [3] = LibSerialize._ReaderIndex.TABLEREF_24,
}

LibSerialize._WriterTable = {
    ["nil"] = function(self)
        -- DebugPrint("Serializing nil")
        self:_WriteByte(readerIndexShift * self._ReaderIndex.NIL)
    end,
    ["number"] = function(self, num)
        if IsFractional(num) then
            -- DebugPrint("Serializing float:", num)
            -- Normally a float takes 8 bytes. See if it's cheaper to encode as a string.
            -- If we encode as a string, though, we'll need a byte for its length.
            local sign = 0
            local numAbs = num
            if num < 0 then
                sign = readerIndexShift
                numAbs = -num
            end
            local asString = tostring(numAbs)
            if #asString < 7 and tonumber(asString) == numAbs then
                self:_WriteByte(sign + readerIndexShift * self._ReaderIndex.NUM_FLOATSTR_POS)
                self:_WriteByte(#asString, 1)
                self._writeString(asString)
            else
                self:_WriteByte(readerIndexShift * self._ReaderIndex.NUM_FLOAT)
                self._writeString(FloatToString(num))
            end
        elseif num > -4096 and num < 4096 then
            -- The type byte supports two modes by which a number can be embedded:
            -- A 1-byte mode for 7-bit numbers, and a 2-byte mode for 12-bit numbers.
            if num >= 0 and num < 128 then
                -- DebugPrint("Serializing embedded number (1byte):", num)
                self:_WriteByte(num * 2 + 1)
            else
                -- DebugPrint("Serializing embedded number (2bytes):", num)
                local sign = 0
                if num < 0 then
                    sign = 8
                    num = -num
                end
                num = num * 16 + sign + 4
                local upper, lower = floor(num / 256), num % 256
                self:_WriteByte(lower)
                self:_WriteByte(upper)
            end
        else
            -- DebugPrint("Serializing number:", num)
            local sign = 0
            if num < 0 then
                num = -num
                sign = readerIndexShift
            end
            local required = GetRequiredBytesNumber(num)
            self:_WriteByte(sign + readerIndexShift * numberIndices[required])
            self:_WriteInt(num, required)
        end
    end,
    ["boolean"] = function(self, bool)
        -- DebugPrint("Serializing bool:", bool)
        self:_WriteByte(readerIndexShift * (bool and self._ReaderIndex.BOOL_T or self._ReaderIndex.BOOL_F))
    end,
    ["string"] = function(self, str)
        local ref = stringRefs[str]
        if ref then
            -- DebugPrint("Serializing string ref:", str)
            local required = GetRequiredBytes(ref)
            self:_WriteByte(readerIndexShift * stringRefIndices[required])
            self:_WriteInt(stringRefs[str], required)
        else
            local len = #str
            if len < 16 then
                -- Short lengths can be embedded directly into the type byte.
                -- DebugPrint("Serializing string, embedded count:", str, len)
                self:_WriteByte(embeddedCountShift * len + embeddedIndexShift * self._EmbeddedIndex.STRING + 2)
            else
                -- DebugPrint("Serializing string:", str, len)
                local required = GetRequiredBytes(len)
                self:_WriteByte(readerIndexShift * stringIndices[required])
                self:_WriteInt(len, required)
            end

            self._writeString(str)
            if len > 2 then
                self:_AddReference(stringRefs, str)
            end
        end
    end,
    ["table"] = function(self, tab, opts)
        local ref = tableRefs[tab]
        if ref then
            -- DebugPrint("Serializing table ref:", tab)
            local required = GetRequiredBytes(ref)
            self:_WriteByte(readerIndexShift * tableRefIndices[required])
            self:_WriteInt(tableRefs[tab], required)
        else
            -- Add a reference before trying to serialize the table's contents,
            -- so that if the table recursively references itself, we can still
            -- properly serialize it.
            self:_AddReference(tableRefs, tab)

            local filter
            local mt = getmetatable(tab)
            if mt and type(mt) == "table" and mt.__LibSerialize then
                filter = mt.__LibSerialize.filter
            end

            -- First determine the "proper" length of the array portion of the table,
            -- which terminates at its first nil value. Note that some values in this
            -- range may not be serializable, which is fine - we'll handle them later.
            -- It's better to maximize the number of values that can be serialized
            -- without needing to also serialize their keys.
            local arrayCount, serializableArrayCount = 0, 0
            local entireArraySerializable = true
            local totalArraySerializable = 0
            for i, v in ipairs(tab) do
                arrayCount = i
                if self:_ShouldSerialize(tab, i, v, opts, filter) then
                    totalArraySerializable = totalArraySerializable + 1
                    if entireArraySerializable then
                        serializableArrayCount = i
                    end
                else
                    entireArraySerializable = false
                end
            end

            -- Consider the array portion as a series of zero or more serializable
            -- entries followed by zero or more entries that may or may not be
            -- serializable. For the latter portion, we can either write them in
            -- the array portion, padding the unserializable entries with nils,
            -- or just write them as key/value pairs in the map portion. We'll choose
            -- the former if there are more serializable entries in this portion than
            -- unserializable, or the latter if more are unserializable.
            if arrayCount - totalArraySerializable > totalArraySerializable - serializableArrayCount then
                arrayCount = serializableArrayCount
                entireArraySerializable = true
            end

            -- Next determine the count of all entries in the table whose keys are not
            -- included in the array portion, only counting keys that are serializable.
            local mapCount = 0
            local entireMapSerializable = true
            for k, v in pairs(tab) do
                local isArrayKey = type(k) == "number" and k >= 1 and k <= arrayCount and not IsFractional(k)
                if not isArrayKey then
                    if self:_ShouldSerialize(tab, k, v, opts, filter) then
                        mapCount = mapCount + 1
                    else
                        entireMapSerializable = false
                    end
                end
            end

            if mapCount == 0 then
                -- The table is an array. We can avoid writing the keys.
                if arrayCount < 16 then
                    -- Short counts can be embedded directly into the type byte.
                    -- DebugPrint("Serializing array, embedded count:", arrayCount)
                    self:_WriteByte(embeddedCountShift * arrayCount + embeddedIndexShift * self._EmbeddedIndex.ARRAY + 2)
                else
                    -- DebugPrint("Serializing array:", arrayCount)
                    local required = GetRequiredBytes(arrayCount)
                    self:_WriteByte(readerIndexShift * arrayIndices[required])
                    self:_WriteInt(arrayCount, required)
                end

                for i = 1, arrayCount do
                    local v = tab[i]
                    if entireArraySerializable or self:_ShouldSerialize(tab, i, v, opts, filter) then
                        self:_WriteObject(v, opts)
                    else
                        -- Since the keys are being omitted, write a `nil` entry
                        -- for any values that shouldn't be serialized.
                        self:_WriteObject(nil, opts)
                    end
                end
            elseif arrayCount ~= 0 then
                -- The table has both array and dictionary keys. We can still save space
                -- by writing the array values first without keys.

                if mapCount < 5 and arrayCount < 5 then
                    -- Short counts can be embedded directly into the type byte.
                    -- They have to be really short though, since we have two counts.
                    -- Since neither can be zero (this is a mixed table),
                    -- we can get away with not being able to represent 0.
                    -- DebugPrint("Serializing mixed array-table, embedded counts:", arrayCount, mapCount)
                    local combined = (mapCount - 1) * 4 + arrayCount - 1
                    self:_WriteByte(embeddedCountShift * combined + embeddedIndexShift * self._EmbeddedIndex.MIXED + 2)
                else
                    -- Use the max required bytes for the two counts.
                    -- DebugPrint("Serializing mixed array-table:", arrayCount, mapCount)
                    local required = max(GetRequiredBytes(mapCount), GetRequiredBytes(arrayCount))
                    self:_WriteByte(readerIndexShift * mixedIndices[required])
                    self:_WriteInt(arrayCount, required)
                    self:_WriteInt(mapCount, required)
                end

                for i = 1, arrayCount do
                    local v = tab[i]
                    if entireArraySerializable or self:_ShouldSerialize(tab, i, v, opts, filter) then
                        self:_WriteObject(v, opts)
                    else
                        -- Since the keys are being omitted, write a `nil` entry
                        -- for any values that shouldn't be serialized.
                        self:_WriteObject(nil, opts)
                    end
                end

                local mapCountWritten = 0
                for k, v in pairs(tab) do
                    -- Exclude keys that have already been written via the previous loop.
                    local isArrayKey = type(k) == "number" and k >= 1 and k <= arrayCount and not IsFractional(k)
                    if not isArrayKey and (entireMapSerializable or self:_ShouldSerialize(tab, k, v, opts, filter)) then
                        self:_WriteObject(k, opts)
                        self:_WriteObject(v, opts)
                        mapCountWritten = mapCountWritten + 1
                    end
                end
                assert(mapCount == mapCountWritten)
            else
                -- The table has only dictionary keys, so we'll write them all.
                if mapCount < 16 then
                    -- Short counts can be embedded directly into the type byte.
                    -- DebugPrint("Serializing table, embedded count:", mapCount)
                    self:_WriteByte(embeddedCountShift * mapCount + embeddedIndexShift * self._EmbeddedIndex.TABLE + 2)
                else
                    -- DebugPrint("Serializing table:", mapCount)
                    local required = GetRequiredBytes(mapCount)
                    self:_WriteByte(readerIndexShift * tableIndices[required])
                    self:_WriteInt(mapCount, required)
                end

                for k, v in pairs(tab) do
                    if entireMapSerializable or self:_ShouldSerialize(tab, k, v, opts, filter) then
                        self:_WriteObject(k, opts)
                        self:_WriteObject(v, opts)
                    end
                end
            end
        end
    end,
}


--[[---------------------------------------------------------------------------
    API support.
--]]---------------------------------------------------------------------------

function LibSerialize:IsSerializableType(...)
    return self:_CanSerialize(canSerializeFnOptions, ...)
end

function LibSerialize:SerializeEx(opts, ...)
    self:_ClearReferences()
    local WriteString, FlushWriter = CreateWriter()

    self._writeString = WriteString
    self:_WriteByte(MINOR)

    -- Create a combined options table, starting with the defaults
    -- and then overwriting any user-supplied keys.
    local combinedOpts = {}
    for k, v in pairs(defaultOptions) do
        combinedOpts[k] = v
    end
    for k, v in pairs(opts) do
        combinedOpts[k] = v
    end

    for i = 1, select("#", ...) do
        local input = select(i, ...)
        if not self:_WriteObject(input, combinedOpts) then
            -- An unserializable object was passed as an argument.
            -- Write nil into its slot so that we deserialize a
            -- consistent number of objects from the resulting string.
            self:_WriteObject(nil, combinedOpts)
        end
    end

    self:_ClearReferences()
    return FlushWriter()
end

function LibSerialize:Serialize(...)
    return self:SerializeEx(defaultOptions, ...)
end

function LibSerialize:DeserializeValue(input)
    self:_ClearReferences()
    local ReadBytes, ReaderBytesLeft = CreateReader(input)

    self._readBytes = ReadBytes

    -- Since there's only one compression version currently,
    -- no extra work needs to be done to decode the data.
    local version = self:_ReadByte()
    assert(version == MINOR)

    -- Since the objects we read may be nil, we need to explicitly
    -- track the number of results and assign by index so that we
    -- can call unpack() successfully at the end.
    local output = {}
    local outputSize = 0

    while ReaderBytesLeft() > 0 do
        outputSize = outputSize + 1
        output[outputSize] = self:_ReadObject()
    end

    self:_ClearReferences()

    if ReaderBytesLeft() < 0 then
        error("Reader went past end of input")
    end

    return unpack(output, 1, outputSize)
end

function LibSerialize:_PostDeserialize(...)
    self:_ClearReferences()
    return ...
end

function LibSerialize:Deserialize(input)
    return self:_PostDeserialize(pcall(self.DeserializeValue, self, input))
end

return LibSerialize


-- ========================================
-- File: WeakAuras/Libs/LibSharedMedia-3.0/LibSharedMedia-3.0.lua
-- ========================================

--@curseforge-project-slug: libsharedmedia-3-0@
--[[
Name: LibSharedMedia-3.0
Revision: $Revision: 151 $
Author: Elkano (elkano@gmx.de)
Inspired By: SurfaceLib by Haste/Otravi (troeks@gmail.com)
Website: http://www.wowace.com/projects/libsharedmedia-3-0/
Description: Shared handling of media data (fonts, sounds, textures, ...) between addons.
Dependencies: LibStub, CallbackHandler-1.0
License: LGPL v2.1
]]

local MAJOR, MINOR = "LibSharedMedia-3.0", 8020003 -- 8.2.0 v3 / increase manually on changes
local lib = LibStub:NewLibrary(MAJOR, MINOR)

if not lib then return end

local _G = getfenv(0)

local pairs		= _G.pairs
local type		= _G.type

local band			= _G.bit.band
local table_sort	= _G.table.sort

local locale = GetLocale()
local locale_is_western
local LOCALE_MASK
lib.LOCALE_BIT_koKR		= 1
lib.LOCALE_BIT_ruRU		= 2
lib.LOCALE_BIT_zhCN		= 4
lib.LOCALE_BIT_zhTW		= 8
lib.LOCALE_BIT_western	= 128

local CallbackHandler = LibStub:GetLibrary("CallbackHandler-1.0")

lib.callbacks		= lib.callbacks			or CallbackHandler:New(lib)

lib.DefaultMedia	= lib.DefaultMedia		or {}
lib.MediaList		= lib.MediaList			or {}
lib.MediaTable		= lib.MediaTable		or {}
lib.MediaType		= lib.MediaType			or {}
lib.OverrideMedia	= lib.OverrideMedia		or {}

local defaultMedia = lib.DefaultMedia
local mediaList = lib.MediaList
local mediaTable = lib.MediaTable
local overrideMedia = lib.OverrideMedia


-- create mediatype constants
lib.MediaType.BACKGROUND	= "background"			-- background textures
lib.MediaType.BORDER		= "border"				-- border textures
lib.MediaType.FONT			= "font"				-- fonts
lib.MediaType.STATUSBAR		= "statusbar"			-- statusbar textures
lib.MediaType.SOUND			= "sound"				-- sound files

-- populate lib with default Blizzard data
-- BACKGROUND
if not lib.MediaTable.background then lib.MediaTable.background = {} end
lib.MediaTable.background["None"]									= [[]]
lib.MediaTable.background["Blizzard Collections Background"]		= [[Interface\Collections\CollectionsBackgroundTile]]
lib.MediaTable.background["Blizzard Dialog Background"]				= [[Interface\DialogFrame\UI-DialogBox-Background]]
lib.MediaTable.background["Blizzard Dialog Background Dark"]		= [[Interface\DialogFrame\UI-DialogBox-Background-Dark]]
lib.MediaTable.background["Blizzard Dialog Background Gold"]		= [[Interface\DialogFrame\UI-DialogBox-Gold-Background]]
lib.MediaTable.background["Blizzard Garrison Background"]			= [[Interface\Garrison\GarrisonUIBackground]]
lib.MediaTable.background["Blizzard Garrison Background 2"]			= [[Interface\Garrison\GarrisonUIBackground2]]
lib.MediaTable.background["Blizzard Garrison Background 3"]			= [[Interface\Garrison\GarrisonMissionUIInfoBoxBackgroundTile]]
lib.MediaTable.background["Blizzard Low Health"]					= [[Interface\FullScreenTextures\LowHealth]]
lib.MediaTable.background["Blizzard Marble"]						= [[Interface\FrameGeneral\UI-Background-Marble]]
lib.MediaTable.background["Blizzard Out of Control"]				= [[Interface\FullScreenTextures\OutOfControl]]
lib.MediaTable.background["Blizzard Parchment"]						= [[Interface\AchievementFrame\UI-Achievement-Parchment-Horizontal]]
lib.MediaTable.background["Blizzard Parchment 2"]					= [[Interface\AchievementFrame\UI-GuildAchievement-Parchment-Horizontal]]
lib.MediaTable.background["Blizzard Rock"]							= [[Interface\FrameGeneral\UI-Background-Rock]]
lib.MediaTable.background["Blizzard Tabard Background"]				= [[Interface\TabardFrame\TabardFrameBackground]]
lib.MediaTable.background["Blizzard Tooltip"]						= [[Interface\Tooltips\UI-Tooltip-Background]]
lib.MediaTable.background["Solid"]									= [[Interface\Buttons\WHITE8X8]]
lib.DefaultMedia.background = "None"

-- BORDER
if not lib.MediaTable.border then lib.MediaTable.border = {} end
lib.MediaTable.border["None"]								= [[]]
lib.MediaTable.border["Blizzard Achievement Wood"]			= [[Interface\AchievementFrame\UI-Achievement-WoodBorder]]
lib.MediaTable.border["Blizzard Chat Bubble"]				= [[Interface\Tooltips\ChatBubble-Backdrop]]
lib.MediaTable.border["Blizzard Dialog"]					= [[Interface\DialogFrame\UI-DialogBox-Border]]
lib.MediaTable.border["Blizzard Dialog Gold"]				= [[Interface\DialogFrame\UI-DialogBox-Gold-Border]]
lib.MediaTable.border["Blizzard Party"]						= [[Interface\CHARACTERFRAME\UI-Party-Border]]
lib.MediaTable.border["Blizzard Tooltip"]					= [[Interface\Tooltips\UI-Tooltip-Border]]
lib.DefaultMedia.border = "None"

-- FONT
if not lib.MediaTable.font then lib.MediaTable.font = {} end
local SML_MT_font = lib.MediaTable.font
--[[
All font files are currently in all clients, the following table depicts which font supports which charset as of 5.0.4
Fonts were checked using langcover.pl from DejaVu fonts (http://sourceforge.net/projects/dejavu/) and FontForge (http://fontforge.org/)
latin means check for: de, en, es, fr, it, pt

file				name							latin	koKR	ruRU	zhCN	zhTW
2002.ttf			2002							X		X		X		-		-
2002B.ttf			2002 Bold						X		X		X		-		-
ARHei.ttf			AR CrystalzcuheiGBK Demibold	X		-		X		X		X
ARIALN.TTF			Arial Narrow					X		-		X		-		-
ARKai_C.ttf			AR ZhongkaiGBK Medium (Combat)	X		-		X		X		X
ARKai_T.ttf			AR ZhongkaiGBK Medium			X		-		X		X		X
bHEI00M.ttf			AR Heiti2 Medium B5				-		-		-		-		X
bHEI01B.ttf			AR Heiti2 Bold B5				-		-		-		-		X
bKAI00M.ttf			AR Kaiti Medium B5				-		-		-		-		X
bLEI00D.ttf			AR Leisu Demi B5				-		-		-		-		X
FRIZQT__.TTF		Friz Quadrata TT				X		-		-		-		-
FRIZQT___CYR.TTF	FrizQuadrataCTT					x		-		X		-		-
K_Damage.TTF		YDIWingsM						-		X		X		-		-
K_Pagetext.TTF		MoK								X		X		X		-		-
MORPHEUS.TTF		Morpheus						X		-		-		-		-
MORPHEUS_CYR.TTF	Morpheus						X		-		X		-		-
NIM_____.ttf		Nimrod MT						X		-		X		-		-
SKURRI.TTF			Skurri							X		-		-		-		-
SKURRI_CYR.TTF		Skurri							X		-		X		-		-

WARNING: Although FRIZQT___CYR is available on western clients, it doesn't support special European characters e.g. , , 
Due to this, we cannot use it as a replacement for FRIZQT__.TTF
]]

if locale == "koKR" then
	LOCALE_MASK = lib.LOCALE_BIT_koKR
--
	SML_MT_font[" "]		= [[Fonts\2002B.TTF]]
	SML_MT_font[" "]		= [[Fonts\2002.TTF]]
	SML_MT_font[" "]		= [[Fonts\K_Damage.TTF]]
	SML_MT_font[" "]		= [[Fonts\K_Pagetext.TTF]]
--
	lib.DefaultMedia["font"] = " " -- someone from koKR please adjust if needed
--
elseif locale == "zhCN" then
	LOCALE_MASK = lib.LOCALE_BIT_zhCN
--
	SML_MT_font[""]		= [[Fonts\ARKai_C.ttf]]
	SML_MT_font[""]			= [[Fonts\ARKai_T.ttf]]
	SML_MT_font[""]			= [[Fonts\ARHei.ttf]]
--
	lib.DefaultMedia["font"] = "" -- someone from zhCN please adjust if needed
--
elseif locale == "zhTW" then
	LOCALE_MASK = lib.LOCALE_BIT_zhTW
--
	SML_MT_font[""]		= [[Fonts\bHEI00M.ttf]]
	SML_MT_font[""]			= [[Fonts\bHEI01B.ttf]]
	SML_MT_font[""]		= [[Fonts\bKAI00M.ttf]]
	SML_MT_font[""]			= [[Fonts\bLEI00D.ttf]]
--
	lib.DefaultMedia["font"] = "" -- someone from zhTW please adjust if needed

elseif locale == "ruRU" then
	LOCALE_MASK = lib.LOCALE_BIT_ruRU
--
	SML_MT_font["2002"]								= [[Fonts\2002.TTF]]
	SML_MT_font["2002 Bold"]						= [[Fonts\2002B.TTF]]
	SML_MT_font["AR CrystalzcuheiGBK Demibold"]		= [[Fonts\ARHei.TTF]]
	SML_MT_font["AR ZhongkaiGBK Medium (Combat)"]	= [[Fonts\ARKai_C.TTF]]
	SML_MT_font["AR ZhongkaiGBK Medium"]			= [[Fonts\ARKai_T.TTF]]
	SML_MT_font["Arial Narrow"]						= [[Fonts\ARIALN.TTF]]
	SML_MT_font["Friz Quadrata TT"]					= [[Fonts\FRIZQT___CYR.TTF]]
	SML_MT_font["MoK"]								= [[Fonts\K_Pagetext.TTF]]
	SML_MT_font["Morpheus"]							= [[Fonts\MORPHEUS_CYR.TTF]]
	SML_MT_font["Nimrod MT"]						= [[Fonts\NIM_____.ttf]]
	SML_MT_font["Skurri"]							= [[Fonts\SKURRI_CYR.TTF]]
--
	lib.DefaultMedia.font = "Friz Quadrata TT"
--
else
	LOCALE_MASK = lib.LOCALE_BIT_western
	locale_is_western = true
--
	SML_MT_font["2002"]								= [[Fonts\2002.TTF]]
	SML_MT_font["2002 Bold"]						= [[Fonts\2002B.TTF]]
	SML_MT_font["AR CrystalzcuheiGBK Demibold"]		= [[Fonts\ARHei.TTF]]
	SML_MT_font["AR ZhongkaiGBK Medium (Combat)"]	= [[Fonts\ARKai_C.TTF]]
	SML_MT_font["AR ZhongkaiGBK Medium"]			= [[Fonts\ARKai_T.TTF]]
	SML_MT_font["Arial Narrow"]						= [[Fonts\ARIALN.TTF]]
	SML_MT_font["Friz Quadrata TT"]					= [[Fonts\FRIZQT__.TTF]]
	SML_MT_font["MoK"]								= [[Fonts\K_Pagetext.TTF]]
	SML_MT_font["Morpheus"]							= [[Fonts\MORPHEUS_CYR.TTF]]
	SML_MT_font["Nimrod MT"]						= [[Fonts\NIM_____.ttf]]
	SML_MT_font["Skurri"]							= [[Fonts\SKURRI_CYR.TTF]]
--
	lib.DefaultMedia.font = "Friz Quadrata TT"
--
end

-- STATUSBAR
if not lib.MediaTable.statusbar then lib.MediaTable.statusbar = {} end
lib.MediaTable.statusbar["Blizzard"]						= [[Interface\TargetingFrame\UI-StatusBar]]
lib.MediaTable.statusbar["Blizzard Character Skills Bar"]	= [[Interface\PaperDollInfoFrame\UI-Character-Skills-Bar]]
lib.MediaTable.statusbar["Blizzard Raid Bar"]				= [[Interface\RaidFrame\Raid-Bar-Hp-Fill]]
lib.MediaTable.statusbar["Solid"]							= [[Interface\Buttons\WHITE8X8]]
lib.DefaultMedia.statusbar = "Blizzard"

-- SOUND
if not lib.MediaTable.sound then lib.MediaTable.sound = {} end
lib.MediaTable.sound["None"] = 1 -- Relies on the fact that PlaySoundFile doesn't error on this value
lib.DefaultMedia.sound = "None"

local function rebuildMediaList(mediatype)
	local mtable = mediaTable[mediatype]
	if not mtable then return end
	if not mediaList[mediatype] then mediaList[mediatype] = {} end
	local mlist = mediaList[mediatype]
	-- list can only get larger, so simply overwrite it
	local i = 0
	for k in pairs(mtable) do
		i = i + 1
		mlist[i] = k
	end
	table_sort(mlist)
end

function lib:Register(mediatype, key, data, langmask)
	if type(mediatype) ~= "string" then
		error(MAJOR..":Register(mediatype, key, data, langmask) - mediatype must be string, got "..type(mediatype))
	end
	if type(key) ~= "string" then
		error(MAJOR..":Register(mediatype, key, data, langmask) - key must be string, got "..type(key))
	end
	mediatype = mediatype:lower()
	if mediatype == lib.MediaType.FONT and ((langmask and band(langmask, LOCALE_MASK) == 0) or not (langmask or locale_is_western)) then
		-- ignore fonts that aren't flagged as supporting local glyphs on non-western clients
		return false
	end
	if type(data) == "string" and (mediatype == lib.MediaType.BACKGROUND or mediatype == lib.MediaType.BORDER or mediatype == lib.MediaType.STATUSBAR or mediatype == lib.MediaType.SOUND) then
		local path = data:lower()
		if not path:find("^interface") then
			-- files accessed via path only allowed from interface folder
			return false
		end
		if mediatype == lib.MediaType.SOUND and not (path:find(".ogg", nil, true) or path:find(".mp3", nil, true)) then
			-- Only ogg and mp3 are valid sounds.
			return false
		end
	end
	if not mediaTable[mediatype] then mediaTable[mediatype] = {} end
	local mtable = mediaTable[mediatype]
	if mtable[key] then return false end

	mtable[key] = data
	rebuildMediaList(mediatype)
	self.callbacks:Fire("LibSharedMedia_Registered", mediatype, key)
	return true
end

function lib:Fetch(mediatype, key, noDefault)
	local mtt = mediaTable[mediatype]
	local overridekey = overrideMedia[mediatype]
	local result = mtt and ((overridekey and mtt[overridekey] or mtt[key]) or (not noDefault and defaultMedia[mediatype] and mtt[defaultMedia[mediatype]])) or nil
	return result ~= "" and result or nil
end

function lib:IsValid(mediatype, key)
	return mediaTable[mediatype] and (not key or mediaTable[mediatype][key]) and true or false
end

function lib:HashTable(mediatype)
	return mediaTable[mediatype]
end

function lib:List(mediatype)
	if not mediaTable[mediatype] then
		return nil
	end
	if not mediaList[mediatype] then
		rebuildMediaList(mediatype)
	end
	return mediaList[mediatype]
end

function lib:GetGlobal(mediatype)
	return overrideMedia[mediatype]
end

function lib:SetGlobal(mediatype, key)
	if not mediaTable[mediatype] then
		return false
	end
	overrideMedia[mediatype] = (key and mediaTable[mediatype][key]) and key or nil
	self.callbacks:Fire("LibSharedMedia_SetGlobal", mediatype, overrideMedia[mediatype])
	return true
end

function lib:GetDefault(mediatype)
	return defaultMedia[mediatype]
end

function lib:SetDefault(mediatype, key)
	if mediaTable[mediatype] and mediaTable[mediatype][key] and not defaultMedia[mediatype] then
		defaultMedia[mediatype] = key
		return true
	else
		return false
	end
end


-- ========================================
-- File: WeakAuras/Libs/LibSpecialization/LibSpecialization.lua
-- ========================================

--@curseforge-project-slug: libspecialization@
local wowID = WOW_PROJECT_ID
local cataWowID = 14
local mistsWowID = 19
if wowID ~= 1 and wowID ~= cataWowID and wowID ~= mistsWowID then return end -- Retail, Cata, Mists

local LS, oldminor = LibStub:NewLibrary("LibSpecialization", 23)
if not LS then return end -- No upgrade needed

LS.callbackMapGroup = LS.callbackMapGroup or {}
LS.callbackMapGuild = LS.callbackMapGuild or {}
LS.callbackMapPlayerSpecChange = LS.callbackMapPlayerSpecChange or {}
LS.frame = LS.frame or CreateFrame("Frame")

-- Positions of roles
local positionTable = wowID == cataWowID and {
	-- Death Knight
	[398] = "MELEE", -- Blood (Tank)
	[399] = "MELEE", -- Frost (DPS)
	[400] = "MELEE", -- Unholy (DPS)
	-- Druid
	[752] = "RANGED", -- Balance (DPS Owl)
	[750] = "MELEE", -- Feral Combat (DPS Cat AND Tank Bear)
	[748] = "RANGED", -- Restoration (Heal)
	-- Hunter
	[811] = "RANGED", -- Beast Mastery
	[807] = "RANGED", -- Marksmanship
	[809] = "RANGED", -- Survival
	-- Mage
	[799] = "RANGED", -- Arcane
	[851] = "RANGED", -- Fire
	[823] = "RANGED", -- Frost
	-- Paladin
	[831] = "RANGED", -- Holy (Heal)
	[839] = "MELEE", -- Protection (Tank)
	[855] = "MELEE", -- Retribution (DPS)
	-- Priest
	[760] = "RANGED", -- Discipline (Heal)
	[813] = "RANGED", -- Holy (Heal)
	[795] = "RANGED", -- Shadow (DPS)
	-- Rogue
	[182] = "MELEE", -- Assassination
	[181] = "MELEE", -- Combat
	[183] = "MELEE", -- Subtlety
	-- Shaman
	[261] = "RANGED", -- Elemental (DPS)
	[263] = "MELEE", -- Enhancement (DPS)
	[262] = "RANGED", -- Restoration (Heal)
	-- Warlock
	[871] = "RANGED", -- Affliction
	[867] = "RANGED", -- Demonology
	[865] = "RANGED", -- Destruction
	-- Warrior
	[746] = "MELEE", -- Arms (DPS)
	[815] = "MELEE", -- Fury (DPS)
	[845] = "MELEE", -- Protection (Tank)
} or {
	-- Death Knight
	[250] = "MELEE", -- Blood (Tank)
	[251] = "MELEE", -- Frost (DPS)
	[252] = "MELEE", -- Unholy (DPS)
	-- Demon Hunter
	[577] = "MELEE", -- Havoc (DPS)
	[581] = "MELEE", -- Vengeance (Tank)
	-- Druid
	[102] = "RANGED", -- Balance (DPS Owl)
	[103] = "MELEE", -- Feral (DPS Cat)
	[104] = "MELEE", -- Guardian (Tank Bear)
	[105] = "RANGED", -- Restoration (Heal)
	-- Evoker
	[1467] = "RANGED", -- Devastation (DPS)
	[1468] = "RANGED", -- Preservation (Heal)
	[1473] = "RANGED", -- Augmentation (DPS)
	-- Hunter
	[253] = "RANGED", -- Beast Mastery
	[254] = "RANGED", -- Marksmanship
	[255] = wowID == mistsWowID and "RANGED" or "MELEE", -- Survival [Ranged on Mists, Melee on Retail]
	-- Mage
	[62] = "RANGED", -- Arcane
	[63] = "RANGED", -- Fire
	[64] = "RANGED", -- Frost
	-- Monk
	[268] = "MELEE", -- Brewmaster (Tank)
	[269] = "MELEE", -- Windwalker (DPS)
	[270] = "MELEE", -- Mistweaver (Heal)
	-- Paladin
	[65] = wowID == mistsWowID and "RANGED" or "MELEE", -- Holy (Heal) [Ranged on Mists, Melee on Retail]
	[66] = "MELEE", -- Protection (Tank)
	[70] = "MELEE", -- Retribution (DPS)
	-- Priest
	[256] = "RANGED", -- Discipline (Heal)
	[257] = "RANGED", -- Holy (Heal)
	[258] = "RANGED", -- Shadow (DPS)
	-- Rogue
	[259] = "MELEE", -- Assassination
	[260] = "MELEE", -- Outlaw [Retail] / Combat [Mists]
	[261] = "MELEE", -- Subtlety
	-- Shaman
	[262] = "RANGED", -- Elemental (DPS)
	[263] = "MELEE", -- Enhancement (DPS)
	[264] = "RANGED", -- Restoration (Heal)
	-- Warlock
	[265] = "RANGED", -- Affliction
	[266] = "RANGED", -- Demonology
	[267] = "RANGED", -- Destruction
	-- Warrior
	[71] = "MELEE", -- Arms (DPS)
	[72] = "MELEE", -- Fury (DPS)
	[73] = "MELEE", -- Protection (Tank)
}
-- Player roles
local roleTable = wowID == cataWowID and {
	-- Death Knight
	[398] = "TANK", -- Blood (Tank)
	[399] = "DAMAGER", -- Frost (DPS)
	[400] = "DAMAGER", -- Unholy (DPS)
	-- Druid
	[752] = "DAMAGER", -- Balance (DPS Owl)
	[750] = "TANK", -- Feral Combat (DPS Cat AND Tank Bear) Oh noooooooooooooooooooooooooooooo, talent checks incoming
	[748] = "HEALER", -- Restoration (Heal)
	-- Hunter
	[811] = "DAMAGER", -- Beast Mastery
	[807] = "DAMAGER", -- Marksmanship
	[809] = "DAMAGER", -- Survival
	-- Mage
	[799] = "DAMAGER", -- Arcane
	[851] = "DAMAGER", -- Fire
	[823] = "DAMAGER", -- Frost
	-- Paladin
	[831] = "HEALER", -- Holy (Heal)
	[839] = "TANK", -- Protection (Tank)
	[855] = "DAMAGER", -- Retribution (DPS)
	-- Priest
	[760] = "HEALER", -- Discipline (Heal)
	[813] = "HEALER", -- Holy (Heal)
	[795] = "DAMAGER", -- Shadow (DPS)
	-- Rogue
	[182] = "DAMAGER", -- Assassination
	[181] = "DAMAGER", -- Combat
	[183] = "DAMAGER", -- Subtlety
	-- Shaman
	[261] = "DAMAGER", -- Elemental (DPS)
	[263] = "DAMAGER", -- Enhancement (DPS)
	[262] = "HEALER", -- Restoration (Heal)
	-- Warlock
	[871] = "DAMAGER", -- Affliction
	[867] = "DAMAGER", -- Demonology
	[865] = "DAMAGER", -- Destruction
	-- Warrior
	[746] = "DAMAGER", -- Arms (DPS)
	[815] = "DAMAGER", -- Fury (DPS)
	[845] = "TANK", -- Protection (Tank)
} or {
	-- Death Knight
	[250] = "TANK", -- Blood (Tank)
	[251] = "DAMAGER", -- Frost (DPS)
	[252] = "DAMAGER", -- Unholy (DPS)
	-- Demon Hunter
	[577] = "DAMAGER", -- Havoc (DPS)
	[581] = "TANK", -- Vengeance (Tank)
	-- Druid
	[102] = "DAMAGER", -- Balance (DPS Owl)
	[103] = "DAMAGER", -- Feral (DPS Cat)
	[104] = "TANK", -- Guardian (Tank Bear)
	[105] = "HEALER", -- Restoration (Heal)
	-- Evoker
	[1467] = "DAMAGER", -- Devastation (DPS)
	[1468] = "HEALER", -- Preservation (Heal)
	[1473] = "DAMAGER", -- Augmentation (DPS)
	-- Hunter
	[253] = "DAMAGER", -- Beast Mastery
	[254] = "DAMAGER", -- Marksmanship
	[255] = "DAMAGER", -- Survival
	-- Mage
	[62] = "DAMAGER", -- Arcane
	[63] = "DAMAGER", -- Fire
	[64] = "DAMAGER", -- Frost
	-- Monk
	[268] = "TANK", -- Brewmaster (Tank)
	[269] = "DAMAGER", -- Windwalker (DPS)
	[270] = "HEALER", -- Mistweaver (Heal)
	-- Paladin
	[65] = "HEALER", -- Holy (Heal)
	[66] = "TANK", -- Protection (Tank)
	[70] = "DAMAGER", -- Retribution (DPS)
	-- Priest
	[256] = "HEALER", -- Discipline (Heal)
	[257] = "HEALER", -- Holy (Heal)
	[258] = "DAMAGER", -- Shadow (DPS)
	-- Rogue
	[259] = "DAMAGER", -- Assassination
	[260] = "DAMAGER", -- Outlaw [Retail] / Combat [Mists]
	[261] = "DAMAGER", -- Subtlety
	-- Shaman
	[262] = "DAMAGER", -- Elemental (DPS)
	[263] = "DAMAGER", -- Enhancement (DPS)
	[264] = "HEALER", -- Restoration (Heal)
	-- Warlock
	[265] = "DAMAGER", -- Affliction
	[266] = "DAMAGER", -- Demonology
	[267] = "DAMAGER", -- Destruction
	-- Warrior
	[71] = "DAMAGER", -- Arms (DPS)
	[72] = "DAMAGER", -- Fury (DPS)
	[73] = "TANK", -- Protection (Tank)
}
-- Starter specs
local starterSpecs = {
	[1444] = true, -- Shaman
	[1446] = true, -- Warrior
	[1447] = true, -- Druid
	[1448] = true, -- Hunter
	[1449] = true, -- Mage
	[1450] = true, -- Monk
	[1451] = true, -- Paladin
	[1452] = true, -- Priest
	[1453] = true, -- Rogue
	[1454] = true, -- Warlock
	[1455] = true, -- Death Knight
	[1456] = true, -- Demon Hunter
	[1465] = true, -- Evoker
}

local callbackMapGroup = LS.callbackMapGroup
local callbackMapGuild = LS.callbackMapGuild

local type, error, format = type, error, string.format
local geterrorhandler, GetTime = geterrorhandler, GetTime

do
	local result = C_ChatInfo.RegisterAddonMessagePrefix("LibSpec")
	-- 0=success, 1=duplicate, 2=invalid, 3=toomany
	if type(result) == "number" and result > 1 then
		error("LibSpecialization: Failed to register the addon prefix.")
	end
end

-- Handle groups (comms are automatic)
function LS.RegisterGroup(addon, func)
	if type(addon) ~= "table" or addon == LS then
		error("LibSpecialization: The function lib.RegisterGroup expects your own addon object as the first arg.")
	end

	local t = type(func)
	if t == "function" then
		callbackMapGroup[addon] = func
	else
		error("LibSpecialization: The function lib.RegisterGroup expects your own function as the second arg.")
	end
end

function LS.UnregisterGroup(addon)
	if type(addon) ~= "table" or addon == LS then
		error("LibSpecialization: The function lib.UnregisterGroup expects your own addon object.")
	end
	callbackMapGroup[addon] = nil
end

-- Handle guilds (comms are on manual request)
function LS.RegisterGuild(addon, func)
	if type(addon) ~= "table" or addon == LS then
		error("LibSpecialization: The function lib.RegisterGuild expects your own addon object as the first arg.")
	end

	local t = type(func)
	if t == "function" then
		callbackMapGuild[addon] = func
	else
		error("LibSpecialization: The function lib.RegisterGuild expects your own function as the second arg.")
	end
end

function LS.UnregisterGuild(addon)
	if type(addon) ~= "table" or addon == LS then
		error("LibSpecialization: The function lib.UnregisterGuild expects your own addon object.")
	end
	callbackMapGuild[addon] = nil
end

function LS.RegisterPlayerSpecChange(addon, func)
	if type(addon) ~= "table" or addon == LS then
		error("LibSpecialization: The function lib.RegisterPlayerSpecChange expects your own addon object as the first arg.")
	end

	local t = type(func)
	if t == "function" then
		LS.callbackMapPlayerSpecChange[addon] = func
	else
		error("LibSpecialization: The function lib.RegisterPlayerSpecChange expects your own function as the second arg.")
	end
end

function LS.UnregisterPlayerSpecChange(addon)
	if type(addon) ~= "table" or addon == LS then
		error("LibSpecialization: The function lib.UnregisterPlayerSpecChange expects your own addon object.")
	end
	LS.callbackMapPlayerSpecChange[addon] = nil
end

local GetInfo
if wowID == cataWowID then
	function GetInfo()
		local specIndex = GetPrimaryTalentTree()
		if specIndex then
			local specId = GetTalentTabInfo(specIndex)
			if type(specId) == "number" and specId > 0 then
				local position = positionTable[specId]
				local role = roleTable[specId]
				if position and role then
					if specId == 750 and not IsPlayerSpell(57880) then -- Cataclysm Feral Druids, if you don't have 2 points in 'Natural Reaction' we assume you're a cat
						return specId, "DAMAGER", position
					end
					return specId, role, position
				else
					geterrorhandler()(format("LibSpecialization: Unknown specId %q", specId))
				end
			end
		end
	end
elseif wowID == mistsWowID then
	local GetSpecialization, GetSpecializationInfo = C_SpecializationInfo.GetSpecialization, C_SpecializationInfo.GetSpecializationInfo
	local GetTalentInfo, GetGlyphSocketInfo = C_SpecializationInfo.GetTalentInfo, GetGlyphSocketInfo
	local SerializeJSON = C_EncodingUtil.SerializeJSON
	function GetInfo()
		local spec = GetSpecialization()
		if type(spec) == "number" and spec > 0 then
			local specId = GetSpecializationInfo(spec)

			if type(specId) == "number" and specId > 0 then
				local position = positionTable[specId]
				local role = roleTable[specId]
				if position and role then
					local storageTable = {
						talents = {0, 0, 0, 0, 0, 0}, -- 6 tiers/rows
						glyphs = {0, 0, 0, 0, 0, 0}, -- 6 glyphs
					}

					-- Fill in the talents
					for tier = 1, 6 do -- 6 rows
						for column = 1, 3 do -- 3 columns
							local talentInfo = GetTalentInfo({tier=tier, column=column})
							if talentInfo.known and type(talentInfo.talentID) == "number" then
								storageTable.talents[tier] = talentInfo.talentID
								break
							end
						end
					end

					-- Fill in the glyphs
					for glyphSlot = 1, 6 do -- There are 6 glyphs in total, 3 major and 3 minor
						local _, _, _, _, _, glyphID = GetGlyphSocketInfo(glyphSlot)
						if type(glyphID) == "number" then
							storageTable.glyphs[glyphSlot] = glyphID
						end
					end

					local talentsAndGlyphsJSON = SerializeJSON(storageTable)
					return specId, role, position, talentsAndGlyphsJSON
				elseif not starterSpecs[specId] then
					geterrorhandler()(format("LibSpecialization: Unknown specId %q", specId))
				end
			end
		end
	end
else
	local C_Traits_GenerateImportString = C_Traits.GenerateImportString
	local C_ClassTalents_GetActiveConfigID = C_ClassTalents.GetActiveConfigID
	local GetSpecialization, GetSpecializationInfo = C_SpecializationInfo.GetSpecialization, C_SpecializationInfo.GetSpecializationInfo
	function GetInfo()
		local spec = GetSpecialization()
		if type(spec) == "number" and spec > 0 then
			local specId = GetSpecializationInfo(spec)

			if type(specId) == "number" and specId > 0 then
				local position = positionTable[specId]
				local role = roleTable[specId]
				if position and role then
					local activeConfigID = C_ClassTalents_GetActiveConfigID()
					if activeConfigID then
						local talentString = C_Traits_GenerateImportString(activeConfigID)
						return specId, role, position, talentString
					end
					return specId, role, position
				elseif not starterSpecs[specId] then
					geterrorhandler()(format("LibSpecialization: Unknown specId %q", specId))
				end
			end
		end
	end
end
LS.MySpecialization = GetInfo

local throttleTimer = 3 -- Seconds
local pName = UnitNameUnmodified("player")
local SendAddonMessage = C_ChatInfo.SendAddonMessage
local IsInGroup = IsInGroup
local CTimerNewTimer = C_Timer.NewTimer
local next, securecallfunction = next, securecallfunction
do
	local currentSpecId, currentTalentString, currentRole = 0, nil, nil

	local PrepareForInstance
	do
		local timerInstance = nil
		local function SendToInstance()
			timerInstance = nil
			if IsInGroup(2) then
				if currentRole then -- Cataclysm Feral Druids
					local result = SendAddonMessage("LibSpec", format("%d,,%s", currentSpecId, currentRole), "INSTANCE_CHAT")
					if result == 9 then
						timerInstance = CTimerNewTimer(throttleTimer, SendToInstance)
					end
				else
					local result = SendAddonMessage("LibSpec", format("%d,%s", currentSpecId, currentTalentString or ""), "INSTANCE_CHAT")
					if result == 9 then
						timerInstance = CTimerNewTimer(throttleTimer, SendToInstance)
					end
				end
			end
		end
		function PrepareForInstance()
			local specId, role, _, talentString = GetInfo()
			if specId then
				currentSpecId = specId
				currentTalentString = talentString
				currentRole = specId == 750 and role or nil -- Cataclysm Feral Druids
				if not timerInstance then
					timerInstance = CTimerNewTimer(throttleTimer, SendToInstance)
				end
			end
		end
	end

	local PrepareForGroup
	do
		local timerGroup = nil
		local function SendToGroup()
			timerGroup = nil
			if IsInGroup(1) then
				if currentRole then -- Cataclysm Feral Druids
					local result = SendAddonMessage("LibSpec", format("%d,,%s", currentSpecId, currentRole), "RAID") -- RAID auto downgrades to PARTY as needed
					if result == 9 then
						timerGroup = CTimerNewTimer(throttleTimer, SendToGroup)
					end
				else
					local result = SendAddonMessage("LibSpec", format("%d,%s", currentSpecId, currentTalentString or ""), "RAID") -- RAID auto downgrades to PARTY as needed
					if result == 9 then
						timerGroup = CTimerNewTimer(throttleTimer, SendToGroup)
					end
				end
			end
		end
		function PrepareForGroup()
			local specId, role, _, talentString = GetInfo()
			if specId then
				currentSpecId = specId
				currentTalentString = talentString
				currentRole = specId == 750 and role or nil -- Cataclysm Feral Druids
				if not timerGroup then
					timerGroup = CTimerNewTimer(throttleTimer, SendToGroup)
				end
			end
		end
	end

	local PrepareForGuild
	do
		local guildTimer = nil
		local prev = 0
		local function SendToGuild()
			if guildTimer then
				guildTimer:Cancel()
				guildTimer = nil
			end
			if IsInGuild() then
				if currentRole then -- Cataclysm Feral Druids
					local result = SendAddonMessage("LibSpec", format("%d,,%s", currentSpecId, currentRole), "GUILD")
					if result == 9 then
						guildTimer = CTimerNewTimer(throttleTimer, SendToGuild)
					end
				else
					local result = SendAddonMessage("LibSpec", format("%d,%s", currentSpecId, currentTalentString or ""), "GUILD")
					if result == 9 then
						guildTimer = CTimerNewTimer(throttleTimer, SendToGuild)
					end
				end
			end
		end
		function PrepareForGuild()
			local specId, role, _, talentString = GetInfo()
			if specId then
				currentSpecId = specId
				currentTalentString = talentString
				currentRole = specId == 750 and role or nil -- Cataclysm Feral Druids
				if not guildTimer then
					local t = GetTime()
					if t-prev > throttleTimer then
						prev = t
						SendToGuild()
					else
						guildTimer = CTimerNewTimer(throttleTimer-(t-prev), SendToGuild)
					end
				end
			end
		end
	end

	local approved = {
		RAID = callbackMapGroup,
		PARTY = callbackMapGroup,
		INSTANCE_CHAT = callbackMapGroup,
		GUILD = callbackMapGuild,
	}
	local tonumber, strmatch = tonumber, string.match
	local Ambiguate = Ambiguate
	local C_ClassTalents_GetActiveConfigID = C_ClassTalents and C_ClassTalents.GetActiveConfigID
	LS.frame:SetScript("OnEvent", function(_, event, prefix, msg, channel, sender)
		if event == "CHAT_MSG_ADDON" then
			if prefix == "LibSpec" and approved[channel] then -- Only approved channels
				if msg == "R" then
					if channel == "GUILD" then
						PrepareForGuild()
					elseif channel == "INSTANCE_CHAT" then
						PrepareForInstance()
					else -- RAID/PARTY
						PrepareForGroup()
					end
					return
				end

				local spec, talentString = strmatch(msg, "(%d+),(.+)")
				local specId = tonumber(spec)
				local cataDruidRole
				if specId == 750 then -- Cataclysm Feral Druids
					talentString = nil
					cataDruidRole = strmatch(msg, "%d+,,(.+)")
				end

				local role, position = roleTable[specId], positionTable[specId]
				if role and position then
					if specId == 750 then -- Cataclysm Feral Druids
						if cataDruidRole == "TANK" or cataDruidRole == "DAMAGER" then
							role = cataDruidRole
						else
							return
						end
					end
					local playerName = Ambiguate(sender, "none")
					local talents = talentString and #talentString > 2 and talentString or nil
					for _,func in next, approved[channel] do
						securecallfunction(func, specId, role, position, playerName, talents)
					end
				end
			end
		elseif event == "GROUP_FORMED" then -- Join new group
			LS.RequestGroupSpecialization()
		elseif event == "PLAYER_TALENT_UPDATE" or event == "PLAYER_SPECIALIZATION_CHANGED" or ((event == "ACTIVE_COMBAT_CONFIG_CHANGED" or event == "TRAIT_CONFIG_UPDATED") and prefix == C_ClassTalents_GetActiveConfigID()) then
			for _,func in next, LS.callbackMapPlayerSpecChange do
				securecallfunction(func) -- Notify when the player has changed their spec
			end
			if IsInGroup() then
				if IsInGroup(2) then -- Instance group
					PrepareForInstance()
				end
				if IsInGroup(1) then -- Normal group
					PrepareForGroup()
				end
			else
				local specId, role, position, talentString = GetInfo()
				if specId then
					for _,func in next, callbackMapGroup do
						securecallfunction(func, specId, role, position, pName, talentString) -- This allows us to show our own spec info when not grouped
					end
				end
			end
		elseif event == "PLAYER_LOGIN" then
			LS.RequestGroupSpecialization()
		end
	end)
	LS.frame:RegisterEvent("CHAT_MSG_ADDON")
	LS.frame:RegisterEvent("GROUP_FORMED")
	if wowID == cataWowID then
		LS.frame:RegisterEvent("PLAYER_TALENT_UPDATE")
	elseif wowID == mistsWowID then
		LS.frame:RegisterUnitEvent("PLAYER_SPECIALIZATION_CHANGED", "player")
	else
		LS.frame:RegisterEvent("ACTIVE_COMBAT_CONFIG_CHANGED")
		LS.frame:RegisterEvent("TRAIT_CONFIG_UPDATED")
	end
	LS.frame:RegisterEvent("PLAYER_LOGIN")
end

do
	local prev = 0
	local timer = nil
	function LS.RequestGroupSpecialization() -- Group comms are automatic, you should never need to use this
		local specId, role, position, talentString = GetInfo()
		if specId then
			for _,func in next, callbackMapGroup do
				securecallfunction(func, specId, role, position, pName, talentString) -- This allows us to show our own spec info when not grouped
			end
		end

		if IsInGroup() then
			local t = GetTime()
			if t-prev > throttleTimer then
				if timer then
					timer:Cancel()
					timer = nil
				end
				prev = t
				if IsInGroup(2) then
					SendAddonMessage("LibSpec", "R", "INSTANCE_CHAT")
				end
				if IsInGroup(1) then
					SendAddonMessage("LibSpec", "R", "RAID")
				end
			elseif not timer then
				timer = CTimerNewTimer((throttleTimer+0.1)-(t-prev), LS.RequestGroupSpecialization)
			end
		end
	end
end

do
	local prev = 0
	local timer = nil
	function LS.RequestGuildSpecialization() -- Guild comms are manual, you will need to manually request data each time
		local specId, role, position, talentString = GetInfo()
		if specId then
			for _,func in next, callbackMapGuild do
				securecallfunction(func, specId, role, position, pName, talentString) -- This allows us to show our own spec info when not grouped
			end
		end

		if IsInGuild() then
			local t = GetTime()
			if t-prev > throttleTimer then
				if timer then
					timer:Cancel()
					timer = nil
				end
				prev = t
				SendAddonMessage("LibSpec", "R", "GUILD")
			elseif not timer then
				timer = CTimerNewTimer((throttleTimer+0.1)-(t-prev), LS.RequestGuildSpecialization)
			end
		end
	end
end

if IsLoggedIn() and not oldminor then -- Player is logged in and library isn't upgrading
	LS.RequestGroupSpecialization()
end


-- ========================================
-- File: WeakAuras/Libs/LibSpellRange-1.0/LibSpellRange-1.0.lua
-- ========================================

--- = Background =
-- Blizzard's IsSpellInRange API has always been very limited - you either must have the name of the spell, or its spell book ID. Checking directly by spellID is simply not possible.
-- Now, in Mists of Pandaria, Blizzard changed the way that many talents and specialization spells work - instead of giving you a new spell when leaned, they replace existing spells. These replacement spells do not work with Blizzard's IsSpellInRange function whatsoever; this limitation is what prompted the creation of this lib.
-- = Usage = 
-- **LibSpellRange-1.0** exposes an enhanced version of IsSpellInRange that:
-- * Allows ranged checking based on both spell name and spellID.
-- * Works correctly with replacement spells that will not work using Blizzard's IsSpellInRange method alone.
--
-- @class file
-- @name LibSpellRange-1.0.lua

local major = "SpellRange-1.0"
local minor = 24

assert(LibStub, format("%s requires LibStub.", major))

local Lib = LibStub:NewLibrary(major, minor)
if not Lib then return end

local tonumber = _G.tonumber
local strlower = _G.strlower
local wipe = _G.wipe
local type = _G.type
local select = _G.select

-- Handles updating spellsByName and spellsByID
if not Lib.updaterFrame then
	Lib.updaterFrame = CreateFrame("Frame")
end
Lib.updaterFrame:UnregisterAllEvents()

if C_Spell.IsSpellInRange then
	-- In TWW, IsSpellInRange supports both spell names and IDs
	-- and also automatically handles override spells (i.e. when given a base spell
	-- that has an active override, the range of the override is what's checked - 
	-- no need to pass the input through C_Spell.GetOverrideSpell).
	-- And it once again works with pet spells too!

	-- It remains to be seen if C_Spell.IsSpellInRange will continue to be so well behaved
	-- if/when it is brought to classic and era. May need to change the feature detection used.

	-- Some good spells to test with:
	-- 	Templar's Verdict (base) & Final Verdict (ret pally talent), talent has longer range than base
	--	Growl (hunter pet) - pet spell with range.

	local IsSpellInRange = C_Spell.IsSpellInRange
	local SpellHasRange = C_Spell.SpellHasRange

	function Lib.IsSpellInRange(spellInput, unit)
		local result = IsSpellInRange(spellInput, unit)
		return result and 1 or result == false and 0 or result
	end

	function Lib.SpellHasRange(spellInput)
		local result = SpellHasRange(spellInput)
		return result and 1 or result == false and 0 or result
	end

	return
end


local GetSpellBookItemInfo = _G.GetSpellBookItemInfo or _G.C_SpellBook.GetSpellBookItemType
local GetSpellBookItemName = _G.GetSpellBookItemName or _G.C_SpellBook.GetSpellBookItemName
local GetSpellLink = _G.GetSpellLink or _G.C_Spell.GetSpellLink
local GetSpellName = _G.GetSpellInfo or _G.C_Spell.GetSpellName

local IsSpellInRange = _G.IsSpellInRange
local IsSpellBookItemInRange = _G.IsSpellInRange or function(index, spellBank, unit)
  local result = C_SpellBook.IsSpellBookItemInRange(index, spellBank, unit)
  if result == true then
    return 1
  elseif result == false then
    return 0
  end
  return nil
end

local SpellHasRange = _G.SpellHasRange
local SpellBookHasRange = _G.SpellHasRange or _G.C_SpellBook.IsSpellBookItemInRange

local UnitExists = _G.UnitExists
local GetPetActionInfo = _G.GetPetActionInfo
local UnitIsUnit = _G.UnitIsUnit

local playerBook = _G.GetSpellBookItemName and "spell" or _G.Enum.SpellBookSpellBank.Player
local petBook = _G.GetSpellBookItemName and "pet" or _G.Enum.SpellBookSpellBank.Pet

-- isNumber is basically a tonumber cache for maximum efficiency
Lib.isNumber = Lib.isNumber or setmetatable({}, {
	__mode = "kv",
	__index = function(t, i)
		local o = tonumber(i) or false
		t[i] = o
		return o
end})
local isNumber = Lib.isNumber

-- strlower cache for maximum efficiency
Lib.strlowerCache = Lib.strlowerCache or setmetatable(
{}, {
	__index = function(t, i)
		if not i then return end
		local o
		if type(i) == "number" then
			o = i
		else
			o = strlower(i)
		end
		t[i] = o
		return o
	end,
}) local strlowerCache = Lib.strlowerCache

-- Matches lowercase player spell names to their spellBookID
Lib.spellsByName_spell = Lib.spellsByName_spell or {}
local spellsByName_spell = Lib.spellsByName_spell

-- Matches player spellIDs to their spellBookID
Lib.spellsByID_spell = Lib.spellsByID_spell or {}
local spellsByID_spell = Lib.spellsByID_spell

-- Matches lowercase pet spell names to their spellBookID
Lib.spellsByName_pet = Lib.spellsByName_pet or {}
local spellsByName_pet = Lib.spellsByName_pet

-- Matches pet spellIDs to their spellBookID
Lib.spellsByID_pet = Lib.spellsByID_pet or {}
local spellsByID_pet = Lib.spellsByID_pet

-- Matches pet spell names to their pet action bar slot
Lib.actionsByName_pet = Lib.actionsByName_pet or {}
local actionsByName_pet = Lib.actionsByName_pet

-- Matches pet spell IDs to their pet action bar slot
Lib.actionsById_pet = Lib.actionsById_pet or {}
local actionsById_pet = Lib.actionsById_pet

-- Caches whether a pet spell has been observed to ever have had a range.
-- Since this should never change for any particular spell,
-- it is not wiped.
Lib.petSpellHasRange = Lib.petSpellHasRange or {}
local petSpellHasRange = Lib.petSpellHasRange

-- Updates spellsByName and spellsByID

local GetNumSpellTabs = _G.GetNumSpellTabs or C_SpellBook.GetNumSpellBookSkillLines
local GetSpellTabInfo = _G.GetSpellTabInfo or function(index)
	local skillLineInfo = C_SpellBook.GetSpellBookSkillLineInfo(index);
	if skillLineInfo then
		return	skillLineInfo.name,
				skillLineInfo.iconID,
				skillLineInfo.itemIndexOffset,
				skillLineInfo.numSpellBookItems,
				skillLineInfo.isGuild,
				skillLineInfo.offSpecID,
				skillLineInfo.shouldHide,
				skillLineInfo.specID;
	end
end

local function UpdateBook(bookType)
	local book = bookType == "spell" and playerBook or petBook
	local max = 0
	for i = 1, GetNumSpellTabs() do
		local _, _, offs, numspells, _, specId = GetSpellTabInfo(i)
		if specId == 0 then
			max = offs + numspells
		end
	end

	local spellsByName = Lib["spellsByName_" .. bookType]
	local spellsByID = Lib["spellsByID_" .. bookType]
	
	wipe(spellsByName)
	wipe(spellsByID)
	
	for spellBookID = 1, max do
		local type, baseSpellID = GetSpellBookItemInfo(spellBookID, book)
		
		if type == "SPELL" or type == "PETACTION" then
			local currentSpellName, _, currentSpellID = GetSpellBookItemName(spellBookID, book)
			if not currentSpellID then
				local link = GetSpellLink(currentSpellName)
				currentSpellID = tonumber(link and link:gsub("|", "||"):match("spell:(%d+)"))
			end

			-- For each entry we add to a table,
			-- only add it if there isn't anything there already.
			-- This prevents weird passives from overwriting real, legit spells.
			-- For example, in WoW 7.3.5 the ret paladin mastery 
			-- was coming back with a base spell named "Judgement",
			-- which was overwriting the real "Judgement".
			-- Passives usually come last in the spellbook,
			-- so this should work just fine as a workaround.
			-- This issue with "Judgement" is gone in BFA because the mastery changed.
			
			if currentSpellName and not spellsByName[strlower(currentSpellName)] then
				spellsByName[strlower(currentSpellName)] = spellBookID
			end
			if currentSpellID and not spellsByID[currentSpellID] then
				spellsByID[currentSpellID] = spellBookID
			end
			
			if type == "SPELL" then
				-- PETACTION (pet abilities) don't return a spellID for baseSpellID,
				-- so base spells only work for proper player spells.
				local baseSpellName = GetSpellName(baseSpellID)
				if baseSpellName and not spellsByName[strlower(baseSpellName)] then
					spellsByName[strlower(baseSpellName)] = spellBookID
				end
				if baseSpellID and not spellsByID[baseSpellID] then
					spellsByID[baseSpellID] = spellBookID
				end
			end
		end
	end
end

local function UpdatePetBar()
	wipe(actionsByName_pet)
	wipe(actionsById_pet)
	if not UnitExists("pet") then return end

	for i = 1, NUM_PET_ACTION_SLOTS do
		local name, texture, isToken, isActive, autoCastAllowed, autoCastEnabled, spellID, checksRange, inRange = GetPetActionInfo(i)
		if checksRange then
			actionsByName_pet[strlower(name)] = i
			actionsById_pet[spellID] = i

			petSpellHasRange[strlower(name)] = true
			petSpellHasRange[spellID] = true
		end
	end
end
UpdatePetBar()

Lib.updaterFrame:RegisterEvent("SPELLS_CHANGED")
Lib.updaterFrame:RegisterEvent("PET_BAR_UPDATE")
Lib.updaterFrame:RegisterEvent("PLAYER_TARGET_CHANGED")
Lib.updaterFrame:RegisterEvent("CVAR_UPDATE")

local function UpdateSpells(_, event, arg1)
	if event == "PET_BAR_UPDATE" then
		UpdatePetBar()
	elseif event == "PLAYER_TARGET_CHANGED" then
		-- `checksRange` from GetPetActionInfo() changes based on whether the player has a target or not.
		UpdatePetBar()
	elseif event == "SPELLS_CHANGED" then
		UpdateBook("spell")
		UpdateBook("pet")
	elseif event == "CVAR_UPDATE" and arg1 == "ShowAllSpellRanks" then
		UpdateBook("spell")
		UpdateBook("pet")
	end
end

Lib.updaterFrame:SetScript("OnEvent", UpdateSpells)


--- Improved spell range checking function.
-- @name SpellRange.IsSpellInRange
-- @paramsig spell, unit
-- @param spell Name or spellID of a spell that you wish to check the range of. The spell must be a spell that you have in your spellbook or your pet's spellbook.
-- @param unit UnitID of the spell that you wish to check the range on.
-- @return Exact same returns as http://wowprogramming.com/docs/api/IsSpellInRange
-- @usage
-- -- Check spell range by spell name on unit "target"
-- local SpellRange = LibStub("SpellRange-1.0")
-- local inRange = SpellRange.IsSpellInRange("Stormstrike", "target")
--
-- -- Check spell range by spellID on unit "mouseover"
-- local SpellRange = LibStub("SpellRange-1.0")
-- local inRange = SpellRange.IsSpellInRange(17364, "mouseover")
function Lib.IsSpellInRange(spellInput, unit)
	if isNumber[spellInput] then
		local spell = spellsByID_spell[spellInput]
		if spell then
			return IsSpellBookItemInRange(spell, playerBook, unit)
		else
			local spell = spellsByID_pet[spellInput]
			if spell then
				local petResult = IsSpellBookItemInRange(spell, petBook, unit)
				if petResult ~= nil then
					return petResult
				end
				
				-- IsSpellInRange seems to no longer work for pet spellbook,
				-- so we also try the action bar API.
				local actionSlot = actionsById_pet[spellInput]
				if actionSlot and (unit == "target" or UnitIsUnit(unit, "target")) then
					return select(9, GetPetActionInfo(actionSlot)) and 1 or 0
				end
			end
		end

		-- if "show all ranks" in spellbook is not ticked and the input was a lower rank of a spell, it won't exist in spellsByID_spell. 
		-- Workaround this issue by testing by name when no result was found using spellbook
		local name = GetSpellName(spellInput)
		if name then
			return IsSpellInRange(name, unit)
		end
	else
		local spellInput = strlowerCache[spellInput]
		
		local spell = spellsByName_spell[spellInput]
		if spell then
			return IsSpellBookItemInRange(spell, playerBook, unit)
		else
			local spell = spellsByName_pet[spellInput]
			if spell then
				local petResult = IsSpellBookItemInRange(spell, petBook, unit)
				if petResult ~= nil then
					return petResult
				end

				-- IsSpellInRange seems to no longer work for pet spellbook,
				-- so we also try the action bar API.
				local actionSlot = actionsByName_pet[spellInput]
				if actionSlot and (unit == "target" or UnitIsUnit(unit, "target")) then
					return select(9, GetPetActionInfo(actionSlot)) and 1 or 0
				end
			end
		end
		return IsSpellInRange(spellInput, unit)
	end
end


--- Improved SpellHasRange.
-- @name SpellRange.SpellHasRange
-- @paramsig spell
-- @param spell Name or spellID of a spell that you wish to check for a range. The spell must be a spell that you have in your spellbook or your pet's spellbook.
-- @return Exact same returns as http://wowprogramming.com/docs/api/SpellHasRange
-- @usage
-- -- Check if a spell has a range by spell name
-- local SpellRange = LibStub("SpellRange-1.0")
-- local hasRange = SpellRange.SpellHasRange("Stormstrike")
--
-- -- Check if a spell has a range by spellID
-- local SpellRange = LibStub("SpellRange-1.0")
-- local hasRange = SpellRange.SpellHasRange(17364)
function Lib.SpellHasRange(spellInput)
	if isNumber[spellInput] then
		local spell = spellsByID_spell[spellInput]
		if spell then
			return SpellBookHasRange(spell, playerBook)
		else
			local spell = spellsByID_pet[spellInput]
			if spell then
				-- SpellHasRange seems to no longer work for pet spellbook.
				return SpellBookHasRange(spell, petBook) or petSpellHasRange[spellInput] or false
			end
		end
	
		local name = GetSpellName(spellInput)
		if name then
			return SpellHasRange(name)
		end
	else
		local spellInput = strlowerCache[spellInput]
		
		local spell = spellsByName_spell[spellInput]
		if spell then
			return SpellBookHasRange(spell, playerBook)
		else
			local spell = spellsByName_pet[spellInput]
			if spell then
				-- SpellHasRange seems to no longer work for pet spellbook.
				return SpellBookHasRange(spell, petBook) or petSpellHasRange[spellInput] or false
			end
		end
		return SpellHasRange(spellInput)
	end
end

-- ========================================
-- File: WeakAuras/Libs/LibStub/LibStub.lua
-- ========================================

-- $Id: LibStub.lua 103 2014-10-16 03:02:50Z mikk $
-- LibStub is a simple versioning stub meant for use in Libraries.  http://www.wowace.com/addons/libstub/ for more info
-- LibStub is hereby placed in the Public Domain
-- Credits: Kaelten, Cladhaire, ckknight, Mikk, Ammo, Nevcairiel, joshborke
local LIBSTUB_MAJOR, LIBSTUB_MINOR = "LibStub", 2  -- NEVER MAKE THIS AN SVN REVISION! IT NEEDS TO BE USABLE IN ALL REPOS!
local LibStub = _G[LIBSTUB_MAJOR]

-- Check to see is this version of the stub is obsolete
if not LibStub or LibStub.minor < LIBSTUB_MINOR then
	LibStub = LibStub or {libs = {}, minors = {} }
	_G[LIBSTUB_MAJOR] = LibStub
	LibStub.minor = LIBSTUB_MINOR
	
	-- LibStub:NewLibrary(major, minor)
	-- major (string) - the major version of the library
	-- minor (string or number ) - the minor version of the library
	-- 
	-- returns nil if a newer or same version of the lib is already present
	-- returns empty library object or old library object if upgrade is needed
	function LibStub:NewLibrary(major, minor)
		assert(type(major) == "string", "Bad argument #2 to `NewLibrary' (string expected)")
		minor = assert(tonumber(strmatch(minor, "%d+")), "Minor version must either be a number or contain a number.")
		
		local oldminor = self.minors[major]
		if oldminor and oldminor >= minor then return nil end
		self.minors[major], self.libs[major] = minor, self.libs[major] or {}
		return self.libs[major], oldminor
	end
	
	-- LibStub:GetLibrary(major, [silent])
	-- major (string) - the major version of the library
	-- silent (boolean) - if true, library is optional, silently return nil if its not found
	--
	-- throws an error if the library can not be found (except silent is set)
	-- returns the library object if found
	function LibStub:GetLibrary(major, silent)
		if not self.libs[major] and not silent then
			error(("Cannot find a library instance of %q."):format(tostring(major)), 2)
		end
		return self.libs[major], self.minors[major]
	end
	
	-- LibStub:IterateLibraries()
	-- 
	-- Returns an iterator for the currently registered libraries
	function LibStub:IterateLibraries() 
		return pairs(self.libs) 
	end
	
	setmetatable(LibStub, { __call = LibStub.GetLibrary })
end


-- ========================================
-- File: WeakAuras/Libs/LibStub/tests/test.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()

local lib, oldMinor = LibStub:NewLibrary("Pants", 1) -- make a new thingy
assert(lib) -- should return the library table
assert(not oldMinor) -- should not return the old minor, since it didn't exist

-- the following is to create data and then be able to check if the same data exists after the fact
function lib:MyMethod()
end
local MyMethod = lib.MyMethod
lib.MyTable = {}
local MyTable = lib.MyTable

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 1) -- try to register a library with the same version, should silently fail
assert(not newLib) -- should not return since out of date

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 0) -- try to register a library with a previous, should silently fail
assert(not newLib) -- should not return since out of date

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 2) -- register a new version
assert(newLib) -- library table
assert(rawequal(newLib, lib)) -- should be the same reference as the previous
assert(newOldMinor == 1) -- should return the minor version of the previous version

assert(rawequal(lib.MyMethod, MyMethod)) -- verify that values were saved
assert(rawequal(lib.MyTable, MyTable)) -- verify that values were saved

local newLib, newOldMinor = LibStub:NewLibrary("Pants", "Blah 3 Blah") -- register a new version with a string minor version (instead of a number)
assert(newLib) -- library table
assert(newOldMinor == 2) -- previous version was 2

local newLib, newOldMinor = LibStub:NewLibrary("Pants", "Blah 4 and please ignore 15 Blah") -- register a new version with a string minor version (instead of a number)
assert(newLib)
assert(newOldMinor == 3) -- previous version was 3 (even though it gave a string)

local newLib, newOldMinor = LibStub:NewLibrary("Pants", 5) -- register a new library, using a normal number instead of a string
assert(newLib)
assert(newOldMinor == 4) -- previous version was 4 (even though it gave a string)

-- ========================================
-- File: WeakAuras/Libs/LibStub/tests/test2.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()

for major, library in LibStub:IterateLibraries() do
	-- check that MyLib doesn't exist yet, by iterating through all the libraries
	assert(major ~= "MyLib")
end

assert(not LibStub:GetLibrary("MyLib", true)) -- check that MyLib doesn't exist yet by direct checking
assert(not pcall(LibStub.GetLibrary, LibStub, "MyLib")) -- don't silently fail, thus it should raise an error.
local lib = LibStub:NewLibrary("MyLib", 1) -- create the lib
assert(lib) -- check it exists
assert(rawequal(LibStub:GetLibrary("MyLib"), lib)) -- verify that :GetLibrary("MyLib") properly equals the lib reference

assert(LibStub:NewLibrary("MyLib", 2))	-- create a new version

local count=0
for major, library in LibStub:IterateLibraries() do
	-- check that MyLib exists somewhere in the libraries, by iterating through all the libraries
	if major == "MyLib" then -- we found it!
		count = count +1
		assert(rawequal(library, lib)) -- verify that the references are equal
	end
end
assert(count == 1) -- verify that we actually found it, and only once


-- ========================================
-- File: WeakAuras/Libs/LibStub/tests/test3.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()

local proxy = newproxy() -- non-string

assert(not pcall(LibStub.NewLibrary, LibStub, proxy, 1)) -- should error, proxy is not a string, it's userdata
local success, ret = pcall(LibStub.GetLibrary, proxy, true)
assert(not success or not ret) -- either error because proxy is not a string or because it's not actually registered.

assert(not pcall(LibStub.NewLibrary, LibStub, "Something", "No number in here")) -- should error, minor has no string in it.

assert(not LibStub:GetLibrary("Something", true)) -- shouldn't've created it from the above statement

-- ========================================
-- File: WeakAuras/Libs/LibStub/tests/test4.lua
-- ========================================

debugstack = debug.traceback
strmatch = string.match

loadfile("../LibStub.lua")()


-- Pretend like loaded libstub is old and doesn't have :IterateLibraries
assert(LibStub.minor)
LibStub.minor = LibStub.minor - 0.0001
LibStub.IterateLibraries = nil

loadfile("../LibStub.lua")()

assert(type(LibStub.IterateLibraries)=="function")


-- Now pretend that we're the same version -- :IterateLibraries should NOT be re-created
LibStub.IterateLibraries = 123

loadfile("../LibStub.lua")()

assert(LibStub.IterateLibraries == 123)


-- Now pretend that a newer version is loaded -- :IterateLibraries should NOT be re-created
LibStub.minor = LibStub.minor + 0.0001

loadfile("../LibStub.lua")()

assert(LibStub.IterateLibraries == 123)


-- Again with a huge number
LibStub.minor = LibStub.minor + 1234567890

loadfile("../LibStub.lua")()

assert(LibStub.IterateLibraries == 123)


print("OK")

-- ========================================
-- File: WeakAuras/Locales/deDE.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "deDE" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = "Filter format:  'Name', 'Name-Realm', '-Realm'. Untersttzt mehrfacheintrge welche durch Kommas getrennt werden. Verwende \\ um - zu escapen."
L["%s Overlay Color"] = "%s Overlay Farbe"
L["* Suffix"] = "* Suffix"
L["/wa help - Show this message"] = "/wa help - Zeige diese Nachricht"
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - Anzeige des Minimap-Icons umschalten"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - Zeigt das Ergebnis des aktuellsten Profilings an"
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart - Startet das Profiling. Optional kann eine Dauer in Sekunden angegeben werden, nachdem das Profiling automatisch gestoppt wird. Um den nchsten Kampf zu loggen, fge combat oder encounter hinzu, also z.B. \"/wa pstart combat\""
L["/wa pstop - Finish profiling"] = "/wa pstop - beendet das Pofiling"
L["/wa repair - Repair tool"] = "/wa repair - Reparierwerkzeug"
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55fLink-Klick|r um das Anzeigen des Hauptfensters umzuschalten."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55fMittlere Maustaste|r um das Minimapsymbol an oder auszuschalten."
--[[Translation missing --]]
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55fRight-Click|r to toggle performance profiling window."
--[[Translation missing --]]
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fShift-Click|r to pause addon execution."
--[[Translation missing --]]
L["|cffff0000deprecated|r"] = "|cffff0000deprecated|r"
--[[Translation missing --]]
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000Not|r Item Bonus Id Equipped"
--[[Translation missing --]]
L["|cFFFF0000Not|r Item Equipped"] = "|cFFFF0000Not|r Item Equipped"
--[[Translation missing --]]
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000Not|r Player Name/Realm"
--[[Translation missing --]]
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000Not|r Spell Known"
--[[Translation missing --]]
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=]
--[[Translation missing --]]
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00Extra Options:|r %s"
--[[Translation missing --]]
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00Extra Options:|r None"
--[[Translation missing --]]
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=]
--[[Translation missing --]]
L["1. Profession 1. Accessory"] = "1. Profession 1. Accessory"
--[[Translation missing --]]
L["1. Profession 2. Accessory"] = "1. Profession 2. Accessory"
--[[Translation missing --]]
L["1. Professsion Tool"] = "1. Professsion Tool"
L["10 Man Raid"] = "10-Mann-Schlachtzug"
--[[Translation missing --]]
L["10 Player Raid"] = "10 Player Raid"
L["10 Player Raid (Heroic)"] = "10 Spieler Schlachtzug (Heroisch)"
L["10 Player Raid (Normal)"] = "10 Spieler Schlachtzug (Normal)"
--[[Translation missing --]]
L["2. Profession 1. Accessory"] = "2. Profession 1. Accessory"
--[[Translation missing --]]
L["2. Profession 2. Accessory"] = "2. Profession 2. Accessory"
--[[Translation missing --]]
L["2. Professsion Tool"] = "2. Professsion Tool"
L["20 Man Raid"] = "20-Mann-Schlachtzug"
--[[Translation missing --]]
L["20 Player Raid"] = "20 Player Raid"
L["25 Man Raid"] = "25-Mann-Schlachtzug"
L["25 Player Raid"] = "25 Spieler Schlachtzug"
L["25 Player Raid (Heroic)"] = "25 Spieler Schlachtzug (Heroisch)"
L["25 Player Raid (Normal)"] = "25 Spieler Schlachtzug (Normal)"
L["40 Man Raid"] = "40-Mann-Schlachtzug"
L["40 Player Raid"] = "40 Spieler Schlachtzug"
L["5 Man Dungeon"] = "5-Mann-Dungeon"
--[[Translation missing --]]
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=]
--[[Translation missing --]]
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."
--[[Translation missing --]]
L["Abbreviate"] = "Abbreviate"
--[[Translation missing --]]
L["AbbreviateLargeNumbers (Blizzard)"] = "AbbreviateLargeNumbers (Blizzard)"
--[[Translation missing --]]
L["AbbreviateNumbers (Blizzard)"] = "AbbreviateNumbers (Blizzard)"
L["Absorb"] = "Absorbieren"
--[[Translation missing --]]
L["Absorb and Healing"] = "Absorb and Healing"
--[[Translation missing --]]
L["Absorb Heal Overlay"] = "Absorb Heal Overlay"
--[[Translation missing --]]
L["Absorb Overlay"] = "Absorb Overlay"
L["Absorbed"] = "Absorbiert"
--[[Translation missing --]]
L["Action Button Glow"] = "Action Button Glow"
L["Actions"] = "Aktionen"
L["Active"] = "Aktiv"
--[[Translation missing --]]
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
--[[Translation missing --]]
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
L["Add"] = "Hinzufgen"
L["Add Missing Auras"] = "Fehlende Auren hinzufgen"
--[[Translation missing --]]
L["Advanced Caster's Target Check"] = "Advanced Caster's Target Check"
L["Affected"] = "Betroffen"
L["Affected Unit Count"] = "Anzahl betroffener Einheiten"
L["Afk"] = "Afk"
L["Aggro"] = "Aggro (Bedrohung)"
L["Agility"] = "Beweglichkeit"
L["Ahn'Qiraj"] = "Ahn'Qiraj"
L["Alert Type"] = "Warnungstyp"
L["Alive"] = "am Leben"
L["All"] = "Alle"
--[[Translation missing --]]
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "All children of this aura will also not be loaded, to minimize the chance of further corruption."
--[[Translation missing --]]
L["All States table contains a non table at key: '%s'."] = "All States table contains a non table at key: '%s'."
L["All Triggers"] = "Alle Auslser (UND)"
L["Alliance"] = "Allianz"
L["Allow partial matches"] = "Teilweise bereinstimmungen erlauben"
L["Alpha"] = "Alpha"
L["Alternate Power"] = "Alternative Energie"
L["Always"] = "Immer"
L["Always active trigger"] = "Immer aktiver Auslser"
L["Always include realm"] = "Immer Realm einschlieen"
L["Always True"] = "Immer Richtig"
L["Amount"] = "Anzahl"
--[[Translation missing --]]
L["Anchoring"] = "Anchoring"
L["And Talent"] = "Und Talent"
--[[Translation missing --]]
L["Angle and Radius"] = "Angle and Radius"
L["Animations"] = "Animationen"
L["Anticlockwise"] = "Im Gegenuhrzeigersinn"
--[[Translation missing --]]
L["Anub'Rekhan"] = "Anub'Rekhan"
--[[Translation missing --]]
L["Any"] = "Any"
L["Any Triggers"] = "Ein Auslser (ODER)"
--[[Translation missing --]]
L["AOE"] = "AOE"
--[[Translation missing --]]
L["Arcane Resistance"] = "Arcane Resistance"
--[[Translation missing --]]
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=]
L["Arena"] = "Arena"
L["Armor (%)"] = "Rstung (%)"
--[[Translation missing --]]
L["Armor against Target (%)"] = "Armor against Target (%)"
--[[Translation missing --]]
L["Armor Rating"] = "Armor Rating"
--[[Translation missing --]]
L["Array"] = "Array"
L["Ascending"] = "Aufsteigend"
L["Assigned Role"] = "Zugewiesene Rolle"
--[[Translation missing --]]
L["Assigned Role Icon"] = "Assigned Role Icon"
--[[Translation missing --]]
L["Assist"] = "Assist"
--[[Translation missing --]]
L["Assisted Combat Next Cast"] = "Assisted Combat Next Cast"
L["At Least One Enemy"] = "Zumindest ein Feind"
L["At missing Value"] = "Bei fehlendem Wert"
L["At Percent"] = "Bei Prozent"
L["At Value"] = "Bei Wert"
--[[Translation missing --]]
L["At War"] = "At War"
L["Attach to End"] = "am Ende befestigen"
--[[Translation missing --]]
L["Attach to End, backwards"] = "Attach to End, backwards"
--[[Translation missing --]]
L["Attach to Point"] = "Attach to Point"
L["Attach to Start"] = "am Anfang befestigen"
L["Attack Power"] = "Angriffskraft"
L["Attackable"] = "Angreifbar"
L["Attackable Target"] = "Angreifbares Ziel"
L["Aura"] = "Aura (Buff/Debuff)"
--[[Translation missing --]]
L["Aura '%s': %s"] = "Aura '%s': %s"
L["Aura Applied"] = "Aura angewandt (AURA_APPLIED)"
L["Aura Applied Dose"] = "Aura angewandt, Stapel erhht (AURA_APPLIED_DOSE)"
L["Aura Broken"] = "Aura gebrochen, Nahkampf (AURA_BROKEN)"
L["Aura Broken Spell"] = "Aura gebrochen, Zauber (AURA_BROKEN_SPELL)"
--[[Translation missing --]]
L["Aura is using deprecated SetDurationInfo"] = "Aura is using deprecated SetDurationInfo"
--[[Translation missing --]]
L["Aura loaded"] = "Aura loaded"
L["Aura Name"] = "Auraname oder -ID"
L["Aura Names"] = "Aura Namen"
L["Aura Refresh"] = "Aura erneuert (AURA_REFRESH)"
L["Aura Removed"] = "Aura entfernt (AURA_REMOVED)"
L["Aura Removed Dose"] = "Aura entfernt, Stack verringert (AURA_REMOVED_DOSE)"
L["Aura Stack"] = "Aurastapel"
L["Aura Type"] = "Auratyp"
--[[Translation missing --]]
L["Aura Version: %s"] = "Aura Version: %s"
L["Aura(s) Found"] = "Auren gefunden"
L["Aura(s) Missing"] = "Auren fehlend"
L["Aura:"] = "Aura:"
--[[Translation missing --]]
L["Auras"] = "Auras"
L["Auras:"] = "Auren:"
--[[Translation missing --]]
L["Author Options"] = "Author Options"
--[[Translation missing --]]
L["Auto"] = "Auto"
--[[Translation missing --]]
L["Autocast Shine"] = "Autocast Shine"
L["Automatic"] = "Automatisch"
--[[Translation missing --]]
L["Automatic Length"] = "Automatic Length"
L["Automatic Rotation"] = "Automatische Rotation"
--[[Translation missing --]]
L["Available features: %s"] = "Available features: %s"
L["Avoidance (%)"] = "Vermeidung (%)"
--[[Translation missing --]]
L["Avoidance Rating"] = "Avoidance Rating"
--[[Translation missing --]]
L["Ayamiss the Hunter"] = "Ayamiss the Hunter"
--[[Translation missing --]]
L["Azuregos"] = "Azuregos"
L["Back and Forth"] = "Vor und zurck"
L["Background"] = "Hintergrund"
L["Background Color"] = "Hintergrundfarbe"
--[[Translation missing --]]
L["Balnazzar"] = "Balnazzar"
--[[Translation missing --]]
L["Bar Color/Gradient Start"] = "Bar Color/Gradient Start"
--[[Translation missing --]]
L["Bar enabled in BigWigs settings"] = "Bar enabled in BigWigs settings"
--[[Translation missing --]]
L["Bar enabled in Boss Mod addon settings"] = "Bar enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Bar enabled in DBM settings"] = "Bar enabled in DBM settings"
--[[Translation missing --]]
L["Bar Texture"] = "Bar Texture"
--[[Translation missing --]]
L["Bar Type"] = "Bar Type"
--[[Translation missing --]]
L["Baron Geddon"] = "Baron Geddon"
--[[Translation missing --]]
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "Battle.net-Flster"
L["Battleground"] = "Schlachtfeld"
--[[Translation missing --]]
L["Battleguard Sartura"] = "Battleguard Sartura"
--[[Translation missing --]]
L["Beastmaster"] = "Beastmaster"
--[[Translation missing --]]
L["Beatrix"] = "Beatrix"
--[[Translation missing --]]
L["BG>Raid>Party>Say"] = "BG>Raid>Party>Say"
L["BG-System Alliance"] = "BG-System Allianz"
L["BG-System Horde"] = "BG-System Horde"
L["BG-System Neutral"] = "BG-System Neutral"
--[[Translation missing --]]
L["Big Number"] = "Big Number"
L["BigWigs Addon"] = "BigWigs-Addon"
L["BigWigs Message"] = "BigWigs-Nachricht"
--[[Translation missing --]]
L["BigWigs Stage"] = "BigWigs Stage"
L["BigWigs Timer"] = "BigWigs-Timer"
L["Black Wing Lair"] = "Pechschwingenhort"
--[[Translation missing --]]
L["Bleed"] = "Bleed"
L["Blizzard Combat Text"] = "Kampflog"
--[[Translation missing --]]
L["Blizzard Cooldown Reduction"] = "Blizzard Cooldown Reduction"
L["Block"] = "Blocken"
--[[Translation missing --]]
L["Block (%)"] = "Block (%)"
--[[Translation missing --]]
L["Block against Target (%)"] = "Block against Target (%)"
--[[Translation missing --]]
L["Block Value"] = "Block Value"
L["Blocked"] = "Geblockt"
--[[Translation missing --]]
L["Blood"] = "Blood"
--[[Translation missing --]]
L["Blood Rune #1"] = "Blood Rune #1"
--[[Translation missing --]]
L["Blood Rune #2"] = "Blood Rune #2"
--[[Translation missing --]]
L["Bloodlord Mandokir"] = "Bloodlord Mandokir"
--[[Translation missing --]]
L["Bonus Reputation Gain"] = "Bonus Reputation Gain"
L["Border"] = "Rahmen"
L["Boss"] = "Boss"
L["Boss Emote"] = "Bossemote"
--[[Translation missing --]]
L["Boss Mod Announce"] = "Boss Mod Announce"
--[[Translation missing --]]
L["Boss Mod Stage"] = "Boss Mod Stage"
--[[Translation missing --]]
L["Boss Mod Stage (Event)"] = "Boss Mod Stage (Event)"
--[[Translation missing --]]
L["Boss Mod Timer"] = "Boss Mod Timer"
L["Boss Whisper"] = "Bossflstern"
L["Bottom"] = "Unten"
L["Bottom Left"] = "Unten Links"
L["Bottom Right"] = "Unten Rechts"
L["Bottom to Top"] = "Unten -> Oben"
L["Bounce"] = "Hpfen"
L["Bounce with Decay"] = "Abklingendes Hpfen"
--[[Translation missing --]]
L["Break"] = "Break"
--[[Translation missing --]]
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers (Blizzard)"
--[[Translation missing --]]
L["Broodlord Lashlayer"] = "Broodlord Lashlayer"
L["Buff"] = "Buff"
L["Buff/Debuff"] = "Strkungs-/Schwchungszauber"
L["Buffed/Debuffed"] = "Buffed/Debuffed"
L["Burning Crusade"] = "Burning Crusade"
--[[Translation missing --]]
L["Buru the Gorger"] = "Buru the Gorger"
--[[Translation missing --]]
L["Caldoran"] = "Caldoran"
--[[Translation missing --]]
L["Callback function"] = "Callback function"
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "Kann genutzt werden um z.B zu checken ob \"Ziel\" dieselbe Einheit ist wie \"Spieler\""
L["Cancel"] = "Abbrechen"
--[[Translation missing --]]
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."
--[[Translation missing --]]
L["Capped"] = "Capped"
--[[Translation missing --]]
L["Capped at Season Max"] = "Capped at Season Max"
--[[Translation missing --]]
L["Capped at Weekly Max"] = "Capped at Weekly Max"
L["Cast"] = "Zauberwirken"
L["Cast Bar"] = "Zauberleiste"
L["Cast Failed"] = "Zauber fehlgeschlagen (CAST_FAILED)"
L["Cast Start"] = "Zauber gestartet (CAST_START)"
L["Cast Success"] = "Zauber gelungen (CAST_SUCCESS)"
L["Cast Type"] = "Zaubertyp"
L["Caster"] = "Zauberwirker"
--[[Translation missing --]]
L["Caster Name"] = "Caster Name"
--[[Translation missing --]]
L["Caster Realm"] = "Caster Realm"
--[[Translation missing --]]
L["Caster Unit"] = "Caster Unit"
--[[Translation missing --]]
L["Casters Name/Realm"] = "Casters Name/Realm"
--[[Translation missing --]]
L["Caster's Target"] = "Caster's Target"
--[[Translation missing --]]
L["Cataclysm"] = "Cataclysm"
--[[Translation missing --]]
L["Ceil"] = "Ceil"
L["Center"] = "Mitte"
--[[Translation missing --]]
L["Center, then alternating bottom and top"] = "Center, then alternating bottom and top"
--[[Translation missing --]]
L["Center, then alternating left and right"] = "Center, then alternating left and right"
--[[Translation missing --]]
L["Center, then alternating right and left"] = "Center, then alternating right and left"
--[[Translation missing --]]
L["Center, then alternating top and bottom"] = "Center, then alternating top and bottom"
L["Centered Horizontal"] = "Horizontal-Zentriert"
--[[Translation missing --]]
L["Centered Horizontal, then Centered Vertical"] = "Centered Horizontal, then Centered Vertical"
--[[Translation missing --]]
L["Centered Horizontal, then Down"] = "Centered Horizontal, then Down"
--[[Translation missing --]]
L["Centered Horizontal, then Up"] = "Centered Horizontal, then Up"
L["Centered Vertical"] = "Vertikal zentriert"
--[[Translation missing --]]
L["Centered Vertical, then Centered Horizontal"] = "Centered Vertical, then Centered Horizontal"
--[[Translation missing --]]
L["Centered Vertical, then Left"] = "Centered Vertical, then Left"
--[[Translation missing --]]
L["Centered Vertical, then Right"] = "Centered Vertical, then Right"
L["Changed"] = "Verndert"
L["Channel"] = "Chatkanal"
L["Channel (Spell)"] = "Kanalisieren (Zauber)"
--[[Translation missing --]]
L["Character GUID"] = "Character GUID"
--[[Translation missing --]]
L["Character Name"] = "Character Name"
L["Character Stats"] = "Charakterwerte"
--[[Translation missing --]]
L["Character Transferred Quantity"] = "Character Transferred Quantity"
L["Character Type"] = "Charaktertyp"
L["Charge gained/lost"] = "Aufladung erhalten/verloren"
--[[Translation missing --]]
L["Charged Combo Points"] = "Charged Combo Points"
L["Charges"] = "Aufladungen"
--[[Translation missing --]]
L["Charges Changed Event"] = "Charges Changed Event"
--[[Translation missing --]]
L["Charging"] = "Charging"
L["Chat Frame"] = "Chatfenster"
L["Chat Message"] = "Chatnachricht"
--[[Translation missing --]]
L["Check if a single talent match a Rank"] = "Check if a single talent match a Rank"
--[[Translation missing --]]
L["Check nameplate's target every 0.2s"] = "Check nameplate's target every 0.2s"
--[[Translation missing --]]
L["Chromaggus"] = "Chromaggus"
L["Circle"] = "Kreis"
--[[Translation missing --]]
L["Circular Texture"] = "Circular Texture"
--[[Translation missing --]]
L["Clamp"] = "Clamp"
L["Class"] = "Klasse"
L["Class and Specialization"] = "Klasse und Spezialisierung"
--[[Translation missing --]]
L["Classic"] = "Classic"
L["Classification"] = "Klassifizierung"
L["Clockwise"] = "Im Uhrzeigersinn"
--[[Translation missing --]]
L["Clone per Character"] = "Clone per Character"
L["Clone per Event"] = "Klonen pro Event"
L["Clone per Match"] = "Klonen pro Treffer"
--[[Translation missing --]]
L["Coin Precision"] = "Coin Precision"
L["Color"] = "Farbe"
--[[Translation missing --]]
L["Color Animation"] = "Color Animation"
L["Combat Log"] = "Kampflog"
--[[Translation missing --]]
L["Communities"] = "Communities"
--[[Translation missing --]]
L["Condition Custom Test"] = "Condition Custom Test"
L["Conditions"] = "Bedingungen"
L["Contains"] = "Enthlt"
--[[Translation missing --]]
L["Continuously update Movement Speed"] = "Continuously update Movement Speed"
L["Cooldown"] = "Abklingzeit"
--[[Translation missing --]]
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"
L["Cooldown Progress (Item)"] = "Abklingzeit (Gegenstand)"
--[[Translation missing --]]
L["Cooldown Progress (Slot)"] = "Cooldown Progress (Slot)"
--[[Translation missing --]]
L["Cooldown Ready Event"] = "Cooldown Ready Event"
--[[Translation missing --]]
L["Cooldown Ready Event (Item)"] = "Cooldown Ready Event (Item)"
--[[Translation missing --]]
L["Cooldown Ready Event (Slot)"] = "Cooldown Ready Event (Slot)"
--[[Translation missing --]]
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."
--[[Translation missing --]]
L["Cooldown/Charges/Count"] = "Cooldown/Charges/Count"
--[[Translation missing --]]
L["Copper"] = "Copper"
--[[Translation missing --]]
L["Could not load WeakAuras Archive, the addon is %s"] = "Could not load WeakAuras Archive, the addon is %s"
L["Count"] = "Anzahl"
L["Counter Clockwise"] = "Gegen den Uhrzeigersinn"
L["Create"] = "Erstellen"
--[[Translation missing --]]
L["Creature Family"] = "Creature Family"
--[[Translation missing --]]
L["Creature Family Name"] = "Creature Family Name"
--[[Translation missing --]]
L["Creature Type"] = "Creature Type"
--[[Translation missing --]]
L["Creature Type Name"] = "Creature Type Name"
L["Critical"] = "Kritisch"
--[[Translation missing --]]
L["Critical (%)"] = "Critical (%)"
--[[Translation missing --]]
L["Critical Rating"] = "Critical Rating"
--[[Translation missing --]]
L["Crop X"] = "Crop X"
--[[Translation missing --]]
L["Crop Y"] = "Crop Y"
L["Crowd Controlled"] = "Kontrollverlust"
L["Crushing"] = "Zerschmettern"
--[[Translation missing --]]
L["C'thun"] = "C'thun"
--[[Translation missing --]]
L["Cumulated time used during profiling"] = "Cumulated time used during profiling"
--[[Translation missing --]]
L["Currency"] = "Currency"
--[[Translation missing --]]
L["Current Essence"] = "Current Essence"
--[[Translation missing --]]
L["Current Experience"] = "Current Experience"
--[[Translation missing --]]
L["Current Instance"] = "Current Instance"
--[[Translation missing --]]
L["Current Movement Speed (%)"] = "Current Movement Speed (%)"
--[[Translation missing --]]
L["Current Stage"] = "Current Stage"
--[[Translation missing --]]
L["Current Zone"] = "Current Zone"
--[[Translation missing --]]
L["Current Zone Group"] = "Current Zone Group"
L["Curse"] = "Fluch"
L["Custom"] = "Benutzerdefiniert"
--[[Translation missing --]]
L["Custom Action"] = "Custom Action"
--[[Translation missing --]]
L["Custom Anchor"] = "Custom Anchor"
--[[Translation missing --]]
L["Custom Check"] = "Custom Check"
--[[Translation missing --]]
L["Custom Color"] = "Custom Color"
--[[Translation missing --]]
L["Custom Condition Code"] = "Custom Condition Code"
--[[Translation missing --]]
L["Custom Configuration"] = "Custom Configuration"
--[[Translation missing --]]
L["Custom Fade Animation"] = "Custom Fade Animation"
L["Custom Function"] = "Benutzerdefiniert"
--[[Translation missing --]]
L["Custom Grow"] = "Custom Grow"
--[[Translation missing --]]
L["Custom Sort"] = "Custom Sort"
--[[Translation missing --]]
L["Custom Text Function"] = "Custom Text Function"
--[[Translation missing --]]
L["Custom Trigger Combination"] = "Custom Trigger Combination"
--[[Translation missing --]]
L["Custom Variables"] = "Custom Variables"
L["Damage"] = "Schaden (DAMAGE)"
L["Damage Shield"] = "Schadensschild (DAMAGE_SHIELD)"
L["Damage Shield Missed"] = "Schadensschild verfehlt (DAMAGE_SHIELD_MISSED)"
L["Damage Split"] = "Schadensteilung (DAMAGE_SPLIT)"
L["DBM Announce"] = "DBM Meldung"
--[[Translation missing --]]
L["DBM Stage"] = "DBM Stage"
L["DBM Timer"] = "DBM-Timer"
--[[Translation missing --]]
L["Dead"] = "Dead"
--[[Translation missing --]]
L["Death"] = "Death"
L["Death Knight Rune"] = "Todesritter-Rune"
L["Debuff"] = "Debuff"
L["Debuff Class"] = "Schwchungszauber Klasse"
L["Debuff Class Icon"] = "Schwchungszauber Klassensymbol"
L["Debuff Type"] = "Schwchungszaubertyp"
--[[Translation missing --]]
L["Debug Log contains more than 1000 entries"] = "Debug Log contains more than 1000 entries"
--[[Translation missing --]]
L["Debug Logging enabled"] = "Debug Logging enabled"
--[[Translation missing --]]
L["Debug Logging enabled for '%s'"] = "Debug Logging enabled for '%s'"
--[[Translation missing --]]
L["Defensive Stats"] = "Defensive Stats"
L["Deflect"] = "Umlenken"
--[[Translation missing --]]
L["Delve"] = "Delve"
L["Desaturate"] = "Entsttigen"
L["Desaturate Background"] = "Hintergrund entsttigen"
L["Desaturate Foreground"] = "Vordergrund entsttigen"
L["Descending"] = "Absteigend"
L["Description"] = "Beschreibung"
L["Dest Raid Mark"] = "Zielmarkierung"
--[[Translation missing --]]
L["Destination Affiliation"] = "Destination Affiliation"
--[[Translation missing --]]
L["Destination GUID"] = "Destination GUID"
--[[Translation missing --]]
L["Destination Info"] = "Destination Info"
L["Destination Name"] = "Zielname"
--[[Translation missing --]]
L["Destination NPC Id"] = "Destination NPC Id"
--[[Translation missing --]]
L["Destination Object Type"] = "Destination Object Type"
--[[Translation missing --]]
L["Destination Reaction"] = "Destination Reaction"
L["Destination Unit"] = "Zieleinheit"
--[[Translation missing --]]
L["Destination unit's raid mark index"] = "Destination unit's raid mark index"
--[[Translation missing --]]
L["Destination unit's raid mark texture"] = "Destination unit's raid mark texture"
L["Difficulty"] = "Schwierigkeit"
--[[Translation missing --]]
L["Disable Spell Known Check"] = "Disable Spell Known Check"
--[[Translation missing --]]
L["Disabled"] = "Disabled"
--[[Translation missing --]]
L["Disabled feature %q"] = "Disabled feature %q"
--[[Translation missing --]]
L["Disabled Spell Known Check"] = "Disabled Spell Known Check"
--[[Translation missing --]]
L["Discovered"] = "Discovered"
L["Disease"] = "Krankheit"
L["Dispel"] = "Bannen (DISPEL)"
L["Dispel Failed"] = "Bannen fehlgeschlagen (DISPEL_FAILED)"
L["Display"] = "Anzeige"
L["Distance"] = "Distanz"
L["Do Not Disturb"] = "Bitte nicht stren"
L["Dodge"] = "Ausweichen (DODGE)"
L["Dodge (%)"] = "Ausweichen (%)"
--[[Translation missing --]]
L["Dodge Rating"] = "Dodge Rating"
L["Down"] = "Runter"
--[[Translation missing --]]
L["Down, then Centered Horizontal"] = "Down, then Centered Horizontal"
L["Down, then Left"] = "Runter, dann links"
L["Down, then Right"] = "Runter, dann rechts"
L["Dragonflight"] = "Dragonflight"
L["Drain"] = "Saugen (DRAIN)"
L["Dropdown Menu"] = "Auswahlmen"
--[[Translation missing --]]
L["Dumping table"] = "Dumping table"
--[[Translation missing --]]
L["Dungeon (Celestial)"] = "Dungeon (Celestial)"
L["Dungeon (Heroic)"] = "Dungeon (Heroisch)"
--[[Translation missing --]]
L["Dungeon (Mythic)"] = "Dungeon (Mythic)"
--[[Translation missing --]]
L["Dungeon (Mythic+)"] = "Dungeon (Mythic+)"
L["Dungeon (Normal)"] = "Dungeon (Normal)"
L["Dungeon (Timewalking)"] = "Dungeon (Zeitwanderung)"
L["Dungeons"] = "Instanzen"
L["Durability Damage"] = "Haltbarkeitsschaden (DURABILITY_DAMAGE)"
L["Durability Damage All"] = "Haltbarkeitsschaden, Alle (DURABILITY_DAMAGE_ALL)"
--[[Translation missing --]]
L["Duration"] = "Duration"
--[[Translation missing --]]
L["Duration Function"] = "Duration Function"
--[[Translation missing --]]
L["Duration Function (fallback state)"] = "Duration Function (fallback state)"
--[[Translation missing --]]
L["Ease In"] = "Ease In"
--[[Translation missing --]]
L["Ease In and Out"] = "Ease In and Out"
--[[Translation missing --]]
L["Ease Out"] = "Ease Out"
--[[Translation missing --]]
L["Ebonroc"] = "Ebonroc"
--[[Translation missing --]]
L["Eclipse Direction"] = "Eclipse Direction"
L["Edge"] = "Ecke"
--[[Translation missing --]]
L["Edge of Madness"] = "Edge of Madness"
--[[Translation missing --]]
L["Effective Spell Id"] = "Effective Spell Id"
--[[Translation missing --]]
L["Elide"] = "Elide"
L["Elite"] = "Elite"
L["Emote"] = "Emote"
--[[Translation missing --]]
L["Empower Cast End"] = "Empower Cast End"
--[[Translation missing --]]
L["Empower Cast Interrupt"] = "Empower Cast Interrupt"
--[[Translation missing --]]
L["Empower Cast Start"] = "Empower Cast Start"
--[[Translation missing --]]
L["Empowered"] = "Empowered"
--[[Translation missing --]]
L["Empowered 1"] = "Empowered 1"
--[[Translation missing --]]
L["Empowered 2"] = "Empowered 2"
--[[Translation missing --]]
L["Empowered 3"] = "Empowered 3"
--[[Translation missing --]]
L["Empowered 4"] = "Empowered 4"
--[[Translation missing --]]
L["Empowered 5"] = "Empowered 5"
--[[Translation missing --]]
L["Empowered Cast"] = "Empowered Cast"
--[[Translation missing --]]
L["Empowered Cast Fully Charged"] = "Empowered Cast Fully Charged"
--[[Translation missing --]]
L["Empowered Fully Charged"] = "Empowered Fully Charged"
L["Empty"] = "Leer"
--[[Translation missing --]]
L["Enabled feature %q"] = "Enabled feature %q"
--[[Translation missing --]]
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "Enables (incorrect) round down of seconds, which was the previous default behavior."
--[[Translation missing --]]
L["Enchant Applied"] = "Enchant Applied"
--[[Translation missing --]]
L["Enchant Found"] = "Enchant Found"
--[[Translation missing --]]
L["Enchant ID"] = "Enchant ID"
--[[Translation missing --]]
L["Enchant Missing"] = "Enchant Missing"
--[[Translation missing --]]
L["Enchant Name or ID"] = "Enchant Name or ID"
--[[Translation missing --]]
L["Enchant Removed"] = "Enchant Removed"
--[[Translation missing --]]
L["Enchanted"] = "Enchanted"
--[[Translation missing --]]
L["Encounter ID(s)"] = "Encounter ID(s)"
L["Energize"] = "Aufladen (ENERGIZE)"
L["Enrage"] = "Wut"
--[[Translation missing --]]
L["Enter a name or a spellId"] = "Enter a name or a spellId"
L["Entering"] = "Betreten"
L["Entering/Leaving Combat"] = "Kampf Betreten/Verlassen"
--[[Translation missing --]]
L["Entering/Leaving Encounter"] = "Entering/Leaving Encounter"
L["Entry Order"] = "Eintragsreihenfolge"
L["Environment Type"] = "Umgebungstyp"
L["Environmental"] = "Umgebung (ENVIRONMENTAL)"
--[[Translation missing --]]
L["Equipment"] = "Equipment"
L["Equipment Set"] = "Ausrstungsset"
L["Equipment Set Equipped"] = "Angelegtes Ausrstungsset"
L["Equipment Slot"] = "Ausrstungsplatz"
L["Equipped"] = "Angelegt"
L["Error"] = "Fehler"
--[[Translation missing --]]
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Error decoding."] = "Error decoding."
--[[Translation missing --]]
L["Error decompressing"] = "Error decompressing"
--[[Translation missing --]]
L["Error decompressing. This doesn't look like a WeakAuras import."] = "Error decompressing. This doesn't look like a WeakAuras import."
--[[Translation missing --]]
L["Error deserializing"] = "Error deserializing"
L["Error Frame"] = "Fehlerfenster"
--[[Translation missing --]]
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "ERROR in '%s' unknown or incompatible sub element type '%s'"
--[[Translation missing --]]
L["Error in Aura '%s'"] = "Error in Aura '%s'"
--[[Translation missing --]]
L["Error not receiving display information from %s"] = "Error not receiving display information from %s"
--[[Translation missing --]]
L["Essence"] = "Essence"
--[[Translation missing --]]
L["Essence #1"] = "Essence #1"
--[[Translation missing --]]
L["Essence #2"] = "Essence #2"
--[[Translation missing --]]
L["Essence #3"] = "Essence #3"
--[[Translation missing --]]
L["Essence #4"] = "Essence #4"
--[[Translation missing --]]
L["Essence #5"] = "Essence #5"
--[[Translation missing --]]
L["Essence #6"] = "Essence #6"
L["Evade"] = "Entkommen (EVADE)"
L["Event"] = "Ereignis"
L["Event(s)"] = "Ereignis(se)"
L["Every Frame"] = "Bei jedem OnUpdate"
--[[Translation missing --]]
L["Every Frame (High CPU usage)"] = "Every Frame (High CPU usage)"
--[[Translation missing --]]
L["Evoker Essence"] = "Evoker Essence"
--[[Translation missing --]]
L["Exact Spell ID(s)"] = "Exact Spell ID(s)"
--[[Translation missing --]]
L["Execute Conditions"] = "Execute Conditions"
--[[Translation missing --]]
L["Experience (%)"] = "Experience (%)"
--[[Translation missing --]]
L["Expertise Bonus"] = "Expertise Bonus"
--[[Translation missing --]]
L["Expertise Rating"] = "Expertise Rating"
--[[Translation missing --]]
L["Extend Outside"] = "Extend Outside"
L["Extra Amount"] = "Extrabetrag"
L["Extra Attacks"] = "Extraangriffe (EXTRA_ATTACKS)"
--[[Translation missing --]]
L["Extra Spell Id"] = "Extra Spell Id"
L["Extra Spell Name"] = "Extra-Zaubername"
L["Faction"] = "Fraktion"
L["Faction Name"] = "Fraktionsname"
L["Faction Reputation"] = "Fraktionsruf"
--[[Translation missing --]]
L["Fade Animation"] = "Fade Animation"
L["Fade In"] = "Einblenden"
L["Fade Out"] = "Ausblenden"
L["Fail Alert"] = "Warnung fr Fehlschlag"
L["False"] = "Nicht Zutrifft"
--[[Translation missing --]]
L["Fankriss the Unyielding"] = "Fankriss the Unyielding"
--[[Translation missing --]]
L["Feature %q is already disabled"] = "Feature %q is already disabled"
--[[Translation missing --]]
L["Feature %q is already enabled"] = "Feature %q is already enabled"
--[[Translation missing --]]
L["Fetch Absorb"] = "Fetch Absorb"
--[[Translation missing --]]
L["Fetch Heal Absorb"] = "Fetch Heal Absorb"
--[[Translation missing --]]
L["Fetch Legendary Power"] = "Fetch Legendary Power"
--[[Translation missing --]]
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "Fetches the name and icon of the Legendary Power that matches this bonus id."
--[[Translation missing --]]
L["Fill Area"] = "Fill Area"
--[[Translation missing --]]
L["Filter messages with format <message>"] = "Filter messages with format <message>"
L["Fire Resistance"] = "Feuerwiderstand"
--[[Translation missing --]]
L["Firemaw"] = "Firemaw"
--[[Translation missing --]]
L["First"] = "First"
--[[Translation missing --]]
L["First Value of Tooltip Text"] = "First Value of Tooltip Text"
L["Fixed"] = "Fixiert"
--[[Translation missing --]]
L["Fixed Names"] = "Fixed Names"
L["Fixed Size"] = "Feste Gre"
--[[Translation missing --]]
L["Flamegor"] = "Flamegor"
L["Flash"] = "Aufblitzen"
L["Flex Raid"] = "Flexibler Schlachtzug"
L["Flip"] = "Umdrehen"
L["Floor"] = "Flur"
L["Focus"] = "Fokus"
--[[Translation missing --]]
L["Follower Dungeon"] = "Follower Dungeon"
--[[Translation missing --]]
L["Font"] = "Font"
L["Font Size"] = "Schriftgre"
--[[Translation missing --]]
L["Forbidden function or table: %s"] = "Forbidden function or table: %s"
L["Foreground"] = "Vordergrund"
L["Foreground Color"] = "Vordergrundfarbe"
L["Form"] = "Form"
--[[Translation missing --]]
L["Format"] = "Format"
--[[Translation missing --]]
L["Format Gold"] = "Format Gold"
--[[Translation missing --]]
L["Formats |cFFFFCC00%unit|r"] = "Formats |cFFFFCC00%unit|r"
--[[Translation missing --]]
L["Formats Player's |cFFFFCC00%guid|r"] = "Formats Player's |cFFFFCC00%guid|r"
L["Forward"] = "Vorwrts"
--[[Translation missing --]]
L["Forward, Reverse Loop"] = "Forward, Reverse Loop"
--[[Translation missing --]]
L["Fourth Value of Tooltip Text"] = "Fourth Value of Tooltip Text"
--[[Translation missing --]]
L["Frame Selector"] = "Frame Selector"
L["Frequency"] = "Hufigkeit"
L["Friendly"] = "Freundlich"
L["Friendly Fire"] = "Eigenbeschuss"
--[[Translation missing --]]
L["Friendship Max Rank"] = "Friendship Max Rank"
--[[Translation missing --]]
L["Friendship Rank"] = "Friendship Rank"
--[[Translation missing --]]
L["Friendship Reputation"] = "Friendship Reputation"
--[[Translation missing --]]
L["Frost"] = "Frost"
L["Frost Resistance"] = "Frostwiderstand"
--[[Translation missing --]]
L["Frost Rune #1"] = "Frost Rune #1"
--[[Translation missing --]]
L["Frost Rune #2"] = "Frost Rune #2"
L["Full"] = "Voll"
--[[Translation missing --]]
L["Full Region"] = "Full Region"
L["Full/Empty"] = "Voll/Leer"
--[[Translation missing --]]
L["Gahz'ranka"] = "Gahz'ranka"
L["Gained"] = "Erhalten "
--[[Translation missing --]]
L["Garr"] = "Garr"
--[[Translation missing --]]
L["Gehennas"] = "Gehennas"
--[[Translation missing --]]
L["General"] = "General"
--[[Translation missing --]]
L["General Rajaxx"] = "General Rajaxx"
--[[Translation missing --]]
L["GetNameAndIcon Function (fallback state)"] = "GetNameAndIcon Function (fallback state)"
L["Glancing"] = "Gestreift (GLANCING)"
L["Global Cooldown"] = "Globale Abklingzeit"
L["Glow"] = "Leuchten"
--[[Translation missing --]]
L["Glow External Element"] = "Glow External Element"
--[[Translation missing --]]
L["Gluth"] = "Gluth"
--[[Translation missing --]]
L["Glyph"] = "Glyph"
--[[Translation missing --]]
L["Gold"] = "Gold"
--[[Translation missing --]]
L["Golemagg the Incinerator"] = "Golemagg the Incinerator"
--[[Translation missing --]]
L["Gothik the Harvester"] = "Gothik the Harvester"
L["Gradient"] = "Gradient"
--[[Translation missing --]]
L["Gradient Enabled"] = "Gradient Enabled"
--[[Translation missing --]]
L["Gradient End"] = "Gradient End"
--[[Translation missing --]]
L["Gradient Orientation"] = "Gradient Orientation"
L["Gradient Pulse"] = "Gradient Pulse"
--[[Translation missing --]]
L["Grand Widow Faerlina"] = "Grand Widow Faerlina"
--[[Translation missing --]]
L["Grid"] = "Grid"
--[[Translation missing --]]
L["Grobbulus"] = "Grobbulus"
L["Group"] = "Gruppe"
L["Group Arrangement"] = "Gruppenanordnung"
--[[Translation missing --]]
L["Group Leader/Assist"] = "Group Leader/Assist"
--[[Translation missing --]]
L["Group Size"] = "Group Size"
--[[Translation missing --]]
L["Group Type"] = "Group Type"
L["Grow"] = "Wachsen"
L["GTFO Alert"] = "GTFO-Warnung"
L["Guardian"] = "Wchter"
L["Guild"] = "Gilde"
--[[Translation missing --]]
L["Hakkar"] = "Hakkar"
--[[Translation missing --]]
L["Hardcore"] = "Hardcore"
L["Has Target"] = "Hat Ziel"
L["Has Vehicle UI"] = "Hat Fahrzeug-UI"
L["HasPet"] = "mit aktivem Begleiter"
L["Haste (%)"] = "Tempo (%)"
L["Haste Rating"] = "Tempowertung"
L["Heal"] = "Heilen"
--[[Translation missing --]]
L["Heal Absorb"] = "Heal Absorb"
--[[Translation missing --]]
L["Heal Absorbed"] = "Heal Absorbed"
L["Health"] = "Lebenspunkte"
L["Health (%)"] = "Lebenspunkte (%)"
--[[Translation missing --]]
L["Health Deficit"] = "Health Deficit"
--[[Translation missing --]]
L["Heigan the Unclean"] = "Heigan the Unclean"
L["Height"] = "Hhe"
--[[Translation missing --]]
L["Hero Talent"] = "Hero Talent"
--[[Translation missing --]]
L["Heroic Party"] = "Heroic Party"
L["Hide"] = "Verbergen"
--[[Translation missing --]]
L["Hide 0 cooldowns"] = "Hide 0 cooldowns"
--[[Translation missing --]]
L["Hide Timer Text"] = "Hide Timer Text"
L["High Damage"] = "Hoher Schaden"
--[[Translation missing --]]
L["High Priest Thekal"] = "High Priest Thekal"
--[[Translation missing --]]
L["High Priest Venoxis"] = "High Priest Venoxis"
--[[Translation missing --]]
L["High Priestess Arlokk"] = "High Priestess Arlokk"
--[[Translation missing --]]
L["High Priestess Jeklik"] = "High Priestess Jeklik"
--[[Translation missing --]]
L["High Priestess Mar'li"] = "High Priestess Mar'li"
L["Higher Than Tank"] = "Hher als der Tank"
--[[Translation missing --]]
L["Highest Spell Id"] = "Highest Spell Id"
--[[Translation missing --]]
L["Hit (%)"] = "Hit (%)"
--[[Translation missing --]]
L["Hit Rating"] = "Hit Rating"
L["Holy Resistance"] = "Heiligwiderstand"
L["Horde"] = "Horde"
--[[Translation missing --]]
L["Horizontal"] = "Horizontal"
L["Hostile"] = "Feindlich"
L["Hostility"] = "Gesinnung"
L["Humanoid"] = "Humanoid"
--[[Translation missing --]]
L["Hybrid"] = "Hybrid"
L["Icon"] = "Symbol"
--[[Translation missing --]]
L["Icon Function"] = "Icon Function"
--[[Translation missing --]]
L["Icon Function (fallback state)"] = "Icon Function (fallback state)"
--[[Translation missing --]]
L["Id"] = "Id"
--[[Translation missing --]]
L["ID"] = "ID"
--[[Translation missing --]]
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"
--[[Translation missing --]]
L["Ignore Dead"] = "Ignore Dead"
--[[Translation missing --]]
L["Ignore Disconnected"] = "Ignore Disconnected"
L["Ignore Rune CD"] = "Runen-CD ignorieren"
--[[Translation missing --]]
L["Ignore Rune CDs"] = "Ignore Rune CDs"
--[[Translation missing --]]
L["Ignore Self"] = "Ignore Self"
--[[Translation missing --]]
L["Ignore Spell Cooldown/Charges"] = "Ignore Spell Cooldown/Charges"
--[[Translation missing --]]
L["Ignore Spell Override"] = "Ignore Spell Override"
L["Immune"] = "Immun (IMMUNE)"
L["Important"] = "Wichtig"
--[[Translation missing --]]
L["Importing will start after combat ends."] = "Importing will start after combat ends."
L["In Combat"] = "im Kampf"
L["In Encounter"] = "im Bosskampf"
L["In Group"] = "In Gruppe"
--[[Translation missing --]]
L["In Party"] = "In Party"
L["In Pet Battle"] = "im Haustierkampf"
L["In Raid"] = "Im Schlachtzug"
--[[Translation missing --]]
L["In Range"] = "In Range"
L["In Vehicle"] = "im Fahrzeug"
--[[Translation missing --]]
L["In War Mode"] = "In War Mode"
L["Include Bank"] = "Bank einbeziehen"
L["Include Charges"] = "Aufladungen einbeziehen"
--[[Translation missing --]]
L["Include Death Runes"] = "Include Death Runes"
--[[Translation missing --]]
L["Include Pets"] = "Include Pets"
--[[Translation missing --]]
L["Include War Band Bank"] = "Include War Band Bank"
L["Incoming Heal"] = "Eingehende Heilung"
--[[Translation missing --]]
L["Increase Precision Below"] = "Increase Precision Below"
--[[Translation missing --]]
L["Increases by one per stage or intermission."] = "Increases by one per stage or intermission."
--[[Translation missing --]]
L["Information"] = "Information"
L["Inherited"] = "Vererbt"
L["Instakill"] = "Sofortiger Tod (INSTAKILL)"
--[[Translation missing --]]
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "Install the addons BugSack and BugGrabber for detailed error logs."
L["Instance"] = "Instanz"
L["Instance Difficulty"] = "Instanzschwierigkeit"
--[[Translation missing --]]
L["Instance Id"] = "Instance Id"
--[[Translation missing --]]
L["Instance ID"] = "Instance ID"
--[[Translation missing --]]
L["Instance Info"] = "Instance Info"
--[[Translation missing --]]
L["Instance Name"] = "Instance Name"
--[[Translation missing --]]
L["Instance Size Type"] = "Instance Size Type"
L["Instance Type"] = "Instanztyp"
--[[Translation missing --]]
L["Instructor Razuvious"] = "Instructor Razuvious"
--[[Translation missing --]]
L["Insufficient Resources"] = "Insufficient Resources"
L["Intellect"] = "Intelligenz"
L["Interrupt"] = "Unterbrechen (INTERRUPT)"
--[[Translation missing --]]
L["Interrupt School"] = "Interrupt School"
--[[Translation missing --]]
L["Interrupted School Text"] = "Interrupted School Text"
L["Interruptible"] = "Unterbrechbar"
L["Inverse"] = "Invertieren"
--[[Translation missing --]]
L["Inverse Pet Behavior"] = "Inverse Pet Behavior"
--[[Translation missing --]]
L["Is Away from Keyboard"] = "Is Away from Keyboard"
--[[Translation missing --]]
L["Is Current Specialization"] = "Is Current Specialization"
--[[Translation missing --]]
L["Is Death Rune"] = "Is Death Rune"
L["Is Exactly"] = "Strikter Vergleich"
L["Is Moving"] = "am Bewegen"
L["Is Off Hand"] = "Ist Schildhand"
--[[Translation missing --]]
L["Is Paragon Reputation"] = "Is Paragon Reputation"
--[[Translation missing --]]
L["Is Paused"] = "Is Paused"
L["is useable"] = "benutzbar"
--[[Translation missing --]]
L["Is Weekly Renown Capped"] = "Is Weekly Renown Capped"
--[[Translation missing --]]
L["Island Expedition (Heroic)"] = "Island Expedition (Heroic)"
--[[Translation missing --]]
L["Island Expedition (Mythic)"] = "Island Expedition (Mythic)"
--[[Translation missing --]]
L["Island Expedition (Normal)"] = "Island Expedition (Normal)"
--[[Translation missing --]]
L["Island Expeditions (PvP)"] = "Island Expeditions (PvP)"
L["Item"] = "Gegenstand"
--[[Translation missing --]]
L["Item Bonus Id"] = "Item Bonus Id"
--[[Translation missing --]]
L["Item Bonus Id Equipped"] = "Item Bonus Id Equipped"
L["Item Count"] = "Gegenstandsanzahl"
L["Item Equipped"] = "Gegenstand angelegt"
--[[Translation missing --]]
L["Item Id"] = "Item Id"
--[[Translation missing --]]
L["Item in Range"] = "Item in Range"
--[[Translation missing --]]
L["Item Name"] = "Item Name"
L["Item Set Equipped"] = "Gegenstandsset angelegt"
--[[Translation missing --]]
L["Item Set Id"] = "Item Set Id"
--[[Translation missing --]]
L["Item Slot"] = "Item Slot"
--[[Translation missing --]]
L["Item Slot String"] = "Item Slot String"
--[[Translation missing --]]
L["Item Type"] = "Item Type"
--[[Translation missing --]]
L["Item Type Equipped"] = "Item Type Equipped"
--[[Translation missing --]]
L["ItemId"] = "ItemId"
--[[Translation missing --]]
L["Jin'do the Hexxer"] = "Jin'do the Hexxer"
--[[Translation missing --]]
L["Journal Stage"] = "Journal Stage"
--[[Translation missing --]]
L["Kazzak"] = "Kazzak"
--[[Translation missing --]]
L["Keep Inside"] = "Keep Inside"
--[[Translation missing --]]
L["Kel'Thuzad"] = "Kel'Thuzad"
--[[Translation missing --]]
L["Kurinnaxx"] = "Kurinnaxx"
--[[Translation missing --]]
L["Large"] = "Large"
--[[Translation missing --]]
L["Latency"] = "Latency"
--[[Translation missing --]]
L["Leader"] = "Leader"
--[[Translation missing --]]
L["Least remaining time"] = "Least remaining time"
L["Leaving"] = "Verlassen"
L["Leech"] = "Saugen (LEECH)"
L["Leech (%)"] = "Lebensraub (%)"
L["Leech Rating"] = "Lebensraubswertung"
L["Left"] = "Links"
L["Left to Right"] = "Links -> Rechts"
--[[Translation missing --]]
L["Left, then Centered Vertical"] = "Left, then Centered Vertical"
L["Left, then Down"] = "Links, dann runter"
L["Left, then Up"] = "Links, dann hoch"
--[[Translation missing --]]
L["Legacy Looking for Raid"] = "Legacy Looking for Raid"
--[[Translation missing --]]
L["Legacy RGB Gradient"] = "Legacy RGB Gradient"
--[[Translation missing --]]
L["Legacy RGB Gradient Pulse"] = "Legacy RGB Gradient Pulse"
--[[Translation missing --]]
L["Legion"] = "Legion"
L["Length"] = "Lnge"
L["Level"] = "Stufe"
--[[Translation missing --]]
L["LibSharedMedia"] = "LibSharedMedia"
--[[Translation missing --]]
L["Lillian Voss"] = "Lillian Voss"
--[[Translation missing --]]
L["Limited"] = "Limited"
--[[Translation missing --]]
L["Linear Texture"] = "Linear Texture"
--[[Translation missing --]]
L["Lines & Particles"] = "Lines & Particles"
L["Load Conditions"] = "Ladebedingungen"
--[[Translation missing --]]
L["Loatheb"] = "Loatheb"
--[[Translation missing --]]
L["Location"] = "Location"
--[[Translation missing --]]
L["Looking for Raid"] = "Looking for Raid"
L["Loop"] = "Schleife"
--[[Translation missing --]]
L["Loot"] = "Loot"
--[[Translation missing --]]
L["Loot Specialization"] = "Loot Specialization"
--[[Translation missing --]]
L["Loot Specialization Id"] = "Loot Specialization Id"
--[[Translation missing --]]
L["Loot Specialization Name"] = "Loot Specialization Name"
--[[Translation missing --]]
L["Lorewalking"] = "Lorewalking"
L["Lost"] = "Verloren"
L["Low Damage"] = "Niedriger Schaden"
L["Lower Than Tank"] = "Niedriger als der Tank"
--[[Translation missing --]]
L["Lowest Spell Id"] = "Lowest Spell Id"
--[[Translation missing --]]
L["Lua error"] = "Lua error"
--[[Translation missing --]]
L["Lua error in Aura '%s': %s"] = "Lua error in Aura '%s': %s"
--[[Translation missing --]]
L["Lucifron"] = "Lucifron"
--[[Translation missing --]]
L["Maexxna"] = "Maexxna"
L["Magic"] = "Magie"
--[[Translation missing --]]
L["Magmadar"] = "Magmadar"
--[[Translation missing --]]
L["Main Character"] = "Main Character"
--[[Translation missing --]]
L["Main Stat"] = "Main Stat"
--[[Translation missing --]]
L["Majordomo Executus"] = "Majordomo Executus"
--[[Translation missing --]]
L["Malformed WeakAuras link"] = "Malformed WeakAuras link"
--[[Translation missing --]]
L["Manual"] = "Manual"
--[[Translation missing --]]
L["Manual Icon"] = "Manual Icon"
L["Manual Rotation"] = "Manuelle Rotation"
L["Marked First"] = "Zuerst markiert"
L["Marked Last"] = "Zuletzt markiert"
--[[Translation missing --]]
L["Mason"] = "Mason"
L["Master"] = "Master"
L["Mastery (%)"] = "Meisterschaft (%)"
L["Mastery Rating"] = "Meisterschaftswertung"
--[[Translation missing --]]
L["Match Count"] = "Match Count"
--[[Translation missing --]]
L["Match Count per Unit"] = "Match Count per Unit"
L["Matches (Pattern)"] = "Abgleichen (Muster)"
--[[Translation missing --]]
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=]
--[[Translation missing --]]
L["Max Char "] = "Max Char "
--[[Translation missing --]]
L["Max Char"] = "Max Char"
--[[Translation missing --]]
L["Max Charges"] = "Max Charges"
--[[Translation missing --]]
L["Max Health"] = "Max Health"
--[[Translation missing --]]
L["Max Power"] = "Max Power"
--[[Translation missing --]]
L["Max Quantity"] = "Max Quantity"
--[[Translation missing --]]
L["Maximum Estimate"] = "Maximum Estimate"
--[[Translation missing --]]
L["Maximum Progress"] = "Maximum Progress"
--[[Translation missing --]]
L["Maximum time used on a single frame"] = "Maximum time used on a single frame"
--[[Translation missing --]]
L["Media"] = "Media"
--[[Translation missing --]]
L["Medium"] = "Medium"
--[[Translation missing --]]
L["Melee"] = "Melee"
--[[Translation missing --]]
L["Melee Haste (%)"] = "Melee Haste (%)"
L["Message"] = "Nachricht"
L["Message Type"] = "Nachrichtentyp"
L["Message type:"] = "Nachrichtentyp:"
--[[Translation missing --]]
L["Meta Data"] = "Meta Data"
--[[Translation missing --]]
L["Mine"] = "Mine"
--[[Translation missing --]]
L["Minimum Estimate"] = "Minimum Estimate"
--[[Translation missing --]]
L["Minimum Progress"] = "Minimum Progress"
--[[Translation missing --]]
L["Minus (Small Nameplate)"] = "Minus (Small Nameplate)"
L["Mirror"] = "Spiegel"
--[[Translation missing --]]
L["Miscellaneous"] = "Miscellaneous"
L["Miss"] = "Verfehlen"
L["Miss Type"] = "Verfehlengrund"
L["Missed"] = "Verfehlt (MISSED)"
L["Missing"] = "Fehlend"
--[[Translation missing --]]
L["Mists of Pandaria"] = "Mists of Pandaria"
--[[Translation missing --]]
L["Moam"] = "Moam"
--[[Translation missing --]]
L["Model"] = "Model"
--[[Translation missing --]]
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"
--[[Translation missing --]]
L["Modernize"] = "Modernize"
L["Molten Core"] = "Geschmolzener Kern"
--[[Translation missing --]]
L["Money"] = "Money"
L["Monochrome"] = "Einfarbig"
L["Monochrome Outline"] = "Graustufenkontur"
L["Monochrome Thick Outline"] = "Einfarbige dicke Kontur"
L["Monster Emote"] = "Monster-Emote"
--[[Translation missing --]]
L["Monster Party"] = "Monster Party"
L["Monster Say"] = "Monster Sagen"
L["Monster Whisper"] = "Monster Flstern"
L["Monster Yell"] = "NPC-Schrei"
--[[Translation missing --]]
L["Moon"] = "Moon"
--[[Translation missing --]]
L["Most remaining time"] = "Most remaining time"
L["Mounted"] = "am Reiten"
L["Mouse Cursor"] = "Mauszeiger"
--[[Translation missing --]]
L["Movement Speed Rating"] = "Movement Speed Rating"
L["Multi-target"] = "Mehrfachziel"
--[[Translation missing --]]
L["Mythic Keystone"] = "Mythic Keystone"
--[[Translation missing --]]
L["Mythic+ Affix"] = "Mythic+ Affix"
L["Name"] = "Name"
--[[Translation missing --]]
L["Name Function"] = "Name Function"
--[[Translation missing --]]
L["Name Function (fallback state)"] = "Name Function (fallback state)"
--[[Translation missing --]]
L["Name of Caster's Target"] = "Name of Caster's Target"
--[[Translation missing --]]
L["Name of the (sub-)zone currently shown above the minimap."] = "Name of the (sub-)zone currently shown above the minimap."
--[[Translation missing --]]
L["Name(s)"] = "Name(s)"
--[[Translation missing --]]
L["Name/Realm of Caster's Target"] = "Name/Realm of Caster's Target"
--[[Translation missing --]]
L["Nameplate"] = "Nameplate"
--[[Translation missing --]]
L["Nameplates"] = "Nameplates"
--[[Translation missing --]]
L["Names of affected Players"] = "Names of affected Players"
--[[Translation missing --]]
L["Names of unaffected Players"] = "Names of unaffected Players"
L["Nature Resistance"] = "Naturwiderstand"
--[[Translation missing --]]
L["Naxxramas"] = "Naxxramas"
--[[Translation missing --]]
L["Nefarian"] = "Nefarian"
L["Neutral"] = "Neutral"
L["Never"] = "Nie"
L["Next Combat"] = "Nchster Kampf"
L["Next Encounter"] = "Nchstes Gefecht"
--[[Translation missing --]]
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
--[[Translation missing --]]
L["No Extend"] = "No Extend"
L["No Instance"] = "Keine Instanz"
--[[Translation missing --]]
L["No Profiling information saved."] = "No Profiling information saved."
--[[Translation missing --]]
L["No Progress Information available."] = "No Progress Information available."
L["None"] = "Keine(r)"
L["Non-player Character"] = "Nicht-Spieler-Charakter (NPC)"
L["Normal"] = "Normal"
--[[Translation missing --]]
L["Normal Party"] = "Normal Party"
L["Not in Group"] = "In keiner Gruppe"
--[[Translation missing --]]
L["Not in Smart Group"] = "Not in Smart Group"
L["Not on Cooldown"] = "Nicht auf Abklingzeit"
L["Not On Threat Table"] = "Nicht bedroht"
--[[Translation missing --]]
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."
--[[Translation missing --]]
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."
--[[Translation missing --]]
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "Note: The available text replacements for multi triggers match the normal triggers now."
--[[Translation missing --]]
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = "Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."
--[[Translation missing --]]
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "Note: This trigger relies on the WoW API, which returns incorrect information in some cases."
--[[Translation missing --]]
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"
--[[Translation missing --]]
L["Noth the Plaguebringer"] = "Noth the Plaguebringer"
L["NPC"] = "NSC"
L["Npc ID"] = "Nsc ID"
L["Number"] = "Nummer"
L["Number Affected"] = "Betroffene Anzahl"
L["Object"] = "Objekt"
--[[Translation missing --]]
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=]
L["Officer"] = "Offizier"
--[[Translation missing --]]
L["Offset from progress"] = "Offset from progress"
--[[Translation missing --]]
L["Offset Timer"] = "Offset Timer"
--[[Translation missing --]]
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Old Blizzard (2h | 3m | 10s | 2.4)"
L["On Cooldown"] = "Auf Abklingzeit"
--[[Translation missing --]]
L["On Taxi"] = "On Taxi"
--[[Translation missing --]]
L["Only if on a different realm"] = "Only if on a different realm"
L["Only if Primary"] = "Nur falls Primr"
L["Onyxia"] = "Onyxia"
L["Opaque"] = "Deckend"
--[[Translation missing --]]
L["Option Group"] = "Option Group"
--[[Translation missing --]]
L["Options could not be loaded, the addon is %s"] = "Options could not be loaded, the addon is %s"
--[[Translation missing --]]
L["Options will finish loading after combat ends."] = "Options will finish loading after combat ends."
--[[Translation missing --]]
L["Options will open after the login process has completed."] = "Options will open after the login process has completed."
--[[Translation missing --]]
L["Or Talent"] = "Or Talent"
L["Orbit"] = "Orbit"
L["Orientation"] = "Ausrichtung"
--[[Translation missing --]]
L["Ossirian the Unscarred"] = "Ossirian the Unscarred"
--[[Translation missing --]]
L["Other"] = "Other"
--[[Translation missing --]]
L["Other Addons"] = "Other Addons"
--[[Translation missing --]]
L["Other Events"] = "Other Events"
--[[Translation missing --]]
L["Ouro"] = "Ouro"
L["Outline"] = "Kontur"
--[[Translation missing --]]
L["Over Energize"] = "Over Energize"
L["Overhealing"] = "berheilung"
L["Overkill"] = "Overkill"
--[[Translation missing --]]
L["Overlay %s"] = "Overlay %s"
--[[Translation missing --]]
L["Overlay Charged Combo Points"] = "Overlay Charged Combo Points"
--[[Translation missing --]]
L["Overlay Cost of Casts"] = "Overlay Cost of Casts"
--[[Translation missing --]]
L["Overlay Latency"] = "Overlay Latency"
--[[Translation missing --]]
L["Pad"] = "Pad"
--[[Translation missing --]]
L["Pad Mode"] = "Pad Mode"
--[[Translation missing --]]
L["Pad to"] = "Pad to"
--[[Translation missing --]]
L["Paragon Reputation"] = "Paragon Reputation"
--[[Translation missing --]]
L["Paragon Reward Pending"] = "Paragon Reward Pending"
--[[Translation missing --]]
L["Parent Frame"] = "Parent Frame"
--[[Translation missing --]]
L["Parent Zone"] = "Parent Zone"
L["Parry"] = "Parieren"
L["Parry (%)"] = "Parieren (%)"
L["Parry Rating"] = "Parierwertung"
L["Party"] = "Gruppe"
L["Party Kill"] = "Gruppen Tod (PARTY_KILL)"
--[[Translation missing --]]
L["Patchwerk"] = "Patchwerk"
--[[Translation missing --]]
L["Path of Ascension: Courage"] = "Path of Ascension: Courage"
--[[Translation missing --]]
L["Path of Ascension: Humility"] = "Path of Ascension: Humility"
--[[Translation missing --]]
L["Path of Ascension: Loyalty"] = "Path of Ascension: Loyalty"
--[[Translation missing --]]
L["Path of Ascension: Wisdom"] = "Path of Ascension: Wisdom"
L["Paused"] = "Pausiert"
L["Periodic Spell"] = "Periodischer Zauber (PERIODIC_SPELL)"
L["Personal Resource Display"] = "Persnliche Ressourcenanzeige"
L["Pet"] = "Begleiter"
L["Pet Behavior"] = "Begleiterverhalten"
--[[Translation missing --]]
L["Pet Specialization"] = "Pet Specialization"
L["Pet Spell"] = "Begleiterzauber"
--[[Translation missing --]]
L["Pets only"] = "Pets only"
L["Phase"] = "Phase"
--[[Translation missing --]]
L["Pixel Glow"] = "Pixel Glow"
--[[Translation missing --]]
L["Placement"] = "Placement"
--[[Translation missing --]]
L["Placement %i"] = "Placement %i"
--[[Translation missing --]]
L["Placement Mode"] = "Placement Mode"
L["Play"] = "Abspielen"
L["Player"] = "Spieler (Selbst)"
L["Player Character"] = "Spieler-Charakter (PC)"
L["Player Class"] = "Spielerklasse"
--[[Translation missing --]]
L["Player Effective Level"] = "Player Effective Level"
--[[Translation missing --]]
L["Player Experience"] = "Player Experience"
L["Player Faction"] = "Spielerfraktion"
L["Player Level"] = "Spielerstufe"
--[[Translation missing --]]
L["Player Location ID(s)"] = "Player Location ID(s)"
--[[Translation missing --]]
L["Player Money"] = "Player Money"
--[[Translation missing --]]
L["Player Name/Realm"] = "Player Name/Realm"
L["Player Race"] = "Spielervolk"
L["Player(s) Affected"] = "Betroffene Spieler"
L["Player(s) Not Affected"] = "Nicht betroffene Spieler"
--[[Translation missing --]]
L["Player/Unit Info"] = "Player/Unit Info"
--[[Translation missing --]]
L["Players and Pets"] = "Players and Pets"
L["Poison"] = "Gift"
L["Power"] = "Ressource"
L["Power (%)"] = "Ressource (%)"
--[[Translation missing --]]
L["Power Deficit"] = "Power Deficit"
L["Power Type"] = "Ressourcentyp"
--[[Translation missing --]]
L["Precision"] = "Precision"
L["Preset"] = "Standard"
--[[Translation missing --]]
L["Primary Stats"] = "Primary Stats"
--[[Translation missing --]]
L["Princess Huhuran"] = "Princess Huhuran"
--[[Translation missing --]]
L["Print Profiling Results"] = "Print Profiling Results"
--[[Translation missing --]]
L["Proc Glow"] = "Proc Glow"
--[[Translation missing --]]
L["Profiling already started."] = "Profiling already started."
--[[Translation missing --]]
L["Profiling automatically started."] = "Profiling automatically started."
--[[Translation missing --]]
L["Profiling not running."] = "Profiling not running."
--[[Translation missing --]]
L["Profiling started."] = "Profiling started."
--[[Translation missing --]]
L["Profiling started. It will end automatically in %d seconds"] = "Profiling started. It will end automatically in %d seconds"
--[[Translation missing --]]
L["Profiling still running, stop before trying to print."] = "Profiling still running, stop before trying to print."
--[[Translation missing --]]
L["Profiling stopped."] = "Profiling stopped."
--[[Translation missing --]]
L["Progress"] = "Progress"
--[[Translation missing --]]
L["Progress Source"] = "Progress Source"
L["Progress Total"] = "Totaler Fortschritt"
L["Progress Value"] = "Fortschrittswert"
--[[Translation missing --]]
L["Pull"] = "Pull"
L["Pulse"] = "Pulsieren"
L["PvP Flagged"] = "PvP aktiv"
L["PvP Talent selected"] = "Gewhltes PvP-Talent"
--[[Translation missing --]]
L["PvP Talent Selected"] = "PvP Talent Selected"
--[[Translation missing --]]
L["Quality Id"] = "Quality Id"
--[[Translation missing --]]
L["Quantity"] = "Quantity"
--[[Translation missing --]]
L["Quantity earned this week"] = "Quantity earned this week"
--[[Translation missing --]]
L["Quest Party"] = "Quest Party"
--[[Translation missing --]]
L["Queued Action"] = "Queued Action"
L["Radius"] = "Radius"
L["Ragnaros"] = "Ragnaros"
L["Raid"] = "Schlachtzug"
--[[Translation missing --]]
L["Raid (Heroic)"] = "Raid (Heroic)"
--[[Translation missing --]]
L["Raid (Mythic)"] = "Raid (Mythic)"
--[[Translation missing --]]
L["Raid (Normal)"] = "Raid (Normal)"
--[[Translation missing --]]
L["Raid (Timewalking)"] = "Raid (Timewalking)"
--[[Translation missing --]]
L["Raid Mark"] = "Raid Mark"
--[[Translation missing --]]
L["Raid Mark Icon"] = "Raid Mark Icon"
--[[Translation missing --]]
L["Raid Role"] = "Raid Role"
L["Raid Warning"] = "Schlachtzugswarnung"
L["Raids"] = "Schlachtzge"
L["Range"] = "Reichweite"
L["Range Check"] = "Reichweitencheck"
--[[Translation missing --]]
L["Ranged"] = "Ranged"
--[[Translation missing --]]
L["Rank"] = "Rank"
--[[Translation missing --]]
L["Rare"] = "Rare"
--[[Translation missing --]]
L["Rare Elite"] = "Rare Elite"
--[[Translation missing --]]
L["Rated Arena"] = "Rated Arena"
--[[Translation missing --]]
L["Rated Battleground"] = "Rated Battleground"
--[[Translation missing --]]
L["Raw Threat Percent"] = "Raw Threat Percent"
--[[Translation missing --]]
L["Razorgore the Untamed"] = "Razorgore the Untamed"
L["Ready Check"] = "Bereitschaftscheck"
--[[Translation missing --]]
L["Reagent Quality"] = "Reagent Quality"
--[[Translation missing --]]
L["Reagent Quality Texture"] = "Reagent Quality Texture"
L["Realm"] = "Realm"
--[[Translation missing --]]
L["Realm Name"] = "Realm Name"
--[[Translation missing --]]
L["Realm of Caster's Target"] = "Realm of Caster's Target"
--[[Translation missing --]]
L["Reborn Council"] = "Reborn Council"
--[[Translation missing --]]
L["Receiving %s Bytes"] = "Receiving %s Bytes"
L["Receiving display information"] = "Erhalte Anzeigeinformationen von %s"
L["Reflect"] = "Reflektieren (REFLECT)"
L["Region type %s not supported"] = "Regiontyp %s wird nicht untersttzt"
L["Relative"] = "Relativ"
--[[Translation missing --]]
L["Relative X-Offset"] = "Relative X-Offset"
--[[Translation missing --]]
L["Relative Y-Offset"] = "Relative Y-Offset"
L["Remaining Duration"] = "Verbleibende Dauer"
L["Remaining Time"] = "Verbleibende Zeit"
--[[Translation missing --]]
L["Remove Obsolete Auras"] = "Remove Obsolete Auras"
--[[Translation missing --]]
L["Renown Level"] = "Renown Level"
--[[Translation missing --]]
L["Renown Max Level"] = "Renown Max Level"
--[[Translation missing --]]
L["Renown Reputation"] = "Renown Reputation"
L["Repair"] = "Reparieren"
L["Repeat"] = "Wiederhole"
--[[Translation missing --]]
L["Report Summary"] = "Report Summary"
--[[Translation missing --]]
L["Reputation"] = "Reputation"
--[[Translation missing --]]
L["Reputation (%)"] = "Reputation (%)"
L["Requested display does not exist"] = "Angeforderte Anzeige existiert nicht"
L["Requested display not authorized"] = "Angeforderte Anzeige ist nicht autorisiert"
--[[Translation missing --]]
L["Requesting display information from %s ..."] = "Requesting display information from %s ..."
L["Require Valid Target"] = "Erfordert gltiges Ziel"
--[[Translation missing --]]
L["Requires syncing the specialization via LibSpecialization."] = "Requires syncing the specialization via LibSpecialization."
--[[Translation missing --]]
L["Resilience (%)"] = "Resilience (%)"
--[[Translation missing --]]
L["Resilience Rating"] = "Resilience Rating"
L["Resist"] = "Widerstehen"
--[[Translation missing --]]
L["Resistances"] = "Resistances"
L["Resisted"] = "Widerstanden (RESISTED)"
--[[Translation missing --]]
L["Rested"] = "Rested"
--[[Translation missing --]]
L["Rested Experience"] = "Rested Experience"
--[[Translation missing --]]
L["Rested Experience (%)"] = "Rested Experience (%)"
L["Resting"] = "am Erholen"
L["Resurrect"] = "Wiederbeleben"
--[[Translation missing --]]
L["Resurrect Pending"] = "Resurrect Pending"
L["Right"] = "Rechts"
L["Right to Left"] = "Rechts -> Links"
--[[Translation missing --]]
L["Right, then Centered Vertical"] = "Right, then Centered Vertical"
L["Right, then Down"] = "Rechts, dann runter"
L["Right, then Up"] = "Rechts, dann hoch"
L["Role"] = "Rolle"
--[[Translation missing --]]
L["Rollback snapshot is complete. Thank you for your patience!"] = "Rollback snapshot is complete. Thank you for your patience!"
--[[Translation missing --]]
L["Rotate Animation"] = "Rotate Animation"
L["Rotate Left"] = "Nach links rotieren"
L["Rotate Right"] = "Nach rechts rotieren"
--[[Translation missing --]]
L["Rotation"] = "Rotation"
--[[Translation missing --]]
L["Round"] = "Round"
--[[Translation missing --]]
L["Round Mode"] = "Round Mode"
L["Ruins of Ahn'Qiraj"] = "Ruinen von Ahn'Qiraj"
L["Run Custom Code"] = "Code ausfhren"
--[[Translation missing --]]
L["Run Speed (%)"] = "Run Speed (%)"
L["Rune"] = "Rune"
L["Rune #1"] = "Rune #1"
L["Rune #2"] = "Rune #2"
L["Rune #3"] = "Rune #3"
L["Rune #4"] = "Rune #4"
L["Rune #5"] = "Rune #5"
L["Rune #6"] = "Rune #6"
--[[Translation missing --]]
L["Rune Count"] = "Rune Count"
--[[Translation missing --]]
L["Rune Count - Blood"] = "Rune Count - Blood"
--[[Translation missing --]]
L["Rune Count - Frost"] = "Rune Count - Frost"
--[[Translation missing --]]
L["Rune Count - Unholy"] = "Rune Count - Unholy"
--[[Translation missing --]]
L["Sapphiron"] = "Sapphiron"
L["Say"] = "Sagen"
--[[Translation missing --]]
L["Scale"] = "Scale"
--[[Translation missing --]]
L["Scarlet Enclave"] = "Scarlet Enclave"
L["Scenario"] = "Szenario"
--[[Translation missing --]]
L["Scenario (Heroic)"] = "Scenario (Heroic)"
--[[Translation missing --]]
L["Scenario (Normal)"] = "Scenario (Normal)"
--[[Translation missing --]]
L["Screen"] = "Screen"
L["Screen/Parent Group"] = "Bildschirm/Elterngruppe"
--[[Translation missing --]]
L["Season of Discovery"] = "Season of Discovery"
--[[Translation missing --]]
L["Second"] = "Second"
--[[Translation missing --]]
L["Second Value of Tooltip Text"] = "Second Value of Tooltip Text"
--[[Translation missing --]]
L["Secondary Stats"] = "Secondary Stats"
L["Seconds"] = "Sekunden"
--[[Translation missing --]]
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Select Frame"] = "Frame auswhlen"
--[[Translation missing --]]
L["Select the type of timer to filter"] = "Select the type of timer to filter"
--[[Translation missing --]]
L["Selection Mode"] = "Selection Mode"
--[[Translation missing --]]
L["Separator"] = "Separator"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "Set IDs can be found on websites such as wowhead.com/cata/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/classic/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "Set IDs can be found on websites such as wowhead.com/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"
L["Shadow Resistance"] = "Schattenwiderstand"
--[[Translation missing --]]
L["Shadowlands"] = "Shadowlands"
L["Shake"] = "Beben"
--[[Translation missing --]]
L["Shazzrah"] = "Shazzrah"
--[[Translation missing --]]
L["Shift-Click to resume addon execution."] = "Shift-Click to resume addon execution."
L["Show"] = "Zeigen"
--[[Translation missing --]]
L["Show CD of Charge"] = "Show CD of Charge"
--[[Translation missing --]]
L["Show charged duration for empowered casts"] = "Show charged duration for empowered casts"
L["Show GCD"] = "GCD anzeigen"
L["Show Global Cooldown"] = "Globale Abklingzeit anzeigen"
L["Show Incoming Heal"] = "Eingehende Heilung zeigen"
--[[Translation missing --]]
L["Show Loss of Control"] = "Show Loss of Control"
--[[Translation missing --]]
L["Show On"] = "Show On"
--[[Translation missing --]]
L["Show Rested Overlay"] = "Show Rested Overlay"
L["Shrink"] = "Schrumpfen"
--[[Translation missing --]]
L["Silithid Royalty"] = "Silithid Royalty"
--[[Translation missing --]]
L["Silver"] = "Silver"
L["Simple"] = "Einfach"
--[[Translation missing --]]
L["Since Active"] = "Since Active"
--[[Translation missing --]]
L["Since Apply"] = "Since Apply"
--[[Translation missing --]]
L["Since Apply/Refresh"] = "Since Apply/Refresh"
--[[Translation missing --]]
L["Since Charge Gain"] = "Since Charge Gain"
--[[Translation missing --]]
L["Since Charge Lost"] = "Since Charge Lost"
--[[Translation missing --]]
L["Since Ready"] = "Since Ready"
--[[Translation missing --]]
L["Since Stack Gain"] = "Since Stack Gain"
--[[Translation missing --]]
L["Since Stack Lost"] = "Since Stack Lost"
L["Size & Position"] = "Gre & Position"
--[[Translation missing --]]
L["Skyriding"] = "Skyriding"
--[[Translation missing --]]
L["Slide Animation"] = "Slide Animation"
L["Slide from Bottom"] = "Von unten eingleiten"
L["Slide from Left"] = "Von links eingleiten"
L["Slide from Right"] = "Von rechts eingleiten"
L["Slide from Top"] = "Von oben eingleiten"
L["Slide to Bottom"] = "Nach unten entgleiten"
L["Slide to Left"] = "Nach links entgleiten"
L["Slide to Right"] = "Nach rechts entgleiten"
L["Slide to Top"] = "Nach oben entgleiten"
--[[Translation missing --]]
L["Slider"] = "Slider"
L["Small"] = "Klein"
--[[Translation missing --]]
L["Smart Group"] = "Smart Group"
--[[Translation missing --]]
L["Soft Enemy"] = "Soft Enemy"
--[[Translation missing --]]
L["Soft Friend"] = "Soft Friend"
--[[Translation missing --]]
L["Solistrasza"] = "Solistrasza"
L["Sound"] = "Ton"
--[[Translation missing --]]
L["Sound by Kit ID"] = "Sound by Kit ID"
--[[Translation missing --]]
L["Source"] = "Source"
--[[Translation missing --]]
L["Source Affiliation"] = "Source Affiliation"
--[[Translation missing --]]
L["Source GUID"] = "Source GUID"
--[[Translation missing --]]
L["Source Info"] = "Source Info"
L["Source Name"] = "Quellname"
--[[Translation missing --]]
L["Source NPC Id"] = "Source NPC Id"
--[[Translation missing --]]
L["Source Object Type"] = "Source Object Type"
L["Source Raid Mark"] = "Quellmarkierung"
--[[Translation missing --]]
L["Source Reaction"] = "Source Reaction"
L["Source Unit"] = "Quelleinheit"
--[[Translation missing --]]
L["Source Unit Name/Realm"] = "Source Unit Name/Realm"
--[[Translation missing --]]
L["Source unit's raid mark index"] = "Source unit's raid mark index"
--[[Translation missing --]]
L["Source unit's raid mark texture"] = "Source unit's raid mark texture"
--[[Translation missing --]]
L["Space"] = "Space"
L["Spacing"] = "Abstand"
--[[Translation missing --]]
L["Spark"] = "Spark"
--[[Translation missing --]]
L["Spec Position"] = "Spec Position"
--[[Translation missing --]]
L["Spec Role"] = "Spec Role"
--[[Translation missing --]]
L["Specialization"] = "Specialization"
--[[Translation missing --]]
L["Specific Currency"] = "Specific Currency"
--[[Translation missing --]]
L["Specific Type"] = "Specific Type"
L["Specific Unit"] = "Konkrete Einheit"
L["Spell"] = "Zauber"
L["Spell (Building)"] = "Zauber, Gebude (SPELL_BUILDING)"
--[[Translation missing --]]
L["Spell Activation Overlay Glow"] = "Spell Activation Overlay Glow"
--[[Translation missing --]]
L["Spell Cast Succeeded"] = "Spell Cast Succeeded"
L["Spell Cost"] = "Zauberkosten"
--[[Translation missing --]]
L["Spell Count"] = "Spell Count"
L["Spell ID"] = "Zauber-ID"
L["Spell Id"] = "Zauber-ID"
L["Spell ID:"] = "Zauber ID:"
L["Spell IDs:"] = "Zauber IDs:"
--[[Translation missing --]]
L["Spell in Range"] = "Spell in Range"
L["Spell Known"] = "Zauber erlernt"
L["Spell Name"] = "Zaubername"
--[[Translation missing --]]
L["Spell Peneration Percent"] = "Spell Peneration Percent"
--[[Translation missing --]]
L["Spell Power"] = "Spell Power"
--[[Translation missing --]]
L["Spell School"] = "Spell School"
L["Spell Usable"] = "Zauber benutzbar"
--[[Translation missing --]]
L["Spellname"] = "Spellname"
--[[Translation missing --]]
L["Spike"] = "Spike"
L["Spin"] = "Drehen"
L["Spiral"] = "Winden"
L["Spiral In And Out"] = "Ein- und Auswinden"
--[[Translation missing --]]
L["Spirit"] = "Spirit"
--[[Translation missing --]]
L["Stack Count"] = "Stack Count"
--[[Translation missing --]]
L["Stack trace:"] = "Stack trace:"
L["Stacks"] = "Stapel"
--[[Translation missing --]]
L["Stacks Function"] = "Stacks Function"
--[[Translation missing --]]
L["Stacks Function (fallback state)"] = "Stacks Function (fallback state)"
--[[Translation missing --]]
L["Stage"] = "Stage"
--[[Translation missing --]]
L["Stage Counter"] = "Stage Counter"
--[[Translation missing --]]
L["Stagger"] = "Stagger"
--[[Translation missing --]]
L["Stagger (%)"] = "Stagger (%)"
--[[Translation missing --]]
L["Stagger against Target (%)"] = "Stagger against Target (%)"
--[[Translation missing --]]
L["Stagger Scale"] = "Stagger Scale"
L["Stamina"] = "Ausdauer"
L["Stance/Form/Aura"] = "Haltung/Form/Aura"
--[[Translation missing --]]
L["Standing"] = "Standing"
--[[Translation missing --]]
L["Star Shake"] = "Star Shake"
--[[Translation missing --]]
L["Start Animation"] = "Start Animation"
--[[Translation missing --]]
L["Start Now"] = "Start Now"
--[[Translation missing --]]
L["Start Profiling"] = "Start Profiling"
L["Status"] = "Status"
--[[Translation missing --]]
L["Status Bar"] = "Status Bar"
L["Stolen"] = "Gestohlen (STOLEN)"
L["Stop"] = "Stopp"
--[[Translation missing --]]
L["Stop Motion"] = "Stop Motion"
--[[Translation missing --]]
L["Story Raid"] = "Story Raid"
L["Strength"] = "Strke"
--[[Translation missing --]]
L["String"] = "String"
--[[Translation missing --]]
L["Subevent Info"] = "Subevent Info"
--[[Translation missing --]]
L["Subtract Cast"] = "Subtract Cast"
--[[Translation missing --]]
L["Subtract Channel"] = "Subtract Channel"
--[[Translation missing --]]
L["Subtract GCD"] = "Subtract GCD"
--[[Translation missing --]]
L["Subzone Name"] = "Subzone Name"
--[[Translation missing --]]
L["Success"] = "Success"
--[[Translation missing --]]
L["Sulfuron Harbinger"] = "Sulfuron Harbinger"
L["Summon"] = "Herbeirufen (SUMMON)"
--[[Translation missing --]]
L["Summon Pending"] = "Summon Pending"
--[[Translation missing --]]
L["Sun"] = "Sun"
--[[Translation missing --]]
L["Supports multiple entries, separated by commas"] = "Supports multiple entries, separated by commas"
--[[Translation missing --]]
L[ [=[Supports multiple entries, separated by commas
]=] ] = [=[Supports multiple entries, separated by commas
]=]
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Prefix with '-' for negation."
--[[Translation missing --]]
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=]
L["Swing"] = "Schwingen (SWING)"
L["Swing Timer"] = "Schlagtimer"
--[[Translation missing --]]
L["Swipe"] = "Swipe"
--[[Translation missing --]]
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = "Syntax /wa feature <toggle|on|enable|disable|off> <feature>"
L["System"] = "System"
--[[Translation missing --]]
L["Systems"] = "Systems"
--[[Translation missing --]]
L["Tab "] = "Tab "
--[[Translation missing --]]
L["Talent"] = "Talent"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Known"] = "Talent |cFFFF0000Not|r Known"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Selected"] = "Talent |cFFFF0000Not|r Selected"
--[[Translation missing --]]
L["Talent Known"] = "Talent Known"
L["Talent Selected"] = "Talent gewhlt"
L["Talent selected"] = "Gewhltes Talent"
L["Talent Specialization"] = "Talentspezialisierung"
L["Tanking And Highest"] = "Hchster und Aggro"
L["Tanking But Not Highest"] = "Aggro aber nicht hchste"
L["Target"] = "Ziel"
L["Targeted"] = "Anvisiert"
--[[Translation missing --]]
L["Tertiary Stats"] = "Tertiary Stats"
--[[Translation missing --]]
L["Test if bar is enabled in BigWigs settings"] = "Test if bar is enabled in BigWigs settings"
--[[Translation missing --]]
L["Test if bar is enabled in Boss Mod addon settings"] = "Test if bar is enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Test if bar is enabled in DBM settings"] = "Test if bar is enabled in DBM settings"
L["Text"] = "Text"
--[[Translation missing --]]
L["Text To Speech"] = "Text To Speech"
--[[Translation missing --]]
L["Text-to-speech"] = "Text-to-speech"
--[[Translation missing --]]
L["Texture"] = "Texture"
--[[Translation missing --]]
L["Texture Function"] = "Texture Function"
--[[Translation missing --]]
L["Texture Function (fallback state)"] = "Texture Function (fallback state)"
--[[Translation missing --]]
L["Texture Picker"] = "Texture Picker"
--[[Translation missing --]]
L["Texture Rotation"] = "Texture Rotation"
--[[Translation missing --]]
L["Thaddius"] = "Thaddius"
--[[Translation missing --]]
L["The aura has overwritten the global '%s', this might affect other auras."] = "The aura has overwritten the global '%s', this might affect other auras."
--[[Translation missing --]]
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "The aura tried to overwrite the aura_env global, which is not allowed."
--[[Translation missing --]]
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "The effective level differs from the level in e.g. Time Walking dungeons."
--[[Translation missing --]]
L["The Four Horsemen"] = "The Four Horsemen"
--[[Translation missing --]]
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "The 'ID' value can be found in the BigWigs options of a specific spell"
--[[Translation missing --]]
L["The Prophet Skeram"] = "The Prophet Skeram"
--[[Translation missing --]]
L["The total quantity a warband character can transfer after paying the transfer cost"] = "The total quantity a warband character can transfer after paying the transfer cost"
--[[Translation missing --]]
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "The total quantity after transferring everything to your current character and paying the transfer cost"
--[[Translation missing --]]
L["The War Within"] = "The War Within"
--[[Translation missing --]]
L["There are %i updates to your auras ready to be installed!"] = "There are %i updates to your auras ready to be installed!"
L["Thick Outline"] = "Dicke Kontur"
--[[Translation missing --]]
L["Thickness"] = "Thickness"
--[[Translation missing --]]
L["Third"] = "Third"
--[[Translation missing --]]
L["Third Value of Tooltip Text"] = "Third Value of Tooltip Text"
--[[Translation missing --]]
L["This aura calls GetData a lot, which is a slow function."] = "This aura calls GetData a lot, which is a slow function."
--[[Translation missing --]]
L["This aura has caused a Lua error."] = "This aura has caused a Lua error."
--[[Translation missing --]]
L["This aura is saving %s KB of data"] = "This aura is saving %s KB of data"
--[[Translation missing --]]
L["This aura plays a sound via a condition."] = "This aura plays a sound via a condition."
--[[Translation missing --]]
L["This aura plays a sound via an action."] = "This aura plays a sound via an action."
--[[Translation missing --]]
L["This aura plays a Text To Speech via a condition."] = "This aura plays a Text To Speech via a condition."
--[[Translation missing --]]
L["This aura plays a Text To Speech via an action."] = "This aura plays a Text To Speech via an action."
--[[Translation missing --]]
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."
--[[Translation missing --]]
L["Threat Percent"] = "Threat Percent"
L["Threat Situation"] = "Bedrohungssituation"
--[[Translation missing --]]
L["Threat Value"] = "Threat Value"
--[[Translation missing --]]
L["Tick"] = "Tick"
--[[Translation missing --]]
L["Time"] = "Time"
--[[Translation missing --]]
L["Time Format"] = "Time Format"
--[[Translation missing --]]
L["Time in GCDs"] = "Time in GCDs"
--[[Translation missing --]]
L["Time since initial application"] = "Time since initial application"
--[[Translation missing --]]
L["Time since last refresh"] = "Time since last refresh"
--[[Translation missing --]]
L["Time since stack gain"] = "Time since stack gain"
--[[Translation missing --]]
L["Time since stack lost"] = "Time since stack lost"
L["Timed"] = "Zeitgesteuert"
--[[Translation missing --]]
L["Timed Progress"] = "Timed Progress"
--[[Translation missing --]]
L["Timer"] = "Timer"
--[[Translation missing --]]
L["Timer Id"] = "Timer Id"
L["Toggle"] = "Umschalten"
--[[Translation missing --]]
L["Toggle List"] = "Toggle List"
--[[Translation missing --]]
L["Toggle Options Window"] = "Toggle Options Window"
--[[Translation missing --]]
L["Toggle Performance Profiling Window"] = "Toggle Performance Profiling Window"
L["Tooltip"] = "Tooltip"
--[[Translation missing --]]
L["Tooltip 1"] = "Tooltip 1"
--[[Translation missing --]]
L["Tooltip 2"] = "Tooltip 2"
--[[Translation missing --]]
L["Tooltip 3"] = "Tooltip 3"
L["Tooltip Value 1"] = "Tooltip Wert 1"
L["Tooltip Value 2"] = "Tooltip Wert 2"
L["Tooltip Value 3"] = "Tooltip Wert 3"
--[[Translation missing --]]
L["Tooltip Value 4"] = "Tooltip Value 4"
L["Top"] = "Oben"
L["Top Left"] = "Oben Links"
L["Top Right"] = "Oben Rechts"
L["Top to Bottom"] = "Oben -> Unten"
--[[Translation missing --]]
L["Torghast"] = "Torghast"
L["Total Duration"] = "Gesamtdauer"
--[[Translation missing --]]
L["Total Earned in this Season"] = "Total Earned in this Season"
--[[Translation missing --]]
L["Total Essence"] = "Total Essence"
--[[Translation missing --]]
L["Total Experience"] = "Total Experience"
--[[Translation missing --]]
L["Total Match Count"] = "Total Match Count"
--[[Translation missing --]]
L["Total Reputation"] = "Total Reputation"
--[[Translation missing --]]
L["Total Stacks"] = "Total Stacks"
--[[Translation missing --]]
L["Total stacks over all matches"] = "Total stacks over all matches"
--[[Translation missing --]]
L["Total Stages"] = "Total Stages"
--[[Translation missing --]]
L["Total Unit Count"] = "Total Unit Count"
--[[Translation missing --]]
L["Total Units"] = "Total Units"
L["Totem"] = "Totem"
L["Totem #%i"] = "Totem #%i"
--[[Translation missing --]]
L["Totem Icon"] = "Totem Icon"
L["Totem Name"] = "Totemname"
--[[Translation missing --]]
L["Totem Name Pattern Match"] = "Totem Name Pattern Match"
L["Totem Number"] = "Totemnummer"
--[[Translation missing --]]
L["Track Cooldowns"] = "Track Cooldowns"
--[[Translation missing --]]
L["Tracking Charge %i"] = "Tracking Charge %i"
--[[Translation missing --]]
L["Tracking Charge CDs"] = "Tracking Charge CDs"
--[[Translation missing --]]
L["Tracking Only Cooldown"] = "Tracking Only Cooldown"
L["Transmission error"] = "bertragungsfehler"
L["Trigger"] = "Auslser"
--[[Translation missing --]]
L["Trigger %i"] = "Trigger %i"
--[[Translation missing --]]
L["Trigger %s"] = "Trigger %s"
L["Trigger 1"] = "Auslser 1"
--[[Translation missing --]]
L["Trigger State Updater (Advanced)"] = "Trigger State Updater (Advanced)"
L["Trigger Update"] = "Auslseraktualisierung"
L["Trigger:"] = "Auslser:"
--[[Translation missing --]]
L["Trivial (Low Level)"] = "Trivial (Low Level)"
L["True"] = "Zutrifft"
--[[Translation missing --]]
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "Trying to repair broken conditions in %s likely caused by a WeakAuras bug."
L["Twin Emperors"] = "Zwillingsimperatoren"
L["Type"] = "Typ"
--[[Translation missing --]]
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."
--[[Translation missing --]]
L["Unaffected"] = "Unaffected"
L["Undefined"] = "Undefiniert"
--[[Translation missing --]]
L["Unholy"] = "Unholy"
--[[Translation missing --]]
L["Unholy Rune #1"] = "Unholy Rune #1"
--[[Translation missing --]]
L["Unholy Rune #2"] = "Unholy Rune #2"
L["Unit"] = "Einheit"
L["Unit Characteristics"] = "Einheitencharakterisierung"
L["Unit Destroyed"] = "Einheit zerstrt"
L["Unit Died"] = "Einheit gestorben"
--[[Translation missing --]]
L["Unit Dissipates"] = "Unit Dissipates"
--[[Translation missing --]]
L["Unit Frame"] = "Unit Frame"
--[[Translation missing --]]
L["Unit Frames"] = "Unit Frames"
L["Unit is Unit"] = "Vergleicht Einheit mit"
--[[Translation missing --]]
L["Unit Name"] = "Unit Name"
--[[Translation missing --]]
L["Unit Name/Realm"] = "Unit Name/Realm"
--[[Translation missing --]]
L["Units Affected"] = "Units Affected"
--[[Translation missing --]]
L["Units of affected Players in a table format"] = "Units of affected Players in a table format"
--[[Translation missing --]]
L["Units of unaffected Players in a table format"] = "Units of unaffected Players in a table format"
--[[Translation missing --]]
L["Unknown action %q"] = "Unknown action %q"
--[[Translation missing --]]
L["Unknown feature %q"] = "Unknown feature %q"
--[[Translation missing --]]
L["unknown location"] = "unknown location"
L["Unlimited"] = "Unbegrenzt"
--[[Translation missing --]]
L["Untrigger %s"] = "Untrigger %s"
L["Up"] = "Hoch"
--[[Translation missing --]]
L["Up, then Centered Horizontal"] = "Up, then Centered Horizontal"
L["Up, then Left"] = "Hoch, dann links"
L["Up, then Right"] = "Hoch, dann rechts"
--[[Translation missing --]]
L["Update Position"] = "Update Position"
L["Usage:"] = "Benutzung:"
--[[Translation missing --]]
L["Use /wa minimap to show the minimap icon again."] = "Use /wa minimap to show the minimap icon again."
L["Use Custom Color"] = "Benutzerdefinierte Farbe benutzen"
--[[Translation missing --]]
L["Use Legacy floor rounding"] = "Use Legacy floor rounding"
--[[Translation missing --]]
L["Use Texture"] = "Use Texture"
--[[Translation missing --]]
L["Use Watched Faction"] = "Use Watched Faction"
--[[Translation missing --]]
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."
--[[Translation missing --]]
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."
--[[Translation missing --]]
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."
--[[Translation missing --]]
L["Vaelastrasz the Corrupt"] = "Vaelastrasz the Corrupt"
L["Versatility (%)"] = "Vielseitigkeit (%)"
L["Versatility Rating"] = "Vielseitigkeitswertung"
--[[Translation missing --]]
L["Vertical"] = "Vertical"
--[[Translation missing --]]
L["Viscidus"] = "Viscidus"
L["Visibility"] = "Sichtbarkeit"
--[[Translation missing --]]
L["Visions of N'Zoth"] = "Visions of N'Zoth"
--[[Translation missing --]]
L["Warband Quantity Total"] = "Warband Quantity Total"
--[[Translation missing --]]
L["Warband Transfer Percentage"] = "Warband Transfer Percentage"
--[[Translation missing --]]
L["Warband Transferred Quantity"] = "Warband Transferred Quantity"
--[[Translation missing --]]
L["Warfront (Heroic)"] = "Warfront (Heroic)"
--[[Translation missing --]]
L["Warfront (Normal)"] = "Warfront (Normal)"
--[[Translation missing --]]
L["Warlords of Draenor"] = "Warlords of Draenor"
--[[Translation missing --]]
L["Warning"] = "Warning"
--[[Translation missing --]]
L["Warning for unknown aura:"] = "Warning for unknown aura:"
--[[Translation missing --]]
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"
--[[Translation missing --]]
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = "Warning: Full Scan auras checking for both name and spell id can't be converted."
--[[Translation missing --]]
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."
--[[Translation missing --]]
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = "Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."
--[[Translation missing --]]
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"
--[[Translation missing --]]
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."
--[[Translation missing --]]
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=]
--[[Translation missing --]]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."
--[[Translation missing --]]
L["WeakAuras Profiling"] = "WeakAuras Profiling"
--[[Translation missing --]]
L["WeakAuras Profiling Report"] = "WeakAuras Profiling Report"
--[[Translation missing --]]
L["WeakAuras Version: %s"] = "WeakAuras Version: %s"
L["Weapon"] = "Waffen"
L["Weapon Enchant"] = "Waffenverzauberung"
L["Weapon Enchant / Fishing Lure"] = "Waffenverzauberung / Angelrute"
L["Whisper"] = "Flstern"
L["Width"] = "Breite"
L["Wobble"] = "Wackeln"
L["World Boss"] = "Weltboss"
--[[Translation missing --]]
L["World Bosses"] = "World Bosses"
--[[Translation missing --]]
L["Wrap"] = "Wrap"
--[[Translation missing --]]
L["Wrath of the Lich King"] = "Wrath of the Lich King"
--[[Translation missing --]]
L["Writing to the WeakAuras table is not allowed."] = "Writing to the WeakAuras table is not allowed."
L["X-Offset"] = "X-Versatz"
L["Yell"] = "Schreien"
L["Y-Offset"] = "Y-Versatz"
--[[Translation missing --]]
L["You have new auras ready to be installed!"] = "You have new auras ready to be installed!"
--[[Translation missing --]]
L["Your next encounter will automatically be profiled."] = "Your next encounter will automatically be profiled."
--[[Translation missing --]]
L["Your next instance of combat will automatically be profiled."] = "Your next instance of combat will automatically be profiled."
--[[Translation missing --]]
L["Your scheduled automatic profile has been cancelled."] = "Your scheduled automatic profile has been cancelled."
--[[Translation missing --]]
L["Your threat as a percentage of the tank's current threat."] = "Your threat as a percentage of the tank's current threat."
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "Ihre Bedrohung fr den Mob als Prozentsatz der Menge, der zum Ziehen von Aggro erforderlich ist. Wird bei 100 Aggro ziehen."
L["Your total threat on the mob."] = "Ihre gesamte Bedrohung fr den Mob."
--[[Translation missing --]]
L["Zone Group ID"] = "Zone Group ID"
--[[Translation missing --]]
L["Zone ID"] = "Zone ID"
L["Zone Name"] = "Gebietsname"
L["Zoom"] = "Zoom"
--[[Translation missing --]]
L["Zoom Animation"] = "Zoom Animation"
L["Zul'Gurub"] = "Zul'Gurub"



-- ========================================
-- File: WeakAuras/Locales/enUS.lua
-- ========================================

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
L["%s Overlay Color"] = "%s Overlay Color"
L["* Suffix"] = "* Suffix"
L["/wa help - Show this message"] = "/wa help - Show this message"
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - Toggle the minimap icon"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - Show the results from the most recent profiling"
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."
L["/wa pstop - Finish profiling"] = "/wa pstop - Finish profiling"
L["/wa repair - Repair tool"] = "/wa repair - Repair tool"
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55fLeft-Click|r to toggle showing the main window."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55fRight-Click|r to toggle performance profiling window."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fShift-Click|r to pause addon execution."
L["|cffff0000deprecated|r"] = "|cffff0000deprecated|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000Not|r Item Bonus Id Equipped"
L["|cFFFF0000Not|r Item Equipped"] = "|cFFFF0000Not|r Item Equipped"
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000Not|r Player Name/Realm"
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000Not|r Spell Known"
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=]
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00Extra Options:|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00Extra Options:|r None"
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=]
L["1. Profession 1. Accessory"] = "1. Profession 1. Accessory"
L["1. Profession 2. Accessory"] = "1. Profession 2. Accessory"
L["1. Professsion Tool"] = "1. Professsion Tool"
L["10 Man Raid"] = "10 Man Raid"
L["10 Player Raid"] = "10 Player Raid"
L["10 Player Raid (Heroic)"] = "10 Player Raid (Heroic)"
L["10 Player Raid (Normal)"] = "10 Player Raid (Normal)"
L["2. Profession 1. Accessory"] = "2. Profession 1. Accessory"
L["2. Profession 2. Accessory"] = "2. Profession 2. Accessory"
L["2. Professsion Tool"] = "2. Professsion Tool"
L["20 Man Raid"] = "20 Man Raid"
L["20 Player Raid"] = "20 Player Raid"
L["25 Man Raid"] = "25 Man Raid"
L["25 Player Raid"] = "25 Player Raid"
L["25 Player Raid (Heroic)"] = "25 Player Raid (Heroic)"
L["25 Player Raid (Normal)"] = "25 Player Raid (Normal)"
L["40 Man Raid"] = "40 Man Raid"
L["40 Player Raid"] = "40 Player Raid"
L["5 Man Dungeon"] = "5 Man Dungeon"
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=]
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."
L["Abbreviate"] = "Abbreviate"
L["AbbreviateLargeNumbers (Blizzard)"] = "AbbreviateLargeNumbers (Blizzard)"
L["AbbreviateNumbers (Blizzard)"] = "AbbreviateNumbers (Blizzard)"
L["Absorb"] = "Absorb"
L["Absorb and Healing"] = "Absorb and Healing"
L["Absorb Heal Overlay"] = "Absorb Heal Overlay"
L["Absorb Overlay"] = "Absorb Overlay"
L["Absorbed"] = "Absorbed"
L["Action Button Glow"] = "Action Button Glow"
L["Actions"] = "Actions"
L["Active"] = "Active"
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
L["Add"] = "Add"
L["Add Missing Auras"] = "Add Missing Auras"
L["Advanced Caster's Target Check"] = "Advanced Caster's Target Check"
L["Affected"] = "Affected"
L["Affected Unit Count"] = "Affected Unit Count"
L["Afk"] = "Afk"
L["Aggro"] = "Aggro"
L["Agility"] = "Agility"
L["Ahn'Qiraj"] = "Ahn'Qiraj"
L["Alert Type"] = "Alert Type"
L["Alive"] = "Alive"
L["All"] = "All"
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "All children of this aura will also not be loaded, to minimize the chance of further corruption."
L["All States table contains a non table at key: '%s'."] = "All States table contains a non table at key: '%s'."
L["All Triggers"] = "All Triggers"
L["Alliance"] = "Alliance"
L["Allow partial matches"] = "Allow partial matches"
L["Alpha"] = "Alpha"
L["Alternate Power"] = "Alternate Power"
L["Always"] = "Always"
L["Always active trigger"] = "Always active trigger"
L["Always include realm"] = "Always include realm"
L["Always True"] = "Always True"
L["Amount"] = "Amount"
L["Anchoring"] = "Anchoring"
L["And Talent"] = "And Talent"
L["Angle and Radius"] = "Angle and Radius"
L["Animations"] = "Animations"
L["Anticlockwise"] = "Anticlockwise"
L["Anub'Rekhan"] = "Anub'Rekhan"
L["Any"] = "Any"
L["Any Triggers"] = "Any Triggers"
L["AOE"] = "AOE"
L["Arcane Resistance"] = "Arcane Resistance"
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=]
L["Arena"] = "Arena"
L["Armor (%)"] = "Armor (%)"
L["Armor against Target (%)"] = "Armor against Target (%)"
L["Armor Rating"] = "Armor Rating"
L["Array"] = "Array"
L["Ascending"] = "Ascending"
L["Assigned Role"] = "Assigned Role"
L["Assigned Role Icon"] = "Assigned Role Icon"
L["Assist"] = "Assist"
L["Assisted Combat Next Cast"] = "Assisted Combat Next Cast"
L["At Least One Enemy"] = "At Least One Enemy"
L["At missing Value"] = "At missing Value"
L["At Percent"] = "At Percent"
L["At Value"] = "At Value"
L["At War"] = "At War"
L["Attach to End"] = "Attach to End"
L["Attach to End, backwards"] = "Attach to End, backwards"
L["Attach to Point"] = "Attach to Point"
L["Attach to Start"] = "Attach to Start"
L["Attack Power"] = "Attack Power"
L["Attackable"] = "Attackable"
L["Attackable Target"] = "Attackable Target"
L["Aura"] = "Aura"
L["Aura '%s': %s"] = "Aura '%s': %s"
L["Aura Applied"] = "Aura Applied"
L["Aura Applied Dose"] = "Aura Applied Dose"
L["Aura Broken"] = "Aura Broken"
L["Aura Broken Spell"] = "Aura Broken Spell"
L["Aura is using deprecated SetDurationInfo"] = "Aura is using deprecated SetDurationInfo"
L["Aura loaded"] = "Aura loaded"
L["Aura Name"] = "Aura Name"
L["Aura Names"] = "Aura Names"
L["Aura Refresh"] = "Aura Refresh"
L["Aura Removed"] = "Aura Removed"
L["Aura Removed Dose"] = "Aura Removed Dose"
L["Aura Stack"] = "Aura Stack"
L["Aura Type"] = "Aura Type"
L["Aura Version: %s"] = "Aura Version: %s"
L["Aura(s) Found"] = "Aura(s) Found"
L["Aura(s) Missing"] = "Aura(s) Missing"
L["Aura:"] = "Aura:"
L["Auras"] = "Auras"
L["Auras:"] = "Auras:"
L["Author Options"] = "Author Options"
L["Auto"] = "Auto"
L["Autocast Shine"] = "Autocast Shine"
L["Automatic"] = "Automatic"
L["Automatic Length"] = "Automatic Length"
L["Automatic Rotation"] = "Automatic Rotation"
L["Available features: %s"] = "Available features: %s"
L["Avoidance (%)"] = "Avoidance (%)"
L["Avoidance Rating"] = "Avoidance Rating"
L["Ayamiss the Hunter"] = "Ayamiss the Hunter"
L["Azuregos"] = "Azuregos"
L["Back and Forth"] = "Back and Forth"
L["Background"] = "Background"
L["Background Color"] = "Background Color"
L["Balnazzar"] = "Balnazzar"
L["Bar Color/Gradient Start"] = "Bar Color/Gradient Start"
L["Bar enabled in BigWigs settings"] = "Bar enabled in BigWigs settings"
L["Bar enabled in Boss Mod addon settings"] = "Bar enabled in Boss Mod addon settings"
L["Bar enabled in DBM settings"] = "Bar enabled in DBM settings"
L["Bar Texture"] = "Bar Texture"
L["Bar Type"] = "Bar Type"
L["Baron Geddon"] = "Baron Geddon"
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "Battle.net Whisper"
L["Battleground"] = "Battleground"
L["Battleguard Sartura"] = "Battleguard Sartura"
L["Beastmaster"] = "Beastmaster"
L["Beatrix"] = "Beatrix"
L["BG>Raid>Party>Say"] = "BG>Raid>Party>Say"
L["BG-System Alliance"] = "BG-System Alliance"
L["BG-System Horde"] = "BG-System Horde"
L["BG-System Neutral"] = "BG-System Neutral"
L["Big Number"] = "Big Number"
L["BigWigs Addon"] = "BigWigs Addon"
L["BigWigs Message"] = "BigWigs Message"
L["BigWigs Stage"] = "BigWigs Stage"
L["BigWigs Timer"] = "BigWigs Timer"
L["Black Wing Lair"] = "Black Wing Lair"
L["Bleed"] = "Bleed"
L["Blizzard Combat Text"] = "Blizzard Combat Text"
L["Blizzard Cooldown Reduction"] = "Blizzard Cooldown Reduction"
L["Block"] = "Block"
L["Block (%)"] = "Block (%)"
L["Block against Target (%)"] = "Block against Target (%)"
L["Block Value"] = "Block Value"
L["Blocked"] = "Blocked"
L["Blood"] = "Blood"
L["Blood Rune #1"] = "Blood Rune #1"
L["Blood Rune #2"] = "Blood Rune #2"
L["Bloodlord Mandokir"] = "Bloodlord Mandokir"
L["Bonus Reputation Gain"] = "Bonus Reputation Gain"
L["Border"] = "Border"
L["Boss"] = "Boss"
L["Boss Emote"] = "Boss Emote"
L["Boss Mod Announce"] = "Boss Mod Announce"
L["Boss Mod Stage"] = "Boss Mod Stage"
L["Boss Mod Stage (Event)"] = "Boss Mod Stage (Event)"
L["Boss Mod Timer"] = "Boss Mod Timer"
L["Boss Whisper"] = "Boss Whisper"
L["Bottom"] = "Bottom"
L["Bottom Left"] = "Bottom Left"
L["Bottom Right"] = "Bottom Right"
L["Bottom to Top"] = "Bottom to Top"
L["Bounce"] = "Bounce"
L["Bounce with Decay"] = "Bounce with Decay"
L["Break"] = "Break"
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers (Blizzard)"
L["Broodlord Lashlayer"] = "Broodlord Lashlayer"
L["Buff"] = "Buff"
L["Buff/Debuff"] = "Buff/Debuff"
L["Buffed/Debuffed"] = "Buffed/Debuffed"
L["Burning Crusade"] = "Burning Crusade"
L["Buru the Gorger"] = "Buru the Gorger"
L["Caldoran"] = "Caldoran"
L["Callback function"] = "Callback function"
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."
L["Cancel"] = "Cancel"
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."
L["Capped"] = "Capped"
L["Capped at Season Max"] = "Capped at Season Max"
L["Capped at Weekly Max"] = "Capped at Weekly Max"
L["Cast"] = "Cast"
L["Cast Bar"] = "Cast Bar"
L["Cast Failed"] = "Cast Failed"
L["Cast Start"] = "Cast Start"
L["Cast Success"] = "Cast Success"
L["Cast Type"] = "Cast Type"
L["Caster"] = "Caster"
L["Caster Name"] = "Caster Name"
L["Caster Realm"] = "Caster Realm"
L["Caster Unit"] = "Caster Unit"
L["Casters Name/Realm"] = "Casters Name/Realm"
L["Caster's Target"] = "Caster's Target"
L["Cataclysm"] = "Cataclysm"
L["Ceil"] = "Ceil"
L["Center"] = "Center"
L["Center, then alternating bottom and top"] = "Center, then alternating bottom and top"
L["Center, then alternating left and right"] = "Center, then alternating left and right"
L["Center, then alternating right and left"] = "Center, then alternating right and left"
L["Center, then alternating top and bottom"] = "Center, then alternating top and bottom"
L["Centered Horizontal"] = "Centered Horizontal"
L["Centered Horizontal, then Centered Vertical"] = "Centered Horizontal, then Centered Vertical"
L["Centered Horizontal, then Down"] = "Centered Horizontal, then Down"
L["Centered Horizontal, then Up"] = "Centered Horizontal, then Up"
L["Centered Vertical"] = "Centered Vertical"
L["Centered Vertical, then Centered Horizontal"] = "Centered Vertical, then Centered Horizontal"
L["Centered Vertical, then Left"] = "Centered Vertical, then Left"
L["Centered Vertical, then Right"] = "Centered Vertical, then Right"
L["Changed"] = "Changed"
L["Channel"] = "Channel"
L["Channel (Spell)"] = "Channel (Spell)"
L["Character GUID"] = "Character GUID"
L["Character Name"] = "Character Name"
L["Character Stats"] = "Character Stats"
L["Character Transferred Quantity"] = "Character Transferred Quantity"
L["Character Type"] = "Character Type"
L["Charge gained/lost"] = "Charge gained/lost"
L["Charged Combo Points"] = "Charged Combo Points"
L["Charges"] = "Charges"
L["Charges Changed Event"] = "Charges Changed Event"
L["Charging"] = "Charging"
L["Chat Frame"] = "Chat Frame"
L["Chat Message"] = "Chat Message"
L["Check if a single talent match a Rank"] = "Check if a single talent match a Rank"
L["Check nameplate's target every 0.2s"] = "Check nameplate's target every 0.2s"
L["Chromaggus"] = "Chromaggus"
L["Circle"] = "Circle"
L["Circular Texture"] = "Circular Texture"
L["Clamp"] = "Clamp"
L["Class"] = "Class"
L["Class and Specialization"] = "Class and Specialization"
L["Classic"] = "Classic"
L["Classification"] = "Classification"
L["Clockwise"] = "Clockwise"
L["Clone per Character"] = "Clone per Character"
L["Clone per Event"] = "Clone per Event"
L["Clone per Match"] = "Clone per Match"
L["Coin Precision"] = "Coin Precision"
L["Color"] = "Color"
L["Color Animation"] = "Color Animation"
L["Combat Log"] = "Combat Log"
L["Communities"] = "Communities"
L["Condition Custom Test"] = "Condition Custom Test"
L["Conditions"] = "Conditions"
L["Contains"] = "Contains"
L["Continuously update Movement Speed"] = "Continuously update Movement Speed"
L["Cooldown"] = "Cooldown"
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"
L["Cooldown Progress (Item)"] = "Cooldown Progress (Item)"
L["Cooldown Progress (Slot)"] = "Cooldown Progress (Slot)"
L["Cooldown Ready Event"] = "Cooldown Ready Event"
L["Cooldown Ready Event (Item)"] = "Cooldown Ready Event (Item)"
L["Cooldown Ready Event (Slot)"] = "Cooldown Ready Event (Slot)"
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."
L["Cooldown/Charges/Count"] = "Cooldown/Charges/Count"
L["Copper"] = "Copper"
L["Could not load WeakAuras Archive, the addon is %s"] = "Could not load WeakAuras Archive, the addon is %s"
L["Count"] = "Count"
L["Counter Clockwise"] = "Counter Clockwise"
L["Create"] = "Create"
L["Creature Family"] = "Creature Family"
L["Creature Family Name"] = "Creature Family Name"
L["Creature Type"] = "Creature Type"
L["Creature Type Name"] = "Creature Type Name"
L["Critical"] = "Critical"
L["Critical (%)"] = "Critical (%)"
L["Critical Rating"] = "Critical Rating"
L["Crop X"] = "Crop X"
L["Crop Y"] = "Crop Y"
L["Crowd Controlled"] = "Crowd Controlled"
L["Crushing"] = "Crushing"
L["C'thun"] = "C'thun"
L["Cumulated time used during profiling"] = "Cumulated time used during profiling"
L["Currency"] = "Currency"
L["Current Essence"] = "Current Essence"
L["Current Experience"] = "Current Experience"
L["Current Instance"] = "Current Instance"
L["Current Movement Speed (%)"] = "Current Movement Speed (%)"
L["Current Stage"] = "Current Stage"
L["Current Zone"] = "Current Zone"
L["Current Zone Group"] = "Current Zone Group"
L["Curse"] = "Curse"
L["Custom"] = "Custom"
L["Custom Action"] = "Custom Action"
L["Custom Anchor"] = "Custom Anchor"
L["Custom Check"] = "Custom Check"
L["Custom Color"] = "Custom Color"
L["Custom Condition Code"] = "Custom Condition Code"
L["Custom Configuration"] = "Custom Configuration"
L["Custom Fade Animation"] = "Custom Fade Animation"
L["Custom Function"] = "Custom Function"
L["Custom Grow"] = "Custom Grow"
L["Custom Sort"] = "Custom Sort"
L["Custom Text Function"] = "Custom Text Function"
L["Custom Trigger Combination"] = "Custom Trigger Combination"
L["Custom Variables"] = "Custom Variables"
L["Damage"] = "Damage"
L["Damage Shield"] = "Damage Shield"
L["Damage Shield Missed"] = "Damage Shield Missed"
L["Damage Split"] = "Damage Split"
L["DBM Announce"] = "DBM Announce"
L["DBM Stage"] = "DBM Stage"
L["DBM Timer"] = "DBM Timer"
L["Dead"] = "Dead"
L["Death"] = "Death"
L["Death Knight Rune"] = "Death Knight Rune"
L["Debuff"] = "Debuff"
L["Debuff Class"] = "Debuff Class"
L["Debuff Class Icon"] = "Debuff Class Icon"
L["Debuff Type"] = "Debuff Type"
L["Debug Log contains more than 1000 entries"] = "Debug Log contains more than 1000 entries"
L["Debug Logging enabled"] = "Debug Logging enabled"
L["Debug Logging enabled for '%s'"] = "Debug Logging enabled for '%s'"
L["Defensive Stats"] = "Defensive Stats"
L["Deflect"] = "Deflect"
L["Delve"] = "Delve"
L["Desaturate"] = "Desaturate"
L["Desaturate Background"] = "Desaturate Background"
L["Desaturate Foreground"] = "Desaturate Foreground"
L["Descending"] = "Descending"
L["Description"] = "Description"
L["Dest Raid Mark"] = "Dest Raid Mark"
L["Destination Affiliation"] = "Destination Affiliation"
L["Destination GUID"] = "Destination GUID"
L["Destination Info"] = "Destination Info"
L["Destination Name"] = "Destination Name"
L["Destination NPC Id"] = "Destination NPC Id"
L["Destination Object Type"] = "Destination Object Type"
L["Destination Reaction"] = "Destination Reaction"
L["Destination Unit"] = "Destination Unit"
L["Destination unit's raid mark index"] = "Destination unit's raid mark index"
L["Destination unit's raid mark texture"] = "Destination unit's raid mark texture"
L["Difficulty"] = "Difficulty"
L["Disable Spell Known Check"] = "Disable Spell Known Check"
L["Disabled"] = "Disabled"
L["Disabled feature %q"] = "Disabled feature %q"
L["Disabled Spell Known Check"] = "Disabled Spell Known Check"
L["Discovered"] = "Discovered"
L["Disease"] = "Disease"
L["Dispel"] = "Dispel"
L["Dispel Failed"] = "Dispel Failed"
L["Display"] = "Display"
L["Distance"] = "Distance"
L["Do Not Disturb"] = "Do Not Disturb"
L["Dodge"] = "Dodge"
L["Dodge (%)"] = "Dodge (%)"
L["Dodge Rating"] = "Dodge Rating"
L["Down"] = "Down"
L["Down, then Centered Horizontal"] = "Down, then Centered Horizontal"
L["Down, then Left"] = "Down, then Left"
L["Down, then Right"] = "Down, then Right"
L["Dragonflight"] = "Dragonflight"
L["Drain"] = "Drain"
L["Dropdown Menu"] = "Dropdown Menu"
L["Dumping table"] = "Dumping table"
L["Dungeon (Celestial)"] = "Dungeon (Celestial)"
L["Dungeon (Heroic)"] = "Dungeon (Heroic)"
L["Dungeon (Mythic)"] = "Dungeon (Mythic)"
L["Dungeon (Mythic+)"] = "Dungeon (Mythic+)"
L["Dungeon (Normal)"] = "Dungeon (Normal)"
L["Dungeon (Timewalking)"] = "Dungeon (Timewalking)"
L["Dungeons"] = "Dungeons"
L["Durability Damage"] = "Durability Damage"
L["Durability Damage All"] = "Durability Damage All"
L["Duration"] = "Duration"
L["Duration Function"] = "Duration Function"
L["Duration Function (fallback state)"] = "Duration Function (fallback state)"
L["Ease In"] = "Ease In"
L["Ease In and Out"] = "Ease In and Out"
L["Ease Out"] = "Ease Out"
L["Ebonroc"] = "Ebonroc"
L["Eclipse Direction"] = "Eclipse Direction"
L["Edge"] = "Edge"
L["Edge of Madness"] = "Edge of Madness"
L["Effective Spell Id"] = "Effective Spell Id"
L["Elide"] = "Elide"
L["Elite"] = "Elite"
L["Emote"] = "Emote"
L["Empower Cast End"] = "Empower Cast End"
L["Empower Cast Interrupt"] = "Empower Cast Interrupt"
L["Empower Cast Start"] = "Empower Cast Start"
L["Empowered"] = "Empowered"
L["Empowered 1"] = "Empowered 1"
L["Empowered 2"] = "Empowered 2"
L["Empowered 3"] = "Empowered 3"
L["Empowered 4"] = "Empowered 4"
L["Empowered 5"] = "Empowered 5"
L["Empowered Cast"] = "Empowered Cast"
L["Empowered Cast Fully Charged"] = "Empowered Cast Fully Charged"
L["Empowered Fully Charged"] = "Empowered Fully Charged"
L["Empty"] = "Empty"
L["Enabled feature %q"] = "Enabled feature %q"
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "Enables (incorrect) round down of seconds, which was the previous default behavior."
L["Enchant Applied"] = "Enchant Applied"
L["Enchant Found"] = "Enchant Found"
L["Enchant ID"] = "Enchant ID"
L["Enchant Missing"] = "Enchant Missing"
L["Enchant Name or ID"] = "Enchant Name or ID"
L["Enchant Removed"] = "Enchant Removed"
L["Enchanted"] = "Enchanted"
L["Encounter ID(s)"] = "Encounter ID(s)"
L["Energize"] = "Energize"
L["Enrage"] = "Enrage"
L["Enter a name or a spellId"] = "Enter a name or a spellId"
L["Entering"] = "Entering"
L["Entering/Leaving Combat"] = "Entering/Leaving Combat"
L["Entering/Leaving Encounter"] = "Entering/Leaving Encounter"
L["Entry Order"] = "Entry Order"
L["Environment Type"] = "Environment Type"
L["Environmental"] = "Environmental"
L["Equipment"] = "Equipment"
L["Equipment Set"] = "Equipment Set"
L["Equipment Set Equipped"] = "Equipment Set Equipped"
L["Equipment Slot"] = "Equipment Slot"
L["Equipped"] = "Equipped"
L["Error"] = "Error"
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Error decoding."] = "Error decoding."
L["Error decompressing"] = "Error decompressing"
L["Error decompressing. This doesn't look like a WeakAuras import."] = "Error decompressing. This doesn't look like a WeakAuras import."
L["Error deserializing"] = "Error deserializing"
L["Error Frame"] = "Error Frame"
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "ERROR in '%s' unknown or incompatible sub element type '%s'"
L["Error in Aura '%s'"] = "Error in Aura '%s'"
L["Error not receiving display information from %s"] = "Error not receiving display information from %s"
L["Essence"] = "Essence"
L["Essence #1"] = "Essence #1"
L["Essence #2"] = "Essence #2"
L["Essence #3"] = "Essence #3"
L["Essence #4"] = "Essence #4"
L["Essence #5"] = "Essence #5"
L["Essence #6"] = "Essence #6"
L["Evade"] = "Evade"
L["Event"] = "Event"
L["Event(s)"] = "Event(s)"
L["Every Frame"] = "Every Frame"
L["Every Frame (High CPU usage)"] = "Every Frame (High CPU usage)"
L["Evoker Essence"] = "Evoker Essence"
L["Exact Spell ID(s)"] = "Exact Spell ID(s)"
L["Execute Conditions"] = "Execute Conditions"
L["Experience (%)"] = "Experience (%)"
L["Expertise Bonus"] = "Expertise Bonus"
L["Expertise Rating"] = "Expertise Rating"
L["Extend Outside"] = "Extend Outside"
L["Extra Amount"] = "Extra Amount"
L["Extra Attacks"] = "Extra Attacks"
L["Extra Spell Id"] = "Extra Spell Id"
L["Extra Spell Name"] = "Extra Spell Name"
L["Faction"] = "Faction"
L["Faction Name"] = "Faction Name"
L["Faction Reputation"] = "Faction Reputation"
L["Fade Animation"] = "Fade Animation"
L["Fade In"] = "Fade In"
L["Fade Out"] = "Fade Out"
L["Fail Alert"] = "Fail Alert"
L["False"] = "False"
L["Fankriss the Unyielding"] = "Fankriss the Unyielding"
L["Feature %q is already disabled"] = "Feature %q is already disabled"
L["Feature %q is already enabled"] = "Feature %q is already enabled"
L["Fetch Absorb"] = "Fetch Absorb"
L["Fetch Heal Absorb"] = "Fetch Heal Absorb"
L["Fetch Legendary Power"] = "Fetch Legendary Power"
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "Fetches the name and icon of the Legendary Power that matches this bonus id."
L["Fill Area"] = "Fill Area"
L["Filter messages with format <message>"] = "Filter messages with format <message>"
L["Fire Resistance"] = "Fire Resistance"
L["Firemaw"] = "Firemaw"
L["First"] = "First"
L["First Value of Tooltip Text"] = "First Value of Tooltip Text"
L["Fixed"] = "Fixed"
L["Fixed Names"] = "Fixed Names"
L["Fixed Size"] = "Fixed Size"
L["Flamegor"] = "Flamegor"
L["Flash"] = "Flash"
L["Flex Raid"] = "Flex Raid"
L["Flip"] = "Flip"
L["Floor"] = "Floor"
L["Focus"] = "Focus"
L["Follower Dungeon"] = "Follower Dungeon"
L["Font"] = "Font"
L["Font Size"] = "Font Size"
L["Forbidden function or table: %s"] = "Forbidden function or table: %s"
L["Foreground"] = "Foreground"
L["Foreground Color"] = "Foreground Color"
L["Form"] = "Form"
L["Format"] = "Format"
L["Format Gold"] = "Format Gold"
L["Formats |cFFFFCC00%unit|r"] = "Formats |cFFFFCC00%unit|r"
L["Formats Player's |cFFFFCC00%guid|r"] = "Formats Player's |cFFFFCC00%guid|r"
L["Forward"] = "Forward"
L["Forward, Reverse Loop"] = "Forward, Reverse Loop"
L["Fourth Value of Tooltip Text"] = "Fourth Value of Tooltip Text"
L["Frame Selector"] = "Frame Selector"
L["Frequency"] = "Frequency"
L["Friendly"] = "Friendly"
L["Friendly Fire"] = "Friendly Fire"
L["Friendship Max Rank"] = "Friendship Max Rank"
L["Friendship Rank"] = "Friendship Rank"
L["Friendship Reputation"] = "Friendship Reputation"
L["Frost"] = "Frost"
L["Frost Resistance"] = "Frost Resistance"
L["Frost Rune #1"] = "Frost Rune #1"
L["Frost Rune #2"] = "Frost Rune #2"
L["Full"] = "Full"
L["Full Region"] = "Full Region"
L["Full/Empty"] = "Full/Empty"
L["Gahz'ranka"] = "Gahz'ranka"
L["Gained"] = "Gained"
L["Garr"] = "Garr"
L["Gehennas"] = "Gehennas"
L["General"] = "General"
L["General Rajaxx"] = "General Rajaxx"
L["GetNameAndIcon Function (fallback state)"] = "GetNameAndIcon Function (fallback state)"
L["Glancing"] = "Glancing"
L["Global Cooldown"] = "Global Cooldown"
L["Glow"] = "Glow"
L["Glow External Element"] = "Glow External Element"
L["Gluth"] = "Gluth"
L["Glyph"] = "Glyph"
L["Gold"] = "Gold"
L["Golemagg the Incinerator"] = "Golemagg the Incinerator"
L["Gothik the Harvester"] = "Gothik the Harvester"
L["Gradient"] = "Gradient"
L["Gradient Enabled"] = "Gradient Enabled"
L["Gradient End"] = "Gradient End"
L["Gradient Orientation"] = "Gradient Orientation"
L["Gradient Pulse"] = "Gradient Pulse"
L["Grand Widow Faerlina"] = "Grand Widow Faerlina"
L["Grid"] = "Grid"
L["Grobbulus"] = "Grobbulus"
L["Group"] = "Group"
L["Group Arrangement"] = "Group Arrangement"
L["Group Leader/Assist"] = "Group Leader/Assist"
L["Group Size"] = "Group Size"
L["Group Type"] = "Group Type"
L["Grow"] = "Grow"
L["GTFO Alert"] = "GTFO Alert"
L["Guardian"] = "Guardian"
L["Guild"] = "Guild"
L["Hakkar"] = "Hakkar"
L["Hardcore"] = "Hardcore"
L["Has Target"] = "Has Target"
L["Has Vehicle UI"] = "Has Vehicle UI"
L["HasPet"] = "HasPet"
L["Haste (%)"] = "Haste (%)"
L["Haste Rating"] = "Haste Rating"
L["Heal"] = "Heal"
L["Heal Absorb"] = "Heal Absorb"
L["Heal Absorbed"] = "Heal Absorbed"
L["Health"] = "Health"
L["Health (%)"] = "Health (%)"
L["Health Deficit"] = "Health Deficit"
L["Heigan the Unclean"] = "Heigan the Unclean"
L["Height"] = "Height"
L["Hero Talent"] = "Hero Talent"
L["Heroic Party"] = "Heroic Party"
L["Hide"] = "Hide"
L["Hide 0 cooldowns"] = "Hide 0 cooldowns"
L["Hide Timer Text"] = "Hide Timer Text"
L["High Damage"] = "High Damage"
L["High Priest Thekal"] = "High Priest Thekal"
L["High Priest Venoxis"] = "High Priest Venoxis"
L["High Priestess Arlokk"] = "High Priestess Arlokk"
L["High Priestess Jeklik"] = "High Priestess Jeklik"
L["High Priestess Mar'li"] = "High Priestess Mar'li"
L["Higher Than Tank"] = "Higher Than Tank"
L["Highest Spell Id"] = "Highest Spell Id"
L["Hit (%)"] = "Hit (%)"
L["Hit Rating"] = "Hit Rating"
L["Holy Resistance"] = "Holy Resistance"
L["Horde"] = "Horde"
L["Horizontal"] = "Horizontal"
L["Hostile"] = "Hostile"
L["Hostility"] = "Hostility"
L["Humanoid"] = "Humanoid"
L["Hybrid"] = "Hybrid"
L["Icon"] = "Icon"
L["Icon Function"] = "Icon Function"
L["Icon Function (fallback state)"] = "Icon Function (fallback state)"
L["Id"] = "Id"
L["ID"] = "ID"
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"
L["Ignore Dead"] = "Ignore Dead"
L["Ignore Disconnected"] = "Ignore Disconnected"
L["Ignore Rune CD"] = "Ignore Rune CD"
L["Ignore Rune CDs"] = "Ignore Rune CDs"
L["Ignore Self"] = "Ignore Self"
L["Ignore Spell Cooldown/Charges"] = "Ignore Spell Cooldown/Charges"
L["Ignore Spell Override"] = "Ignore Spell Override"
L["Immune"] = "Immune"
L["Important"] = "Important"
L["Importing will start after combat ends."] = "Importing will start after combat ends."
L["In Combat"] = "In Combat"
L["In Encounter"] = "In Encounter"
L["In Group"] = "In Group"
L["In Party"] = "In Party"
L["In Pet Battle"] = "In Pet Battle"
L["In Raid"] = "In Raid"
L["In Range"] = "In Range"
L["In Vehicle"] = "In Vehicle"
L["In War Mode"] = "In War Mode"
L["Include Bank"] = "Include Bank"
L["Include Charges"] = "Include Charges"
L["Include Death Runes"] = "Include Death Runes"
L["Include Pets"] = "Include Pets"
L["Include War Band Bank"] = "Include War Band Bank"
L["Incoming Heal"] = "Incoming Heal"
L["Increase Precision Below"] = "Increase Precision Below"
L["Increases by one per stage or intermission."] = "Increases by one per stage or intermission."
L["Information"] = "Information"
L["Inherited"] = "Inherited"
L["Instakill"] = "Instakill"
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "Install the addons BugSack and BugGrabber for detailed error logs."
L["Instance"] = "Instance"
L["Instance Difficulty"] = "Instance Difficulty"
L["Instance Id"] = "Instance Id"
L["Instance ID"] = "Instance ID"
L["Instance Info"] = "Instance Info"
L["Instance Name"] = "Instance Name"
L["Instance Size Type"] = "Instance Size Type"
L["Instance Type"] = "Instance Type"
L["Instructor Razuvious"] = "Instructor Razuvious"
L["Insufficient Resources"] = "Insufficient Resources"
L["Intellect"] = "Intellect"
L["Interrupt"] = "Interrupt"
L["Interrupt School"] = "Interrupt School"
L["Interrupted School Text"] = "Interrupted School Text"
L["Interruptible"] = "Interruptible"
L["Inverse"] = "Inverse"
L["Inverse Pet Behavior"] = "Inverse Pet Behavior"
L["Is Away from Keyboard"] = "Is Away from Keyboard"
L["Is Current Specialization"] = "Is Current Specialization"
L["Is Death Rune"] = "Is Death Rune"
L["Is Exactly"] = "Is Exactly"
L["Is Moving"] = "Is Moving"
L["Is Off Hand"] = "Is Off Hand"
L["Is Paragon Reputation"] = "Is Paragon Reputation"
L["Is Paused"] = "Is Paused"
L["is useable"] = "is useable"
L["Is Weekly Renown Capped"] = "Is Weekly Renown Capped"
L["Island Expedition (Heroic)"] = "Island Expedition (Heroic)"
L["Island Expedition (Mythic)"] = "Island Expedition (Mythic)"
L["Island Expedition (Normal)"] = "Island Expedition (Normal)"
L["Island Expeditions (PvP)"] = "Island Expeditions (PvP)"
L["Item"] = "Item"
L["Item Bonus Id"] = "Item Bonus Id"
L["Item Bonus Id Equipped"] = "Item Bonus Id Equipped"
L["Item Count"] = "Item Count"
L["Item Equipped"] = "Item Equipped"
L["Item Id"] = "Item Id"
L["Item in Range"] = "Item in Range"
L["Item Name"] = "Item Name"
L["Item Set Equipped"] = "Item Set Equipped"
L["Item Set Id"] = "Item Set Id"
L["Item Slot"] = "Item Slot"
L["Item Slot String"] = "Item Slot String"
L["Item Type"] = "Item Type"
L["Item Type Equipped"] = "Item Type Equipped"
L["ItemId"] = "ItemId"
L["Jin'do the Hexxer"] = "Jin'do the Hexxer"
L["Journal Stage"] = "Journal Stage"
L["Kazzak"] = "Kazzak"
L["Keep Inside"] = "Keep Inside"
L["Kel'Thuzad"] = "Kel'Thuzad"
L["Kurinnaxx"] = "Kurinnaxx"
L["Large"] = "Large"
L["Latency"] = "Latency"
L["Leader"] = "Leader"
L["Least remaining time"] = "Least remaining time"
L["Leaving"] = "Leaving"
L["Leech"] = "Leech"
L["Leech (%)"] = "Leech (%)"
L["Leech Rating"] = "Leech Rating"
L["Left"] = "Left"
L["Left to Right"] = "Left to Right"
L["Left, then Centered Vertical"] = "Left, then Centered Vertical"
L["Left, then Down"] = "Left, then Down"
L["Left, then Up"] = "Left, then Up"
L["Legacy Looking for Raid"] = "Legacy Looking for Raid"
L["Legacy RGB Gradient"] = "Legacy RGB Gradient"
L["Legacy RGB Gradient Pulse"] = "Legacy RGB Gradient Pulse"
L["Legion"] = "Legion"
L["Length"] = "Length"
L["Level"] = "Level"
L["LibSharedMedia"] = "LibSharedMedia"
L["Lillian Voss"] = "Lillian Voss"
L["Limited"] = "Limited"
L["Linear Texture"] = "Linear Texture"
L["Lines & Particles"] = "Lines & Particles"
L["Load Conditions"] = "Load Conditions"
L["Loatheb"] = "Loatheb"
L["Location"] = "Location"
L["Looking for Raid"] = "Looking for Raid"
L["Loop"] = "Loop"
L["Loot"] = "Loot"
L["Loot Specialization"] = "Loot Specialization"
L["Loot Specialization Id"] = "Loot Specialization Id"
L["Loot Specialization Name"] = "Loot Specialization Name"
L["Lorewalking"] = "Lorewalking"
L["Lost"] = "Lost"
L["Low Damage"] = "Low Damage"
L["Lower Than Tank"] = "Lower Than Tank"
L["Lowest Spell Id"] = "Lowest Spell Id"
L["Lua error"] = "Lua error"
L["Lua error in Aura '%s': %s"] = "Lua error in Aura '%s': %s"
L["Lucifron"] = "Lucifron"
L["Maexxna"] = "Maexxna"
L["Magic"] = "Magic"
L["Magmadar"] = "Magmadar"
L["Main Character"] = "Main Character"
L["Main Stat"] = "Main Stat"
L["Majordomo Executus"] = "Majordomo Executus"
L["Malformed WeakAuras link"] = "Malformed WeakAuras link"
L["Manual"] = "Manual"
L["Manual Icon"] = "Manual Icon"
L["Manual Rotation"] = "Manual Rotation"
L["Marked First"] = "Marked First"
L["Marked Last"] = "Marked Last"
L["Mason"] = "Mason"
L["Master"] = "Master"
L["Mastery (%)"] = "Mastery (%)"
L["Mastery Rating"] = "Mastery Rating"
L["Match Count"] = "Match Count"
L["Match Count per Unit"] = "Match Count per Unit"
L["Matches (Pattern)"] = "Matches (Pattern)"
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=]
L["Max Char "] = "Max Char "
L["Max Char"] = "Max Char"
L["Max Charges"] = "Max Charges"
L["Max Health"] = "Max Health"
L["Max Power"] = "Max Power"
L["Max Quantity"] = "Max Quantity"
L["Maximum Estimate"] = "Maximum Estimate"
L["Maximum Progress"] = "Maximum Progress"
L["Maximum time used on a single frame"] = "Maximum time used on a single frame"
L["Media"] = "Media"
L["Medium"] = "Medium"
L["Melee"] = "Melee"
L["Melee Haste (%)"] = "Melee Haste (%)"
L["Message"] = "Message"
L["Message Type"] = "Message Type"
L["Message type:"] = "Message type:"
L["Meta Data"] = "Meta Data"
L["Mine"] = "Mine"
L["Minimum Estimate"] = "Minimum Estimate"
L["Minimum Progress"] = "Minimum Progress"
L["Minus (Small Nameplate)"] = "Minus (Small Nameplate)"
L["Mirror"] = "Mirror"
L["Miscellaneous"] = "Miscellaneous"
L["Miss"] = "Miss"
L["Miss Type"] = "Miss Type"
L["Missed"] = "Missed"
L["Missing"] = "Missing"
L["Mists of Pandaria"] = "Mists of Pandaria"
L["Moam"] = "Moam"
L["Model"] = "Model"
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"
L["Modernize"] = "Modernize"
L["Molten Core"] = "Molten Core"
L["Money"] = "Money"
L["Monochrome"] = "Monochrome"
L["Monochrome Outline"] = "Monochrome Outline"
L["Monochrome Thick Outline"] = "Monochrome Thick Outline"
L["Monster Emote"] = "Monster Emote"
L["Monster Party"] = "Monster Party"
L["Monster Say"] = "Monster Say"
L["Monster Whisper"] = "Monster Whisper"
L["Monster Yell"] = "Monster Yell"
L["Moon"] = "Moon"
L["Most remaining time"] = "Most remaining time"
L["Mounted"] = "Mounted"
L["Mouse Cursor"] = "Mouse Cursor"
L["Movement Speed Rating"] = "Movement Speed Rating"
L["Multi-target"] = "Multi-target"
L["Mythic Keystone"] = "Mythic Keystone"
L["Mythic+ Affix"] = "Mythic+ Affix"
L["Name"] = "Name"
L["Name Function"] = "Name Function"
L["Name Function (fallback state)"] = "Name Function (fallback state)"
L["Name of Caster's Target"] = "Name of Caster's Target"
L["Name of the (sub-)zone currently shown above the minimap."] = "Name of the (sub-)zone currently shown above the minimap."
L["Name(s)"] = "Name(s)"
L["Name/Realm of Caster's Target"] = "Name/Realm of Caster's Target"
L["Nameplate"] = "Nameplate"
L["Nameplates"] = "Nameplates"
L["Names of affected Players"] = "Names of affected Players"
L["Names of unaffected Players"] = "Names of unaffected Players"
L["Nature Resistance"] = "Nature Resistance"
L["Naxxramas"] = "Naxxramas"
L["Nefarian"] = "Nefarian"
L["Neutral"] = "Neutral"
L["Never"] = "Never"
L["Next Combat"] = "Next Combat"
L["Next Encounter"] = "Next Encounter"
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
L["No Extend"] = "No Extend"
L["No Instance"] = "No Instance"
L["No Profiling information saved."] = "No Profiling information saved."
L["No Progress Information available."] = "No Progress Information available."
L["None"] = "None"
L["Non-player Character"] = "Non-player Character"
L["Normal"] = "Normal"
L["Normal Party"] = "Normal Party"
L["Not in Group"] = "Not in Group"
L["Not in Smart Group"] = "Not in Smart Group"
L["Not on Cooldown"] = "Not on Cooldown"
L["Not On Threat Table"] = "Not On Threat Table"
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "Note: The available text replacements for multi triggers match the normal triggers now."
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = "Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "Note: This trigger relies on the WoW API, which returns incorrect information in some cases."
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"
L["Noth the Plaguebringer"] = "Noth the Plaguebringer"
L["NPC"] = "NPC"
L["Npc ID"] = "Npc ID"
L["Number"] = "Number"
L["Number Affected"] = "Number Affected"
L["Object"] = "Object"
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=]
L["Officer"] = "Officer"
L["Offset from progress"] = "Offset from progress"
L["Offset Timer"] = "Offset Timer"
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Old Blizzard (2h | 3m | 10s | 2.4)"
L["On Cooldown"] = "On Cooldown"
L["On Taxi"] = "On Taxi"
L["Only if on a different realm"] = "Only if on a different realm"
L["Only if Primary"] = "Only if Primary"
L["Onyxia"] = "Onyxia"
L["Opaque"] = "Opaque"
L["Option Group"] = "Option Group"
L["Options could not be loaded, the addon is %s"] = "Options could not be loaded, the addon is %s"
L["Options will finish loading after combat ends."] = "Options will finish loading after combat ends."
L["Options will open after the login process has completed."] = "Options will open after the login process has completed."
L["Or Talent"] = "Or Talent"
L["Orbit"] = "Orbit"
L["Orientation"] = "Orientation"
L["Ossirian the Unscarred"] = "Ossirian the Unscarred"
L["Other"] = "Other"
L["Other Addons"] = "Other Addons"
L["Other Events"] = "Other Events"
L["Ouro"] = "Ouro"
L["Outline"] = "Outline"
L["Over Energize"] = "Over Energize"
L["Overhealing"] = "Overhealing"
L["Overkill"] = "Overkill"
L["Overlay %s"] = "Overlay %s"
L["Overlay Charged Combo Points"] = "Overlay Charged Combo Points"
L["Overlay Cost of Casts"] = "Overlay Cost of Casts"
L["Overlay Latency"] = "Overlay Latency"
L["Pad"] = "Pad"
L["Pad Mode"] = "Pad Mode"
L["Pad to"] = "Pad to"
L["Paragon Reputation"] = "Paragon Reputation"
L["Paragon Reward Pending"] = "Paragon Reward Pending"
L["Parent Frame"] = "Parent Frame"
L["Parent Zone"] = "Parent Zone"
L["Parry"] = "Parry"
L["Parry (%)"] = "Parry (%)"
L["Parry Rating"] = "Parry Rating"
L["Party"] = "Party"
L["Party Kill"] = "Party Kill"
L["Patchwerk"] = "Patchwerk"
L["Path of Ascension: Courage"] = "Path of Ascension: Courage"
L["Path of Ascension: Humility"] = "Path of Ascension: Humility"
L["Path of Ascension: Loyalty"] = "Path of Ascension: Loyalty"
L["Path of Ascension: Wisdom"] = "Path of Ascension: Wisdom"
L["Paused"] = "Paused"
L["Periodic Spell"] = "Periodic Spell"
L["Personal Resource Display"] = "Personal Resource Display"
L["Pet"] = "Pet"
L["Pet Behavior"] = "Pet Behavior"
L["Pet Specialization"] = "Pet Specialization"
L["Pet Spell"] = "Pet Spell"
L["Pets only"] = "Pets only"
L["Phase"] = "Phase"
L["Pixel Glow"] = "Pixel Glow"
L["Placement"] = "Placement"
L["Placement %i"] = "Placement %i"
L["Placement Mode"] = "Placement Mode"
L["Play"] = "Play"
L["Player"] = "Player"
L["Player Character"] = "Player Character"
L["Player Class"] = "Player Class"
L["Player Effective Level"] = "Player Effective Level"
L["Player Experience"] = "Player Experience"
L["Player Faction"] = "Player Faction"
L["Player Level"] = "Player Level"
L["Player Location ID(s)"] = "Player Location ID(s)"
L["Player Money"] = "Player Money"
L["Player Name/Realm"] = "Player Name/Realm"
L["Player Race"] = "Player Race"
L["Player(s) Affected"] = "Player(s) Affected"
L["Player(s) Not Affected"] = "Player(s) Not Affected"
L["Player/Unit Info"] = "Player/Unit Info"
L["Players and Pets"] = "Players and Pets"
L["Poison"] = "Poison"
L["Power"] = "Power"
L["Power (%)"] = "Power (%)"
L["Power Deficit"] = "Power Deficit"
L["Power Type"] = "Power Type"
L["Precision"] = "Precision"
L["Preset"] = "Preset"
L["Primary Stats"] = "Primary Stats"
L["Princess Huhuran"] = "Princess Huhuran"
L["Print Profiling Results"] = "Print Profiling Results"
L["Proc Glow"] = "Proc Glow"
L["Profiling already started."] = "Profiling already started."
L["Profiling automatically started."] = "Profiling automatically started."
L["Profiling not running."] = "Profiling not running."
L["Profiling started."] = "Profiling started."
L["Profiling started. It will end automatically in %d seconds"] = "Profiling started. It will end automatically in %d seconds"
L["Profiling still running, stop before trying to print."] = "Profiling still running, stop before trying to print."
L["Profiling stopped."] = "Profiling stopped."
L["Progress"] = "Progress"
L["Progress Source"] = "Progress Source"
L["Progress Total"] = "Progress Total"
L["Progress Value"] = "Progress Value"
L["Pull"] = "Pull"
L["Pulse"] = "Pulse"
L["PvP Flagged"] = "PvP Flagged"
L["PvP Talent selected"] = "PvP Talent selected"
L["PvP Talent Selected"] = "PvP Talent Selected"
L["Quality Id"] = "Quality Id"
L["Quantity"] = "Quantity"
L["Quantity earned this week"] = "Quantity earned this week"
L["Quest Party"] = "Quest Party"
L["Queued Action"] = "Queued Action"
L["Radius"] = "Radius"
L["Ragnaros"] = "Ragnaros"
L["Raid"] = "Raid"
L["Raid (Heroic)"] = "Raid (Heroic)"
L["Raid (Mythic)"] = "Raid (Mythic)"
L["Raid (Normal)"] = "Raid (Normal)"
L["Raid (Timewalking)"] = "Raid (Timewalking)"
L["Raid Mark"] = "Raid Mark"
L["Raid Mark Icon"] = "Raid Mark Icon"
L["Raid Role"] = "Raid Role"
L["Raid Warning"] = "Raid Warning"
L["Raids"] = "Raids"
L["Range"] = "Range"
L["Range Check"] = "Range Check"
L["Ranged"] = "Ranged"
L["Rank"] = "Rank"
L["Rare"] = "Rare"
L["Rare Elite"] = "Rare Elite"
L["Rated Arena"] = "Rated Arena"
L["Rated Battleground"] = "Rated Battleground"
L["Raw Threat Percent"] = "Raw Threat Percent"
L["Razorgore the Untamed"] = "Razorgore the Untamed"
L["Ready Check"] = "Ready Check"
L["Reagent Quality"] = "Reagent Quality"
L["Reagent Quality Texture"] = "Reagent Quality Texture"
L["Realm"] = "Realm"
L["Realm Name"] = "Realm Name"
L["Realm of Caster's Target"] = "Realm of Caster's Target"
L["Reborn Council"] = "Reborn Council"
L["Receiving %s Bytes"] = "Receiving %s Bytes"
L["Receiving display information"] = "Receiving display information"
L["Reflect"] = "Reflect"
L["Region type %s not supported"] = "Region type %s not supported"
L["Relative"] = "Relative"
L["Relative X-Offset"] = "Relative X-Offset"
L["Relative Y-Offset"] = "Relative Y-Offset"
L["Remaining Duration"] = "Remaining Duration"
L["Remaining Time"] = "Remaining Time"
L["Remove Obsolete Auras"] = "Remove Obsolete Auras"
L["Renown Level"] = "Renown Level"
L["Renown Max Level"] = "Renown Max Level"
L["Renown Reputation"] = "Renown Reputation"
L["Repair"] = "Repair"
L["Repeat"] = "Repeat"
L["Report Summary"] = "Report Summary"
L["Reputation"] = "Reputation"
L["Reputation (%)"] = "Reputation (%)"
L["Requested display does not exist"] = "Requested display does not exist"
L["Requested display not authorized"] = "Requested display not authorized"
L["Requesting display information from %s ..."] = "Requesting display information from %s ..."
L["Require Valid Target"] = "Require Valid Target"
L["Requires syncing the specialization via LibSpecialization."] = "Requires syncing the specialization via LibSpecialization."
L["Resilience (%)"] = "Resilience (%)"
L["Resilience Rating"] = "Resilience Rating"
L["Resist"] = "Resist"
L["Resistances"] = "Resistances"
L["Resisted"] = "Resisted"
L["Rested"] = "Rested"
L["Rested Experience"] = "Rested Experience"
L["Rested Experience (%)"] = "Rested Experience (%)"
L["Resting"] = "Resting"
L["Resurrect"] = "Resurrect"
L["Resurrect Pending"] = "Resurrect Pending"
L["Right"] = "Right"
L["Right to Left"] = "Right to Left"
L["Right, then Centered Vertical"] = "Right, then Centered Vertical"
L["Right, then Down"] = "Right, then Down"
L["Right, then Up"] = "Right, then Up"
L["Role"] = "Role"
L["Rollback snapshot is complete. Thank you for your patience!"] = "Rollback snapshot is complete. Thank you for your patience!"
L["Rotate Animation"] = "Rotate Animation"
L["Rotate Left"] = "Rotate Left"
L["Rotate Right"] = "Rotate Right"
L["Rotation"] = "Rotation"
L["Round"] = "Round"
L["Round Mode"] = "Round Mode"
L["Ruins of Ahn'Qiraj"] = "Ruins of Ahn'Qiraj"
L["Run Custom Code"] = "Run Custom Code"
L["Run Speed (%)"] = "Run Speed (%)"
L["Rune"] = "Rune"
L["Rune #1"] = "Rune #1"
L["Rune #2"] = "Rune #2"
L["Rune #3"] = "Rune #3"
L["Rune #4"] = "Rune #4"
L["Rune #5"] = "Rune #5"
L["Rune #6"] = "Rune #6"
L["Rune Count"] = "Rune Count"
L["Rune Count - Blood"] = "Rune Count - Blood"
L["Rune Count - Frost"] = "Rune Count - Frost"
L["Rune Count - Unholy"] = "Rune Count - Unholy"
L["Sapphiron"] = "Sapphiron"
L["Say"] = "Say"
L["Scale"] = "Scale"
L["Scarlet Enclave"] = "Scarlet Enclave"
L["Scenario"] = "Scenario"
L["Scenario (Heroic)"] = "Scenario (Heroic)"
L["Scenario (Normal)"] = "Scenario (Normal)"
L["Screen"] = "Screen"
L["Screen/Parent Group"] = "Screen/Parent Group"
L["Season of Discovery"] = "Season of Discovery"
L["Second"] = "Second"
L["Second Value of Tooltip Text"] = "Second Value of Tooltip Text"
L["Secondary Stats"] = "Secondary Stats"
L["Seconds"] = "Seconds"
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Select Frame"] = "Select Frame"
L["Select the type of timer to filter"] = "Select the type of timer to filter"
L["Selection Mode"] = "Selection Mode"
L["Separator"] = "Separator"
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "Set IDs can be found on websites such as wowhead.com/cata/item-sets"
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/classic/item-sets"
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "Set IDs can be found on websites such as wowhead.com/item-sets"
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"
L["Shadow Resistance"] = "Shadow Resistance"
L["Shadowlands"] = "Shadowlands"
L["Shake"] = "Shake"
L["Shazzrah"] = "Shazzrah"
L["Shift-Click to resume addon execution."] = "Shift-Click to resume addon execution."
L["Show"] = "Show"
L["Show CD of Charge"] = "Show CD of Charge"
L["Show charged duration for empowered casts"] = "Show charged duration for empowered casts"
L["Show GCD"] = "Show GCD"
L["Show Global Cooldown"] = "Show Global Cooldown"
L["Show Incoming Heal"] = "Show Incoming Heal"
L["Show Loss of Control"] = "Show Loss of Control"
L["Show On"] = "Show On"
L["Show Rested Overlay"] = "Show Rested Overlay"
L["Shrink"] = "Shrink"
L["Silithid Royalty"] = "Silithid Royalty"
L["Silver"] = "Silver"
L["Simple"] = "Simple"
L["Since Active"] = "Since Active"
L["Since Apply"] = "Since Apply"
L["Since Apply/Refresh"] = "Since Apply/Refresh"
L["Since Charge Gain"] = "Since Charge Gain"
L["Since Charge Lost"] = "Since Charge Lost"
L["Since Ready"] = "Since Ready"
L["Since Stack Gain"] = "Since Stack Gain"
L["Since Stack Lost"] = "Since Stack Lost"
L["Size & Position"] = "Size & Position"
L["Skyriding"] = "Skyriding"
L["Slide Animation"] = "Slide Animation"
L["Slide from Bottom"] = "Slide from Bottom"
L["Slide from Left"] = "Slide from Left"
L["Slide from Right"] = "Slide from Right"
L["Slide from Top"] = "Slide from Top"
L["Slide to Bottom"] = "Slide to Bottom"
L["Slide to Left"] = "Slide to Left"
L["Slide to Right"] = "Slide to Right"
L["Slide to Top"] = "Slide to Top"
L["Slider"] = "Slider"
L["Small"] = "Small"
L["Smart Group"] = "Smart Group"
L["Soft Enemy"] = "Soft Enemy"
L["Soft Friend"] = "Soft Friend"
L["Solistrasza"] = "Solistrasza"
L["Sound"] = "Sound"
L["Sound by Kit ID"] = "Sound by Kit ID"
L["Source"] = "Source"
L["Source Affiliation"] = "Source Affiliation"
L["Source GUID"] = "Source GUID"
L["Source Info"] = "Source Info"
L["Source Name"] = "Source Name"
L["Source NPC Id"] = "Source NPC Id"
L["Source Object Type"] = "Source Object Type"
L["Source Raid Mark"] = "Source Raid Mark"
L["Source Reaction"] = "Source Reaction"
L["Source Unit"] = "Source Unit"
L["Source Unit Name/Realm"] = "Source Unit Name/Realm"
L["Source unit's raid mark index"] = "Source unit's raid mark index"
L["Source unit's raid mark texture"] = "Source unit's raid mark texture"
L["Space"] = "Space"
L["Spacing"] = "Spacing"
L["Spark"] = "Spark"
L["Spec Position"] = "Spec Position"
L["Spec Role"] = "Spec Role"
L["Specialization"] = "Specialization"
L["Specific Currency"] = "Specific Currency"
L["Specific Type"] = "Specific Type"
L["Specific Unit"] = "Specific Unit"
L["Spell"] = "Spell"
L["Spell (Building)"] = "Spell (Building)"
L["Spell Activation Overlay Glow"] = "Spell Activation Overlay Glow"
L["Spell Cast Succeeded"] = "Spell Cast Succeeded"
L["Spell Cost"] = "Spell Cost"
L["Spell Count"] = "Spell Count"
L["Spell ID"] = "Spell ID"
L["Spell Id"] = "Spell Id"
L["Spell ID:"] = "Spell ID:"
L["Spell IDs:"] = "Spell IDs:"
L["Spell in Range"] = "Spell in Range"
L["Spell Known"] = "Spell Known"
L["Spell Name"] = "Spell Name"
L["Spell Peneration Percent"] = "Spell Peneration Percent"
L["Spell Power"] = "Spell Power"
L["Spell School"] = "Spell School"
L["Spell Usable"] = "Spell Usable"
L["Spellname"] = "Spellname"
L["Spike"] = "Spike"
L["Spin"] = "Spin"
L["Spiral"] = "Spiral"
L["Spiral In And Out"] = "Spiral In And Out"
L["Spirit"] = "Spirit"
L["Stack Count"] = "Stack Count"
L["Stack trace:"] = "Stack trace:"
L["Stacks"] = "Stacks"
L["Stacks Function"] = "Stacks Function"
L["Stacks Function (fallback state)"] = "Stacks Function (fallback state)"
L["Stage"] = "Stage"
L["Stage Counter"] = "Stage Counter"
L["Stagger"] = "Stagger"
L["Stagger (%)"] = "Stagger (%)"
L["Stagger against Target (%)"] = "Stagger against Target (%)"
L["Stagger Scale"] = "Stagger Scale"
L["Stamina"] = "Stamina"
L["Stance/Form/Aura"] = "Stance/Form/Aura"
L["Standing"] = "Standing"
L["Star Shake"] = "Star Shake"
L["Start Animation"] = "Start Animation"
L["Start Now"] = "Start Now"
L["Start Profiling"] = "Start Profiling"
L["Status"] = "Status"
L["Status Bar"] = "Status Bar"
L["Stolen"] = "Stolen"
L["Stop"] = "Stop"
L["Stop Motion"] = "Stop Motion"
L["Story Raid"] = "Story Raid"
L["Strength"] = "Strength"
L["String"] = "String"
L["Subevent Info"] = "Subevent Info"
L["Subtract Cast"] = "Subtract Cast"
L["Subtract Channel"] = "Subtract Channel"
L["Subtract GCD"] = "Subtract GCD"
L["Subzone Name"] = "Subzone Name"
L["Success"] = "Success"
L["Sulfuron Harbinger"] = "Sulfuron Harbinger"
L["Summon"] = "Summon"
L["Summon Pending"] = "Summon Pending"
L["Sun"] = "Sun"
L["Supports multiple entries, separated by commas"] = "Supports multiple entries, separated by commas"
L[ [=[Supports multiple entries, separated by commas
]=] ] = [=[Supports multiple entries, separated by commas
]=]
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Prefix with '-' for negation."
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=]
L["Swing"] = "Swing"
L["Swing Timer"] = "Swing Timer"
L["Swipe"] = "Swipe"
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = "Syntax /wa feature <toggle|on|enable|disable|off> <feature>"
L["System"] = "System"
L["Systems"] = "Systems"
L["Tab "] = "Tab "
L["Talent"] = "Talent"
L["Talent |cFFFF0000Not|r Known"] = "Talent |cFFFF0000Not|r Known"
L["Talent |cFFFF0000Not|r Selected"] = "Talent |cFFFF0000Not|r Selected"
L["Talent Known"] = "Talent Known"
L["Talent Selected"] = "Talent Selected"
L["Talent selected"] = "Talent selected"
L["Talent Specialization"] = "Talent Specialization"
L["Tanking And Highest"] = "Tanking And Highest"
L["Tanking But Not Highest"] = "Tanking But Not Highest"
L["Target"] = "Target"
L["Targeted"] = "Targeted"
L["Tertiary Stats"] = "Tertiary Stats"
L["Test if bar is enabled in BigWigs settings"] = "Test if bar is enabled in BigWigs settings"
L["Test if bar is enabled in Boss Mod addon settings"] = "Test if bar is enabled in Boss Mod addon settings"
L["Test if bar is enabled in DBM settings"] = "Test if bar is enabled in DBM settings"
L["Text"] = "Text"
L["Text To Speech"] = "Text To Speech"
L["Text-to-speech"] = "Text-to-speech"
L["Texture"] = "Texture"
L["Texture Function"] = "Texture Function"
L["Texture Function (fallback state)"] = "Texture Function (fallback state)"
L["Texture Picker"] = "Texture Picker"
L["Texture Rotation"] = "Texture Rotation"
L["Thaddius"] = "Thaddius"
L["The aura has overwritten the global '%s', this might affect other auras."] = "The aura has overwritten the global '%s', this might affect other auras."
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "The aura tried to overwrite the aura_env global, which is not allowed."
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "The effective level differs from the level in e.g. Time Walking dungeons."
L["The Four Horsemen"] = "The Four Horsemen"
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "The 'ID' value can be found in the BigWigs options of a specific spell"
L["The Prophet Skeram"] = "The Prophet Skeram"
L["The total quantity a warband character can transfer after paying the transfer cost"] = "The total quantity a warband character can transfer after paying the transfer cost"
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "The total quantity after transferring everything to your current character and paying the transfer cost"
L["The War Within"] = "The War Within"
L["There are %i updates to your auras ready to be installed!"] = "There are %i updates to your auras ready to be installed!"
L["Thick Outline"] = "Thick Outline"
L["Thickness"] = "Thickness"
L["Third"] = "Third"
L["Third Value of Tooltip Text"] = "Third Value of Tooltip Text"
L["This aura calls GetData a lot, which is a slow function."] = "This aura calls GetData a lot, which is a slow function."
L["This aura has caused a Lua error."] = "This aura has caused a Lua error."
L["This aura is saving %s KB of data"] = "This aura is saving %s KB of data"
L["This aura plays a sound via a condition."] = "This aura plays a sound via a condition."
L["This aura plays a sound via an action."] = "This aura plays a sound via an action."
L["This aura plays a Text To Speech via a condition."] = "This aura plays a Text To Speech via a condition."
L["This aura plays a Text To Speech via an action."] = "This aura plays a Text To Speech via an action."
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."
L["Threat Percent"] = "Threat Percent"
L["Threat Situation"] = "Threat Situation"
L["Threat Value"] = "Threat Value"
L["Tick"] = "Tick"
L["Time"] = "Time"
L["Time Format"] = "Time Format"
L["Time in GCDs"] = "Time in GCDs"
L["Time since initial application"] = "Time since initial application"
L["Time since last refresh"] = "Time since last refresh"
L["Time since stack gain"] = "Time since stack gain"
L["Time since stack lost"] = "Time since stack lost"
L["Timed"] = "Timed"
L["Timed Progress"] = "Timed Progress"
L["Timer"] = "Timer"
L["Timer Id"] = "Timer Id"
L["Toggle"] = "Toggle"
L["Toggle List"] = "Toggle List"
L["Toggle Options Window"] = "Toggle Options Window"
L["Toggle Performance Profiling Window"] = "Toggle Performance Profiling Window"
L["Tooltip"] = "Tooltip"
L["Tooltip 1"] = "Tooltip 1"
L["Tooltip 2"] = "Tooltip 2"
L["Tooltip 3"] = "Tooltip 3"
L["Tooltip Value 1"] = "Tooltip Value 1"
L["Tooltip Value 2"] = "Tooltip Value 2"
L["Tooltip Value 3"] = "Tooltip Value 3"
L["Tooltip Value 4"] = "Tooltip Value 4"
L["Top"] = "Top"
L["Top Left"] = "Top Left"
L["Top Right"] = "Top Right"
L["Top to Bottom"] = "Top to Bottom"
L["Torghast"] = "Torghast"
L["Total Duration"] = "Total Duration"
L["Total Earned in this Season"] = "Total Earned in this Season"
L["Total Essence"] = "Total Essence"
L["Total Experience"] = "Total Experience"
L["Total Match Count"] = "Total Match Count"
L["Total Reputation"] = "Total Reputation"
L["Total Stacks"] = "Total Stacks"
L["Total stacks over all matches"] = "Total stacks over all matches"
L["Total Stages"] = "Total Stages"
L["Total Unit Count"] = "Total Unit Count"
L["Total Units"] = "Total Units"
L["Totem"] = "Totem"
L["Totem #%i"] = "Totem #%i"
L["Totem Icon"] = "Totem Icon"
L["Totem Name"] = "Totem Name"
L["Totem Name Pattern Match"] = "Totem Name Pattern Match"
L["Totem Number"] = "Totem Number"
L["Track Cooldowns"] = "Track Cooldowns"
L["Tracking Charge %i"] = "Tracking Charge %i"
L["Tracking Charge CDs"] = "Tracking Charge CDs"
L["Tracking Only Cooldown"] = "Tracking Only Cooldown"
L["Transmission error"] = "Transmission error"
L["Trigger"] = "Trigger"
L["Trigger %i"] = "Trigger %i"
L["Trigger %s"] = "Trigger %s"
L["Trigger 1"] = "Trigger 1"
L["Trigger State Updater (Advanced)"] = "Trigger State Updater (Advanced)"
L["Trigger Update"] = "Trigger Update"
L["Trigger:"] = "Trigger:"
L["Trivial (Low Level)"] = "Trivial (Low Level)"
L["True"] = "True"
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "Trying to repair broken conditions in %s likely caused by a WeakAuras bug."
L["Twin Emperors"] = "Twin Emperors"
L["Type"] = "Type"
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."
L["Unaffected"] = "Unaffected"
L["Undefined"] = "Undefined"
L["Unholy"] = "Unholy"
L["Unholy Rune #1"] = "Unholy Rune #1"
L["Unholy Rune #2"] = "Unholy Rune #2"
L["Unit"] = "Unit"
L["Unit Characteristics"] = "Unit Characteristics"
L["Unit Destroyed"] = "Unit Destroyed"
L["Unit Died"] = "Unit Died"
L["Unit Dissipates"] = "Unit Dissipates"
L["Unit Frame"] = "Unit Frame"
L["Unit Frames"] = "Unit Frames"
L["Unit is Unit"] = "Unit is Unit"
L["Unit Name"] = "Unit Name"
L["Unit Name/Realm"] = "Unit Name/Realm"
L["Units Affected"] = "Units Affected"
L["Units of affected Players in a table format"] = "Units of affected Players in a table format"
L["Units of unaffected Players in a table format"] = "Units of unaffected Players in a table format"
L["Unknown action %q"] = "Unknown action %q"
L["Unknown feature %q"] = "Unknown feature %q"
L["unknown location"] = "unknown location"
L["Unlimited"] = "Unlimited"
L["Untrigger %s"] = "Untrigger %s"
L["Up"] = "Up"
L["Up, then Centered Horizontal"] = "Up, then Centered Horizontal"
L["Up, then Left"] = "Up, then Left"
L["Up, then Right"] = "Up, then Right"
L["Update Position"] = "Update Position"
L["Usage:"] = "Usage:"
L["Use /wa minimap to show the minimap icon again."] = "Use /wa minimap to show the minimap icon again."
L["Use Custom Color"] = "Use Custom Color"
L["Use Legacy floor rounding"] = "Use Legacy floor rounding"
L["Use Texture"] = "Use Texture"
L["Use Watched Faction"] = "Use Watched Faction"
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."
L["Vaelastrasz the Corrupt"] = "Vaelastrasz the Corrupt"
L["Versatility (%)"] = "Versatility (%)"
L["Versatility Rating"] = "Versatility Rating"
L["Vertical"] = "Vertical"
L["Viscidus"] = "Viscidus"
L["Visibility"] = "Visibility"
L["Visions of N'Zoth"] = "Visions of N'Zoth"
L["Warband Quantity Total"] = "Warband Quantity Total"
L["Warband Transfer Percentage"] = "Warband Transfer Percentage"
L["Warband Transferred Quantity"] = "Warband Transferred Quantity"
L["Warfront (Heroic)"] = "Warfront (Heroic)"
L["Warfront (Normal)"] = "Warfront (Normal)"
L["Warlords of Draenor"] = "Warlords of Draenor"
L["Warning"] = "Warning"
L["Warning for unknown aura:"] = "Warning for unknown aura:"
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = "Warning: Full Scan auras checking for both name and spell id can't be converted."
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = "Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."
L["WeakAuras Profiling"] = "WeakAuras Profiling"
L["WeakAuras Profiling Report"] = "WeakAuras Profiling Report"
L["WeakAuras Version: %s"] = "WeakAuras Version: %s"
L["Weapon"] = "Weapon"
L["Weapon Enchant"] = "Weapon Enchant"
L["Weapon Enchant / Fishing Lure"] = "Weapon Enchant / Fishing Lure"
L["Whisper"] = "Whisper"
L["Width"] = "Width"
L["Wobble"] = "Wobble"
L["World Boss"] = "World Boss"
L["World Bosses"] = "World Bosses"
L["Wrap"] = "Wrap"
L["Wrath of the Lich King"] = "Wrath of the Lich King"
L["Writing to the WeakAuras table is not allowed."] = "Writing to the WeakAuras table is not allowed."
L["X-Offset"] = "X-Offset"
L["Yell"] = "Yell"
L["Y-Offset"] = "Y-Offset"
L["You have new auras ready to be installed!"] = "You have new auras ready to be installed!"
L["Your next encounter will automatically be profiled."] = "Your next encounter will automatically be profiled."
L["Your next instance of combat will automatically be profiled."] = "Your next instance of combat will automatically be profiled."
L["Your scheduled automatic profile has been cancelled."] = "Your scheduled automatic profile has been cancelled."
L["Your threat as a percentage of the tank's current threat."] = "Your threat as a percentage of the tank's current threat."
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."
L["Your total threat on the mob."] = "Your total threat on the mob."
L["Zone Group ID"] = "Zone Group ID"
L["Zone ID"] = "Zone ID"
L["Zone Name"] = "Zone Name"
L["Zoom"] = "Zoom"
L["Zoom Animation"] = "Zoom Animation"
L["Zul'Gurub"] = "Zul'Gurub"


-- Make missing translations available
setmetatable(WeakAuras.L, {__index = function(self, key)
  self[key] = (key or "")
  return key
end})



-- ========================================
-- File: WeakAuras/Locales/esES.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "esES" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = "Formatos de filtro: 'Nombre', 'Nombre-Reino', '-Reino'. Admite varias entradas, separadas por comas Puedes utilizar \\ para escapar -."
L["%s Overlay Color"] = "%s Color de superposicin"
L["* Suffix"] = "* Sufijo"
L["/wa help - Show this message"] = "/wa help - Muestra este mensaje"
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - Mostrar el botn del minimapa"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - Muestra los resultados de los perfiles ms recientes"
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart: inicia perfilados. Opcionalmente, incluya una duracin en segundos despus de la cual perfilado se detiene automticamente. Para perfilar el prximo combate/encuentro, pase un argumento de \"combate\" o \"encuentro\"."
L["/wa pstop - Finish profiling"] = "/wa pstop - Finalizar perfilado"
L["/wa repair - Repair tool"] = "/wa repair - Herramienta de reparacin"
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55fClic izquierdo|r para mostrar la ventana principal."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55fClic central|r para mostrar el icono del minimapa."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55fClic derecho|r para mostrar la ventana de perfiles de rendimiento."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fMays clic|r para pausar la ejecucin del addon."
L["|cffff0000deprecated|r"] = "|cffff0000obsoleto|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000No|r equipado ID bonus de objeto"
L["|cFFFF0000Not|r Item Equipped"] = "Objeto |cFFFF0000no|r equipado"
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000No|r nombre/reino del jugador"
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000No|r hechizo conocido"
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = "|cFFFF0000El soporte para COMBAT_LOG_EVENT_UNFILTERED sin filtro est obsoleto|r COMBAT_LOG_EVENT_UNFILTERED sin un filtro estn deshabilitados ya que son muy costosos en trminos de rendimiento. Ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00Opciones adicionales:|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00Opciones adicionales:|r Ninguno"
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = " |cff00ff00Jugador|r, |cff00ff00Objetivo|r, |cff00ff00Enfoque|r y |cff00ff00Mascota|r corresponden directamente a esos ID de unidad individuales.  |cff00ff00Unidad especfica|r te permite proporcionar un ID de unidad vlido especfico para observar. |cffff0000Nota|r: El juego no activar eventos para todos los ID de unidad vlidos, lo que har que este activador no pueda rastrear algunos.  |cffffff00Grupo|r, |cffffff00Banda|r, |cffffff00Jefe|r, |cffffff00Arena|r y |cffffff00Placa de nombre|r pueden coincidir con mltiples ID de unidad correspondientes.  |cffffff00Grupo inteligente|r se ajusta a tu tipo de grupo actual, haciendo coincidir solo el \"jugador\" cuando ests solo, las unidades de \"grupo\" (incluido el \"jugador\") en un grupo o las unidades de \"banda\" en una banda. |cffffff00*|r La configuracin de la unidad amarilla crear clones para cada unidad coincidente mientras este activador proporciona informacin dinmica a la aura."
L["1. Profession 1. Accessory"] = "1. Profesin 1. Accesorio"
L["1. Profession 2. Accessory"] = "1. Profesin 2. Accesorio"
L["1. Professsion Tool"] = "1. Herramienta de profesin"
L["10 Man Raid"] = "Banda de 10 jugadores"
L["10 Player Raid"] = "Banda de 10 jugadores"
L["10 Player Raid (Heroic)"] = "Banda de 10 jugadores (heroico)"
L["10 Player Raid (Normal)"] = "Banda de 10 jugadores (normal)"
L["2. Profession 1. Accessory"] = "2. Profesin 1. Accesorio"
L["2. Profession 2. Accessory"] = "2. Profesin 2. Accesorio"
L["2. Professsion Tool"] = "2. Herramienta de profesin"
L["20 Man Raid"] = "Banda de 20 jugadores"
L["20 Player Raid"] = "Banda de 20 jugadores"
L["25 Man Raid"] = "Banda de 25 jugadores"
L["25 Player Raid"] = "Banda de 25 jugadores"
L["25 Player Raid (Heroic)"] = "Banda de 25 jugadores (heroico)"
L["25 Player Raid (Normal)"] = "Banda de 25 jugadores (normal)"
L["40 Man Raid"] = "Banda de 40 jugadores"
L["40 Player Raid"] = "Banda de 40 jugadores"
L["5 Man Dungeon"] = "Mazmorra de 5 jugadores"
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = "Una descripcin detallada de tus sistemas de auras y WeakAuras. Copia todo el texto en el Discord de WeakAura si necesitas ayuda."
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "Un activador de esta aura est configurado para rastrear una unidad de tipo soft target, pero no tienes configuradas las CVars para que esto funcione correctamente. Considera la posibilidad de cambiar la unidad rastreada o de configurar las CVars de soft target."
L["Abbreviate"] = "Abreviar"
L["AbbreviateLargeNumbers (Blizzard)"] = "AbreviarNmerosGrandes (Blizzard)"
L["AbbreviateNumbers (Blizzard)"] = "AbreviarNmeros (Blizzard)"
L["Absorb"] = "Absorcin"
L["Absorb and Healing"] = "Absorpcin y sanacin"
L["Absorb Heal Overlay"] = "Superposicin de absorcin de sanacin"
L["Absorb Overlay"] = "Superposicin de absorcin"
L["Absorbed"] = "Absorbido"
L["Action Button Glow"] = "Resplandor del botn de accin"
L["Actions"] = "Acciones"
L["Active"] = "Activo"
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Addon de mdulo de jefe activo: |cFFffcc00BigWigs|r Nota: Este activador utilizar BigWigs o DBM, en ese orden si ambos estn instalados."
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Addon de mdulo de jefe activo: |cFFffcc00DBM|r Nota: Este activador utilizar BigWigs o DBM, en ese orden si ambos estn instalados."
L["Add"] = "Aadir"
L["Add Missing Auras"] = "Aadir auras perdidas"
L["Advanced Caster's Target Check"] = "Comprobacin avanzada del objetivo del lanzador"
L["Affected"] = "Afectado"
L["Affected Unit Count"] = "Recuento de unidades afectadas"
L["Afk"] = "Ausente"
L["Aggro"] = "Amenaza"
L["Agility"] = "Agilidad"
L["Ahn'Qiraj"] = "Ahn'Qiraj"
L["Alert Type"] = "Tipo de alerta"
L["Alive"] = "Vivo"
L["All"] = "Todo"
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "Todos los hijos de esta aura tampoco se cargarn, para minimizar la posibilidad de una corrupcin adicional."
L["All States table contains a non table at key: '%s'."] = "La tabla Todos los estados contiene una no tabla en la clave: '%s'."
L["All Triggers"] = "Todos los activadores"
L["Alliance"] = "Alianza"
L["Allow partial matches"] = "Permitir coincidencias parciales"
L["Alpha"] = "Transparencia"
L["Alternate Power"] = "Poder Alternativa"
L["Always"] = "Siempre"
L["Always active trigger"] = "Siempre activar activador"
L["Always include realm"] = "Incluir siempre el reino"
L["Always True"] = "Siempre verdadero"
L["Amount"] = "Cantidad"
L["Anchoring"] = "Anclaje"
L["And Talent"] = "y talento"
L["Angle and Radius"] = "ngulo y radio"
L["Animations"] = "Animaciones"
L["Anticlockwise"] = "Sentido antihorario"
L["Anub'Rekhan"] = "Anub'Rekhan"
L["Any"] = "Cualquiera"
L["Any Triggers"] = "Cualquier activador"
L["AOE"] = "AOE"
L["Arcane Resistance"] = "Resistencia arcana"
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = "Ests seguro de que quieres ejecutar la herramienta de reparacin |cffff0000EXPERIMENTAL|r? Esto sobrescribir cualquier cambio que hayas realizado desde la ltima actualizacin de la base de datos. ltima actualizacin: %s"
L["Arena"] = "Arena"
L["Armor (%)"] = "Armadura (%)"
L["Armor against Target (%)"] = "Armadura contra objetivo (%)"
L["Armor Rating"] = "ndice de armadura"
L["Array"] = "Formacin"
L["Ascending"] = "Ascendente"
L["Assigned Role"] = "Rol asignado"
L["Assigned Role Icon"] = "Icono del rol asignado"
L["Assist"] = "Ayudante"
L["Assisted Combat Next Cast"] = "Prximo lanzamiento de combate asistido"
L["At Least One Enemy"] = "Como Mnimo un Enemigo"
L["At missing Value"] = "Al faltar el valor"
L["At Percent"] = "Al porcentaje"
L["At Value"] = "Al valor"
L["At War"] = "En guerra"
L["Attach to End"] = "Fijar al final"
L["Attach to End, backwards"] = "Adjuntar al final, al revs"
L["Attach to Point"] = "Adjuntar al punto"
L["Attach to Start"] = "Fijar al inicio"
L["Attack Power"] = "Poder de ataque"
L["Attackable"] = "Atacable"
L["Attackable Target"] = "Objetivo atacable"
L["Aura"] = "Aura"
L["Aura '%s': %s"] = "Aura '%s': %s"
L["Aura Applied"] = "Aura aplicada"
L["Aura Applied Dose"] = "Dosis de aura aplicada"
L["Aura Broken"] = "Aura rota"
L["Aura Broken Spell"] = "Hechizo de aura rota"
L["Aura is using deprecated SetDurationInfo"] = "Aura est utilizando SetDurationInfo obsoleto"
L["Aura loaded"] = "Aura cargada"
L["Aura Name"] = "Nombre de aura"
L["Aura Names"] = "Nombres de aura"
L["Aura Refresh"] = "Actualizar aura"
L["Aura Removed"] = "Aura eliminada"
L["Aura Removed Dose"] = "Dosis de aura eliminada"
L["Aura Stack"] = "Acumulacin de Auras"
L["Aura Type"] = "Tipo de aura"
L["Aura Version: %s"] = "Versin del aura: %s"
L["Aura(s) Found"] = "Aura(s) encontrada(s)"
L["Aura(s) Missing"] = "Aura(s) faltante(s)"
L["Aura:"] = "Aura:"
L["Auras"] = "Auras"
L["Auras:"] = "Auras:"
L["Author Options"] = "Opciones de autor"
L["Auto"] = "Auto"
L["Autocast Shine"] = "Brillo de lanzamiento automtico"
L["Automatic"] = "Automtico"
L["Automatic Length"] = "Longitud automtica"
L["Automatic Rotation"] = "Rotacin automtica"
L["Available features: %s"] = "Caractersticas disponibles: %s"
L["Avoidance (%)"] = "Evasin (%)"
L["Avoidance Rating"] = "ndice de evasin"
L["Ayamiss the Hunter"] = "Ayamiss el Cazador"
L["Azuregos"] = "Azuregos"
L["Back and Forth"] = "De Atrs a Adelante"
L["Background"] = "Fondo"
L["Background Color"] = "Color de fondo"
L["Balnazzar"] = "Balnazzar"
L["Bar Color/Gradient Start"] = "Inicio de color de barra/gradiente"
L["Bar enabled in BigWigs settings"] = "Barra activada en la configuracin de BigWigs"
L["Bar enabled in Boss Mod addon settings"] = "Barra activada en la configuracin del addon del mdulo de jefe"
L["Bar enabled in DBM settings"] = "Barra activada en la configuracin de DBM"
L["Bar Texture"] = "Textura de barra"
L["Bar Type"] = "Tipo de barra"
L["Baron Geddon"] = "Barn Geddon"
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "Battle.net Mensaje"
L["Battleground"] = "Campo de Batalla"
L["Battleguard Sartura"] = "Guardia de batalla Sartura"
L["Beastmaster"] = "Maestro de bestias"
L["Beatrix"] = "Beatrix"
L["BG>Raid>Party>Say"] = "BG>Banda>Grupo>Decir"
L["BG-System Alliance"] = "Campo de Batalla - Alianza"
L["BG-System Horde"] = "Campo de Batalla - Horda"
L["BG-System Neutral"] = "Campo de Batalla - Neutral"
L["Big Number"] = "Nmero grande"
L["BigWigs Addon"] = "Addon de BigWigs"
L["BigWigs Message"] = "Mensaje de BigWigs"
L["BigWigs Stage"] = "Etapa de BigWigs"
L["BigWigs Timer"] = "Temporizador de BigWigs"
L["Black Wing Lair"] = "Guarida de Alanegra"
L["Bleed"] = "Sangrado"
L["Blizzard Combat Text"] = "Texto de Combate de Blizzard"
L["Blizzard Cooldown Reduction"] = "Reduccin de reutilizacin de Blizzard"
L["Block"] = "Bloqueo"
L["Block (%)"] = "Bloquear (%)"
L["Block against Target (%)"] = "Bloqueo contra objetivo (%)"
L["Block Value"] = "Valor de bloqueo"
L["Blocked"] = "Bloqueado"
L["Blood"] = "Sangre"
L["Blood Rune #1"] = "Runa sangrienta #1"
L["Blood Rune #2"] = "Runa sangrienta #2"
L["Bloodlord Mandokir"] = "Seor sangriento Mandokir"
L["Bonus Reputation Gain"] = "Bonus de reputacin ganada"
L["Border"] = "Borde"
L["Boss"] = "Jefe"
L["Boss Emote"] = "Jefe - Emocin"
L["Boss Mod Announce"] = "Anuncio de mdulo de jefe"
L["Boss Mod Stage"] = "Etapa de mdulo de jefe"
L["Boss Mod Stage (Event)"] = "Etapa (evento) de mdulo de jefe"
L["Boss Mod Timer"] = "Temporizador de mdulo de jefe"
L["Boss Whisper"] = "Susurro de jefe"
L["Bottom"] = "Abajo"
L["Bottom Left"] = "Abajo Izquierda"
L["Bottom Right"] = "Abajo Derecha"
L["Bottom to Top"] = "De Abajo a Arriba"
L["Bounce"] = "Rebotar"
L["Bounce with Decay"] = "Rebotar con Amortiguacin"
L["Break"] = "Romper"
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers (Blizzard)"
L["Broodlord Lashlayer"] = "Seor de linaje Capazote"
L["Buff"] = "Beneficio"
L["Buff/Debuff"] = "Beneficio/Perjuicio"
L["Buffed/Debuffed"] = "Beneficio activo/Perjuicio activo"
L["Burning Crusade"] = "Burning Crusade"
L["Buru the Gorger"] = "Buru el Manducador"
L["Caldoran"] = "Caldoran"
L["Callback function"] = "Funcin de rellamada"
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "Se puede utilizar, por ejemplo, para comprobar si \"boss1target\" es el mismo que \"player\"."
L["Cancel"] = "Cancelar"
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "No se puede cambiar el marco de seguridad en el bloqueo de combate. Ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "No se puede programar el temporizador con %i, debido a un error de World of Warcraft con un alto tiempo de actividad del ordenador. (Tiempo de actividad: %i). Por favor, reinicia tu ordenador."
L["Capped"] = "Lmite"
L["Capped at Season Max"] = "Lmite de mx. de la temporada"
L["Capped at Weekly Max"] = "Lmite de mx. semanal"
L["Cast"] = "Lanzar Hechizo"
L["Cast Bar"] = "Barra de lanzamiento"
L["Cast Failed"] = "Hechizo - Fallido"
L["Cast Start"] = "Hechizo - Empezar"
L["Cast Success"] = "Hechizo - Completado"
L["Cast Type"] = "Tipo de Hechizo"
L["Caster"] = "Lanzador"
L["Caster Name"] = "Nombre del lanzador"
L["Caster Realm"] = "Reino del lanzador"
L["Caster Unit"] = "Unidad del lanzador"
L["Casters Name/Realm"] = "Nombre/reino del lanzador"
L["Caster's Target"] = "Objetivo del lanzador"
L["Cataclysm"] = "Cataclysm"
L["Ceil"] = "Ceil"
L["Center"] = "Centro"
L["Center, then alternating bottom and top"] = "Centro, luego alternando abajo y arriba"
L["Center, then alternating left and right"] = "Centro, luego alternando izquierda y derecha"
L["Center, then alternating right and left"] = "Centro, luego alternando derecha e izquierda"
L["Center, then alternating top and bottom"] = "Centro, luego alternando arriba y abajo"
L["Centered Horizontal"] = "Centrado Horizontal"
L["Centered Horizontal, then Centered Vertical"] = "Centrado horizontal, luego centrado vertical"
L["Centered Horizontal, then Down"] = "Centrado horizontal, luego hacia abajo"
L["Centered Horizontal, then Up"] = "Centrado horizontal, luego hacia arriba"
L["Centered Vertical"] = "Centrado Vertical"
L["Centered Vertical, then Centered Horizontal"] = "Centrado vertical, luego centrado horizontal"
L["Centered Vertical, then Left"] = "Centrado vertical, luego a la izquierda"
L["Centered Vertical, then Right"] = "Centrado vertical, luego a la derecha"
L["Changed"] = "Modificado"
L["Channel"] = "Canal"
L["Channel (Spell)"] = "Canalizar Hechizo"
L["Character GUID"] = "GUID del personaje"
L["Character Name"] = "Nombre de personaje"
L["Character Stats"] = "Estadsticas del personaje"
L["Character Transferred Quantity"] = "Cantidad transferida de personaje"
L["Character Type"] = "Tipo de Personaje"
L["Charge gained/lost"] = "Carga ganada/perdida"
L["Charged Combo Points"] = "Puntos de combo cargados"
L["Charges"] = "Cargas"
L["Charges Changed Event"] = "Cargas de evento cambiado"
L["Charging"] = "Cargando"
L["Chat Frame"] = "Marco de Chat"
L["Chat Message"] = "Mensaje de Chat"
L["Check if a single talent match a Rank"] = "Comprobar si un talento coincide con un rango"
L["Check nameplate's target every 0.2s"] = "Comprueba el objetivo del nombre de placa cada 0.2s"
L["Chromaggus"] = "Chromaggus"
L["Circle"] = "Crculo"
L["Circular Texture"] = "Textura circular"
L["Clamp"] = "Sujetar"
L["Class"] = "Clase"
L["Class and Specialization"] = "Clase y especializacin"
L["Classic"] = "Clsico"
L["Classification"] = "Clasificacin"
L["Clockwise"] = "En sentido horario"
L["Clone per Character"] = "Clonar por personaje"
L["Clone per Event"] = "Clonar por evento"
L["Clone per Match"] = "Clonar por encuentro"
L["Coin Precision"] = "Precisin de monedas"
L["Color"] = "Color"
L["Color Animation"] = "Animacin de color"
L["Combat Log"] = "Registro de Combate"
L["Communities"] = "Comunidades"
L["Condition Custom Test"] = "Prueba personalizada de condicin"
L["Conditions"] = "Condiciones"
L["Contains"] = "Contiene"
L["Continuously update Movement Speed"] = "Actualizacin continua de la velocidad de movimiento"
L["Cooldown"] = "Reutilizacin"
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "Las barras de reutilizacin muestran el tiempo que transcurre antes de que una habilidad est lista para ser utilizada, BigWigs las indica con el prefijo \"~\"."
L["Cooldown Progress (Item)"] = "Recarga en Progreso (Objeto)"
L["Cooldown Progress (Slot)"] = "Progreso de reutilizacin (ranura)"
L["Cooldown Ready Event"] = "Evento de reutilizacin preparado"
L["Cooldown Ready Event (Item)"] = "Evento de reutilizacin preparado (objeto)"
L["Cooldown Ready Event (Slot)"] = "Evento de reutilizacin preparado (ranura)"
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "Reduccin de reutilizacin cambia la duracin de los segundos en lugar de mostrar los segundos en tiempo real."
L["Cooldown/Charges/Count"] = "Reutilizacin/Cargas/Recuento"
L["Copper"] = "Cobre"
L["Could not load WeakAuras Archive, the addon is %s"] = "No se pudo cargar WeakAuras Archive, el addon est %s"
L["Count"] = "Recuento"
L["Counter Clockwise"] = "En sentido anti-horario"
L["Create"] = "Crear"
L["Creature Family"] = "Familia de criatura"
L["Creature Family Name"] = "Nombre de familia de criatura"
L["Creature Type"] = "Tipo de criatura"
L["Creature Type Name"] = "Nombre de tipo de criatura"
L["Critical"] = "Crtico"
L["Critical (%)"] = "Crtico (%)"
L["Critical Rating"] = "ndice de crtico"
L["Crop X"] = "Recorte X"
L["Crop Y"] = "Recorte Y"
L["Crowd Controlled"] = "Bajo Control"
L["Crushing"] = "Golpe Aplastador"
L["C'thun"] = "C'thun"
L["Cumulated time used during profiling"] = "Tiempo acumulado utilizado durante el perfilado."
L["Currency"] = "Moneda"
L["Current Essence"] = "Esencia actual"
L["Current Experience"] = "Experiencia actual"
L["Current Instance"] = "Estancia actual"
L["Current Movement Speed (%)"] = "Velocidad de movimiento actual (%)"
L["Current Stage"] = "Etapa actual"
L["Current Zone"] = "Zona actual"
L["Current Zone Group"] = "Grupo de zona actual"
L["Curse"] = "Maldicin"
L["Custom"] = "Personalizado"
L["Custom Action"] = "Accin personalizada"
L["Custom Anchor"] = "Ancla personalizada"
L["Custom Check"] = "Comprobacin personalizada"
L["Custom Color"] = "Color personalizado"
L["Custom Condition Code"] = "Cdigo de condicin personalizado"
L["Custom Configuration"] = "Configuracin personalizada"
L["Custom Fade Animation"] = "Animacin de fundido personalizada"
L["Custom Function"] = "Funcin Personalizada"
L["Custom Grow"] = "Crecimiento personalizado"
L["Custom Sort"] = "Orden personalizado"
L["Custom Text Function"] = "Funcin de texto personalizado"
L["Custom Trigger Combination"] = "Combinacin de activadores personalizada"
L["Custom Variables"] = "Variables personalizadas"
L["Damage"] = "Dao"
L["Damage Shield"] = "Escudo Daino"
L["Damage Shield Missed"] = "Escudo Daino Fallido"
L["Damage Split"] = "Dao Repartido"
L["DBM Announce"] = "Anuncio de DBM"
L["DBM Stage"] = "Etapa de DBM"
L["DBM Timer"] = "Temporizador de DBM"
L["Dead"] = "Muerto"
L["Death"] = "Muerte"
L["Death Knight Rune"] = "Caballero de la Muerte - Runa"
L["Debuff"] = "Perjuicio"
L["Debuff Class"] = "Clase del perjuicio"
L["Debuff Class Icon"] = "Icono de clase del perjuicio"
L["Debuff Type"] = "Tipo de perjuicio"
L["Debug Log contains more than 1000 entries"] = "El registro de depuracin contiene ms de 1000 entradas"
L["Debug Logging enabled"] = "Registro de depuracin activado"
L["Debug Logging enabled for '%s'"] = "Registro de depuracin activado para '%s'."
L["Defensive Stats"] = "Estadsticas defensivas"
L["Deflect"] = "Desviar"
L["Delve"] = "Profundidad"
L["Desaturate"] = "Desaturar"
L["Desaturate Background"] = "Desaturar fondo"
L["Desaturate Foreground"] = "Desaturar primer plano"
L["Descending"] = "Descendente"
L["Description"] = "Descripcin"
L["Dest Raid Mark"] = "Marca de banda de destino"
L["Destination Affiliation"] = "Afiliacin de destino"
L["Destination GUID"] = "GUID del destino"
L["Destination Info"] = "Info del destino"
L["Destination Name"] = "Nombre del Destino"
L["Destination NPC Id"] = "ID de PNJ del destino"
L["Destination Object Type"] = "Tipo de objeto del destino"
L["Destination Reaction"] = "Reaccin de destino"
L["Destination Unit"] = "Unidad de Destino"
L["Destination unit's raid mark index"] = "ndice de marcas de banda de la unidad de destino"
L["Destination unit's raid mark texture"] = "Textura de marcas de banda de la unidad de destino"
L["Difficulty"] = "Dificultad"
L["Disable Spell Known Check"] = "Desactivar comprobacin de hechizo conocido"
L["Disabled"] = "Desactivado"
L["Disabled feature %q"] = "Caracterstica desactivada: %q"
L["Disabled Spell Known Check"] = "Desactivar comprobacin de hechizo conocido"
L["Discovered"] = "Descubierto"
L["Disease"] = "Enfermedad"
L["Dispel"] = "Disipar"
L["Dispel Failed"] = "Disipar Fallido"
L["Display"] = "Visualizacin"
L["Distance"] = "Distancia"
L["Do Not Disturb"] = "No molestar"
L["Dodge"] = "Esquivar"
L["Dodge (%)"] = "Esquivar (%)"
L["Dodge Rating"] = "ndice de esquiva"
L["Down"] = "Abajo"
L["Down, then Centered Horizontal"] = "Abajo, luego centrado horizontal"
L["Down, then Left"] = "Abajo, luego izquierda"
L["Down, then Right"] = "Abajo, luego derecha"
L["Dragonflight"] = "Dragonflight"
L["Drain"] = "Drenar"
L["Dropdown Menu"] = "Men desplegable"
L["Dumping table"] = "Tabla de descarga"
L["Dungeon (Celestial)"] = "Mazmorra (Celestial)"
L["Dungeon (Heroic)"] = "Mazmorra (Heroico)"
L["Dungeon (Mythic)"] = "Mazmorra (Mtico)"
L["Dungeon (Mythic+)"] = "Mazmorra (Mtico+)"
L["Dungeon (Normal)"] = "Mazmorra (Normal)"
L["Dungeon (Timewalking)"] = "Mazmorra (Paseo en el tiempo)"
L["Dungeons"] = "Mazmorras"
L["Durability Damage"] = "Dao a la Durabilidad"
L["Durability Damage All"] = "Dao a la Durabilidad Total"
L["Duration"] = "Duracin"
L["Duration Function"] = "Funcin de duracin"
L["Duration Function (fallback state)"] = "Funcin de duracin (estado de reserva)"
L["Ease In"] = "Entrar"
L["Ease In and Out"] = "Entrar y salir"
L["Ease Out"] = "Salir"
L["Ebonroc"] = "Ebanorroca"
L["Eclipse Direction"] = "Direccin de Eclipse"
L["Edge"] = "Borde"
L["Edge of Madness"] = "Cabo de la Locura"
L["Effective Spell Id"] = "ID de hechizo efectivo"
L["Elide"] = "Omitir"
L["Elite"] = "lite"
L["Emote"] = "Emocion"
L["Empower Cast End"] = "Empoderar fin de lanzamiento"
L["Empower Cast Interrupt"] = "Empoderar interrupcin de lanzamiento"
L["Empower Cast Start"] = "Empoderar inicio de lanzamiento"
L["Empowered"] = "Empoderado"
L["Empowered 1"] = "Empoderado 1"
L["Empowered 2"] = "Empoderado 2"
L["Empowered 3"] = "Empoderado 3"
L["Empowered 4"] = "Empoderado 4"
L["Empowered 5"] = "Empoderado 5"
L["Empowered Cast"] = "Lanzamiento empoderado"
L["Empowered Cast Fully Charged"] = "Empoderar lanzamiento cargado completamente"
L["Empowered Fully Charged"] = "Empoderar carga completa"
L["Empty"] = "Ninguna"
L["Enabled feature %q"] = "Caracterstica activada: %q"
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "Activa el redondeo (incorrecto) a la baja de los segundos, que era el comportamiento anterior por defecto."
L["Enchant Applied"] = "Encantamiento aplicado"
L["Enchant Found"] = "Encantar encontrado"
L["Enchant ID"] = "ID de encantamiento"
L["Enchant Missing"] = "Falta encantamiento"
L["Enchant Name or ID"] = "Nombre o ID del encantamiento"
L["Enchant Removed"] = "Encantamiento eliminado"
L["Enchanted"] = "Encantado"
L["Encounter ID(s)"] = "ID(s) del encuentro"
L["Energize"] = "Vigorizar"
L["Enrage"] = "Enfurecido"
L["Enter a name or a spellId"] = "Entrar un nombre o ID de hechizo"
L["Entering"] = "Accediendo"
L["Entering/Leaving Combat"] = "Entrar/Salir de combate"
L["Entering/Leaving Encounter"] = "Comenzando/saliendo encuentro"
L["Entry Order"] = "Orden de entrada"
L["Environment Type"] = "Tipo de Entorno"
L["Environmental"] = "Ambiental"
L["Equipment"] = "Equipo"
L["Equipment Set"] = "Conjunto de equipo"
L["Equipment Set Equipped"] = "Conjunto de equipo equipado"
L["Equipment Slot"] = "Ranura para equipo"
L["Equipped"] = "Equipado"
L["Error"] = "Error"
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "El error '%s' ha creado un clon seguro. Aconsejamos eliminar el aura. Para ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Error decoding."] = "Error al descodificar."
L["Error decompressing"] = "Error al descomprimir"
L["Error decompressing. This doesn't look like a WeakAuras import."] = "Error al descomprimir. Esto no parece una importacin de WeakAuras."
L["Error deserializing"] = "Error de deserializacin"
L["Error Frame"] = "Marco de error"
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "ERROR en '%s' tipo de subelemento '%s' desconocido o incompatible"
L["Error in Aura '%s'"] = "Error en el aura '%s\""
L["Error not receiving display information from %s"] = "Error al no recibir informacin de visualizacin de %s"
L["Essence"] = "Esencia"
L["Essence #1"] = "Esencia #1"
L["Essence #2"] = "Esencia #2"
L["Essence #3"] = "Esencia #3"
L["Essence #4"] = "Esencia #4"
L["Essence #5"] = "Esencia #5"
L["Essence #6"] = "Esencia #6"
L["Evade"] = "Evadir"
L["Event"] = "Evento"
L["Event(s)"] = "Evento(s)"
L["Every Frame"] = "Cada Uno de los Marcos"
L["Every Frame (High CPU usage)"] = "Cada fotograma (uso elevado de CPU)"
L["Evoker Essence"] = "Esencia evocadora"
L["Exact Spell ID(s)"] = "ID de hechizo exacto"
L["Execute Conditions"] = "Ejecutar condiciones"
L["Experience (%)"] = "Experiencia (%)"
L["Expertise Bonus"] = "Bonus de pericia"
L["Expertise Rating"] = "ndice de pericia"
L["Extend Outside"] = "Extender afuera"
L["Extra Amount"] = "Cantidad Adicional"
L["Extra Attacks"] = "Ataques Adicional"
L["Extra Spell Id"] = "ID de hechizo extra"
L["Extra Spell Name"] = "Nombre del Hechizo Extra"
L["Faction"] = "Faccin"
L["Faction Name"] = "Nombre de faccin "
L["Faction Reputation"] = "Reputacin de faccin"
L["Fade Animation"] = "Animacin de fundido"
L["Fade In"] = "Aparecer"
L["Fade Out"] = "Desaparecer"
L["Fail Alert"] = "Alerta de Fallo"
L["False"] = "Falso"
L["Fankriss the Unyielding"] = "Fankriss el Implacable"
L["Feature %q is already disabled"] = "La caracterstica %q ya est desactivada."
L["Feature %q is already enabled"] = "La caracterstica %q ya est activada."
L["Fetch Absorb"] = "Obtener absorcin"
L["Fetch Heal Absorb"] = "Obtener absorcin de sanacin"
L["Fetch Legendary Power"] = "Obtener poder legendario"
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "Obtiene el nombre y el icono del Poder Legendario que coincide con este id de bonificacin."
L["Fill Area"] = "Rellenar rea"
L["Filter messages with format <message>"] = "Filtrar mensajes con formato <mensaje>"
L["Fire Resistance"] = "Resistencia al fuego"
L["Firemaw"] = "Faucefogo"
L["First"] = "Primero"
L["First Value of Tooltip Text"] = "Primer valor del texto del tooltip"
L["Fixed"] = "Fijo"
L["Fixed Names"] = "Nombres fijos"
L["Fixed Size"] = "Tamao fijo"
L["Flamegor"] = "Flamagor"
L["Flash"] = "Destello"
L["Flex Raid"] = "Banda Flexible"
L["Flip"] = "Voltear"
L["Floor"] = "Piso"
L["Focus"] = "Foco"
L["Follower Dungeon"] = "Mazmorra de seguidores"
L["Font"] = "Fuente"
L["Font Size"] = "Tamao de fuente"
L["Forbidden function or table: %s"] = "Funcin o tabla prohibida: %s"
L["Foreground"] = "Primer plano"
L["Foreground Color"] = "Color de primer plano"
L["Form"] = "Forma"
L["Format"] = "Formato"
L["Format Gold"] = "Formatar oro"
L["Formats |cFFFFCC00%unit|r"] = "Formatea |cFFFFCC00%unidad|r"
L["Formats Player's |cFFFFCC00%guid|r"] = "Formatea |cFFFFCC00%guid|r del jugador"
L["Forward"] = "Adelante"
L["Forward, Reverse Loop"] = "Adelante, bucle inverso"
L["Fourth Value of Tooltip Text"] = "Cuarto valor del texto de tooltip"
L["Frame Selector"] = "Selector de marco"
L["Frequency"] = "Frecuencia"
L["Friendly"] = "Amistoso"
L["Friendly Fire"] = "Fuego Amigo"
L["Friendship Max Rank"] = "Rango mx. de amistad"
L["Friendship Rank"] = "Rango de amistad"
L["Friendship Reputation"] = "Reputacin de amistad"
L["Frost"] = "Escarcha"
L["Frost Resistance"] = "Resistencia a la Escarcha"
L["Frost Rune #1"] = "Runa de escarcha #1"
L["Frost Rune #2"] = "Runa de escarcha #2"
L["Full"] = "Lleno"
L["Full Region"] = "Regin llena"
L["Full/Empty"] = "Lleno/vaco"
L["Gahz'ranka"] = "Gahz'ranka"
L["Gained"] = "Obtenido"
L["Garr"] = "Garr"
L["Gehennas"] = "Gehennas"
L["General"] = "General"
L["General Rajaxx"] = "General Rajaxx"
L["GetNameAndIcon Function (fallback state)"] = "Funcin GetNameAndIcon (estado de reserva)"
L["Glancing"] = "de refiln"
L["Global Cooldown"] = "Recarga Global"
L["Glow"] = "Resplandor"
L["Glow External Element"] = "Elemento externo del resplandor"
L["Gluth"] = "Gluth"
L["Glyph"] = "Glifo"
L["Gold"] = "Oro"
L["Golemagg the Incinerator"] = "Golemagg el Incinerador"
L["Gothik the Harvester"] = "Gothik el Cosechador"
L["Gradient"] = "Degradado"
L["Gradient Enabled"] = "Degradado activado"
L["Gradient End"] = "Fin del gradiente"
L["Gradient Orientation"] = "Orientacin del degradado"
L["Gradient Pulse"] = "Degradado Pulsante"
L["Grand Widow Faerlina"] = "Gran Viuda Faerlina"
L["Grid"] = "Rejilla"
L["Grobbulus"] = "Grobbulus"
L["Group"] = "Grupo"
L["Group Arrangement"] = "Disposicin de grupos"
L["Group Leader/Assist"] = "Lder/ayudante de grupo"
L["Group Size"] = "Tamao de grupo"
L["Group Type"] = "Tipo de grupo"
L["Grow"] = "Crecer"
L["GTFO Alert"] = "Alerta GTFO"
L["Guardian"] = "Guardin"
L["Guild"] = "Hermandad"
L["Hakkar"] = "Hakkar"
L["Hardcore"] = "Hardcore"
L["Has Target"] = "Tiene objetivo"
L["Has Vehicle UI"] = "Tiene IU de vehculo"
L["HasPet"] = "Mascota viva"
L["Haste (%)"] = "Celeridad (%)"
L["Haste Rating"] = "ndice de celeridad"
L["Heal"] = "Cura"
L["Heal Absorb"] = "Absorcin de sanacin"
L["Heal Absorbed"] = "Sanacin absorbida"
L["Health"] = "Salud"
L["Health (%)"] = "Vida (%)"
L["Health Deficit"] = "Dficit de sanacin"
L["Heigan the Unclean"] = "Heigan el Impuro"
L["Height"] = "Altura"
L["Hero Talent"] = "Talento de Hroe"
L["Heroic Party"] = "Grupo heroico"
L["Hide"] = "Ocultar"
L["Hide 0 cooldowns"] = "Ocultar 0 reutilizaciones"
L["Hide Timer Text"] = "Ocultar texto del temporizador"
L["High Damage"] = "Alto Dao"
L["High Priest Thekal"] = "Sumo Sacerdote Thekal"
L["High Priest Venoxis"] = "Sumo Sacerdote Thekal"
L["High Priestess Arlokk"] = "Suma Sacerdotisa Arlokk"
L["High Priestess Jeklik"] = "Suma Sacerdotisa Jeklik"
L["High Priestess Mar'li"] = "Suma Sacerdotisa Mar'li"
L["Higher Than Tank"] = "Mayor Que el Tanque"
L["Highest Spell Id"] = "ID de hechizo ms alto"
L["Hit (%)"] = "Golpear (%)"
L["Hit Rating"] = "ndice de golpear"
L["Holy Resistance"] = "Resistencia sagrada"
L["Horde"] = "Horda"
L["Horizontal"] = "Horizontal"
L["Hostile"] = "Hostil"
L["Hostility"] = "Holstilidad"
L["Humanoid"] = "Humanoide"
L["Hybrid"] = "Hbrido"
L["Icon"] = "Icono"
L["Icon Function"] = "Funcin de icono"
L["Icon Function (fallback state)"] = "Funcin de icono (estado de reserva)"
L["Id"] = "ID"
L["ID"] = "ID"
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "Si necesitas ms ayuda, abre un ticket en GitHub o visita nuestro Discord en https://discord.gg/weakauras."
L["Ignore Dead"] = "Ignorar muertos"
L["Ignore Disconnected"] = "Ignorar desconectados"
L["Ignore Rune CD"] = "Ignorar Recarga de Runas"
L["Ignore Rune CDs"] = "Ignorar reutilizacin de runa"
L["Ignore Self"] = "Ignorarse a s mismo"
L["Ignore Spell Cooldown/Charges"] = "Ignorar tiempo de reutilizacin/cargas de hechizos"
L["Ignore Spell Override"] = "Ignorar sobrescritura de hechizo"
L["Immune"] = "Inmune"
L["Important"] = "Importante"
L["Importing will start after combat ends."] = "La importacin comenzar una vez finalizado el combate."
L["In Combat"] = "En combate"
L["In Encounter"] = "En encuentro"
L["In Group"] = "En grupo"
L["In Party"] = "En grupo"
L["In Pet Battle"] = "En duelo de mascotas"
L["In Raid"] = "En banda"
L["In Range"] = "En el rango"
L["In Vehicle"] = "Conduciendo"
L["In War Mode"] = "En modo guerra"
L["Include Bank"] = "Incluye el Banco"
L["Include Charges"] = "Incluye las Cargas"
L["Include Death Runes"] = "Incluir runas de muerte"
L["Include Pets"] = "Incluir mascotas"
L["Include War Band Bank"] = "Incluir banco de bandas guerreras"
L["Incoming Heal"] = "Sanacin entrante"
L["Increase Precision Below"] = "Aumentar la precisin por debajo de"
L["Increases by one per stage or intermission."] = "Aumenta en uno por etapa o intervalo."
L["Information"] = "Informacin"
L["Inherited"] = "Heredado"
L["Instakill"] = "Muerte Instantanea"
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "Instala los addons BugSack y BugGrabber para obtener registros de errores detallados."
L["Instance"] = "Instancia"
L["Instance Difficulty"] = "Dificultad de la instancia"
L["Instance Id"] = "ID de estancia"
L["Instance ID"] = "ID de estancia"
L["Instance Info"] = "Info de estancia"
L["Instance Name"] = "Nombre de estancia"
L["Instance Size Type"] = "Tipo de tamao de estancia"
L["Instance Type"] = "Tipo de Instancia"
L["Instructor Razuvious"] = "Instructor Razuvious"
L["Insufficient Resources"] = "Recursos insuficientes"
L["Intellect"] = "Intelecto"
L["Interrupt"] = "Interrupcin"
L["Interrupt School"] = "Interrumpir escuela"
L["Interrupted School Text"] = "Texto de escuela interrumpido"
L["Interruptible"] = "Interrumpible"
L["Inverse"] = "Inverso"
L["Inverse Pet Behavior"] = "Invertir comportamiento de mascota"
L["Is Away from Keyboard"] = "No est delante del ordenador"
L["Is Current Specialization"] = "Es la especializacin actual"
L["Is Death Rune"] = "Es una Runa de muerte"
L["Is Exactly"] = "Es Exactamente"
L["Is Moving"] = "se est moviendo"
L["Is Off Hand"] = "Es mano izquierda"
L["Is Paragon Reputation"] = "Es reputacin de Dechado"
L["Is Paused"] = "Est en pausa"
L["is useable"] = "es utilizable"
L["Is Weekly Renown Capped"] = "Est limitado el renombre semanal"
L["Island Expedition (Heroic)"] = "Expedicin insular (Heroico)"
L["Island Expedition (Mythic)"] = "Expedicin insular (Mtico)"
L["Island Expedition (Normal)"] = "Expedicin insular (Normal)"
L["Island Expeditions (PvP)"] = "Expedicin insular (JcJ)"
L["Item"] = "Objeto"
L["Item Bonus Id"] = "ID de bonus de objeto"
L["Item Bonus Id Equipped"] = "ID de bonus de objeto equipado"
L["Item Count"] = "Contar los Objetos"
L["Item Equipped"] = "Objeto equipado"
L["Item Id"] = "ID de objeto"
L["Item in Range"] = "Objeto en rango"
L["Item Name"] = "Nombre de objeto"
L["Item Set Equipped"] = "Conjunto de objeto equipado"
L["Item Set Id"] = "ID de conjunto de objetos"
L["Item Slot"] = "Ranura de objeto"
L["Item Slot String"] = "Cadena de ranura de objeto"
L["Item Type"] = "Tipo de objeto"
L["Item Type Equipped"] = "Tipo de objeto equipado"
L["ItemId"] = "ID de objeto"
L["Jin'do the Hexxer"] = "Jin'do el Aojador"
L["Journal Stage"] = "Etapa de diario"
L["Kazzak"] = "Kazzak"
L["Keep Inside"] = "Mantener en el interior"
L["Kel'Thuzad"] = "Kel'Thuzad"
L["Kurinnaxx"] = "Kurinnaxx"
L["Large"] = "Grande"
L["Latency"] = "Latencia"
L["Leader"] = "Lder"
L["Least remaining time"] = "Menos tiempo restante"
L["Leaving"] = "Saliendo"
L["Leech"] = "Parasitar"
L["Leech (%)"] = "Parasitar (%)"
L["Leech Rating"] = "ndice de parasitar"
L["Left"] = "Izquierda"
L["Left to Right"] = "De Izquierda a Derecha"
L["Left, then Centered Vertical"] = "Izquierda, luego centrado vertical"
L["Left, then Down"] = "Izquierda, luego abajo"
L["Left, then Up"] = "Izquierda, luego arriba"
L["Legacy Looking for Raid"] = "Buscar banda legado"
L["Legacy RGB Gradient"] = "Gradiente RGB legado"
L["Legacy RGB Gradient Pulse"] = "Pulsa de gradiente RGB legado"
L["Legion"] = "Legion"
L["Length"] = "Longitud"
L["Level"] = "Nivel"
L["LibSharedMedia"] = "LibSharedMedia"
L["Lillian Voss"] = "Lilian Voss"
L["Limited"] = "Limitado"
L["Linear Texture"] = "Textura lineal"
L["Lines & Particles"] = "Lneas y partculas"
L["Load Conditions"] = "Condiciones de carga"
L["Loatheb"] = "Loatheb"
L["Location"] = "Ubicacin"
L["Looking for Raid"] = "Buscador de banda"
L["Loop"] = "Bucle"
L["Loot"] = "Botn"
L["Loot Specialization"] = "Especializacin de botn"
L["Loot Specialization Id"] = "ID de especializacin de botn"
L["Loot Specialization Name"] = "Nombre de especializacin de botn"
L["Lorewalking"] = "Paseo por la historia"
L["Lost"] = "Perdido"
L["Low Damage"] = "Bajo Dao"
L["Lower Than Tank"] = "Menor Que el Tanque"
L["Lowest Spell Id"] = "ID de hechizo ms bajo"
L["Lua error"] = "Error de lua"
L["Lua error in Aura '%s': %s"] = "Error de Lua en el aura '%s': %s"
L["Lucifron"] = "Lucifron"
L["Maexxna"] = "Maexxna"
L["Magic"] = "Magia"
L["Magmadar"] = "Magmadar"
L["Main Character"] = "Personaje principal"
L["Main Stat"] = "Estadstica principal"
L["Majordomo Executus"] = "Mayordomo Executus"
L["Malformed WeakAuras link"] = "Enlace WeakAuras malformado"
L["Manual"] = "Manual"
L["Manual Icon"] = "Icono manual"
L["Manual Rotation"] = "Rotacin manual"
L["Marked First"] = "Marcado en primer lugar"
L["Marked Last"] = "Marcado en ltimo lugar"
L["Mason"] = "Mason"
L["Master"] = "Maestro"
L["Mastery (%)"] = "Maestra (%)"
L["Mastery Rating"] = "ndice de maestra"
L["Match Count"] = "Recuento de coincidencia"
L["Match Count per Unit"] = "Recuento de coincidencia por unidad"
L["Matches (Pattern)"] = "Corresponde (Patrn)"
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = "Coincide con el nmero de etapa del diario de encuentros. Los intermedios son .5 Por ej. 1;2;1;2;2.5;3"
L["Max Char "] = "Caracteres mx."
L["Max Char"] = "Carcter mximo"
L["Max Charges"] = "Cargas mx."
L["Max Health"] = "Salud mx."
L["Max Power"] = "Poder mx."
L["Max Quantity"] = "Cantidad mx."
L["Maximum Estimate"] = "Mximo estimado"
L["Maximum Progress"] = "Progreso mximo"
L["Maximum time used on a single frame"] = "Tiempo mximo utilizado en un solo fotograma"
L["Media"] = "Media"
L["Medium"] = "Medio"
L["Melee"] = "Cuerpo a cuerpo"
L["Melee Haste (%)"] = "Celeridad cuerpo a cuerpo (%)"
L["Message"] = "Mensaje"
L["Message Type"] = "Tipo de Mensaje"
L["Message type:"] = "Tipo de Mensaje:"
L["Meta Data"] = "Metadatos"
L["Mine"] = "Mo"
L["Minimum Estimate"] = "Mnimo estimado"
L["Minimum Progress"] = "Progreso mnimo"
L["Minus (Small Nameplate)"] = "Menos (placa de nombre pequeo)"
L["Mirror"] = "Reflejo"
L["Miscellaneous"] = "Miscelneos"
L["Miss"] = "Fallo"
L["Miss Type"] = "Tipo de Fallo"
L["Missed"] = "Fallado"
L["Missing"] = "Ausente"
L["Mists of Pandaria"] = "Mists of Pandaria"
L["Moam"] = "Moam"
L["Model"] = "Modelo"
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Blizzard moderno (1h 3m | 3m 7s | 10s | 2.4)"
L["Modernize"] = "Modernizar"
L["Molten Core"] = "Ncleo de Magma"
L["Money"] = "Dinero"
L["Monochrome"] = "Monocromo"
L["Monochrome Outline"] = "Contorno monocromo"
L["Monochrome Thick Outline"] = "Contorno grueso monocromo"
L["Monster Emote"] = "Emote de monstruo"
L["Monster Party"] = "Grupo de monstruo"
L["Monster Say"] = "Monstruo hablando"
L["Monster Whisper"] = "Susurro de monstruo"
L["Monster Yell"] = "Grito de Monstruo"
L["Moon"] = "Luna"
L["Most remaining time"] = "La mayor parte del tiempo restante"
L["Mounted"] = "Montado"
L["Mouse Cursor"] = "Cursor del ratn"
L["Movement Speed Rating"] = "ndice de velocidad de movimiento"
L["Multi-target"] = "Objetivo Mltiple"
L["Mythic Keystone"] = "Piedra angular mtica"
L["Mythic+ Affix"] = "Afijo de mtica+"
L["Name"] = "Nombre"
L["Name Function"] = "Funcin de nombre"
L["Name Function (fallback state)"] = "Funcin de nombre (estado de reserva)"
L["Name of Caster's Target"] = "Nombre del objetivo del lanzador"
L["Name of the (sub-)zone currently shown above the minimap."] = "Nombre de la (sub)zona que se muestra actualmente encima del minimapa."
L["Name(s)"] = "Nombre(s)"
L["Name/Realm of Caster's Target"] = "Nombre/Reino del objetivo del lanzador"
L["Nameplate"] = "Placa"
L["Nameplates"] = "Placas"
L["Names of affected Players"] = "Nombres de los jugadores afectados"
L["Names of unaffected Players"] = "Nombres de los jugadores no afectados"
L["Nature Resistance"] = "Resistencia a la naturaleza"
L["Naxxramas"] = "Naxxramas"
L["Nefarian"] = "Nefarian"
L["Neutral"] = "Neutral"
L["Never"] = "Nunca"
L["Next Combat"] = "Siguiente combate"
L["Next Encounter"] = "Siguiente encuentro"
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Ningn addon de mdulo de jefe activo. Nota: Este activador utilizar BigWigs o DBM, en ese orden si ambos estn instalados."
L["No Extend"] = "Sin extender"
L["No Instance"] = "Fuera de Instancia"
L["No Profiling information saved."] = "No hay informacin de perfil guardada."
L["No Progress Information available."] = "No hay informacin de progreso disponible."
L["None"] = "Nada"
L["Non-player Character"] = "Personaje No Jugador"
L["Normal"] = "Normal"
L["Normal Party"] = "Grupo normal"
L["Not in Group"] = "No en grupo"
L["Not in Smart Group"] = "No en grupo inteligente"
L["Not on Cooldown"] = "No en reutilizacin"
L["Not On Threat Table"] = "No Est En La Tabla De Amenaza"
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "Nota: debido a lo complicado que es el comportamiento del temporizador de swing y a la falta de APIs por parte de Blizzard, los resultados son imprecisos en casos extremos."
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "Nota: 'Ocultar solo' no est disponible en el nuevo sistema de seguimiento de aura. En su lugar, se puede utilizar una opcin de carga."
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "Nota: las sustituciones de texto disponibles para los multiactivadores coinciden ahora con las de los activadores normales."
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = "Nota: Este disparador almacena internamente la posicin de cambio de forma, por lo tanto es incompatible con aprender posturas sobre la marcha, como por ejemplo la Runa del Gladiador."
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "Nota: Este activador se basa en la API de WoW, que devuelve informacin incorrecta en algunos casos."
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "Nota: este tipo de activador estima el alcance a la hitbox de una unidad. El alcance real de los jugadores aliados suele ser 3 metros ms que la estimacin. Las capacidades de comprobacin del alcance dependen de tu clase actual y de tus habilidades conocidas, as como del tipo de unidad que se est comprobando. Algunos de los rangos pueden no funcionar con ciertos NPCs.|n|n|cFFAAFFAAUnidades amistosas:|r %s|n|cFFFFAAAAUnidades dainas:|r %s|n|cFFAAAAFFUnidades diversas:|r %s"
L["Noth the Plaguebringer"] = "Noth el Pesteador"
L["NPC"] = "PNJ"
L["Npc ID"] = "ID de pnj"
L["Number"] = "Nmero"
L["Number Affected"] = "Dependiente de nmeros"
L["Object"] = "Objeto"
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3. Funciona solo si el addon mdulo de jefe muestra el contador."
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3 Solo si BigWigs lo muestra en su barra"
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3 Solo si DBM lo muestra en su barra"
L["Officer"] = "Oficial"
L["Offset from progress"] = "Desplazamiento de progreso"
L["Offset Timer"] = "Temporizador de desplazamiento"
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Antiguo de Blizzard (2h | 3m | 10s | 2.4)"
L["On Cooldown"] = "En reutilizacin"
L["On Taxi"] = "En taxi"
L["Only if on a different realm"] = "Solo si est en otro reino"
L["Only if Primary"] = "Solo si es primario"
L["Onyxia"] = "Onyxia"
L["Opaque"] = "Opaco"
L["Option Group"] = "Grupo de opcin"
L["Options could not be loaded, the addon is %s"] = "No se han podido cargar las opciones, el addon es %s"
L["Options will finish loading after combat ends."] = "Las opciones terminarn de cargarse una vez finalizado el combate."
L["Options will open after the login process has completed."] = "Las opciones se abrirn una vez finalizado el proceso de inicio de sesin."
L["Or Talent"] = "o talento"
L["Orbit"] = "Orbitar"
L["Orientation"] = "Orientacin"
L["Ossirian the Unscarred"] = "Osirio el Sinmarcas"
L["Other"] = "Otros"
L["Other Addons"] = "Otros addons"
L["Other Events"] = "Otros eventos"
L["Ouro"] = "Ouro"
L["Outline"] = "Contorno"
L["Over Energize"] = "Sobreenergizar"
L["Overhealing"] = "Sobre Curacin"
L["Overkill"] = "Muerte de Ms"
L["Overlay %s"] = "Superposicin %s"
L["Overlay Charged Combo Points"] = "Puntos de combo cargados de la superposicin"
L["Overlay Cost of Casts"] = "Superposicin del costo de lanzamiento"
L["Overlay Latency"] = "Latencia de superposicin"
L["Pad"] = "Relleno"
L["Pad Mode"] = "Modo de relleno"
L["Pad to"] = "Rellenar a"
L["Paragon Reputation"] = "Reputacin de dechado"
L["Paragon Reward Pending"] = "Recompensa de Dechado pendiente"
L["Parent Frame"] = "Marco de padre"
L["Parent Zone"] = "Zona de padre"
L["Parry"] = "Parar"
L["Parry (%)"] = "Parar (%)"
L["Parry Rating"] = "ndice de parar"
L["Party"] = "Grupo"
L["Party Kill"] = "Muerte de Grupo"
L["Patchwerk"] = "Remendejo"
L["Path of Ascension: Courage"] = "Camino de la ascensin: coraje"
L["Path of Ascension: Humility"] = "Camino de la ascensin: humilde"
L["Path of Ascension: Loyalty"] = "Camino de la ascensin: lealtad"
L["Path of Ascension: Wisdom"] = "Camino de la ascensin: sabidura"
L["Paused"] = "Pausado"
L["Periodic Spell"] = "Hechizo Peridico"
L["Personal Resource Display"] = "Visualizacin de recursos personales"
L["Pet"] = "Mascota"
L["Pet Behavior"] = "Comportamiento de mascota"
L["Pet Specialization"] = "Especializacin de mascota"
L["Pet Spell"] = "Habilidad de mascota"
L["Pets only"] = "Solamente mascotas"
L["Phase"] = "Fase"
L["Pixel Glow"] = "Resplandor de pxel"
L["Placement"] = "Ubicacin"
L["Placement %i"] = "Colocacin %i"
L["Placement Mode"] = "Modo de ubicacin"
L["Play"] = "Reproducir"
L["Player"] = "Jugador"
L["Player Character"] = "Personaje Jugador"
L["Player Class"] = "Clase del jugador"
L["Player Effective Level"] = "Nivel efectivo del jugador"
L["Player Experience"] = "Experiencia del jugador"
L["Player Faction"] = "Faccin del jugador"
L["Player Level"] = "Nivel del jugador"
L["Player Location ID(s)"] = "ID de ubicacin del jugador"
L["Player Money"] = "Dinero del jugador"
L["Player Name/Realm"] = "Nombre/reino del jugador"
L["Player Race"] = "Raza del jugador"
L["Player(s) Affected"] = "Jugador(es) Afectados"
L["Player(s) Not Affected"] = "Jugador(es) no Afectados"
L["Player/Unit Info"] = "Informacin del jugador/unidad"
L["Players and Pets"] = "Jugadores y mascotas"
L["Poison"] = "Veneno"
L["Power"] = "Poder"
L["Power (%)"] = "Poder  (%)"
L["Power Deficit"] = "Dficit de poder"
L["Power Type"] = "Tipo de Poder"
L["Precision"] = "Precisin"
L["Preset"] = "Preestablecido"
L["Primary Stats"] = "Estadsticas primarias"
L["Princess Huhuran"] = "Princesa Huhuran"
L["Print Profiling Results"] = "Imprimir resultados del perfilado"
L["Proc Glow"] = "Resplandor de prec"
L["Profiling already started."] = "Perfilado ya se inici."
L["Profiling automatically started."] = "Perfilado se inici automticamente"
L["Profiling not running."] = "Perfilado no ejecutndose"
L["Profiling started."] = "Perfilado iniciado."
L["Profiling started. It will end automatically in %d seconds"] = "Se inici el perfilado. Terminar automticamente en %d segundos"
L["Profiling still running, stop before trying to print."] = "Perfilado an ejecutndose, detenerse antes de intentar imprimir"
L["Profiling stopped."] = "Se detuvo el perfilado."
L["Progress"] = "Progreso"
L["Progress Source"] = "Fuente de progreso"
L["Progress Total"] = "Progreso total"
L["Progress Value"] = "Valor de progreso"
L["Pull"] = "Iniciar"
L["Pulse"] = "Pulso"
L["PvP Flagged"] = "Marcado JcJ"
L["PvP Talent selected"] = "Talento de JcJ seleccionado"
L["PvP Talent Selected"] = "Talento de JcJ seleccionado"
L["Quality Id"] = "ID de calidad"
L["Quantity"] = "Cantidad"
L["Quantity earned this week"] = "Cantidad ganada esta semana"
L["Quest Party"] = "Grupo de misin"
L["Queued Action"] = "Accin en cola"
L["Radius"] = "Radio"
L["Ragnaros"] = "Ragnaros"
L["Raid"] = "Banda"
L["Raid (Heroic)"] = "Banda (heroico)"
L["Raid (Mythic)"] = "Banda (mtico)"
L["Raid (Normal)"] = "Banda (normal)"
L["Raid (Timewalking)"] = "Banda (paseo temporal)"
L["Raid Mark"] = "Marca de banda"
L["Raid Mark Icon"] = "Icono de marca de banda"
L["Raid Role"] = "Rol de banda"
L["Raid Warning"] = "Alerta de Banda"
L["Raids"] = "Bandas"
L["Range"] = "Rango"
L["Range Check"] = "Comprobacin de distancia"
L["Ranged"] = "A distancia"
L["Rank"] = "Rango"
L["Rare"] = "Raro"
L["Rare Elite"] = "Raro lite"
L["Rated Arena"] = "Arena puntuada"
L["Rated Battleground"] = "Campo de batalla puntuado"
L["Raw Threat Percent"] = "Porcentaje de amenaza en bruto"
L["Razorgore the Untamed"] = "Sangrevaja el Indomable"
L["Ready Check"] = "Comprobacin de preparados"
L["Reagent Quality"] = "Calidad de componente"
L["Reagent Quality Texture"] = "Textura de calidad de componente"
L["Realm"] = "Reino"
L["Realm Name"] = "Nombre de reino"
L["Realm of Caster's Target"] = "Reino del objetivo del lanzador"
L["Reborn Council"] = "Consejo renacido"
L["Receiving %s Bytes"] = "Recibiendo %s bytes"
L["Receiving display information"] = "Recibiendo informacin de aura de %s..."
L["Reflect"] = "Reflejar"
L["Region type %s not supported"] = "No se admite el tipo de regin %s"
L["Relative"] = "Relativo"
L["Relative X-Offset"] = "Desplazamiento X relativo"
L["Relative Y-Offset"] = "Desplazamiento Y relativo"
L["Remaining Duration"] = "Duracin restante"
L["Remaining Time"] = "Tiempo Restante"
L["Remove Obsolete Auras"] = "Eliminar auras obsoletas"
L["Renown Level"] = "Nivel de renombre"
L["Renown Max Level"] = "Nivel mximo de renombre"
L["Renown Reputation"] = "Reputacin de renombre"
L["Repair"] = "Reparar"
L["Repeat"] = "Repetir"
L["Report Summary"] = "Resumen del informe"
L["Reputation"] = "Reputacin"
L["Reputation (%)"] = "Reputacin (%)"
L["Requested display does not exist"] = "El aura requerida no existe"
L["Requested display not authorized"] = "El aura requerida no est autorizada"
L["Requesting display information from %s ..."] = "Solicitando informacin de visualizacin de %s..."
L["Require Valid Target"] = "Requiere Objetivo Vlido"
L["Requires syncing the specialization via LibSpecialization."] = "Requiere sincronizar la especializacin mediante LibSpecialization."
L["Resilience (%)"] = "Temple (%)"
L["Resilience Rating"] = "ndice de temple"
L["Resist"] = "Resistir"
L["Resistances"] = "Resistencias"
L["Resisted"] = "Resistido"
L["Rested"] = "Descansado"
L["Rested Experience"] = "Experiencia descansada"
L["Rested Experience (%)"] = "Experiencia descansada (%)"
L["Resting"] = "Descansado"
L["Resurrect"] = "Resucitar"
L["Resurrect Pending"] = "Resurreccin pendiente"
L["Right"] = "Derecha"
L["Right to Left"] = "De Derecha a Izquierda"
L["Right, then Centered Vertical"] = "Derecha, luego centrado vertical"
L["Right, then Down"] = "Derecha, luego abajo"
L["Right, then Up"] = "Derecha, luego arriba"
L["Role"] = "Rol"
L["Rollback snapshot is complete. Thank you for your patience!"] = "La instantnea de reversin est completa. Gracias por tu paciencia!"
L["Rotate Animation"] = "Rotar animacin"
L["Rotate Left"] = "Rotar a la Izquierda"
L["Rotate Right"] = "Rotar a la Derecha"
L["Rotation"] = "Rotacin"
L["Round"] = "Redondo"
L["Round Mode"] = "Modo redondo"
L["Ruins of Ahn'Qiraj"] = "Ruinas de Ahn'Qiraj"
L["Run Custom Code"] = "Ejecutar cdigo personalizado"
L["Run Speed (%)"] = "Velocidad de movimiento (%)"
L["Rune"] = "Runa"
L["Rune #1"] = "Runa #1"
L["Rune #2"] = "Runa #2"
L["Rune #3"] = "Runa #3"
L["Rune #4"] = "Runa #4"
L["Rune #5"] = "Runa #5"
L["Rune #6"] = "Runa #6"
L["Rune Count"] = "Contador de runas"
L["Rune Count - Blood"] = "Recuento de Runa sangrienta"
L["Rune Count - Frost"] = "Recuento de Runa de Escarcha"
L["Rune Count - Unholy"] = "Recuento de Runa profana"
L["Sapphiron"] = "Sapphiron"
L["Say"] = "Decir"
L["Scale"] = "Escala"
L["Scarlet Enclave"] = "Enclave Escarlata"
L["Scenario"] = "Escenario"
L["Scenario (Heroic)"] = "Escenario (heroico)"
L["Scenario (Normal)"] = "Escenario (normal)"
L["Screen"] = "Pantalla"
L["Screen/Parent Group"] = "Grupo de pantalla/padre"
L["Season of Discovery"] = "Temporada de descubrimiento"
L["Second"] = "Segundo"
L["Second Value of Tooltip Text"] = "Segundo valor del texto del tooltip"
L["Secondary Stats"] = "Estadsticas secundarias"
L["Seconds"] = "Segundos"
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "Marco seguro detectado. Encuentra ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Select Frame"] = "Seleccionar marco"
L["Select the type of timer to filter"] = "Selecciona el tipo de temporizador para filtrar"
L["Selection Mode"] = "Modo de seleccin"
L["Separator"] = "Separador"
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "Los IDs de conjuntos se pueden encontrar en sitios web como wowhead.com/cata/es/item-sets"
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Los IDs de conjuntos se pueden encontrar en sitios web como wowhead.com/classic/es/item-sets"
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "Los ID de conjuntos se pueden encontrar en sitios web como wowhead.com/es/item-sets"
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Los IDs de conjuntos se pueden encontrar en sitios web como wowhead.com/mop-classic/es/item-sets"
L["Shadow Resistance"] = "Resistencia a las Sombras"
L["Shadowlands"] = "Shadowlands"
L["Shake"] = "Sacudida"
L["Shazzrah"] = "Shazzrah"
L["Shift-Click to resume addon execution."] = "Mays clic para reanudar la ejecucin del addon."
L["Show"] = "Mostrar"
L["Show CD of Charge"] = "Mostrar reutilizacin de carga"
L["Show charged duration for empowered casts"] = "Mostrar duracin cargada para lanzamientos empoderados"
L["Show GCD"] = "Mostrar reutilizacin global"
L["Show Global Cooldown"] = "Mostrar reutilizacin global"
L["Show Incoming Heal"] = "Mostrar sanacin entrante"
L["Show Loss of Control"] = "Mostrar prdida de control"
L["Show On"] = "Mostrar en"
L["Show Rested Overlay"] = "Mostrar superposicin descansada"
L["Shrink"] = "Encoger"
L["Silithid Royalty"] = "Realeza siltida"
L["Silver"] = "Plata"
L["Simple"] = "Simple"
L["Since Active"] = "Desde activo"
L["Since Apply"] = "Desde aplicar"
L["Since Apply/Refresh"] = "Desde aplicar/actualizar"
L["Since Charge Gain"] = "Desde ganancia de carga"
L["Since Charge Lost"] = "Desde que se perdi la carga"
L["Since Ready"] = "Desde listo"
L["Since Stack Gain"] = "Desde ganancia de acumulacin"
L["Since Stack Lost"] = "Desde que se perdi la acumulacin"
L["Size & Position"] = "Tamao y posicin"
L["Skyriding"] = "Vuelo surcacielos"
L["Slide Animation"] = "Animacin deslizante"
L["Slide from Bottom"] = "Arrastrar Desde Abajo"
L["Slide from Left"] = "Arrastrar Desde la Izquierda"
L["Slide from Right"] = "Arrastrar Desde la Derecha"
L["Slide from Top"] = "Arrastrar Desde Arriba"
L["Slide to Bottom"] = "Arrastrar Hacia Abajo"
L["Slide to Left"] = "Arrastrar Hacia la Izquierda"
L["Slide to Right"] = "Arrastrar Hacia la Derecha"
L["Slide to Top"] = "Arrastrar Hacia Arriba"
L["Slider"] = "Control deslizante"
L["Small"] = "Pequeo"
L["Smart Group"] = "Grupo inteligente"
L["Soft Enemy"] = "Enemigo flexible"
L["Soft Friend"] = "Amigo flexible"
L["Solistrasza"] = "Solistrasza"
L["Sound"] = "Sonido"
L["Sound by Kit ID"] = "Sonido por ID de kit"
L["Source"] = "Fuente"
L["Source Affiliation"] = "Afiliacin de fuente"
L["Source GUID"] = "GUID de la fuente"
L["Source Info"] = "Info de la fuente"
L["Source Name"] = "Nombre de Origen"
L["Source NPC Id"] = "ID de PNJ de la fuente"
L["Source Object Type"] = "Tipo de objeto de la fuente"
L["Source Raid Mark"] = "Marca de banda de la fuente"
L["Source Reaction"] = "Reaccin de la fuente"
L["Source Unit"] = "Unidad Origen"
L["Source Unit Name/Realm"] = "Nombre/reino de unidad de la fuente"
L["Source unit's raid mark index"] = "ndice de marca de banda de unidad de la fuente"
L["Source unit's raid mark texture"] = "Textura de marca de banda de unidad de la fuente"
L["Space"] = "Espacio"
L["Spacing"] = "Espaciado"
L["Spark"] = "Chispa"
L["Spec Position"] = "Posicin de especializacin"
L["Spec Role"] = "Rol de especializacin"
L["Specialization"] = "Especializacin"
L["Specific Currency"] = "Moneda especfica"
L["Specific Type"] = "Tipo especfico"
L["Specific Unit"] = "Unidad Especfica"
L["Spell"] = "Hechizo"
L["Spell (Building)"] = "Hechizo (en curso)"
L["Spell Activation Overlay Glow"] = "Resplandor de superposicin de activacin de hechizos"
L["Spell Cast Succeeded"] = "Lanzamiento del hechizo exitoso"
L["Spell Cost"] = "Costo de hechizo"
L["Spell Count"] = "Contador de hechizo"
L["Spell ID"] = "ID de hechizo"
L["Spell Id"] = "ID de hechizo"
L["Spell ID:"] = "ID de hechizo:"
L["Spell IDs:"] = "IDs de hechizo:"
L["Spell in Range"] = "Hechizo en rango"
L["Spell Known"] = "Hechizo conocido"
L["Spell Name"] = "Nombre del Hechizo"
L["Spell Peneration Percent"] = "Porcentaje de penetracin de hechizo"
L["Spell Power"] = "Poder con hechizos"
L["Spell School"] = "Escuela de hechizo"
L["Spell Usable"] = "Hechizo utilizable"
L["Spellname"] = "Nombre de hechizo"
L["Spike"] = "Pico"
L["Spin"] = "Girar"
L["Spiral"] = "Espiral"
L["Spiral In And Out"] = "Espiral de Dentro a Fuera"
L["Spirit"] = "Espritu"
L["Stack Count"] = "Recuento de acumulaciones"
L["Stack trace:"] = "Traza de pila:"
L["Stacks"] = "Acumulaciones"
L["Stacks Function"] = "Funcin de acumulaciones"
L["Stacks Function (fallback state)"] = "Funcin de acumulaciones (estado reserva)"
L["Stage"] = "Etapa"
L["Stage Counter"] = "Contador de etapa"
L["Stagger"] = "Escalonar"
L["Stagger (%)"] = "Tambalear (%)"
L["Stagger against Target (%)"] = "Tambalearse contra el objetivo (%)"
L["Stagger Scale"] = "Escala escalonada"
L["Stamina"] = "Aguante"
L["Stance/Form/Aura"] = "Impostura/Forma/Aura"
L["Standing"] = "De pie"
L["Star Shake"] = "Sacudida de estrellas"
L["Start Animation"] = "Iniciar animacin"
L["Start Now"] = "Iniciar ahora"
L["Start Profiling"] = "Iniciar el perfilado"
L["Status"] = "Estado"
L["Status Bar"] = "Barra de estado"
L["Stolen"] = "Robado"
L["Stop"] = "Detener"
L["Stop Motion"] = "Stop motion"
L["Story Raid"] = "Banda de historia"
L["Strength"] = "Fuerza"
L["String"] = "Cadena"
L["Subevent Info"] = "Info de subevento"
L["Subtract Cast"] = "Sustraer lanzamiento"
L["Subtract Channel"] = "Sustraer canal"
L["Subtract GCD"] = "Sustraer reutilizacin global"
L["Subzone Name"] = "Nombre de subzona"
L["Success"] = "xito"
L["Sulfuron Harbinger"] = "Sulfuron Presagista"
L["Summon"] = "Invocar"
L["Summon Pending"] = "Invocacin pendiente"
L["Sun"] = "Sol"
L["Supports multiple entries, separated by commas"] = "Admite mltiples entradas, separadas por comas"
L[ [=[Supports multiple entries, separated by commas
]=] ] = "Supports multiple entries, separated by commas"
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "Admite varias entradas, separadas por comas. Escapar  la ',' con \\. Prefijo con '-' para negacin."
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Admite mltiples entradas, separadas por comas. Escapa con . Prefjalas con '-' para negacin."
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "Admite varias entradas, separadas por comas. Utilice el prefijo '-' para la negacin."
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = "Admite varias entradas, separadas por comas. Para incluir identificadores de zonas secundarias, utilice el prefijo c, por ejemplo c2022. Los ID de zona de grupo deben ir precedidos de g, por ejemplo g277. Admite ID de zona de https://wago.tools/db2/AreaTable prefijados con 'a'. Admite ID de estancia con el prefijo i. Las entradas pueden llevar el prefijo - para negarlas."
L["Swing"] = "Golpe"
L["Swing Timer"] = "Temporizador de Golpes"
L["Swipe"] = "Berrido"
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = "Sintaxis /wa caracterstica <alternar|activado|activar|desactivar|desactivado> <caracterstica>"
L["System"] = "Sistema"
L["Systems"] = "Sistemas"
L["Tab "] = "Pestaa"
L["Talent"] = "Talento"
L["Talent |cFFFF0000Not|r Known"] = "Talento |cFFFF0000desconocido|r"
L["Talent |cFFFF0000Not|r Selected"] = "Talento |cFFFF0000no|r seleccionado"
L["Talent Known"] = "Talento conocido"
L["Talent Selected"] = "Talento seleccionado"
L["Talent selected"] = "Talento seleccionado"
L["Talent Specialization"] = "Especializacin de Talentos"
L["Tanking And Highest"] = "Tanqueando y el ms alto"
L["Tanking But Not Highest"] = "Tanqueando pero no el mas alto"
L["Target"] = "Objetivo"
L["Targeted"] = "Objetivo"
L["Tertiary Stats"] = "Estadsticas terciarias"
L["Test if bar is enabled in BigWigs settings"] = "Prueba si la barra est activada en la configuracin de BigWigs"
L["Test if bar is enabled in Boss Mod addon settings"] = "Prueba si la barra est activada en la configuracin del addon del mdulo de jefe"
L["Test if bar is enabled in DBM settings"] = "Prueba si la barra est activada en la configuracin de DBM"
L["Text"] = "Texto"
L["Text To Speech"] = "Texto a voz"
L["Text-to-speech"] = "Texto a voz"
L["Texture"] = "Textura"
L["Texture Function"] = "Funcin de textura"
L["Texture Function (fallback state)"] = "Funcin de textura (estado de reserva)"
L["Texture Picker"] = "Selector de texturas"
L["Texture Rotation"] = "Rotacin de textura"
L["Thaddius"] = "Thaddius"
L["The aura has overwritten the global '%s', this might affect other auras."] = "La aura ha sobrescrito el '%s' global, esto podra afectar otras auras."
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "El aura intent sobrescribir la variable global aura_env, lo cual no est permitido"
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "El nivel efectivo difiere del nivel p.ej. mazmorras de paseo en el tiempo"
L["The Four Horsemen"] = "Los cuatro jinetes"
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "El valor 'ID' se puede encontrar en las opciones de BigWigs de un hechizo especfico."
L["The Prophet Skeram"] = "El profeta Skeram"
L["The total quantity a warband character can transfer after paying the transfer cost"] = "La cantidad total que un personaje de una banda guerrera puede transferir despus de pagar el costo de transferencia."
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "La cantidad total despus de transferir todo a tu personaje actual y pagar el costo de transferencia."
L["The War Within"] = "The War Within"
L["There are %i updates to your auras ready to be installed!"] = "Hay %i actualizaciones para tus auras listas para ser instaladas!"
L["Thick Outline"] = "Contorno grueso"
L["Thickness"] = "Espesor"
L["Third"] = "Tercero"
L["Third Value of Tooltip Text"] = "Tercero valor del texto del tooltip"
L["This aura calls GetData a lot, which is a slow function."] = "Esta aura llama mucho a GetData, que es una funcin lenta."
L["This aura has caused a Lua error."] = "Esta aura ha provocado un error de Lua."
L["This aura is saving %s KB of data"] = "Esta aura est guardando %s KB de datos."
L["This aura plays a sound via a condition."] = "Este aura reproduce un sonido a travs de una condicin."
L["This aura plays a sound via an action."] = "Este aura reproduce un sonido a travs de una accin."
L["This aura plays a Text To Speech via a condition."] = "Esta aura reproduce un texto a voz a travs de una condicin."
L["This aura plays a Text To Speech via an action."] = "Esta aura reproduce un texto a voz a travs de una accin."
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "Este filtro ha sido trasladado al disparador de ubicacin. Cambia tu aura para utilizar el nuevo disparador de ubicacin o nete al servidor de Discord de WeakAuras para obtener ayuda."
L["Threat Percent"] = "Porcentaje de amenaza"
L["Threat Situation"] = "Situacin de la Amenaza"
L["Threat Value"] = "Valor de amenaza"
L["Tick"] = "Tic"
L["Time"] = "Tiempo"
L["Time Format"] = "Formato de tiempo"
L["Time in GCDs"] = "Tiempo de reutilizacin global"
L["Time since initial application"] = "Tiempo desde la aplicacin inicial"
L["Time since last refresh"] = "Tiempo desde la ltima actualizacin"
L["Time since stack gain"] = "Tiempo desde gana de acumulacin"
L["Time since stack lost"] = "Tiempo desde que se perdi la acumulacin"
L["Timed"] = "Temporizado"
L["Timed Progress"] = "Progreso temporizado"
L["Timer"] = "Temporizador"
L["Timer Id"] = "ID de temporizador"
L["Toggle"] = "Mostrar"
L["Toggle List"] = "Mostar lista"
L["Toggle Options Window"] = "Mostrar ventana de opciones"
L["Toggle Performance Profiling Window"] = "Mostrar la ventana de perfiles de rendimiento"
L["Tooltip"] = "Descripcin emergente"
L["Tooltip 1"] = "Tooltip 1"
L["Tooltip 2"] = "Tooltip 2"
L["Tooltip 3"] = "Tooltip 3"
L["Tooltip Value 1"] = "Valor de tooltip 1"
L["Tooltip Value 2"] = "Valor de tooltip 2"
L["Tooltip Value 3"] = "Valor de tooltip 3"
L["Tooltip Value 4"] = "Valor de tooltip 4"
L["Top"] = "Superior"
L["Top Left"] = "Superior izquierda"
L["Top Right"] = "Superior derecha"
L["Top to Bottom"] = "De Arriba a Abajo"
L["Torghast"] = "Torghast"
L["Total Duration"] = "Duracin total"
L["Total Earned in this Season"] = "Total ganado en esta temporada"
L["Total Essence"] = "Esencia total"
L["Total Experience"] = "Experiencia total"
L["Total Match Count"] = "Recuento de coincidencia en total"
L["Total Reputation"] = "Reputacin total"
L["Total Stacks"] = "Acumulaciones totales"
L["Total stacks over all matches"] = "Acumulaciones totales sobre todas las coincidencias"
L["Total Stages"] = "Etapas totales"
L["Total Unit Count"] = "Recuento de unidad total"
L["Total Units"] = "Unidades totales"
L["Totem"] = "Ttem"
L["Totem #%i"] = "Ttem #%i"
L["Totem Icon"] = "Icono de Ttem"
L["Totem Name"] = "Nombre del Ttem"
L["Totem Name Pattern Match"] = "Coincidencia de patrn de nombre de ttem"
L["Totem Number"] = "Nmero de ttem"
L["Track Cooldowns"] = "Rastrear reutilizaciones"
L["Tracking Charge %i"] = "Carga de seguimiento %i"
L["Tracking Charge CDs"] = "Seguimiento de reutilizacin de carga"
L["Tracking Only Cooldown"] = "Seguimiento de sola reutilizacin"
L["Transmission error"] = "Error de transmisin"
L["Trigger"] = "Activador"
L["Trigger %i"] = "Activador %i"
L["Trigger %s"] = "Activador %s"
L["Trigger 1"] = "Activador 1"
L["Trigger State Updater (Advanced)"] = "Actualizacin del estado del activador (avanzada)"
L["Trigger Update"] = "Actualizacin del activador"
L["Trigger:"] = "Activador:"
L["Trivial (Low Level)"] = "Trivial (nivel bajo)"
L["True"] = "Verdadero"
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "Intentando reparar condiciones rotas en %s probablemente causadas por un error de WeakAuras."
L["Twin Emperors"] = "Emperadores gemelos"
L["Type"] = "Tipo"
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "No se puede modernizar el aura '%s'. Probablemente se deba a datos corruptos o una migracin incorrecta. Por favor, informe de esto al equipo de WeakAuras."
L["Unaffected"] = "Inafectado"
L["Undefined"] = "No Definido"
L["Unholy"] = "Profano"
L["Unholy Rune #1"] = "Runa profana #1"
L["Unholy Rune #2"] = "Runa profana #2"
L["Unit"] = "Unidad"
L["Unit Characteristics"] = "Caractersticas de la unidad"
L["Unit Destroyed"] = "Unidad Destruida"
L["Unit Died"] = "Unit Muerta"
L["Unit Dissipates"] = "Disipaciones de unidad"
L["Unit Frame"] = "Marco de unidad"
L["Unit Frames"] = "Marcos de unidad"
L["Unit is Unit"] = "Unidad es unidad"
L["Unit Name"] = "Nombre de unidad"
L["Unit Name/Realm"] = "Nombre/reino de unidad"
L["Units Affected"] = "Unidades afectadas"
L["Units of affected Players in a table format"] = "Unidades de jugadores afectados en formato de tabla"
L["Units of unaffected Players in a table format"] = "Unidades de jugadores no afectados en formato de tabla."
L["Unknown action %q"] = "Accin desconocida %q"
L["Unknown feature %q"] = "Caracterstica desconocida %q"
L["unknown location"] = "zona desconocida"
L["Unlimited"] = "Ilimitado"
L["Untrigger %s"] = "Desactivador %s"
L["Up"] = "Arriba"
L["Up, then Centered Horizontal"] = "Arriba, luego centrado horizontal"
L["Up, then Left"] = "Arriba, luego izquierda"
L["Up, then Right"] = "Arriba, luego derecha"
L["Update Position"] = "Actualizar posicin"
L["Usage:"] = "Uso:"
L["Use /wa minimap to show the minimap icon again."] = "Utilizar /wa minimap para mostrar el icono del minimapa de nuevo"
L["Use Custom Color"] = "Utilizar color personalizado"
L["Use Legacy floor rounding"] = "Utiliza el redondeo de suelo legado"
L["Use Texture"] = "Utilizar textura"
L["Use Watched Faction"] = "Utilizar faccin vigilada"
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "Utiliza UnitInRange() para comprobar si est dentro del rango. Coincide con el comportamiento predeterminado de los marcos de banda fuera de alcance, que oscila entre 25 y 40 metros dependiendo de tu clase y especializacin."
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = [=[El uso de WeakAuras.clones est en desuso. Utilice WeakAuras.GetRegion(id, cloneId) en su lugar.
]=]
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "El uso de WeakAuras.regions est en desuso. Utilice WeakAuras.GetRegion(id) en su lugar."
L["Vaelastrasz the Corrupt"] = "Vaelastrasz el Corrupto"
L["Versatility (%)"] = "Versatilidad (%)"
L["Versatility Rating"] = "ndice de versatilidad"
L["Vertical"] = "Vertical"
L["Viscidus"] = "Viscidus"
L["Visibility"] = "Visibilidad"
L["Visions of N'Zoth"] = "Visiones de N'Zoth"
L["Warband Quantity Total"] = "Cantidad total de banda guerrera"
L["Warband Transfer Percentage"] = "Porcentaje de transferencia de banda guerrera"
L["Warband Transferred Quantity"] = "Cantidad transferida de banda guerrera"
L["Warfront (Heroic)"] = "Frente de guerra (heroico)"
L["Warfront (Normal)"] = "Frente de guerra (normal)"
L["Warlords of Draenor"] = "Warlords of Draenor"
L["Warning"] = "Aviso"
L["Warning for unknown aura:"] = "Aviso para aura desconocida:"
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "Aviso: Anclar en el aura '%s' es imposible, debido a un ciclo de anclaje"
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = [=[Aviso: las auras de escaneo completo que verifican tanto el nombre como la identificacin del hechizo no se pueden convertir.
]=]
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "Aviso: la informacin del nombre ahora est disponible a travs de %affected, %unaffected. Nmero de miembros del grupo afectados a travs de %unitCount. Algunas opciones se comportan de manera diferente ahora. Esto no se ajusta automticamente."
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = [=[Aviso: Los valores de tooltip ahora estn disponibles a travs de %tooltip1, %tooltip2, %tooltip3 en lugar de %s. Esto no se ajusta automticamente.
]=]
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras incorporado (63:42 | 3:07 | 10 | 2.4)"
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras ha detectado configuraciones vacas. Si esto es inesperado, solicita asistencia en https://discord.gg/weakauras."
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = "WeakAuras ha detectado que ha sido degradado. Es posible que tus auras guardadas ya no funcionen correctamente. Te gustaras ejecutar la herramienta de reparacin |cffff0000EXPERIMENTAL|r? Esto sobrescribir cualquier cambio que haya realizado desde la ltima actualizacin de la base de datos. ltima actualizacin: %s |cffff0000Debes HACER UNA COPIA DE SEGURIDAD de tu carpeta WTF ANTES de presionar este botn.|r"
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras est creando una instantnea de reversin de tus auras. Esta instantnea te permitir volver al estado actual de tus auras si algo sale mal. Este proceso puede hacer que tu tasa de fotogramas disminuya hasta que se complete."
L["WeakAuras Profiling"] = "Perfilado de WeakAuras"
L["WeakAuras Profiling Report"] = "Informe de perfilado de WeakAuras"
L["WeakAuras Version: %s"] = "WeakAuras Versin: %s"
L["Weapon"] = "Arma"
L["Weapon Enchant"] = "Encantamiento de arma"
L["Weapon Enchant / Fishing Lure"] = "Encantamiento de arma/Cebo de pesca"
L["Whisper"] = "Susurro"
L["Width"] = "Anchura"
L["Wobble"] = "Temblar"
L["World Boss"] = "Jefe del mundo"
L["World Bosses"] = "Jefes del mundo"
L["Wrap"] = "Envolver"
L["Wrath of the Lich King"] = "Wrath of the Lich King"
L["Writing to the WeakAuras table is not allowed."] = "No se permite escribir en la tabla WeakAuras."
L["X-Offset"] = "Desplazamiento X"
L["Yell"] = "Grito"
L["Y-Offset"] = "Desplazamiento Y"
L["You have new auras ready to be installed!"] = "Tienes nuevas auras listas para instalar!"
L["Your next encounter will automatically be profiled."] = "Tu prximo encuentro se perfilar automticamente."
L["Your next instance of combat will automatically be profiled."] = "Tu prxima instancia de combate se perfilar automticamente."
L["Your scheduled automatic profile has been cancelled."] = "Tu perfil automtico programado ha sido cancelado."
L["Your threat as a percentage of the tank's current threat."] = "Tu amenaza como porcentaje de la amenaza actual del tanque."
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "Tu amenaza como porcentaje de la cantidad requerida para tomar agro. Tomar de agro a 100."
L["Your total threat on the mob."] = "Tu amenaza total por el monstruo"
L["Zone Group ID"] = "ID de grupo de zona"
L["Zone ID"] = "ID de zona"
L["Zone Name"] = "Nombre de zona"
L["Zoom"] = "Zoom"
L["Zoom Animation"] = "Animacin de zoom"
L["Zul'Gurub"] = "Zul'Gurub"



-- ========================================
-- File: WeakAuras/Locales/esMX.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "esMX" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = "Formatos de filtro: 'Nombre', 'Nombre-Reino', '-Reino'. Admite varias entradas, separadas por comas Puedes utilizar \\ para escapar -."
L["%s Overlay Color"] = "%s Color de superposicin"
L["* Suffix"] = "* Sufijo"
L["/wa help - Show this message"] = "/wa help - Muestra este mensaje"
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - Mostrar el botn del minimapa"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - Muestra los resultados de los perfiles ms recientes"
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart: inicia perfilados. Opcionalmente, incluya una duracin en segundos despus de la cual perfilado se detiene automticamente. Para perfilar el prximo combate/encuentro, pase un argumento de \"combate\" o \"encuentro\"."
L["/wa pstop - Finish profiling"] = "/wa pstop - Finalizar perfilado"
L["/wa repair - Repair tool"] = "/wa repair - Herramienta de reparacin"
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55fClic izquierdo|r para mostrar la ventana principal."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55fClic central|r para mostrar el icono del minimapa."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55fClic derecho|r para mostrar la ventana de perfiles de rendimiento."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fMays clic|r para pausar la ejecucin del addon."
L["|cffff0000deprecated|r"] = "|cffff0000obsoleto|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000No|r equipado ID bonus de objeto"
L["|cFFFF0000Not|r Item Equipped"] = "Objeto |cFFFF0000no|r equipado"
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000No|r nombre/reino del jugador"
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000No|r hechizo conocido"
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = "|cFFFF0000El soporte para COMBAT_LOG_EVENT_UNFILTERED sin filtro est obsoleto|r COMBAT_LOG_EVENT_UNFILTERED sin un filtro estn deshabilitados ya que son muy costosos en trminos de rendimiento. Ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00Opciones adicionales:|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00Opciones adicionales:|r Ninguno"
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = " |cff00ff00Jugador|r, |cff00ff00Objetivo|r, |cff00ff00Enfoque|r y |cff00ff00Mascota|r corresponden directamente a esos ID de unidad individuales.  |cff00ff00Unidad especfica|r te permite proporcionar un ID de unidad vlido especfico para observar. |cffff0000Nota|r: El juego no activar eventos para todos los ID de unidad vlidos, lo que har que este activador no pueda rastrear algunos.  |cffffff00Grupo|r, |cffffff00Banda|r, |cffffff00Jefe|r, |cffffff00Arena|r y |cffffff00Placa de nombre|r pueden coincidir con mltiples ID de unidad correspondientes.  |cffffff00Grupo inteligente|r se ajusta a tu tipo de grupo actual, haciendo coincidir solo el \"jugador\" cuando ests solo, las unidades de \"grupo\" (incluido el \"jugador\") en un grupo o las unidades de \"banda\" en una banda. |cffffff00*|r La configuracin de la unidad amarilla crear clones para cada unidad coincidente mientras este activador proporciona informacin dinmica a la aura."
L["1. Profession 1. Accessory"] = "1. Profesin 1. Accesorio"
L["1. Profession 2. Accessory"] = "1. Profesin 2. Accesorio"
L["1. Professsion Tool"] = "1. Herramienta de profesin"
L["10 Man Raid"] = "Banda de 10 jugadores"
L["10 Player Raid"] = "Banda de 10 jugadores"
L["10 Player Raid (Heroic)"] = "Banda de 10 jugadores (heroico)"
L["10 Player Raid (Normal)"] = "Banda de 10 jugadores (normal)"
L["2. Profession 1. Accessory"] = "2. Profesin 1. Accesorio"
L["2. Profession 2. Accessory"] = "2. Profesin 2. Accesorio"
L["2. Professsion Tool"] = "2. Herramienta de profesin"
L["20 Man Raid"] = "Banda de 20 jugadores"
L["20 Player Raid"] = "Banda de 20 jugadores"
L["25 Man Raid"] = "Banda de 25 jugadores"
L["25 Player Raid"] = "Banda de 25 jugadores"
L["25 Player Raid (Heroic)"] = "Banda de 25 jugadores (heroico)"
L["25 Player Raid (Normal)"] = "Banda de 25 jugadores (normal)"
L["40 Man Raid"] = "Banda de 40 jugadores"
L["40 Player Raid"] = "Banda de 40 jugadores"
L["5 Man Dungeon"] = "Mazmorra de 5 jugadores"
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = "Una descripcin detallada de tus sistemas de auras y WeakAuras. Copia todo el texto en el Discord de WeakAura si necesitas ayuda."
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "Un activador de esta aura est configurado para rastrear una unidad de tipo soft target, pero no tienes configuradas las CVars para que esto funcione correctamente. Considera la posibilidad de cambiar la unidad rastreada o de configurar las CVars de soft target."
L["Abbreviate"] = "Abreviar"
L["AbbreviateLargeNumbers (Blizzard)"] = "AbreviarNmerosGrandes (Blizzard)"
L["AbbreviateNumbers (Blizzard)"] = "AbreviarNmeros (Blizzard)"
L["Absorb"] = "Absorcin"
L["Absorb and Healing"] = "Absorpcin y sanacin"
L["Absorb Heal Overlay"] = "Superposicin de absorcin de sanacin"
L["Absorb Overlay"] = "Superposicin de absorcin"
L["Absorbed"] = "Absorbido"
L["Action Button Glow"] = "Resplandor del botn de accin"
L["Actions"] = "Acciones"
L["Active"] = "Activo"
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Addon de mdulo de jefe activo: |cFFffcc00BigWigs|r Nota: Este activador utilizar BigWigs o DBM, en ese orden si ambos estn instalados."
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Addon de mdulo de jefe activo: |cFFffcc00DBM|r Nota: Este activador utilizar BigWigs o DBM, en ese orden si ambos estn instalados."
L["Add"] = "Aadir"
L["Add Missing Auras"] = "Aadir auras perdidas"
L["Advanced Caster's Target Check"] = "Comprobacin avanzada del objetivo del lanzador"
L["Affected"] = "Afectado"
L["Affected Unit Count"] = "Recuento de unidades afectadas"
L["Afk"] = "Ausente"
L["Aggro"] = "Amenaza"
L["Agility"] = "Agilidad"
L["Ahn'Qiraj"] = "Ahn'Qiraj"
L["Alert Type"] = "Tipo de alerta"
L["Alive"] = "Vivo"
L["All"] = "Todo"
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "Todos los hijos de esta aura tampoco se cargarn, para minimizar la posibilidad de una corrupcin adicional."
L["All States table contains a non table at key: '%s'."] = "La tabla Todos los estados contiene una no tabla en la clave: '%s'."
L["All Triggers"] = "Todos los activadores"
L["Alliance"] = "Alianza"
L["Allow partial matches"] = "Permitir coincidencias parciales"
L["Alpha"] = "Transparencia"
L["Alternate Power"] = "Poder Alternativa"
L["Always"] = "Siempre"
L["Always active trigger"] = "Siempre activar activador"
L["Always include realm"] = "Incluir siempre el reino"
L["Always True"] = "Siempre verdadero"
L["Amount"] = "Cantidad"
L["Anchoring"] = "Anclaje"
L["And Talent"] = "y talento"
L["Angle and Radius"] = "ngulo y radio"
L["Animations"] = "Animaciones"
L["Anticlockwise"] = "Sentido antihorario"
L["Anub'Rekhan"] = "Anub'Rekhan"
L["Any"] = "Cualquiera"
L["Any Triggers"] = "Cualquier activador"
L["AOE"] = "AOE"
L["Arcane Resistance"] = "Resistencia arcana"
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = "Ests seguro de que quieres ejecutar la herramienta de reparacin |cffff0000EXPERIMENTAL|r? Esto sobrescribir cualquier cambio que hayas realizado desde la ltima actualizacin de la base de datos. ltima actualizacin: %s"
L["Arena"] = "Arena"
L["Armor (%)"] = "Armadura (%)"
L["Armor against Target (%)"] = "Armadura contra objetivo (%)"
L["Armor Rating"] = "ndice de armadura"
L["Array"] = "Formacin"
L["Ascending"] = "Ascendente"
L["Assigned Role"] = "Rol asignado"
L["Assigned Role Icon"] = "Icono del rol asignado"
L["Assist"] = "Ayudante"
L["Assisted Combat Next Cast"] = "Prximo lanzamiento de combate asistido"
L["At Least One Enemy"] = "Como Mnimo un Enemigo"
L["At missing Value"] = "Al faltar el valor"
L["At Percent"] = "Al porcentaje"
L["At Value"] = "Al valor"
L["At War"] = "En guerra"
L["Attach to End"] = "Fijar al final"
L["Attach to End, backwards"] = "Adjuntar al final, al revs"
L["Attach to Point"] = "Adjuntar al punto"
L["Attach to Start"] = "Fijar al inicio"
L["Attack Power"] = "Poder de ataque"
L["Attackable"] = "Atacable"
L["Attackable Target"] = "Objetivo atacable"
L["Aura"] = "Aura"
L["Aura '%s': %s"] = "Aura '%s': %s"
L["Aura Applied"] = "Aura aplicada"
L["Aura Applied Dose"] = "Dosis de aura aplicada"
L["Aura Broken"] = "Aura rota"
L["Aura Broken Spell"] = "Hechizo de aura rota"
L["Aura is using deprecated SetDurationInfo"] = "Aura est utilizando SetDurationInfo obsoleto"
L["Aura loaded"] = "Aura cargada"
L["Aura Name"] = "Nombre de aura"
L["Aura Names"] = "Nombres de aura"
L["Aura Refresh"] = "Actualizar aura"
L["Aura Removed"] = "Aura eliminada"
L["Aura Removed Dose"] = "Dosis de aura eliminada"
L["Aura Stack"] = "Acumulacin de Auras"
L["Aura Type"] = "Tipo de aura"
L["Aura Version: %s"] = "Versin del aura: %s"
L["Aura(s) Found"] = "Aura(s) encontrada(s)"
L["Aura(s) Missing"] = "Aura(s) faltante(s)"
L["Aura:"] = "Aura:"
L["Auras"] = "Auras"
L["Auras:"] = "Auras:"
L["Author Options"] = "Opciones de autor"
L["Auto"] = "Auto"
L["Autocast Shine"] = "Brillo de lanzamiento automtico"
L["Automatic"] = "Automtico"
L["Automatic Length"] = "Longitud automtica"
L["Automatic Rotation"] = "Rotacin automtica"
L["Available features: %s"] = "Caractersticas disponibles: %s"
L["Avoidance (%)"] = "Evasin (%)"
L["Avoidance Rating"] = "ndice de evasin"
L["Ayamiss the Hunter"] = "Ayamiss el Cazador"
L["Azuregos"] = "Azuregos"
L["Back and Forth"] = "De Atrs a Adelante"
L["Background"] = "Fondo"
L["Background Color"] = "Color de fondo"
L["Balnazzar"] = "Balnazzar"
L["Bar Color/Gradient Start"] = "Inicio de color de barra/gradiente"
L["Bar enabled in BigWigs settings"] = "Barra activada en la configuracin de BigWigs"
L["Bar enabled in Boss Mod addon settings"] = "Barra activada en la configuracin del addon del mdulo de jefe"
L["Bar enabled in DBM settings"] = "Barra activada en la configuracin de DBM"
L["Bar Texture"] = "Textura de barra"
L["Bar Type"] = "Tipo de barra"
L["Baron Geddon"] = "Barn Geddon"
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "Battle.net Mensaje"
L["Battleground"] = "Campo de Batalla"
L["Battleguard Sartura"] = "Guardia de batalla Sartura"
L["Beastmaster"] = "Maestro de bestias"
L["Beatrix"] = "Beatrix"
L["BG>Raid>Party>Say"] = "BG>Banda>Grupo>Decir"
L["BG-System Alliance"] = "Campo de Batalla - Alianza"
L["BG-System Horde"] = "Campo de Batalla - Horda"
L["BG-System Neutral"] = "Campo de Batalla - Neutral"
L["Big Number"] = "Nmero grande"
L["BigWigs Addon"] = "Addon de BigWigs"
L["BigWigs Message"] = "Mensaje de BigWigs"
L["BigWigs Stage"] = "Etapa de BigWigs"
L["BigWigs Timer"] = "Temporizador de BigWigs"
L["Black Wing Lair"] = "Guarida de Alanegra"
L["Bleed"] = "Sangrado"
L["Blizzard Combat Text"] = "Texto de Combate de Blizzard"
L["Blizzard Cooldown Reduction"] = "Reduccin de reutilizacin de Blizzard"
L["Block"] = "Bloqueo"
L["Block (%)"] = "Bloquear (%)"
L["Block against Target (%)"] = "Bloqueo contra objetivo (%)"
L["Block Value"] = "Valor de bloqueo"
L["Blocked"] = "Bloqueado"
L["Blood"] = "Sangre"
L["Blood Rune #1"] = "Runa sangrienta #1"
L["Blood Rune #2"] = "Runa sangrienta #2"
L["Bloodlord Mandokir"] = "Seor sangriento Mandokir"
L["Bonus Reputation Gain"] = "Bonus de reputacin ganada"
L["Border"] = "Borde"
L["Boss"] = "Jefe"
L["Boss Emote"] = "Jefe - Emocin"
L["Boss Mod Announce"] = "Anuncio de mdulo de jefe"
L["Boss Mod Stage"] = "Etapa de mdulo de jefe"
L["Boss Mod Stage (Event)"] = "Etapa (evento) de mdulo de jefe"
L["Boss Mod Timer"] = "Temporizador de mdulo de jefe"
L["Boss Whisper"] = "Susurro de jefe"
L["Bottom"] = "Abajo"
L["Bottom Left"] = "Abajo Izquierda"
L["Bottom Right"] = "Abajo Derecha"
L["Bottom to Top"] = "De Abajo a Arriba"
L["Bounce"] = "Rebotar"
L["Bounce with Decay"] = "Rebotar con Amortiguacin"
L["Break"] = "Romper"
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers (Blizzard)"
L["Broodlord Lashlayer"] = "Seor de linaje Capazote"
L["Buff"] = "Beneficio"
L["Buff/Debuff"] = "Beneficio/Perjuicio"
L["Buffed/Debuffed"] = "Beneficio activo/Perjuicio activo"
L["Burning Crusade"] = "Burning Crusade"
L["Buru the Gorger"] = "Buru el Manducador"
L["Caldoran"] = "Caldoran"
L["Callback function"] = "Funcin de rellamada"
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "Se puede utilizar, por ejemplo, para comprobar si \"boss1target\" es el mismo que \"player\"."
L["Cancel"] = "Cancelar"
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "No se puede cambiar el marco de seguridad en el bloqueo de combate. Ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "No se puede programar el temporizador con %i, debido a un error de World of Warcraft con un alto tiempo de actividad del ordenador. (Tiempo de actividad: %i). Por favor, reinicia tu ordenador."
L["Capped"] = "Lmite"
L["Capped at Season Max"] = "Lmite de mx. de la temporada"
L["Capped at Weekly Max"] = "Lmite de mx. semanal"
L["Cast"] = "Lanzar Hechizo"
L["Cast Bar"] = "Barra de lanzamiento"
L["Cast Failed"] = "Hechizo - Fallido"
L["Cast Start"] = "Hechizo - Empezar"
L["Cast Success"] = "Hechizo - Completado"
L["Cast Type"] = "Tipo de Hechizo"
L["Caster"] = "Lanzador"
L["Caster Name"] = "Nombre del lanzador"
L["Caster Realm"] = "Reino del lanzador"
L["Caster Unit"] = "Unidad del lanzador"
L["Casters Name/Realm"] = "Nombre/reino del lanzador"
L["Caster's Target"] = "Objetivo del lanzador"
L["Cataclysm"] = "Cataclysm"
L["Ceil"] = "Ceil"
L["Center"] = "Centro"
L["Center, then alternating bottom and top"] = "Centro, luego alternando abajo y arriba"
L["Center, then alternating left and right"] = "Centro, luego alternando izquierda y derecha"
L["Center, then alternating right and left"] = "Centro, luego alternando derecha e izquierda"
L["Center, then alternating top and bottom"] = "Centro, luego alternando arriba y abajo"
L["Centered Horizontal"] = "Centrado Horizontal"
L["Centered Horizontal, then Centered Vertical"] = "Centrado horizontal, luego centrado vertical"
L["Centered Horizontal, then Down"] = "Centrado horizontal, luego hacia abajo"
L["Centered Horizontal, then Up"] = "Centrado horizontal, luego hacia arriba"
L["Centered Vertical"] = "Centrado Vertical"
L["Centered Vertical, then Centered Horizontal"] = "Centrado vertical, luego centrado horizontal"
L["Centered Vertical, then Left"] = "Centrado vertical, luego a la izquierda"
L["Centered Vertical, then Right"] = "Centrado vertical, luego a la derecha"
L["Changed"] = "Modificado"
L["Channel"] = "Canal"
L["Channel (Spell)"] = "Canalizar Hechizo"
L["Character GUID"] = "GUID del personaje"
L["Character Name"] = "Nombre de personaje"
L["Character Stats"] = "Estadsticas del personaje"
L["Character Transferred Quantity"] = "Cantidad transferida de personaje"
L["Character Type"] = "Tipo de Personaje"
L["Charge gained/lost"] = "Carga ganada/perdida"
L["Charged Combo Points"] = "Puntos de combo cargados"
L["Charges"] = "Cargas"
L["Charges Changed Event"] = "Cargas de evento cambiado"
L["Charging"] = "Cargando"
L["Chat Frame"] = "Marco de chat"
L["Chat Message"] = "Mensaje de Chat"
L["Check if a single talent match a Rank"] = "Comprobar si un talento coincide con un rango"
L["Check nameplate's target every 0.2s"] = "Comprueba el objetivo del nombre de placa cada 0.2s"
L["Chromaggus"] = "Chromaggus"
L["Circle"] = "Crculo"
L["Circular Texture"] = "Textura circular"
L["Clamp"] = "Sujetar"
L["Class"] = "Clase"
L["Class and Specialization"] = "Clase y especializacin"
L["Classic"] = "Clsico"
L["Classification"] = "Clasificacin"
L["Clockwise"] = "En sentido horario"
L["Clone per Character"] = "Clonar por personaje"
L["Clone per Event"] = "Clonar por evento"
L["Clone per Match"] = "Clonar por encuentro"
L["Coin Precision"] = "Precisin de monedas"
L["Color"] = "Color"
L["Color Animation"] = "Animacin de color"
L["Combat Log"] = "Registro de Combate"
L["Communities"] = "Comunidades"
L["Condition Custom Test"] = "Prueba personalizada de condicin"
L["Conditions"] = "Condiciones"
L["Contains"] = "Contiene"
L["Continuously update Movement Speed"] = "Actualizacin continua de la velocidad de movimiento"
L["Cooldown"] = "Reutilizacin"
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "Las barras de reutilizacin muestran el tiempo que transcurre antes de que una habilidad est lista para ser utilizada, BigWigs las indica con el prefijo \"~\"."
L["Cooldown Progress (Item)"] = "Progreso de reutilizacin (objeto)"
L["Cooldown Progress (Slot)"] = "Progreso de reutilizacin (ranura)"
L["Cooldown Ready Event"] = "Evento de reutilizacin preparado"
L["Cooldown Ready Event (Item)"] = "Evento de reutilizacin preparado (objeto)"
L["Cooldown Ready Event (Slot)"] = "Evento de reutilizacin preparado (ranura)"
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "Reduccin de reutilizacin cambia la duracin de los segundos en lugar de mostrar los segundos en tiempo real."
L["Cooldown/Charges/Count"] = "Reutilizacin/Cargas/Recuento"
L["Copper"] = "Cobre"
L["Could not load WeakAuras Archive, the addon is %s"] = "No se pudo cargar WeakAuras Archive, el addon est %s"
L["Count"] = "Recuento"
L["Counter Clockwise"] = "En sentido anti-horario"
L["Create"] = "Crear"
L["Creature Family"] = "Familia de criatura"
L["Creature Family Name"] = "Nombre de familia de criatura"
L["Creature Type"] = "Tipo de criatura"
L["Creature Type Name"] = "Nombre de tipo de criatura"
L["Critical"] = "Crtico"
L["Critical (%)"] = "Crtico (%)"
L["Critical Rating"] = "ndice de crtico"
L["Crop X"] = "Recorte X"
L["Crop Y"] = "Recorte Y"
L["Crowd Controlled"] = "Bajo Control"
L["Crushing"] = "Golpe Aplastador"
L["C'thun"] = "C'thun"
L["Cumulated time used during profiling"] = "Tiempo acumulado utilizado durante el perfilado."
L["Currency"] = "Moneda"
L["Current Essence"] = "Esencia actual"
L["Current Experience"] = "Experiencia actual"
L["Current Instance"] = "Estancia actual"
L["Current Movement Speed (%)"] = "Velocidad de movimiento actual (%)"
L["Current Stage"] = "Etapa actual"
L["Current Zone"] = "Zona actual"
L["Current Zone Group"] = "Grupo de zona actual"
L["Curse"] = "Maldicin"
L["Custom"] = "Personalizado"
L["Custom Action"] = "Accin personalizada"
L["Custom Anchor"] = "Ancla personalizada"
L["Custom Check"] = "Comprobacin personalizada"
L["Custom Color"] = "Color personalizado"
L["Custom Condition Code"] = "Cdigo de condicin personalizado"
L["Custom Configuration"] = "Configuracin personalizada"
L["Custom Fade Animation"] = "Animacin de fundido personalizada"
L["Custom Function"] = "Funcin Personalizada"
L["Custom Grow"] = "Crecimiento personalizado"
L["Custom Sort"] = "Orden personalizado"
L["Custom Text Function"] = "Funcin de texto personalizado"
L["Custom Trigger Combination"] = "Combinacin de activadores personalizada"
L["Custom Variables"] = "Variables personalizadas"
L["Damage"] = "Dao"
L["Damage Shield"] = "Escudo Daino"
L["Damage Shield Missed"] = "Escudo Daino Fallido"
L["Damage Split"] = "Dao Repartido"
L["DBM Announce"] = "Anuncio de DBM"
L["DBM Stage"] = "Etapa de DBM"
L["DBM Timer"] = "Temporizador de DBM"
L["Dead"] = "Muerto"
L["Death"] = "Muerte"
L["Death Knight Rune"] = "Caballero de la Muerte - Runa"
L["Debuff"] = "Perjuicio"
L["Debuff Class"] = "Clase del perjuicio"
L["Debuff Class Icon"] = "Icono de clase del perjuicio"
L["Debuff Type"] = "Tipo de perjuicio"
L["Debug Log contains more than 1000 entries"] = "El registro de depuracin contiene ms de 1000 entradas"
L["Debug Logging enabled"] = "Registro de depuracin activado"
L["Debug Logging enabled for '%s'"] = "Registro de depuracin activado para '%s'."
L["Defensive Stats"] = "Estadsticas defensivas"
L["Deflect"] = "Desviar"
L["Delve"] = "Abismo"
L["Desaturate"] = "Desaturar"
L["Desaturate Background"] = "Desaturar fondo"
L["Desaturate Foreground"] = "Desaturar primer plano"
L["Descending"] = "Descendente"
L["Description"] = "Descripcin"
L["Dest Raid Mark"] = "Marca de banda de destino"
L["Destination Affiliation"] = "Afiliacin de destino"
L["Destination GUID"] = "GUID del destino"
L["Destination Info"] = "Info del destino"
L["Destination Name"] = "Nombre del Destino"
L["Destination NPC Id"] = "ID de PNJ del destino"
L["Destination Object Type"] = "Tipo de objeto del destino"
L["Destination Reaction"] = "Reaccin de destino"
L["Destination Unit"] = "Unidad de Destino"
L["Destination unit's raid mark index"] = "ndice de marcas de banda de la unidad de destino"
L["Destination unit's raid mark texture"] = "Textura de marcas de banda de la unidad de destino"
L["Difficulty"] = "Dificultad"
L["Disable Spell Known Check"] = "Desactivar comprobacin de hechizo conocido"
L["Disabled"] = "Desactivado"
L["Disabled feature %q"] = "Caracterstica desactivada: %q"
L["Disabled Spell Known Check"] = "Desactivar comprobacin de hechizo conocido"
L["Discovered"] = "Descubierto"
L["Disease"] = "Enfermedad"
L["Dispel"] = "Disipar"
L["Dispel Failed"] = "Disipar Fallido"
L["Display"] = "Visualizacin"
L["Distance"] = "Distancia"
L["Do Not Disturb"] = "No molestar"
L["Dodge"] = "Esquivar"
L["Dodge (%)"] = "Esquivar (%)"
L["Dodge Rating"] = "ndice de esquiva"
L["Down"] = "Abajo"
L["Down, then Centered Horizontal"] = "Abajo, luego centrado horizontal"
L["Down, then Left"] = "Abajo, luego izquierda"
L["Down, then Right"] = "Abajo, luego derecha"
L["Dragonflight"] = "Dragonflight"
L["Drain"] = "Drenar"
L["Dropdown Menu"] = "Men desplegable"
L["Dumping table"] = "Tabla de descarga"
L["Dungeon (Celestial)"] = "Calabozo (Celestial)"
L["Dungeon (Heroic)"] = "Mazmorra (Heroico)"
L["Dungeon (Mythic)"] = "Mazmorra (Mtico)"
L["Dungeon (Mythic+)"] = "Mazmorra (Mtico+)"
L["Dungeon (Normal)"] = "Mazmorra (Normal)"
L["Dungeon (Timewalking)"] = "Mazmorra (Paseo en el tiempo)"
L["Dungeons"] = "Mazmorras"
L["Durability Damage"] = "Dao a la Durabilidad"
L["Durability Damage All"] = "Dao a la Durabilidad Total"
L["Duration"] = "Duracin"
L["Duration Function"] = "Funcin de duracin"
L["Duration Function (fallback state)"] = "Funcin de duracin (estado de reserva)"
L["Ease In"] = "Entrar"
L["Ease In and Out"] = "Entrar y salir"
L["Ease Out"] = "Salir"
L["Ebonroc"] = "Ebanorroca"
L["Eclipse Direction"] = "Direccin de Eclipse"
L["Edge"] = "Borde"
L["Edge of Madness"] = "Cabo de la Locura"
L["Effective Spell Id"] = "ID de hechizo efectivo"
L["Elide"] = "Omitir"
L["Elite"] = "lite"
L["Emote"] = "Emocion"
L["Empower Cast End"] = "Empoderar fin de lanzamiento"
L["Empower Cast Interrupt"] = "Empoderar interrupcin de lanzamiento"
L["Empower Cast Start"] = "Empoderar inicio de lanzamiento"
L["Empowered"] = "Empoderado"
L["Empowered 1"] = "Empoderado 1"
L["Empowered 2"] = "Empoderado 2"
L["Empowered 3"] = "Empoderado 3"
L["Empowered 4"] = "Empoderado 4"
L["Empowered 5"] = "Empoderado 5"
L["Empowered Cast"] = "Lanzamiento empoderado"
L["Empowered Cast Fully Charged"] = "Empoderar lanzamiento cargado completamente"
L["Empowered Fully Charged"] = "Empoderar carga completa"
L["Empty"] = "Ninguna"
L["Enabled feature %q"] = "Caracterstica activada: %q"
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "Activa el redondeo (incorrecto) a la baja de los segundos, que era el comportamiento anterior por defecto."
L["Enchant Applied"] = "Encantamiento aplicado"
L["Enchant Found"] = "Encantar encontrado"
L["Enchant ID"] = "ID de encantamiento"
L["Enchant Missing"] = "Falta encantamiento"
L["Enchant Name or ID"] = "Nombre o ID del encantamiento"
L["Enchant Removed"] = "Encantamiento eliminado"
L["Enchanted"] = "Encantado"
L["Encounter ID(s)"] = "ID(s) del encuentro"
L["Energize"] = "Vigorizar"
L["Enrage"] = "Enfurecido"
L["Enter a name or a spellId"] = "Entrar un nombre o ID de hechizo"
L["Entering"] = "Accediendo"
L["Entering/Leaving Combat"] = "Entrar/Salir de combate"
L["Entering/Leaving Encounter"] = "Comenzando/saliendo encuentro"
L["Entry Order"] = "Orden de entrada"
L["Environment Type"] = "Tipo de Entorno"
L["Environmental"] = "Ambiental"
L["Equipment"] = "Equipo"
L["Equipment Set"] = "Conjunto de equipo"
L["Equipment Set Equipped"] = "Conjunto de equipo equipado"
L["Equipment Slot"] = "Ranura para equipo"
L["Equipped"] = "Equipado"
L["Error"] = "Error"
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "El error '%s' ha creado un clon seguro. Aconsejamos eliminar el aura. Para ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Error decoding."] = "Error al descodificar."
L["Error decompressing"] = "Error al descomprimir"
L["Error decompressing. This doesn't look like a WeakAuras import."] = "Error al descomprimir. Esto no parece una importacin de WeakAuras."
L["Error deserializing"] = "Error de deserializacin"
L["Error Frame"] = "Marco de error"
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "ERROR en '%s' tipo de subelemento '%s' desconocido o incompatible"
L["Error in Aura '%s'"] = "Error en el aura '%s'"
L["Error not receiving display information from %s"] = "Error al no recibir informacin de visualizacin de %s"
L["Essence"] = "Esencia"
L["Essence #1"] = "Esencia #1"
L["Essence #2"] = "Esencia #2"
L["Essence #3"] = "Esencia #3"
L["Essence #4"] = "Esencia #4"
L["Essence #5"] = "Esencia #5"
L["Essence #6"] = "Esencia #6"
L["Evade"] = "Evadir"
L["Event"] = "Evento"
L["Event(s)"] = "Evento(s)"
L["Every Frame"] = "Cada fotograma"
L["Every Frame (High CPU usage)"] = "Cada fotograma (uso elevado de CPU)"
L["Evoker Essence"] = "Esencia evocadora"
L["Exact Spell ID(s)"] = "ID de hechizo exacto"
L["Execute Conditions"] = "Ejecutar condiciones"
L["Experience (%)"] = "Experiencia (%)"
L["Expertise Bonus"] = "Bonus de pericia"
L["Expertise Rating"] = "ndice de pericia"
L["Extend Outside"] = "Extender afuera"
L["Extra Amount"] = "Cantidad Adicional"
L["Extra Attacks"] = "Ataques Adicional"
L["Extra Spell Id"] = "ID de hechizo extra"
L["Extra Spell Name"] = "Nombre del Hechizo Extra"
L["Faction"] = "Faccin"
L["Faction Name"] = "Nombre de faccin "
L["Faction Reputation"] = "Reputacin de faccin"
L["Fade Animation"] = "Animacin de fundido"
L["Fade In"] = "Aparecer"
L["Fade Out"] = "Desaparecer"
L["Fail Alert"] = "Alerta de Fallo"
L["False"] = "Falso"
L["Fankriss the Unyielding"] = "Fankriss el Implacable"
L["Feature %q is already disabled"] = "La caracterstica %q ya est desactivada."
L["Feature %q is already enabled"] = "La caracterstica %q ya est activada."
L["Fetch Absorb"] = "Obtener absorcin"
L["Fetch Heal Absorb"] = "Obtener absorcin de sanacin"
L["Fetch Legendary Power"] = "Obtener poder legendario"
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "Obtiene el nombre y el icono del Poder Legendario que coincide con este id de bonificacin."
L["Fill Area"] = "Rellenar rea"
L["Filter messages with format <message>"] = "Filtrar mensajes con formato <mensaje>"
L["Fire Resistance"] = "Resistencia al fuego"
L["Firemaw"] = "Faucefogo"
L["First"] = "Primero"
L["First Value of Tooltip Text"] = "Primer valor del texto del tooltip"
L["Fixed"] = "Fijo"
L["Fixed Names"] = "Nombres fijos"
L["Fixed Size"] = "Tamao fijo"
L["Flamegor"] = "Flamagor"
L["Flash"] = "Destello"
L["Flex Raid"] = "Banda Flexible"
L["Flip"] = "Voltear"
L["Floor"] = "Piso"
L["Focus"] = "Foco"
L["Follower Dungeon"] = "Calabozo de seguidores"
L["Font"] = "Fuente"
L["Font Size"] = "Tamao de fuente"
L["Forbidden function or table: %s"] = "Funcin o tabla prohibida: %s"
L["Foreground"] = "Primer plano"
L["Foreground Color"] = "Color de primer plano"
L["Form"] = "Forma"
L["Format"] = "Formato"
L["Format Gold"] = "Formatar oro"
L["Formats |cFFFFCC00%unit|r"] = "Formatea |cFFFFCC00%unidad|r"
L["Formats Player's |cFFFFCC00%guid|r"] = "Formatea |cFFFFCC00%guid|r del jugador"
L["Forward"] = "Adelante"
L["Forward, Reverse Loop"] = "Adelante, bucle inverso"
L["Fourth Value of Tooltip Text"] = "Cuarto valor del texto de tooltip"
L["Frame Selector"] = "Selector de marco"
L["Frequency"] = "Frecuencia"
L["Friendly"] = "Amistoso"
L["Friendly Fire"] = "Fuego Amigo"
L["Friendship Max Rank"] = "Rango mx. de amistad"
L["Friendship Rank"] = "Rango de amistad"
L["Friendship Reputation"] = "Reputacin de amistad"
L["Frost"] = "Escarcha"
L["Frost Resistance"] = "Resistencia a la Escarcha"
L["Frost Rune #1"] = "Runa de escarcha #1"
L["Frost Rune #2"] = "Runa de escarcha #2"
L["Full"] = "Lleno"
L["Full Region"] = "Regin llena"
L["Full/Empty"] = "Lleno/vaco"
L["Gahz'ranka"] = "Gahz'ranka"
L["Gained"] = "Obtenido"
L["Garr"] = "Garr"
L["Gehennas"] = "Gehennas"
L["General"] = "General"
L["General Rajaxx"] = "General Rajaxx"
L["GetNameAndIcon Function (fallback state)"] = "Funcin GetNameAndIcon (estado de reserva)"
L["Glancing"] = "de refiln"
L["Global Cooldown"] = "Recarga Global"
L["Glow"] = "Resplandor"
L["Glow External Element"] = "Elemento externo del resplandor"
L["Gluth"] = "Gluth"
L["Glyph"] = "Glifo"
L["Gold"] = "Oro"
L["Golemagg the Incinerator"] = "Golemagg el Incinerador"
L["Gothik the Harvester"] = "Gothik el Cosechador"
L["Gradient"] = "Degradado"
L["Gradient Enabled"] = "Degradado activado"
L["Gradient End"] = "Fin del gradiente"
L["Gradient Orientation"] = "Orientacin del degradado"
L["Gradient Pulse"] = "Degradado Pulsante"
L["Grand Widow Faerlina"] = "Gran Viuda Faerlina"
L["Grid"] = "Rejilla"
L["Grobbulus"] = "Grobbulus"
L["Group"] = "Grupo"
L["Group Arrangement"] = "Disposicin de grupos"
L["Group Leader/Assist"] = "Lder/ayudante de grupo"
L["Group Size"] = "Tamao de grupo"
L["Group Type"] = "Tipo de grupo"
L["Grow"] = "Crecer"
L["GTFO Alert"] = "Alerta GTFO"
L["Guardian"] = "Guardin"
L["Guild"] = "Hermandad"
L["Hakkar"] = "Hakkar"
L["Hardcore"] = "Extremo"
L["Has Target"] = "Tiene objetivo"
L["Has Vehicle UI"] = "Tiene IU de vehculo"
L["HasPet"] = "Mascota viva"
L["Haste (%)"] = "Celeridad (%)"
L["Haste Rating"] = "ndice de celeridad"
L["Heal"] = "Cura"
L["Heal Absorb"] = "Absorcin de sanacin"
L["Heal Absorbed"] = "Sanacin absorbida"
L["Health"] = "Salud"
L["Health (%)"] = "Vida (%)"
L["Health Deficit"] = "Dficit de sanacin"
L["Heigan the Unclean"] = "Heigan el Impuro"
L["Height"] = "Altura"
L["Hero Talent"] = "Talento de Hroe"
L["Heroic Party"] = "Grupo heroico"
L["Hide"] = "Ocultar"
L["Hide 0 cooldowns"] = "Ocultar 0 reutilizaciones"
L["Hide Timer Text"] = "Ocultar texto del temporizador"
L["High Damage"] = "Alto Dao"
L["High Priest Thekal"] = "Sumo Sacerdote Thekal"
L["High Priest Venoxis"] = "Sumo Sacerdote Thekal"
L["High Priestess Arlokk"] = "Suma Sacerdotisa Arlokk"
L["High Priestess Jeklik"] = "Suma Sacerdotisa Jeklik"
L["High Priestess Mar'li"] = "Suma Sacerdotisa Mar'li"
L["Higher Than Tank"] = "Mayor Que el Tanque"
L["Highest Spell Id"] = "ID de hechizo ms alto"
L["Hit (%)"] = "Golpear (%)"
L["Hit Rating"] = "ndice de golpear"
L["Holy Resistance"] = "Resistencia sagrada"
L["Horde"] = "Horda"
L["Horizontal"] = "Horizontal"
L["Hostile"] = "Hostil"
L["Hostility"] = "Holstilidad"
L["Humanoid"] = "Humanoide"
L["Hybrid"] = "Hbrido"
L["Icon"] = "Icono"
L["Icon Function"] = "Funcin de icono"
L["Icon Function (fallback state)"] = "Funcin de icono (estado de reserva)"
L["Id"] = "ID"
L["ID"] = "ID"
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "Si necesitas ms ayuda, abre un ticket en GitHub o visita nuestro Discord en https://discord.gg/weakauras."
L["Ignore Dead"] = "Ignorar muertos"
L["Ignore Disconnected"] = "Ignorar desconectados"
L["Ignore Rune CD"] = "Ignorar Recarga de Runas"
L["Ignore Rune CDs"] = "Ignorar reutilizacin de runa"
L["Ignore Self"] = "Ignorarse a s mismo"
L["Ignore Spell Cooldown/Charges"] = "Ignorar tiempo de reutilizacin/cargas de hechizos"
L["Ignore Spell Override"] = [=[Ignorar sobrescritura de hechizo
]=]
L["Immune"] = "Inmune"
L["Important"] = "Importante"
L["Importing will start after combat ends."] = "La importacin comenzar una vez finalizado el combate."
L["In Combat"] = "En combate"
L["In Encounter"] = "En encuentro"
L["In Group"] = "En grupo"
L["In Party"] = "En grupo"
L["In Pet Battle"] = "En duelo de mascotas"
L["In Raid"] = "En banda"
L["In Range"] = "En el rango"
L["In Vehicle"] = "Conduciendo"
L["In War Mode"] = "En modo guerra"
L["Include Bank"] = "Incluye el Banco"
L["Include Charges"] = "Incluye las Cargas"
L["Include Death Runes"] = "Incluir runas de muerte"
L["Include Pets"] = "Incluir mascotas"
L["Include War Band Bank"] = "Incluir banco de tropas"
L["Incoming Heal"] = "Sanacin entrante"
L["Increase Precision Below"] = "Aumentar la precisin por debajo de"
L["Increases by one per stage or intermission."] = "Aumenta en uno por etapa o intervalo."
L["Information"] = "Informacin"
L["Inherited"] = "Heredado"
L["Instakill"] = "Muerte Instantanea"
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "Instala los addons BugSack y BugGrabber para obtener registros de errores detallados."
L["Instance"] = "Instancia"
L["Instance Difficulty"] = "Dificultad de la instancia"
L["Instance Id"] = "ID de estancia"
L["Instance ID"] = "ID de estancia"
L["Instance Info"] = "Info de estancia"
L["Instance Name"] = "Nombre de estancia"
L["Instance Size Type"] = "Tipo de tamao de estancia"
L["Instance Type"] = "Tipo de Instancia"
L["Instructor Razuvious"] = "Instructor Razuvious"
L["Insufficient Resources"] = "Recursos insuficientes"
L["Intellect"] = "Intelecto"
L["Interrupt"] = "Interrupcin"
L["Interrupt School"] = "Interrumpir escuela"
L["Interrupted School Text"] = "Texto de escuela interrumpido"
L["Interruptible"] = "Interrumpible"
L["Inverse"] = "Inverso"
L["Inverse Pet Behavior"] = "Invertir comportamiento de mascota"
L["Is Away from Keyboard"] = "No est delante del ordenador"
L["Is Current Specialization"] = "Es especializacin actual"
L["Is Death Rune"] = "Es una Runa de muerte"
L["Is Exactly"] = "Es Exactamente"
L["Is Moving"] = "se est moviendo"
L["Is Off Hand"] = "Es mano izquierda"
L["Is Paragon Reputation"] = "Es reputacin de Dechado"
L["Is Paused"] = "Est en pausa"
L["is useable"] = "es utilizable"
L["Is Weekly Renown Capped"] = "Est limitado el renombre semanal"
L["Island Expedition (Heroic)"] = "Expedicin insular (Heroico)"
L["Island Expedition (Mythic)"] = "Expedicin insular (Mtico)"
L["Island Expedition (Normal)"] = "Expedicin insular (Normal)"
L["Island Expeditions (PvP)"] = "Expedicin insular (JcJ)"
L["Item"] = "Objeto"
L["Item Bonus Id"] = "ID de bonus de objeto"
L["Item Bonus Id Equipped"] = "ID de bonus de objeto equipado"
L["Item Count"] = "Contar los Objetos"
L["Item Equipped"] = "Objeto equipado"
L["Item Id"] = "ID de objeto"
L["Item in Range"] = "Objeto en rango"
L["Item Name"] = "Nombre de objeto"
L["Item Set Equipped"] = "Conjunto de objeto equipado"
L["Item Set Id"] = "ID de conjunto de objetos"
L["Item Slot"] = "Ranura de objeto"
L["Item Slot String"] = "Cadena de ranura de objeto"
L["Item Type"] = "Tipo de objeto"
L["Item Type Equipped"] = "Tipo de objeto equipado"
L["ItemId"] = "ID de objeto"
L["Jin'do the Hexxer"] = "Jin'do el Aojador"
L["Journal Stage"] = "Etapa de diario"
L["Kazzak"] = "Kazzak"
L["Keep Inside"] = "Mantener en el interior"
L["Kel'Thuzad"] = "Kel'Thuzad"
L["Kurinnaxx"] = "Kurinnaxx"
L["Large"] = "Grande"
L["Latency"] = "Latencia"
L["Leader"] = "Lder"
L["Least remaining time"] = "Menos tiempo restante"
L["Leaving"] = "Saliendo"
L["Leech"] = "Parasitar"
L["Leech (%)"] = "Parasitar (%)"
L["Leech Rating"] = "ndice de parasitar"
L["Left"] = "Izquierda"
L["Left to Right"] = "De Izquierda a Derecha"
L["Left, then Centered Vertical"] = "Izquierda, luego centrado vertical"
L["Left, then Down"] = "Izquierda, luego abajo"
L["Left, then Up"] = "Izquierda, luego arriba"
L["Legacy Looking for Raid"] = "Buscar banda legado"
L["Legacy RGB Gradient"] = "Gradiente RGB legado"
L["Legacy RGB Gradient Pulse"] = "Pulsa de gradiente RGB legado"
L["Legion"] = "Legion"
L["Length"] = "Longitud"
L["Level"] = "Nivel"
L["LibSharedMedia"] = "LibSharedMedia"
L["Lillian Voss"] = "Lillian Voss"
L["Limited"] = "Limitado"
L["Linear Texture"] = "Textura lineal"
L["Lines & Particles"] = "Lneas y partculas"
L["Load Conditions"] = "Condiciones de carga"
L["Loatheb"] = "Loatheb"
L["Location"] = "Ubicacin"
L["Looking for Raid"] = "Buscador de banda"
L["Loop"] = "Bucle"
L["Loot"] = "Botn"
L["Loot Specialization"] = "Especializacin de botn"
L["Loot Specialization Id"] = "ID de especializacin de botn"
L["Loot Specialization Name"] = "Nombre de especializacin de botn"
L["Lorewalking"] = "Cronoleyenda"
L["Lost"] = "Perdido"
L["Low Damage"] = "Bajo Dao"
L["Lower Than Tank"] = "Menor Que el Tanque"
L["Lowest Spell Id"] = "ID de hechizo ms bajo"
L["Lua error"] = "Error de lua"
L["Lua error in Aura '%s': %s"] = "Error de Lua en el aura '%s': %s"
L["Lucifron"] = "Lucifron"
L["Maexxna"] = "Maexxna"
L["Magic"] = "Magia"
L["Magmadar"] = "Magmadar"
L["Main Character"] = "Personaje principal"
L["Main Stat"] = "Estadstica principal"
L["Majordomo Executus"] = "Mayordomo Executus"
L["Malformed WeakAuras link"] = "Enlace WeakAuras malformado"
L["Manual"] = "Manual"
L["Manual Icon"] = "Icono manual"
L["Manual Rotation"] = "Rotacin manual"
L["Marked First"] = "Marcado en primer lugar"
L["Marked Last"] = "Marcado en ltimo lugar"
L["Mason"] = "Mampostero"
L["Master"] = "Maestro"
L["Mastery (%)"] = "Maestra (%)"
L["Mastery Rating"] = "ndice de maestra"
L["Match Count"] = "Recuento de coincidencia"
L["Match Count per Unit"] = "Recuento de coincidencia por unidad"
L["Matches (Pattern)"] = "Corresponde (Patrn)"
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = "Coincide con el nmero de etapa del diario de encuentros. Los intermedios son .5 Por ej. 1;2;1;2;2.5;3"
L["Max Char "] = "Caracteres mx."
L["Max Char"] = "Carcter mximo"
L["Max Charges"] = "Cargas mx."
L["Max Health"] = "Salud mx."
L["Max Power"] = "Poder mx."
L["Max Quantity"] = "Cantidad mx."
L["Maximum Estimate"] = "Mximo estimado"
L["Maximum Progress"] = "Progreso mximo"
L["Maximum time used on a single frame"] = "Tiempo mximo utilizado en un solo fotograma"
L["Media"] = "Media"
L["Medium"] = "Medio"
L["Melee"] = "Cuerpo a cuerpo"
L["Melee Haste (%)"] = "Celeridad cuerpo a cuerpo (%)"
L["Message"] = "Mensaje"
L["Message Type"] = "Tipo de Mensaje"
L["Message type:"] = "Tipo de Mensaje:"
L["Meta Data"] = "Metadatos"
L["Mine"] = "Mo"
L["Minimum Estimate"] = "Mnimo estimado"
L["Minimum Progress"] = "Progreso mnimo"
L["Minus (Small Nameplate)"] = "Menos (placa de nombre pequeo)"
L["Mirror"] = "Reflejo"
L["Miscellaneous"] = "Miscelneos"
L["Miss"] = "Fallo"
L["Miss Type"] = "Tipo de Fallo"
L["Missed"] = "Fallado"
L["Missing"] = "Ausente"
L["Mists of Pandaria"] = "Mists of Pandaria"
L["Moam"] = "Moam"
L["Model"] = "Modelo"
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Blizzard moderno (1h 3m | 3m 7s | 10s | 2.4)"
L["Modernize"] = "Modernizar"
L["Molten Core"] = "Ncleo de Magma"
L["Money"] = "Dinero"
L["Monochrome"] = "Monocromo"
L["Monochrome Outline"] = "Contorno monocromo"
L["Monochrome Thick Outline"] = "Contorno grueso monocromo"
L["Monster Emote"] = "Emote de monstruo"
L["Monster Party"] = "Grupo de monstruo"
L["Monster Say"] = "Monstruo hablando"
L["Monster Whisper"] = "Susurro de monstruo"
L["Monster Yell"] = "Grito de Monstruo"
L["Moon"] = "Luna"
L["Most remaining time"] = "La mayor parte del tiempo restante"
L["Mounted"] = "Montado"
L["Mouse Cursor"] = "Cursor del ratn"
L["Movement Speed Rating"] = "ndice de velocidad de movimiento"
L["Multi-target"] = "Objetivo Mltiple"
L["Mythic Keystone"] = "Piedra angular mtica"
L["Mythic+ Affix"] = "Afijo de mtica+"
L["Name"] = "Nombre"
L["Name Function"] = "Funcin de nombre"
L["Name Function (fallback state)"] = "Funcin de nombre (estado de reserva)"
L["Name of Caster's Target"] = "Nombre del objetivo del lanzador"
L["Name of the (sub-)zone currently shown above the minimap."] = "Nombre de la (sub)zona que se muestra actualmente encima del minimapa."
L["Name(s)"] = "Nombre(s)"
L["Name/Realm of Caster's Target"] = "Nombre/Reino del objetivo del lanzador"
L["Nameplate"] = "Placa"
L["Nameplates"] = "Placas"
L["Names of affected Players"] = "Nombres de los jugadores afectados"
L["Names of unaffected Players"] = "Nombres de los jugadores no afectados"
L["Nature Resistance"] = "Resistencia a la naturaleza"
L["Naxxramas"] = "Naxxramas"
L["Nefarian"] = "Nefarian"
L["Neutral"] = "Neutral"
L["Never"] = "Nunca"
L["Next Combat"] = "Siguiente combate"
L["Next Encounter"] = "Siguiente encuentro"
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Ningn addon de mdulo de jefe activo. Nota: Este activador utilizar BigWigs o DBM, en ese orden si ambos estn instalados."
L["No Extend"] = "Sin extender"
L["No Instance"] = "Fuera de Instancia"
L["No Profiling information saved."] = "No hay informacin de perfil guardada."
L["No Progress Information available."] = "No hay informacin de progreso disponible."
L["None"] = "Nada"
L["Non-player Character"] = "Personaje No Jugador"
L["Normal"] = "Normal"
L["Normal Party"] = "Grupo normal"
L["Not in Group"] = "No en grupo"
L["Not in Smart Group"] = "No en grupo inteligente"
L["Not on Cooldown"] = "No en reutilizacin"
L["Not On Threat Table"] = "No Est En La Tabla De Amenaza"
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "Nota: debido a lo complicado que es el comportamiento del temporizador de swing y a la falta de APIs por parte de Blizzard, los resultados son imprecisos en casos extremos."
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "Nota: 'Ocultar solo' no est disponible en el nuevo sistema de seguimiento de aura. En su lugar, se puede utilizar una opcin de carga."
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "Nota: las sustituciones de texto disponibles para los multiactivadores coinciden ahora con las de los activadores normales."
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = "Nota: Este disparador almacena internamente la posicin de cambio de forma, por lo tanto es incompatible con aprender posturas sobre la marcha, como por ejemplo la Runa del Gladiador."
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "Nota: Este activador se basa en la API de WoW, que devuelve informacin incorrecta en algunos casos."
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "Nota: este tipo de activador estima el alcance a la hitbox de una unidad. El alcance real de los jugadores aliados suele ser 3 metros ms que la estimacin. Las capacidades de comprobacin del alcance dependen de tu clase actual y de tus habilidades conocidas, as como del tipo de unidad que se est comprobando. Algunos de los rangos pueden no funcionar con ciertos NPCs.|n|n|cFFAAFFAAUnidades amistosas:|r %s|n|cFFFFAAAAUnidades dainas:|r %s|n|cFFAAAAFFUnidades diversas:|r %s"
L["Noth the Plaguebringer"] = "Noth el Pesteador"
L["NPC"] = "PNJ"
L["Npc ID"] = "ID de pnj"
L["Number"] = "Nmero"
L["Number Affected"] = "Dependiente de nmeros"
L["Object"] = "Objeto"
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3. Funciona solo si el addon mdulo de jefe muestra el contador."
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3 Solo si BigWigs lo muestra en su barra"
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = "Ocurrencia del evento, se reinicia cuando se descarga la aura. Puede ser un rango de valores. Puede tener mltiples valores separados por una coma o un espacio. Ejemplos: 2. 5. y 6. eventos: 2, 5, 6 2. a 6.: 2-6 cada 2 eventos : /2 cada 3 eventos comenzando desde el 2: 2/3 cada 3 eventos comenzando desde el 2 y terminando en el 11: 2-11/3 Solo si DBM lo muestra en su barra"
L["Officer"] = "Oficial"
L["Offset from progress"] = "Desplazamiento de progreso"
L["Offset Timer"] = "Temporizador de desplazamiento"
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Antiguo de Blizzard (2h | 3m | 10s | 2.4)"
L["On Cooldown"] = "En reutilizacin"
L["On Taxi"] = "En taxi"
L["Only if on a different realm"] = "Solo si est en otro reino"
L["Only if Primary"] = "Solo si es primario"
L["Onyxia"] = "Onyxia"
L["Opaque"] = "Opaco"
L["Option Group"] = "Grupo de opcin"
L["Options could not be loaded, the addon is %s"] = "No se han podido cargar las opciones, el addon es %s"
L["Options will finish loading after combat ends."] = "Las opciones terminarn de cargarse una vez finalizado el combate."
L["Options will open after the login process has completed."] = "Las opciones se abrirn una vez finalizado el proceso de inicio de sesin."
L["Or Talent"] = "o talento"
L["Orbit"] = "Orbitar"
L["Orientation"] = "Orientacin"
L["Ossirian the Unscarred"] = "Osirio el Sinmarcas"
L["Other"] = "Otros"
L["Other Addons"] = "Otros addons"
L["Other Events"] = "Otros eventos"
L["Ouro"] = "Ouro"
L["Outline"] = "Contorno"
L["Over Energize"] = "Sobreenergizar"
L["Overhealing"] = "Sobre Curacin"
L["Overkill"] = "Muerte de Ms"
L["Overlay %s"] = "Superposicin %s"
L["Overlay Charged Combo Points"] = "Puntos de combo cargados de la superposicin"
L["Overlay Cost of Casts"] = "Superposicin del costo de lanzamiento"
L["Overlay Latency"] = "Latencia de superposicin"
L["Pad"] = "Relleno"
L["Pad Mode"] = "Modo de relleno"
L["Pad to"] = "Rellenar a"
L["Paragon Reputation"] = "Reputacin de dechado"
L["Paragon Reward Pending"] = "Recompensa de Dechado pendiente"
L["Parent Frame"] = "Marco de padre"
L["Parent Zone"] = "Zona de padre"
L["Parry"] = "Parar"
L["Parry (%)"] = "Parar (%)"
L["Parry Rating"] = "ndice de parar"
L["Party"] = "Grupo"
L["Party Kill"] = "Muerte de Grupo"
L["Patchwerk"] = "Remendejo"
L["Path of Ascension: Courage"] = "Camino de la ascensin: coraje"
L["Path of Ascension: Humility"] = "Camino de la ascensin: humilde"
L["Path of Ascension: Loyalty"] = "Camino de la ascensin: lealtad"
L["Path of Ascension: Wisdom"] = "Camino de la ascensin: sabidura"
L["Paused"] = "Pausado"
L["Periodic Spell"] = "Hechizo Peridico"
L["Personal Resource Display"] = "Visualizacin de recursos personales"
L["Pet"] = "Mascota"
L["Pet Behavior"] = "Comportamiento de mascota"
L["Pet Specialization"] = "Especializacin de mascota"
L["Pet Spell"] = "Habilidad de mascota"
L["Pets only"] = "Solamente mascotas"
L["Phase"] = "Fase"
L["Pixel Glow"] = "Resplandor de pxel"
L["Placement"] = "Ubicacin"
L["Placement %i"] = "Colocacin %i"
L["Placement Mode"] = "Modo de ubicacin"
L["Play"] = "Reproducir"
L["Player"] = "Jugador"
L["Player Character"] = "Personaje Jugador"
L["Player Class"] = "Clase del jugador"
L["Player Effective Level"] = "Nivel efectivo del jugador"
L["Player Experience"] = "Experiencia del jugador"
L["Player Faction"] = "Faccin del jugador"
L["Player Level"] = "Nivel del jugador"
L["Player Location ID(s)"] = "ID de ubicacin del jugador"
L["Player Money"] = "Dinero del jugador"
L["Player Name/Realm"] = "Nombre/reino del jugador"
L["Player Race"] = "Raza del jugador"
L["Player(s) Affected"] = "Jugador(es) Afectados"
L["Player(s) Not Affected"] = "Jugador(es) no Afectados"
L["Player/Unit Info"] = "Informacin del jugador/unidad"
L["Players and Pets"] = "Jugadores y mascotas"
L["Poison"] = "Veneno"
L["Power"] = "Poder"
L["Power (%)"] = "Poder  (%)"
L["Power Deficit"] = "Dficit de poder"
L["Power Type"] = "Tipo de Poder"
L["Precision"] = "Precisin"
L["Preset"] = "Preestablecido"
L["Primary Stats"] = "Estadsticas primarias"
L["Princess Huhuran"] = "Princesa Huhuran"
L["Print Profiling Results"] = "Imprimir resultados del perfilado"
L["Proc Glow"] = "Resplandor de prec"
L["Profiling already started."] = "Perfilado ya se inici."
L["Profiling automatically started."] = "Perfilado se inici automticamente"
L["Profiling not running."] = "Perfilado no ejecutndose"
L["Profiling started."] = "Perfilado iniciado."
L["Profiling started. It will end automatically in %d seconds"] = "Se inici el perfilado. Terminar automticamente en %d segundos"
L["Profiling still running, stop before trying to print."] = "Perfilado an ejecutndose, detenerse antes de intentar imprimir"
L["Profiling stopped."] = "Se detuvo el perfilado."
L["Progress"] = "Progreso"
L["Progress Source"] = "Fuente de progreso"
L["Progress Total"] = "Progreso total"
L["Progress Value"] = "Valor de progreso"
L["Pull"] = "Iniciar"
L["Pulse"] = "Pulso"
L["PvP Flagged"] = "Marcado JcJ"
L["PvP Talent selected"] = "Talento de JcJ seleccionado"
L["PvP Talent Selected"] = "Talento de JcJ seleccionado"
L["Quality Id"] = "ID de calidad"
L["Quantity"] = "Cantidad"
L["Quantity earned this week"] = "Cantidad ganada esta semana"
L["Quest Party"] = "Grupo de misin"
L["Queued Action"] = "Accin en cola"
L["Radius"] = "Radio"
L["Ragnaros"] = "Ragnaros"
L["Raid"] = "Banda"
L["Raid (Heroic)"] = "Banda (heroico)"
L["Raid (Mythic)"] = "Banda (mtico)"
L["Raid (Normal)"] = "Banda (normal)"
L["Raid (Timewalking)"] = "Banda (paseo temporal)"
L["Raid Mark"] = "Marca de banda"
L["Raid Mark Icon"] = "Icono de marca de banda"
L["Raid Role"] = "Rol de banda"
L["Raid Warning"] = "Alerta de Banda"
L["Raids"] = "Bandas"
L["Range"] = "Rango"
L["Range Check"] = "Comprobacin de distancia"
L["Ranged"] = "A distancia"
L["Rank"] = "Rango"
L["Rare"] = "Raro"
L["Rare Elite"] = "Raro lite"
L["Rated Arena"] = "Arena puntuada"
L["Rated Battleground"] = "Campo de batalla puntuado"
L["Raw Threat Percent"] = "Porcentaje de amenaza en bruto"
L["Razorgore the Untamed"] = "Sangrevaja el Indomable"
L["Ready Check"] = "Comprobacin de preparados"
L["Reagent Quality"] = "Calidad de componente"
L["Reagent Quality Texture"] = "Textura de calidad de componente"
L["Realm"] = "Reino"
L["Realm Name"] = "Nombre de reino"
L["Realm of Caster's Target"] = "Reino del objetivo del lanzador"
L["Reborn Council"] = "Consejo renacido"
L["Receiving %s Bytes"] = "Recibiendo %s bytes"
L["Receiving display information"] = "Recibiendo informacin de aura de %s..."
L["Reflect"] = "Reflejar"
L["Region type %s not supported"] = "No se admite el tipo de regin %s"
L["Relative"] = "Relativo"
L["Relative X-Offset"] = "Desplazamiento X relativo"
L["Relative Y-Offset"] = "Desplazamiento Y relativo"
L["Remaining Duration"] = "Duracin restante"
L["Remaining Time"] = "Tiempo Restante"
L["Remove Obsolete Auras"] = "Eliminar auras obsoletas"
L["Renown Level"] = "Nivel de renombre"
L["Renown Max Level"] = "Nivel mximo de renombre"
L["Renown Reputation"] = "Reputacin de renombre"
L["Repair"] = "Reparar"
L["Repeat"] = "Repetir"
L["Report Summary"] = "Resumen del informe"
L["Reputation"] = "Reputacin"
L["Reputation (%)"] = "Reputacin (%)"
L["Requested display does not exist"] = "El aura requerida no existe"
L["Requested display not authorized"] = "El aura requerida no est autorizada"
L["Requesting display information from %s ..."] = "Solicitando informacin de visualizacin de %s..."
L["Require Valid Target"] = "Requiere Objetivo Vlido"
L["Requires syncing the specialization via LibSpecialization."] = "Requiere sincronizar la especializacin mediante LibSpecialization."
L["Resilience (%)"] = "Temple (%)"
L["Resilience Rating"] = "ndice de temple"
L["Resist"] = "Resistir"
L["Resistances"] = "Resistencias"
L["Resisted"] = "Resistido"
L["Rested"] = "Descansado"
L["Rested Experience"] = "Experiencia descansada"
L["Rested Experience (%)"] = "Experiencia descansada (%)"
L["Resting"] = "Descansado"
L["Resurrect"] = "Resucitar"
L["Resurrect Pending"] = "Resurreccin pendiente"
L["Right"] = "Derecha"
L["Right to Left"] = "De Derecha a Izquierda"
L["Right, then Centered Vertical"] = "Derecha, luego centrado vertical"
L["Right, then Down"] = "Derecha, luego abajo"
L["Right, then Up"] = "Derecha, luego arriba"
L["Role"] = "Rol"
L["Rollback snapshot is complete. Thank you for your patience!"] = "La instantnea de reversin est completa. Gracias por tu paciencia!"
L["Rotate Animation"] = "Rotar animacin"
L["Rotate Left"] = "Rotar a la Izquierda"
L["Rotate Right"] = "Rotar a la Derecha"
L["Rotation"] = "Rotacin"
L["Round"] = "Redondo"
L["Round Mode"] = "Modo redondo"
L["Ruins of Ahn'Qiraj"] = "Ruinas de Ahn'Qiraj"
L["Run Custom Code"] = "Ejecutar cdigo personalizado"
L["Run Speed (%)"] = "Velocidad de movimiento (%)"
L["Rune"] = "Runa"
L["Rune #1"] = "Runa #1"
L["Rune #2"] = "Runa #2"
L["Rune #3"] = "Runa #3"
L["Rune #4"] = "Runa #4"
L["Rune #5"] = "Runa #5"
L["Rune #6"] = "Runa #6"
L["Rune Count"] = "Contador de runas"
L["Rune Count - Blood"] = "Recuento de Runa sangrienta"
L["Rune Count - Frost"] = "Recuento de Runa de Escarcha"
L["Rune Count - Unholy"] = "Recuento de Runa profana"
L["Sapphiron"] = "Sapphiron"
L["Say"] = "Decir"
L["Scale"] = "Escala"
L["Scarlet Enclave"] = "Enclave Escarlata"
L["Scenario"] = "Escenario"
L["Scenario (Heroic)"] = "Escenario (heroico)"
L["Scenario (Normal)"] = "Escenario (normal)"
L["Screen"] = "Pantalla"
L["Screen/Parent Group"] = "Grupo de pantalla/padre"
L["Season of Discovery"] = "Temporada de descubrimiento"
L["Second"] = "Segundo"
L["Second Value of Tooltip Text"] = "Segundo valor del texto del tooltip"
L["Secondary Stats"] = "Estadsticas secundarias"
L["Seconds"] = "Segundos"
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "Marco seguro detectado. Encuentra ms informacin: https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Select Frame"] = "Seleccionar marco"
L["Select the type of timer to filter"] = "Selecciona el tipo de temporizador para filtrar"
L["Selection Mode"] = "Modo de seleccin"
L["Separator"] = "Separador"
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "Los ID de conjuntos se pueden encontrar en sitios web como wowhead.com/cata/mx/item-sets"
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Los ID de conjuntos se pueden encontrar en sitios web como wowhead.com/classic/mx/item-sets"
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "Los ID de conjuntos se pueden encontrar en sitios web como wowhead.com/mx/item-sets"
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Los ID de conjuntos se pueden encontrar en sitios web como wowhead.com/mop-classic/mx/item-sets"
L["Shadow Resistance"] = "Resistencia a las Sombras"
L["Shadowlands"] = "Shadowlands"
L["Shake"] = "Sacudida"
L["Shazzrah"] = "Shazzrah"
L["Shift-Click to resume addon execution."] = "Mays clic para reanudar la ejecucin del addon."
L["Show"] = "Mostrar"
L["Show CD of Charge"] = "Mostrar reutilizacin de carga"
L["Show charged duration for empowered casts"] = "Mostrar duracin cargada para lanzamientos empoderados"
L["Show GCD"] = "Mostrar reutilizacin global"
L["Show Global Cooldown"] = "Mostrar reutilizacin global"
L["Show Incoming Heal"] = "Mostrar sanacin entrante"
L["Show Loss of Control"] = "Mostrar prdida de control"
L["Show On"] = "Mostrar en"
L["Show Rested Overlay"] = "Mostrar superposicin descansada"
L["Shrink"] = "Encoger"
L["Silithid Royalty"] = "Realeza siltida"
L["Silver"] = "Plata"
L["Simple"] = "Simple"
L["Since Active"] = "Desde activo"
L["Since Apply"] = "Desde aplicar"
L["Since Apply/Refresh"] = "Desde aplicar/actualizar"
L["Since Charge Gain"] = "Desde ganancia de carga"
L["Since Charge Lost"] = "Desde que se perdi la carga"
L["Since Ready"] = "Desde listo"
L["Since Stack Gain"] = "Desde ganancia de acumulacin"
L["Since Stack Lost"] = "Desde que se perdi la acumulacin"
L["Size & Position"] = "Tamao y posicin"
L["Skyriding"] = "Cielonutica"
L["Slide Animation"] = "Animacin deslizante"
L["Slide from Bottom"] = "Arrastrar Desde Abajo"
L["Slide from Left"] = "Arrastrar Desde la Izquierda"
L["Slide from Right"] = "Arrastrar Desde la Derecha"
L["Slide from Top"] = "Arrastrar Desde Arriba"
L["Slide to Bottom"] = "Arrastrar Hacia Abajo"
L["Slide to Left"] = "Arrastrar Hacia la Izquierda"
L["Slide to Right"] = "Arrastrar Hacia la Derecha"
L["Slide to Top"] = "Arrastrar Hacia Arriba"
L["Slider"] = "Control deslizante"
L["Small"] = "Pequeo"
L["Smart Group"] = "Grupo inteligente"
L["Soft Enemy"] = "Enemigo flexible"
L["Soft Friend"] = "Amigo flexible"
L["Solistrasza"] = "Solistrasza"
L["Sound"] = "Sonido"
L["Sound by Kit ID"] = "Sonido por ID de kit"
L["Source"] = "Fuente"
L["Source Affiliation"] = "Afiliacin de fuente"
L["Source GUID"] = "GUID de la fuente"
L["Source Info"] = "Info de la fuente"
L["Source Name"] = "Nombre de Origen"
L["Source NPC Id"] = "ID de PNJ de la fuente"
L["Source Object Type"] = "Tipo de objeto de la fuente"
L["Source Raid Mark"] = "Marca de banda de la fuente"
L["Source Reaction"] = "Reaccin de la fuente"
L["Source Unit"] = "Unidad Origen"
L["Source Unit Name/Realm"] = "Nombre/reino de unidad de la fuente"
L["Source unit's raid mark index"] = "ndice de marca de banda de unidad de la fuente"
L["Source unit's raid mark texture"] = "Textura de marca de banda de unidad de la fuente"
L["Space"] = "Espacio"
L["Spacing"] = "Espaciado"
L["Spark"] = "Chispa"
L["Spec Position"] = "Posicin de especializacin"
L["Spec Role"] = "Rol de especializacin"
L["Specialization"] = "Especializacin"
L["Specific Currency"] = "Moneda especfica"
L["Specific Type"] = "Tipo especfico"
L["Specific Unit"] = "Unidad Especfica"
L["Spell"] = "Hechizo"
L["Spell (Building)"] = "Hechizo (en curso)"
L["Spell Activation Overlay Glow"] = "Resplandor de superposicin de activacin de hechizos"
L["Spell Cast Succeeded"] = "Lanzamiento del hechizo exitoso"
L["Spell Cost"] = "Costo de hechizo"
L["Spell Count"] = "Contador de hechizo"
L["Spell ID"] = "ID de hechizo"
L["Spell Id"] = "ID de hechizo"
L["Spell ID:"] = "ID de hechizo:"
L["Spell IDs:"] = "IDs de hechizo:"
L["Spell in Range"] = "Hechizo en rango"
L["Spell Known"] = "Hechizo conocido"
L["Spell Name"] = "Nombre del Hechizo"
L["Spell Peneration Percent"] = "Porcentaje de penetracin de hechizo"
L["Spell Power"] = "Poder con hechizos"
L["Spell School"] = "Escuela de hechizo"
L["Spell Usable"] = "Hechizo utilizable"
L["Spellname"] = "Nombre de hechizo"
L["Spike"] = "Pico"
L["Spin"] = "Girar"
L["Spiral"] = "Espiral"
L["Spiral In And Out"] = "Espiral de Dentro a Fuera"
L["Spirit"] = "Espritu"
L["Stack Count"] = "Recuento de acumulaciones"
L["Stack trace:"] = "Traza de pila:"
L["Stacks"] = "Acumulaciones"
L["Stacks Function"] = "Funcin de acumulaciones"
L["Stacks Function (fallback state)"] = "Funcin de acumulaciones (estado reserva)"
L["Stage"] = "Etapa"
L["Stage Counter"] = "Contador de etapa"
L["Stagger"] = "Escalonar"
L["Stagger (%)"] = "Tambalear (%)"
L["Stagger against Target (%)"] = "Tambalearse contra el objetivo (%)"
L["Stagger Scale"] = "Escala escalonada"
L["Stamina"] = "Aguante"
L["Stance/Form/Aura"] = "Impostura/Forma/Aura"
L["Standing"] = "De pie"
L["Star Shake"] = "Sacudida de estrellas"
L["Start Animation"] = "Iniciar animacin"
L["Start Now"] = "Iniciar ahora"
L["Start Profiling"] = "Iniciar el perfilado"
L["Status"] = "Estado"
L["Status Bar"] = "Barra de estado"
L["Stolen"] = "Robado"
L["Stop"] = "Detener"
L["Stop Motion"] = "Stop motion"
L["Story Raid"] = "Banda de historia"
L["Strength"] = "Fuerza"
L["String"] = "Cadena"
L["Subevent Info"] = "Info de subevento"
L["Subtract Cast"] = "Sustraer lanzamiento"
L["Subtract Channel"] = "Sustraer canal"
L["Subtract GCD"] = "Sustraer reutilizacin global"
L["Subzone Name"] = "Nombre de subzona"
L["Success"] = "xito"
L["Sulfuron Harbinger"] = "Presagista de Sulfuron"
L["Summon"] = "Invocar"
L["Summon Pending"] = "Invocacin pendiente"
L["Sun"] = "Sol"
L["Supports multiple entries, separated by commas"] = "Admite mltiples entradas, separadas por comas"
L[ [=[Supports multiple entries, separated by commas
]=] ] = "Admite mltiples entradas, separadas por comas"
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "Admite mltiples entradas, separadas por comas. Escapa ',' con . Prefija con '-' para negacin."
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Admite mltiples entradas, separadas por comas. Escapa con . Prefjalas con '-' para negacin."
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "Admite mltiples entradas, separadas por comas. Prefija con '-' para negacin."
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = "Admite mltiples entradas, separadas por comas. Para incluir identificadores de zonas secundarias, prefija con 'c', por ejemplo, 'c2022'. Los identificadores de zonas grupales deben estar prefijados con 'g', por ejemplo, 'g277'. Admite identificadores de reas de https://wago.tools/db2/AreaTable prefijados con 'a'. Admite identificadores de estancias prefijados con 'i'. Las entradas pueden prefijarse con '-' para negar."
L["Swing"] = "Golpe"
L["Swing Timer"] = "Temporizador de Golpes"
L["Swipe"] = "Berrido"
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = "Sintaxis /wa caracterstica <alternar|activado|activar|desactivar|desactivado> <caracterstica>"
L["System"] = "Sistema"
L["Systems"] = "Sistemas"
L["Tab "] = "Pestaa"
L["Talent"] = "Talento"
L["Talent |cFFFF0000Not|r Known"] = "Talento |cFFFF0000desconocido|r"
L["Talent |cFFFF0000Not|r Selected"] = "Talento |cFFFF0000no|r seleccionado"
L["Talent Known"] = "Talento conocido"
L["Talent Selected"] = "Talento seleccionado"
L["Talent selected"] = "Talento seleccionado"
L["Talent Specialization"] = "Especializacin de Talentos"
L["Tanking And Highest"] = "Tanqueando y el ms alto"
L["Tanking But Not Highest"] = "Tanqueando pero no el mas alto"
L["Target"] = "Objetivo"
L["Targeted"] = "Objetivo"
L["Tertiary Stats"] = "Estadsticas terciarias"
L["Test if bar is enabled in BigWigs settings"] = "Prueba si la barra est activada en la configuracin de BigWigs"
L["Test if bar is enabled in Boss Mod addon settings"] = "Prueba si la barra est activada en la configuracin del addon del mdulo de jefe"
L["Test if bar is enabled in DBM settings"] = "Prueba si la barra est activada en la configuracin de DBM"
L["Text"] = "Texto"
L["Text To Speech"] = "Texto a voz"
L["Text-to-speech"] = "Texto a voz"
L["Texture"] = "Textura"
L["Texture Function"] = "Funcin de textura"
L["Texture Function (fallback state)"] = "Funcin de textura (estado de reserva)"
L["Texture Picker"] = "Selector de texturas"
L["Texture Rotation"] = "Rotacin de textura"
L["Thaddius"] = "Thaddius"
L["The aura has overwritten the global '%s', this might affect other auras."] = "La aura ha sobrescrito el '%s' global, esto podra afectar otras auras."
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "El aura intent sobrescribir la variable global aura_env, lo cual no est permitido."
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "El nivel efectivo difiere del nivel p.ej. mazmorras de paseo en el tiempo"
L["The Four Horsemen"] = "Los cuatro jinetes"
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "El valor 'ID' se puede encontrar en las opciones de BigWigs de un hechizo especfico."
L["The Prophet Skeram"] = "El profeta Skeram"
L["The total quantity a warband character can transfer after paying the transfer cost"] = "La cantidad total que un personaje de tropa puede transferir despus de pagar el costo de transferencia."
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "La cantidad total despus de transferir todo a tu personaje actual y pagar el costo de transferencia"
L["The War Within"] = "The War Within"
L["There are %i updates to your auras ready to be installed!"] = "Hay %i actualizaciones para tus auras listas para ser instaladas!"
L["Thick Outline"] = "Contorno grueso"
L["Thickness"] = "Espesor"
L["Third"] = "Tercero"
L["Third Value of Tooltip Text"] = "Tercero valor del texto del tooltip"
L["This aura calls GetData a lot, which is a slow function."] = "Esta aura llama mucho a GetData, que es una funcin lenta."
L["This aura has caused a Lua error."] = "Esta aura ha provocado un error de Lua."
L["This aura is saving %s KB of data"] = "Esta aura est guardando %s KB de datos."
L["This aura plays a sound via a condition."] = "Este aura reproduce un sonido a travs de una condicin."
L["This aura plays a sound via an action."] = "Este aura reproduce un sonido a travs de una accin."
L["This aura plays a Text To Speech via a condition."] = "Esta aura reproduce un texto a voz a travs de una condicin."
L["This aura plays a Text To Speech via an action."] = "Esta aura reproduce un texto a voz a travs de una accin."
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "Este filtro ha sido trasladado al disparador de ubicacin. Cambia tu aura para utilizar el nuevo disparador de ubicacin o nete al servidor de Discord de WeakAuras para obtener ayuda."
L["Threat Percent"] = "Porcentaje de amenaza"
L["Threat Situation"] = "Situacin de la Amenaza"
L["Threat Value"] = "Valor de amenaza"
L["Tick"] = "Tic"
L["Time"] = "Tiempo"
L["Time Format"] = "Formato de tiempo"
L["Time in GCDs"] = "Tiempo de reutilizacin global"
L["Time since initial application"] = "Tiempo desde la aplicacin inicial"
L["Time since last refresh"] = "Tiempo desde la ltima actualizacin"
L["Time since stack gain"] = "Tiempo desde gana de acumulacin"
L["Time since stack lost"] = "Tiempo desde que se perdi la acumulacin"
L["Timed"] = "Temporizado"
L["Timed Progress"] = "Progreso temporizado"
L["Timer"] = "Temporizador"
L["Timer Id"] = "ID de temporizador"
L["Toggle"] = "Mostrar"
L["Toggle List"] = "Mostar lista"
L["Toggle Options Window"] = "Mostrar ventana de opciones"
L["Toggle Performance Profiling Window"] = "Mostrar la ventana de perfiles de rendimiento"
L["Tooltip"] = "Descripcin emergente"
L["Tooltip 1"] = "Tooltip 1"
L["Tooltip 2"] = "Tooltip 2"
L["Tooltip 3"] = "Tooltip 3"
L["Tooltip Value 1"] = "Valor de tooltip 1"
L["Tooltip Value 2"] = "Valor de tooltip 2"
L["Tooltip Value 3"] = "Valor de tooltip 3"
L["Tooltip Value 4"] = "Valor de tooltip 4"
L["Top"] = "Superior"
L["Top Left"] = "Superior izquierda"
L["Top Right"] = "Superior derecha"
L["Top to Bottom"] = "De Arriba a Abajo"
L["Torghast"] = "Torghast"
L["Total Duration"] = "Duracin total"
L["Total Earned in this Season"] = "Total ganado en esta temporada"
L["Total Essence"] = "Esencia total"
L["Total Experience"] = "Experiencia total"
L["Total Match Count"] = "Recuento de coincidencia en total"
L["Total Reputation"] = "Reputacin total"
L["Total Stacks"] = "Acumulaciones totales"
L["Total stacks over all matches"] = "Acumulaciones totales sobre todas las coincidencias"
L["Total Stages"] = "Etapas totales"
L["Total Unit Count"] = "Recuento de unidad total"
L["Total Units"] = "Unidades totales"
L["Totem"] = "Ttem"
L["Totem #%i"] = "Ttem #%i"
L["Totem Icon"] = "Icono de ttem"
L["Totem Name"] = "Nombre del Ttem"
L["Totem Name Pattern Match"] = "Coincidencia de patrn de nombre de ttem"
L["Totem Number"] = "Nmero de ttem"
L["Track Cooldowns"] = "Rastrear reutilizaciones"
L["Tracking Charge %i"] = "Carga de seguimiento %i"
L["Tracking Charge CDs"] = "Seguimiento de reutilizacin de carga"
L["Tracking Only Cooldown"] = "Seguimiento de sola reutilizacin"
L["Transmission error"] = "Error de transmisin"
L["Trigger"] = "Activador"
L["Trigger %i"] = "Activador %i"
L["Trigger %s"] = "Activador %s"
L["Trigger 1"] = "Activador 1"
L["Trigger State Updater (Advanced)"] = "Actualizacin del estado del activador (avanzada)"
L["Trigger Update"] = "Actualizacin del activador"
L["Trigger:"] = "Activador:"
L["Trivial (Low Level)"] = "Trivial (nivel bajo)"
L["True"] = "Verdadero"
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "Intentando reparar condiciones rotas en %s probablemente causadas por un error de WeakAuras."
L["Twin Emperors"] = "Emperadores gemelos"
L["Type"] = "Tipo"
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "No se puede modernizar el aura '%s'. Probablemente se deba a datos corruptos o una migracin incorrecta. Por favor, informe de esto al equipo de WeakAuras."
L["Unaffected"] = "Inafectado"
L["Undefined"] = "No Definido"
L["Unholy"] = "Profano"
L["Unholy Rune #1"] = "Runa profana #1"
L["Unholy Rune #2"] = "Runa profana #2"
L["Unit"] = "Unidad"
L["Unit Characteristics"] = "Caractersticas de la unidad"
L["Unit Destroyed"] = "Unidad Destruida"
L["Unit Died"] = "Unit Muerta"
L["Unit Dissipates"] = "Disipaciones de unidad"
L["Unit Frame"] = "Marco de unidad"
L["Unit Frames"] = "Marcos de unidad"
L["Unit is Unit"] = "Unidad es unidad"
L["Unit Name"] = "Nombre de unidad"
L["Unit Name/Realm"] = "Nombre/reino de unidad"
L["Units Affected"] = "Unidades afectadas"
L["Units of affected Players in a table format"] = "Unidades de jugadores afectados en formato de tabla"
L["Units of unaffected Players in a table format"] = "Unidades de jugadores no afectados en formato de tabla."
L["Unknown action %q"] = "Accin desconocida %q"
L["Unknown feature %q"] = "Caracterstica desconocida %q"
L["unknown location"] = "zona desconocida"
L["Unlimited"] = "Ilimitado"
L["Untrigger %s"] = "Desactivador %s"
L["Up"] = "Arriba"
L["Up, then Centered Horizontal"] = "Arriba, luego centrado horizontal"
L["Up, then Left"] = "Arriba, luego izquierda"
L["Up, then Right"] = "Arriba, luego derecha"
L["Update Position"] = "Actualizar posicin"
L["Usage:"] = "Uso:"
L["Use /wa minimap to show the minimap icon again."] = "Utilizar /wa minimap para mostrar el icono del minimapa de nuevo"
L["Use Custom Color"] = "Utilizar color personalizado"
L["Use Legacy floor rounding"] = "Utiliza el redondeo de suelo legado"
L["Use Texture"] = "Utilizar textura"
L["Use Watched Faction"] = "Utilizar faccin vigilada"
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "Utiliza UnitInRange() para comprobar si est dentro del rango. Coincide con el comportamiento predeterminado de los marcos de banda fuera de alcance, que oscila entre 25 y 40 metros dependiendo de tu clase y especializacin."
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = [=[El uso de WeakAuras.clones est en desuso. Utilice WeakAuras.GetRegion(id, cloneId) en su lugar.
]=]
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "El uso de WeakAuras.regions est en desuso. Utilice WeakAuras.GetRegion(id) en su lugar."
L["Vaelastrasz the Corrupt"] = "Vaelastrasz el Corrupto"
L["Versatility (%)"] = "Versatilidad (%)"
L["Versatility Rating"] = "ndice de versatilidad"
L["Vertical"] = "Vertical"
L["Viscidus"] = "Viscidus"
L["Visibility"] = "Visibilidad"
L["Visions of N'Zoth"] = "Visiones de N'Zoth"
L["Warband Quantity Total"] = "Cantidad total de tropa"
L["Warband Transfer Percentage"] = "Porcentaje de transferencia de tropa"
L["Warband Transferred Quantity"] = "Cantidad transferida de tropa"
L["Warfront (Heroic)"] = "Frente de guerra (heroico)"
L["Warfront (Normal)"] = "Frente de guerra (normal)"
L["Warlords of Draenor"] = "Warlords of Draenor"
L["Warning"] = "Aviso"
L["Warning for unknown aura:"] = "Aviso para aura desconocida:"
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "Aviso: Anclar en el aura '%s' es imposible, debido a un ciclo de anclaje"
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = [=[Aviso: las auras de escaneo completo que verifican tanto el nombre como la identificacin del hechizo no se pueden convertir.
]=]
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "Aviso: la informacin del nombre ahora est disponible a travs de %affected, %unaffected. Nmero de miembros del grupo afectados a travs de %unitCount. Algunas opciones se comportan de manera diferente ahora. Esto no se ajusta automticamente."
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = [=[Aviso: Los valores de tooltip ahora estn disponibles a travs de %tooltip1, %tooltip2, %tooltip3 en lugar de %s. Esto no se ajusta automticamente.
]=]
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras incorporado (63:42 | 3:07 | 10 | 2.4)"
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras ha detectado configuraciones vacas. Si esto es inesperado, solicita asistencia en https://discord.gg/weakauras."
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = "WeakAuras ha detectado que ha sido degradado. Es posible que tus auras guardadas ya no funcionen correctamente. Te gustaras ejecutar la herramienta de reparacin |cffff0000EXPERIMENTAL|r? Esto sobrescribir cualquier cambio que haya realizado desde la ltima actualizacin de la base de datos. ltima actualizacin: %s |cffff0000Debes HACER UNA COPIA DE SEGURIDAD de tu carpeta WTF ANTES de presionar este botn.|r"
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras est creando una instantnea de reversin de tus auras. Esta instantnea te permitir volver al estado actual de tus auras si algo sale mal. Este proceso puede hacer que tu tasa de fotogramas disminuya hasta que se complete."
L["WeakAuras Profiling"] = "Perfilado de WeakAuras"
L["WeakAuras Profiling Report"] = "Informe de perfilado de WeakAuras"
L["WeakAuras Version: %s"] = "WeakAuras Versin: %s"
L["Weapon"] = "Arma"
L["Weapon Enchant"] = "Encantamiento de arma"
L["Weapon Enchant / Fishing Lure"] = "Encantamiento de arma/Cebo de pesca"
L["Whisper"] = "Susurro"
L["Width"] = "Anchura"
L["Wobble"] = "Temblar"
L["World Boss"] = "Jefe del mundo"
L["World Bosses"] = "Jefes del mundo"
L["Wrap"] = "Envolver"
L["Wrath of the Lich King"] = "Wrath of the Lich King"
L["Writing to the WeakAuras table is not allowed."] = "No se permite escribir en la tabla WeakAuras."
L["X-Offset"] = "Desplazamiento X"
L["Yell"] = "Grito"
L["Y-Offset"] = "Desplazamiento Y"
L["You have new auras ready to be installed!"] = "Tienes nuevas auras listas para instalar!"
L["Your next encounter will automatically be profiled."] = "Tu prximo encuentro se perfilar automticamente."
L["Your next instance of combat will automatically be profiled."] = "Tu prxima instancia de combate se perfilar automticamente."
L["Your scheduled automatic profile has been cancelled."] = "Tu perfil automtico programado ha sido cancelado."
L["Your threat as a percentage of the tank's current threat."] = "Tu amenaza como porcentaje de la amenaza actual del tanque."
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "Tu amenaza como porcentaje de la cantidad requerida para tomar agro. Tomar de agro a 100."
L["Your total threat on the mob."] = "Tu amenaza total por el monstruo"
L["Zone Group ID"] = "ID de grupo de zona"
L["Zone ID"] = "ID de zona"
L["Zone Name"] = "Nombre de zona"
L["Zoom"] = "Zoom"
L["Zoom Animation"] = "Animacin de zoom"
L["Zul'Gurub"] = "Zul'Gurub"



-- ========================================
-- File: WeakAuras/Locales/frFR.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "frFR" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = "Filtres supports : 'Pseudo', 'Pseudo-Serveur', '-Serveur'. Supporte les entres multiples, spares par des virgules; utiliser \\ pour \"chapper\"  -."
L["%s Overlay Color"] = "%s couleur de la superposition"
L["* Suffix"] = "* Suffixe"
L["/wa help - Show this message"] = "/wa help - Affiche ce message"
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - Afficher l'icne sur la mini-carte"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - Affiche les rsultats du profilage le plus rcent"
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart - Dmarre le profilage. Vous pouvez inclure une dure en secondes aprs laquelle le profilage s'arrte automatiquement. Pour tablir le profil du prochain combat / contretemps, passez un argument \"combat\" ou \"rencontre\"."
L["/wa pstop - Finish profiling"] = "/wa pstop - Arrter le profilage"
L["/wa repair - Repair tool"] = "/wa repair - Utilitaire de rparation"
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55fClic-Gauche|r pour dclencher l'affichage de la fentre principale."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "Clique du milieu pour activer ou dsactiver l'icne de la mini-carte."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55fClic-Droit|r pour basculer la fentre de profilage des performances."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fMaj-Clic|r Pour suspendre l'excution de l'addon."
L["|cffff0000deprecated|r"] = "|cffff0000obsolte|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "ID du bonus de l'objet |cFFFF0000non|r quip"
L["|cFFFF0000Not|r Item Equipped"] = "Objet |cFFFF0000non|r quip"
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000Not|r Nom du joueur / serveur"
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000Sort|r non connu"
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = "|cFFFF0000La prise en charge des vnements COMBAT_LOG_EVENT_UNFILTERED non filtrs est obsolte|r Les vnements COMBAT_LOG_EVENT_UNFILTERED sans filtre sont dsactivs, car ils nuisent fortement aux performances. Plus d'informations: https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00Options supplmentaires :|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00Options supplmentaires :|r aucun"
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = " |cff00ff00Joueur|r, |cff00ff00Cible|r, |cff00ff00Focalisation|r et |cff00ff00Familier|r correspondent directement  ces identifiants dunit spcifiques.  |cff00ff00Unit spcifique|r vous permet dindiquer un identifiant dunit valide  surveiller. |cffff0000Remarque|r : Le jeu ne dclenche pas dvnements pour tous les identifiants dunit valides, ce qui rend certains non traables par ce dclencheur.  |cffffff00Groupe|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arne|r et |cffffff00Barre de vie|r peuvent correspondre  plusieurs identifiants dunit associs.  |cffffff00Groupe intelligent|r sajuste en fonction de votre type de groupe actuel : il correspond uniquement au \"joueur\" en solo, aux units du \"groupe\" (y compris le joueur) en groupe, ou aux units du \"raid\" en raid. |cffffff00*|r Les paramtres dunit en jaune creront des clones pour chaque unit correspondante tant que ce dclencheur fournit des informations dynamiques  laura."
L["1. Profession 1. Accessory"] = "1. Profession 1. Accessoire"
L["1. Profession 2. Accessory"] = "1. Profession 2. Accessoire"
L["1. Professsion Tool"] = "1. Outil de profession"
L["10 Man Raid"] = "Raid 10 Joueurs"
L["10 Player Raid"] = "Raid  10 Joueurs"
L["10 Player Raid (Heroic)"] = "Raid  10 Joueurs (Hroque)"
L["10 Player Raid (Normal)"] = "Raid  10 Joueurs (Normal)"
L["2. Profession 1. Accessory"] = "2. Profession 1. Accessoire"
--[[Translation missing --]]
L["2. Profession 2. Accessory"] = "2. Profession 2. Accessory"
--[[Translation missing --]]
L["2. Professsion Tool"] = "2. Professsion Tool"
L["20 Man Raid"] = "Raid 20 Joueurs"
L["20 Player Raid"] = "Raid  20 joueurs"
L["25 Man Raid"] = "Raid 25 Joueurs"
L["25 Player Raid"] = "Raid  25 joueurs"
L["25 Player Raid (Heroic)"] = "Raid 25 Joueurs (Hroque)"
L["25 Player Raid (Normal)"] = "Raid 25 Joueurs (Normal)"
L["40 Man Raid"] = "Raid 40 Personnes"
L["40 Player Raid"] = "Raid 40 Joueurs"
L["5 Man Dungeon"] = "Donjon 5 joueurs"
--[[Translation missing --]]
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=]
--[[Translation missing --]]
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."
L["Abbreviate"] = "Abrger"
L["AbbreviateLargeNumbers (Blizzard)"] = "AbrgerGrandsNombres (Blizzard)"
L["AbbreviateNumbers (Blizzard)"] = "AbrgerNombres (Blizzard)"
L["Absorb"] = "Absorbe"
--[[Translation missing --]]
L["Absorb and Healing"] = "Absorb and Healing"
--[[Translation missing --]]
L["Absorb Heal Overlay"] = "Absorb Heal Overlay"
--[[Translation missing --]]
L["Absorb Overlay"] = "Absorb Overlay"
L["Absorbed"] = "Absorb"
L["Action Button Glow"] = "Bouton d'action brillant"
L["Actions"] = "Actions"
L["Active"] = [=[Actif
]=]
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Addon de boss actif: |cFFffcc00BigWigs|r Remarque: ce dclencheur utilisera BigWigs ou DBM, dans cet ordre si les deux sont installs."
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Addon de boss actif: |cFFffcc00DBM|r Remarque: ce dclencheur utilisera BigWigs ou DBM, dans cet ordre si les deux sont installs."
L["Add"] = "Ajouter"
L["Add Missing Auras"] = "Ajouter les auras manquantes"
--[[Translation missing --]]
L["Advanced Caster's Target Check"] = "Advanced Caster's Target Check"
L["Affected"] = "Affect"
L["Affected Unit Count"] = "Nombre d'units Affectes"
--[[Translation missing --]]
L["Afk"] = "Afk"
L["Aggro"] = "Aggro"
L["Agility"] = "Agilit"
L["Ahn'Qiraj"] = "Ahn'Qiraj"
L["Alert Type"] = "Type d'alerte"
L["Alive"] = "En vie"
L["All"] = "Tous"
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "Tous les lments enfants de cette aura ne seront galement pas chargs, afin de minimiser le risque de corruption supplmentaire."
L["All States table contains a non table at key: '%s'."] = "La table All States contient une valeur non-table  la cl : %s."
L["All Triggers"] = "Tous les dclencheurs"
L["Alliance"] = "Alliance"
L["Allow partial matches"] = "Permettre les correspondances partielles"
L["Alpha"] = "Opacit"
L["Alternate Power"] = "Puissance alternative"
L["Always"] = "Toujours"
L["Always active trigger"] = "Dclencheur toujours actif"
L["Always include realm"] = "Toujours inclure le royaume"
L["Always True"] = "Toujours Vrai"
L["Amount"] = "Quantit"
L["Anchoring"] = "Ancrage"
L["And Talent"] = "Et talent"
L["Angle and Radius"] = "Angle et rayon"
L["Animations"] = "Animations"
L["Anticlockwise"] = "Sens anti-horaire"
L["Anub'Rekhan"] = "Anub'Rekhan"
L["Any"] = "N'importe lequel"
L["Any Triggers"] = "Au moins un dclencheur"
L["AOE"] = "AOE"
L["Arcane Resistance"] = "Rsistance aux arcanes"
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = "tes-vous sr de vouloir excuter l'outil de rparation |cffff0000exprimental|r ? Cela crasera toutes les modifications que vous avez apportes depuis la dernire mise  niveau de la base de donnes. Dernire mise  jour : %s"
L["Arena"] = "Arne"
L["Armor (%)"] = "Armure (%)"
L["Armor against Target (%)"] = "Armure contre Cible (%)"
L["Armor Rating"] = "Categorie d'armure"
L["Array"] = "Tableau"
L["Ascending"] = "Croissant"
L["Assigned Role"] = "Rle assign"
L["Assigned Role Icon"] = "Icne de rle assign"
L["Assist"] = "Assister"
--[[Translation missing --]]
L["Assisted Combat Next Cast"] = "Assisted Combat Next Cast"
L["At Least One Enemy"] = "Au moins un ennemi"
L["At missing Value"] = " la valeur manquante"
L["At Percent"] = " pourcentage"
L["At Value"] = " la valeur"
--[[Translation missing --]]
L["At War"] = "At War"
L["Attach to End"] = "Attacher  la Fin"
L["Attach to End, backwards"] = "Attacher  la fin, en arrire"
L["Attach to Point"] = "Attacher au point"
L["Attach to Start"] = "Attacher au Dbut"
L["Attack Power"] = "Puissance d'attaque"
L["Attackable"] = "Attaquable"
L["Attackable Target"] = "Cible attaquable"
L["Aura"] = "Aura"
L["Aura '%s': %s"] = "Aura '%s' : %s"
L["Aura Applied"] = "Aura applique"
L["Aura Applied Dose"] = "Dose de l'aura applique"
L["Aura Broken"] = "Aura Casse"
L["Aura Broken Spell"] = "Sort de l'Aura Casse"
L["Aura is using deprecated SetDurationInfo"] = "Laura utilise la fonction obsolte SetDurationInfo"
L["Aura loaded"] = "Aura charge"
L["Aura Name"] = "Nom de l'aura"
L["Aura Names"] = "Nom des auras"
L["Aura Refresh"] = "Aura rafraichie"
L["Aura Removed"] = "Aura Supprim"
L["Aura Removed Dose"] = "Aura Supprim Dose"
L["Aura Stack"] = "Pile d'aura"
L["Aura Type"] = "Type Aura"
L["Aura Version: %s"] = "Version de laura : %s"
L["Aura(s) Found"] = "Aura(s) Trouve(s)"
L["Aura(s) Missing"] = "Aura(s) Manquante"
L["Aura:"] = "Aura:"
L["Auras"] = "Auras"
L["Auras:"] = "Auras:"
L["Author Options"] = "Options de l'auteur"
L["Auto"] = "auto"
--[[Translation missing --]]
L["Autocast Shine"] = "Autocast Shine"
L["Automatic"] = "Automatique"
L["Automatic Length"] = "Longueur automatique"
L["Automatic Rotation"] = "Rotation automatique"
--[[Translation missing --]]
L["Available features: %s"] = "Available features: %s"
L["Avoidance (%)"] = "Evitement (%)"
L["Avoidance Rating"] = "Pourcentage Evitement "
L["Ayamiss the Hunter"] = "Ayamiss le Chasseur"
L["Azuregos"] = "Azuregos"
L["Back and Forth"] = "D'avant en arrire"
L["Background"] = "Arrire-plan"
L["Background Color"] = "Couleur d'arrire-plan"
L["Balnazzar"] = "Balnazzar"
L["Bar Color/Gradient Start"] = "Couleur/gradient de dpart de la barre"
L["Bar enabled in BigWigs settings"] = "Barre active dans les paramtres de BigWigs"
L["Bar enabled in Boss Mod addon settings"] = "Barre active dans les paramtres de laddon de boss mod"
L["Bar enabled in DBM settings"] = [=[Barre active dans les paramtres de DBM








]=]
L["Bar Texture"] = "Texture de la barre"
--[[Translation missing --]]
L["Bar Type"] = "Bar Type"
L["Baron Geddon"] = "Baron Geddon"
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "Message Battle.net"
L["Battleground"] = [=[Champ De Bataille 
]=]
L["Battleguard Sartura"] = "Garde de guerre Sartura"
--[[Translation missing --]]
L["Beastmaster"] = "Beastmaster"
--[[Translation missing --]]
L["Beatrix"] = "Beatrix"
L["BG>Raid>Party>Say"] = "BG>Raid>Groupe>Dire"
L["BG-System Alliance"] = "Systme-BG Alliance"
L["BG-System Horde"] = "Systme-BG Horde"
L["BG-System Neutral"] = "Systme-BG Neutre"
L["Big Number"] = "Grand nombre"
L["BigWigs Addon"] = "Addon BigWigs"
L["BigWigs Message"] = "Message BigWigs"
--[[Translation missing --]]
L["BigWigs Stage"] = "BigWigs Stage"
L["BigWigs Timer"] = "Temps BigWigs"
--[[Translation missing --]]
L["Black Wing Lair"] = "Black Wing Lair"
--[[Translation missing --]]
L["Bleed"] = "Bleed"
L["Blizzard Combat Text"] = "Texte de Combat Blizzard"
L["Blizzard Cooldown Reduction"] = "Rduction du temps de recharge de Blizzard"
L["Block"] = "Bloc"
L["Block (%)"] = "Blocage"
L["Block against Target (%)"] = "Blocage contre la cible"
L["Block Value"] = "Valeur du bloc"
L["Blocked"] = "Bloqu"
--[[Translation missing --]]
L["Blood"] = "Blood"
L["Blood Rune #1"] = "Rune de sang #1"
--[[Translation missing --]]
L["Blood Rune #2"] = "Blood Rune #2"
L["Bloodlord Mandokir"] = "Seigneur sanglant Mandokir"
--[[Translation missing --]]
L["Bonus Reputation Gain"] = "Bonus Reputation Gain"
L["Border"] = "Encadrement"
L["Boss"] = "Boss"
L["Boss Emote"] = "Emote de boss"
--[[Translation missing --]]
L["Boss Mod Announce"] = "Boss Mod Announce"
--[[Translation missing --]]
L["Boss Mod Stage"] = "Boss Mod Stage"
--[[Translation missing --]]
L["Boss Mod Stage (Event)"] = "Boss Mod Stage (Event)"
--[[Translation missing --]]
L["Boss Mod Timer"] = "Boss Mod Timer"
L["Boss Whisper"] = "Chuchotement de Boss"
L["Bottom"] = "Bas"
L["Bottom Left"] = "Bas Gauche"
L["Bottom Right"] = "Bas Droite"
L["Bottom to Top"] = "De Bas en Haut"
L["Bounce"] = "Rebond"
L["Bounce with Decay"] = "Rebond dcroissant"
--[[Translation missing --]]
L["Break"] = "Break"
--[[Translation missing --]]
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers (Blizzard)"
--[[Translation missing --]]
L["Broodlord Lashlayer"] = "Broodlord Lashlayer"
L["Buff"] = "Amlioration"
L["Buff/Debuff"] = "Amlioration / affaiblissement"
L["Buffed/Debuffed"] = "Amlior/Affaiblit"
--[[Translation missing --]]
L["Burning Crusade"] = "Burning Crusade"
L["Buru the Gorger"] = "Buru Grandgosier"
--[[Translation missing --]]
L["Caldoran"] = "Caldoran"
--[[Translation missing --]]
L["Callback function"] = "Callback function"
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "Peut tre utilis pour par exemple vrifier si l'unit \"boss1target\" est la mme que \"player\"."
L["Cancel"] = "Annuler"
--[[Translation missing --]]
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."
--[[Translation missing --]]
L["Capped"] = "Capped"
--[[Translation missing --]]
L["Capped at Season Max"] = "Capped at Season Max"
--[[Translation missing --]]
L["Capped at Weekly Max"] = "Capped at Weekly Max"
L["Cast"] = "Incantation"
L["Cast Bar"] = "Barre d'incantation"
L["Cast Failed"] = "Incantation rate"
L["Cast Start"] = "Incantation dbute"
L["Cast Success"] = "Incantation russie"
L["Cast Type"] = "Type d'incantation"
L["Caster"] = "Lanceur de sort"
L["Caster Name"] = "Nom du Lanceur de sort "
L["Caster Realm"] = "Royaume du Lanceur de sort"
L["Caster Unit"] = "Unit lanceur de sort"
--[[Translation missing --]]
L["Casters Name/Realm"] = "Casters Name/Realm"
L["Caster's Target"] = "Cible du Lanceur de sort"
L["Cataclysm"] = "Cataclysm"
L["Ceil"] = "Cellule"
L["Center"] = "Centre"
L["Center, then alternating bottom and top"] = "Centrer, puis alterner bas et haut"
L["Center, then alternating left and right"] = "Centrer, puis alterner gauche et droite"
L["Center, then alternating right and left"] = "Centrer, puis alterner droite et gauche"
L["Center, then alternating top and bottom"] = "Centrer, puis alterner haut et bas"
L["Centered Horizontal"] = "Centrer horizontalement"
L["Centered Horizontal, then Centered Vertical"] = "Centrer horizontalement, puis centrer verticalement"
L["Centered Horizontal, then Down"] = "Centrer horizontalement, puis vers le haut"
L["Centered Horizontal, then Up"] = "Centrer horizontalement, puis vers le bas"
L["Centered Vertical"] = "Centr verticalement"
--[[Translation missing --]]
L["Centered Vertical, then Centered Horizontal"] = "Centered Vertical, then Centered Horizontal"
--[[Translation missing --]]
L["Centered Vertical, then Left"] = "Centered Vertical, then Left"
--[[Translation missing --]]
L["Centered Vertical, then Right"] = "Centered Vertical, then Right"
L["Changed"] = "Modifi"
L["Channel"] = "Canal"
L["Channel (Spell)"] = "Canalisation"
--[[Translation missing --]]
L["Character GUID"] = "Character GUID"
--[[Translation missing --]]
L["Character Name"] = "Character Name"
L["Character Stats"] = "Stats Personnage"
--[[Translation missing --]]
L["Character Transferred Quantity"] = "Character Transferred Quantity"
L["Character Type"] = "Type de Personnage"
L["Charge gained/lost"] = "Charge gagn/perdu"
--[[Translation missing --]]
L["Charged Combo Points"] = "Charged Combo Points"
L["Charges"] = "Charges"
--[[Translation missing --]]
L["Charges Changed Event"] = "Charges Changed Event"
--[[Translation missing --]]
L["Charging"] = "Charging"
L["Chat Frame"] = "Fentre de discussion"
L["Chat Message"] = "Message crit"
--[[Translation missing --]]
L["Check if a single talent match a Rank"] = "Check if a single talent match a Rank"
--[[Translation missing --]]
L["Check nameplate's target every 0.2s"] = "Check nameplate's target every 0.2s"
L["Chromaggus"] = "Chromaggus"
L["Circle"] = "Cercle"
--[[Translation missing --]]
L["Circular Texture"] = "Circular Texture"
L["Clamp"] = "Attache"
L["Class"] = "Classe"
L["Class and Specialization"] = "Classe et spcialisation"
L["Classic"] = "Classic"
L["Classification"] = "Classification"
L["Clockwise"] = "Sens horaire"
--[[Translation missing --]]
L["Clone per Character"] = "Clone per Character"
L["Clone per Event"] = "Clone pour chaque vnement"
L["Clone per Match"] = "Clone pour chaque Correspondance"
--[[Translation missing --]]
L["Coin Precision"] = "Coin Precision"
L["Color"] = "Couleur"
--[[Translation missing --]]
L["Color Animation"] = "Color Animation"
L["Combat Log"] = "Journal de combat"
--[[Translation missing --]]
L["Communities"] = "Communities"
--[[Translation missing --]]
L["Condition Custom Test"] = "Condition Custom Test"
L["Conditions"] = "Conditions"
L["Contains"] = "Contient"
--[[Translation missing --]]
L["Continuously update Movement Speed"] = "Continuously update Movement Speed"
L["Cooldown"] = "Temps de recharge"
--[[Translation missing --]]
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"
L["Cooldown Progress (Item)"] = "Progression du temps de recharge (Objet)"
--[[Translation missing --]]
L["Cooldown Progress (Slot)"] = "Cooldown Progress (Slot)"
--[[Translation missing --]]
L["Cooldown Ready Event"] = "Cooldown Ready Event"
--[[Translation missing --]]
L["Cooldown Ready Event (Item)"] = "Cooldown Ready Event (Item)"
--[[Translation missing --]]
L["Cooldown Ready Event (Slot)"] = "Cooldown Ready Event (Slot)"
--[[Translation missing --]]
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."
--[[Translation missing --]]
L["Cooldown/Charges/Count"] = "Cooldown/Charges/Count"
--[[Translation missing --]]
L["Copper"] = "Copper"
--[[Translation missing --]]
L["Could not load WeakAuras Archive, the addon is %s"] = "Could not load WeakAuras Archive, the addon is %s"
L["Count"] = "Nombre"
L["Counter Clockwise"] = "Sens Antihoraire"
L["Create"] = "Crer"
--[[Translation missing --]]
L["Creature Family"] = "Creature Family"
--[[Translation missing --]]
L["Creature Family Name"] = "Creature Family Name"
--[[Translation missing --]]
L["Creature Type"] = "Creature Type"
--[[Translation missing --]]
L["Creature Type Name"] = "Creature Type Name"
L["Critical"] = "Critique"
L["Critical (%)"] = "Critique (%)"
L["Critical Rating"] = "valuation Critique"
--[[Translation missing --]]
L["Crop X"] = "Crop X"
--[[Translation missing --]]
L["Crop Y"] = "Crop Y"
L["Crowd Controlled"] = "Contrl"
L["Crushing"] = "Ecrasant"
L["C'thun"] = "C'thun"
--[[Translation missing --]]
L["Cumulated time used during profiling"] = "Cumulated time used during profiling"
--[[Translation missing --]]
L["Currency"] = "Currency"
--[[Translation missing --]]
L["Current Essence"] = "Current Essence"
--[[Translation missing --]]
L["Current Experience"] = "Current Experience"
--[[Translation missing --]]
L["Current Instance"] = "Current Instance"
--[[Translation missing --]]
L["Current Movement Speed (%)"] = "Current Movement Speed (%)"
--[[Translation missing --]]
L["Current Stage"] = "Current Stage"
--[[Translation missing --]]
L["Current Zone"] = "Current Zone"
--[[Translation missing --]]
L["Current Zone Group"] = "Current Zone Group"
L["Curse"] = "Maldiction"
L["Custom"] = "Personnalis"
--[[Translation missing --]]
L["Custom Action"] = "Custom Action"
--[[Translation missing --]]
L["Custom Anchor"] = "Custom Anchor"
--[[Translation missing --]]
L["Custom Check"] = "Custom Check"
L["Custom Color"] = "Couleur personnalise"
--[[Translation missing --]]
L["Custom Condition Code"] = "Custom Condition Code"
L["Custom Configuration"] = "Configuration personnalise"
--[[Translation missing --]]
L["Custom Fade Animation"] = "Custom Fade Animation"
L["Custom Function"] = "Fonction personnalise"
--[[Translation missing --]]
L["Custom Grow"] = "Custom Grow"
--[[Translation missing --]]
L["Custom Sort"] = "Custom Sort"
--[[Translation missing --]]
L["Custom Text Function"] = "Custom Text Function"
--[[Translation missing --]]
L["Custom Trigger Combination"] = "Custom Trigger Combination"
--[[Translation missing --]]
L["Custom Variables"] = "Custom Variables"
L["Damage"] = "Dgts"
L["Damage Shield"] = "Bouclier de dgts"
L["Damage Shield Missed"] = "Bouclier de dgts rat"
L["Damage Split"] = "Rpartition des dgts"
L["DBM Announce"] = "Annonce DBM"
--[[Translation missing --]]
L["DBM Stage"] = "DBM Stage"
L["DBM Timer"] = "Temps DBM"
--[[Translation missing --]]
L["Dead"] = "Dead"
--[[Translation missing --]]
L["Death"] = "Death"
L["Death Knight Rune"] = "Rune de Chevalier de la Mort"
L["Debuff"] = "Affaiblissement"
--[[Translation missing --]]
L["Debuff Class"] = "Debuff Class"
--[[Translation missing --]]
L["Debuff Class Icon"] = "Debuff Class Icon"
L["Debuff Type"] = "Type daffaiblissement"
--[[Translation missing --]]
L["Debug Log contains more than 1000 entries"] = "Debug Log contains more than 1000 entries"
--[[Translation missing --]]
L["Debug Logging enabled"] = "Debug Logging enabled"
--[[Translation missing --]]
L["Debug Logging enabled for '%s'"] = "Debug Logging enabled for '%s'"
--[[Translation missing --]]
L["Defensive Stats"] = "Defensive Stats"
L["Deflect"] = "Dviation"
--[[Translation missing --]]
L["Delve"] = "Delve"
L["Desaturate"] = "Dsaturer"
L["Desaturate Background"] = "Dsaturer l'Arrire-plan"
L["Desaturate Foreground"] = "Dsaturer le Premier-plan"
L["Descending"] = "Dcroissant"
L["Description"] = "Description"
L["Dest Raid Mark"] = "Marqueur de raid"
--[[Translation missing --]]
L["Destination Affiliation"] = "Destination Affiliation"
--[[Translation missing --]]
L["Destination GUID"] = "Destination GUID"
--[[Translation missing --]]
L["Destination Info"] = "Destination Info"
L["Destination Name"] = "Nom de destination"
--[[Translation missing --]]
L["Destination NPC Id"] = "Destination NPC Id"
--[[Translation missing --]]
L["Destination Object Type"] = "Destination Object Type"
--[[Translation missing --]]
L["Destination Reaction"] = "Destination Reaction"
L["Destination Unit"] = "Unit de destination"
--[[Translation missing --]]
L["Destination unit's raid mark index"] = "Destination unit's raid mark index"
--[[Translation missing --]]
L["Destination unit's raid mark texture"] = "Destination unit's raid mark texture"
--[[Translation missing --]]
L["Difficulty"] = "Difficulty"
L["Disable Spell Known Check"] = "Dsactiver la vrification des sorts connus"
--[[Translation missing --]]
L["Disabled"] = "Disabled"
--[[Translation missing --]]
L["Disabled feature %q"] = "Disabled feature %q"
L["Disabled Spell Known Check"] = "Vrification des sorts connus dsactives"
--[[Translation missing --]]
L["Discovered"] = "Discovered"
L["Disease"] = "Maladie"
L["Dispel"] = "Dissipation"
L["Dispel Failed"] = "Dissipation choue"
L["Display"] = "Affichage"
L["Distance"] = "Distance"
--[[Translation missing --]]
L["Do Not Disturb"] = "Do Not Disturb"
L["Dodge"] = "Esquive"
L["Dodge (%)"] = "Esquive (%)"
L["Dodge Rating"] = "Pourcentage Esquive"
L["Down"] = "Bas"
--[[Translation missing --]]
L["Down, then Centered Horizontal"] = "Down, then Centered Horizontal"
L["Down, then Left"] = "Bas puis Gauche"
L["Down, then Right"] = "Bas puis Droite"
L["Dragonflight"] = "Dragonflight"
L["Drain"] = "Drain"
L["Dropdown Menu"] = "Menu Droulant"
--[[Translation missing --]]
L["Dumping table"] = "Dumping table"
--[[Translation missing --]]
L["Dungeon (Celestial)"] = "Dungeon (Celestial)"
L["Dungeon (Heroic)"] = "Donjon (Hroque)"
L["Dungeon (Mythic)"] = "Donjon (Mythique)"
--[[Translation missing --]]
L["Dungeon (Mythic+)"] = "Dungeon (Mythic+)"
L["Dungeon (Normal)"] = "Donjon (Normal)"
L["Dungeon (Timewalking)"] = "Donjon (Marcheurs du temps)"
L["Dungeons"] = "Donjons"
L["Durability Damage"] = "Perte de durabilit"
L["Durability Damage All"] = "Perte de durabilit sur tout"
--[[Translation missing --]]
L["Duration"] = "Duration"
--[[Translation missing --]]
L["Duration Function"] = "Duration Function"
--[[Translation missing --]]
L["Duration Function (fallback state)"] = "Duration Function (fallback state)"
--[[Translation missing --]]
L["Ease In"] = "Ease In"
L["Ease In and Out"] = "Faciliter l'entre et la sortie"
--[[Translation missing --]]
L["Ease Out"] = "Ease Out"
L["Ebonroc"] = "Rochbne"
--[[Translation missing --]]
L["Eclipse Direction"] = "Eclipse Direction"
L["Edge"] = "Marge"
--[[Translation missing --]]
L["Edge of Madness"] = "Edge of Madness"
--[[Translation missing --]]
L["Effective Spell Id"] = "Effective Spell Id"
L["Elide"] = "Elider"
--[[Translation missing --]]
L["Elite"] = "Elite"
L["Emote"] = "Emote"
--[[Translation missing --]]
L["Empower Cast End"] = "Empower Cast End"
--[[Translation missing --]]
L["Empower Cast Interrupt"] = "Empower Cast Interrupt"
--[[Translation missing --]]
L["Empower Cast Start"] = "Empower Cast Start"
--[[Translation missing --]]
L["Empowered"] = "Empowered"
--[[Translation missing --]]
L["Empowered 1"] = "Empowered 1"
--[[Translation missing --]]
L["Empowered 2"] = "Empowered 2"
--[[Translation missing --]]
L["Empowered 3"] = "Empowered 3"
--[[Translation missing --]]
L["Empowered 4"] = "Empowered 4"
--[[Translation missing --]]
L["Empowered 5"] = "Empowered 5"
--[[Translation missing --]]
L["Empowered Cast"] = "Empowered Cast"
--[[Translation missing --]]
L["Empowered Cast Fully Charged"] = "Empowered Cast Fully Charged"
--[[Translation missing --]]
L["Empowered Fully Charged"] = "Empowered Fully Charged"
L["Empty"] = "Vide"
--[[Translation missing --]]
L["Enabled feature %q"] = "Enabled feature %q"
--[[Translation missing --]]
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "Enables (incorrect) round down of seconds, which was the previous default behavior."
L["Enchant Applied"] = "Enchantement appliqu"
L["Enchant Found"] = "Enchantement prsent"
--[[Translation missing --]]
L["Enchant ID"] = "Enchant ID"
L["Enchant Missing"] = "Enchantement manquant"
L["Enchant Name or ID"] = "Nom ou ID de l'Enchantement"
L["Enchant Removed"] = "Enchantement retir"
L["Enchanted"] = "Enchant"
L["Encounter ID(s)"] = "ID de la Rencontre"
L["Energize"] = "Gain d'nergie"
L["Enrage"] = "Enrager"
--[[Translation missing --]]
L["Enter a name or a spellId"] = "Enter a name or a spellId"
L["Entering"] = "Entrer"
L["Entering/Leaving Combat"] = "Entrer / sortir de combat"
--[[Translation missing --]]
L["Entering/Leaving Encounter"] = "Entering/Leaving Encounter"
--[[Translation missing --]]
L["Entry Order"] = "Entry Order"
L["Environment Type"] = "Type d'environnement"
L["Environmental"] = "Environnement"
L["Equipment"] = "quipement"
L["Equipment Set"] = "Ensemble d'quipement"
L["Equipment Set Equipped"] = "Ensemble d'quipement quip"
L["Equipment Slot"] = "Emplacement d'quipement"
L["Equipped"] = "quip "
L["Error"] = "Erreur"
--[[Translation missing --]]
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Error decoding."] = "Error decoding."
--[[Translation missing --]]
L["Error decompressing"] = "Error decompressing"
--[[Translation missing --]]
L["Error decompressing. This doesn't look like a WeakAuras import."] = "Error decompressing. This doesn't look like a WeakAuras import."
--[[Translation missing --]]
L["Error deserializing"] = "Error deserializing"
L["Error Frame"] = "Fentre d'erreur"
--[[Translation missing --]]
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "ERROR in '%s' unknown or incompatible sub element type '%s'"
--[[Translation missing --]]
L["Error in Aura '%s'"] = "Error in Aura '%s'"
L["Error not receiving display information from %s"] = "Erreur de non-rception d'informations d'affichage de %s"
--[[Translation missing --]]
L["Essence"] = "Essence"
L["Essence #1"] = "Essence #1"
--[[Translation missing --]]
L["Essence #2"] = "Essence #2"
--[[Translation missing --]]
L["Essence #3"] = "Essence #3"
--[[Translation missing --]]
L["Essence #4"] = "Essence #4"
--[[Translation missing --]]
L["Essence #5"] = "Essence #5"
--[[Translation missing --]]
L["Essence #6"] = "Essence #6"
L["Evade"] = "Evite"
L["Event"] = "Evnement"
L["Event(s)"] = "Evnement(s)"
L["Every Frame"] = "Chaque image"
L["Every Frame (High CPU usage)"] = "Chaque image (utilisation importante du CPU)"
--[[Translation missing --]]
L["Evoker Essence"] = "Evoker Essence"
L["Exact Spell ID(s)"] = "Correspondance exacte de l'ID du/des sort(s)"
--[[Translation missing --]]
L["Execute Conditions"] = "Execute Conditions"
L["Experience (%)"] = "Exprience (%)"
--[[Translation missing --]]
L["Expertise Bonus"] = "Expertise Bonus"
--[[Translation missing --]]
L["Expertise Rating"] = "Expertise Rating"
L["Extend Outside"] = "tendre  l'extrieur"
L["Extra Amount"] = "Quantit extra"
L["Extra Attacks"] = "Attaques supplmentaires"
--[[Translation missing --]]
L["Extra Spell Id"] = "Extra Spell Id"
L["Extra Spell Name"] = "Nom de Sort supplmentaire"
L["Faction"] = "Faction"
L["Faction Name"] = "Nom de la Faction"
L["Faction Reputation"] = "Rputation envers la Faction"
--[[Translation missing --]]
L["Fade Animation"] = "Fade Animation"
L["Fade In"] = "Fondu entrant"
L["Fade Out"] = "Fondu sortant"
L["Fail Alert"] = "Alerte d'chec"
L["False"] = "Faux"
--[[Translation missing --]]
L["Fankriss the Unyielding"] = "Fankriss the Unyielding"
--[[Translation missing --]]
L["Feature %q is already disabled"] = "Feature %q is already disabled"
--[[Translation missing --]]
L["Feature %q is already enabled"] = "Feature %q is already enabled"
--[[Translation missing --]]
L["Fetch Absorb"] = "Fetch Absorb"
--[[Translation missing --]]
L["Fetch Heal Absorb"] = "Fetch Heal Absorb"
--[[Translation missing --]]
L["Fetch Legendary Power"] = "Fetch Legendary Power"
--[[Translation missing --]]
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "Fetches the name and icon of the Legendary Power that matches this bonus id."
--[[Translation missing --]]
L["Fill Area"] = "Fill Area"
--[[Translation missing --]]
L["Filter messages with format <message>"] = "Filter messages with format <message>"
L["Fire Resistance"] = "Rsistance au feu"
L["Firemaw"] = "Gueule-de-feu"
L["First"] = "Premier"
L["First Value of Tooltip Text"] = "Premire Valeur du Texte de l'Info-bulle"
L["Fixed"] = "Fix"
--[[Translation missing --]]
L["Fixed Names"] = "Fixed Names"
--[[Translation missing --]]
L["Fixed Size"] = "Fixed Size"
--[[Translation missing --]]
L["Flamegor"] = "Flamegor"
L["Flash"] = "Flash"
L["Flex Raid"] = "Raid Dynamique"
L["Flip"] = "Retourner"
L["Floor"] = "Plancher"
L["Focus"] = "Focalisation"
--[[Translation missing --]]
L["Follower Dungeon"] = "Follower Dungeon"
--[[Translation missing --]]
L["Font"] = "Font"
L["Font Size"] = "Taille de Police"
--[[Translation missing --]]
L["Forbidden function or table: %s"] = "Forbidden function or table: %s"
L["Foreground"] = "Premier plan"
L["Foreground Color"] = "Couleur de Premier Plan"
L["Form"] = "Forme"
L["Format"] = "Format"
--[[Translation missing --]]
L["Format Gold"] = "Format Gold"
--[[Translation missing --]]
L["Formats |cFFFFCC00%unit|r"] = "Formats |cFFFFCC00%unit|r"
--[[Translation missing --]]
L["Formats Player's |cFFFFCC00%guid|r"] = "Formats Player's |cFFFFCC00%guid|r"
--[[Translation missing --]]
L["Forward"] = "Forward"
--[[Translation missing --]]
L["Forward, Reverse Loop"] = "Forward, Reverse Loop"
--[[Translation missing --]]
L["Fourth Value of Tooltip Text"] = "Fourth Value of Tooltip Text"
--[[Translation missing --]]
L["Frame Selector"] = "Frame Selector"
L["Frequency"] = "Frquence"
L["Friendly"] = "Amical"
L["Friendly Fire"] = "Tir ami"
--[[Translation missing --]]
L["Friendship Max Rank"] = "Friendship Max Rank"
--[[Translation missing --]]
L["Friendship Rank"] = "Friendship Rank"
--[[Translation missing --]]
L["Friendship Reputation"] = "Friendship Reputation"
--[[Translation missing --]]
L["Frost"] = "Frost"
L["Frost Resistance"] = "Rsistance au givre"
L["Frost Rune #1"] = "Rune de givre n1"
--[[Translation missing --]]
L["Frost Rune #2"] = "Frost Rune #2"
L["Full"] = "Plein"
--[[Translation missing --]]
L["Full Region"] = "Full Region"
L["Full/Empty"] = "Plein/Vide"
--[[Translation missing --]]
L["Gahz'ranka"] = "Gahz'ranka"
L["Gained"] = "Gagn"
--[[Translation missing --]]
L["Garr"] = "Garr"
--[[Translation missing --]]
L["Gehennas"] = "Gehennas"
--[[Translation missing --]]
L["General"] = "General"
--[[Translation missing --]]
L["General Rajaxx"] = "General Rajaxx"
--[[Translation missing --]]
L["GetNameAndIcon Function (fallback state)"] = "GetNameAndIcon Function (fallback state)"
L["Glancing"] = "Erafle"
L["Global Cooldown"] = "Temps de recharge global"
L["Glow"] = "Brillance"
L["Glow External Element"] = "lment externe brillant"
--[[Translation missing --]]
L["Gluth"] = "Gluth"
--[[Translation missing --]]
L["Glyph"] = "Glyph"
--[[Translation missing --]]
L["Gold"] = "Gold"
--[[Translation missing --]]
L["Golemagg the Incinerator"] = "Golemagg the Incinerator"
--[[Translation missing --]]
L["Gothik the Harvester"] = "Gothik the Harvester"
L["Gradient"] = "Dgrad"
--[[Translation missing --]]
L["Gradient Enabled"] = "Gradient Enabled"
--[[Translation missing --]]
L["Gradient End"] = "Gradient End"
--[[Translation missing --]]
L["Gradient Orientation"] = "Gradient Orientation"
L["Gradient Pulse"] = "Pulsation dgrade"
--[[Translation missing --]]
L["Grand Widow Faerlina"] = "Grand Widow Faerlina"
L["Grid"] = "Grille"
--[[Translation missing --]]
L["Grobbulus"] = "Grobbulus"
L["Group"] = "Groupe"
L["Group Arrangement"] = "Arrangement du Groupe"
--[[Translation missing --]]
L["Group Leader/Assist"] = "Group Leader/Assist"
--[[Translation missing --]]
L["Group Size"] = "Group Size"
--[[Translation missing --]]
L["Group Type"] = "Group Type"
L["Grow"] = "Grandir"
L["GTFO Alert"] = "Alerte GTFO"
--[[Translation missing --]]
L["Guardian"] = "Guardian"
L["Guild"] = "Guilde"
--[[Translation missing --]]
L["Hakkar"] = "Hakkar"
--[[Translation missing --]]
L["Hardcore"] = "Hardcore"
L["Has Target"] = "A une Cible"
L["Has Vehicle UI"] = "Interface vhicule"
L["HasPet"] = "Avoir un familier (vivant)"
L["Haste (%)"] = "Hte (%)"
L["Haste Rating"] = "Score de hte"
L["Heal"] = "Soin"
--[[Translation missing --]]
L["Heal Absorb"] = "Heal Absorb"
--[[Translation missing --]]
L["Heal Absorbed"] = "Heal Absorbed"
L["Health"] = "Vie"
L["Health (%)"] = "Vie (%)"
--[[Translation missing --]]
L["Health Deficit"] = "Health Deficit"
--[[Translation missing --]]
L["Heigan the Unclean"] = "Heigan the Unclean"
L["Height"] = "Hauteur"
--[[Translation missing --]]
L["Hero Talent"] = "Hero Talent"
--[[Translation missing --]]
L["Heroic Party"] = "Heroic Party"
L["Hide"] = "Cacher"
--[[Translation missing --]]
L["Hide 0 cooldowns"] = "Hide 0 cooldowns"
L["Hide Timer Text"] = "Masquer le texte du minuteur"
L["High Damage"] = "Dgts levs"
--[[Translation missing --]]
L["High Priest Thekal"] = "High Priest Thekal"
--[[Translation missing --]]
L["High Priest Venoxis"] = "High Priest Venoxis"
--[[Translation missing --]]
L["High Priestess Arlokk"] = "High Priestess Arlokk"
--[[Translation missing --]]
L["High Priestess Jeklik"] = "High Priestess Jeklik"
--[[Translation missing --]]
L["High Priestess Mar'li"] = "High Priestess Mar'li"
L["Higher Than Tank"] = "Plus haut que le tank"
--[[Translation missing --]]
L["Highest Spell Id"] = "Highest Spell Id"
--[[Translation missing --]]
L["Hit (%)"] = "Hit (%)"
--[[Translation missing --]]
L["Hit Rating"] = "Hit Rating"
L["Holy Resistance"] = "Rsistance au sacr"
L["Horde"] = "Horde"
--[[Translation missing --]]
L["Horizontal"] = "Horizontal"
L["Hostile"] = "Hostile"
L["Hostility"] = "Hostilit"
L["Humanoid"] = "Humanode"
L["Hybrid"] = "Hybride"
L["Icon"] = "Icne"
--[[Translation missing --]]
L["Icon Function"] = "Icon Function"
--[[Translation missing --]]
L["Icon Function (fallback state)"] = "Icon Function (fallback state)"
--[[Translation missing --]]
L["Id"] = "Id"
--[[Translation missing --]]
L["ID"] = "ID"
--[[Translation missing --]]
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"
L["Ignore Dead"] = "Ignorer la mort"
L["Ignore Disconnected"] = "Ignorer les dconnects"
L["Ignore Rune CD"] = "Ignorer le rechargement des runes"
L["Ignore Rune CDs"] = "Ignorer les rechargements des runes"
L["Ignore Self"] = "Ignorer soi-mme"
--[[Translation missing --]]
L["Ignore Spell Cooldown/Charges"] = "Ignore Spell Cooldown/Charges"
--[[Translation missing --]]
L["Ignore Spell Override"] = "Ignore Spell Override"
L["Immune"] = "Immunit"
L["Important"] = "Important"
--[[Translation missing --]]
L["Importing will start after combat ends."] = "Importing will start after combat ends."
L["In Combat"] = "En combat"
L["In Encounter"] = "En rencontre"
L["In Group"] = "En groupe"
L["In Party"] = "En groupe"
L["In Pet Battle"] = "En combat de mascottes"
L["In Raid"] = "En raid"
--[[Translation missing --]]
L["In Range"] = "In Range"
L["In Vehicle"] = "Dans un vhicule"
L["In War Mode"] = "En mode guerre"
L["Include Bank"] = "Inclure la Banque"
L["Include Charges"] = "Inclure charges"
L["Include Death Runes"] = "Inclure les Runes de la mort"
L["Include Pets"] = "Inclure les familiers"
L["Include War Band Bank"] = "Inclure la Banque de bataillon"
L["Incoming Heal"] = "Soins en Cours"
--[[Translation missing --]]
L["Increase Precision Below"] = "Increase Precision Below"
--[[Translation missing --]]
L["Increases by one per stage or intermission."] = "Increases by one per stage or intermission."
L["Information"] = "Information"
L["Inherited"] = "Hrit"
L["Instakill"] = "Mort instant."
--[[Translation missing --]]
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "Install the addons BugSack and BugGrabber for detailed error logs."
L["Instance"] = "Instance"
L["Instance Difficulty"] = "Difficult de l'Instance"
--[[Translation missing --]]
L["Instance Id"] = "Instance Id"
--[[Translation missing --]]
L["Instance ID"] = "Instance ID"
--[[Translation missing --]]
L["Instance Info"] = "Instance Info"
--[[Translation missing --]]
L["Instance Name"] = "Instance Name"
L["Instance Size Type"] = "Taille de l'instance"
L["Instance Type"] = "Type d'instance"
--[[Translation missing --]]
L["Instructor Razuvious"] = "Instructor Razuvious"
L["Insufficient Resources"] = "Ressources insuffisantes"
L["Intellect"] = "Intelligence"
L["Interrupt"] = "Interruption"
--[[Translation missing --]]
L["Interrupt School"] = "Interrupt School"
--[[Translation missing --]]
L["Interrupted School Text"] = "Interrupted School Text"
L["Interruptible"] = "Interruptible"
L["Inverse"] = "Inverser"
L["Inverse Pet Behavior"] = "Inverser le comportement du familier"
--[[Translation missing --]]
L["Is Away from Keyboard"] = "Is Away from Keyboard"
--[[Translation missing --]]
L["Is Current Specialization"] = "Is Current Specialization"
--[[Translation missing --]]
L["Is Death Rune"] = "Is Death Rune"
L["Is Exactly"] = "Est exactement"
L["Is Moving"] = "Est en mouvement"
L["Is Off Hand"] = "Est une Main gauche"
--[[Translation missing --]]
L["Is Paragon Reputation"] = "Is Paragon Reputation"
--[[Translation missing --]]
L["Is Paused"] = "Is Paused"
L["is useable"] = "est utilisable"
--[[Translation missing --]]
L["Is Weekly Renown Capped"] = "Is Weekly Renown Capped"
--[[Translation missing --]]
L["Island Expedition (Heroic)"] = "Island Expedition (Heroic)"
--[[Translation missing --]]
L["Island Expedition (Mythic)"] = "Island Expedition (Mythic)"
--[[Translation missing --]]
L["Island Expedition (Normal)"] = "Island Expedition (Normal)"
--[[Translation missing --]]
L["Island Expeditions (PvP)"] = "Island Expeditions (PvP)"
L["Item"] = "Objet"
L["Item Bonus Id"] = "ID du bonus de l'objet"
L["Item Bonus Id Equipped"] = "ID du bonus de l'objet quip"
L["Item Count"] = "Nombre d'objets"
L["Item Equipped"] = "Objet quip"
--[[Translation missing --]]
L["Item Id"] = "Item Id"
L["Item in Range"] = "Objet  port"
--[[Translation missing --]]
L["Item Name"] = "Item Name"
L["Item Set Equipped"] = "Ensemble d'objets quip"
L["Item Set Id"] = "ID de l'Ensemble d'Equipement"
--[[Translation missing --]]
L["Item Slot"] = "Item Slot"
--[[Translation missing --]]
L["Item Slot String"] = "Item Slot String"
L["Item Type"] = "Type d'objet"
L["Item Type Equipped"] = "Type d'objet quip"
--[[Translation missing --]]
L["ItemId"] = "ItemId"
--[[Translation missing --]]
L["Jin'do the Hexxer"] = "Jin'do the Hexxer"
--[[Translation missing --]]
L["Journal Stage"] = "Journal Stage"
--[[Translation missing --]]
L["Kazzak"] = "Kazzak"
L["Keep Inside"] = "Garder  l'Intrieur"
--[[Translation missing --]]
L["Kel'Thuzad"] = "Kel'Thuzad"
--[[Translation missing --]]
L["Kurinnaxx"] = "Kurinnaxx"
L["Large"] = "Large"
--[[Translation missing --]]
L["Latency"] = "Latency"
--[[Translation missing --]]
L["Leader"] = "Leader"
L["Least remaining time"] = "Moins de temps restant"
L["Leaving"] = "Quitter"
L["Leech"] = "Drain"
L["Leech (%)"] = "Ponction (%)"
L["Leech Rating"] = "Score de ponction"
L["Left"] = "Gauche"
L["Left to Right"] = "De Gauche  Droite"
--[[Translation missing --]]
L["Left, then Centered Vertical"] = "Left, then Centered Vertical"
L["Left, then Down"] = "Gauche, puis bas"
L["Left, then Up"] = "Gauche, puis haut"
--[[Translation missing --]]
L["Legacy Looking for Raid"] = "Legacy Looking for Raid"
L["Legacy RGB Gradient"] = "Dgrad RVB Hrit"
L["Legacy RGB Gradient Pulse"] = "Impulsion de Dgrad RVB hrite"
--[[Translation missing --]]
L["Legion"] = "Legion"
L["Length"] = "Longueur"
L["Level"] = "Niveau"
--[[Translation missing --]]
L["LibSharedMedia"] = "LibSharedMedia"
--[[Translation missing --]]
L["Lillian Voss"] = "Lillian Voss"
L["Limited"] = "Limit"
--[[Translation missing --]]
L["Linear Texture"] = "Linear Texture"
--[[Translation missing --]]
L["Lines & Particles"] = "Lines & Particles"
L["Load Conditions"] = "Conditions de Chargement"
--[[Translation missing --]]
L["Loatheb"] = "Loatheb"
--[[Translation missing --]]
L["Location"] = "Location"
--[[Translation missing --]]
L["Looking for Raid"] = "Looking for Raid"
L["Loop"] = "Boucle"
--[[Translation missing --]]
L["Loot"] = "Loot"
--[[Translation missing --]]
L["Loot Specialization"] = "Loot Specialization"
--[[Translation missing --]]
L["Loot Specialization Id"] = "Loot Specialization Id"
--[[Translation missing --]]
L["Loot Specialization Name"] = "Loot Specialization Name"
--[[Translation missing --]]
L["Lorewalking"] = "Lorewalking"
L["Lost"] = "Perdu"
L["Low Damage"] = "Dgts faibles"
L["Lower Than Tank"] = "Plus bas que le tank"
--[[Translation missing --]]
L["Lowest Spell Id"] = "Lowest Spell Id"
--[[Translation missing --]]
L["Lua error"] = "Lua error"
--[[Translation missing --]]
L["Lua error in Aura '%s': %s"] = "Lua error in Aura '%s': %s"
--[[Translation missing --]]
L["Lucifron"] = "Lucifron"
--[[Translation missing --]]
L["Maexxna"] = "Maexxna"
L["Magic"] = "Magique"
--[[Translation missing --]]
L["Magmadar"] = "Magmadar"
--[[Translation missing --]]
L["Main Character"] = "Main Character"
L["Main Stat"] = "Caractristique principale"
--[[Translation missing --]]
L["Majordomo Executus"] = "Majordomo Executus"
L["Malformed WeakAuras link"] = "Lien WeakAuras mal form"
--[[Translation missing --]]
L["Manual"] = "Manual"
--[[Translation missing --]]
L["Manual Icon"] = "Manual Icon"
L["Manual Rotation"] = "Rotation manuelle"
L["Marked First"] = "Marqu en premier"
L["Marked Last"] = "Marqu en dernier"
--[[Translation missing --]]
L["Mason"] = "Mason"
L["Master"] = "Matre"
L["Mastery (%)"] = "Maitrise (%)"
L["Mastery Rating"] = "Score de matrise"
L["Match Count"] = "taux de rencontre"
--[[Translation missing --]]
L["Match Count per Unit"] = "Match Count per Unit"
L["Matches (Pattern)"] = "Correspond (format)"
--[[Translation missing --]]
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=]
--[[Translation missing --]]
L["Max Char "] = "Max Char "
--[[Translation missing --]]
L["Max Char"] = "Max Char"
L["Max Charges"] = "Charges Max"
--[[Translation missing --]]
L["Max Health"] = "Max Health"
--[[Translation missing --]]
L["Max Power"] = "Max Power"
--[[Translation missing --]]
L["Max Quantity"] = "Max Quantity"
L["Maximum Estimate"] = "Estimation Maximale"
--[[Translation missing --]]
L["Maximum Progress"] = "Maximum Progress"
--[[Translation missing --]]
L["Maximum time used on a single frame"] = "Maximum time used on a single frame"
--[[Translation missing --]]
L["Media"] = "Media"
L["Medium"] = "Moyen"
--[[Translation missing --]]
L["Melee"] = "Melee"
--[[Translation missing --]]
L["Melee Haste (%)"] = "Melee Haste (%)"
L["Message"] = "Message"
L["Message Type"] = "Type de message"
L["Message type:"] = "Type de message :"
L["Meta Data"] = "Mtadonnes"
--[[Translation missing --]]
L["Mine"] = "Mine"
L["Minimum Estimate"] = "Estimation minimale"
--[[Translation missing --]]
L["Minimum Progress"] = "Minimum Progress"
--[[Translation missing --]]
L["Minus (Small Nameplate)"] = "Minus (Small Nameplate)"
L["Mirror"] = "Miroir"
--[[Translation missing --]]
L["Miscellaneous"] = "Miscellaneous"
L["Miss"] = "Rat"
L["Miss Type"] = "Type de rat"
L["Missed"] = "Rat"
L["Missing"] = "Manquant"
--[[Translation missing --]]
L["Mists of Pandaria"] = "Mists of Pandaria"
L["Moam"] = "Moam"
L["Model"] = "Modle"
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Blizzard moderne (1h 3min | 3m 7s | 10s | 2.4)"
--[[Translation missing --]]
L["Modernize"] = "Modernize"
--[[Translation missing --]]
L["Molten Core"] = "Molten Core"
--[[Translation missing --]]
L["Money"] = "Money"
L["Monochrome"] = "Monochrome"
L["Monochrome Outline"] = "Contour monochrome"
L["Monochrome Thick Outline"] = "Contour pais monochrome"
L["Monster Emote"] = "Emote de Monstre"
L["Monster Party"] = "Groupe de Monstre"
L["Monster Say"] = "Dire de Monstre"
L["Monster Whisper"] = "Chuchotement de Monstre"
L["Monster Yell"] = "Cri de monstre"
--[[Translation missing --]]
L["Moon"] = "Moon"
L["Most remaining time"] = "Plus de temps restant"
L["Mounted"] = "En monture"
L["Mouse Cursor"] = "Curseur de la souris"
L["Movement Speed Rating"] = [=[Score de vitesse
]=]
L["Multi-target"] = "Multi-cibles"
L["Mythic Keystone"] = "Cl mythique"
L["Mythic+ Affix"] = "Affixe de Mythique +"
L["Name"] = "Nom"
--[[Translation missing --]]
L["Name Function"] = "Name Function"
--[[Translation missing --]]
L["Name Function (fallback state)"] = "Name Function (fallback state)"
L["Name of Caster's Target"] = "Nom de la cible du lanceur"
L["Name of the (sub-)zone currently shown above the minimap."] = "Nom de la (sous-)zone actuellement affiche au-dessus de la mini-carte."
--[[Translation missing --]]
L["Name(s)"] = "Name(s)"
L["Name/Realm of Caster's Target"] = "Nom/Royaume de la Cible du Lanceur de sort"
L["Nameplate"] = "Barre de vie"
L["Nameplates"] = "Barres de vie"
L["Names of affected Players"] = "Noms des joueurs affects"
L["Names of unaffected Players"] = "Noms des joueurs non affects"
L["Nature Resistance"] = "Rsistance  la nature"
L["Naxxramas"] = "Naxxramas"
L["Nefarian"] = "Nefarian"
L["Neutral"] = "Neutre"
L["Never"] = "Jamais"
L["Next Combat"] = "Prochain combat"
--[[Translation missing --]]
L["Next Encounter"] = "Next Encounter"
--[[Translation missing --]]
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
--[[Translation missing --]]
L["No Extend"] = "No Extend"
L["No Instance"] = "Aucune instance"
L["No Profiling information saved."] = "Aucune information de profilage enregistre."
--[[Translation missing --]]
L["No Progress Information available."] = "No Progress Information available."
L["None"] = "Aucun"
L["Non-player Character"] = "Personnage non-joueur"
L["Normal"] = "Normal"
--[[Translation missing --]]
L["Normal Party"] = "Normal Party"
L["Not in Group"] = "N'est pas en groupe"
L["Not in Smart Group"] = "N'est pas dans un petit groupe"
L["Not on Cooldown"] = "Pas en recharge"
L["Not On Threat Table"] = "Pas sur la table de menace"
--[[Translation missing --]]
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "Remarque: \"Cacher Seul\" n'est pas disponible dans le nouveau systme de suivi d'aura. Une option de chargement peut tre utilise  la place."
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "Remarque: Les remplacements de texte disponibles pour les dclencheurs multiples correspondent maintenant aux dclencheurs normaux."
--[[Translation missing --]]
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = "Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."
--[[Translation missing --]]
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "Note: This trigger relies on the WoW API, which returns incorrect information in some cases."
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "Remarque : Ce type de dclencheur estime la porte du masque de collision (hitbox) d'une unit. La porte relle des joueurs amis est gnralement suprieure de 3 mtres  l'estimation. Les capacits de vrification de la porte dpendent de votre classe actuelle et de vos capacits connues, ainsi que du type d'unit  vrifier. Certaines des portes peuvent galement ne pas fonctionner avec certains PNJ.|n|n|cFFAAFFAAUnits amies :|r %s|n|cFFFFAAAAUnits nuisibles :|r %s|n|cFFAAAAFFUnits diverses :|r %s"
L["Noth the Plaguebringer"] = "Noth le Porte-peste"
L["NPC"] = "PNJ"
L["Npc ID"] = "ID PNJ"
L["Number"] = "Nombre"
L["Number Affected"] = "Nombre affect"
L["Object"] = "Objet"
--[[Translation missing --]]
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=]
L["Officer"] = "Officier"
--[[Translation missing --]]
L["Offset from progress"] = "Offset from progress"
L["Offset Timer"] = "Dcalage de la dure"
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Blizzard ancien (2h | 3m | 10s | 2.4)"
L["On Cooldown"] = "En recharge"
--[[Translation missing --]]
L["On Taxi"] = "On Taxi"
--[[Translation missing --]]
L["Only if on a different realm"] = "Only if on a different realm"
L["Only if Primary"] = "Seulement si primaire"
L["Onyxia"] = "Onyxia"
L["Opaque"] = "Opaque"
L["Option Group"] = "Option du groupe"
--[[Translation missing --]]
L["Options could not be loaded, the addon is %s"] = "Options could not be loaded, the addon is %s"
L["Options will finish loading after combat ends."] = "Les options finiront de se charger aprs la fin du combat."
L["Options will open after the login process has completed."] = "Les options s'ouvriront aprs la fin du chargement."
--[[Translation missing --]]
L["Or Talent"] = "Or Talent"
L["Orbit"] = "Orbite"
L["Orientation"] = "Orientation"
L["Ossirian the Unscarred"] = "Ossirian l'Intouch"
L["Other"] = "Autre"
L["Other Addons"] = "Autre Addons"
L["Other Events"] = "Autre vnements"
L["Ouro"] = "Ouro"
L["Outline"] = "Contour"
--[[Translation missing --]]
L["Over Energize"] = "Over Energize"
L["Overhealing"] = "Soin en excs"
L["Overkill"] = "Dgts en excs"
L["Overlay %s"] = "Superposer %s"
L["Overlay Charged Combo Points"] = "Superposer les Points de combo chargs"
L["Overlay Cost of Casts"] = "Superposer le cot des incantations"
L["Overlay Latency"] = "Superposer la Latence"
--[[Translation missing --]]
L["Pad"] = "Pad"
--[[Translation missing --]]
L["Pad Mode"] = "Pad Mode"
--[[Translation missing --]]
L["Pad to"] = "Pad to"
--[[Translation missing --]]
L["Paragon Reputation"] = "Paragon Reputation"
--[[Translation missing --]]
L["Paragon Reward Pending"] = "Paragon Reward Pending"
--[[Translation missing --]]
L["Parent Frame"] = "Parent Frame"
--[[Translation missing --]]
L["Parent Zone"] = "Parent Zone"
L["Parry"] = "Parade"
L["Parry (%)"] = "Parade (%)"
L["Parry Rating"] = "Score de parade"
L["Party"] = "Groupe"
L["Party Kill"] = "Tu par le groupe"
--[[Translation missing --]]
L["Patchwerk"] = "Patchwerk"
--[[Translation missing --]]
L["Path of Ascension: Courage"] = "Path of Ascension: Courage"
--[[Translation missing --]]
L["Path of Ascension: Humility"] = "Path of Ascension: Humility"
--[[Translation missing --]]
L["Path of Ascension: Loyalty"] = "Path of Ascension: Loyalty"
--[[Translation missing --]]
L["Path of Ascension: Wisdom"] = "Path of Ascension: Wisdom"
L["Paused"] = "En pause"
L["Periodic Spell"] = "Sort priodique"
L["Personal Resource Display"] = "Cadre des ressources personnelles"
L["Pet"] = "Familier "
L["Pet Behavior"] = "Comportement du familier"
L["Pet Specialization"] = "Spcialisation du familier"
L["Pet Spell"] = "Sort du familier"
L["Pets only"] = "Familiers seulement"
L["Phase"] = "Phase"
L["Pixel Glow"] = "Pixel brillant"
L["Placement"] = "Placement"
--[[Translation missing --]]
L["Placement %i"] = "Placement %i"
--[[Translation missing --]]
L["Placement Mode"] = "Placement Mode"
L["Play"] = "Jouer"
L["Player"] = "Joueur"
L["Player Character"] = "Personnage Joueur"
L["Player Class"] = "Classe du joueur"
L["Player Effective Level"] = "Niveau effectif du joueur"
--[[Translation missing --]]
L["Player Experience"] = "Player Experience"
L["Player Faction"] = "Faction joueur"
L["Player Level"] = "Niveau du joueur"
--[[Translation missing --]]
L["Player Location ID(s)"] = "Player Location ID(s)"
--[[Translation missing --]]
L["Player Money"] = "Player Money"
L["Player Name/Realm"] = "Nom du joueur / serveur"
L["Player Race"] = "Race du joueur"
L["Player(s) Affected"] = "Joueur(s) affect(s)"
L["Player(s) Not Affected"] = "Joueur(s) non affect(s)"
--[[Translation missing --]]
L["Player/Unit Info"] = "Player/Unit Info"
L["Players and Pets"] = "Joueurs et familiers"
L["Poison"] = "Poison"
L["Power"] = "Puissance"
L["Power (%)"] = "Puissance (%)"
--[[Translation missing --]]
L["Power Deficit"] = "Power Deficit"
L["Power Type"] = "Type de puissance"
L["Precision"] = "Prcision"
L["Preset"] = "Prrgl"
--[[Translation missing --]]
L["Primary Stats"] = "Primary Stats"
--[[Translation missing --]]
L["Princess Huhuran"] = "Princess Huhuran"
L["Print Profiling Results"] = "Afficher les rsultats de profilage"
L["Proc Glow"] = "Gnre une brillance"
L["Profiling already started."] = "Le profilage a dj commenc."
--[[Translation missing --]]
L["Profiling automatically started."] = "Profiling automatically started."
L["Profiling not running."] = "Le profilage ne fonctionne pas."
L["Profiling started."] = "Le profilage a commenc."
--[[Translation missing --]]
L["Profiling started. It will end automatically in %d seconds"] = "Profiling started. It will end automatically in %d seconds"
L["Profiling still running, stop before trying to print."] = "Le profilage est toujours en cours, arrtez avant d'essayer de l'afficher"
L["Profiling stopped."] = "Le profilage s'est arrt."
L["Progress"] = "Progrs"
--[[Translation missing --]]
L["Progress Source"] = "Progress Source"
L["Progress Total"] = "Progrs Total"
L["Progress Value"] = "Valeur de progression"
--[[Translation missing --]]
L["Pull"] = "Pull"
L["Pulse"] = "Pulsation"
L["PvP Flagged"] = "JcJ activ"
L["PvP Talent selected"] = "Talent JcJ slectionn"
--[[Translation missing --]]
L["PvP Talent Selected"] = "PvP Talent Selected"
--[[Translation missing --]]
L["Quality Id"] = "Quality Id"
--[[Translation missing --]]
L["Quantity"] = "Quantity"
--[[Translation missing --]]
L["Quantity earned this week"] = "Quantity earned this week"
--[[Translation missing --]]
L["Quest Party"] = "Quest Party"
--[[Translation missing --]]
L["Queued Action"] = "Queued Action"
L["Radius"] = "Rayon"
--[[Translation missing --]]
L["Ragnaros"] = "Ragnaros"
L["Raid"] = "Raid "
L["Raid (Heroic)"] = "Raid (Hroque)"
L["Raid (Mythic)"] = "Raid (Mythique)"
L["Raid (Normal)"] = "Raid (Normal)"
L["Raid (Timewalking)"] = "Raid (Marcheurs du temps)"
L["Raid Mark"] = "Marque de raid"
L["Raid Mark Icon"] = "Icne pour la marque de raid"
L["Raid Role"] = "Rle de raid"
L["Raid Warning"] = "Avertissement de raid"
L["Raids"] = "Raids RdR"
L["Range"] = "Porte"
L["Range Check"] = "Vrification de la porte"
--[[Translation missing --]]
L["Ranged"] = "Ranged"
--[[Translation missing --]]
L["Rank"] = "Rank"
L["Rare"] = "Rare"
--[[Translation missing --]]
L["Rare Elite"] = "Rare Elite"
L["Rated Arena"] = "Arne Cot"
L["Rated Battleground"] = "Champ de bataille Cot"
--[[Translation missing --]]
L["Raw Threat Percent"] = "Raw Threat Percent"
--[[Translation missing --]]
L["Razorgore the Untamed"] = "Razorgore the Untamed"
L["Ready Check"] = "Appel de Raid"
--[[Translation missing --]]
L["Reagent Quality"] = "Reagent Quality"
--[[Translation missing --]]
L["Reagent Quality Texture"] = "Reagent Quality Texture"
L["Realm"] = "Royaume"
L["Realm Name"] = "Nom du Royaume"
L["Realm of Caster's Target"] = "Royaume de la Cible du Lanceur de sort"
--[[Translation missing --]]
L["Reborn Council"] = "Reborn Council"
--[[Translation missing --]]
L["Receiving %s Bytes"] = "Receiving %s Bytes"
L["Receiving display information"] = "Rception d'information de graphique de %s..."
L["Reflect"] = "Renvoi"
L["Region type %s not supported"] = "Rgion de type %s non support"
L["Relative"] = "Relatif"
L["Relative X-Offset"] = "Dcalage sur l'axe X"
L["Relative Y-Offset"] = "Dcalage sur l'axe Y"
L["Remaining Duration"] = "Dure Restante"
L["Remaining Time"] = "Temps restant"
L["Remove Obsolete Auras"] = "Retirer les auras obsoltes"
--[[Translation missing --]]
L["Renown Level"] = "Renown Level"
--[[Translation missing --]]
L["Renown Max Level"] = "Renown Max Level"
--[[Translation missing --]]
L["Renown Reputation"] = "Renown Reputation"
L["Repair"] = "Rparer"
L["Repeat"] = "Rpter"
--[[Translation missing --]]
L["Report Summary"] = "Report Summary"
--[[Translation missing --]]
L["Reputation"] = "Reputation"
--[[Translation missing --]]
L["Reputation (%)"] = "Reputation (%)"
L["Requested display does not exist"] = "L'affichage demand n'existe pas"
L["Requested display not authorized"] = "L'affichage demand n'est pas autoris"
L["Requesting display information from %s ..."] = "Demande des informations de l'affichage depuis %s ..."
L["Require Valid Target"] = "Exige une cible valide"
--[[Translation missing --]]
L["Requires syncing the specialization via LibSpecialization."] = "Requires syncing the specialization via LibSpecialization."
--[[Translation missing --]]
L["Resilience (%)"] = "Resilience (%)"
--[[Translation missing --]]
L["Resilience Rating"] = "Resilience Rating"
L["Resist"] = "Rsiste"
--[[Translation missing --]]
L["Resistances"] = "Resistances"
L["Resisted"] = "Rsist"
L["Rested"] = "Repos"
--[[Translation missing --]]
L["Rested Experience"] = "Rested Experience"
--[[Translation missing --]]
L["Rested Experience (%)"] = "Rested Experience (%)"
L["Resting"] = "Repos"
L["Resurrect"] = "Rsurrection"
--[[Translation missing --]]
L["Resurrect Pending"] = "Resurrect Pending"
L["Right"] = "Droite"
L["Right to Left"] = "Droite  Gauche"
L["Right, then Centered Vertical"] = "Droite, puis centrer verticalement"
L["Right, then Down"] = "Droite, puis bas"
L["Right, then Up"] = "Droite, puis haut"
L["Role"] = "Rle"
--[[Translation missing --]]
L["Rollback snapshot is complete. Thank you for your patience!"] = "Rollback snapshot is complete. Thank you for your patience!"
--[[Translation missing --]]
L["Rotate Animation"] = "Rotate Animation"
L["Rotate Left"] = "Rotation gauche"
L["Rotate Right"] = "Rotation droite"
L["Rotation"] = "Rotation"
L["Round"] = "Ronde"
--[[Translation missing --]]
L["Round Mode"] = "Round Mode"
L["Ruins of Ahn'Qiraj"] = "Ruines d'Ahn'Qiraj"
L["Run Custom Code"] = "Excuter le code personnalis"
--[[Translation missing --]]
L["Run Speed (%)"] = "Run Speed (%)"
L["Rune"] = "Rune"
L["Rune #1"] = "Rune #1"
L["Rune #2"] = "Rune #2"
L["Rune #3"] = "Rune #3"
L["Rune #4"] = "Rune #4"
L["Rune #5"] = "Rune #5"
L["Rune #6"] = "Rune #6"
--[[Translation missing --]]
L["Rune Count"] = "Rune Count"
--[[Translation missing --]]
L["Rune Count - Blood"] = "Rune Count - Blood"
--[[Translation missing --]]
L["Rune Count - Frost"] = "Rune Count - Frost"
--[[Translation missing --]]
L["Rune Count - Unholy"] = "Rune Count - Unholy"
--[[Translation missing --]]
L["Sapphiron"] = "Sapphiron"
L["Say"] = "Dire"
L["Scale"] = "chelle"
--[[Translation missing --]]
L["Scarlet Enclave"] = "Scarlet Enclave"
L["Scenario"] = "Scnario"
--[[Translation missing --]]
L["Scenario (Heroic)"] = "Scenario (Heroic)"
--[[Translation missing --]]
L["Scenario (Normal)"] = "Scenario (Normal)"
--[[Translation missing --]]
L["Screen"] = "Screen"
L["Screen/Parent Group"] = "cran/Groupe parent"
--[[Translation missing --]]
L["Season of Discovery"] = "Season of Discovery"
L["Second"] = "Deuxime"
L["Second Value of Tooltip Text"] = "Deuxime valeur du texte de l'info-bulle"
--[[Translation missing --]]
L["Secondary Stats"] = "Secondary Stats"
L["Seconds"] = "Secondes"
--[[Translation missing --]]
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Select Frame"] = "Slectionner le cadre"
--[[Translation missing --]]
L["Select the type of timer to filter"] = "Select the type of timer to filter"
--[[Translation missing --]]
L["Selection Mode"] = "Selection Mode"
L["Separator"] = "Sparateur"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "Set IDs can be found on websites such as wowhead.com/cata/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/classic/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "Set IDs can be found on websites such as wowhead.com/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"
L["Shadow Resistance"] = "Rsistance  l'ombre"
--[[Translation missing --]]
L["Shadowlands"] = "Shadowlands"
L["Shake"] = "Secouer"
--[[Translation missing --]]
L["Shazzrah"] = "Shazzrah"
L["Shift-Click to resume addon execution."] = "Maj-Clic pour reprendre l'excution de l'addon."
L["Show"] = "Montrer"
L["Show CD of Charge"] = "Afficher le Temps de Recharge de la charge"
--[[Translation missing --]]
L["Show charged duration for empowered casts"] = "Show charged duration for empowered casts"
L["Show GCD"] = "Afficher GCD"
L["Show Global Cooldown"] = "Afficher le Temps de Recharge Global"
L["Show Incoming Heal"] = "Afficher les Soins en Cours"
--[[Translation missing --]]
L["Show Loss of Control"] = "Show Loss of Control"
L["Show On"] = "Afficher Sur"
L["Show Rested Overlay"] = "Superposer l'XP en repos"
L["Shrink"] = "Rtrcir"
--[[Translation missing --]]
L["Silithid Royalty"] = "Silithid Royalty"
--[[Translation missing --]]
L["Silver"] = "Silver"
L["Simple"] = "Basique"
--[[Translation missing --]]
L["Since Active"] = "Since Active"
--[[Translation missing --]]
L["Since Apply"] = "Since Apply"
--[[Translation missing --]]
L["Since Apply/Refresh"] = "Since Apply/Refresh"
--[[Translation missing --]]
L["Since Charge Gain"] = "Since Charge Gain"
--[[Translation missing --]]
L["Since Charge Lost"] = "Since Charge Lost"
--[[Translation missing --]]
L["Since Ready"] = "Since Ready"
--[[Translation missing --]]
L["Since Stack Gain"] = "Since Stack Gain"
--[[Translation missing --]]
L["Since Stack Lost"] = "Since Stack Lost"
L["Size & Position"] = "Taille & Position"
--[[Translation missing --]]
L["Skyriding"] = "Skyriding"
--[[Translation missing --]]
L["Slide Animation"] = "Slide Animation"
L["Slide from Bottom"] = "Glisser d'en bas"
L["Slide from Left"] = "Glisser de la gauche"
L["Slide from Right"] = "Glisser de la droite"
L["Slide from Top"] = "Glisser d'en haut"
L["Slide to Bottom"] = "Glisser en bas"
L["Slide to Left"] = "Glisser  gauche"
L["Slide to Right"] = "Glisser  droite"
L["Slide to Top"] = "Glisser en haut"
--[[Translation missing --]]
L["Slider"] = "Slider"
L["Small"] = "Petit"
--[[Translation missing --]]
L["Smart Group"] = "Smart Group"
--[[Translation missing --]]
L["Soft Enemy"] = "Soft Enemy"
--[[Translation missing --]]
L["Soft Friend"] = "Soft Friend"
--[[Translation missing --]]
L["Solistrasza"] = "Solistrasza"
L["Sound"] = "Son"
L["Sound by Kit ID"] = "Son par Kit ID"
L["Source"] = "Source"
--[[Translation missing --]]
L["Source Affiliation"] = "Source Affiliation"
--[[Translation missing --]]
L["Source GUID"] = "Source GUID"
--[[Translation missing --]]
L["Source Info"] = "Source Info"
L["Source Name"] = "Nom de source"
--[[Translation missing --]]
L["Source NPC Id"] = "Source NPC Id"
--[[Translation missing --]]
L["Source Object Type"] = "Source Object Type"
--[[Translation missing --]]
L["Source Raid Mark"] = "Source Raid Mark"
--[[Translation missing --]]
L["Source Reaction"] = "Source Reaction"
L["Source Unit"] = "Unit source"
--[[Translation missing --]]
L["Source Unit Name/Realm"] = "Source Unit Name/Realm"
--[[Translation missing --]]
L["Source unit's raid mark index"] = "Source unit's raid mark index"
--[[Translation missing --]]
L["Source unit's raid mark texture"] = "Source unit's raid mark texture"
L["Space"] = "Ecart"
L["Spacing"] = "Ecartement"
L["Spark"] = "tincelle"
--[[Translation missing --]]
L["Spec Position"] = "Spec Position"
--[[Translation missing --]]
L["Spec Role"] = "Spec Role"
--[[Translation missing --]]
L["Specialization"] = "Specialization"
--[[Translation missing --]]
L["Specific Currency"] = "Specific Currency"
L["Specific Type"] = "Type spcifique"
L["Specific Unit"] = "Unit spcifique"
L["Spell"] = "Sort"
L["Spell (Building)"] = "Sort (croissant)"
L["Spell Activation Overlay Glow"] = "Brillance pendant que le sort est actif"
--[[Translation missing --]]
L["Spell Cast Succeeded"] = "Spell Cast Succeeded"
L["Spell Cost"] = "Cot des sorts"
--[[Translation missing --]]
L["Spell Count"] = "Spell Count"
L["Spell ID"] = "ID de Sort"
L["Spell Id"] = "ID de Sort"
L["Spell ID:"] = "ID de sort:"
L["Spell IDs:"] = "IDs de sort"
L["Spell in Range"] = "Sort  porte"
L["Spell Known"] = "Sort connu"
L["Spell Name"] = "Nom du sort"
--[[Translation missing --]]
L["Spell Peneration Percent"] = "Spell Peneration Percent"
--[[Translation missing --]]
L["Spell Power"] = "Spell Power"
--[[Translation missing --]]
L["Spell School"] = "Spell School"
L["Spell Usable"] = "Sort Utilisable"
--[[Translation missing --]]
L["Spellname"] = "Spellname"
--[[Translation missing --]]
L["Spike"] = "Spike"
L["Spin"] = "Tourne"
L["Spiral"] = "Spirale"
L["Spiral In And Out"] = "Spirale entrante et sortante"
--[[Translation missing --]]
L["Spirit"] = "Spirit"
L["Stack Count"] = "Nombre de Piles"
--[[Translation missing --]]
L["Stack trace:"] = "Stack trace:"
L["Stacks"] = "Piles"
--[[Translation missing --]]
L["Stacks Function"] = "Stacks Function"
--[[Translation missing --]]
L["Stacks Function (fallback state)"] = "Stacks Function (fallback state)"
--[[Translation missing --]]
L["Stage"] = "Stage"
--[[Translation missing --]]
L["Stage Counter"] = "Stage Counter"
--[[Translation missing --]]
L["Stagger"] = "Stagger"
--[[Translation missing --]]
L["Stagger (%)"] = "Stagger (%)"
--[[Translation missing --]]
L["Stagger against Target (%)"] = "Stagger against Target (%)"
L["Stagger Scale"] = "espacer"
L["Stamina"] = "Endurance"
L["Stance/Form/Aura"] = "Posture/Forme/Aura"
--[[Translation missing --]]
L["Standing"] = "Standing"
--[[Translation missing --]]
L["Star Shake"] = "Star Shake"
--[[Translation missing --]]
L["Start Animation"] = "Start Animation"
--[[Translation missing --]]
L["Start Now"] = "Start Now"
--[[Translation missing --]]
L["Start Profiling"] = "Start Profiling"
L["Status"] = "Statut"
--[[Translation missing --]]
L["Status Bar"] = "Status Bar"
L["Stolen"] = "Vol"
L["Stop"] = "Arrter"
--[[Translation missing --]]
L["Stop Motion"] = "Stop Motion"
--[[Translation missing --]]
L["Story Raid"] = "Story Raid"
L["Strength"] = "Force"
L["String"] = "Squence"
--[[Translation missing --]]
L["Subevent Info"] = "Subevent Info"
--[[Translation missing --]]
L["Subtract Cast"] = "Subtract Cast"
--[[Translation missing --]]
L["Subtract Channel"] = "Subtract Channel"
--[[Translation missing --]]
L["Subtract GCD"] = "Subtract GCD"
--[[Translation missing --]]
L["Subzone Name"] = "Subzone Name"
--[[Translation missing --]]
L["Success"] = "Success"
--[[Translation missing --]]
L["Sulfuron Harbinger"] = "Sulfuron Harbinger"
L["Summon"] = "Invocation"
--[[Translation missing --]]
L["Summon Pending"] = "Summon Pending"
--[[Translation missing --]]
L["Sun"] = "Sun"
L["Supports multiple entries, separated by commas"] = "Prend en charge plusieurs entres, spares par des virgules"
L[ [=[Supports multiple entries, separated by commas
]=] ] = "Prend en charge plusieurs entres, spares par des virgules"
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Prefix with '-' for negation."
--[[Translation missing --]]
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=]
L["Swing"] = "Coup"
L["Swing Timer"] = "Vitesse d'attaque"
L["Swipe"] = "Balayage"
--[[Translation missing --]]
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = "Syntax /wa feature <toggle|on|enable|disable|off> <feature>"
L["System"] = "Systme"
--[[Translation missing --]]
L["Systems"] = "Systems"
L["Tab "] = "Onglet"
--[[Translation missing --]]
L["Talent"] = "Talent"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Known"] = "Talent |cFFFF0000Not|r Known"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Selected"] = "Talent |cFFFF0000Not|r Selected"
--[[Translation missing --]]
L["Talent Known"] = "Talent Known"
L["Talent Selected"] = "Talent slectionn"
L["Talent selected"] = "Talent slectionn"
L["Talent Specialization"] = "Spcialisation"
L["Tanking And Highest"] = "Tank et le plus haut"
L["Tanking But Not Highest"] = "Tank mais pas le plus haut"
L["Target"] = "Cible"
L["Targeted"] = "Cibl"
--[[Translation missing --]]
L["Tertiary Stats"] = "Tertiary Stats"
--[[Translation missing --]]
L["Test if bar is enabled in BigWigs settings"] = "Test if bar is enabled in BigWigs settings"
--[[Translation missing --]]
L["Test if bar is enabled in Boss Mod addon settings"] = "Test if bar is enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Test if bar is enabled in DBM settings"] = "Test if bar is enabled in DBM settings"
L["Text"] = "Texte"
--[[Translation missing --]]
L["Text To Speech"] = "Text To Speech"
--[[Translation missing --]]
L["Text-to-speech"] = "Text-to-speech"
--[[Translation missing --]]
L["Texture"] = "Texture"
--[[Translation missing --]]
L["Texture Function"] = "Texture Function"
--[[Translation missing --]]
L["Texture Function (fallback state)"] = "Texture Function (fallback state)"
--[[Translation missing --]]
L["Texture Picker"] = "Texture Picker"
--[[Translation missing --]]
L["Texture Rotation"] = "Texture Rotation"
--[[Translation missing --]]
L["Thaddius"] = "Thaddius"
--[[Translation missing --]]
L["The aura has overwritten the global '%s', this might affect other auras."] = "The aura has overwritten the global '%s', this might affect other auras."
--[[Translation missing --]]
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "The aura tried to overwrite the aura_env global, which is not allowed."
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "Le niveau effectif diffre du niveau dans les donjons des Marcheurs du temps, par exemple."
--[[Translation missing --]]
L["The Four Horsemen"] = "The Four Horsemen"
--[[Translation missing --]]
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "The 'ID' value can be found in the BigWigs options of a specific spell"
--[[Translation missing --]]
L["The Prophet Skeram"] = "The Prophet Skeram"
--[[Translation missing --]]
L["The total quantity a warband character can transfer after paying the transfer cost"] = "The total quantity a warband character can transfer after paying the transfer cost"
--[[Translation missing --]]
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "The total quantity after transferring everything to your current character and paying the transfer cost"
--[[Translation missing --]]
L["The War Within"] = "The War Within"
L["There are %i updates to your auras ready to be installed!"] = [=[
Il y a %i mises  jour de vos auras prtes  tre installes!]=]
L["Thick Outline"] = "Contour pais"
L["Thickness"] = "paisseur"
L["Third"] = "Troisime"
L["Third Value of Tooltip Text"] = "Troisime valeur du texte de l'info-bulle"
--[[Translation missing --]]
L["This aura calls GetData a lot, which is a slow function."] = "This aura calls GetData a lot, which is a slow function."
--[[Translation missing --]]
L["This aura has caused a Lua error."] = "This aura has caused a Lua error."
--[[Translation missing --]]
L["This aura is saving %s KB of data"] = "This aura is saving %s KB of data"
--[[Translation missing --]]
L["This aura plays a sound via a condition."] = "This aura plays a sound via a condition."
--[[Translation missing --]]
L["This aura plays a sound via an action."] = "This aura plays a sound via an action."
--[[Translation missing --]]
L["This aura plays a Text To Speech via a condition."] = "This aura plays a Text To Speech via a condition."
--[[Translation missing --]]
L["This aura plays a Text To Speech via an action."] = "This aura plays a Text To Speech via an action."
--[[Translation missing --]]
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."
--[[Translation missing --]]
L["Threat Percent"] = "Threat Percent"
L["Threat Situation"] = "Situation de Menace"
--[[Translation missing --]]
L["Threat Value"] = "Threat Value"
L["Tick"] = "Coche"
--[[Translation missing --]]
L["Time"] = "Time"
--[[Translation missing --]]
L["Time Format"] = "Time Format"
--[[Translation missing --]]
L["Time in GCDs"] = "Time in GCDs"
--[[Translation missing --]]
L["Time since initial application"] = "Time since initial application"
--[[Translation missing --]]
L["Time since last refresh"] = "Time since last refresh"
--[[Translation missing --]]
L["Time since stack gain"] = "Time since stack gain"
--[[Translation missing --]]
L["Time since stack lost"] = "Time since stack lost"
L["Timed"] = "Temporis"
--[[Translation missing --]]
L["Timed Progress"] = "Timed Progress"
--[[Translation missing --]]
L["Timer"] = "Timer"
--[[Translation missing --]]
L["Timer Id"] = "Timer Id"
L["Toggle"] = "Basculer"
L["Toggle List"] = "Basculer la liste"
L["Toggle Options Window"] = "Activer/Dsactiver la Fentre d'Options"
--[[Translation missing --]]
L["Toggle Performance Profiling Window"] = "Toggle Performance Profiling Window"
L["Tooltip"] = "Info-bulle"
L["Tooltip 1"] = "Info-bulle 1"
L["Tooltip 2"] = "Info-bulle 2"
L["Tooltip 3"] = "Info-bulle 3"
L["Tooltip Value 1"] = "Valeur de l'info-bulle 1"
L["Tooltip Value 2"] = "Valeur de l'info-bulle 2"
L["Tooltip Value 3"] = "Valeur de l'info-bulle 3"
L["Tooltip Value 4"] = "Valeur de l'info-bulle 4"
L["Top"] = "Haut"
L["Top Left"] = "Haut Gauche"
L["Top Right"] = "Haut Droite"
L["Top to Bottom"] = "Haut en Bas"
--[[Translation missing --]]
L["Torghast"] = "Torghast"
L["Total Duration"] = "Duration Totale"
--[[Translation missing --]]
L["Total Earned in this Season"] = "Total Earned in this Season"
--[[Translation missing --]]
L["Total Essence"] = "Total Essence"
--[[Translation missing --]]
L["Total Experience"] = "Total Experience"
--[[Translation missing --]]
L["Total Match Count"] = "Total Match Count"
--[[Translation missing --]]
L["Total Reputation"] = "Total Reputation"
--[[Translation missing --]]
L["Total Stacks"] = "Total Stacks"
--[[Translation missing --]]
L["Total stacks over all matches"] = "Total stacks over all matches"
--[[Translation missing --]]
L["Total Stages"] = "Total Stages"
--[[Translation missing --]]
L["Total Unit Count"] = "Total Unit Count"
L["Total Units"] = "Units Total"
L["Totem"] = "Totem"
L["Totem #%i"] = "Totem #%i"
--[[Translation missing --]]
L["Totem Icon"] = "Totem Icon"
L["Totem Name"] = "Nom Totem"
--[[Translation missing --]]
L["Totem Name Pattern Match"] = "Totem Name Pattern Match"
L["Totem Number"] = "Numro du Totem"
L["Track Cooldowns"] = "Suivre les temps de recharge "
L["Tracking Charge %i"] = "Suivi de charge %i"
L["Tracking Charge CDs"] = "Suivi des CD de charge"
L["Tracking Only Cooldown"] = "Suivi du temps de recharge"
L["Transmission error"] = "Erreur de transmission"
L["Trigger"] = "Dclencheur"
--[[Translation missing --]]
L["Trigger %i"] = "Trigger %i"
--[[Translation missing --]]
L["Trigger %s"] = "Trigger %s"
L["Trigger 1"] = "Dclencheur 1"
L["Trigger State Updater (Advanced)"] = [=[
Mise  jour de l'tat du dclencheur (Avanc)]=]
L["Trigger Update"] = "Mise--jour du dclencheur"
L["Trigger:"] = "Dclencheur :"
--[[Translation missing --]]
L["Trivial (Low Level)"] = "Trivial (Low Level)"
L["True"] = "Vrai"
--[[Translation missing --]]
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "Trying to repair broken conditions in %s likely caused by a WeakAuras bug."
--[[Translation missing --]]
L["Twin Emperors"] = "Twin Emperors"
L["Type"] = "Type"
--[[Translation missing --]]
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."
L["Unaffected"] = "Non-affect"
L["Undefined"] = "Non-dfini"
--[[Translation missing --]]
L["Unholy"] = "Unholy"
--[[Translation missing --]]
L["Unholy Rune #1"] = "Unholy Rune #1"
--[[Translation missing --]]
L["Unholy Rune #2"] = "Unholy Rune #2"
L["Unit"] = "Unit"
L["Unit Characteristics"] = "Caractristique d'unit"
L["Unit Destroyed"] = "Unit dtruite"
L["Unit Died"] = "Unit morte"
--[[Translation missing --]]
L["Unit Dissipates"] = "Unit Dissipates"
--[[Translation missing --]]
L["Unit Frame"] = "Unit Frame"
L["Unit Frames"] = "Cadre d'unit"
L["Unit is Unit"] = "L'unit est l'unit"
L["Unit Name"] = "Nom de l'Unit"
--[[Translation missing --]]
L["Unit Name/Realm"] = "Unit Name/Realm"
L["Units Affected"] = "Units Concerns"
--[[Translation missing --]]
L["Units of affected Players in a table format"] = "Units of affected Players in a table format"
--[[Translation missing --]]
L["Units of unaffected Players in a table format"] = "Units of unaffected Players in a table format"
--[[Translation missing --]]
L["Unknown action %q"] = "Unknown action %q"
--[[Translation missing --]]
L["Unknown feature %q"] = "Unknown feature %q"
--[[Translation missing --]]
L["unknown location"] = "unknown location"
L["Unlimited"] = "Illimit"
--[[Translation missing --]]
L["Untrigger %s"] = "Untrigger %s"
L["Up"] = "Haut"
L["Up, then Centered Horizontal"] = "Haut, puis centrer horizontalement"
L["Up, then Left"] = "Haut, puis gauche"
L["Up, then Right"] = "Haut, puis droite"
--[[Translation missing --]]
L["Update Position"] = "Update Position"
L["Usage:"] = "Utilisation:"
L["Use /wa minimap to show the minimap icon again."] = "Utilisez /wa minimap pour afficher  nouveau licne de la mini-carte."
L["Use Custom Color"] = "Utiliser couleur personnalise"
--[[Translation missing --]]
L["Use Legacy floor rounding"] = "Use Legacy floor rounding"
--[[Translation missing --]]
L["Use Texture"] = "Use Texture"
--[[Translation missing --]]
L["Use Watched Faction"] = "Use Watched Faction"
--[[Translation missing --]]
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "L'utilisation de WeakAuras.clones est obsolte. Utilisez plutt WeakAuras.GetRegion(id, cloneId)."
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "L'utilisation de WeakAuras.regions est obsolte. Utilisez plutt WeakAuras.GetRegion(id)."
L["Vaelastrasz the Corrupt"] = "Vaelastrasz le Corrompu"
L["Versatility (%)"] = "Polyvalence (%)"
L["Versatility Rating"] = "Score de Polyvalence"
L["Vertical"] = "Verticale"
L["Viscidus"] = "Viscidus"
L["Visibility"] = "Visibilit"
L["Visions of N'Zoth"] = "Visions de N'Zoth"
--[[Translation missing --]]
L["Warband Quantity Total"] = "Warband Quantity Total"
--[[Translation missing --]]
L["Warband Transfer Percentage"] = "Warband Transfer Percentage"
--[[Translation missing --]]
L["Warband Transferred Quantity"] = "Warband Transferred Quantity"
L["Warfront (Heroic)"] = "Front de guerre (Hroque)"
L["Warfront (Normal)"] = "Front de guerre (Normal)"
L["Warlords of Draenor"] = "Warlords of Draenor"
L["Warning"] = "Attention"
--[[Translation missing --]]
L["Warning for unknown aura:"] = "Warning for unknown aura:"
--[[Translation missing --]]
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = "Avertissement : Les auras  balayage complet vrifiant  la fois le nom et l'identifiant du sort ne peuvent pas tre converties."
--[[Translation missing --]]
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."
--[[Translation missing --]]
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = "Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."
--[[Translation missing --]]
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"
--[[Translation missing --]]
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."
--[[Translation missing --]]
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=]
--[[Translation missing --]]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."
--[[Translation missing --]]
L["WeakAuras Profiling"] = "WeakAuras Profiling"
--[[Translation missing --]]
L["WeakAuras Profiling Report"] = "WeakAuras Profiling Report"
--[[Translation missing --]]
L["WeakAuras Version: %s"] = "WeakAuras Version: %s"
L["Weapon"] = "Arme"
L["Weapon Enchant"] = "Enchantement d'arme"
--[[Translation missing --]]
L["Weapon Enchant / Fishing Lure"] = "Weapon Enchant / Fishing Lure"
L["Whisper"] = "Chuchoter"
L["Width"] = "Largeur"
L["Wobble"] = "Osciller"
L["World Boss"] = "Boss de Monde"
--[[Translation missing --]]
L["World Bosses"] = "World Bosses"
L["Wrap"] = "Emballage, absorbe"
--[[Translation missing --]]
L["Wrath of the Lich King"] = "Wrath of the Lich King"
--[[Translation missing --]]
L["Writing to the WeakAuras table is not allowed."] = "Writing to the WeakAuras table is not allowed."
L["X-Offset"] = "Dcalage X"
L["Yell"] = "Crier"
L["Y-Offset"] = "Dcalage Y"
--[[Translation missing --]]
L["You have new auras ready to be installed!"] = "You have new auras ready to be installed!"
--[[Translation missing --]]
L["Your next encounter will automatically be profiled."] = "Your next encounter will automatically be profiled."
--[[Translation missing --]]
L["Your next instance of combat will automatically be profiled."] = "Your next instance of combat will automatically be profiled."
--[[Translation missing --]]
L["Your scheduled automatic profile has been cancelled."] = "Your scheduled automatic profile has been cancelled."
--[[Translation missing --]]
L["Your threat as a percentage of the tank's current threat."] = "Your threat as a percentage of the tank's current threat."
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "Votre menace sur le monstre en pourcentage du montant requis pour attirer l'aggro. Monte l'aggro  100."
L["Your total threat on the mob."] = "Votre menace totale sur le monstre."
L["Zone Group ID"] = "Zone Groupe ID"
L["Zone ID"] = "Zone ID"
L["Zone Name"] = "Nom de la zone"
L["Zoom"] = "Zoom"
--[[Translation missing --]]
L["Zoom Animation"] = "Zoom Animation"
L["Zul'Gurub"] = "Zul'Gurub"



-- ========================================
-- File: WeakAuras/Locales/itIT.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "itIT" then
  return
end

local L = WeakAuras.L

-- WeakAuras
--[[Translation missing --]]
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
L["%s Overlay Color"] = "%s Colore Overlay"
L["* Suffix"] = "* Suffisso"
L["/wa help - Show this message"] = "/wa help - Mostra questo messaggio"
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - Mostra/Nascondi l'icona della minimappa"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - Mostra i risultati del pi recente profiling"
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart - Inizia il profiling. Si pu includere una durata in secondi dopo la quale il profiling termina automaticamente. Per profilare il prossimo combattimento, passare un argomento ''combat'' o ''encounter''."
L["/wa pstop - Finish profiling"] = "/wa pstop - Termina il profiling"
L["/wa repair - Repair tool"] = "/wa riparazione - Strumento di riparazione"
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55fClick Sinistro|r per mostrare/nascondere la finestra principale."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55fClick Centrale|r per mostrare/nascondere l'icona della minimappa."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55fFare clic con il pulsante destro del mouse|r per attivare/disattivare la finestra di profilazione delle prestazioni."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fShift Click|r per mettere in pausa l'addon."
--[[Translation missing --]]
L["|cffff0000deprecated|r"] = "|cffff0000deprecated|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000Not|r Bonus Id oggetto equipaggiato"
L["|cFFFF0000Not|r Item Equipped"] = "|cFFFF0000Not|r Oggetto Equipaggiato "
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000Not|r Nome Giocatore/Reame"
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000Not|r Incantesimo Conosciuto"
--[[Translation missing --]]
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=]
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00Opzioni Extra:|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00Opzioni Extra:|r Nessuna"
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = " |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r e |cff00ff00Pet|r corrispondono direttamente a quei singoli unitID.   |cff00ff00Unit specifica|r consente di fornire uno specifico ID unit valido da guardare.  |cffff0000Nota|r: il gioco non attiver eventi per tutti gli unitID validi, rendendone alcuni non tracciabili da questa attivazione.   |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r e |cffffff00Nameplate|r possono corrispondere a pi ID unit corrispondenti.   |cffffff00Smart Group|r si adatta al tipo di gruppo corrente, abbinando solo il \"giocatore\" in modalit solista, le unit \"party\" (incluso il \"giocatore\") in un party o le unit \"raid\" in un raid.  |cffffff00*|r Le impostazioni dell'unit gialla creeranno cloni per ciascuna unit corrispondente mentre questa attivazione fornisce informazioni dinamiche all'aura."
L["1. Profession 1. Accessory"] = "1. Professione 1. Accessorio"
L["1. Profession 2. Accessory"] = "1. Professione 2. Accessorio"
L["1. Professsion Tool"] = "1. Strumento Professione "
L["10 Man Raid"] = "Incursione da 10 giocatori"
L["10 Player Raid"] = "Raid da 10 giocatori"
L["10 Player Raid (Heroic)"] = "Raid da 10 giocatori (Eroico)"
L["10 Player Raid (Normal)"] = "Raid da 10 giocatori (Normale)"
L["2. Profession 1. Accessory"] = "2. Professione 1. Accessorio"
L["2. Profession 2. Accessory"] = "2. Professione 2. Accessorio"
L["2. Professsion Tool"] = "2. Strumento Professione"
L["20 Man Raid"] = "incursione da 20 giocatori"
L["20 Player Raid"] = "Raid da 20 giocatori"
L["25 Man Raid"] = "Incursione da 25 giocatori"
L["25 Player Raid"] = "Raid da 25 giocatori"
L["25 Player Raid (Heroic)"] = "Raid da 25 giocatori (Eroico)"
L["25 Player Raid (Normal)"] = "Raid da 25 giocatori (Normale)"
L["40 Man Raid"] = "incursione da 40 giocatori"
L["40 Player Raid"] = "Raid da 40 giocatori"
L["5 Man Dungeon"] = "Spedizione da 5 giocatori"
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = "Una panoramica dettagliata delle tue aure e dei sistemi WeakAuras, Copia l'intero testo su Discord di Weakaura se hai bisogno di assistenza."
--[[Translation missing --]]
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."
L["Abbreviate"] = "Abbreviare"
L["AbbreviateLargeNumbers (Blizzard)"] = "AbbreviareGrandiNumeri (Blizzard)"
L["AbbreviateNumbers (Blizzard)"] = "Abbreviare i numeri (Blizzard)"
L["Absorb"] = "Assorbimento"
--[[Translation missing --]]
L["Absorb and Healing"] = "Absorb and Healing"
L["Absorb Heal Overlay"] = "Assorbe la copertura di guarigione"
--[[Translation missing --]]
L["Absorb Overlay"] = "Absorb Overlay"
L["Absorbed"] = "Assorbito"
L["Action Button Glow"] = "Bagliore Pulsante Azioni"
L["Actions"] = "Azioni"
L["Active"] = "Attivo"
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Componente aggiuntivo mod boss attivo: |cFFffcc00BigWigs|r Nota: Questa attivazione utilizzer BigWigs o DBM, in quest'ordine se entrambi sono installati."
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "Componente aggiuntivo mod boss attivo: |cFFffcc00DBM|r Nota: questa attivazione utilizzer BigWigs o DBM, in quest'ordine se entrambi sono installati."
L["Add"] = "Aggiungi"
L["Add Missing Auras"] = "Aggiungi Aure Mancanti"
L["Advanced Caster's Target Check"] = "Controllo del bersaglio dell'incantatore avanzato"
L["Affected"] = "Affetto"
L["Affected Unit Count"] = "Conta Unit Interessate"
--[[Translation missing --]]
L["Afk"] = "Afk"
L["Aggro"] = "Aggro"
L["Agility"] = "Agilit"
L["Ahn'Qiraj"] = "Ahn'Qiraj"
L["Alert Type"] = "Tipo di Allerta"
L["Alive"] = "Vivo"
L["All"] = "Tutto"
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "Anche tutti i bambini di quest'aura non verranno caricati, per ridurre al minimo la possibilit di ulteriore corruzione."
--[[Translation missing --]]
L["All States table contains a non table at key: '%s'."] = "All States table contains a non table at key: '%s'."
L["All Triggers"] = "Tutte le attivazioni"
L["Alliance"] = "Alleanza"
L["Allow partial matches"] = "Permetti corrispondenze parziali"
L["Alpha"] = "Alfa"
L["Alternate Power"] = "Risorse Speciali"
L["Always"] = "Sempre"
L["Always active trigger"] = "Innesco sempre attivo"
L["Always include realm"] = "Includi sempre il reame"
L["Always True"] = "Sempre Vero"
L["Amount"] = "Quantit"
L["Anchoring"] = "Ancoraggio"
L["And Talent"] = "E Talento "
L["Angle and Radius"] = "Angolo e Raggio"
L["Animations"] = "Animazioni"
L["Anticlockwise"] = "Antiorario"
--[[Translation missing --]]
L["Anub'Rekhan"] = "Anub'Rekhan"
L["Any"] = "Qualsiasi"
L["Any Triggers"] = "Qualsiasi attivazione"
--[[Translation missing --]]
L["AOE"] = "AOE"
L["Arcane Resistance"] = "Resistenza Arcana"
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = "Vuoi eseguire lo strumento di riparazione |cffff0000EXPERIMENTAL|r? Ci sovrascriver tutte le modifiche apportate dall'ultimo aggiornamento del database. Ultimo aggiornamento: %s"
L["Arena"] = "Arena"
L["Armor (%)"] = "Armatura (%)"
L["Armor against Target (%)"] = "Armatura contro il bersaglio (%)"
L["Armor Rating"] = "Grado di armatura"
--[[Translation missing --]]
L["Array"] = "Array"
L["Ascending"] = "Crescente"
L["Assigned Role"] = "Ruolo assegnato"
L["Assigned Role Icon"] = "Icona del ruolo assegnato"
--[[Translation missing --]]
L["Assist"] = "Assist"
--[[Translation missing --]]
L["Assisted Combat Next Cast"] = "Assisted Combat Next Cast"
L["At Least One Enemy"] = "Almeno un nemico"
L["At missing Value"] = "Al valore mancante"
L["At Percent"] = "In Percentuale"
L["At Value"] = "Al valore"
L["At War"] = "In guerra"
L["Attach to End"] = "Aggiungi alla Fine"
--[[Translation missing --]]
L["Attach to End, backwards"] = "Attach to End, backwards"
--[[Translation missing --]]
L["Attach to Point"] = "Attach to Point"
L["Attach to Start"] = "Aggiungi all'inizio"
L["Attack Power"] = "Potenza d'attacco"
L["Attackable"] = "Attaccabile"
L["Attackable Target"] = "Bersaglio attaccabile"
L["Aura"] = "Aura"
--[[Translation missing --]]
L["Aura '%s': %s"] = "Aura '%s': %s"
L["Aura Applied"] = "Aura applicata"
L["Aura Applied Dose"] = "Parte di aura applicata"
L["Aura Broken"] = "Aura finita"
L["Aura Broken Spell"] = "Aura di magia finita"
L["Aura is using deprecated SetDurationInfo"] = "Aura utilizza SetDurationInfo deprecato"
L["Aura loaded"] = "Aura caricata"
L["Aura Name"] = "Nome Aura"
L["Aura Names"] = "Nomi Aura"
L["Aura Refresh"] = "Aura rinnovata"
L["Aura Removed"] = "Aura rimossa"
L["Aura Removed Dose"] = "Parte di aura rimossa"
L["Aura Stack"] = "Aura Stack"
L["Aura Type"] = "Tipo di aura"
L["Aura Version: %s"] = "Versione dell'aura: %s"
L["Aura(s) Found"] = "Aura(e) Trovata(e)"
L["Aura(s) Missing"] = "Aura(e) Mancante(i)"
L["Aura:"] = "Aura:"
L["Auras"] = "Aure"
L["Auras:"] = "Aure:"
L["Author Options"] = "Opzioni Autore"
--[[Translation missing --]]
L["Auto"] = "Auto"
--[[Translation missing --]]
L["Autocast Shine"] = "Autocast Shine"
L["Automatic"] = "Automatico"
L["Automatic Length"] = "Lunghezza Automatica"
L["Automatic Rotation"] = "Rotazione Automatica"
L["Available features: %s"] = "Funzionalit disponibili: %s"
L["Avoidance (%)"] = "Elusione (%)"
L["Avoidance Rating"] = "Grado di Elusione"
L["Ayamiss the Hunter"] = "Ayamiss il Cacciatore"
--[[Translation missing --]]
L["Azuregos"] = "Azuregos"
L["Back and Forth"] = "Avanti e indietro"
L["Background"] = "Sfondo"
L["Background Color"] = "Colore Sfondo"
--[[Translation missing --]]
L["Balnazzar"] = "Balnazzar"
L["Bar Color/Gradient Start"] = "Inizio Colore/Inclinazione della Barra"
--[[Translation missing --]]
L["Bar enabled in BigWigs settings"] = "Bar enabled in BigWigs settings"
--[[Translation missing --]]
L["Bar enabled in Boss Mod addon settings"] = "Bar enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Bar enabled in DBM settings"] = "Bar enabled in DBM settings"
--[[Translation missing --]]
L["Bar Texture"] = "Bar Texture"
--[[Translation missing --]]
L["Bar Type"] = "Bar Type"
L["Baron Geddon"] = "Barone Geddon"
--[[Translation missing --]]
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "Sussurri di Battle.net"
L["Battleground"] = "Campo di battaglia"
L["Battleguard Sartura"] = "Guardia di battaglia Sartura"
--[[Translation missing --]]
L["Beastmaster"] = "Beastmaster"
--[[Translation missing --]]
L["Beatrix"] = "Beatrix"
--[[Translation missing --]]
L["BG>Raid>Party>Say"] = "BG>Raid>Party>Say"
--[[Translation missing --]]
L["BG-System Alliance"] = "BG-System Alliance"
--[[Translation missing --]]
L["BG-System Horde"] = "BG-System Horde"
--[[Translation missing --]]
L["BG-System Neutral"] = "BG-System Neutral"
L["Big Number"] = "Grande Numero"
L["BigWigs Addon"] = "BigWigs Add-on"
L["BigWigs Message"] = "Messaggio di BigWigs"
--[[Translation missing --]]
L["BigWigs Stage"] = "BigWigs Stage"
L["BigWigs Timer"] = "Timer di BigWigs"
L["Black Wing Lair"] = "Sotterranei dell'Ala Nera"
--[[Translation missing --]]
L["Bleed"] = "Bleed"
L["Blizzard Combat Text"] = "Testo di combattimento Blizzard"
L["Blizzard Cooldown Reduction"] = "Riduzione Cooldown Blizzard"
L["Block"] = "Bloccare"
L["Block (%)"] = "Blocco (%)"
L["Block against Target (%)"] = "Blocco rispetto al target (%)"
L["Block Value"] = "Valore di Blocco"
L["Blocked"] = "Bloccato"
L["Blood"] = "Sangue"
L["Blood Rune #1"] = "Runa del sangue n. 1"
L["Blood Rune #2"] = "Runa del sangue n.2"
L["Bloodlord Mandokir"] = "Signore del Sangue Mandokir"
L["Bonus Reputation Gain"] = "Guadagno di reputazione bonus"
L["Border"] = "Bordo"
L["Boss"] = "Boss"
L["Boss Emote"] = "Boss Emote"
--[[Translation missing --]]
L["Boss Mod Announce"] = "Boss Mod Announce"
--[[Translation missing --]]
L["Boss Mod Stage"] = "Boss Mod Stage"
--[[Translation missing --]]
L["Boss Mod Stage (Event)"] = "Boss Mod Stage (Event)"
--[[Translation missing --]]
L["Boss Mod Timer"] = "Boss Mod Timer"
--[[Translation missing --]]
L["Boss Whisper"] = "Boss Whisper"
L["Bottom"] = "Basso"
L["Bottom Left"] = "Basso a sinistra"
L["Bottom Right"] = "Basso a destra"
L["Bottom to Top"] = "Basso verso l'alto"
L["Bounce"] = "Balzo"
L["Bounce with Decay"] = "Bounce with Decay"
--[[Translation missing --]]
L["Break"] = "Break"
--[[Translation missing --]]
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers (Blizzard)"
L["Broodlord Lashlayer"] = "Signore della Progenie Lashlayer"
L["Buff"] = "Buff"
--[[Translation missing --]]
L["Buff/Debuff"] = "Buff/Debuff"
L["Buffed/Debuffed"] = "Buffato/Debuffato"
--[[Translation missing --]]
L["Burning Crusade"] = "Burning Crusade"
--[[Translation missing --]]
L["Buru the Gorger"] = "Buru the Gorger"
--[[Translation missing --]]
L["Caldoran"] = "Caldoran"
L["Callback function"] = "Funzione di richiamata"
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "Pu essere usato per esempio per controllare se \"boss1target\" sia uguale a \"player\"."
L["Cancel"] = "Cancella"
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "Non  possibile modificare il frame protetto durante il blocco del combattimento. Trova ulteriori informazioni: https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "Impossibile programmare il timer con %i, a causa di un bug di World of Warcraft con tempi di attivit elevati del computer.  (Tempo di attivit: %i).  Riavvia il computer."
L["Capped"] = "Limitato"
L["Capped at Season Max"] = "Limitato alla stagione massima"
L["Capped at Weekly Max"] = "Limitato al massimo settimanale"
L["Cast"] = "Cast"
L["Cast Bar"] = "Barra del cast"
L["Cast Failed"] = "Cast fallito"
L["Cast Start"] = "Inizio cast"
L["Cast Success"] = "Cast terminato con successo"
L["Cast Type"] = "Tipo di cast"
--[[Translation missing --]]
L["Caster"] = "Caster"
L["Caster Name"] = "Nome del Caster"
L["Caster Realm"] = "Reame del Caster"
L["Caster Unit"] = "Unit del Caster"
L["Casters Name/Realm"] = "Nome/Reame dei Caster"
L["Caster's Target"] = "Bersaglio dei Caster"
--[[Translation missing --]]
L["Cataclysm"] = "Cataclysm"
--[[Translation missing --]]
L["Ceil"] = "Ceil"
L["Center"] = "Centro"
L["Center, then alternating bottom and top"] = "Al centro, poi alternando il basso e l'alto"
L["Center, then alternating left and right"] = "Al centro, poi alternando sinistra e destra"
L["Center, then alternating right and left"] = "Al centro, poi alternando destra e sinistra"
L["Center, then alternating top and bottom"] = "Al centro, poi alternando la parte superiore e quella inferiore"
L["Centered Horizontal"] = "Centrato orizzontalmente"
L["Centered Horizontal, then Centered Vertical"] = "Centrato orizzontalmente, poi centrato verticalmente"
L["Centered Horizontal, then Down"] = "Centrato orizzontalmente, poi in basso"
L["Centered Horizontal, then Up"] = "Centrato orizzontalmente, poi in alto"
L["Centered Vertical"] = "Centrato verticalmente"
L["Centered Vertical, then Centered Horizontal"] = "Centrato verticalmente, poi centrato orizzontalmente "
L["Centered Vertical, then Left"] = "Centrato verticalmente, poi a sinistra"
L["Centered Vertical, then Right"] = "Centrato verticalmente, poi a destra"
L["Changed"] = "Modificato"
L["Channel"] = "Canale"
L["Channel (Spell)"] = "Canale (Magia)"
--[[Translation missing --]]
L["Character GUID"] = "Character GUID"
--[[Translation missing --]]
L["Character Name"] = "Character Name"
L["Character Stats"] = "Statistiche del Personaggio "
--[[Translation missing --]]
L["Character Transferred Quantity"] = "Character Transferred Quantity"
L["Character Type"] = "Tipo di carattere"
L["Charge gained/lost"] = "Carica guadagnata/persa"
--[[Translation missing --]]
L["Charged Combo Points"] = "Charged Combo Points"
L["Charges"] = "Cariche"
L["Charges Changed Event"] = "Evento modificato caricato"
L["Charging"] = "In carica"
L["Chat Frame"] = "Cornice di chat"
L["Chat Message"] = "Messaggio di chat"
L["Check if a single talent match a Rank"] = "Controlla se un singolo talento corrisponde a un grado"
L["Check nameplate's target every 0.2s"] = "Controllare le barre del bersaglio ogni 0,2 s"
--[[Translation missing --]]
L["Chromaggus"] = "Chromaggus"
L["Circle"] = "Cerchio"
--[[Translation missing --]]
L["Circular Texture"] = "Circular Texture"
L["Clamp"] = "Morso"
L["Class"] = "Classe"
L["Class and Specialization"] = "Classe e Specializzazione"
--[[Translation missing --]]
L["Classic"] = "Classic"
L["Classification"] = "Classificazione"
L["Clockwise"] = "Senso Orario"
--[[Translation missing --]]
L["Clone per Character"] = "Clone per Character"
L["Clone per Event"] = "Clona per evento"
L["Clone per Match"] = "Clona per partita"
--[[Translation missing --]]
L["Coin Precision"] = "Coin Precision"
L["Color"] = "Colore"
L["Color Animation"] = "Animazione a colori"
L["Combat Log"] = "Registro di combattimento"
--[[Translation missing --]]
L["Communities"] = "Communities"
--[[Translation missing --]]
L["Condition Custom Test"] = "Condition Custom Test"
L["Conditions"] = "Condizioni"
L["Contains"] = "Contiene"
L["Continuously update Movement Speed"] = "Aggiorna continuamente la velocit di movimento"
--[[Translation missing --]]
L["Cooldown"] = "Cooldown"
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "Le barre di Cooldown mostrano il tempo trascorso prima che un'abilit sia pronta per essere utilizzata, BigWigs le prefissa con '~'"
--[[Translation missing --]]
L["Cooldown Progress (Item)"] = "Cooldown Progress (Item)"
--[[Translation missing --]]
L["Cooldown Progress (Slot)"] = "Cooldown Progress (Slot)"
L["Cooldown Ready Event"] = "Cooldiwn evento pronto"
L["Cooldown Ready Event (Item)"] = "Cooldown evento pronto (Oggetto)"
L["Cooldown Ready Event (Slot)"] = "Cooldown evento pronto (Slot)"
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "La riduzione del Cooldown modifica la durata dei secondi invece di mostrare i secondi in tempo reale."
L["Cooldown/Charges/Count"] = "Cooldown/Cariche/Conteggio "
--[[Translation missing --]]
L["Copper"] = "Copper"
L["Could not load WeakAuras Archive, the addon is %s"] = "Impossibile caricare l'archivio WeakAuras, il componente aggiuntivo  %s"
L["Count"] = "Conteggio "
L["Counter Clockwise"] = "Conteggio Antiorario"
L["Create"] = "Crea"
--[[Translation missing --]]
L["Creature Family"] = "Creature Family"
--[[Translation missing --]]
L["Creature Family Name"] = "Creature Family Name"
--[[Translation missing --]]
L["Creature Type"] = "Creature Type"
--[[Translation missing --]]
L["Creature Type Name"] = "Creature Type Name"
L["Critical"] = "Critico"
L["Critical (%)"] = "Critico (%)"
L["Critical Rating"] = "Grado del Critico"
--[[Translation missing --]]
L["Crop X"] = "Crop X"
--[[Translation missing --]]
L["Crop Y"] = "Crop Y"
--[[Translation missing --]]
L["Crowd Controlled"] = "Crowd Controlled"
L["Crushing"] = "Frantumazione "
--[[Translation missing --]]
L["C'thun"] = "C'thun"
L["Cumulated time used during profiling"] = "Tempo cumulativo utilizzato durante la profilazione"
L["Currency"] = "Corrente"
L["Current Essence"] = "Essenza Attuale"
L["Current Experience"] = "Esperienza Attuale"
L["Current Instance"] = "Spedizione Attuale "
L["Current Movement Speed (%)"] = "Velocit di movimento attuale (%)"
L["Current Stage"] = "Stage Attuale "
L["Current Zone"] = "Zona Attuale "
L["Current Zone Group"] = "Gruppo di Zona Attuale "
L["Curse"] = "Maledizione"
--[[Translation missing --]]
L["Custom"] = "Custom"
--[[Translation missing --]]
L["Custom Action"] = "Custom Action"
--[[Translation missing --]]
L["Custom Anchor"] = "Custom Anchor"
--[[Translation missing --]]
L["Custom Check"] = "Custom Check"
--[[Translation missing --]]
L["Custom Color"] = "Custom Color"
--[[Translation missing --]]
L["Custom Condition Code"] = "Custom Condition Code"
--[[Translation missing --]]
L["Custom Configuration"] = "Custom Configuration"
--[[Translation missing --]]
L["Custom Fade Animation"] = "Custom Fade Animation"
--[[Translation missing --]]
L["Custom Function"] = "Custom Function"
--[[Translation missing --]]
L["Custom Grow"] = "Custom Grow"
--[[Translation missing --]]
L["Custom Sort"] = "Custom Sort"
--[[Translation missing --]]
L["Custom Text Function"] = "Custom Text Function"
--[[Translation missing --]]
L["Custom Trigger Combination"] = "Custom Trigger Combination"
--[[Translation missing --]]
L["Custom Variables"] = "Custom Variables"
--[[Translation missing --]]
L["Damage"] = "Damage"
--[[Translation missing --]]
L["Damage Shield"] = "Damage Shield"
--[[Translation missing --]]
L["Damage Shield Missed"] = "Damage Shield Missed"
--[[Translation missing --]]
L["Damage Split"] = "Damage Split"
--[[Translation missing --]]
L["DBM Announce"] = "DBM Announce"
--[[Translation missing --]]
L["DBM Stage"] = "DBM Stage"
--[[Translation missing --]]
L["DBM Timer"] = "DBM Timer"
--[[Translation missing --]]
L["Dead"] = "Dead"
--[[Translation missing --]]
L["Death"] = "Death"
L["Death Knight Rune"] = "Rune del cavaliere della morte"
--[[Translation missing --]]
L["Debuff"] = "Debuff"
--[[Translation missing --]]
L["Debuff Class"] = "Debuff Class"
--[[Translation missing --]]
L["Debuff Class Icon"] = "Debuff Class Icon"
--[[Translation missing --]]
L["Debuff Type"] = "Debuff Type"
--[[Translation missing --]]
L["Debug Log contains more than 1000 entries"] = "Debug Log contains more than 1000 entries"
--[[Translation missing --]]
L["Debug Logging enabled"] = "Debug Logging enabled"
--[[Translation missing --]]
L["Debug Logging enabled for '%s'"] = "Debug Logging enabled for '%s'"
--[[Translation missing --]]
L["Defensive Stats"] = "Defensive Stats"
--[[Translation missing --]]
L["Deflect"] = "Deflect"
--[[Translation missing --]]
L["Delve"] = "Delve"
--[[Translation missing --]]
L["Desaturate"] = "Desaturate"
--[[Translation missing --]]
L["Desaturate Background"] = "Desaturate Background"
--[[Translation missing --]]
L["Desaturate Foreground"] = "Desaturate Foreground"
--[[Translation missing --]]
L["Descending"] = "Descending"
L["Description"] = "Descrizione"
--[[Translation missing --]]
L["Dest Raid Mark"] = "Dest Raid Mark"
--[[Translation missing --]]
L["Destination Affiliation"] = "Destination Affiliation"
--[[Translation missing --]]
L["Destination GUID"] = "Destination GUID"
--[[Translation missing --]]
L["Destination Info"] = "Destination Info"
--[[Translation missing --]]
L["Destination Name"] = "Destination Name"
--[[Translation missing --]]
L["Destination NPC Id"] = "Destination NPC Id"
--[[Translation missing --]]
L["Destination Object Type"] = "Destination Object Type"
--[[Translation missing --]]
L["Destination Reaction"] = "Destination Reaction"
--[[Translation missing --]]
L["Destination Unit"] = "Destination Unit"
--[[Translation missing --]]
L["Destination unit's raid mark index"] = "Destination unit's raid mark index"
--[[Translation missing --]]
L["Destination unit's raid mark texture"] = "Destination unit's raid mark texture"
--[[Translation missing --]]
L["Difficulty"] = "Difficulty"
--[[Translation missing --]]
L["Disable Spell Known Check"] = "Disable Spell Known Check"
--[[Translation missing --]]
L["Disabled"] = "Disabled"
--[[Translation missing --]]
L["Disabled feature %q"] = "Disabled feature %q"
--[[Translation missing --]]
L["Disabled Spell Known Check"] = "Disabled Spell Known Check"
--[[Translation missing --]]
L["Discovered"] = "Discovered"
--[[Translation missing --]]
L["Disease"] = "Disease"
--[[Translation missing --]]
L["Dispel"] = "Dispel"
--[[Translation missing --]]
L["Dispel Failed"] = "Dispel Failed"
--[[Translation missing --]]
L["Display"] = "Display"
L["Distance"] = "Distanza"
--[[Translation missing --]]
L["Do Not Disturb"] = "Do Not Disturb"
--[[Translation missing --]]
L["Dodge"] = "Dodge"
--[[Translation missing --]]
L["Dodge (%)"] = "Dodge (%)"
--[[Translation missing --]]
L["Dodge Rating"] = "Dodge Rating"
--[[Translation missing --]]
L["Down"] = "Down"
--[[Translation missing --]]
L["Down, then Centered Horizontal"] = "Down, then Centered Horizontal"
--[[Translation missing --]]
L["Down, then Left"] = "Down, then Left"
--[[Translation missing --]]
L["Down, then Right"] = "Down, then Right"
--[[Translation missing --]]
L["Dragonflight"] = "Dragonflight"
--[[Translation missing --]]
L["Drain"] = "Drain"
--[[Translation missing --]]
L["Dropdown Menu"] = "Dropdown Menu"
--[[Translation missing --]]
L["Dumping table"] = "Dumping table"
--[[Translation missing --]]
L["Dungeon (Celestial)"] = "Dungeon (Celestial)"
--[[Translation missing --]]
L["Dungeon (Heroic)"] = "Dungeon (Heroic)"
--[[Translation missing --]]
L["Dungeon (Mythic)"] = "Dungeon (Mythic)"
--[[Translation missing --]]
L["Dungeon (Mythic+)"] = "Dungeon (Mythic+)"
--[[Translation missing --]]
L["Dungeon (Normal)"] = "Dungeon (Normal)"
--[[Translation missing --]]
L["Dungeon (Timewalking)"] = "Dungeon (Timewalking)"
--[[Translation missing --]]
L["Dungeons"] = "Dungeons"
--[[Translation missing --]]
L["Durability Damage"] = "Durability Damage"
--[[Translation missing --]]
L["Durability Damage All"] = "Durability Damage All"
--[[Translation missing --]]
L["Duration"] = "Duration"
--[[Translation missing --]]
L["Duration Function"] = "Duration Function"
--[[Translation missing --]]
L["Duration Function (fallback state)"] = "Duration Function (fallback state)"
--[[Translation missing --]]
L["Ease In"] = "Ease In"
--[[Translation missing --]]
L["Ease In and Out"] = "Ease In and Out"
--[[Translation missing --]]
L["Ease Out"] = "Ease Out"
--[[Translation missing --]]
L["Ebonroc"] = "Ebonroc"
--[[Translation missing --]]
L["Eclipse Direction"] = "Eclipse Direction"
--[[Translation missing --]]
L["Edge"] = "Edge"
--[[Translation missing --]]
L["Edge of Madness"] = "Edge of Madness"
--[[Translation missing --]]
L["Effective Spell Id"] = "Effective Spell Id"
--[[Translation missing --]]
L["Elide"] = "Elide"
--[[Translation missing --]]
L["Elite"] = "Elite"
--[[Translation missing --]]
L["Emote"] = "Emote"
--[[Translation missing --]]
L["Empower Cast End"] = "Empower Cast End"
--[[Translation missing --]]
L["Empower Cast Interrupt"] = "Empower Cast Interrupt"
--[[Translation missing --]]
L["Empower Cast Start"] = "Empower Cast Start"
--[[Translation missing --]]
L["Empowered"] = "Empowered"
--[[Translation missing --]]
L["Empowered 1"] = "Empowered 1"
--[[Translation missing --]]
L["Empowered 2"] = "Empowered 2"
--[[Translation missing --]]
L["Empowered 3"] = "Empowered 3"
--[[Translation missing --]]
L["Empowered 4"] = "Empowered 4"
--[[Translation missing --]]
L["Empowered 5"] = "Empowered 5"
--[[Translation missing --]]
L["Empowered Cast"] = "Empowered Cast"
--[[Translation missing --]]
L["Empowered Cast Fully Charged"] = "Empowered Cast Fully Charged"
--[[Translation missing --]]
L["Empowered Fully Charged"] = "Empowered Fully Charged"
--[[Translation missing --]]
L["Empty"] = "Empty"
--[[Translation missing --]]
L["Enabled feature %q"] = "Enabled feature %q"
--[[Translation missing --]]
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "Enables (incorrect) round down of seconds, which was the previous default behavior."
--[[Translation missing --]]
L["Enchant Applied"] = "Enchant Applied"
--[[Translation missing --]]
L["Enchant Found"] = "Enchant Found"
--[[Translation missing --]]
L["Enchant ID"] = "Enchant ID"
--[[Translation missing --]]
L["Enchant Missing"] = "Enchant Missing"
--[[Translation missing --]]
L["Enchant Name or ID"] = "Enchant Name or ID"
--[[Translation missing --]]
L["Enchant Removed"] = "Enchant Removed"
--[[Translation missing --]]
L["Enchanted"] = "Enchanted"
--[[Translation missing --]]
L["Encounter ID(s)"] = "Encounter ID(s)"
--[[Translation missing --]]
L["Energize"] = "Energize"
--[[Translation missing --]]
L["Enrage"] = "Enrage"
--[[Translation missing --]]
L["Enter a name or a spellId"] = "Enter a name or a spellId"
--[[Translation missing --]]
L["Entering"] = "Entering"
--[[Translation missing --]]
L["Entering/Leaving Combat"] = "Entering/Leaving Combat"
--[[Translation missing --]]
L["Entering/Leaving Encounter"] = "Entering/Leaving Encounter"
--[[Translation missing --]]
L["Entry Order"] = "Entry Order"
--[[Translation missing --]]
L["Environment Type"] = "Environment Type"
--[[Translation missing --]]
L["Environmental"] = "Environmental"
--[[Translation missing --]]
L["Equipment"] = "Equipment"
--[[Translation missing --]]
L["Equipment Set"] = "Equipment Set"
--[[Translation missing --]]
L["Equipment Set Equipped"] = "Equipment Set Equipped"
--[[Translation missing --]]
L["Equipment Slot"] = "Equipment Slot"
--[[Translation missing --]]
L["Equipped"] = "Equipped"
L["Error"] = "Errore"
--[[Translation missing --]]
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Error decoding."] = "Error decoding."
--[[Translation missing --]]
L["Error decompressing"] = "Error decompressing"
--[[Translation missing --]]
L["Error decompressing. This doesn't look like a WeakAuras import."] = "Error decompressing. This doesn't look like a WeakAuras import."
--[[Translation missing --]]
L["Error deserializing"] = "Error deserializing"
--[[Translation missing --]]
L["Error Frame"] = "Error Frame"
--[[Translation missing --]]
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "ERROR in '%s' unknown or incompatible sub element type '%s'"
--[[Translation missing --]]
L["Error in Aura '%s'"] = "Error in Aura '%s'"
--[[Translation missing --]]
L["Error not receiving display information from %s"] = "Error not receiving display information from %s"
--[[Translation missing --]]
L["Essence"] = "Essence"
--[[Translation missing --]]
L["Essence #1"] = "Essence #1"
--[[Translation missing --]]
L["Essence #2"] = "Essence #2"
--[[Translation missing --]]
L["Essence #3"] = "Essence #3"
--[[Translation missing --]]
L["Essence #4"] = "Essence #4"
--[[Translation missing --]]
L["Essence #5"] = "Essence #5"
--[[Translation missing --]]
L["Essence #6"] = "Essence #6"
--[[Translation missing --]]
L["Evade"] = "Evade"
L["Event"] = "Evento"
--[[Translation missing --]]
L["Event(s)"] = "Event(s)"
--[[Translation missing --]]
L["Every Frame"] = "Every Frame"
--[[Translation missing --]]
L["Every Frame (High CPU usage)"] = "Every Frame (High CPU usage)"
--[[Translation missing --]]
L["Evoker Essence"] = "Evoker Essence"
--[[Translation missing --]]
L["Exact Spell ID(s)"] = "Exact Spell ID(s)"
--[[Translation missing --]]
L["Execute Conditions"] = "Execute Conditions"
--[[Translation missing --]]
L["Experience (%)"] = "Experience (%)"
--[[Translation missing --]]
L["Expertise Bonus"] = "Expertise Bonus"
--[[Translation missing --]]
L["Expertise Rating"] = "Expertise Rating"
--[[Translation missing --]]
L["Extend Outside"] = "Extend Outside"
--[[Translation missing --]]
L["Extra Amount"] = "Extra Amount"
--[[Translation missing --]]
L["Extra Attacks"] = "Extra Attacks"
--[[Translation missing --]]
L["Extra Spell Id"] = "Extra Spell Id"
--[[Translation missing --]]
L["Extra Spell Name"] = "Extra Spell Name"
--[[Translation missing --]]
L["Faction"] = "Faction"
--[[Translation missing --]]
L["Faction Name"] = "Faction Name"
--[[Translation missing --]]
L["Faction Reputation"] = "Faction Reputation"
--[[Translation missing --]]
L["Fade Animation"] = "Fade Animation"
--[[Translation missing --]]
L["Fade In"] = "Fade In"
--[[Translation missing --]]
L["Fade Out"] = "Fade Out"
--[[Translation missing --]]
L["Fail Alert"] = "Fail Alert"
--[[Translation missing --]]
L["False"] = "False"
--[[Translation missing --]]
L["Fankriss the Unyielding"] = "Fankriss the Unyielding"
--[[Translation missing --]]
L["Feature %q is already disabled"] = "Feature %q is already disabled"
--[[Translation missing --]]
L["Feature %q is already enabled"] = "Feature %q is already enabled"
--[[Translation missing --]]
L["Fetch Absorb"] = "Fetch Absorb"
--[[Translation missing --]]
L["Fetch Heal Absorb"] = "Fetch Heal Absorb"
--[[Translation missing --]]
L["Fetch Legendary Power"] = "Fetch Legendary Power"
--[[Translation missing --]]
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "Fetches the name and icon of the Legendary Power that matches this bonus id."
--[[Translation missing --]]
L["Fill Area"] = "Fill Area"
--[[Translation missing --]]
L["Filter messages with format <message>"] = "Filter messages with format <message>"
--[[Translation missing --]]
L["Fire Resistance"] = "Fire Resistance"
--[[Translation missing --]]
L["Firemaw"] = "Firemaw"
--[[Translation missing --]]
L["First"] = "First"
--[[Translation missing --]]
L["First Value of Tooltip Text"] = "First Value of Tooltip Text"
--[[Translation missing --]]
L["Fixed"] = "Fixed"
--[[Translation missing --]]
L["Fixed Names"] = "Fixed Names"
--[[Translation missing --]]
L["Fixed Size"] = "Fixed Size"
--[[Translation missing --]]
L["Flamegor"] = "Flamegor"
--[[Translation missing --]]
L["Flash"] = "Flash"
--[[Translation missing --]]
L["Flex Raid"] = "Flex Raid"
--[[Translation missing --]]
L["Flip"] = "Flip"
--[[Translation missing --]]
L["Floor"] = "Floor"
--[[Translation missing --]]
L["Focus"] = "Focus"
--[[Translation missing --]]
L["Follower Dungeon"] = "Follower Dungeon"
--[[Translation missing --]]
L["Font"] = "Font"
--[[Translation missing --]]
L["Font Size"] = "Font Size"
--[[Translation missing --]]
L["Forbidden function or table: %s"] = "Forbidden function or table: %s"
--[[Translation missing --]]
L["Foreground"] = "Foreground"
--[[Translation missing --]]
L["Foreground Color"] = "Foreground Color"
L["Form"] = "Forma"
--[[Translation missing --]]
L["Format"] = "Format"
--[[Translation missing --]]
L["Format Gold"] = "Format Gold"
--[[Translation missing --]]
L["Formats |cFFFFCC00%unit|r"] = "Formats |cFFFFCC00%unit|r"
--[[Translation missing --]]
L["Formats Player's |cFFFFCC00%guid|r"] = "Formats Player's |cFFFFCC00%guid|r"
--[[Translation missing --]]
L["Forward"] = "Forward"
--[[Translation missing --]]
L["Forward, Reverse Loop"] = "Forward, Reverse Loop"
--[[Translation missing --]]
L["Fourth Value of Tooltip Text"] = "Fourth Value of Tooltip Text"
--[[Translation missing --]]
L["Frame Selector"] = "Frame Selector"
--[[Translation missing --]]
L["Frequency"] = "Frequency"
--[[Translation missing --]]
L["Friendly"] = "Friendly"
--[[Translation missing --]]
L["Friendly Fire"] = "Friendly Fire"
--[[Translation missing --]]
L["Friendship Max Rank"] = "Friendship Max Rank"
--[[Translation missing --]]
L["Friendship Rank"] = "Friendship Rank"
--[[Translation missing --]]
L["Friendship Reputation"] = "Friendship Reputation"
--[[Translation missing --]]
L["Frost"] = "Frost"
--[[Translation missing --]]
L["Frost Resistance"] = "Frost Resistance"
--[[Translation missing --]]
L["Frost Rune #1"] = "Frost Rune #1"
--[[Translation missing --]]
L["Frost Rune #2"] = "Frost Rune #2"
--[[Translation missing --]]
L["Full"] = "Full"
--[[Translation missing --]]
L["Full Region"] = "Full Region"
--[[Translation missing --]]
L["Full/Empty"] = "Full/Empty"
--[[Translation missing --]]
L["Gahz'ranka"] = "Gahz'ranka"
--[[Translation missing --]]
L["Gained"] = "Gained"
--[[Translation missing --]]
L["Garr"] = "Garr"
--[[Translation missing --]]
L["Gehennas"] = "Gehennas"
--[[Translation missing --]]
L["General"] = "General"
--[[Translation missing --]]
L["General Rajaxx"] = "General Rajaxx"
--[[Translation missing --]]
L["GetNameAndIcon Function (fallback state)"] = "GetNameAndIcon Function (fallback state)"
--[[Translation missing --]]
L["Glancing"] = "Glancing"
--[[Translation missing --]]
L["Global Cooldown"] = "Global Cooldown"
--[[Translation missing --]]
L["Glow"] = "Glow"
--[[Translation missing --]]
L["Glow External Element"] = "Glow External Element"
--[[Translation missing --]]
L["Gluth"] = "Gluth"
--[[Translation missing --]]
L["Glyph"] = "Glyph"
--[[Translation missing --]]
L["Gold"] = "Gold"
--[[Translation missing --]]
L["Golemagg the Incinerator"] = "Golemagg the Incinerator"
--[[Translation missing --]]
L["Gothik the Harvester"] = "Gothik the Harvester"
--[[Translation missing --]]
L["Gradient"] = "Gradient"
--[[Translation missing --]]
L["Gradient Enabled"] = "Gradient Enabled"
--[[Translation missing --]]
L["Gradient End"] = "Gradient End"
--[[Translation missing --]]
L["Gradient Orientation"] = "Gradient Orientation"
--[[Translation missing --]]
L["Gradient Pulse"] = "Gradient Pulse"
--[[Translation missing --]]
L["Grand Widow Faerlina"] = "Grand Widow Faerlina"
--[[Translation missing --]]
L["Grid"] = "Grid"
--[[Translation missing --]]
L["Grobbulus"] = "Grobbulus"
--[[Translation missing --]]
L["Group"] = "Group"
--[[Translation missing --]]
L["Group Arrangement"] = "Group Arrangement"
--[[Translation missing --]]
L["Group Leader/Assist"] = "Group Leader/Assist"
--[[Translation missing --]]
L["Group Size"] = "Group Size"
--[[Translation missing --]]
L["Group Type"] = "Group Type"
--[[Translation missing --]]
L["Grow"] = "Grow"
--[[Translation missing --]]
L["GTFO Alert"] = "GTFO Alert"
--[[Translation missing --]]
L["Guardian"] = "Guardian"
--[[Translation missing --]]
L["Guild"] = "Guild"
--[[Translation missing --]]
L["Hakkar"] = "Hakkar"
--[[Translation missing --]]
L["Hardcore"] = "Hardcore"
--[[Translation missing --]]
L["Has Target"] = "Has Target"
--[[Translation missing --]]
L["Has Vehicle UI"] = "Has Vehicle UI"
--[[Translation missing --]]
L["HasPet"] = "HasPet"
--[[Translation missing --]]
L["Haste (%)"] = "Haste (%)"
--[[Translation missing --]]
L["Haste Rating"] = "Haste Rating"
--[[Translation missing --]]
L["Heal"] = "Heal"
--[[Translation missing --]]
L["Heal Absorb"] = "Heal Absorb"
--[[Translation missing --]]
L["Heal Absorbed"] = "Heal Absorbed"
--[[Translation missing --]]
L["Health"] = "Health"
--[[Translation missing --]]
L["Health (%)"] = "Health (%)"
--[[Translation missing --]]
L["Health Deficit"] = "Health Deficit"
--[[Translation missing --]]
L["Heigan the Unclean"] = "Heigan the Unclean"
--[[Translation missing --]]
L["Height"] = "Height"
--[[Translation missing --]]
L["Hero Talent"] = "Hero Talent"
--[[Translation missing --]]
L["Heroic Party"] = "Heroic Party"
--[[Translation missing --]]
L["Hide"] = "Hide"
--[[Translation missing --]]
L["Hide 0 cooldowns"] = "Hide 0 cooldowns"
--[[Translation missing --]]
L["Hide Timer Text"] = "Hide Timer Text"
--[[Translation missing --]]
L["High Damage"] = "High Damage"
--[[Translation missing --]]
L["High Priest Thekal"] = "High Priest Thekal"
--[[Translation missing --]]
L["High Priest Venoxis"] = "High Priest Venoxis"
--[[Translation missing --]]
L["High Priestess Arlokk"] = "High Priestess Arlokk"
--[[Translation missing --]]
L["High Priestess Jeklik"] = "High Priestess Jeklik"
--[[Translation missing --]]
L["High Priestess Mar'li"] = "High Priestess Mar'li"
--[[Translation missing --]]
L["Higher Than Tank"] = "Higher Than Tank"
--[[Translation missing --]]
L["Highest Spell Id"] = "Highest Spell Id"
--[[Translation missing --]]
L["Hit (%)"] = "Hit (%)"
--[[Translation missing --]]
L["Hit Rating"] = "Hit Rating"
--[[Translation missing --]]
L["Holy Resistance"] = "Holy Resistance"
--[[Translation missing --]]
L["Horde"] = "Horde"
--[[Translation missing --]]
L["Horizontal"] = "Horizontal"
--[[Translation missing --]]
L["Hostile"] = "Hostile"
--[[Translation missing --]]
L["Hostility"] = "Hostility"
--[[Translation missing --]]
L["Humanoid"] = "Humanoid"
--[[Translation missing --]]
L["Hybrid"] = "Hybrid"
--[[Translation missing --]]
L["Icon"] = "Icon"
--[[Translation missing --]]
L["Icon Function"] = "Icon Function"
--[[Translation missing --]]
L["Icon Function (fallback state)"] = "Icon Function (fallback state)"
--[[Translation missing --]]
L["Id"] = "Id"
--[[Translation missing --]]
L["ID"] = "ID"
--[[Translation missing --]]
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"
--[[Translation missing --]]
L["Ignore Dead"] = "Ignore Dead"
--[[Translation missing --]]
L["Ignore Disconnected"] = "Ignore Disconnected"
--[[Translation missing --]]
L["Ignore Rune CD"] = "Ignore Rune CD"
--[[Translation missing --]]
L["Ignore Rune CDs"] = "Ignore Rune CDs"
--[[Translation missing --]]
L["Ignore Self"] = "Ignore Self"
--[[Translation missing --]]
L["Ignore Spell Cooldown/Charges"] = "Ignore Spell Cooldown/Charges"
--[[Translation missing --]]
L["Ignore Spell Override"] = "Ignore Spell Override"
--[[Translation missing --]]
L["Immune"] = "Immune"
--[[Translation missing --]]
L["Important"] = "Important"
--[[Translation missing --]]
L["Importing will start after combat ends."] = "Importing will start after combat ends."
--[[Translation missing --]]
L["In Combat"] = "In Combat"
--[[Translation missing --]]
L["In Encounter"] = "In Encounter"
--[[Translation missing --]]
L["In Group"] = "In Group"
--[[Translation missing --]]
L["In Party"] = "In Party"
--[[Translation missing --]]
L["In Pet Battle"] = "In Pet Battle"
--[[Translation missing --]]
L["In Raid"] = "In Raid"
--[[Translation missing --]]
L["In Range"] = "In Range"
--[[Translation missing --]]
L["In Vehicle"] = "In Vehicle"
--[[Translation missing --]]
L["In War Mode"] = "In War Mode"
--[[Translation missing --]]
L["Include Bank"] = "Include Bank"
--[[Translation missing --]]
L["Include Charges"] = "Include Charges"
--[[Translation missing --]]
L["Include Death Runes"] = "Include Death Runes"
--[[Translation missing --]]
L["Include Pets"] = "Include Pets"
--[[Translation missing --]]
L["Include War Band Bank"] = "Include War Band Bank"
--[[Translation missing --]]
L["Incoming Heal"] = "Incoming Heal"
--[[Translation missing --]]
L["Increase Precision Below"] = "Increase Precision Below"
--[[Translation missing --]]
L["Increases by one per stage or intermission."] = "Increases by one per stage or intermission."
--[[Translation missing --]]
L["Information"] = "Information"
--[[Translation missing --]]
L["Inherited"] = "Inherited"
--[[Translation missing --]]
L["Instakill"] = "Instakill"
--[[Translation missing --]]
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "Install the addons BugSack and BugGrabber for detailed error logs."
--[[Translation missing --]]
L["Instance"] = "Instance"
--[[Translation missing --]]
L["Instance Difficulty"] = "Instance Difficulty"
--[[Translation missing --]]
L["Instance Id"] = "Instance Id"
--[[Translation missing --]]
L["Instance ID"] = "Instance ID"
--[[Translation missing --]]
L["Instance Info"] = "Instance Info"
--[[Translation missing --]]
L["Instance Name"] = "Instance Name"
--[[Translation missing --]]
L["Instance Size Type"] = "Instance Size Type"
--[[Translation missing --]]
L["Instance Type"] = "Instance Type"
--[[Translation missing --]]
L["Instructor Razuvious"] = "Instructor Razuvious"
--[[Translation missing --]]
L["Insufficient Resources"] = "Insufficient Resources"
--[[Translation missing --]]
L["Intellect"] = "Intellect"
--[[Translation missing --]]
L["Interrupt"] = "Interrupt"
--[[Translation missing --]]
L["Interrupt School"] = "Interrupt School"
--[[Translation missing --]]
L["Interrupted School Text"] = "Interrupted School Text"
--[[Translation missing --]]
L["Interruptible"] = "Interruptible"
--[[Translation missing --]]
L["Inverse"] = "Inverse"
--[[Translation missing --]]
L["Inverse Pet Behavior"] = "Inverse Pet Behavior"
--[[Translation missing --]]
L["Is Away from Keyboard"] = "Is Away from Keyboard"
--[[Translation missing --]]
L["Is Current Specialization"] = "Is Current Specialization"
--[[Translation missing --]]
L["Is Death Rune"] = "Is Death Rune"
--[[Translation missing --]]
L["Is Exactly"] = "Is Exactly"
--[[Translation missing --]]
L["Is Moving"] = "Is Moving"
--[[Translation missing --]]
L["Is Off Hand"] = "Is Off Hand"
--[[Translation missing --]]
L["Is Paragon Reputation"] = "Is Paragon Reputation"
--[[Translation missing --]]
L["Is Paused"] = "Is Paused"
--[[Translation missing --]]
L["is useable"] = "is useable"
--[[Translation missing --]]
L["Is Weekly Renown Capped"] = "Is Weekly Renown Capped"
--[[Translation missing --]]
L["Island Expedition (Heroic)"] = "Island Expedition (Heroic)"
--[[Translation missing --]]
L["Island Expedition (Mythic)"] = "Island Expedition (Mythic)"
--[[Translation missing --]]
L["Island Expedition (Normal)"] = "Island Expedition (Normal)"
--[[Translation missing --]]
L["Island Expeditions (PvP)"] = "Island Expeditions (PvP)"
--[[Translation missing --]]
L["Item"] = "Item"
--[[Translation missing --]]
L["Item Bonus Id"] = "Item Bonus Id"
--[[Translation missing --]]
L["Item Bonus Id Equipped"] = "Item Bonus Id Equipped"
--[[Translation missing --]]
L["Item Count"] = "Item Count"
--[[Translation missing --]]
L["Item Equipped"] = "Item Equipped"
--[[Translation missing --]]
L["Item Id"] = "Item Id"
--[[Translation missing --]]
L["Item in Range"] = "Item in Range"
--[[Translation missing --]]
L["Item Name"] = "Item Name"
--[[Translation missing --]]
L["Item Set Equipped"] = "Item Set Equipped"
--[[Translation missing --]]
L["Item Set Id"] = "Item Set Id"
--[[Translation missing --]]
L["Item Slot"] = "Item Slot"
--[[Translation missing --]]
L["Item Slot String"] = "Item Slot String"
--[[Translation missing --]]
L["Item Type"] = "Item Type"
--[[Translation missing --]]
L["Item Type Equipped"] = "Item Type Equipped"
--[[Translation missing --]]
L["ItemId"] = "ItemId"
--[[Translation missing --]]
L["Jin'do the Hexxer"] = "Jin'do the Hexxer"
--[[Translation missing --]]
L["Journal Stage"] = "Journal Stage"
--[[Translation missing --]]
L["Kazzak"] = "Kazzak"
--[[Translation missing --]]
L["Keep Inside"] = "Keep Inside"
--[[Translation missing --]]
L["Kel'Thuzad"] = "Kel'Thuzad"
--[[Translation missing --]]
L["Kurinnaxx"] = "Kurinnaxx"
--[[Translation missing --]]
L["Large"] = "Large"
--[[Translation missing --]]
L["Latency"] = "Latency"
--[[Translation missing --]]
L["Leader"] = "Leader"
--[[Translation missing --]]
L["Least remaining time"] = "Least remaining time"
--[[Translation missing --]]
L["Leaving"] = "Leaving"
--[[Translation missing --]]
L["Leech"] = "Leech"
--[[Translation missing --]]
L["Leech (%)"] = "Leech (%)"
--[[Translation missing --]]
L["Leech Rating"] = "Leech Rating"
--[[Translation missing --]]
L["Left"] = "Left"
--[[Translation missing --]]
L["Left to Right"] = "Left to Right"
--[[Translation missing --]]
L["Left, then Centered Vertical"] = "Left, then Centered Vertical"
--[[Translation missing --]]
L["Left, then Down"] = "Left, then Down"
--[[Translation missing --]]
L["Left, then Up"] = "Left, then Up"
--[[Translation missing --]]
L["Legacy Looking for Raid"] = "Legacy Looking for Raid"
--[[Translation missing --]]
L["Legacy RGB Gradient"] = "Legacy RGB Gradient"
--[[Translation missing --]]
L["Legacy RGB Gradient Pulse"] = "Legacy RGB Gradient Pulse"
--[[Translation missing --]]
L["Legion"] = "Legion"
--[[Translation missing --]]
L["Length"] = "Length"
--[[Translation missing --]]
L["Level"] = "Level"
--[[Translation missing --]]
L["LibSharedMedia"] = "LibSharedMedia"
--[[Translation missing --]]
L["Lillian Voss"] = "Lillian Voss"
--[[Translation missing --]]
L["Limited"] = "Limited"
--[[Translation missing --]]
L["Linear Texture"] = "Linear Texture"
--[[Translation missing --]]
L["Lines & Particles"] = "Lines & Particles"
--[[Translation missing --]]
L["Load Conditions"] = "Load Conditions"
--[[Translation missing --]]
L["Loatheb"] = "Loatheb"
--[[Translation missing --]]
L["Location"] = "Location"
--[[Translation missing --]]
L["Looking for Raid"] = "Looking for Raid"
--[[Translation missing --]]
L["Loop"] = "Loop"
--[[Translation missing --]]
L["Loot"] = "Loot"
--[[Translation missing --]]
L["Loot Specialization"] = "Loot Specialization"
--[[Translation missing --]]
L["Loot Specialization Id"] = "Loot Specialization Id"
--[[Translation missing --]]
L["Loot Specialization Name"] = "Loot Specialization Name"
--[[Translation missing --]]
L["Lorewalking"] = "Lorewalking"
--[[Translation missing --]]
L["Lost"] = "Lost"
--[[Translation missing --]]
L["Low Damage"] = "Low Damage"
--[[Translation missing --]]
L["Lower Than Tank"] = "Lower Than Tank"
--[[Translation missing --]]
L["Lowest Spell Id"] = "Lowest Spell Id"
--[[Translation missing --]]
L["Lua error"] = "Lua error"
--[[Translation missing --]]
L["Lua error in Aura '%s': %s"] = "Lua error in Aura '%s': %s"
--[[Translation missing --]]
L["Lucifron"] = "Lucifron"
--[[Translation missing --]]
L["Maexxna"] = "Maexxna"
--[[Translation missing --]]
L["Magic"] = "Magic"
--[[Translation missing --]]
L["Magmadar"] = "Magmadar"
--[[Translation missing --]]
L["Main Character"] = "Main Character"
--[[Translation missing --]]
L["Main Stat"] = "Main Stat"
--[[Translation missing --]]
L["Majordomo Executus"] = "Majordomo Executus"
--[[Translation missing --]]
L["Malformed WeakAuras link"] = "Malformed WeakAuras link"
--[[Translation missing --]]
L["Manual"] = "Manual"
--[[Translation missing --]]
L["Manual Icon"] = "Manual Icon"
--[[Translation missing --]]
L["Manual Rotation"] = "Manual Rotation"
--[[Translation missing --]]
L["Marked First"] = "Marked First"
--[[Translation missing --]]
L["Marked Last"] = "Marked Last"
--[[Translation missing --]]
L["Mason"] = "Mason"
--[[Translation missing --]]
L["Master"] = "Master"
--[[Translation missing --]]
L["Mastery (%)"] = "Mastery (%)"
--[[Translation missing --]]
L["Mastery Rating"] = "Mastery Rating"
--[[Translation missing --]]
L["Match Count"] = "Match Count"
--[[Translation missing --]]
L["Match Count per Unit"] = "Match Count per Unit"
--[[Translation missing --]]
L["Matches (Pattern)"] = "Matches (Pattern)"
--[[Translation missing --]]
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=]
--[[Translation missing --]]
L["Max Char "] = "Max Char "
--[[Translation missing --]]
L["Max Char"] = "Max Char"
--[[Translation missing --]]
L["Max Charges"] = "Max Charges"
--[[Translation missing --]]
L["Max Health"] = "Max Health"
--[[Translation missing --]]
L["Max Power"] = "Max Power"
--[[Translation missing --]]
L["Max Quantity"] = "Max Quantity"
--[[Translation missing --]]
L["Maximum Estimate"] = "Maximum Estimate"
--[[Translation missing --]]
L["Maximum Progress"] = "Maximum Progress"
--[[Translation missing --]]
L["Maximum time used on a single frame"] = "Maximum time used on a single frame"
--[[Translation missing --]]
L["Media"] = "Media"
--[[Translation missing --]]
L["Medium"] = "Medium"
--[[Translation missing --]]
L["Melee"] = "Melee"
--[[Translation missing --]]
L["Melee Haste (%)"] = "Melee Haste (%)"
--[[Translation missing --]]
L["Message"] = "Message"
--[[Translation missing --]]
L["Message Type"] = "Message Type"
--[[Translation missing --]]
L["Message type:"] = "Message type:"
--[[Translation missing --]]
L["Meta Data"] = "Meta Data"
--[[Translation missing --]]
L["Mine"] = "Mine"
--[[Translation missing --]]
L["Minimum Estimate"] = "Minimum Estimate"
--[[Translation missing --]]
L["Minimum Progress"] = "Minimum Progress"
--[[Translation missing --]]
L["Minus (Small Nameplate)"] = "Minus (Small Nameplate)"
--[[Translation missing --]]
L["Mirror"] = "Mirror"
--[[Translation missing --]]
L["Miscellaneous"] = "Miscellaneous"
--[[Translation missing --]]
L["Miss"] = "Miss"
--[[Translation missing --]]
L["Miss Type"] = "Miss Type"
--[[Translation missing --]]
L["Missed"] = "Missed"
--[[Translation missing --]]
L["Missing"] = "Missing"
--[[Translation missing --]]
L["Mists of Pandaria"] = "Mists of Pandaria"
--[[Translation missing --]]
L["Moam"] = "Moam"
--[[Translation missing --]]
L["Model"] = "Model"
--[[Translation missing --]]
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"
--[[Translation missing --]]
L["Modernize"] = "Modernize"
--[[Translation missing --]]
L["Molten Core"] = "Molten Core"
--[[Translation missing --]]
L["Money"] = "Money"
--[[Translation missing --]]
L["Monochrome"] = "Monochrome"
--[[Translation missing --]]
L["Monochrome Outline"] = "Monochrome Outline"
--[[Translation missing --]]
L["Monochrome Thick Outline"] = "Monochrome Thick Outline"
--[[Translation missing --]]
L["Monster Emote"] = "Monster Emote"
--[[Translation missing --]]
L["Monster Party"] = "Monster Party"
--[[Translation missing --]]
L["Monster Say"] = "Monster Say"
--[[Translation missing --]]
L["Monster Whisper"] = "Monster Whisper"
--[[Translation missing --]]
L["Monster Yell"] = "Monster Yell"
--[[Translation missing --]]
L["Moon"] = "Moon"
--[[Translation missing --]]
L["Most remaining time"] = "Most remaining time"
--[[Translation missing --]]
L["Mounted"] = "Mounted"
--[[Translation missing --]]
L["Mouse Cursor"] = "Mouse Cursor"
--[[Translation missing --]]
L["Movement Speed Rating"] = "Movement Speed Rating"
--[[Translation missing --]]
L["Multi-target"] = "Multi-target"
--[[Translation missing --]]
L["Mythic Keystone"] = "Mythic Keystone"
--[[Translation missing --]]
L["Mythic+ Affix"] = "Mythic+ Affix"
--[[Translation missing --]]
L["Name"] = "Name"
--[[Translation missing --]]
L["Name Function"] = "Name Function"
--[[Translation missing --]]
L["Name Function (fallback state)"] = "Name Function (fallback state)"
--[[Translation missing --]]
L["Name of Caster's Target"] = "Name of Caster's Target"
--[[Translation missing --]]
L["Name of the (sub-)zone currently shown above the minimap."] = "Name of the (sub-)zone currently shown above the minimap."
--[[Translation missing --]]
L["Name(s)"] = "Name(s)"
--[[Translation missing --]]
L["Name/Realm of Caster's Target"] = "Name/Realm of Caster's Target"
--[[Translation missing --]]
L["Nameplate"] = "Nameplate"
--[[Translation missing --]]
L["Nameplates"] = "Nameplates"
--[[Translation missing --]]
L["Names of affected Players"] = "Names of affected Players"
--[[Translation missing --]]
L["Names of unaffected Players"] = "Names of unaffected Players"
--[[Translation missing --]]
L["Nature Resistance"] = "Nature Resistance"
--[[Translation missing --]]
L["Naxxramas"] = "Naxxramas"
--[[Translation missing --]]
L["Nefarian"] = "Nefarian"
--[[Translation missing --]]
L["Neutral"] = "Neutral"
--[[Translation missing --]]
L["Never"] = "Never"
--[[Translation missing --]]
L["Next Combat"] = "Next Combat"
--[[Translation missing --]]
L["Next Encounter"] = "Next Encounter"
--[[Translation missing --]]
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
--[[Translation missing --]]
L["No Extend"] = "No Extend"
--[[Translation missing --]]
L["No Instance"] = "No Instance"
--[[Translation missing --]]
L["No Profiling information saved."] = "No Profiling information saved."
--[[Translation missing --]]
L["No Progress Information available."] = "No Progress Information available."
--[[Translation missing --]]
L["None"] = "None"
--[[Translation missing --]]
L["Non-player Character"] = "Non-player Character"
--[[Translation missing --]]
L["Normal"] = "Normal"
--[[Translation missing --]]
L["Normal Party"] = "Normal Party"
--[[Translation missing --]]
L["Not in Group"] = "Not in Group"
--[[Translation missing --]]
L["Not in Smart Group"] = "Not in Smart Group"
--[[Translation missing --]]
L["Not on Cooldown"] = "Not on Cooldown"
--[[Translation missing --]]
L["Not On Threat Table"] = "Not On Threat Table"
--[[Translation missing --]]
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."
--[[Translation missing --]]
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."
--[[Translation missing --]]
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "Note: The available text replacements for multi triggers match the normal triggers now."
--[[Translation missing --]]
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = "Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."
--[[Translation missing --]]
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "Note: This trigger relies on the WoW API, which returns incorrect information in some cases."
--[[Translation missing --]]
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"
--[[Translation missing --]]
L["Noth the Plaguebringer"] = "Noth the Plaguebringer"
--[[Translation missing --]]
L["NPC"] = "NPC"
--[[Translation missing --]]
L["Npc ID"] = "Npc ID"
--[[Translation missing --]]
L["Number"] = "Number"
--[[Translation missing --]]
L["Number Affected"] = "Number Affected"
--[[Translation missing --]]
L["Object"] = "Object"
--[[Translation missing --]]
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=]
--[[Translation missing --]]
L["Officer"] = "Officer"
--[[Translation missing --]]
L["Offset from progress"] = "Offset from progress"
--[[Translation missing --]]
L["Offset Timer"] = "Offset Timer"
--[[Translation missing --]]
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Old Blizzard (2h | 3m | 10s | 2.4)"
--[[Translation missing --]]
L["On Cooldown"] = "On Cooldown"
--[[Translation missing --]]
L["On Taxi"] = "On Taxi"
--[[Translation missing --]]
L["Only if on a different realm"] = "Only if on a different realm"
--[[Translation missing --]]
L["Only if Primary"] = "Only if Primary"
--[[Translation missing --]]
L["Onyxia"] = "Onyxia"
--[[Translation missing --]]
L["Opaque"] = "Opaque"
--[[Translation missing --]]
L["Option Group"] = "Option Group"
--[[Translation missing --]]
L["Options could not be loaded, the addon is %s"] = "Options could not be loaded, the addon is %s"
--[[Translation missing --]]
L["Options will finish loading after combat ends."] = "Options will finish loading after combat ends."
--[[Translation missing --]]
L["Options will open after the login process has completed."] = "Options will open after the login process has completed."
--[[Translation missing --]]
L["Or Talent"] = "Or Talent"
--[[Translation missing --]]
L["Orbit"] = "Orbit"
--[[Translation missing --]]
L["Orientation"] = "Orientation"
--[[Translation missing --]]
L["Ossirian the Unscarred"] = "Ossirian the Unscarred"
--[[Translation missing --]]
L["Other"] = "Other"
--[[Translation missing --]]
L["Other Addons"] = "Other Addons"
--[[Translation missing --]]
L["Other Events"] = "Other Events"
--[[Translation missing --]]
L["Ouro"] = "Ouro"
--[[Translation missing --]]
L["Outline"] = "Outline"
--[[Translation missing --]]
L["Over Energize"] = "Over Energize"
--[[Translation missing --]]
L["Overhealing"] = "Overhealing"
--[[Translation missing --]]
L["Overkill"] = "Overkill"
--[[Translation missing --]]
L["Overlay %s"] = "Overlay %s"
--[[Translation missing --]]
L["Overlay Charged Combo Points"] = "Overlay Charged Combo Points"
--[[Translation missing --]]
L["Overlay Cost of Casts"] = "Overlay Cost of Casts"
--[[Translation missing --]]
L["Overlay Latency"] = "Overlay Latency"
--[[Translation missing --]]
L["Pad"] = "Pad"
--[[Translation missing --]]
L["Pad Mode"] = "Pad Mode"
--[[Translation missing --]]
L["Pad to"] = "Pad to"
--[[Translation missing --]]
L["Paragon Reputation"] = "Paragon Reputation"
--[[Translation missing --]]
L["Paragon Reward Pending"] = "Paragon Reward Pending"
--[[Translation missing --]]
L["Parent Frame"] = "Parent Frame"
--[[Translation missing --]]
L["Parent Zone"] = "Parent Zone"
--[[Translation missing --]]
L["Parry"] = "Parry"
--[[Translation missing --]]
L["Parry (%)"] = "Parry (%)"
--[[Translation missing --]]
L["Parry Rating"] = "Parry Rating"
--[[Translation missing --]]
L["Party"] = "Party"
--[[Translation missing --]]
L["Party Kill"] = "Party Kill"
--[[Translation missing --]]
L["Patchwerk"] = "Patchwerk"
--[[Translation missing --]]
L["Path of Ascension: Courage"] = "Path of Ascension: Courage"
--[[Translation missing --]]
L["Path of Ascension: Humility"] = "Path of Ascension: Humility"
--[[Translation missing --]]
L["Path of Ascension: Loyalty"] = "Path of Ascension: Loyalty"
--[[Translation missing --]]
L["Path of Ascension: Wisdom"] = "Path of Ascension: Wisdom"
--[[Translation missing --]]
L["Paused"] = "Paused"
--[[Translation missing --]]
L["Periodic Spell"] = "Periodic Spell"
--[[Translation missing --]]
L["Personal Resource Display"] = "Personal Resource Display"
--[[Translation missing --]]
L["Pet"] = "Pet"
--[[Translation missing --]]
L["Pet Behavior"] = "Pet Behavior"
--[[Translation missing --]]
L["Pet Specialization"] = "Pet Specialization"
--[[Translation missing --]]
L["Pet Spell"] = "Pet Spell"
--[[Translation missing --]]
L["Pets only"] = "Pets only"
--[[Translation missing --]]
L["Phase"] = "Phase"
--[[Translation missing --]]
L["Pixel Glow"] = "Pixel Glow"
--[[Translation missing --]]
L["Placement"] = "Placement"
--[[Translation missing --]]
L["Placement %i"] = "Placement %i"
--[[Translation missing --]]
L["Placement Mode"] = "Placement Mode"
--[[Translation missing --]]
L["Play"] = "Play"
--[[Translation missing --]]
L["Player"] = "Player"
--[[Translation missing --]]
L["Player Character"] = "Player Character"
--[[Translation missing --]]
L["Player Class"] = "Player Class"
--[[Translation missing --]]
L["Player Effective Level"] = "Player Effective Level"
--[[Translation missing --]]
L["Player Experience"] = "Player Experience"
--[[Translation missing --]]
L["Player Faction"] = "Player Faction"
--[[Translation missing --]]
L["Player Level"] = "Player Level"
--[[Translation missing --]]
L["Player Location ID(s)"] = "Player Location ID(s)"
--[[Translation missing --]]
L["Player Money"] = "Player Money"
--[[Translation missing --]]
L["Player Name/Realm"] = "Player Name/Realm"
--[[Translation missing --]]
L["Player Race"] = "Player Race"
--[[Translation missing --]]
L["Player(s) Affected"] = "Player(s) Affected"
--[[Translation missing --]]
L["Player(s) Not Affected"] = "Player(s) Not Affected"
--[[Translation missing --]]
L["Player/Unit Info"] = "Player/Unit Info"
--[[Translation missing --]]
L["Players and Pets"] = "Players and Pets"
--[[Translation missing --]]
L["Poison"] = "Poison"
--[[Translation missing --]]
L["Power"] = "Power"
--[[Translation missing --]]
L["Power (%)"] = "Power (%)"
--[[Translation missing --]]
L["Power Deficit"] = "Power Deficit"
--[[Translation missing --]]
L["Power Type"] = "Power Type"
--[[Translation missing --]]
L["Precision"] = "Precision"
--[[Translation missing --]]
L["Preset"] = "Preset"
--[[Translation missing --]]
L["Primary Stats"] = "Primary Stats"
--[[Translation missing --]]
L["Princess Huhuran"] = "Princess Huhuran"
--[[Translation missing --]]
L["Print Profiling Results"] = "Print Profiling Results"
--[[Translation missing --]]
L["Proc Glow"] = "Proc Glow"
--[[Translation missing --]]
L["Profiling already started."] = "Profiling already started."
--[[Translation missing --]]
L["Profiling automatically started."] = "Profiling automatically started."
--[[Translation missing --]]
L["Profiling not running."] = "Profiling not running."
--[[Translation missing --]]
L["Profiling started."] = "Profiling started."
--[[Translation missing --]]
L["Profiling started. It will end automatically in %d seconds"] = "Profiling started. It will end automatically in %d seconds"
--[[Translation missing --]]
L["Profiling still running, stop before trying to print."] = "Profiling still running, stop before trying to print."
--[[Translation missing --]]
L["Profiling stopped."] = "Profiling stopped."
--[[Translation missing --]]
L["Progress"] = "Progress"
--[[Translation missing --]]
L["Progress Source"] = "Progress Source"
--[[Translation missing --]]
L["Progress Total"] = "Progress Total"
--[[Translation missing --]]
L["Progress Value"] = "Progress Value"
--[[Translation missing --]]
L["Pull"] = "Pull"
--[[Translation missing --]]
L["Pulse"] = "Pulse"
--[[Translation missing --]]
L["PvP Flagged"] = "PvP Flagged"
--[[Translation missing --]]
L["PvP Talent selected"] = "PvP Talent selected"
--[[Translation missing --]]
L["PvP Talent Selected"] = "PvP Talent Selected"
--[[Translation missing --]]
L["Quality Id"] = "Quality Id"
--[[Translation missing --]]
L["Quantity"] = "Quantity"
--[[Translation missing --]]
L["Quantity earned this week"] = "Quantity earned this week"
--[[Translation missing --]]
L["Quest Party"] = "Quest Party"
--[[Translation missing --]]
L["Queued Action"] = "Queued Action"
--[[Translation missing --]]
L["Radius"] = "Radius"
--[[Translation missing --]]
L["Ragnaros"] = "Ragnaros"
--[[Translation missing --]]
L["Raid"] = "Raid"
--[[Translation missing --]]
L["Raid (Heroic)"] = "Raid (Heroic)"
--[[Translation missing --]]
L["Raid (Mythic)"] = "Raid (Mythic)"
--[[Translation missing --]]
L["Raid (Normal)"] = "Raid (Normal)"
--[[Translation missing --]]
L["Raid (Timewalking)"] = "Raid (Timewalking)"
--[[Translation missing --]]
L["Raid Mark"] = "Raid Mark"
--[[Translation missing --]]
L["Raid Mark Icon"] = "Raid Mark Icon"
--[[Translation missing --]]
L["Raid Role"] = "Raid Role"
--[[Translation missing --]]
L["Raid Warning"] = "Raid Warning"
--[[Translation missing --]]
L["Raids"] = "Raids"
--[[Translation missing --]]
L["Range"] = "Range"
--[[Translation missing --]]
L["Range Check"] = "Range Check"
--[[Translation missing --]]
L["Ranged"] = "Ranged"
--[[Translation missing --]]
L["Rank"] = "Rank"
--[[Translation missing --]]
L["Rare"] = "Rare"
--[[Translation missing --]]
L["Rare Elite"] = "Rare Elite"
--[[Translation missing --]]
L["Rated Arena"] = "Rated Arena"
--[[Translation missing --]]
L["Rated Battleground"] = "Rated Battleground"
--[[Translation missing --]]
L["Raw Threat Percent"] = "Raw Threat Percent"
--[[Translation missing --]]
L["Razorgore the Untamed"] = "Razorgore the Untamed"
--[[Translation missing --]]
L["Ready Check"] = "Ready Check"
--[[Translation missing --]]
L["Reagent Quality"] = "Reagent Quality"
--[[Translation missing --]]
L["Reagent Quality Texture"] = "Reagent Quality Texture"
--[[Translation missing --]]
L["Realm"] = "Realm"
--[[Translation missing --]]
L["Realm Name"] = "Realm Name"
--[[Translation missing --]]
L["Realm of Caster's Target"] = "Realm of Caster's Target"
--[[Translation missing --]]
L["Reborn Council"] = "Reborn Council"
--[[Translation missing --]]
L["Receiving %s Bytes"] = "Receiving %s Bytes"
--[[Translation missing --]]
L["Receiving display information"] = "Receiving display information"
--[[Translation missing --]]
L["Reflect"] = "Reflect"
--[[Translation missing --]]
L["Region type %s not supported"] = "Region type %s not supported"
--[[Translation missing --]]
L["Relative"] = "Relative"
--[[Translation missing --]]
L["Relative X-Offset"] = "Relative X-Offset"
--[[Translation missing --]]
L["Relative Y-Offset"] = "Relative Y-Offset"
--[[Translation missing --]]
L["Remaining Duration"] = "Remaining Duration"
--[[Translation missing --]]
L["Remaining Time"] = "Remaining Time"
--[[Translation missing --]]
L["Remove Obsolete Auras"] = "Remove Obsolete Auras"
--[[Translation missing --]]
L["Renown Level"] = "Renown Level"
--[[Translation missing --]]
L["Renown Max Level"] = "Renown Max Level"
--[[Translation missing --]]
L["Renown Reputation"] = "Renown Reputation"
--[[Translation missing --]]
L["Repair"] = "Repair"
--[[Translation missing --]]
L["Repeat"] = "Repeat"
--[[Translation missing --]]
L["Report Summary"] = "Report Summary"
--[[Translation missing --]]
L["Reputation"] = "Reputation"
--[[Translation missing --]]
L["Reputation (%)"] = "Reputation (%)"
--[[Translation missing --]]
L["Requested display does not exist"] = "Requested display does not exist"
--[[Translation missing --]]
L["Requested display not authorized"] = "Requested display not authorized"
--[[Translation missing --]]
L["Requesting display information from %s ..."] = "Requesting display information from %s ..."
--[[Translation missing --]]
L["Require Valid Target"] = "Require Valid Target"
--[[Translation missing --]]
L["Requires syncing the specialization via LibSpecialization."] = "Requires syncing the specialization via LibSpecialization."
--[[Translation missing --]]
L["Resilience (%)"] = "Resilience (%)"
--[[Translation missing --]]
L["Resilience Rating"] = "Resilience Rating"
--[[Translation missing --]]
L["Resist"] = "Resist"
--[[Translation missing --]]
L["Resistances"] = "Resistances"
--[[Translation missing --]]
L["Resisted"] = "Resisted"
--[[Translation missing --]]
L["Rested"] = "Rested"
--[[Translation missing --]]
L["Rested Experience"] = "Rested Experience"
--[[Translation missing --]]
L["Rested Experience (%)"] = "Rested Experience (%)"
--[[Translation missing --]]
L["Resting"] = "Resting"
--[[Translation missing --]]
L["Resurrect"] = "Resurrect"
--[[Translation missing --]]
L["Resurrect Pending"] = "Resurrect Pending"
--[[Translation missing --]]
L["Right"] = "Right"
--[[Translation missing --]]
L["Right to Left"] = "Right to Left"
--[[Translation missing --]]
L["Right, then Centered Vertical"] = "Right, then Centered Vertical"
--[[Translation missing --]]
L["Right, then Down"] = "Right, then Down"
--[[Translation missing --]]
L["Right, then Up"] = "Right, then Up"
--[[Translation missing --]]
L["Role"] = "Role"
--[[Translation missing --]]
L["Rollback snapshot is complete. Thank you for your patience!"] = "Rollback snapshot is complete. Thank you for your patience!"
--[[Translation missing --]]
L["Rotate Animation"] = "Rotate Animation"
--[[Translation missing --]]
L["Rotate Left"] = "Rotate Left"
--[[Translation missing --]]
L["Rotate Right"] = "Rotate Right"
--[[Translation missing --]]
L["Rotation"] = "Rotation"
--[[Translation missing --]]
L["Round"] = "Round"
--[[Translation missing --]]
L["Round Mode"] = "Round Mode"
--[[Translation missing --]]
L["Ruins of Ahn'Qiraj"] = "Ruins of Ahn'Qiraj"
--[[Translation missing --]]
L["Run Custom Code"] = "Run Custom Code"
--[[Translation missing --]]
L["Run Speed (%)"] = "Run Speed (%)"
--[[Translation missing --]]
L["Rune"] = "Rune"
--[[Translation missing --]]
L["Rune #1"] = "Rune #1"
--[[Translation missing --]]
L["Rune #2"] = "Rune #2"
--[[Translation missing --]]
L["Rune #3"] = "Rune #3"
--[[Translation missing --]]
L["Rune #4"] = "Rune #4"
--[[Translation missing --]]
L["Rune #5"] = "Rune #5"
--[[Translation missing --]]
L["Rune #6"] = "Rune #6"
--[[Translation missing --]]
L["Rune Count"] = "Rune Count"
--[[Translation missing --]]
L["Rune Count - Blood"] = "Rune Count - Blood"
--[[Translation missing --]]
L["Rune Count - Frost"] = "Rune Count - Frost"
--[[Translation missing --]]
L["Rune Count - Unholy"] = "Rune Count - Unholy"
--[[Translation missing --]]
L["Sapphiron"] = "Sapphiron"
--[[Translation missing --]]
L["Say"] = "Say"
--[[Translation missing --]]
L["Scale"] = "Scale"
--[[Translation missing --]]
L["Scarlet Enclave"] = "Scarlet Enclave"
--[[Translation missing --]]
L["Scenario"] = "Scenario"
--[[Translation missing --]]
L["Scenario (Heroic)"] = "Scenario (Heroic)"
--[[Translation missing --]]
L["Scenario (Normal)"] = "Scenario (Normal)"
--[[Translation missing --]]
L["Screen"] = "Screen"
--[[Translation missing --]]
L["Screen/Parent Group"] = "Screen/Parent Group"
--[[Translation missing --]]
L["Season of Discovery"] = "Season of Discovery"
--[[Translation missing --]]
L["Second"] = "Second"
--[[Translation missing --]]
L["Second Value of Tooltip Text"] = "Second Value of Tooltip Text"
--[[Translation missing --]]
L["Secondary Stats"] = "Secondary Stats"
--[[Translation missing --]]
L["Seconds"] = "Seconds"
--[[Translation missing --]]
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Select Frame"] = "Select Frame"
--[[Translation missing --]]
L["Select the type of timer to filter"] = "Select the type of timer to filter"
--[[Translation missing --]]
L["Selection Mode"] = "Selection Mode"
--[[Translation missing --]]
L["Separator"] = "Separator"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "Set IDs can be found on websites such as wowhead.com/cata/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/classic/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "Set IDs can be found on websites such as wowhead.com/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"
--[[Translation missing --]]
L["Shadow Resistance"] = "Shadow Resistance"
--[[Translation missing --]]
L["Shadowlands"] = "Shadowlands"
--[[Translation missing --]]
L["Shake"] = "Shake"
--[[Translation missing --]]
L["Shazzrah"] = "Shazzrah"
--[[Translation missing --]]
L["Shift-Click to resume addon execution."] = "Shift-Click to resume addon execution."
--[[Translation missing --]]
L["Show"] = "Show"
--[[Translation missing --]]
L["Show CD of Charge"] = "Show CD of Charge"
--[[Translation missing --]]
L["Show charged duration for empowered casts"] = "Show charged duration for empowered casts"
--[[Translation missing --]]
L["Show GCD"] = "Show GCD"
--[[Translation missing --]]
L["Show Global Cooldown"] = "Show Global Cooldown"
--[[Translation missing --]]
L["Show Incoming Heal"] = "Show Incoming Heal"
--[[Translation missing --]]
L["Show Loss of Control"] = "Show Loss of Control"
--[[Translation missing --]]
L["Show On"] = "Show On"
--[[Translation missing --]]
L["Show Rested Overlay"] = "Show Rested Overlay"
--[[Translation missing --]]
L["Shrink"] = "Shrink"
--[[Translation missing --]]
L["Silithid Royalty"] = "Silithid Royalty"
--[[Translation missing --]]
L["Silver"] = "Silver"
--[[Translation missing --]]
L["Simple"] = "Simple"
--[[Translation missing --]]
L["Since Active"] = "Since Active"
--[[Translation missing --]]
L["Since Apply"] = "Since Apply"
--[[Translation missing --]]
L["Since Apply/Refresh"] = "Since Apply/Refresh"
--[[Translation missing --]]
L["Since Charge Gain"] = "Since Charge Gain"
--[[Translation missing --]]
L["Since Charge Lost"] = "Since Charge Lost"
--[[Translation missing --]]
L["Since Ready"] = "Since Ready"
--[[Translation missing --]]
L["Since Stack Gain"] = "Since Stack Gain"
--[[Translation missing --]]
L["Since Stack Lost"] = "Since Stack Lost"
--[[Translation missing --]]
L["Size & Position"] = "Size & Position"
--[[Translation missing --]]
L["Skyriding"] = "Skyriding"
--[[Translation missing --]]
L["Slide Animation"] = "Slide Animation"
--[[Translation missing --]]
L["Slide from Bottom"] = "Slide from Bottom"
--[[Translation missing --]]
L["Slide from Left"] = "Slide from Left"
--[[Translation missing --]]
L["Slide from Right"] = "Slide from Right"
--[[Translation missing --]]
L["Slide from Top"] = "Slide from Top"
--[[Translation missing --]]
L["Slide to Bottom"] = "Slide to Bottom"
--[[Translation missing --]]
L["Slide to Left"] = "Slide to Left"
--[[Translation missing --]]
L["Slide to Right"] = "Slide to Right"
--[[Translation missing --]]
L["Slide to Top"] = "Slide to Top"
--[[Translation missing --]]
L["Slider"] = "Slider"
--[[Translation missing --]]
L["Small"] = "Small"
--[[Translation missing --]]
L["Smart Group"] = "Smart Group"
--[[Translation missing --]]
L["Soft Enemy"] = "Soft Enemy"
--[[Translation missing --]]
L["Soft Friend"] = "Soft Friend"
--[[Translation missing --]]
L["Solistrasza"] = "Solistrasza"
--[[Translation missing --]]
L["Sound"] = "Sound"
--[[Translation missing --]]
L["Sound by Kit ID"] = "Sound by Kit ID"
--[[Translation missing --]]
L["Source"] = "Source"
--[[Translation missing --]]
L["Source Affiliation"] = "Source Affiliation"
--[[Translation missing --]]
L["Source GUID"] = "Source GUID"
--[[Translation missing --]]
L["Source Info"] = "Source Info"
--[[Translation missing --]]
L["Source Name"] = "Source Name"
--[[Translation missing --]]
L["Source NPC Id"] = "Source NPC Id"
--[[Translation missing --]]
L["Source Object Type"] = "Source Object Type"
--[[Translation missing --]]
L["Source Raid Mark"] = "Source Raid Mark"
--[[Translation missing --]]
L["Source Reaction"] = "Source Reaction"
--[[Translation missing --]]
L["Source Unit"] = "Source Unit"
--[[Translation missing --]]
L["Source Unit Name/Realm"] = "Source Unit Name/Realm"
--[[Translation missing --]]
L["Source unit's raid mark index"] = "Source unit's raid mark index"
--[[Translation missing --]]
L["Source unit's raid mark texture"] = "Source unit's raid mark texture"
--[[Translation missing --]]
L["Space"] = "Space"
--[[Translation missing --]]
L["Spacing"] = "Spacing"
--[[Translation missing --]]
L["Spark"] = "Spark"
--[[Translation missing --]]
L["Spec Position"] = "Spec Position"
--[[Translation missing --]]
L["Spec Role"] = "Spec Role"
--[[Translation missing --]]
L["Specialization"] = "Specialization"
--[[Translation missing --]]
L["Specific Currency"] = "Specific Currency"
--[[Translation missing --]]
L["Specific Type"] = "Specific Type"
--[[Translation missing --]]
L["Specific Unit"] = "Specific Unit"
--[[Translation missing --]]
L["Spell"] = "Spell"
--[[Translation missing --]]
L["Spell (Building)"] = "Spell (Building)"
--[[Translation missing --]]
L["Spell Activation Overlay Glow"] = "Spell Activation Overlay Glow"
--[[Translation missing --]]
L["Spell Cast Succeeded"] = "Spell Cast Succeeded"
--[[Translation missing --]]
L["Spell Cost"] = "Spell Cost"
--[[Translation missing --]]
L["Spell Count"] = "Spell Count"
--[[Translation missing --]]
L["Spell ID"] = "Spell ID"
--[[Translation missing --]]
L["Spell Id"] = "Spell Id"
--[[Translation missing --]]
L["Spell ID:"] = "Spell ID:"
--[[Translation missing --]]
L["Spell IDs:"] = "Spell IDs:"
--[[Translation missing --]]
L["Spell in Range"] = "Spell in Range"
--[[Translation missing --]]
L["Spell Known"] = "Spell Known"
--[[Translation missing --]]
L["Spell Name"] = "Spell Name"
--[[Translation missing --]]
L["Spell Peneration Percent"] = "Spell Peneration Percent"
--[[Translation missing --]]
L["Spell Power"] = "Spell Power"
--[[Translation missing --]]
L["Spell School"] = "Spell School"
--[[Translation missing --]]
L["Spell Usable"] = "Spell Usable"
--[[Translation missing --]]
L["Spellname"] = "Spellname"
--[[Translation missing --]]
L["Spike"] = "Spike"
--[[Translation missing --]]
L["Spin"] = "Spin"
--[[Translation missing --]]
L["Spiral"] = "Spiral"
--[[Translation missing --]]
L["Spiral In And Out"] = "Spiral In And Out"
--[[Translation missing --]]
L["Spirit"] = "Spirit"
--[[Translation missing --]]
L["Stack Count"] = "Stack Count"
--[[Translation missing --]]
L["Stack trace:"] = "Stack trace:"
--[[Translation missing --]]
L["Stacks"] = "Stacks"
--[[Translation missing --]]
L["Stacks Function"] = "Stacks Function"
--[[Translation missing --]]
L["Stacks Function (fallback state)"] = "Stacks Function (fallback state)"
--[[Translation missing --]]
L["Stage"] = "Stage"
--[[Translation missing --]]
L["Stage Counter"] = "Stage Counter"
--[[Translation missing --]]
L["Stagger"] = "Stagger"
--[[Translation missing --]]
L["Stagger (%)"] = "Stagger (%)"
--[[Translation missing --]]
L["Stagger against Target (%)"] = "Stagger against Target (%)"
--[[Translation missing --]]
L["Stagger Scale"] = "Stagger Scale"
--[[Translation missing --]]
L["Stamina"] = "Stamina"
--[[Translation missing --]]
L["Stance/Form/Aura"] = "Stance/Form/Aura"
--[[Translation missing --]]
L["Standing"] = "Standing"
--[[Translation missing --]]
L["Star Shake"] = "Star Shake"
--[[Translation missing --]]
L["Start Animation"] = "Start Animation"
--[[Translation missing --]]
L["Start Now"] = "Start Now"
--[[Translation missing --]]
L["Start Profiling"] = "Start Profiling"
--[[Translation missing --]]
L["Status"] = "Status"
--[[Translation missing --]]
L["Status Bar"] = "Status Bar"
--[[Translation missing --]]
L["Stolen"] = "Stolen"
--[[Translation missing --]]
L["Stop"] = "Stop"
--[[Translation missing --]]
L["Stop Motion"] = "Stop Motion"
--[[Translation missing --]]
L["Story Raid"] = "Story Raid"
--[[Translation missing --]]
L["Strength"] = "Strength"
--[[Translation missing --]]
L["String"] = "String"
--[[Translation missing --]]
L["Subevent Info"] = "Subevent Info"
--[[Translation missing --]]
L["Subtract Cast"] = "Subtract Cast"
--[[Translation missing --]]
L["Subtract Channel"] = "Subtract Channel"
--[[Translation missing --]]
L["Subtract GCD"] = "Subtract GCD"
--[[Translation missing --]]
L["Subzone Name"] = "Subzone Name"
--[[Translation missing --]]
L["Success"] = "Success"
--[[Translation missing --]]
L["Sulfuron Harbinger"] = "Sulfuron Harbinger"
--[[Translation missing --]]
L["Summon"] = "Summon"
--[[Translation missing --]]
L["Summon Pending"] = "Summon Pending"
--[[Translation missing --]]
L["Sun"] = "Sun"
--[[Translation missing --]]
L["Supports multiple entries, separated by commas"] = "Supports multiple entries, separated by commas"
--[[Translation missing --]]
L[ [=[Supports multiple entries, separated by commas
]=] ] = [=[Supports multiple entries, separated by commas
]=]
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Prefix with '-' for negation."
--[[Translation missing --]]
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=]
--[[Translation missing --]]
L["Swing"] = "Swing"
--[[Translation missing --]]
L["Swing Timer"] = "Swing Timer"
--[[Translation missing --]]
L["Swipe"] = "Swipe"
--[[Translation missing --]]
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = "Syntax /wa feature <toggle|on|enable|disable|off> <feature>"
--[[Translation missing --]]
L["System"] = "System"
--[[Translation missing --]]
L["Systems"] = "Systems"
--[[Translation missing --]]
L["Tab "] = "Tab "
--[[Translation missing --]]
L["Talent"] = "Talent"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Known"] = "Talent |cFFFF0000Not|r Known"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Selected"] = "Talent |cFFFF0000Not|r Selected"
--[[Translation missing --]]
L["Talent Known"] = "Talent Known"
--[[Translation missing --]]
L["Talent Selected"] = "Talent Selected"
--[[Translation missing --]]
L["Talent selected"] = "Talent selected"
--[[Translation missing --]]
L["Talent Specialization"] = "Talent Specialization"
--[[Translation missing --]]
L["Tanking And Highest"] = "Tanking And Highest"
--[[Translation missing --]]
L["Tanking But Not Highest"] = "Tanking But Not Highest"
--[[Translation missing --]]
L["Target"] = "Target"
--[[Translation missing --]]
L["Targeted"] = "Targeted"
--[[Translation missing --]]
L["Tertiary Stats"] = "Tertiary Stats"
--[[Translation missing --]]
L["Test if bar is enabled in BigWigs settings"] = "Test if bar is enabled in BigWigs settings"
--[[Translation missing --]]
L["Test if bar is enabled in Boss Mod addon settings"] = "Test if bar is enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Test if bar is enabled in DBM settings"] = "Test if bar is enabled in DBM settings"
--[[Translation missing --]]
L["Text"] = "Text"
--[[Translation missing --]]
L["Text To Speech"] = "Text To Speech"
--[[Translation missing --]]
L["Text-to-speech"] = "Text-to-speech"
--[[Translation missing --]]
L["Texture"] = "Texture"
--[[Translation missing --]]
L["Texture Function"] = "Texture Function"
--[[Translation missing --]]
L["Texture Function (fallback state)"] = "Texture Function (fallback state)"
--[[Translation missing --]]
L["Texture Picker"] = "Texture Picker"
--[[Translation missing --]]
L["Texture Rotation"] = "Texture Rotation"
--[[Translation missing --]]
L["Thaddius"] = "Thaddius"
--[[Translation missing --]]
L["The aura has overwritten the global '%s', this might affect other auras."] = "The aura has overwritten the global '%s', this might affect other auras."
--[[Translation missing --]]
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "The aura tried to overwrite the aura_env global, which is not allowed."
--[[Translation missing --]]
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "The effective level differs from the level in e.g. Time Walking dungeons."
--[[Translation missing --]]
L["The Four Horsemen"] = "The Four Horsemen"
--[[Translation missing --]]
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "The 'ID' value can be found in the BigWigs options of a specific spell"
--[[Translation missing --]]
L["The Prophet Skeram"] = "The Prophet Skeram"
--[[Translation missing --]]
L["The total quantity a warband character can transfer after paying the transfer cost"] = "The total quantity a warband character can transfer after paying the transfer cost"
--[[Translation missing --]]
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "The total quantity after transferring everything to your current character and paying the transfer cost"
--[[Translation missing --]]
L["The War Within"] = "The War Within"
--[[Translation missing --]]
L["There are %i updates to your auras ready to be installed!"] = "There are %i updates to your auras ready to be installed!"
--[[Translation missing --]]
L["Thick Outline"] = "Thick Outline"
--[[Translation missing --]]
L["Thickness"] = "Thickness"
--[[Translation missing --]]
L["Third"] = "Third"
--[[Translation missing --]]
L["Third Value of Tooltip Text"] = "Third Value of Tooltip Text"
--[[Translation missing --]]
L["This aura calls GetData a lot, which is a slow function."] = "This aura calls GetData a lot, which is a slow function."
--[[Translation missing --]]
L["This aura has caused a Lua error."] = "This aura has caused a Lua error."
--[[Translation missing --]]
L["This aura is saving %s KB of data"] = "This aura is saving %s KB of data"
--[[Translation missing --]]
L["This aura plays a sound via a condition."] = "This aura plays a sound via a condition."
--[[Translation missing --]]
L["This aura plays a sound via an action."] = "This aura plays a sound via an action."
--[[Translation missing --]]
L["This aura plays a Text To Speech via a condition."] = "This aura plays a Text To Speech via a condition."
--[[Translation missing --]]
L["This aura plays a Text To Speech via an action."] = "This aura plays a Text To Speech via an action."
--[[Translation missing --]]
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."
--[[Translation missing --]]
L["Threat Percent"] = "Threat Percent"
--[[Translation missing --]]
L["Threat Situation"] = "Threat Situation"
--[[Translation missing --]]
L["Threat Value"] = "Threat Value"
--[[Translation missing --]]
L["Tick"] = "Tick"
--[[Translation missing --]]
L["Time"] = "Time"
--[[Translation missing --]]
L["Time Format"] = "Time Format"
--[[Translation missing --]]
L["Time in GCDs"] = "Time in GCDs"
--[[Translation missing --]]
L["Time since initial application"] = "Time since initial application"
--[[Translation missing --]]
L["Time since last refresh"] = "Time since last refresh"
--[[Translation missing --]]
L["Time since stack gain"] = "Time since stack gain"
--[[Translation missing --]]
L["Time since stack lost"] = "Time since stack lost"
--[[Translation missing --]]
L["Timed"] = "Timed"
--[[Translation missing --]]
L["Timed Progress"] = "Timed Progress"
--[[Translation missing --]]
L["Timer"] = "Timer"
--[[Translation missing --]]
L["Timer Id"] = "Timer Id"
--[[Translation missing --]]
L["Toggle"] = "Toggle"
--[[Translation missing --]]
L["Toggle List"] = "Toggle List"
--[[Translation missing --]]
L["Toggle Options Window"] = "Toggle Options Window"
--[[Translation missing --]]
L["Toggle Performance Profiling Window"] = "Toggle Performance Profiling Window"
--[[Translation missing --]]
L["Tooltip"] = "Tooltip"
--[[Translation missing --]]
L["Tooltip 1"] = "Tooltip 1"
--[[Translation missing --]]
L["Tooltip 2"] = "Tooltip 2"
--[[Translation missing --]]
L["Tooltip 3"] = "Tooltip 3"
--[[Translation missing --]]
L["Tooltip Value 1"] = "Tooltip Value 1"
--[[Translation missing --]]
L["Tooltip Value 2"] = "Tooltip Value 2"
--[[Translation missing --]]
L["Tooltip Value 3"] = "Tooltip Value 3"
--[[Translation missing --]]
L["Tooltip Value 4"] = "Tooltip Value 4"
--[[Translation missing --]]
L["Top"] = "Top"
--[[Translation missing --]]
L["Top Left"] = "Top Left"
--[[Translation missing --]]
L["Top Right"] = "Top Right"
--[[Translation missing --]]
L["Top to Bottom"] = "Top to Bottom"
--[[Translation missing --]]
L["Torghast"] = "Torghast"
--[[Translation missing --]]
L["Total Duration"] = "Total Duration"
--[[Translation missing --]]
L["Total Earned in this Season"] = "Total Earned in this Season"
--[[Translation missing --]]
L["Total Essence"] = "Total Essence"
--[[Translation missing --]]
L["Total Experience"] = "Total Experience"
--[[Translation missing --]]
L["Total Match Count"] = "Total Match Count"
--[[Translation missing --]]
L["Total Reputation"] = "Total Reputation"
--[[Translation missing --]]
L["Total Stacks"] = "Total Stacks"
--[[Translation missing --]]
L["Total stacks over all matches"] = "Total stacks over all matches"
--[[Translation missing --]]
L["Total Stages"] = "Total Stages"
--[[Translation missing --]]
L["Total Unit Count"] = "Total Unit Count"
--[[Translation missing --]]
L["Total Units"] = "Total Units"
--[[Translation missing --]]
L["Totem"] = "Totem"
--[[Translation missing --]]
L["Totem #%i"] = "Totem #%i"
--[[Translation missing --]]
L["Totem Icon"] = "Totem Icon"
--[[Translation missing --]]
L["Totem Name"] = "Totem Name"
--[[Translation missing --]]
L["Totem Name Pattern Match"] = "Totem Name Pattern Match"
--[[Translation missing --]]
L["Totem Number"] = "Totem Number"
--[[Translation missing --]]
L["Track Cooldowns"] = "Track Cooldowns"
--[[Translation missing --]]
L["Tracking Charge %i"] = "Tracking Charge %i"
--[[Translation missing --]]
L["Tracking Charge CDs"] = "Tracking Charge CDs"
--[[Translation missing --]]
L["Tracking Only Cooldown"] = "Tracking Only Cooldown"
--[[Translation missing --]]
L["Transmission error"] = "Transmission error"
--[[Translation missing --]]
L["Trigger"] = "Trigger"
--[[Translation missing --]]
L["Trigger %i"] = "Trigger %i"
--[[Translation missing --]]
L["Trigger %s"] = "Trigger %s"
--[[Translation missing --]]
L["Trigger 1"] = "Trigger 1"
--[[Translation missing --]]
L["Trigger State Updater (Advanced)"] = "Trigger State Updater (Advanced)"
--[[Translation missing --]]
L["Trigger Update"] = "Trigger Update"
--[[Translation missing --]]
L["Trigger:"] = "Trigger:"
--[[Translation missing --]]
L["Trivial (Low Level)"] = "Trivial (Low Level)"
--[[Translation missing --]]
L["True"] = "True"
--[[Translation missing --]]
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "Trying to repair broken conditions in %s likely caused by a WeakAuras bug."
--[[Translation missing --]]
L["Twin Emperors"] = "Twin Emperors"
--[[Translation missing --]]
L["Type"] = "Type"
--[[Translation missing --]]
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."
--[[Translation missing --]]
L["Unaffected"] = "Unaffected"
--[[Translation missing --]]
L["Undefined"] = "Undefined"
--[[Translation missing --]]
L["Unholy"] = "Unholy"
--[[Translation missing --]]
L["Unholy Rune #1"] = "Unholy Rune #1"
--[[Translation missing --]]
L["Unholy Rune #2"] = "Unholy Rune #2"
--[[Translation missing --]]
L["Unit"] = "Unit"
--[[Translation missing --]]
L["Unit Characteristics"] = "Unit Characteristics"
--[[Translation missing --]]
L["Unit Destroyed"] = "Unit Destroyed"
--[[Translation missing --]]
L["Unit Died"] = "Unit Died"
--[[Translation missing --]]
L["Unit Dissipates"] = "Unit Dissipates"
--[[Translation missing --]]
L["Unit Frame"] = "Unit Frame"
--[[Translation missing --]]
L["Unit Frames"] = "Unit Frames"
--[[Translation missing --]]
L["Unit is Unit"] = "Unit is Unit"
--[[Translation missing --]]
L["Unit Name"] = "Unit Name"
--[[Translation missing --]]
L["Unit Name/Realm"] = "Unit Name/Realm"
--[[Translation missing --]]
L["Units Affected"] = "Units Affected"
--[[Translation missing --]]
L["Units of affected Players in a table format"] = "Units of affected Players in a table format"
--[[Translation missing --]]
L["Units of unaffected Players in a table format"] = "Units of unaffected Players in a table format"
--[[Translation missing --]]
L["Unknown action %q"] = "Unknown action %q"
--[[Translation missing --]]
L["Unknown feature %q"] = "Unknown feature %q"
--[[Translation missing --]]
L["unknown location"] = "unknown location"
--[[Translation missing --]]
L["Unlimited"] = "Unlimited"
--[[Translation missing --]]
L["Untrigger %s"] = "Untrigger %s"
--[[Translation missing --]]
L["Up"] = "Up"
--[[Translation missing --]]
L["Up, then Centered Horizontal"] = "Up, then Centered Horizontal"
--[[Translation missing --]]
L["Up, then Left"] = "Up, then Left"
--[[Translation missing --]]
L["Up, then Right"] = "Up, then Right"
--[[Translation missing --]]
L["Update Position"] = "Update Position"
--[[Translation missing --]]
L["Usage:"] = "Usage:"
--[[Translation missing --]]
L["Use /wa minimap to show the minimap icon again."] = "Use /wa minimap to show the minimap icon again."
--[[Translation missing --]]
L["Use Custom Color"] = "Use Custom Color"
--[[Translation missing --]]
L["Use Legacy floor rounding"] = "Use Legacy floor rounding"
--[[Translation missing --]]
L["Use Texture"] = "Use Texture"
--[[Translation missing --]]
L["Use Watched Faction"] = "Use Watched Faction"
--[[Translation missing --]]
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."
--[[Translation missing --]]
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."
--[[Translation missing --]]
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."
--[[Translation missing --]]
L["Vaelastrasz the Corrupt"] = "Vaelastrasz the Corrupt"
--[[Translation missing --]]
L["Versatility (%)"] = "Versatility (%)"
--[[Translation missing --]]
L["Versatility Rating"] = "Versatility Rating"
--[[Translation missing --]]
L["Vertical"] = "Vertical"
--[[Translation missing --]]
L["Viscidus"] = "Viscidus"
--[[Translation missing --]]
L["Visibility"] = "Visibility"
--[[Translation missing --]]
L["Visions of N'Zoth"] = "Visions of N'Zoth"
--[[Translation missing --]]
L["Warband Quantity Total"] = "Warband Quantity Total"
--[[Translation missing --]]
L["Warband Transfer Percentage"] = "Warband Transfer Percentage"
--[[Translation missing --]]
L["Warband Transferred Quantity"] = "Warband Transferred Quantity"
--[[Translation missing --]]
L["Warfront (Heroic)"] = "Warfront (Heroic)"
--[[Translation missing --]]
L["Warfront (Normal)"] = "Warfront (Normal)"
--[[Translation missing --]]
L["Warlords of Draenor"] = "Warlords of Draenor"
--[[Translation missing --]]
L["Warning"] = "Warning"
--[[Translation missing --]]
L["Warning for unknown aura:"] = "Warning for unknown aura:"
--[[Translation missing --]]
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"
--[[Translation missing --]]
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = "Warning: Full Scan auras checking for both name and spell id can't be converted."
--[[Translation missing --]]
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."
--[[Translation missing --]]
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = "Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."
--[[Translation missing --]]
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"
--[[Translation missing --]]
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."
--[[Translation missing --]]
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=]
--[[Translation missing --]]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."
--[[Translation missing --]]
L["WeakAuras Profiling"] = "WeakAuras Profiling"
--[[Translation missing --]]
L["WeakAuras Profiling Report"] = "WeakAuras Profiling Report"
--[[Translation missing --]]
L["WeakAuras Version: %s"] = "WeakAuras Version: %s"
--[[Translation missing --]]
L["Weapon"] = "Weapon"
--[[Translation missing --]]
L["Weapon Enchant"] = "Weapon Enchant"
--[[Translation missing --]]
L["Weapon Enchant / Fishing Lure"] = "Weapon Enchant / Fishing Lure"
--[[Translation missing --]]
L["Whisper"] = "Whisper"
--[[Translation missing --]]
L["Width"] = "Width"
--[[Translation missing --]]
L["Wobble"] = "Wobble"
--[[Translation missing --]]
L["World Boss"] = "World Boss"
--[[Translation missing --]]
L["World Bosses"] = "World Bosses"
--[[Translation missing --]]
L["Wrap"] = "Wrap"
--[[Translation missing --]]
L["Wrath of the Lich King"] = "Wrath of the Lich King"
--[[Translation missing --]]
L["Writing to the WeakAuras table is not allowed."] = "Writing to the WeakAuras table is not allowed."
--[[Translation missing --]]
L["X-Offset"] = "X-Offset"
--[[Translation missing --]]
L["Yell"] = "Yell"
--[[Translation missing --]]
L["Y-Offset"] = "Y-Offset"
--[[Translation missing --]]
L["You have new auras ready to be installed!"] = "You have new auras ready to be installed!"
--[[Translation missing --]]
L["Your next encounter will automatically be profiled."] = "Your next encounter will automatically be profiled."
--[[Translation missing --]]
L["Your next instance of combat will automatically be profiled."] = "Your next instance of combat will automatically be profiled."
--[[Translation missing --]]
L["Your scheduled automatic profile has been cancelled."] = "Your scheduled automatic profile has been cancelled."
--[[Translation missing --]]
L["Your threat as a percentage of the tank's current threat."] = "Your threat as a percentage of the tank's current threat."
--[[Translation missing --]]
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."
--[[Translation missing --]]
L["Your total threat on the mob."] = "Your total threat on the mob."
--[[Translation missing --]]
L["Zone Group ID"] = "Zone Group ID"
--[[Translation missing --]]
L["Zone ID"] = "Zone ID"
--[[Translation missing --]]
L["Zone Name"] = "Zone Name"
--[[Translation missing --]]
L["Zoom"] = "Zoom"
--[[Translation missing --]]
L["Zoom Animation"] = "Zoom Animation"
--[[Translation missing --]]
L["Zul'Gurub"] = "Zul'Gurub"



-- ========================================
-- File: WeakAuras/Locales/koKR.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "koKR" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[ : '', '-', '-'.   ,    .
-  \      .]=]
L["%s Overlay Color"] = "%s "
L["* Suffix"] = "* "
L["/wa help - Show this message"] = "/wa help -   "
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap -    "
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint -     "
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart -  .    ()    .  (combat)/(encounter)   \"combat\" \"encounter\"  ."
L["/wa pstop - Finish profiling"] = "/wa pstop -  "
L["/wa repair - Repair tool"] = "/wa repair -  "
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55f|r    ."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55f  |r    ."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55f|r     ."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55f+|r    ."
L["|cffff0000deprecated|r"] = "|cffff0000 |r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = " |cFFFF0000|r   ID"
L["|cFFFF0000Not|r Item Equipped"] = " |cFFFF0000|r "
L["|cFFFF0000Not|r Player Name/Realm"] = " / |cFFFF0000|r"
L["|cFFFF0000Not|r Spell Known"] = " |cFFFF0000|r "
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = "|cFFFF0000  COMBAT_LOG_EVENT_UNFILTERED   |r   COMBAT_LOG_EVENT_UNFILTERED       .  : https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00 :|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00 :|r "
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = [=[ |cff00ff00|r, |cff00ff00|r, |cff00ff00 |r  |cff00ff00|r  ID  .

 |cff00ff00  |r  ID    .

|cffff0000|r:   ID      ID     .

 |cffffff00|r, |cffffff00|r, |cffffff00|r, |cffffff00|r  |cffffff00|r  ID   .

 |cffffff00 |r        "player",   "party"  ("player" ),   "raid"  .


|cffffff00*|r                .]=]
L["1. Profession 1. Accessory"] = "1   1 "
L["1. Profession 2. Accessory"] = "1   2 "
L["1. Professsion Tool"] = "1   "
L["10 Man Raid"] = "10 "
L["10 Player Raid"] = "10 "
L["10 Player Raid (Heroic)"] = "10  ()"
L["10 Player Raid (Normal)"] = "10  ()"
L["2. Profession 1. Accessory"] = "2   1 "
L["2. Profession 2. Accessory"] = "2   2 "
L["2. Professsion Tool"] = "2   "
L["20 Man Raid"] = "20 "
L["20 Player Raid"] = "20 "
L["25 Man Raid"] = "25 "
L["25 Player Raid"] = "25 "
L["25 Player Raid (Heroic)"] = "25  ()"
L["25 Player Raid (Normal)"] = "25  ()"
L["40 Man Raid"] = "40 "
L["40 Player Raid"] = "40 "
L["5 Man Dungeon"] = "5 "
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = [=[  WeakAuras     
      WeakAura Discord .]=]
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "          CVar     .       CVar  ."
L["Abbreviate"] = "  "
L["AbbreviateLargeNumbers (Blizzard)"] = "   ()"
L["AbbreviateNumbers (Blizzard)"] = "  ()"
L["Absorb"] = " "
L["Absorb and Healing"] = "  "
L["Absorb Heal Overlay"] = "  "
L["Absorb Overlay"] = "  "
L["Absorbed"] = " "
L["Action Button Glow"] = "  "
L["Actions"] = ""
L["Active"] = ""
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[   : |cFFffcc00BigWigs|r

:    BigWigs DBM      BigWigs .]=]
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[   : |cFFffcc00DBM|r

:    BigWigs DBM      BigWigs .]=]
L["Add"] = ""
L["Add Missing Auras"] = "  "
L["Advanced Caster's Target Check"] = "   "
L["Affected"] = "  "
L["Affected Unit Count"] = "   "
L["Afk"] = " "
L["Aggro"] = " "
L["Agility"] = ""
L["Ahn'Qiraj"] = ""
L["Alert Type"] = " "
L["Alive"] = ""
L["All"] = ""
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "       .    ."
L["All States table contains a non table at key: '%s'."] = "All States        : '%s'"
L["All Triggers"] = "   "
L["Alliance"] = ""
L["Allow partial matches"] = "  "
L["Alpha"] = ""
L["Alternate Power"] = " "
L["Always"] = ""
L["Always active trigger"] = "   "
L["Always include realm"] = "  "
L["Always True"] = " "
L["Amount"] = ""
L["Anchoring"] = " "
L["And Talent"] = " "
L["Angle and Radius"] = " "
L["Animations"] = ""
L["Anticlockwise"] = " "
L["Anub'Rekhan"] = ""
L["Any"] = ""
L["Any Triggers"] = "   "
L["AOE"] = " "
L["Arcane Resistance"] = " "
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = "|cffff0000|r   ?          .  : %s"
L["Arena"] = ""
L["Armor (%)"] = " (%)"
L["Armor against Target (%)"] = "   (%)"
L["Armor Rating"] = " "
L["Array"] = ""
L["Ascending"] = ""
L["Assigned Role"] = " "
L["Assigned Role Icon"] = "  "
L["Assist"] = ""
L["Assisted Combat Next Cast"] = "   "
L["At Least One Enemy"] = " 1  "
L["At missing Value"] = " "
L["At Percent"] = ""
L["At Value"] = ""
L["At War"] = " "
L["Attach to End"] = "  "
L["Attach to End, backwards"] = "   "
L["Attach to Point"] = "  "
L["Attach to Start"] = "  "
L["Attack Power"] = ""
L["Attackable"] = " "
L["Attackable Target"] = "  "
L["Aura"] = ""
L["Aura '%s': %s"] = " '%s': %s"
L["Aura Applied"] = " "
L["Aura Applied Dose"] = "  "
L["Aura Broken"] = " "
L["Aura Broken Spell"] = "  "
L["Aura is using deprecated SetDurationInfo"] = "   SetDurationInfo "
L["Aura loaded"] = " "
L["Aura Name"] = " "
L["Aura Names"] = " "
L["Aura Refresh"] = "  "
L["Aura Removed"] = " "
L["Aura Removed Dose"] = "  "
L["Aura Stack"] = " "
L["Aura Type"] = " "
L["Aura Version: %s"] = " : %s"
L["Aura(s) Found"] = " "
L["Aura(s) Missing"] = " "
L["Aura:"] = ":"
L["Auras"] = ""
L["Auras:"] = ":"
L["Author Options"] = " "
L["Auto"] = ""
L["Autocast Shine"] = " "
L["Automatic"] = " "
L["Automatic Length"] = "  "
L["Automatic Rotation"] = " "
L["Available features: %s"] = "  : %s"
L["Avoidance (%)"] = " (%)"
L["Avoidance Rating"] = " "
L["Ayamiss the Hunter"] = " "
L["Azuregos"] = ""
L["Back and Forth"] = ""
L["Background"] = ""
L["Background Color"] = ""
L["Balnazzar"] = ""
L["Bar Color/Gradient Start"] = " /  "
L["Bar enabled in BigWigs settings"] = "   BigWigs  "
L["Bar enabled in Boss Mod addon settings"] = "      "
L["Bar enabled in DBM settings"] = "   DBM  "
L["Bar Texture"] = " "
L["Bar Type"] = "  "
L["Baron Geddon"] = " "
L["Battle for Azeroth"] = " "
L["Battle.net Whisper"] = "Battle.net "
L["Battleground"] = ""
L["Battleguard Sartura"] = " "
L["Beastmaster"] = ""
L["Beatrix"] = ""
L["BG>Raid>Party>Say"] = ">>> "
L["BG-System Alliance"] = " "
L["BG-System Horde"] = " "
L["BG-System Neutral"] = " "
L["Big Number"] = " "
L["BigWigs Addon"] = "BigWigs "
L["BigWigs Message"] = "BigWigs "
L["BigWigs Stage"] = "BigWigs "
L["BigWigs Timer"] = "BigWigs "
L["Black Wing Lair"] = " "
L["Bleed"] = ""
L["Blizzard Combat Text"] = "  "
L["Blizzard Cooldown Reduction"] = "   "
L["Block"] = ""
L["Block (%)"] = " (%)"
L["Block against Target (%)"] = "   (%)"
L["Block Value"] = " "
L["Blocked"] = " "
L["Blood"] = ""
L["Blood Rune #1"] = "  #1"
L["Blood Rune #2"] = "  #2"
L["Bloodlord Mandokir"] = " "
L["Bonus Reputation Gain"] = "  "
L["Border"] = ""
L["Boss"] = ""
L["Boss Emote"] = "  "
L["Boss Mod Announce"] = "  "
L["Boss Mod Stage"] = "  "
L["Boss Mod Stage (Event)"] = "   ()"
L["Boss Mod Timer"] = "  "
L["Boss Whisper"] = " "
L["Bottom"] = ""
L["Bottom Left"] = " "
L["Bottom Right"] = " "
L["Bottom to Top"] = " "
L["Bounce"] = ""
L["Bounce with Decay"] = " ( )"
L["Break"] = ""
L["BreakUpLargeNumbers (Blizzard)"] = "   ()"
L["Broodlord Lashlayer"] = " "
L["Buff"] = ""
L["Buff/Debuff"] = "/"
L["Buffed/Debuffed"] = " / "
L["Burning Crusade"] = " "
L["Buru the Gorger"] = " "
L["Caldoran"] = ""
L["Callback function"] = " "
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "\"boss1target\" \"player\"     ."
L["Cancel"] = ""
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[      .  :
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "%i     .     World of Warcraft  . (: %i).   ."
L["Capped"] = " "
L["Capped at Season Max"] = "  "
L["Capped at Weekly Max"] = "  "
L["Cast"] = ""
L["Cast Bar"] = ""
L["Cast Failed"] = " "
L["Cast Start"] = " "
L["Cast Success"] = " "
L["Cast Type"] = " "
L["Caster"] = ""
L["Caster Name"] = " "
L["Caster Realm"] = " "
L["Caster Unit"] = " "
L["Casters Name/Realm"] = " /"
L["Caster's Target"] = " "
L["Cataclysm"] = ""
L["Ceil"] = ""
L["Center"] = ""
L["Center, then alternating bottom and top"] = ",     "
L["Center, then alternating left and right"] = ",     "
L["Center, then alternating right and left"] = ",     "
L["Center, then alternating top and bottom"] = ",     "
L["Centered Horizontal"] = " "
L["Centered Horizontal, then Centered Vertical"] = "    "
L["Centered Horizontal, then Down"] = "   "
L["Centered Horizontal, then Up"] = "   "
L["Centered Vertical"] = " "
L["Centered Vertical, then Centered Horizontal"] = "    "
L["Centered Vertical, then Left"] = "   "
L["Centered Vertical, then Right"] = "   "
L["Changed"] = ""
L["Channel"] = ""
L["Channel (Spell)"] = "  ()"
L["Character GUID"] = " GUID"
L["Character Name"] = " "
L["Character Stats"] = " "
L["Character Transferred Quantity"] = "   "
L["Character Type"] = " "
L["Charge gained/lost"] = " /"
L["Charged Combo Points"] = "  "
L["Charges"] = ""
L["Charges Changed Event"] = "  "
L["Charging"] = ""
L["Chat Frame"] = ""
L["Chat Message"] = " "
L["Check if a single talent match a Rank"] = "    "
L["Check nameplate's target every 0.2s"] = "0.2   "
L["Chromaggus"] = ""
L["Circle"] = ""
L["Circular Texture"] = " "
L["Clamp"] = " "
L["Class"] = ""
L["Class and Specialization"] = "  "
L["Classic"] = ""
L["Classification"] = " "
L["Clockwise"] = " "
L["Clone per Character"] = " "
L["Clone per Event"] = " "
L["Clone per Match"] = "  "
L["Coin Precision"] = "  "
L["Color"] = ""
L["Color Animation"] = " "
L["Combat Log"] = " "
L["Communities"] = ""
L["Condition Custom Test"] = "   "
L["Conditions"] = ""
L["Contains"] = ""
L["Continuously update Movement Speed"] = "   "
L["Cooldown"] = ""
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "         , BigWigs  '~'  ."
L["Cooldown Progress (Item)"] = "   ()"
L["Cooldown Progress (Slot)"] = "   ( )"
L["Cooldown Ready Event"] = "  "
L["Cooldown Ready Event (Item)"] = "   ()"
L["Cooldown Ready Event (Slot)"] = "   ( )"
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "         ."
L["Cooldown/Charges/Count"] = "//  "
L["Copper"] = ""
L["Could not load WeakAuras Archive, the addon is %s"] = "WeakAuras Archive   .  %s "
L["Count"] = ""
L["Counter Clockwise"] = " "
L["Create"] = ""
L["Creature Family"] = " "
L["Creature Family Name"] = "  "
L["Creature Type"] = " "
L["Creature Type Name"] = "  "
L["Critical"] = "  "
L["Critical (%)"] = " (%)"
L["Critical Rating"] = "   "
L["Crop X"] = "X "
L["Crop Y"] = "Y "
L["Crowd Controlled"] = " "
L["Crushing"] = ""
L["C'thun"] = ""
L["Cumulated time used during profiling"] = "   "
L["Currency"] = ""
L["Current Essence"] = " "
L["Current Experience"] = " "
L["Current Instance"] = "  "
L["Current Movement Speed (%)"] = "   (%)"
L["Current Stage"] = " "
L["Current Zone"] = "  "
L["Current Zone Group"] = "   "
L["Curse"] = ""
L["Custom"] = " "
L["Custom Action"] = "  "
L["Custom Anchor"] = "  "
L["Custom Check"] = "  "
L["Custom Color"] = "  "
L["Custom Condition Code"] = "   "
L["Custom Configuration"] = "  "
L["Custom Fade Animation"] = "   "
L["Custom Function"] = "  "
L["Custom Grow"] = "   "
L["Custom Sort"] = "  "
L["Custom Text Function"] = "   "
L["Custom Trigger Combination"] = "    "
L["Custom Variables"] = "  "
L["Damage"] = ""
L["Damage Shield"] = " "
L["Damage Shield Missed"] = "   "
L["Damage Split"] = " "
L["DBM Announce"] = "DBM "
L["DBM Stage"] = "DBM "
L["DBM Timer"] = "DBM "
L["Dead"] = ""
L["Death"] = ""
L["Death Knight Rune"] = "  "
L["Debuff"] = ""
L["Debuff Class"] = " "
L["Debuff Class Icon"] = "  "
L["Debuff Type"] = " "
L["Debug Log contains more than 1000 entries"] = "   1000  ."
L["Debug Logging enabled"] = "  "
L["Debug Logging enabled for '%s'"] = "'%s'    "
L["Defensive Stats"] = " "
L["Deflect"] = ""
L["Delve"] = ""
L["Desaturate"] = ""
L["Desaturate Background"] = " "
L["Desaturate Foreground"] = " "
L["Descending"] = ""
L["Description"] = ""
L["Dest Raid Mark"] = "  "
L["Destination Affiliation"] = " "
L["Destination GUID"] = " GUID"
L["Destination Info"] = " "
L["Destination Name"] = " "
L["Destination NPC Id"] = " NPC ID"
L["Destination Object Type"] = "  "
L["Destination Reaction"] = " "
L["Destination Unit"] = " "
L["Destination unit's raid mark index"] = "    "
L["Destination unit's raid mark texture"] = "    "
L["Difficulty"] = ""
L["Disable Spell Known Check"] = "   "
L["Disabled"] = ""
L["Disabled feature %q"] = "%q  "
L["Disabled Spell Known Check"] = "   "
L["Discovered"] = ""
L["Disease"] = ""
L["Dispel"] = ""
L["Dispel Failed"] = " "
L["Display"] = ""
L["Distance"] = ""
L["Do Not Disturb"] = "  "
L["Dodge"] = ""
L["Dodge (%)"] = " (%)"
L["Dodge Rating"] = " "
L["Down"] = ""
L["Down, then Centered Horizontal"] = "   "
L["Down, then Left"] = ", "
L["Down, then Right"] = ", "
L["Dragonflight"] = ""
L["Drain"] = " "
L["Dropdown Menu"] = " "
L["Dumping table"] = " "
L["Dungeon (Celestial)"] = " ()"
L["Dungeon (Heroic)"] = " ()"
L["Dungeon (Mythic)"] = " ()"
L["Dungeon (Mythic+)"] = " (+)"
L["Dungeon (Normal)"] = " ()"
L["Dungeon (Timewalking)"] = " ()"
L["Dungeons"] = ""
L["Durability Damage"] = " "
L["Durability Damage All"] = "  "
L["Duration"] = ""
L["Duration Function"] = " "
L["Duration Function (fallback state)"] = "Duration  (  )"
L["Ease In"] = " "
L["Ease In and Out"] = "  "
L["Ease Out"] = " "
L["Ebonroc"] = ""
L["Eclipse Direction"] = " "
L["Edge"] = ""
L["Edge of Madness"] = " "
L["Effective Spell Id"] = "  ID"
L["Elide"] = ""
L["Elite"] = ""
L["Emote"] = " "
L["Empower Cast End"] = "  "
L["Empower Cast Interrupt"] = "  "
L["Empower Cast Start"] = "  "
L["Empowered"] = " "
L["Empowered 1"] = " 1"
L["Empowered 2"] = " 2"
L["Empowered 3"] = " 3"
L["Empowered 4"] = " 4"
L["Empowered 5"] = " 5"
L["Empowered Cast"] = " "
L["Empowered Cast Fully Charged"] = "   "
L["Empowered Fully Charged"] = "   "
L["Empty"] = " "
L["Enabled feature %q"] = "%q  "
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "        . ()"
L["Enchant Applied"] = "  "
L["Enchant Found"] = " "
L["Enchant ID"] = " ID"
L["Enchant Missing"] = " "
L["Enchant Name or ID"] = "   ID"
L["Enchant Removed"] = "  "
L["Enchanted"] = ""
L["Encounter ID(s)"] = "(Encounter) ID ( )"
L["Energize"] = " "
L["Enrage"] = ""
L["Enter a name or a spellId"] = "  id "
L["Entering"] = ""
L["Entering/Leaving Combat"] = " /"
L["Entering/Leaving Encounter"] = " /"
L["Entry Order"] = " "
L["Environment Type"] = " "
L["Environmental"] = ""
L["Equipment"] = ""
L["Equipment Set"] = " "
L["Equipment Set Equipped"] = "  "
L["Equipment Slot"] = " "
L["Equipped"] = " "
L["Error"] = ""
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=['%s'     .     .  :
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Error decoding."] = " ."
L["Error decompressing"] = "  "
L["Error decompressing. This doesn't look like a WeakAuras import."] = "    . WeakAuras   ."
L["Error deserializing"] = " "
L["Error Frame"] = ""
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "'%s'         '%s'"
L["Error in Aura '%s'"] = "'%s'   "
L["Error not receiving display information from %s"] = "%s     "
L["Essence"] = ""
L["Essence #1"] = " #1"
L["Essence #2"] = " #2"
L["Essence #3"] = " #3"
L["Essence #4"] = " #4"
L["Essence #5"] = " #5"
L["Essence #6"] = " #6"
L["Evade"] = ""
L["Event"] = ""
L["Event(s)"] = " ( )"
L["Every Frame"] = " "
L["Every Frame (High CPU usage)"] = "  (CPU  )"
L["Evoker Essence"] = " "
L["Exact Spell ID(s)"] = "  ID ( )"
L["Execute Conditions"] = " "
L["Experience (%)"] = " (%)"
L["Expertise Bonus"] = " "
L["Expertise Rating"] = " "
L["Extend Outside"] = "  "
L["Extra Amount"] = " "
L["Extra Attacks"] = " "
L["Extra Spell Id"] = "  ID"
L["Extra Spell Name"] = "  "
L["Faction"] = ""
L["Faction Name"] = " "
L["Faction Reputation"] = " "
L["Fade Animation"] = "  "
L["Fade In"] = " "
L["Fade Out"] = " "
L["Fail Alert"] = "  "
L["False"] = ""
L["Fankriss the Unyielding"] = " "
L["Feature %q is already disabled"] = "%q    "
L["Feature %q is already enabled"] = "%q    "
L["Fetch Absorb"] = "  "
L["Fetch Heal Absorb"] = "  "
L["Fetch Legendary Power"] = "  "
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "  ID      ."
L["Fill Area"] = " "
L["Filter messages with format <message>"] = "<>    "
L["Fire Resistance"] = " "
L["Firemaw"] = ""
L["First"] = " "
L["First Value of Tooltip Text"] = "   "
L["Fixed"] = ""
L["Fixed Names"] = " "
L["Fixed Size"] = " "
L["Flamegor"] = ""
L["Flash"] = ""
L["Flex Raid"] = " "
L["Flip"] = " "
L["Floor"] = ""
L["Focus"] = " "
L["Follower Dungeon"] = " "
L["Font"] = ""
L["Font Size"] = " "
L["Forbidden function or table: %s"] = "   : %s"
L["Foreground"] = ""
L["Foreground Color"] = ""
L["Form"] = ""
L["Format"] = ""
L["Format Gold"] = " "
L["Formats |cFFFFCC00%unit|r"] = "|cFFFFCC00%unit|r "
L["Formats Player's |cFFFFCC00%guid|r"] = " |cFFFFCC00%guid|r "
L["Forward"] = "1 "
L["Forward, Reverse Loop"] = "  "
L["Fourth Value of Tooltip Text"] = "   "
L["Frame Selector"] = " "
L["Frequency"] = ""
L["Friendly"] = ""
L["Friendly Fire"] = "  "
L["Friendship Max Rank"] = "  "
L["Friendship Rank"] = " "
L["Friendship Reputation"] = " "
L["Frost"] = ""
L["Frost Resistance"] = " "
L["Frost Rune #1"] = "  #1"
L["Frost Rune #2"] = "  #2"
L["Full"] = "  "
L["Full Region"] = "  (Region)"
L["Full/Empty"] = "   "
L["Gahz'ranka"] = ""
L["Gained"] = ""
L["Garr"] = ""
L["Gehennas"] = ""
L["General"] = ""
L["General Rajaxx"] = " "
L["GetNameAndIcon Function (fallback state)"] = "GetNameAndIcon  (  )"
L["Glancing"] = ""
L["Global Cooldown"] = " "
L["Glow"] = ""
L["Glow External Element"] = "    "
L["Gluth"] = ""
L["Glyph"] = ""
L["Gold"] = ""
L["Golemagg the Incinerator"] = " "
L["Gothik the Harvester"] = "  "
L["Gradient"] = ""
L["Gradient Enabled"] = " "
L["Gradient End"] = "  "
L["Gradient Orientation"] = "  "
L["Gradient Pulse"] = " "
L["Grand Widow Faerlina"] = " "
L["Grid"] = ""
L["Grobbulus"] = ""
L["Group"] = ""
L["Group Arrangement"] = " "
L["Group Leader/Assist"] = "/"
L["Group Size"] = " "
L["Group Type"] = " "
L["Grow"] = ""
L["GTFO Alert"] = "GTFO "
L["Guardian"] = ""
L["Guild"] = ""
L["Hakkar"] = ""
L["Hardcore"] = ""
L["Has Target"] = " "
L["Has Vehicle UI"] = " UI "
L["HasPet"] = "  ()"
L["Haste (%)"] = " (%)"
L["Haste Rating"] = " "
L["Heal"] = ""
L["Heal Absorb"] = " "
L["Heal Absorbed"] = " "
L["Health"] = ""
L["Health (%)"] = " (%)"
L["Health Deficit"] = " "
L["Heigan the Unclean"] = " "
L["Height"] = ""
L["Hero Talent"] = " "
L["Heroic Party"] = " "
L["Hide"] = ""
L["Hide 0 cooldowns"] = "0  "
L["Hide Timer Text"] = "  "
L["High Damage"] = " "
L["High Priest Thekal"] = " "
L["High Priest Venoxis"] = " "
L["High Priestess Arlokk"] = " "
L["High Priestess Jeklik"] = " "
L["High Priestess Mar'li"] = " "
L["Higher Than Tank"] = "  "
L["Highest Spell Id"] = "   ID"
L["Hit (%)"] = " (%)"
L["Hit Rating"] = " "
L["Holy Resistance"] = " "
L["Horde"] = ""
L["Horizontal"] = ""
L["Hostile"] = ""
L["Hostility"] = "/"
L["Humanoid"] = ""
L["Hybrid"] = ""
L["Icon"] = ""
L["Icon Function"] = " "
L["Icon Function (fallback state)"] = "Icon  (  )"
L["Id"] = "ID"
L["ID"] = "ID"
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "    GitHub    Discord (https://discord.gg/weakauras)  !"
L["Ignore Dead"] = " "
L["Ignore Disconnected"] = " "
L["Ignore Rune CD"] = "  "
L["Ignore Rune CDs"] = "  "
L["Ignore Self"] = " "
L["Ignore Spell Cooldown/Charges"] = " / "
L["Ignore Spell Override"] = "  "
L["Immune"] = ""
L["Important"] = ""
L["Importing will start after combat ends."] = "    ."
L["In Combat"] = " "
L["In Encounter"] = ""
L["In Group"] = " "
L["In Party"] = ""
L["In Pet Battle"] = "  "
L["In Raid"] = ""
L["In Range"] = "  "
L["In Vehicle"] = "  "
L["In War Mode"] = " "
L["Include Bank"] = " "
L["Include Charges"] = "  "
L["Include Death Runes"] = "  "
L["Include Pets"] = " "
L["Include War Band Bank"] = "  "
L["Incoming Heal"] = " "
L["Increase Precision Below"] = "   "
L["Increases by one per stage or intermission."] = "   1 ."
L["Information"] = ""
L["Inherited"] = " "
L["Instakill"] = ""
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "    BugSack BugGrabber  ."
L["Instance"] = ""
L["Instance Difficulty"] = " "
L["Instance Id"] = "(Instance) ID"
L["Instance ID"] = "(Instance) ID"
L["Instance Info"] = "  "
L["Instance Name"] = " "
L["Instance Size Type"] = "  "
L["Instance Type"] = " "
L["Instructor Razuvious"] = " "
L["Insufficient Resources"] = " "
L["Intellect"] = ""
L["Interrupt"] = ""
L["Interrupt School"] = "  "
L["Interrupted School Text"] = "   "
L["Interruptible"] = " "
L["Inverse"] = ""
L["Inverse Pet Behavior"] = "  "
L["Is Away from Keyboard"] = " "
L["Is Current Specialization"] = " "
L["Is Death Rune"] = " "
L["Is Exactly"] = " "
L["Is Moving"] = " "
L["Is Off Hand"] = " "
L["Is Paragon Reputation"] = "  "
L["Is Paused"] = " "
L["is useable"] = " "
L["Is Weekly Renown Capped"] = "  "
L["Island Expedition (Heroic)"] = "  ()"
L["Island Expedition (Mythic)"] = "  ()"
L["Island Expedition (Normal)"] = "  ()"
L["Island Expeditions (PvP)"] = "  (PvP)"
L["Item"] = ""
L["Item Bonus Id"] = "  ID"
L["Item Bonus Id Equipped"] = "   ID"
L["Item Count"] = " "
L["Item Equipped"] = " "
L["Item Id"] = " ID"
L["Item in Range"] = "   "
L["Item Name"] = " "
L["Item Set Equipped"] = "  "
L["Item Set Id"] = "  ID"
L["Item Slot"] = " "
L["Item Slot String"] = "  "
L["Item Type"] = " "
L["Item Type Equipped"] = "  "
L["ItemId"] = "ID"
L["Jin'do the Hexxer"] = " "
L["Journal Stage"] = " "
L["Kazzak"] = ""
L["Keep Inside"] = "  "
L["Kel'Thuzad"] = ""
L["Kurinnaxx"] = ""
L["Large"] = ""
L["Latency"] = " "
L["Leader"] = ""
L["Least remaining time"] = "    "
L["Leaving"] = ""
L["Leech"] = ""
L["Leech (%)"] = " (%)"
L["Leech Rating"] = " "
L["Left"] = ""
L["Left to Right"] = " "
L["Left, then Centered Vertical"] = ",  "
L["Left, then Down"] = ", "
L["Left, then Up"] = ", "
L["Legacy Looking for Raid"] = "  "
L["Legacy RGB Gradient"] = " RGB "
L["Legacy RGB Gradient Pulse"] = " RGB  "
L["Legion"] = ""
L["Length"] = ""
L["Level"] = ""
L["LibSharedMedia"] = "LibSharedMedia"
L["Lillian Voss"] = " "
L["Limited"] = ""
L["Linear Texture"] = " "
L["Lines & Particles"] = "  "
L["Load Conditions"] = " "
L["Loatheb"] = ""
L["Location"] = ""
L["Looking for Raid"] = " "
L["Loop"] = ""
L["Loot"] = " "
L["Loot Specialization"] = "  "
L["Loot Specialization Id"] = "   ID"
L["Loot Specialization Name"] = "   "
L["Lorewalking"] = ""
L["Lost"] = ""
L["Low Damage"] = " "
L["Lower Than Tank"] = "  "
L["Lowest Spell Id"] = "   ID"
L["Lua error"] = "Lua "
L["Lua error in Aura '%s': %s"] = "'%s'  Lua  : %s"
L["Lucifron"] = ""
L["Maexxna"] = ""
L["Magic"] = ""
L["Magmadar"] = ""
L["Main Character"] = " "
L["Main Stat"] = " "
L["Majordomo Executus"] = " "
L["Malformed WeakAuras link"] = " WeakAuras "
L["Manual"] = " "
L["Manual Icon"] = "  "
L["Manual Rotation"] = " "
L["Marked First"] = "  "
L["Marked Last"] = " "
L["Mason"] = ""
L["Master"] = " "
L["Mastery (%)"] = " (%)"
L["Mastery Rating"] = " "
L["Match Count"] = "   "
L["Match Count per Unit"] = "    "
L["Matches (Pattern)"] = " ()"
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = "     .  .5 .   1;2;1;2;2.5;3"
L["Max Char "] = "  "
L["Max Char"] = "  "
L["Max Charges"] = " "
L["Max Health"] = " "
L["Max Power"] = " "
L["Max Quantity"] = " "
L["Maximum Estimate"] = " "
L["Maximum Progress"] = " "
L["Maximum time used on a single frame"] = "    "
L["Media"] = ""
L["Medium"] = ""
L["Melee"] = ""
L["Melee Haste (%)"] = "  (%)"
L["Message"] = ""
L["Message Type"] = " "
L["Message type:"] = " :"
L["Meta Data"] = " "
L["Mine"] = ""
L["Minimum Estimate"] = " "
L["Minimum Progress"] = " "
L["Minus (Small Nameplate)"] = " ( )"
L["Mirror"] = " "
L["Miscellaneous"] = ""
L["Miss"] = ""
L["Miss Type"] = " "
L["Missed"] = " "
L["Missing"] = ""
L["Mists of Pandaria"] = " "
L["Moam"] = ""
L["Model"] = ""
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "  (1h 3m | 3m 7s | 10s | 2.4)"
L["Modernize"] = ""
L["Molten Core"] = " "
L["Money"] = ""
L["Monochrome"] = ""
L["Monochrome Outline"] = " "
L["Monochrome Thick Outline"] = "  "
L["Monster Emote"] = "  "
L["Monster Party"] = " "
L["Monster Say"] = "  "
L["Monster Whisper"] = " "
L["Monster Yell"] = " "
L["Moon"] = ""
L["Most remaining time"] = "    "
L["Mounted"] = "  "
L["Mouse Cursor"] = " "
L["Movement Speed Rating"] = "  "
L["Multi-target"] = " "
L["Mythic Keystone"] = " "
L["Mythic+ Affix"] = "+ "
L["Name"] = ""
L["Name Function"] = " "
L["Name Function (fallback state)"] = "Name  (  )"
L["Name of Caster's Target"] = "  "
L["Name of the (sub-)zone currently shown above the minimap."] = "   (  )    ."
L["Name(s)"] = " ( )"
L["Name/Realm of Caster's Target"] = "  /"
L["Nameplate"] = ""
L["Nameplates"] = ""
L["Names of affected Players"] = "   "
L["Names of unaffected Players"] = "    "
L["Nature Resistance"] = " "
L["Naxxramas"] = ""
L["Nefarian"] = ""
L["Neutral"] = ""
L["Never"] = "  "
L["Next Combat"] = " "
L["Next Encounter"] = " "
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[    .

:    BigWigs DBM .    BigWigs .]=]
L["No Extend"] = "  "
L["No Instance"] = "  "
L["No Profiling information saved."] = "   ."
L["No Progress Information available."] = "    ."
L["None"] = ""
L["Non-player Character"] = "NPC"
L["Normal"] = ""
L["Normal Party"] = " "
L["Not in Group"] = " "
L["Not in Smart Group"] = "  "
L["Not on Cooldown"] = "  "
L["Not On Threat Table"] = "    "
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = ":       Blizzard  API     ."
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = ": ' '           ."
L["Note: The available text replacements for multi triggers match the normal triggers now."] = ":              ."
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = ":     /             ."
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = ":    WoW API   API     ."
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = ":       .       3   .               .  NPC        .|n|n|cFFAAFFAA :|r %s|n|cFFFFAAAA :|r %s|n|cFFAAAAFF :|r %s"
L["Noth the Plaguebringer"] = " "
L["NPC"] = "NPC"
L["Npc ID"] = "NPC ID"
L["Number"] = ""
L["Number Affected"] = "  "
L["Object"] = ""
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = [=[  
    
       

:
2 5 6 : 2, 5, 6
2 6: 2-6
2 : /2
2  3 : 2/3
2  11   3 : 2-11/3

      ]=]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[       
    
       

:
2 5 6 : 2, 5, 6
2 6: 2-6
2 : /2
2  3 : 2/3
2 11   3 : 2-11/3

BigWigs     ]=]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[       
    
       

:
2 5 6 : 2, 5, 6
2 6: 2-6
2 : /2
2  3 : 2/3
2 11   3 : 2-11/3

DBM     ]=]
L["Officer"] = ""
L["Offset from progress"] = "  "
L["Offset Timer"] = " "
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "  (2h | 3m | 10s | 2.4)"
L["On Cooldown"] = " "
L["On Taxi"] = "   "
L["Only if on a different realm"] = "  "
L["Only if Primary"] = " "
L["Onyxia"] = ""
L["Opaque"] = ""
L["Option Group"] = " "
L["Options could not be loaded, the addon is %s"] = "   .  %s."
L["Options will finish loading after combat ends."] = "    ."
L["Options will open after the login process has completed."] = "     ."
L["Or Talent"] = "  "
L["Orbit"] = ""
L["Orientation"] = " "
L["Ossirian the Unscarred"] = " "
L["Other"] = ""
L["Other Addons"] = " "
L["Other Events"] = " "
L["Ouro"] = ""
L["Outline"] = ""
L["Over Energize"] = ""
L["Overhealing"] = " "
L["Overkill"] = " "
L["Overlay %s"] = " %s"
L["Overlay Charged Combo Points"] = "   "
L["Overlay Cost of Casts"] = "  "
L["Overlay Latency"] = "  "
L["Pad"] = ""
L["Pad Mode"] = " "
L["Pad to"] = " "
L["Paragon Reputation"] = "  "
L["Paragon Reward Pending"] = "   "
L["Parent Frame"] = " "
L["Parent Zone"] = " "
L["Parry"] = ""
L["Parry (%)"] = "  (%)"
L["Parry Rating"] = "  "
L["Party"] = ""
L["Party Kill"] = ""
L["Patchwerk"] = ""
L["Path of Ascension: Courage"] = " : "
L["Path of Ascension: Humility"] = " : "
L["Path of Ascension: Loyalty"] = " : "
L["Path of Ascension: Wisdom"] = " : "
L["Paused"] = ""
L["Periodic Spell"] = " "
L["Personal Resource Display"] = "  "
L["Pet"] = ""
L["Pet Behavior"] = " "
L["Pet Specialization"] = " "
L["Pet Spell"] = " "
L["Pets only"] = ""
L["Phase"] = ""
L["Pixel Glow"] = "  "
L["Placement"] = ""
L["Placement %i"] = "%i "
L["Placement Mode"] = " "
L["Play"] = ""
L["Player"] = ""
L["Player Character"] = " "
L["Player Class"] = " "
L["Player Effective Level"] = "  "
L["Player Experience"] = " "
L["Player Faction"] = " "
L["Player Level"] = " "
L["Player Location ID(s)"] = "   ID ( )"
L["Player Money"] = " "
L["Player Name/Realm"] = " /"
L["Player Race"] = " "
L["Player(s) Affected"] = "   "
L["Player(s) Not Affected"] = "    "
L["Player/Unit Info"] = "/ "
L["Players and Pets"] = " "
L["Poison"] = ""
L["Power"] = ""
L["Power (%)"] = " (%)"
L["Power Deficit"] = " "
L["Power Type"] = " "
L["Precision"] = ""
L["Preset"] = " "
L["Primary Stats"] = " "
L["Princess Huhuran"] = " "
L["Print Profiling Results"] = "  "
L["Proc Glow"] = "  "
L["Profiling already started."] = "  ."
L["Profiling automatically started."] = "  ."
L["Profiling not running."] = "   ."
L["Profiling started."] = " ."
L["Profiling started. It will end automatically in %d seconds"] = " . %d   ."
L["Profiling still running, stop before trying to print."] = "   .    ."
L["Profiling stopped."] = " ."
L["Progress"] = " "
L["Progress Source"] = " "
L["Progress Total"] = " "
L["Progress Value"] = " "
L["Pull"] = ""
L["Pulse"] = ""
L["PvP Flagged"] = "   "
L["PvP Talent selected"] = " PvP "
L["PvP Talent Selected"] = " PvP "
L["Quality Id"] = " Id"
L["Quantity"] = ""
L["Quantity earned this week"] = " "
L["Quest Party"] = " "
L["Queued Action"] = " "
L["Radius"] = ""
L["Ragnaros"] = ""
L["Raid"] = ""
L["Raid (Heroic)"] = " ()"
L["Raid (Mythic)"] = " ()"
L["Raid (Normal)"] = " ()"
L["Raid (Timewalking)"] = " ()"
L["Raid Mark"] = " "
L["Raid Mark Icon"] = "  "
L["Raid Role"] = " "
L["Raid Warning"] = " "
L["Raids"] = ""
L["Range"] = " "
L["Range Check"] = " "
L["Ranged"] = ""
L["Rank"] = ""
L["Rare"] = ""
L["Rare Elite"] = " "
L["Rated Arena"] = " "
L["Rated Battleground"] = " "
L["Raw Threat Percent"] = "   "
L["Razorgore the Untamed"] = " "
L["Ready Check"] = " "
L["Reagent Quality"] = " "
L["Reagent Quality Texture"] = "  "
L["Realm"] = ""
L["Realm Name"] = ""
L["Realm of Caster's Target"] = "  "
L["Reborn Council"] = " "
L["Receiving %s Bytes"] = "%s  "
L["Receiving display information"] = "   "
L["Reflect"] = ""
L["Region type %s not supported"] = " (Region)  %s|1;;  "
L["Relative"] = ""
L["Relative X-Offset"] = " X- "
L["Relative Y-Offset"] = " Y- "
L["Remaining Duration"] = " "
L["Remaining Time"] = " "
L["Remove Obsolete Auras"] = "  "
L["Renown Level"] = " "
L["Renown Max Level"] = "  "
L["Renown Reputation"] = " "
L["Repair"] = ""
L["Repeat"] = ""
L["Report Summary"] = " "
L["Reputation"] = ""
L["Reputation (%)"] = " (%)"
L["Requested display does not exist"] = "   "
L["Requested display not authorized"] = "   "
L["Requesting display information from %s ..."] = "%s|1;;     ..."
L["Require Valid Target"] = "  "
L["Requires syncing the specialization via LibSpecialization."] = "   LibSpecialization ."
L["Resilience (%)"] = " (%)"
L["Resilience Rating"] = " "
L["Resist"] = ""
L["Resistances"] = ""
L["Resisted"] = ""
L["Rested"] = " "
L["Rested Experience"] = " "
L["Rested Experience (%)"] = "  (%)"
L["Resting"] = " "
L["Resurrect"] = ""
L["Resurrect Pending"] = "  "
L["Right"] = ""
L["Right to Left"] = " "
L["Right, then Centered Vertical"] = ",  "
L["Right, then Down"] = ", "
L["Right, then Up"] = ", "
L["Role"] = ""
L["Rollback snapshot is complete. Thank you for your patience!"] = "  .   !"
L["Rotate Animation"] = " "
L["Rotate Left"] = " "
L["Rotate Right"] = " "
L["Rotation"] = ""
L["Round"] = ""
L["Round Mode"] = " "
L["Ruins of Ahn'Qiraj"] = " "
L["Run Custom Code"] = "   "
L["Run Speed (%)"] = "  (%)"
L["Rune"] = ""
L["Rune #1"] = " #1"
L["Rune #2"] = " #2"
L["Rune #3"] = " #3"
L["Rune #4"] = " #4"
L["Rune #5"] = " #5"
L["Rune #6"] = " #6"
L["Rune Count"] = " "
L["Rune Count - Blood"] = "  - "
L["Rune Count - Frost"] = "  - "
L["Rune Count - Unholy"] = "  - "
L["Sapphiron"] = ""
L["Say"] = " "
L["Scale"] = ""
L["Scarlet Enclave"] = " "
L["Scenario"] = ""
L["Scenario (Heroic)"] = " ()"
L["Scenario (Normal)"] = " ()"
L["Screen"] = ""
L["Screen/Parent Group"] = "/ "
L["Season of Discovery"] = " "
L["Second"] = " "
L["Second Value of Tooltip Text"] = "   "
L["Secondary Stats"] = "2 "
L["Seconds"] = ""
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[  .  :
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Select Frame"] = " "
L["Select the type of timer to filter"] = "   "
L["Selection Mode"] = " "
L["Separator"] = ""
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = " ID wowhead.com/cata/item-sets     "
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = " ID wowhead.com/classic/item-sets     ."
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = " ID Wowhead.com/item-sets     ."
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = " ID wowhead.com/mop-classic/item-sets     ."
L["Shadow Resistance"] = " "
L["Shadowlands"] = ""
L["Shake"] = ""
L["Shazzrah"] = ""
L["Shift-Click to resume addon execution."] = "+   ."
L["Show"] = ""
L["Show CD of Charge"] = "  "
L["Show charged duration for empowered casts"] = "     "
L["Show GCD"] = "  "
L["Show Global Cooldown"] = "  "
L["Show Incoming Heal"] = "  "
L["Show Loss of Control"] = "   "
L["Show On"] = " "
L["Show Rested Overlay"] = "  "
L["Shrink"] = ""
L["Silithid Royalty"] = " "
L["Silver"] = ""
L["Simple"] = " "
L["Since Active"] = " "
L["Since Apply"] = "  "
L["Since Apply/Refresh"] = " / "
L["Since Charge Gain"] = "  "
L["Since Charge Lost"] = "  "
L["Since Ready"] = "  "
L["Since Stack Gain"] = "  "
L["Since Stack Lost"] = "  "
L["Size & Position"] = " & "
L["Skyriding"] = ""
L["Slide Animation"] = " "
L["Slide from Bottom"] = " "
L["Slide from Left"] = " "
L["Slide from Right"] = " "
L["Slide from Top"] = " "
L["Slide to Bottom"] = " "
L["Slide to Left"] = " "
L["Slide to Right"] = " "
L["Slide to Top"] = " "
L["Slider"] = ""
L["Small"] = ""
L["Smart Group"] = " "
L["Soft Enemy"] = "  "
L["Soft Friend"] = "  "
L["Solistrasza"] = ""
L["Sound"] = ""
L["Sound by Kit ID"] = "Kit ID  "
L["Source"] = ""
L["Source Affiliation"] = " "
L["Source GUID"] = " GUID"
L["Source Info"] = " "
L["Source Name"] = " "
L["Source NPC Id"] = " NPC ID"
L["Source Object Type"] = "  "
L["Source Raid Mark"] = "  "
L["Source Reaction"] = " "
L["Source Unit"] = " "
L["Source Unit Name/Realm"] = "  /"
L["Source unit's raid mark index"] = "    "
L["Source unit's raid mark texture"] = "    "
L["Space"] = ""
L["Spacing"] = ""
L["Spark"] = ""
L["Spec Position"] = " "
L["Spec Role"] = " "
L["Specialization"] = ""
L["Specific Currency"] = "  "
L["Specific Type"] = " "
L["Specific Unit"] = "  "
L["Spell"] = ""
L["Spell (Building)"] = " ()"
L["Spell Activation Overlay Glow"] = "   "
L["Spell Cast Succeeded"] = "  "
L["Spell Cost"] = "  "
L["Spell Count"] = "   "
L["Spell ID"] = " ID"
L["Spell Id"] = " ID"
L["Spell ID:"] = " ID:"
L["Spell IDs:"] = " ID ( ):"
L["Spell in Range"] = "   "
L["Spell Known"] = " "
L["Spell Name"] = " "
L["Spell Peneration Percent"] = "  "
L["Spell Power"] = ""
L["Spell School"] = " "
L["Spell Usable"] = "  "
L["Spellname"] = " "
L["Spike"] = " "
L["Spin"] = ""
L["Spiral"] = ""
L["Spiral In And Out"] = " "
L["Spirit"] = ""
L["Stack Count"] = " "
L["Stack trace:"] = " :"
L["Stacks"] = ""
L["Stacks Function"] = " "
L["Stacks Function (fallback state)"] = "Stacks  (  )"
L["Stage"] = ""
L["Stage Counter"] = " "
L["Stagger"] = ""
L["Stagger (%)"] = " (%)"
L["Stagger against Target (%)"] = "   (%)"
L["Stagger Scale"] = "  "
L["Stamina"] = ""
L["Stance/Form/Aura"] = "//"
L["Standing"] = ""
L["Star Shake"] = " "
L["Start Animation"] = " "
L["Start Now"] = " "
L["Start Profiling"] = " "
L["Status"] = ""
L["Status Bar"] = " "
L["Stolen"] = " "
L["Stop"] = ""
L["Stop Motion"] = " "
L["Story Raid"] = " "
L["Strength"] = ""
L["String"] = ""
L["Subevent Info"] = " "
L["Subtract Cast"] = "  "
L["Subtract Channel"] = "   "
L["Subtract GCD"] = "  "
L["Subzone Name"] = " "
L["Success"] = ""
L["Sulfuron Harbinger"] = " "
L["Summon"] = ""
L["Summon Pending"] = "  "
L["Sun"] = ""
L["Supports multiple entries, separated by commas"] = "    "
L[ [=[Supports multiple entries, separated by commas
]=] ] = "    "
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "    . ','    '\\'    .  '-'    ."
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "    .  \\    .  '-'    ."
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "    .     '-' ."
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = "    .  (Child Zone) ID  'c2022' 'c'  .  (Group Zone) ID 'g277' 'g'   . (Area) ID https://wago.tools/db2/AreaTable    'a'  . (Instance) ID 'i'  .   '-'         ."
L["Swing"] = " "
L["Swing Timer"] = "  "
L["Swipe"] = " "
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = " /wa feature <toggle|on|enable|disable|off> <feature>"
L["System"] = ""
L["Systems"] = ""
L["Tab "] = ""
L["Talent"] = ""
L["Talent |cFFFF0000Not|r Known"] = " |cFFFF0000|r "
L["Talent |cFFFF0000Not|r Selected"] = " |cFFFF0000|r "
L["Talent Known"] = " "
L["Talent Selected"] = " "
L["Talent selected"] = " "
L["Talent Specialization"] = " "
L["Tanking And Highest"] = "   "
L["Tanking But Not Highest"] = "    "
L["Target"] = ""
L["Targeted"] = " "
L["Tertiary Stats"] = "3 "
L["Test if bar is enabled in BigWigs settings"] = "  BigWigs    "
L["Test if bar is enabled in Boss Mod addon settings"] = "       "
L["Test if bar is enabled in DBM settings"] = "  DBM    "
L["Text"] = ""
L["Text To Speech"] = "  "
L["Text-to-speech"] = "  "
L["Texture"] = ""
L["Texture Function"] = " "
L["Texture Function (fallback state)"] = "Texture  (  )"
L["Texture Picker"] = " "
L["Texture Rotation"] = " "
L["Thaddius"] = ""
L["The aura has overwritten the global '%s', this might affect other auras."] = "   '%s'|1;; .     ."
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "  aura_env     .   ."
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "          ."
L["The Four Horsemen"] = "4"
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "'ID'   BigWigs  "
L["The Prophet Skeram"] = " "
L["The total quantity a warband character can transfer after paying the transfer cost"] = "         "
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "          "
L["The War Within"] = " "
L["There are %i updates to your auras ready to be installed!"] = " %i    !"
L["Thick Outline"] = " "
L["Thickness"] = ""
L["Third"] = " "
L["Third Value of Tooltip Text"] = "   "
L["This aura calls GetData a lot, which is a slow function."] = "    GetData   ."
L["This aura has caused a Lua error."] = "  Lua  ."
L["This aura is saving %s KB of data"] = "  %s KB   "
L["This aura plays a sound via a condition."] = "      ."
L["This aura plays a sound via an action."] = "      ."
L["This aura plays a Text To Speech via a condition."] = "        ."
L["This aura plays a Text To Speech via an action."] = "        ."
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "     .          WeakAuras Discord    ."
L["Threat Percent"] = "  "
L["Threat Situation"] = "  "
L["Threat Value"] = "  "
L["Tick"] = ""
L["Time"] = ""
L["Time Format"] = ""
L["Time in GCDs"] = "   "
L["Time since initial application"] = "    "
L["Time since last refresh"] = "    "
L["Time since stack gain"] = "   "
L["Time since stack lost"] = "   "
L["Timed"] = " "
L["Timed Progress"] = " "
L["Timer"] = ""
L["Timer Id"] = " ID"
L["Toggle"] = "/"
L["Toggle List"] = " /"
L["Toggle Options Window"] = " /"
L["Toggle Performance Profiling Window"] = "   /"
L["Tooltip"] = ""
L["Tooltip 1"] = " 1"
L["Tooltip 2"] = " 2"
L["Tooltip 3"] = " 3"
L["Tooltip Value 1"] = "  1"
L["Tooltip Value 2"] = "  2"
L["Tooltip Value 3"] = "  3"
L["Tooltip Value 4"] = "  4"
L["Top"] = ""
L["Top Left"] = " "
L["Top Right"] = " "
L["Top to Bottom"] = " "
L["Torghast"] = ""
L["Total Duration"] = " "
L["Total Earned in this Season"] = "   "
L["Total Essence"] = " "
L["Total Experience"] = " "
L["Total Match Count"] = "    "
L["Total Reputation"] = " "
L["Total Stacks"] = " "
L["Total stacks over all matches"] = "    "
L["Total Stages"] = " "
L["Total Unit Count"] = "  "
L["Total Units"] = " "
L["Totem"] = ""
L["Totem #%i"] = " #%i"
L["Totem Icon"] = " "
L["Totem Name"] = " "
L["Totem Name Pattern Match"] = "   "
L["Totem Number"] = " "
L["Track Cooldowns"] = "  "
L["Tracking Charge %i"] = "%i  "
L["Tracking Charge CDs"] = "  "
L["Tracking Only Cooldown"] = " "
L["Transmission error"] = " "
L["Trigger"] = " "
L["Trigger %i"] = "  %i"
L["Trigger %s"] = "  %s"
L["Trigger 1"] = "  1"
L["Trigger State Updater (Advanced)"] = "(State)    ()"
L["Trigger Update"] = "   "
L["Trigger:"] = " :"
L["Trivial (Low Level)"] = "  ()"
L["True"] = ""
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "%s WeakAuras      ."
L["Twin Emperors"] = " "
L["Type"] = ""
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "'%s'    .       .   WeakAuras   ."
L["Unaffected"] = "   "
L["Undefined"] = "  "
L["Unholy"] = ""
L["Unholy Rune #1"] = "  #1"
L["Unholy Rune #2"] = "  #2"
L["Unit"] = ""
L["Unit Characteristics"] = " "
L["Unit Destroyed"] = " "
L["Unit Died"] = " "
L["Unit Dissipates"] = " "
L["Unit Frame"] = " "
L["Unit Frames"] = " "
L["Unit is Unit"] = " "
L["Unit Name"] = " "
L["Unit Name/Realm"] = " /"
L["Units Affected"] = "   "
L["Units of affected Players in a table format"] = "       "
L["Units of unaffected Players in a table format"] = "       "
L["Unknown action %q"] = "    %q"
L["Unknown feature %q"] = "    %q"
L["unknown location"] = "   "
L["Unlimited"] = ""
L["Untrigger %s"] = "  %s"
L["Up"] = ""
L["Up, then Centered Horizontal"] = ",  "
L["Up, then Left"] = ", "
L["Up, then Right"] = ", "
L["Update Position"] = " "
L["Usage:"] = ":"
L["Use /wa minimap to show the minimap icon again."] = "    /wa minimap  ."
L["Use Custom Color"] = "   "
L["Use Legacy floor rounding"] = "   "
L["Use Texture"] = " "
L["Use Watched Faction"] = "  "
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "      UnitInRange() .            25~40  ."
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "WeakAuras.clones    . WeakAuras.GetRegion(id, cloneId) ."
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "WeakAuras.regions    . WeakAuras.GetRegion(id) ."
L["Vaelastrasz the Corrupt"] = " "
L["Versatility (%)"] = " (%)"
L["Versatility Rating"] = " "
L["Vertical"] = ""
L["Viscidus"] = ""
L["Visibility"] = ""
L["Visions of N'Zoth"] = " "
L["Warband Quantity Total"] = "   "
L["Warband Transfer Percentage"] = "  "
L["Warband Transferred Quantity"] = "  "
L["Warfront (Heroic)"] = " ()"
L["Warfront (Normal)"] = " ()"
L["Warlords of Draenor"] = " "
L["Warning"] = ""
L["Warning for unknown aura:"] = "    :"
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = ":     '%s'   ."
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = ":      ID     ."
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = ":  %affected, %unaffected      .     %unitCount .     .    ."
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = ":    %s  %tooltip1, %tooltip2, %tooltip3   .    ."
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras  (63:42 | 3:07 | 10 | 2.4)"
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras   .    https://discord.gg/weakauras  ."
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras  .
      .
|cffff0000|r    ?          .
 : %s

|cffff0000    WTF   .|r]=]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras     .             .       ."
L["WeakAuras Profiling"] = "WeakAuras  "
L["WeakAuras Profiling Report"] = "WeakAuras   "
L["WeakAuras Version: %s"] = "WeakAuras : %s"
L["Weapon"] = ""
L["Weapon Enchant"] = "  "
L["Weapon Enchant / Fishing Lure"] = "   /  "
L["Whisper"] = ""
L["Width"] = ""
L["Wobble"] = ""
L["World Boss"] = " "
L["World Bosses"] = " "
L["Wrap"] = ""
L["Wrath of the Lich King"] = "  "
L["Writing to the WeakAuras table is not allowed."] = "WeakAuras     ."
L["X-Offset"] = "X- "
L["Yell"] = ""
L["Y-Offset"] = "Y- "
L["You have new auras ready to be installed!"] = "    !"
L["Your next encounter will automatically be profiled."] = "     ."
L["Your next instance of combat will automatically be profiled."] = "     ."
L["Your scheduled automatic profile has been cancelled."] = "   ."
L["Your threat as a percentage of the tank's current threat."] = "        ."
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "         . 100  ."
L["Your total threat on the mob."] = "     ."
L["Zone Group ID"] = "  ID"
L["Zone ID"] = " ID"
L["Zone Name"] = " "
L["Zoom"] = ""
L["Zoom Animation"] = " "
L["Zul'Gurub"] = ""



-- ========================================
-- File: WeakAuras/Locales/ptBR.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "ptBR" then
  return
end

local L = WeakAuras.L

-- WeakAuras
--[[Translation missing --]]
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=]
L["%s Overlay Color"] = "%s Cor de Sobreposio"
L["* Suffix"] = "* Sufixo"
L["/wa help - Show this message"] = "/wa help - Mostrar essa mensagem"
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - Mostrar/esconder o cone de minimapa"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - Mostra os resultados da criao de perfil mais recente"
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart - Inicia a criao de perfil. Opcionalmente inclui uma durao em segundos em que a criao de perfis automaticamente para. Para traar o perfil do prximo combate/encontro, passe um argumento de \"combate\" ou \"encontro\"."
L["/wa pstop - Finish profiling"] = "/wa pstop - Concluir criao de perfil"
L["/wa repair - Repair tool"] = "/wa repair - Ferramenta de reparo"
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55fLeft-Click|r para alternar a exibio da janela principal."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55fMiddle-Click|r para esconder ou mostrar o cone do minimapa."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55fRight-Click|r mostrar/esconder a janela de perfil de desempenho."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fShift-Click|r para pausar a execuo do addon."
--[[Translation missing --]]
L["|cffff0000deprecated|r"] = "|cffff0000deprecated|r"
--[[Translation missing --]]
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000Not|r Item Bonus Id Equipped"
--[[Translation missing --]]
L["|cFFFF0000Not|r Item Equipped"] = "|cFFFF0000Not|r Item Equipped"
--[[Translation missing --]]
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000Not|r Player Name/Realm"
--[[Translation missing --]]
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000Not|r Spell Known"
--[[Translation missing --]]
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=]
L["|cFFffcc00Extra Options:|r %s"] = [=[|cFFffcc00Opes Extra:|r %s

]=]
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00Opes Extra:|r Nenhuma"
--[[Translation missing --]]
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=]
--[[Translation missing --]]
L["1. Profession 1. Accessory"] = "1. Profession 1. Accessory"
--[[Translation missing --]]
L["1. Profession 2. Accessory"] = "1. Profession 2. Accessory"
--[[Translation missing --]]
L["1. Professsion Tool"] = "1. Professsion Tool"
L["10 Man Raid"] = "Raide de 10 jogadores"
--[[Translation missing --]]
L["10 Player Raid"] = "10 Player Raid"
--[[Translation missing --]]
L["10 Player Raid (Heroic)"] = "10 Player Raid (Heroic)"
--[[Translation missing --]]
L["10 Player Raid (Normal)"] = "10 Player Raid (Normal)"
--[[Translation missing --]]
L["2. Profession 1. Accessory"] = "2. Profession 1. Accessory"
--[[Translation missing --]]
L["2. Profession 2. Accessory"] = "2. Profession 2. Accessory"
--[[Translation missing --]]
L["2. Professsion Tool"] = "2. Professsion Tool"
L["20 Man Raid"] = "Raide de 20 jogadores"
--[[Translation missing --]]
L["20 Player Raid"] = "20 Player Raid"
L["25 Man Raid"] = "Raide de 25 jogadores"
--[[Translation missing --]]
L["25 Player Raid"] = "25 Player Raid"
--[[Translation missing --]]
L["25 Player Raid (Heroic)"] = "25 Player Raid (Heroic)"
--[[Translation missing --]]
L["25 Player Raid (Normal)"] = "25 Player Raid (Normal)"
L["40 Man Raid"] = "Raide de 40 jogadores"
--[[Translation missing --]]
L["40 Player Raid"] = "40 Player Raid"
L["5 Man Dungeon"] = "Masmorra de 5 jogadores"
--[[Translation missing --]]
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=]
--[[Translation missing --]]
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."
L["Abbreviate"] = "Abreviar"
L["AbbreviateLargeNumbers (Blizzard)"] = "AbreviarNmerosGrandes (Blizzard)"
L["AbbreviateNumbers (Blizzard)"] = "AbreviarNmeros (Blizzard)"
L["Absorb"] = "Absorver"
--[[Translation missing --]]
L["Absorb and Healing"] = "Absorb and Healing"
--[[Translation missing --]]
L["Absorb Heal Overlay"] = "Absorb Heal Overlay"
--[[Translation missing --]]
L["Absorb Overlay"] = "Absorb Overlay"
L["Absorbed"] = "Absorvido"
L["Action Button Glow"] = "Brilho do boto de ao"
L["Actions"] = "Aes"
L["Active"] = "Ativo"
--[[Translation missing --]]
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
--[[Translation missing --]]
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
L["Add"] = "Adicionar"
L["Add Missing Auras"] = "Adicionar auras faltantes"
--[[Translation missing --]]
L["Advanced Caster's Target Check"] = "Advanced Caster's Target Check"
L["Affected"] = "Afetado"
L["Affected Unit Count"] = "Contagem de unidades afetadas"
--[[Translation missing --]]
L["Afk"] = "Afk"
L["Aggro"] = "Aggro"
L["Agility"] = "Agilidade"
L["Ahn'Qiraj"] = "Ahn'Qiraj"
L["Alert Type"] = "Tipo de alerta"
L["Alive"] = "Vivo"
L["All"] = "Todos"
--[[Translation missing --]]
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "All children of this aura will also not be loaded, to minimize the chance of further corruption."
--[[Translation missing --]]
L["All States table contains a non table at key: '%s'."] = "All States table contains a non table at key: '%s'."
L["All Triggers"] = "Todos os Gatilhos"
L["Alliance"] = "Aliana"
L["Allow partial matches"] = "Permitir combinaes parciais"
L["Alpha"] = "Transparncia"
L["Alternate Power"] = "Alternar Poder"
L["Always"] = "Sempre"
L["Always active trigger"] = "Gatilho sempre ativo"
L["Always include realm"] = "Sempre incluir reino"
L["Always True"] = "Sempre Verdadeiro"
L["Amount"] = "Quantidade"
--[[Translation missing --]]
L["Anchoring"] = "Anchoring"
L["And Talent"] = "E Tambm o Talento"
--[[Translation missing --]]
L["Angle and Radius"] = "Angle and Radius"
L["Animations"] = "Animaes"
L["Anticlockwise"] = "Anti-horrio"
L["Anub'Rekhan"] = "Anub'Rekhan"
L["Any"] = "Qualquer"
L["Any Triggers"] = "Quaisquer gatilhos"
L["AOE"] = "AOE"
L["Arcane Resistance"] = "Resistncia Arcana"
--[[Translation missing --]]
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=]
L["Arena"] = "Arena"
L["Armor (%)"] = "Armadura (%)"
L["Armor against Target (%)"] = "Armadura contra o Alvo (%)"
L["Armor Rating"] = "Classificao de armadura"
L["Array"] = "Arranjo"
L["Ascending"] = "Ascendente"
L["Assigned Role"] = "Funo Atribuda"
--[[Translation missing --]]
L["Assigned Role Icon"] = "Assigned Role Icon"
--[[Translation missing --]]
L["Assist"] = "Assist"
--[[Translation missing --]]
L["Assisted Combat Next Cast"] = "Assisted Combat Next Cast"
L["At Least One Enemy"] = "Pelo Menos Um Inimigo"
L["At missing Value"] = "No valor ausente"
L["At Percent"] = "Na porcentagem"
L["At Value"] = "Em valor"
--[[Translation missing --]]
L["At War"] = "At War"
L["Attach to End"] = "Anexar ao final"
--[[Translation missing --]]
L["Attach to End, backwards"] = "Attach to End, backwards"
--[[Translation missing --]]
L["Attach to Point"] = "Attach to Point"
L["Attach to Start"] = "Anexar ao inicio"
L["Attack Power"] = "Poder de ataque"
L["Attackable"] = "Atacvel"
L["Attackable Target"] = "Alvo atacvel "
L["Aura"] = "Aura"
L["Aura '%s': %s"] = "Aura '%s': %s"
L["Aura Applied"] = "Aura Aplicada"
L["Aura Applied Dose"] = "Dose de Aura Aplicada"
L["Aura Broken"] = "Aura violada"
L["Aura Broken Spell"] = "Feitio violar de aura"
--[[Translation missing --]]
L["Aura is using deprecated SetDurationInfo"] = "Aura is using deprecated SetDurationInfo"
--[[Translation missing --]]
L["Aura loaded"] = "Aura loaded"
L["Aura Name"] = "Nome da Aura"
L["Aura Names"] = "Nomes das Auras"
L["Aura Refresh"] = "Aura Restaurada"
L["Aura Removed"] = "Aura Removida"
L["Aura Removed Dose"] = "Dose de Aura Removida"
L["Aura Stack"] = "Monte da Aura"
L["Aura Type"] = "Tipo de Aura"
--[[Translation missing --]]
L["Aura Version: %s"] = "Aura Version: %s"
L["Aura(s) Found"] = "Aura(s) Encontrada(s)"
L["Aura(s) Missing"] = "Aura(s) Faltando"
L["Aura:"] = "Aura:"
--[[Translation missing --]]
L["Auras"] = "Auras"
L["Auras:"] = "Auras:"
L["Author Options"] = "Opes de Autor"
L["Auto"] = "Auto"
--[[Translation missing --]]
L["Autocast Shine"] = "Autocast Shine"
L["Automatic"] = "Automtico"
L["Automatic Length"] = "Comprimento Automtico"
L["Automatic Rotation"] = "Rotao Automtica"
--[[Translation missing --]]
L["Available features: %s"] = "Available features: %s"
--[[Translation missing --]]
L["Avoidance (%)"] = "Avoidance (%)"
--[[Translation missing --]]
L["Avoidance Rating"] = "Avoidance Rating"
L["Ayamiss the Hunter"] = "Ayamiss, o Caador"
--[[Translation missing --]]
L["Azuregos"] = "Azuregos"
L["Back and Forth"] = "Vai e volta"
L["Background"] = "Plano de fundo"
L["Background Color"] = "Cor do Plano de Fundo"
--[[Translation missing --]]
L["Balnazzar"] = "Balnazzar"
--[[Translation missing --]]
L["Bar Color/Gradient Start"] = "Bar Color/Gradient Start"
--[[Translation missing --]]
L["Bar enabled in BigWigs settings"] = "Bar enabled in BigWigs settings"
--[[Translation missing --]]
L["Bar enabled in Boss Mod addon settings"] = "Bar enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Bar enabled in DBM settings"] = "Bar enabled in DBM settings"
--[[Translation missing --]]
L["Bar Texture"] = "Bar Texture"
--[[Translation missing --]]
L["Bar Type"] = "Bar Type"
L["Baron Geddon"] = "Baro Geddon"
--[[Translation missing --]]
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "Battle.net Sussuro"
L["Battleground"] = "Campo de Batalha"
L["Battleguard Sartura"] = "Guarda de Batalha Sartura"
--[[Translation missing --]]
L["Beastmaster"] = "Beastmaster"
--[[Translation missing --]]
L["Beatrix"] = "Beatrix"
L["BG>Raid>Party>Say"] = "CB>Raide>Grupo>Dizer"
L["BG-System Alliance"] = "CB-Sistema da Aliana"
L["BG-System Horde"] = "CB-Sistema da Horda"
L["BG-System Neutral"] = "CB-Sistema Neutro"
L["Big Number"] = "Nmero Grande"
L["BigWigs Addon"] = "Addon BigWigs"
L["BigWigs Message"] = "Mensagem do BigWigs"
--[[Translation missing --]]
L["BigWigs Stage"] = "BigWigs Stage"
L["BigWigs Timer"] = "Cronmetro do BigWigs"
L["Black Wing Lair"] = "Covil Asa Negra"
--[[Translation missing --]]
L["Bleed"] = "Bleed"
L["Blizzard Combat Text"] = "Texto de Combate da Blizzard"
--[[Translation missing --]]
L["Blizzard Cooldown Reduction"] = "Blizzard Cooldown Reduction"
L["Block"] = "Bloquear"
L["Block (%)"] = "Bloqueio (%)"
L["Block against Target (%)"] = "Bloqueio contra o Alvo (%)"
--[[Translation missing --]]
L["Block Value"] = "Block Value"
L["Blocked"] = "Bloqueado"
--[[Translation missing --]]
L["Blood"] = "Blood"
--[[Translation missing --]]
L["Blood Rune #1"] = "Blood Rune #1"
--[[Translation missing --]]
L["Blood Rune #2"] = "Blood Rune #2"
L["Bloodlord Mandokir"] = "Sangrelorde Mandokir"
--[[Translation missing --]]
L["Bonus Reputation Gain"] = "Bonus Reputation Gain"
L["Border"] = "Borda"
L["Boss"] = "Chefe"
L["Boss Emote"] = "Emote do Chefe"
--[[Translation missing --]]
L["Boss Mod Announce"] = "Boss Mod Announce"
--[[Translation missing --]]
L["Boss Mod Stage"] = "Boss Mod Stage"
--[[Translation missing --]]
L["Boss Mod Stage (Event)"] = "Boss Mod Stage (Event)"
--[[Translation missing --]]
L["Boss Mod Timer"] = "Boss Mod Timer"
L["Boss Whisper"] = "Sussurro do Chefe"
L["Bottom"] = "Embaixo"
L["Bottom Left"] = "Embaixo  esquerda"
L["Bottom Right"] = "Embaixo  direita"
L["Bottom to Top"] = "De baixo para cima"
L["Bounce"] = "Salto"
L["Bounce with Decay"] = "Salto com declnio"
--[[Translation missing --]]
L["Break"] = "Break"
--[[Translation missing --]]
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers (Blizzard)"
L["Broodlord Lashlayer"] = "Prolemestre Flagelador"
L["Buff"] = "Buff"
--[[Translation missing --]]
L["Buff/Debuff"] = "Buff/Debuff"
L["Buffed/Debuffed"] = "Buffado/Debuffado"
--[[Translation missing --]]
L["Burning Crusade"] = "Burning Crusade"
L["Buru the Gorger"] = "Buru, o Banqueteador"
--[[Translation missing --]]
L["Caldoran"] = "Caldoran"
--[[Translation missing --]]
L["Callback function"] = "Callback function"
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "Pode ser usado, por exemplo, para checar se \"chefe1alvo\"  o mesmo que \"jogador\"."
L["Cancel"] = "Cancelar"
--[[Translation missing --]]
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "No  possvel agendar o cronmetro com %i, devido a um bug do World of Warcraft com alto tempo de atividade do computador. (Tempo de atividade: %i). Por favor, reinicie o seu computador."
--[[Translation missing --]]
L["Capped"] = "Capped"
--[[Translation missing --]]
L["Capped at Season Max"] = "Capped at Season Max"
--[[Translation missing --]]
L["Capped at Weekly Max"] = "Capped at Weekly Max"
L["Cast"] = "Lanar"
L["Cast Bar"] = "Barra de Lanamento"
L["Cast Failed"] = "Lanamento falho"
L["Cast Start"] = "Comear lanamento"
L["Cast Success"] = "Sucesso no lanamento"
L["Cast Type"] = "Tipo de lanamento"
L["Caster"] = "Lanador"
L["Caster Name"] = "Nome do Lanador"
L["Caster Realm"] = "Reino do Lanador"
L["Caster Unit"] = "Unidade de Lanador"
--[[Translation missing --]]
L["Casters Name/Realm"] = "Casters Name/Realm"
L["Caster's Target"] = "Alvo do Lanador"
--[[Translation missing --]]
L["Cataclysm"] = "Cataclysm"
L["Ceil"] = "Teto"
L["Center"] = "Centro"
--[[Translation missing --]]
L["Center, then alternating bottom and top"] = "Center, then alternating bottom and top"
--[[Translation missing --]]
L["Center, then alternating left and right"] = "Center, then alternating left and right"
--[[Translation missing --]]
L["Center, then alternating right and left"] = "Center, then alternating right and left"
--[[Translation missing --]]
L["Center, then alternating top and bottom"] = "Center, then alternating top and bottom"
L["Centered Horizontal"] = "Centralizado Horizontalmente"
--[[Translation missing --]]
L["Centered Horizontal, then Centered Vertical"] = "Centered Horizontal, then Centered Vertical"
--[[Translation missing --]]
L["Centered Horizontal, then Down"] = "Centered Horizontal, then Down"
--[[Translation missing --]]
L["Centered Horizontal, then Up"] = "Centered Horizontal, then Up"
L["Centered Vertical"] = "Centralizado Verticalmente"
--[[Translation missing --]]
L["Centered Vertical, then Centered Horizontal"] = "Centered Vertical, then Centered Horizontal"
--[[Translation missing --]]
L["Centered Vertical, then Left"] = "Centered Vertical, then Left"
--[[Translation missing --]]
L["Centered Vertical, then Right"] = "Centered Vertical, then Right"
L["Changed"] = "Mudou"
L["Channel"] = "Canal"
L["Channel (Spell)"] = "Canal (Feitio)"
--[[Translation missing --]]
L["Character GUID"] = "Character GUID"
--[[Translation missing --]]
L["Character Name"] = "Character Name"
L["Character Stats"] = "Atributos do Personagem"
--[[Translation missing --]]
L["Character Transferred Quantity"] = "Character Transferred Quantity"
L["Character Type"] = "Tipo de personagem"
L["Charge gained/lost"] = "Carga ganha/perdida"
--[[Translation missing --]]
L["Charged Combo Points"] = "Charged Combo Points"
L["Charges"] = "Cargas"
--[[Translation missing --]]
L["Charges Changed Event"] = "Charges Changed Event"
--[[Translation missing --]]
L["Charging"] = "Charging"
L["Chat Frame"] = "Quadro do bate-papo"
L["Chat Message"] = "Mensagem de bate-papo"
--[[Translation missing --]]
L["Check if a single talent match a Rank"] = "Check if a single talent match a Rank"
--[[Translation missing --]]
L["Check nameplate's target every 0.2s"] = "Check nameplate's target every 0.2s"
L["Chromaggus"] = "Chromaggus"
L["Circle"] = "Crculo"
--[[Translation missing --]]
L["Circular Texture"] = "Circular Texture"
--[[Translation missing --]]
L["Clamp"] = "Clamp"
L["Class"] = "Classe"
L["Class and Specialization"] = "Classe e Especializao"
--[[Translation missing --]]
L["Classic"] = "Classic"
L["Classification"] = "Classificao"
L["Clockwise"] = "Sentido Horrio"
--[[Translation missing --]]
L["Clone per Character"] = "Clone per Character"
--[[Translation missing --]]
L["Clone per Event"] = "Clone per Event"
--[[Translation missing --]]
L["Clone per Match"] = "Clone per Match"
--[[Translation missing --]]
L["Coin Precision"] = "Coin Precision"
L["Color"] = "Cor"
--[[Translation missing --]]
L["Color Animation"] = "Color Animation"
L["Combat Log"] = "Registro de combate"
--[[Translation missing --]]
L["Communities"] = "Communities"
--[[Translation missing --]]
L["Condition Custom Test"] = "Condition Custom Test"
L["Conditions"] = "Condies"
L["Contains"] = "Contm"
--[[Translation missing --]]
L["Continuously update Movement Speed"] = "Continuously update Movement Speed"
L["Cooldown"] = "Tempo de Recarga"
--[[Translation missing --]]
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"
L["Cooldown Progress (Item)"] = "Curso do tempo de recarga (Item)"
--[[Translation missing --]]
L["Cooldown Progress (Slot)"] = "Cooldown Progress (Slot)"
--[[Translation missing --]]
L["Cooldown Ready Event"] = "Cooldown Ready Event"
--[[Translation missing --]]
L["Cooldown Ready Event (Item)"] = "Cooldown Ready Event (Item)"
--[[Translation missing --]]
L["Cooldown Ready Event (Slot)"] = "Cooldown Ready Event (Slot)"
--[[Translation missing --]]
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."
--[[Translation missing --]]
L["Cooldown/Charges/Count"] = "Cooldown/Charges/Count"
--[[Translation missing --]]
L["Copper"] = "Copper"
--[[Translation missing --]]
L["Could not load WeakAuras Archive, the addon is %s"] = "Could not load WeakAuras Archive, the addon is %s"
--[[Translation missing --]]
L["Count"] = "Count"
--[[Translation missing --]]
L["Counter Clockwise"] = "Counter Clockwise"
L["Create"] = "Criar"
--[[Translation missing --]]
L["Creature Family"] = "Creature Family"
--[[Translation missing --]]
L["Creature Family Name"] = "Creature Family Name"
--[[Translation missing --]]
L["Creature Type"] = "Creature Type"
--[[Translation missing --]]
L["Creature Type Name"] = "Creature Type Name"
L["Critical"] = "Crtico"
--[[Translation missing --]]
L["Critical (%)"] = "Critical (%)"
--[[Translation missing --]]
L["Critical Rating"] = "Critical Rating"
--[[Translation missing --]]
L["Crop X"] = "Crop X"
--[[Translation missing --]]
L["Crop Y"] = "Crop Y"
L["Crowd Controlled"] = "Sob efeito de C/C"
L["Crushing"] = "Esmagador"
--[[Translation missing --]]
L["C'thun"] = "C'thun"
--[[Translation missing --]]
L["Cumulated time used during profiling"] = "Cumulated time used during profiling"
--[[Translation missing --]]
L["Currency"] = "Currency"
--[[Translation missing --]]
L["Current Essence"] = "Current Essence"
--[[Translation missing --]]
L["Current Experience"] = "Current Experience"
--[[Translation missing --]]
L["Current Instance"] = "Current Instance"
--[[Translation missing --]]
L["Current Movement Speed (%)"] = "Current Movement Speed (%)"
--[[Translation missing --]]
L["Current Stage"] = "Current Stage"
--[[Translation missing --]]
L["Current Zone"] = "Current Zone"
--[[Translation missing --]]
L["Current Zone Group"] = "Current Zone Group"
L["Curse"] = "Maldio"
L["Custom"] = "Personalizado"
--[[Translation missing --]]
L["Custom Action"] = "Custom Action"
--[[Translation missing --]]
L["Custom Anchor"] = "Custom Anchor"
--[[Translation missing --]]
L["Custom Check"] = "Custom Check"
--[[Translation missing --]]
L["Custom Color"] = "Custom Color"
--[[Translation missing --]]
L["Custom Condition Code"] = "Custom Condition Code"
--[[Translation missing --]]
L["Custom Configuration"] = "Custom Configuration"
--[[Translation missing --]]
L["Custom Fade Animation"] = "Custom Fade Animation"
L["Custom Function"] = "Funo personalizada"
--[[Translation missing --]]
L["Custom Grow"] = "Custom Grow"
--[[Translation missing --]]
L["Custom Sort"] = "Custom Sort"
--[[Translation missing --]]
L["Custom Text Function"] = "Custom Text Function"
--[[Translation missing --]]
L["Custom Trigger Combination"] = "Custom Trigger Combination"
--[[Translation missing --]]
L["Custom Variables"] = "Custom Variables"
L["Damage"] = "Dano"
L["Damage Shield"] = "Escudo de Dano"
L["Damage Shield Missed"] = "Escudo de dano falho"
L["Damage Split"] = "Dano dividido"
--[[Translation missing --]]
L["DBM Announce"] = "DBM Announce"
--[[Translation missing --]]
L["DBM Stage"] = "DBM Stage"
--[[Translation missing --]]
L["DBM Timer"] = "DBM Timer"
--[[Translation missing --]]
L["Dead"] = "Dead"
--[[Translation missing --]]
L["Death"] = "Death"
L["Death Knight Rune"] = "Runa de Cavaleiro da Morte"
--[[Translation missing --]]
L["Debuff"] = "Debuff"
--[[Translation missing --]]
L["Debuff Class"] = "Debuff Class"
--[[Translation missing --]]
L["Debuff Class Icon"] = "Debuff Class Icon"
--[[Translation missing --]]
L["Debuff Type"] = "Debuff Type"
--[[Translation missing --]]
L["Debug Log contains more than 1000 entries"] = "Debug Log contains more than 1000 entries"
--[[Translation missing --]]
L["Debug Logging enabled"] = "Debug Logging enabled"
--[[Translation missing --]]
L["Debug Logging enabled for '%s'"] = "Debug Logging enabled for '%s'"
--[[Translation missing --]]
L["Defensive Stats"] = "Defensive Stats"
--[[Translation missing --]]
L["Deflect"] = "Deflect"
--[[Translation missing --]]
L["Delve"] = "Delve"
--[[Translation missing --]]
L["Desaturate"] = "Desaturate"
--[[Translation missing --]]
L["Desaturate Background"] = "Desaturate Background"
--[[Translation missing --]]
L["Desaturate Foreground"] = "Desaturate Foreground"
--[[Translation missing --]]
L["Descending"] = "Descending"
L["Description"] = "Descrio"
--[[Translation missing --]]
L["Dest Raid Mark"] = "Dest Raid Mark"
--[[Translation missing --]]
L["Destination Affiliation"] = "Destination Affiliation"
--[[Translation missing --]]
L["Destination GUID"] = "Destination GUID"
--[[Translation missing --]]
L["Destination Info"] = "Destination Info"
--[[Translation missing --]]
L["Destination Name"] = "Destination Name"
--[[Translation missing --]]
L["Destination NPC Id"] = "Destination NPC Id"
--[[Translation missing --]]
L["Destination Object Type"] = "Destination Object Type"
--[[Translation missing --]]
L["Destination Reaction"] = "Destination Reaction"
--[[Translation missing --]]
L["Destination Unit"] = "Destination Unit"
--[[Translation missing --]]
L["Destination unit's raid mark index"] = "Destination unit's raid mark index"
--[[Translation missing --]]
L["Destination unit's raid mark texture"] = "Destination unit's raid mark texture"
--[[Translation missing --]]
L["Difficulty"] = "Difficulty"
--[[Translation missing --]]
L["Disable Spell Known Check"] = "Disable Spell Known Check"
--[[Translation missing --]]
L["Disabled"] = "Disabled"
--[[Translation missing --]]
L["Disabled feature %q"] = "Disabled feature %q"
--[[Translation missing --]]
L["Disabled Spell Known Check"] = "Disabled Spell Known Check"
--[[Translation missing --]]
L["Discovered"] = "Discovered"
--[[Translation missing --]]
L["Disease"] = "Disease"
--[[Translation missing --]]
L["Dispel"] = "Dispel"
--[[Translation missing --]]
L["Dispel Failed"] = "Dispel Failed"
--[[Translation missing --]]
L["Display"] = "Display"
L["Distance"] = "Distncia"
--[[Translation missing --]]
L["Do Not Disturb"] = "Do Not Disturb"
--[[Translation missing --]]
L["Dodge"] = "Dodge"
--[[Translation missing --]]
L["Dodge (%)"] = "Dodge (%)"
--[[Translation missing --]]
L["Dodge Rating"] = "Dodge Rating"
--[[Translation missing --]]
L["Down"] = "Down"
--[[Translation missing --]]
L["Down, then Centered Horizontal"] = "Down, then Centered Horizontal"
--[[Translation missing --]]
L["Down, then Left"] = "Down, then Left"
--[[Translation missing --]]
L["Down, then Right"] = "Down, then Right"
--[[Translation missing --]]
L["Dragonflight"] = "Dragonflight"
--[[Translation missing --]]
L["Drain"] = "Drain"
--[[Translation missing --]]
L["Dropdown Menu"] = "Dropdown Menu"
--[[Translation missing --]]
L["Dumping table"] = "Dumping table"
--[[Translation missing --]]
L["Dungeon (Celestial)"] = "Dungeon (Celestial)"
--[[Translation missing --]]
L["Dungeon (Heroic)"] = "Dungeon (Heroic)"
--[[Translation missing --]]
L["Dungeon (Mythic)"] = "Dungeon (Mythic)"
--[[Translation missing --]]
L["Dungeon (Mythic+)"] = "Dungeon (Mythic+)"
--[[Translation missing --]]
L["Dungeon (Normal)"] = "Dungeon (Normal)"
--[[Translation missing --]]
L["Dungeon (Timewalking)"] = "Dungeon (Timewalking)"
--[[Translation missing --]]
L["Dungeons"] = "Dungeons"
--[[Translation missing --]]
L["Durability Damage"] = "Durability Damage"
--[[Translation missing --]]
L["Durability Damage All"] = "Durability Damage All"
--[[Translation missing --]]
L["Duration"] = "Duration"
--[[Translation missing --]]
L["Duration Function"] = "Duration Function"
--[[Translation missing --]]
L["Duration Function (fallback state)"] = "Duration Function (fallback state)"
--[[Translation missing --]]
L["Ease In"] = "Ease In"
--[[Translation missing --]]
L["Ease In and Out"] = "Ease In and Out"
--[[Translation missing --]]
L["Ease Out"] = "Ease Out"
--[[Translation missing --]]
L["Ebonroc"] = "Ebonroc"
--[[Translation missing --]]
L["Eclipse Direction"] = "Eclipse Direction"
--[[Translation missing --]]
L["Edge"] = "Edge"
--[[Translation missing --]]
L["Edge of Madness"] = "Edge of Madness"
--[[Translation missing --]]
L["Effective Spell Id"] = "Effective Spell Id"
--[[Translation missing --]]
L["Elide"] = "Elide"
--[[Translation missing --]]
L["Elite"] = "Elite"
--[[Translation missing --]]
L["Emote"] = "Emote"
--[[Translation missing --]]
L["Empower Cast End"] = "Empower Cast End"
--[[Translation missing --]]
L["Empower Cast Interrupt"] = "Empower Cast Interrupt"
--[[Translation missing --]]
L["Empower Cast Start"] = "Empower Cast Start"
--[[Translation missing --]]
L["Empowered"] = "Empowered"
--[[Translation missing --]]
L["Empowered 1"] = "Empowered 1"
--[[Translation missing --]]
L["Empowered 2"] = "Empowered 2"
--[[Translation missing --]]
L["Empowered 3"] = "Empowered 3"
--[[Translation missing --]]
L["Empowered 4"] = "Empowered 4"
--[[Translation missing --]]
L["Empowered 5"] = "Empowered 5"
--[[Translation missing --]]
L["Empowered Cast"] = "Empowered Cast"
--[[Translation missing --]]
L["Empowered Cast Fully Charged"] = "Empowered Cast Fully Charged"
--[[Translation missing --]]
L["Empowered Fully Charged"] = "Empowered Fully Charged"
--[[Translation missing --]]
L["Empty"] = "Empty"
--[[Translation missing --]]
L["Enabled feature %q"] = "Enabled feature %q"
--[[Translation missing --]]
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "Enables (incorrect) round down of seconds, which was the previous default behavior."
--[[Translation missing --]]
L["Enchant Applied"] = "Enchant Applied"
--[[Translation missing --]]
L["Enchant Found"] = "Enchant Found"
--[[Translation missing --]]
L["Enchant ID"] = "Enchant ID"
--[[Translation missing --]]
L["Enchant Missing"] = "Enchant Missing"
--[[Translation missing --]]
L["Enchant Name or ID"] = "Enchant Name or ID"
--[[Translation missing --]]
L["Enchant Removed"] = "Enchant Removed"
--[[Translation missing --]]
L["Enchanted"] = "Enchanted"
--[[Translation missing --]]
L["Encounter ID(s)"] = "Encounter ID(s)"
--[[Translation missing --]]
L["Energize"] = "Energize"
--[[Translation missing --]]
L["Enrage"] = "Enrage"
--[[Translation missing --]]
L["Enter a name or a spellId"] = "Enter a name or a spellId"
--[[Translation missing --]]
L["Entering"] = "Entering"
--[[Translation missing --]]
L["Entering/Leaving Combat"] = "Entering/Leaving Combat"
--[[Translation missing --]]
L["Entering/Leaving Encounter"] = "Entering/Leaving Encounter"
--[[Translation missing --]]
L["Entry Order"] = "Entry Order"
--[[Translation missing --]]
L["Environment Type"] = "Environment Type"
--[[Translation missing --]]
L["Environmental"] = "Environmental"
--[[Translation missing --]]
L["Equipment"] = "Equipment"
--[[Translation missing --]]
L["Equipment Set"] = "Equipment Set"
--[[Translation missing --]]
L["Equipment Set Equipped"] = "Equipment Set Equipped"
--[[Translation missing --]]
L["Equipment Slot"] = "Equipment Slot"
--[[Translation missing --]]
L["Equipped"] = "Equipped"
--[[Translation missing --]]
L["Error"] = "Error"
--[[Translation missing --]]
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Error decoding."] = "Error decoding."
--[[Translation missing --]]
L["Error decompressing"] = "Error decompressing"
--[[Translation missing --]]
L["Error decompressing. This doesn't look like a WeakAuras import."] = "Error decompressing. This doesn't look like a WeakAuras import."
--[[Translation missing --]]
L["Error deserializing"] = "Error deserializing"
--[[Translation missing --]]
L["Error Frame"] = "Error Frame"
--[[Translation missing --]]
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "ERROR in '%s' unknown or incompatible sub element type '%s'"
--[[Translation missing --]]
L["Error in Aura '%s'"] = "Error in Aura '%s'"
--[[Translation missing --]]
L["Error not receiving display information from %s"] = "Error not receiving display information from %s"
--[[Translation missing --]]
L["Essence"] = "Essence"
--[[Translation missing --]]
L["Essence #1"] = "Essence #1"
--[[Translation missing --]]
L["Essence #2"] = "Essence #2"
--[[Translation missing --]]
L["Essence #3"] = "Essence #3"
--[[Translation missing --]]
L["Essence #4"] = "Essence #4"
--[[Translation missing --]]
L["Essence #5"] = "Essence #5"
--[[Translation missing --]]
L["Essence #6"] = "Essence #6"
--[[Translation missing --]]
L["Evade"] = "Evade"
L["Event"] = "Evento"
L["Event(s)"] = "Evento(s)"
L["Every Frame"] = "Todo Frame"
--[[Translation missing --]]
L["Every Frame (High CPU usage)"] = "Every Frame (High CPU usage)"
--[[Translation missing --]]
L["Evoker Essence"] = "Evoker Essence"
--[[Translation missing --]]
L["Exact Spell ID(s)"] = "Exact Spell ID(s)"
--[[Translation missing --]]
L["Execute Conditions"] = "Execute Conditions"
--[[Translation missing --]]
L["Experience (%)"] = "Experience (%)"
--[[Translation missing --]]
L["Expertise Bonus"] = "Expertise Bonus"
--[[Translation missing --]]
L["Expertise Rating"] = "Expertise Rating"
--[[Translation missing --]]
L["Extend Outside"] = "Extend Outside"
L["Extra Amount"] = "Quantidade Extra"
L["Extra Attacks"] = "Ataques Extras"
--[[Translation missing --]]
L["Extra Spell Id"] = "Extra Spell Id"
L["Extra Spell Name"] = "Nome da Magia Extra"
--[[Translation missing --]]
L["Faction"] = "Faction"
--[[Translation missing --]]
L["Faction Name"] = "Faction Name"
--[[Translation missing --]]
L["Faction Reputation"] = "Faction Reputation"
--[[Translation missing --]]
L["Fade Animation"] = "Fade Animation"
--[[Translation missing --]]
L["Fade In"] = "Fade In"
--[[Translation missing --]]
L["Fade Out"] = "Fade Out"
--[[Translation missing --]]
L["Fail Alert"] = "Fail Alert"
--[[Translation missing --]]
L["False"] = "False"
--[[Translation missing --]]
L["Fankriss the Unyielding"] = "Fankriss the Unyielding"
--[[Translation missing --]]
L["Feature %q is already disabled"] = "Feature %q is already disabled"
--[[Translation missing --]]
L["Feature %q is already enabled"] = "Feature %q is already enabled"
--[[Translation missing --]]
L["Fetch Absorb"] = "Fetch Absorb"
--[[Translation missing --]]
L["Fetch Heal Absorb"] = "Fetch Heal Absorb"
--[[Translation missing --]]
L["Fetch Legendary Power"] = "Fetch Legendary Power"
--[[Translation missing --]]
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "Fetches the name and icon of the Legendary Power that matches this bonus id."
--[[Translation missing --]]
L["Fill Area"] = "Fill Area"
--[[Translation missing --]]
L["Filter messages with format <message>"] = "Filter messages with format <message>"
--[[Translation missing --]]
L["Fire Resistance"] = "Fire Resistance"
--[[Translation missing --]]
L["Firemaw"] = "Firemaw"
--[[Translation missing --]]
L["First"] = "First"
--[[Translation missing --]]
L["First Value of Tooltip Text"] = "First Value of Tooltip Text"
--[[Translation missing --]]
L["Fixed"] = "Fixed"
--[[Translation missing --]]
L["Fixed Names"] = "Fixed Names"
--[[Translation missing --]]
L["Fixed Size"] = "Fixed Size"
--[[Translation missing --]]
L["Flamegor"] = "Flamegor"
--[[Translation missing --]]
L["Flash"] = "Flash"
--[[Translation missing --]]
L["Flex Raid"] = "Flex Raid"
--[[Translation missing --]]
L["Flip"] = "Flip"
--[[Translation missing --]]
L["Floor"] = "Floor"
--[[Translation missing --]]
L["Focus"] = "Focus"
--[[Translation missing --]]
L["Follower Dungeon"] = "Follower Dungeon"
--[[Translation missing --]]
L["Font"] = "Font"
--[[Translation missing --]]
L["Font Size"] = "Font Size"
--[[Translation missing --]]
L["Forbidden function or table: %s"] = "Forbidden function or table: %s"
--[[Translation missing --]]
L["Foreground"] = "Foreground"
--[[Translation missing --]]
L["Foreground Color"] = "Foreground Color"
--[[Translation missing --]]
L["Form"] = "Form"
--[[Translation missing --]]
L["Format"] = "Format"
--[[Translation missing --]]
L["Format Gold"] = "Format Gold"
--[[Translation missing --]]
L["Formats |cFFFFCC00%unit|r"] = "Formats |cFFFFCC00%unit|r"
--[[Translation missing --]]
L["Formats Player's |cFFFFCC00%guid|r"] = "Formats Player's |cFFFFCC00%guid|r"
--[[Translation missing --]]
L["Forward"] = "Forward"
--[[Translation missing --]]
L["Forward, Reverse Loop"] = "Forward, Reverse Loop"
--[[Translation missing --]]
L["Fourth Value of Tooltip Text"] = "Fourth Value of Tooltip Text"
--[[Translation missing --]]
L["Frame Selector"] = "Frame Selector"
--[[Translation missing --]]
L["Frequency"] = "Frequency"
L["Friendly"] = "Amigvel"
L["Friendly Fire"] = "Fogo Amigo"
--[[Translation missing --]]
L["Friendship Max Rank"] = "Friendship Max Rank"
--[[Translation missing --]]
L["Friendship Rank"] = "Friendship Rank"
--[[Translation missing --]]
L["Friendship Reputation"] = "Friendship Reputation"
--[[Translation missing --]]
L["Frost"] = "Frost"
--[[Translation missing --]]
L["Frost Resistance"] = "Frost Resistance"
--[[Translation missing --]]
L["Frost Rune #1"] = "Frost Rune #1"
--[[Translation missing --]]
L["Frost Rune #2"] = "Frost Rune #2"
--[[Translation missing --]]
L["Full"] = "Full"
--[[Translation missing --]]
L["Full Region"] = "Full Region"
--[[Translation missing --]]
L["Full/Empty"] = "Full/Empty"
--[[Translation missing --]]
L["Gahz'ranka"] = "Gahz'ranka"
--[[Translation missing --]]
L["Gained"] = "Gained"
--[[Translation missing --]]
L["Garr"] = "Garr"
--[[Translation missing --]]
L["Gehennas"] = "Gehennas"
--[[Translation missing --]]
L["General"] = "General"
--[[Translation missing --]]
L["General Rajaxx"] = "General Rajaxx"
--[[Translation missing --]]
L["GetNameAndIcon Function (fallback state)"] = "GetNameAndIcon Function (fallback state)"
--[[Translation missing --]]
L["Glancing"] = "Glancing"
--[[Translation missing --]]
L["Global Cooldown"] = "Global Cooldown"
--[[Translation missing --]]
L["Glow"] = "Glow"
--[[Translation missing --]]
L["Glow External Element"] = "Glow External Element"
--[[Translation missing --]]
L["Gluth"] = "Gluth"
--[[Translation missing --]]
L["Glyph"] = "Glyph"
--[[Translation missing --]]
L["Gold"] = "Gold"
--[[Translation missing --]]
L["Golemagg the Incinerator"] = "Golemagg the Incinerator"
--[[Translation missing --]]
L["Gothik the Harvester"] = "Gothik the Harvester"
--[[Translation missing --]]
L["Gradient"] = "Gradient"
--[[Translation missing --]]
L["Gradient Enabled"] = "Gradient Enabled"
--[[Translation missing --]]
L["Gradient End"] = "Gradient End"
--[[Translation missing --]]
L["Gradient Orientation"] = "Gradient Orientation"
--[[Translation missing --]]
L["Gradient Pulse"] = "Gradient Pulse"
--[[Translation missing --]]
L["Grand Widow Faerlina"] = "Grand Widow Faerlina"
--[[Translation missing --]]
L["Grid"] = "Grid"
--[[Translation missing --]]
L["Grobbulus"] = "Grobbulus"
L["Group"] = "Grupo"
--[[Translation missing --]]
L["Group Arrangement"] = "Group Arrangement"
--[[Translation missing --]]
L["Group Leader/Assist"] = "Group Leader/Assist"
--[[Translation missing --]]
L["Group Size"] = "Group Size"
--[[Translation missing --]]
L["Group Type"] = "Group Type"
--[[Translation missing --]]
L["Grow"] = "Grow"
--[[Translation missing --]]
L["GTFO Alert"] = "GTFO Alert"
--[[Translation missing --]]
L["Guardian"] = "Guardian"
--[[Translation missing --]]
L["Guild"] = "Guild"
--[[Translation missing --]]
L["Hakkar"] = "Hakkar"
--[[Translation missing --]]
L["Hardcore"] = "Hardcore"
L["Has Target"] = "Tem Alvo"
--[[Translation missing --]]
L["Has Vehicle UI"] = "Has Vehicle UI"
--[[Translation missing --]]
L["HasPet"] = "HasPet"
--[[Translation missing --]]
L["Haste (%)"] = "Haste (%)"
--[[Translation missing --]]
L["Haste Rating"] = "Haste Rating"
--[[Translation missing --]]
L["Heal"] = "Heal"
--[[Translation missing --]]
L["Heal Absorb"] = "Heal Absorb"
--[[Translation missing --]]
L["Heal Absorbed"] = "Heal Absorbed"
--[[Translation missing --]]
L["Health"] = "Health"
--[[Translation missing --]]
L["Health (%)"] = "Health (%)"
--[[Translation missing --]]
L["Health Deficit"] = "Health Deficit"
--[[Translation missing --]]
L["Heigan the Unclean"] = "Heigan the Unclean"
--[[Translation missing --]]
L["Height"] = "Height"
--[[Translation missing --]]
L["Hero Talent"] = "Hero Talent"
--[[Translation missing --]]
L["Heroic Party"] = "Heroic Party"
--[[Translation missing --]]
L["Hide"] = "Hide"
--[[Translation missing --]]
L["Hide 0 cooldowns"] = "Hide 0 cooldowns"
--[[Translation missing --]]
L["Hide Timer Text"] = "Hide Timer Text"
--[[Translation missing --]]
L["High Damage"] = "High Damage"
--[[Translation missing --]]
L["High Priest Thekal"] = "High Priest Thekal"
--[[Translation missing --]]
L["High Priest Venoxis"] = "High Priest Venoxis"
--[[Translation missing --]]
L["High Priestess Arlokk"] = "High Priestess Arlokk"
--[[Translation missing --]]
L["High Priestess Jeklik"] = "High Priestess Jeklik"
--[[Translation missing --]]
L["High Priestess Mar'li"] = "High Priestess Mar'li"
--[[Translation missing --]]
L["Higher Than Tank"] = "Higher Than Tank"
--[[Translation missing --]]
L["Highest Spell Id"] = "Highest Spell Id"
--[[Translation missing --]]
L["Hit (%)"] = "Hit (%)"
--[[Translation missing --]]
L["Hit Rating"] = "Hit Rating"
--[[Translation missing --]]
L["Holy Resistance"] = "Holy Resistance"
L["Horde"] = "Horda"
--[[Translation missing --]]
L["Horizontal"] = "Horizontal"
--[[Translation missing --]]
L["Hostile"] = "Hostile"
--[[Translation missing --]]
L["Hostility"] = "Hostility"
L["Humanoid"] = "Humanoide"
--[[Translation missing --]]
L["Hybrid"] = "Hybrid"
L["Icon"] = "cone"
--[[Translation missing --]]
L["Icon Function"] = "Icon Function"
--[[Translation missing --]]
L["Icon Function (fallback state)"] = "Icon Function (fallback state)"
--[[Translation missing --]]
L["Id"] = "Id"
--[[Translation missing --]]
L["ID"] = "ID"
--[[Translation missing --]]
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"
--[[Translation missing --]]
L["Ignore Dead"] = "Ignore Dead"
--[[Translation missing --]]
L["Ignore Disconnected"] = "Ignore Disconnected"
--[[Translation missing --]]
L["Ignore Rune CD"] = "Ignore Rune CD"
--[[Translation missing --]]
L["Ignore Rune CDs"] = "Ignore Rune CDs"
--[[Translation missing --]]
L["Ignore Self"] = "Ignore Self"
--[[Translation missing --]]
L["Ignore Spell Cooldown/Charges"] = "Ignore Spell Cooldown/Charges"
--[[Translation missing --]]
L["Ignore Spell Override"] = "Ignore Spell Override"
L["Immune"] = "Imune"
L["Important"] = "Importante"
--[[Translation missing --]]
L["Importing will start after combat ends."] = "Importing will start after combat ends."
L["In Combat"] = "Em Combate"
L["In Encounter"] = "Em Encontro"
L["In Group"] = "Em Grupo"
--[[Translation missing --]]
L["In Party"] = "In Party"
--[[Translation missing --]]
L["In Pet Battle"] = "In Pet Battle"
L["In Raid"] = "Em Raide"
--[[Translation missing --]]
L["In Range"] = "In Range"
L["In Vehicle"] = "Em Veculo"
--[[Translation missing --]]
L["In War Mode"] = "In War Mode"
--[[Translation missing --]]
L["Include Bank"] = "Include Bank"
--[[Translation missing --]]
L["Include Charges"] = "Include Charges"
--[[Translation missing --]]
L["Include Death Runes"] = "Include Death Runes"
--[[Translation missing --]]
L["Include Pets"] = "Include Pets"
--[[Translation missing --]]
L["Include War Band Bank"] = "Include War Band Bank"
--[[Translation missing --]]
L["Incoming Heal"] = "Incoming Heal"
--[[Translation missing --]]
L["Increase Precision Below"] = "Increase Precision Below"
--[[Translation missing --]]
L["Increases by one per stage or intermission."] = "Increases by one per stage or intermission."
--[[Translation missing --]]
L["Information"] = "Information"
--[[Translation missing --]]
L["Inherited"] = "Inherited"
--[[Translation missing --]]
L["Instakill"] = "Instakill"
--[[Translation missing --]]
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "Install the addons BugSack and BugGrabber for detailed error logs."
--[[Translation missing --]]
L["Instance"] = "Instance"
L["Instance Difficulty"] = "Dificuldade da Instncia"
--[[Translation missing --]]
L["Instance Id"] = "Instance Id"
--[[Translation missing --]]
L["Instance ID"] = "Instance ID"
--[[Translation missing --]]
L["Instance Info"] = "Instance Info"
--[[Translation missing --]]
L["Instance Name"] = "Instance Name"
--[[Translation missing --]]
L["Instance Size Type"] = "Instance Size Type"
--[[Translation missing --]]
L["Instance Type"] = "Instance Type"
--[[Translation missing --]]
L["Instructor Razuvious"] = "Instructor Razuvious"
--[[Translation missing --]]
L["Insufficient Resources"] = "Insufficient Resources"
--[[Translation missing --]]
L["Intellect"] = "Intellect"
--[[Translation missing --]]
L["Interrupt"] = "Interrupt"
--[[Translation missing --]]
L["Interrupt School"] = "Interrupt School"
--[[Translation missing --]]
L["Interrupted School Text"] = "Interrupted School Text"
--[[Translation missing --]]
L["Interruptible"] = "Interruptible"
--[[Translation missing --]]
L["Inverse"] = "Inverse"
--[[Translation missing --]]
L["Inverse Pet Behavior"] = "Inverse Pet Behavior"
--[[Translation missing --]]
L["Is Away from Keyboard"] = "Is Away from Keyboard"
--[[Translation missing --]]
L["Is Current Specialization"] = "Is Current Specialization"
--[[Translation missing --]]
L["Is Death Rune"] = "Is Death Rune"
--[[Translation missing --]]
L["Is Exactly"] = "Is Exactly"
--[[Translation missing --]]
L["Is Moving"] = "Is Moving"
--[[Translation missing --]]
L["Is Off Hand"] = "Is Off Hand"
--[[Translation missing --]]
L["Is Paragon Reputation"] = "Is Paragon Reputation"
--[[Translation missing --]]
L["Is Paused"] = "Is Paused"
--[[Translation missing --]]
L["is useable"] = "is useable"
--[[Translation missing --]]
L["Is Weekly Renown Capped"] = "Is Weekly Renown Capped"
--[[Translation missing --]]
L["Island Expedition (Heroic)"] = "Island Expedition (Heroic)"
--[[Translation missing --]]
L["Island Expedition (Mythic)"] = "Island Expedition (Mythic)"
--[[Translation missing --]]
L["Island Expedition (Normal)"] = "Island Expedition (Normal)"
--[[Translation missing --]]
L["Island Expeditions (PvP)"] = "Island Expeditions (PvP)"
L["Item"] = "Item"
--[[Translation missing --]]
L["Item Bonus Id"] = "Item Bonus Id"
--[[Translation missing --]]
L["Item Bonus Id Equipped"] = "Item Bonus Id Equipped"
L["Item Count"] = "Contagem de Item"
L["Item Equipped"] = "Item Equipado"
--[[Translation missing --]]
L["Item Id"] = "Item Id"
--[[Translation missing --]]
L["Item in Range"] = "Item in Range"
--[[Translation missing --]]
L["Item Name"] = "Item Name"
--[[Translation missing --]]
L["Item Set Equipped"] = "Item Set Equipped"
--[[Translation missing --]]
L["Item Set Id"] = "Item Set Id"
--[[Translation missing --]]
L["Item Slot"] = "Item Slot"
--[[Translation missing --]]
L["Item Slot String"] = "Item Slot String"
--[[Translation missing --]]
L["Item Type"] = "Item Type"
L["Item Type Equipped"] = "Tipo de Item Equipado"
--[[Translation missing --]]
L["ItemId"] = "ItemId"
--[[Translation missing --]]
L["Jin'do the Hexxer"] = "Jin'do the Hexxer"
--[[Translation missing --]]
L["Journal Stage"] = "Journal Stage"
--[[Translation missing --]]
L["Kazzak"] = "Kazzak"
--[[Translation missing --]]
L["Keep Inside"] = "Keep Inside"
--[[Translation missing --]]
L["Kel'Thuzad"] = "Kel'Thuzad"
--[[Translation missing --]]
L["Kurinnaxx"] = "Kurinnaxx"
--[[Translation missing --]]
L["Large"] = "Large"
--[[Translation missing --]]
L["Latency"] = "Latency"
--[[Translation missing --]]
L["Leader"] = "Leader"
--[[Translation missing --]]
L["Least remaining time"] = "Least remaining time"
--[[Translation missing --]]
L["Leaving"] = "Leaving"
L["Leech"] = "Sugar"
--[[Translation missing --]]
L["Leech (%)"] = "Leech (%)"
--[[Translation missing --]]
L["Leech Rating"] = "Leech Rating"
L["Left"] = "Esquerda"
L["Left to Right"] = "Da esquerda para direita"
--[[Translation missing --]]
L["Left, then Centered Vertical"] = "Left, then Centered Vertical"
--[[Translation missing --]]
L["Left, then Down"] = "Left, then Down"
--[[Translation missing --]]
L["Left, then Up"] = "Left, then Up"
--[[Translation missing --]]
L["Legacy Looking for Raid"] = "Legacy Looking for Raid"
--[[Translation missing --]]
L["Legacy RGB Gradient"] = "Legacy RGB Gradient"
--[[Translation missing --]]
L["Legacy RGB Gradient Pulse"] = "Legacy RGB Gradient Pulse"
--[[Translation missing --]]
L["Legion"] = "Legion"
--[[Translation missing --]]
L["Length"] = "Length"
--[[Translation missing --]]
L["Level"] = "Level"
--[[Translation missing --]]
L["LibSharedMedia"] = "LibSharedMedia"
--[[Translation missing --]]
L["Lillian Voss"] = "Lillian Voss"
--[[Translation missing --]]
L["Limited"] = "Limited"
--[[Translation missing --]]
L["Linear Texture"] = "Linear Texture"
--[[Translation missing --]]
L["Lines & Particles"] = "Lines & Particles"
--[[Translation missing --]]
L["Load Conditions"] = "Load Conditions"
--[[Translation missing --]]
L["Loatheb"] = "Loatheb"
--[[Translation missing --]]
L["Location"] = "Location"
--[[Translation missing --]]
L["Looking for Raid"] = "Looking for Raid"
--[[Translation missing --]]
L["Loop"] = "Loop"
--[[Translation missing --]]
L["Loot"] = "Loot"
--[[Translation missing --]]
L["Loot Specialization"] = "Loot Specialization"
--[[Translation missing --]]
L["Loot Specialization Id"] = "Loot Specialization Id"
--[[Translation missing --]]
L["Loot Specialization Name"] = "Loot Specialization Name"
--[[Translation missing --]]
L["Lorewalking"] = "Lorewalking"
--[[Translation missing --]]
L["Lost"] = "Lost"
--[[Translation missing --]]
L["Low Damage"] = "Low Damage"
L["Lower Than Tank"] = "Menor que o tanque"
--[[Translation missing --]]
L["Lowest Spell Id"] = "Lowest Spell Id"
--[[Translation missing --]]
L["Lua error"] = "Lua error"
--[[Translation missing --]]
L["Lua error in Aura '%s': %s"] = "Lua error in Aura '%s': %s"
--[[Translation missing --]]
L["Lucifron"] = "Lucifron"
--[[Translation missing --]]
L["Maexxna"] = "Maexxna"
L["Magic"] = "Mgico"
--[[Translation missing --]]
L["Magmadar"] = "Magmadar"
--[[Translation missing --]]
L["Main Character"] = "Main Character"
--[[Translation missing --]]
L["Main Stat"] = "Main Stat"
--[[Translation missing --]]
L["Majordomo Executus"] = "Majordomo Executus"
--[[Translation missing --]]
L["Malformed WeakAuras link"] = "Malformed WeakAuras link"
--[[Translation missing --]]
L["Manual"] = "Manual"
--[[Translation missing --]]
L["Manual Icon"] = "Manual Icon"
--[[Translation missing --]]
L["Manual Rotation"] = "Manual Rotation"
--[[Translation missing --]]
L["Marked First"] = "Marked First"
--[[Translation missing --]]
L["Marked Last"] = "Marked Last"
--[[Translation missing --]]
L["Mason"] = "Mason"
L["Master"] = "Mestre"
--[[Translation missing --]]
L["Mastery (%)"] = "Mastery (%)"
--[[Translation missing --]]
L["Mastery Rating"] = "Mastery Rating"
--[[Translation missing --]]
L["Match Count"] = "Match Count"
--[[Translation missing --]]
L["Match Count per Unit"] = "Match Count per Unit"
--[[Translation missing --]]
L["Matches (Pattern)"] = "Matches (Pattern)"
--[[Translation missing --]]
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=]
--[[Translation missing --]]
L["Max Char "] = "Max Char "
--[[Translation missing --]]
L["Max Char"] = "Max Char"
--[[Translation missing --]]
L["Max Charges"] = "Max Charges"
--[[Translation missing --]]
L["Max Health"] = "Max Health"
--[[Translation missing --]]
L["Max Power"] = "Max Power"
--[[Translation missing --]]
L["Max Quantity"] = "Max Quantity"
--[[Translation missing --]]
L["Maximum Estimate"] = "Maximum Estimate"
--[[Translation missing --]]
L["Maximum Progress"] = "Maximum Progress"
--[[Translation missing --]]
L["Maximum time used on a single frame"] = "Maximum time used on a single frame"
--[[Translation missing --]]
L["Media"] = "Media"
--[[Translation missing --]]
L["Medium"] = "Medium"
--[[Translation missing --]]
L["Melee"] = "Melee"
--[[Translation missing --]]
L["Melee Haste (%)"] = "Melee Haste (%)"
L["Message"] = "Mensagem"
L["Message Type"] = "Tipo de mensagem"
L["Message type:"] = "Tipo de mensagem:"
--[[Translation missing --]]
L["Meta Data"] = "Meta Data"
--[[Translation missing --]]
L["Mine"] = "Mine"
--[[Translation missing --]]
L["Minimum Estimate"] = "Minimum Estimate"
--[[Translation missing --]]
L["Minimum Progress"] = "Minimum Progress"
--[[Translation missing --]]
L["Minus (Small Nameplate)"] = "Minus (Small Nameplate)"
--[[Translation missing --]]
L["Mirror"] = "Mirror"
--[[Translation missing --]]
L["Miscellaneous"] = "Miscellaneous"
L["Miss"] = "Falha"
L["Miss Type"] = "Tipo de falha"
L["Missed"] = "Falho"
L["Missing"] = "Faltando"
--[[Translation missing --]]
L["Mists of Pandaria"] = "Mists of Pandaria"
--[[Translation missing --]]
L["Moam"] = "Moam"
--[[Translation missing --]]
L["Model"] = "Model"
--[[Translation missing --]]
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"
--[[Translation missing --]]
L["Modernize"] = "Modernize"
--[[Translation missing --]]
L["Molten Core"] = "Molten Core"
--[[Translation missing --]]
L["Money"] = "Money"
--[[Translation missing --]]
L["Monochrome"] = "Monochrome"
--[[Translation missing --]]
L["Monochrome Outline"] = "Monochrome Outline"
--[[Translation missing --]]
L["Monochrome Thick Outline"] = "Monochrome Thick Outline"
--[[Translation missing --]]
L["Monster Emote"] = "Monster Emote"
--[[Translation missing --]]
L["Monster Party"] = "Monster Party"
--[[Translation missing --]]
L["Monster Say"] = "Monster Say"
--[[Translation missing --]]
L["Monster Whisper"] = "Monster Whisper"
L["Monster Yell"] = "Grito do monstro"
--[[Translation missing --]]
L["Moon"] = "Moon"
--[[Translation missing --]]
L["Most remaining time"] = "Most remaining time"
L["Mounted"] = "Montado"
--[[Translation missing --]]
L["Mouse Cursor"] = "Mouse Cursor"
--[[Translation missing --]]
L["Movement Speed Rating"] = "Movement Speed Rating"
L["Multi-target"] = "Multi-alvo"
--[[Translation missing --]]
L["Mythic Keystone"] = "Mythic Keystone"
--[[Translation missing --]]
L["Mythic+ Affix"] = "Mythic+ Affix"
L["Name"] = "Nome"
--[[Translation missing --]]
L["Name Function"] = "Name Function"
--[[Translation missing --]]
L["Name Function (fallback state)"] = "Name Function (fallback state)"
--[[Translation missing --]]
L["Name of Caster's Target"] = "Name of Caster's Target"
--[[Translation missing --]]
L["Name of the (sub-)zone currently shown above the minimap."] = "Name of the (sub-)zone currently shown above the minimap."
--[[Translation missing --]]
L["Name(s)"] = "Name(s)"
--[[Translation missing --]]
L["Name/Realm of Caster's Target"] = "Name/Realm of Caster's Target"
--[[Translation missing --]]
L["Nameplate"] = "Nameplate"
--[[Translation missing --]]
L["Nameplates"] = "Nameplates"
--[[Translation missing --]]
L["Names of affected Players"] = "Names of affected Players"
--[[Translation missing --]]
L["Names of unaffected Players"] = "Names of unaffected Players"
--[[Translation missing --]]
L["Nature Resistance"] = "Nature Resistance"
--[[Translation missing --]]
L["Naxxramas"] = "Naxxramas"
--[[Translation missing --]]
L["Nefarian"] = "Nefarian"
L["Neutral"] = "Neutro"
L["Never"] = "Nunca"
--[[Translation missing --]]
L["Next Combat"] = "Next Combat"
--[[Translation missing --]]
L["Next Encounter"] = "Next Encounter"
--[[Translation missing --]]
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=]
--[[Translation missing --]]
L["No Extend"] = "No Extend"
L["No Instance"] = "Fora da instncia"
--[[Translation missing --]]
L["No Profiling information saved."] = "No Profiling information saved."
--[[Translation missing --]]
L["No Progress Information available."] = "No Progress Information available."
L["None"] = "Nenhum"
--[[Translation missing --]]
L["Non-player Character"] = "Non-player Character"
L["Normal"] = "Normal"
--[[Translation missing --]]
L["Normal Party"] = "Normal Party"
--[[Translation missing --]]
L["Not in Group"] = "Not in Group"
--[[Translation missing --]]
L["Not in Smart Group"] = "Not in Smart Group"
--[[Translation missing --]]
L["Not on Cooldown"] = "Not on Cooldown"
--[[Translation missing --]]
L["Not On Threat Table"] = "Not On Threat Table"
--[[Translation missing --]]
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."
--[[Translation missing --]]
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."
--[[Translation missing --]]
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "Note: The available text replacements for multi triggers match the normal triggers now."
--[[Translation missing --]]
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = "Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."
--[[Translation missing --]]
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "Note: This trigger relies on the WoW API, which returns incorrect information in some cases."
--[[Translation missing --]]
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"
--[[Translation missing --]]
L["Noth the Plaguebringer"] = "Noth the Plaguebringer"
--[[Translation missing --]]
L["NPC"] = "NPC"
--[[Translation missing --]]
L["Npc ID"] = "Npc ID"
L["Number"] = "Nmero"
L["Number Affected"] = "Nmero Afetado"
L["Object"] = "Objeto"
--[[Translation missing --]]
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=]
--[[Translation missing --]]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=]
L["Officer"] = "Oficial"
--[[Translation missing --]]
L["Offset from progress"] = "Offset from progress"
--[[Translation missing --]]
L["Offset Timer"] = "Offset Timer"
--[[Translation missing --]]
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Old Blizzard (2h | 3m | 10s | 2.4)"
--[[Translation missing --]]
L["On Cooldown"] = "On Cooldown"
--[[Translation missing --]]
L["On Taxi"] = "On Taxi"
--[[Translation missing --]]
L["Only if on a different realm"] = "Only if on a different realm"
--[[Translation missing --]]
L["Only if Primary"] = "Only if Primary"
--[[Translation missing --]]
L["Onyxia"] = "Onyxia"
--[[Translation missing --]]
L["Opaque"] = "Opaque"
--[[Translation missing --]]
L["Option Group"] = "Option Group"
--[[Translation missing --]]
L["Options could not be loaded, the addon is %s"] = "Options could not be loaded, the addon is %s"
--[[Translation missing --]]
L["Options will finish loading after combat ends."] = "Options will finish loading after combat ends."
--[[Translation missing --]]
L["Options will open after the login process has completed."] = "Options will open after the login process has completed."
--[[Translation missing --]]
L["Or Talent"] = "Or Talent"
L["Orbit"] = "rbita"
--[[Translation missing --]]
L["Orientation"] = "Orientation"
--[[Translation missing --]]
L["Ossirian the Unscarred"] = "Ossirian the Unscarred"
--[[Translation missing --]]
L["Other"] = "Other"
--[[Translation missing --]]
L["Other Addons"] = "Other Addons"
--[[Translation missing --]]
L["Other Events"] = "Other Events"
--[[Translation missing --]]
L["Ouro"] = "Ouro"
--[[Translation missing --]]
L["Outline"] = "Outline"
--[[Translation missing --]]
L["Over Energize"] = "Over Energize"
L["Overhealing"] = "Sobrecura"
L["Overkill"] = "Sobreassassinato"
--[[Translation missing --]]
L["Overlay %s"] = "Overlay %s"
--[[Translation missing --]]
L["Overlay Charged Combo Points"] = "Overlay Charged Combo Points"
--[[Translation missing --]]
L["Overlay Cost of Casts"] = "Overlay Cost of Casts"
--[[Translation missing --]]
L["Overlay Latency"] = "Overlay Latency"
--[[Translation missing --]]
L["Pad"] = "Pad"
--[[Translation missing --]]
L["Pad Mode"] = "Pad Mode"
--[[Translation missing --]]
L["Pad to"] = "Pad to"
--[[Translation missing --]]
L["Paragon Reputation"] = "Paragon Reputation"
--[[Translation missing --]]
L["Paragon Reward Pending"] = "Paragon Reward Pending"
--[[Translation missing --]]
L["Parent Frame"] = "Parent Frame"
--[[Translation missing --]]
L["Parent Zone"] = "Parent Zone"
L["Parry"] = "Aparar"
--[[Translation missing --]]
L["Parry (%)"] = "Parry (%)"
--[[Translation missing --]]
L["Parry Rating"] = "Parry Rating"
L["Party"] = "Grupo"
L["Party Kill"] = "Assassinato do grupo"
--[[Translation missing --]]
L["Patchwerk"] = "Patchwerk"
--[[Translation missing --]]
L["Path of Ascension: Courage"] = "Path of Ascension: Courage"
--[[Translation missing --]]
L["Path of Ascension: Humility"] = "Path of Ascension: Humility"
--[[Translation missing --]]
L["Path of Ascension: Loyalty"] = "Path of Ascension: Loyalty"
--[[Translation missing --]]
L["Path of Ascension: Wisdom"] = "Path of Ascension: Wisdom"
L["Paused"] = "Pausado"
L["Periodic Spell"] = "Feitio peridico"
--[[Translation missing --]]
L["Personal Resource Display"] = "Personal Resource Display"
L["Pet"] = "Assistente"
--[[Translation missing --]]
L["Pet Behavior"] = "Pet Behavior"
--[[Translation missing --]]
L["Pet Specialization"] = "Pet Specialization"
--[[Translation missing --]]
L["Pet Spell"] = "Pet Spell"
--[[Translation missing --]]
L["Pets only"] = "Pets only"
--[[Translation missing --]]
L["Phase"] = "Phase"
--[[Translation missing --]]
L["Pixel Glow"] = "Pixel Glow"
--[[Translation missing --]]
L["Placement"] = "Placement"
--[[Translation missing --]]
L["Placement %i"] = "Placement %i"
--[[Translation missing --]]
L["Placement Mode"] = "Placement Mode"
--[[Translation missing --]]
L["Play"] = "Play"
L["Player"] = "Jogador"
L["Player Character"] = "Personagem do Jogador"
L["Player Class"] = "Classe do Jogador"
--[[Translation missing --]]
L["Player Effective Level"] = "Player Effective Level"
--[[Translation missing --]]
L["Player Experience"] = "Player Experience"
--[[Translation missing --]]
L["Player Faction"] = "Player Faction"
L["Player Level"] = "Nvel do Jogador"
--[[Translation missing --]]
L["Player Location ID(s)"] = "Player Location ID(s)"
--[[Translation missing --]]
L["Player Money"] = "Player Money"
L["Player Name/Realm"] = "Nome do Jogador/Reino"
--[[Translation missing --]]
L["Player Race"] = "Player Race"
L["Player(s) Affected"] = "Jogado(res) afetados"
L["Player(s) Not Affected"] = "Jogado(res) no afetados"
--[[Translation missing --]]
L["Player/Unit Info"] = "Player/Unit Info"
--[[Translation missing --]]
L["Players and Pets"] = "Players and Pets"
L["Poison"] = "Veneno"
L["Power"] = "Poder"
L["Power (%)"] = "Poder (%)"
--[[Translation missing --]]
L["Power Deficit"] = "Power Deficit"
L["Power Type"] = "Tipo de Poder"
--[[Translation missing --]]
L["Precision"] = "Precision"
L["Preset"] = "Predefinido"
--[[Translation missing --]]
L["Primary Stats"] = "Primary Stats"
--[[Translation missing --]]
L["Princess Huhuran"] = "Princess Huhuran"
--[[Translation missing --]]
L["Print Profiling Results"] = "Print Profiling Results"
--[[Translation missing --]]
L["Proc Glow"] = "Proc Glow"
--[[Translation missing --]]
L["Profiling already started."] = "Profiling already started."
--[[Translation missing --]]
L["Profiling automatically started."] = "Profiling automatically started."
--[[Translation missing --]]
L["Profiling not running."] = "Profiling not running."
--[[Translation missing --]]
L["Profiling started."] = "Profiling started."
--[[Translation missing --]]
L["Profiling started. It will end automatically in %d seconds"] = "Profiling started. It will end automatically in %d seconds"
--[[Translation missing --]]
L["Profiling still running, stop before trying to print."] = "Profiling still running, stop before trying to print."
--[[Translation missing --]]
L["Profiling stopped."] = "Profiling stopped."
--[[Translation missing --]]
L["Progress"] = "Progress"
--[[Translation missing --]]
L["Progress Source"] = "Progress Source"
--[[Translation missing --]]
L["Progress Total"] = "Progress Total"
--[[Translation missing --]]
L["Progress Value"] = "Progress Value"
--[[Translation missing --]]
L["Pull"] = "Pull"
L["Pulse"] = "Pulsar"
L["PvP Flagged"] = "Marcado para JxJ"
--[[Translation missing --]]
L["PvP Talent selected"] = "PvP Talent selected"
--[[Translation missing --]]
L["PvP Talent Selected"] = "PvP Talent Selected"
--[[Translation missing --]]
L["Quality Id"] = "Quality Id"
--[[Translation missing --]]
L["Quantity"] = "Quantity"
--[[Translation missing --]]
L["Quantity earned this week"] = "Quantity earned this week"
--[[Translation missing --]]
L["Quest Party"] = "Quest Party"
--[[Translation missing --]]
L["Queued Action"] = "Queued Action"
L["Radius"] = "Raio"
--[[Translation missing --]]
L["Ragnaros"] = "Ragnaros"
L["Raid"] = "Raide"
L["Raid (Heroic)"] = "Raide (Heroica)"
L["Raid (Mythic)"] = "Raide (Mtica)"
L["Raid (Normal)"] = "Raide (Normal)"
L["Raid (Timewalking)"] = "Raide (Caminhada Temporal)"
--[[Translation missing --]]
L["Raid Mark"] = "Raid Mark"
--[[Translation missing --]]
L["Raid Mark Icon"] = "Raid Mark Icon"
--[[Translation missing --]]
L["Raid Role"] = "Raid Role"
L["Raid Warning"] = "Aviso de raide"
--[[Translation missing --]]
L["Raids"] = "Raids"
L["Range"] = "Alcance"
--[[Translation missing --]]
L["Range Check"] = "Range Check"
--[[Translation missing --]]
L["Ranged"] = "Ranged"
--[[Translation missing --]]
L["Rank"] = "Rank"
--[[Translation missing --]]
L["Rare"] = "Rare"
--[[Translation missing --]]
L["Rare Elite"] = "Rare Elite"
--[[Translation missing --]]
L["Rated Arena"] = "Rated Arena"
--[[Translation missing --]]
L["Rated Battleground"] = "Rated Battleground"
--[[Translation missing --]]
L["Raw Threat Percent"] = "Raw Threat Percent"
--[[Translation missing --]]
L["Razorgore the Untamed"] = "Razorgore the Untamed"
--[[Translation missing --]]
L["Ready Check"] = "Ready Check"
--[[Translation missing --]]
L["Reagent Quality"] = "Reagent Quality"
--[[Translation missing --]]
L["Reagent Quality Texture"] = "Reagent Quality Texture"
--[[Translation missing --]]
L["Realm"] = "Realm"
--[[Translation missing --]]
L["Realm Name"] = "Realm Name"
--[[Translation missing --]]
L["Realm of Caster's Target"] = "Realm of Caster's Target"
--[[Translation missing --]]
L["Reborn Council"] = "Reborn Council"
--[[Translation missing --]]
L["Receiving %s Bytes"] = "Receiving %s Bytes"
--[[Translation missing --]]
L["Receiving display information"] = "Receiving display information"
L["Reflect"] = "Refletir"
--[[Translation missing --]]
L["Region type %s not supported"] = "Region type %s not supported"
L["Relative"] = "Relativo"
--[[Translation missing --]]
L["Relative X-Offset"] = "Relative X-Offset"
--[[Translation missing --]]
L["Relative Y-Offset"] = "Relative Y-Offset"
--[[Translation missing --]]
L["Remaining Duration"] = "Remaining Duration"
L["Remaining Time"] = "Tempo restante"
--[[Translation missing --]]
L["Remove Obsolete Auras"] = "Remove Obsolete Auras"
--[[Translation missing --]]
L["Renown Level"] = "Renown Level"
--[[Translation missing --]]
L["Renown Max Level"] = "Renown Max Level"
--[[Translation missing --]]
L["Renown Reputation"] = "Renown Reputation"
L["Repair"] = "Reparar"
--[[Translation missing --]]
L["Repeat"] = "Repeat"
--[[Translation missing --]]
L["Report Summary"] = "Report Summary"
--[[Translation missing --]]
L["Reputation"] = "Reputation"
--[[Translation missing --]]
L["Reputation (%)"] = "Reputation (%)"
L["Requested display does not exist"] = "Exibio requerida no existe"
L["Requested display not authorized"] = "Exibio requerida no autorizada"
--[[Translation missing --]]
L["Requesting display information from %s ..."] = "Requesting display information from %s ..."
L["Require Valid Target"] = "Requer um alvo vlido"
--[[Translation missing --]]
L["Requires syncing the specialization via LibSpecialization."] = "Requires syncing the specialization via LibSpecialization."
--[[Translation missing --]]
L["Resilience (%)"] = "Resilience (%)"
--[[Translation missing --]]
L["Resilience Rating"] = "Resilience Rating"
L["Resist"] = "Resistir"
--[[Translation missing --]]
L["Resistances"] = "Resistances"
L["Resisted"] = "Resistido"
--[[Translation missing --]]
L["Rested"] = "Rested"
--[[Translation missing --]]
L["Rested Experience"] = "Rested Experience"
--[[Translation missing --]]
L["Rested Experience (%)"] = "Rested Experience (%)"
L["Resting"] = "Descansando"
L["Resurrect"] = "Reviver"
--[[Translation missing --]]
L["Resurrect Pending"] = "Resurrect Pending"
L["Right"] = "Direita"
L["Right to Left"] = "Da direita  esquerda"
--[[Translation missing --]]
L["Right, then Centered Vertical"] = "Right, then Centered Vertical"
--[[Translation missing --]]
L["Right, then Down"] = "Right, then Down"
--[[Translation missing --]]
L["Right, then Up"] = "Right, then Up"
--[[Translation missing --]]
L["Role"] = "Role"
--[[Translation missing --]]
L["Rollback snapshot is complete. Thank you for your patience!"] = "Rollback snapshot is complete. Thank you for your patience!"
--[[Translation missing --]]
L["Rotate Animation"] = "Rotate Animation"
L["Rotate Left"] = "Girar  esquerda"
L["Rotate Right"] = "Girar  direita"
--[[Translation missing --]]
L["Rotation"] = "Rotation"
--[[Translation missing --]]
L["Round"] = "Round"
--[[Translation missing --]]
L["Round Mode"] = "Round Mode"
--[[Translation missing --]]
L["Ruins of Ahn'Qiraj"] = "Ruins of Ahn'Qiraj"
--[[Translation missing --]]
L["Run Custom Code"] = "Run Custom Code"
--[[Translation missing --]]
L["Run Speed (%)"] = "Run Speed (%)"
L["Rune"] = "Runa"
--[[Translation missing --]]
L["Rune #1"] = "Rune #1"
--[[Translation missing --]]
L["Rune #2"] = "Rune #2"
--[[Translation missing --]]
L["Rune #3"] = "Rune #3"
--[[Translation missing --]]
L["Rune #4"] = "Rune #4"
--[[Translation missing --]]
L["Rune #5"] = "Rune #5"
--[[Translation missing --]]
L["Rune #6"] = "Rune #6"
--[[Translation missing --]]
L["Rune Count"] = "Rune Count"
--[[Translation missing --]]
L["Rune Count - Blood"] = "Rune Count - Blood"
--[[Translation missing --]]
L["Rune Count - Frost"] = "Rune Count - Frost"
--[[Translation missing --]]
L["Rune Count - Unholy"] = "Rune Count - Unholy"
--[[Translation missing --]]
L["Sapphiron"] = "Sapphiron"
L["Say"] = "falar"
--[[Translation missing --]]
L["Scale"] = "Scale"
--[[Translation missing --]]
L["Scarlet Enclave"] = "Scarlet Enclave"
--[[Translation missing --]]
L["Scenario"] = "Scenario"
--[[Translation missing --]]
L["Scenario (Heroic)"] = "Scenario (Heroic)"
--[[Translation missing --]]
L["Scenario (Normal)"] = "Scenario (Normal)"
--[[Translation missing --]]
L["Screen"] = "Screen"
--[[Translation missing --]]
L["Screen/Parent Group"] = "Screen/Parent Group"
--[[Translation missing --]]
L["Season of Discovery"] = "Season of Discovery"
--[[Translation missing --]]
L["Second"] = "Second"
--[[Translation missing --]]
L["Second Value of Tooltip Text"] = "Second Value of Tooltip Text"
--[[Translation missing --]]
L["Secondary Stats"] = "Secondary Stats"
L["Seconds"] = "Segundos"
--[[Translation missing --]]
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
--[[Translation missing --]]
L["Select Frame"] = "Select Frame"
--[[Translation missing --]]
L["Select the type of timer to filter"] = "Select the type of timer to filter"
--[[Translation missing --]]
L["Selection Mode"] = "Selection Mode"
--[[Translation missing --]]
L["Separator"] = "Separator"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "Set IDs can be found on websites such as wowhead.com/cata/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/classic/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "Set IDs can be found on websites such as wowhead.com/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"
--[[Translation missing --]]
L["Shadow Resistance"] = "Shadow Resistance"
--[[Translation missing --]]
L["Shadowlands"] = "Shadowlands"
L["Shake"] = "Sacudir"
--[[Translation missing --]]
L["Shazzrah"] = "Shazzrah"
--[[Translation missing --]]
L["Shift-Click to resume addon execution."] = "Shift-Click to resume addon execution."
L["Show"] = "Mostrar"
--[[Translation missing --]]
L["Show CD of Charge"] = "Show CD of Charge"
--[[Translation missing --]]
L["Show charged duration for empowered casts"] = "Show charged duration for empowered casts"
--[[Translation missing --]]
L["Show GCD"] = "Show GCD"
--[[Translation missing --]]
L["Show Global Cooldown"] = "Show Global Cooldown"
--[[Translation missing --]]
L["Show Incoming Heal"] = "Show Incoming Heal"
--[[Translation missing --]]
L["Show Loss of Control"] = "Show Loss of Control"
--[[Translation missing --]]
L["Show On"] = "Show On"
--[[Translation missing --]]
L["Show Rested Overlay"] = "Show Rested Overlay"
L["Shrink"] = "Encolher"
--[[Translation missing --]]
L["Silithid Royalty"] = "Silithid Royalty"
--[[Translation missing --]]
L["Silver"] = "Silver"
L["Simple"] = "Simples"
--[[Translation missing --]]
L["Since Active"] = "Since Active"
--[[Translation missing --]]
L["Since Apply"] = "Since Apply"
--[[Translation missing --]]
L["Since Apply/Refresh"] = "Since Apply/Refresh"
--[[Translation missing --]]
L["Since Charge Gain"] = "Since Charge Gain"
--[[Translation missing --]]
L["Since Charge Lost"] = "Since Charge Lost"
--[[Translation missing --]]
L["Since Ready"] = "Since Ready"
--[[Translation missing --]]
L["Since Stack Gain"] = "Since Stack Gain"
--[[Translation missing --]]
L["Since Stack Lost"] = "Since Stack Lost"
--[[Translation missing --]]
L["Size & Position"] = "Size & Position"
--[[Translation missing --]]
L["Skyriding"] = "Skyriding"
--[[Translation missing --]]
L["Slide Animation"] = "Slide Animation"
L["Slide from Bottom"] = "Deslizar de baixo"
L["Slide from Left"] = "Deslizar da esquerda"
L["Slide from Right"] = "Deslizar da direita"
L["Slide from Top"] = "Deslizar de cima"
L["Slide to Bottom"] = "Deslizar para baixo"
L["Slide to Left"] = "Deslizar para esquerda"
L["Slide to Right"] = "Deslizar para direita"
L["Slide to Top"] = "Deslizar para cima"
--[[Translation missing --]]
L["Slider"] = "Slider"
--[[Translation missing --]]
L["Small"] = "Small"
--[[Translation missing --]]
L["Smart Group"] = "Smart Group"
--[[Translation missing --]]
L["Soft Enemy"] = "Soft Enemy"
--[[Translation missing --]]
L["Soft Friend"] = "Soft Friend"
--[[Translation missing --]]
L["Solistrasza"] = "Solistrasza"
--[[Translation missing --]]
L["Sound"] = "Sound"
--[[Translation missing --]]
L["Sound by Kit ID"] = "Sound by Kit ID"
--[[Translation missing --]]
L["Source"] = "Source"
--[[Translation missing --]]
L["Source Affiliation"] = "Source Affiliation"
--[[Translation missing --]]
L["Source GUID"] = "Source GUID"
--[[Translation missing --]]
L["Source Info"] = "Source Info"
L["Source Name"] = "Origem do nome"
--[[Translation missing --]]
L["Source NPC Id"] = "Source NPC Id"
--[[Translation missing --]]
L["Source Object Type"] = "Source Object Type"
--[[Translation missing --]]
L["Source Raid Mark"] = "Source Raid Mark"
--[[Translation missing --]]
L["Source Reaction"] = "Source Reaction"
L["Source Unit"] = "Origem da unidade"
--[[Translation missing --]]
L["Source Unit Name/Realm"] = "Source Unit Name/Realm"
--[[Translation missing --]]
L["Source unit's raid mark index"] = "Source unit's raid mark index"
--[[Translation missing --]]
L["Source unit's raid mark texture"] = "Source unit's raid mark texture"
--[[Translation missing --]]
L["Space"] = "Space"
L["Spacing"] = "Espaamento"
--[[Translation missing --]]
L["Spark"] = "Spark"
--[[Translation missing --]]
L["Spec Position"] = "Spec Position"
--[[Translation missing --]]
L["Spec Role"] = "Spec Role"
--[[Translation missing --]]
L["Specialization"] = "Specialization"
--[[Translation missing --]]
L["Specific Currency"] = "Specific Currency"
--[[Translation missing --]]
L["Specific Type"] = "Specific Type"
L["Specific Unit"] = "Unidade especfica"
L["Spell"] = "Feitio"
L["Spell (Building)"] = "Feitio (Construo)"
--[[Translation missing --]]
L["Spell Activation Overlay Glow"] = "Spell Activation Overlay Glow"
--[[Translation missing --]]
L["Spell Cast Succeeded"] = "Spell Cast Succeeded"
--[[Translation missing --]]
L["Spell Cost"] = "Spell Cost"
--[[Translation missing --]]
L["Spell Count"] = "Spell Count"
--[[Translation missing --]]
L["Spell ID"] = "Spell ID"
--[[Translation missing --]]
L["Spell Id"] = "Spell Id"
--[[Translation missing --]]
L["Spell ID:"] = "Spell ID:"
--[[Translation missing --]]
L["Spell IDs:"] = "Spell IDs:"
--[[Translation missing --]]
L["Spell in Range"] = "Spell in Range"
--[[Translation missing --]]
L["Spell Known"] = "Spell Known"
L["Spell Name"] = "Nome do feitio"
--[[Translation missing --]]
L["Spell Peneration Percent"] = "Spell Peneration Percent"
--[[Translation missing --]]
L["Spell Power"] = "Spell Power"
--[[Translation missing --]]
L["Spell School"] = "Spell School"
--[[Translation missing --]]
L["Spell Usable"] = "Spell Usable"
--[[Translation missing --]]
L["Spellname"] = "Spellname"
--[[Translation missing --]]
L["Spike"] = "Spike"
L["Spin"] = "Girar"
L["Spiral"] = "Espiral"
L["Spiral In And Out"] = "Espiral dentro e fora"
--[[Translation missing --]]
L["Spirit"] = "Spirit"
--[[Translation missing --]]
L["Stack Count"] = "Stack Count"
--[[Translation missing --]]
L["Stack trace:"] = "Stack trace:"
L["Stacks"] = "Pilhas"
--[[Translation missing --]]
L["Stacks Function"] = "Stacks Function"
--[[Translation missing --]]
L["Stacks Function (fallback state)"] = "Stacks Function (fallback state)"
--[[Translation missing --]]
L["Stage"] = "Stage"
--[[Translation missing --]]
L["Stage Counter"] = "Stage Counter"
--[[Translation missing --]]
L["Stagger"] = "Stagger"
--[[Translation missing --]]
L["Stagger (%)"] = "Stagger (%)"
--[[Translation missing --]]
L["Stagger against Target (%)"] = "Stagger against Target (%)"
--[[Translation missing --]]
L["Stagger Scale"] = "Stagger Scale"
--[[Translation missing --]]
L["Stamina"] = "Stamina"
L["Stance/Form/Aura"] = "Postura/Forma/Aura"
--[[Translation missing --]]
L["Standing"] = "Standing"
--[[Translation missing --]]
L["Star Shake"] = "Star Shake"
--[[Translation missing --]]
L["Start Animation"] = "Start Animation"
--[[Translation missing --]]
L["Start Now"] = "Start Now"
--[[Translation missing --]]
L["Start Profiling"] = "Start Profiling"
L["Status"] = "Estado"
--[[Translation missing --]]
L["Status Bar"] = "Status Bar"
L["Stolen"] = "Roubado"
--[[Translation missing --]]
L["Stop"] = "Stop"
--[[Translation missing --]]
L["Stop Motion"] = "Stop Motion"
--[[Translation missing --]]
L["Story Raid"] = "Story Raid"
--[[Translation missing --]]
L["Strength"] = "Strength"
--[[Translation missing --]]
L["String"] = "String"
--[[Translation missing --]]
L["Subevent Info"] = "Subevent Info"
--[[Translation missing --]]
L["Subtract Cast"] = "Subtract Cast"
--[[Translation missing --]]
L["Subtract Channel"] = "Subtract Channel"
--[[Translation missing --]]
L["Subtract GCD"] = "Subtract GCD"
--[[Translation missing --]]
L["Subzone Name"] = "Subzone Name"
--[[Translation missing --]]
L["Success"] = "Success"
--[[Translation missing --]]
L["Sulfuron Harbinger"] = "Sulfuron Harbinger"
L["Summon"] = "Invocar"
--[[Translation missing --]]
L["Summon Pending"] = "Summon Pending"
--[[Translation missing --]]
L["Sun"] = "Sun"
--[[Translation missing --]]
L["Supports multiple entries, separated by commas"] = "Supports multiple entries, separated by commas"
--[[Translation missing --]]
L[ [=[Supports multiple entries, separated by commas
]=] ] = [=[Supports multiple entries, separated by commas
]=]
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Prefix with '-' for negation."
--[[Translation missing --]]
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=]
L["Swing"] = "Balanar"
L["Swing Timer"] = "Tempo de balano"
--[[Translation missing --]]
L["Swipe"] = "Swipe"
--[[Translation missing --]]
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = "Syntax /wa feature <toggle|on|enable|disable|off> <feature>"
--[[Translation missing --]]
L["System"] = "System"
--[[Translation missing --]]
L["Systems"] = "Systems"
--[[Translation missing --]]
L["Tab "] = "Tab "
L["Talent"] = "Talento"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Known"] = "Talent |cFFFF0000Not|r Known"
--[[Translation missing --]]
L["Talent |cFFFF0000Not|r Selected"] = "Talent |cFFFF0000Not|r Selected"
--[[Translation missing --]]
L["Talent Known"] = "Talent Known"
--[[Translation missing --]]
L["Talent Selected"] = "Talent Selected"
--[[Translation missing --]]
L["Talent selected"] = "Talent selected"
L["Talent Specialization"] = "Especializao de talentos"
--[[Translation missing --]]
L["Tanking And Highest"] = "Tanking And Highest"
--[[Translation missing --]]
L["Tanking But Not Highest"] = "Tanking But Not Highest"
L["Target"] = "Alvo"
--[[Translation missing --]]
L["Targeted"] = "Targeted"
--[[Translation missing --]]
L["Tertiary Stats"] = "Tertiary Stats"
--[[Translation missing --]]
L["Test if bar is enabled in BigWigs settings"] = "Test if bar is enabled in BigWigs settings"
--[[Translation missing --]]
L["Test if bar is enabled in Boss Mod addon settings"] = "Test if bar is enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Test if bar is enabled in DBM settings"] = "Test if bar is enabled in DBM settings"
L["Text"] = "Texto"
--[[Translation missing --]]
L["Text To Speech"] = "Text To Speech"
--[[Translation missing --]]
L["Text-to-speech"] = "Text-to-speech"
--[[Translation missing --]]
L["Texture"] = "Texture"
--[[Translation missing --]]
L["Texture Function"] = "Texture Function"
--[[Translation missing --]]
L["Texture Function (fallback state)"] = "Texture Function (fallback state)"
--[[Translation missing --]]
L["Texture Picker"] = "Texture Picker"
--[[Translation missing --]]
L["Texture Rotation"] = "Texture Rotation"
--[[Translation missing --]]
L["Thaddius"] = "Thaddius"
--[[Translation missing --]]
L["The aura has overwritten the global '%s', this might affect other auras."] = "The aura has overwritten the global '%s', this might affect other auras."
--[[Translation missing --]]
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "The aura tried to overwrite the aura_env global, which is not allowed."
--[[Translation missing --]]
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "The effective level differs from the level in e.g. Time Walking dungeons."
--[[Translation missing --]]
L["The Four Horsemen"] = "The Four Horsemen"
--[[Translation missing --]]
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "The 'ID' value can be found in the BigWigs options of a specific spell"
--[[Translation missing --]]
L["The Prophet Skeram"] = "The Prophet Skeram"
--[[Translation missing --]]
L["The total quantity a warband character can transfer after paying the transfer cost"] = "The total quantity a warband character can transfer after paying the transfer cost"
--[[Translation missing --]]
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "The total quantity after transferring everything to your current character and paying the transfer cost"
--[[Translation missing --]]
L["The War Within"] = "The War Within"
--[[Translation missing --]]
L["There are %i updates to your auras ready to be installed!"] = "There are %i updates to your auras ready to be installed!"
--[[Translation missing --]]
L["Thick Outline"] = "Thick Outline"
--[[Translation missing --]]
L["Thickness"] = "Thickness"
--[[Translation missing --]]
L["Third"] = "Third"
--[[Translation missing --]]
L["Third Value of Tooltip Text"] = "Third Value of Tooltip Text"
--[[Translation missing --]]
L["This aura calls GetData a lot, which is a slow function."] = "This aura calls GetData a lot, which is a slow function."
--[[Translation missing --]]
L["This aura has caused a Lua error."] = "This aura has caused a Lua error."
--[[Translation missing --]]
L["This aura is saving %s KB of data"] = "This aura is saving %s KB of data"
--[[Translation missing --]]
L["This aura plays a sound via a condition."] = "This aura plays a sound via a condition."
--[[Translation missing --]]
L["This aura plays a sound via an action."] = "This aura plays a sound via an action."
--[[Translation missing --]]
L["This aura plays a Text To Speech via a condition."] = "This aura plays a Text To Speech via a condition."
--[[Translation missing --]]
L["This aura plays a Text To Speech via an action."] = "This aura plays a Text To Speech via an action."
--[[Translation missing --]]
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."
--[[Translation missing --]]
L["Threat Percent"] = "Threat Percent"
L["Threat Situation"] = "Situao de ameaa"
--[[Translation missing --]]
L["Threat Value"] = "Threat Value"
--[[Translation missing --]]
L["Tick"] = "Tick"
--[[Translation missing --]]
L["Time"] = "Time"
--[[Translation missing --]]
L["Time Format"] = "Time Format"
--[[Translation missing --]]
L["Time in GCDs"] = "Time in GCDs"
--[[Translation missing --]]
L["Time since initial application"] = "Time since initial application"
--[[Translation missing --]]
L["Time since last refresh"] = "Time since last refresh"
--[[Translation missing --]]
L["Time since stack gain"] = "Time since stack gain"
--[[Translation missing --]]
L["Time since stack lost"] = "Time since stack lost"
L["Timed"] = "Temporizado"
--[[Translation missing --]]
L["Timed Progress"] = "Timed Progress"
--[[Translation missing --]]
L["Timer"] = "Timer"
--[[Translation missing --]]
L["Timer Id"] = "Timer Id"
--[[Translation missing --]]
L["Toggle"] = "Toggle"
--[[Translation missing --]]
L["Toggle List"] = "Toggle List"
--[[Translation missing --]]
L["Toggle Options Window"] = "Toggle Options Window"
--[[Translation missing --]]
L["Toggle Performance Profiling Window"] = "Toggle Performance Profiling Window"
--[[Translation missing --]]
L["Tooltip"] = "Tooltip"
--[[Translation missing --]]
L["Tooltip 1"] = "Tooltip 1"
--[[Translation missing --]]
L["Tooltip 2"] = "Tooltip 2"
--[[Translation missing --]]
L["Tooltip 3"] = "Tooltip 3"
--[[Translation missing --]]
L["Tooltip Value 1"] = "Tooltip Value 1"
--[[Translation missing --]]
L["Tooltip Value 2"] = "Tooltip Value 2"
--[[Translation missing --]]
L["Tooltip Value 3"] = "Tooltip Value 3"
--[[Translation missing --]]
L["Tooltip Value 4"] = "Tooltip Value 4"
L["Top"] = "Topo"
L["Top Left"] = "Topo  esquerda"
L["Top Right"] = "Topo  direita"
L["Top to Bottom"] = "Do topo para base"
--[[Translation missing --]]
L["Torghast"] = "Torghast"
--[[Translation missing --]]
L["Total Duration"] = "Total Duration"
--[[Translation missing --]]
L["Total Earned in this Season"] = "Total Earned in this Season"
--[[Translation missing --]]
L["Total Essence"] = "Total Essence"
--[[Translation missing --]]
L["Total Experience"] = "Total Experience"
--[[Translation missing --]]
L["Total Match Count"] = "Total Match Count"
--[[Translation missing --]]
L["Total Reputation"] = "Total Reputation"
--[[Translation missing --]]
L["Total Stacks"] = "Total Stacks"
--[[Translation missing --]]
L["Total stacks over all matches"] = "Total stacks over all matches"
--[[Translation missing --]]
L["Total Stages"] = "Total Stages"
--[[Translation missing --]]
L["Total Unit Count"] = "Total Unit Count"
--[[Translation missing --]]
L["Total Units"] = "Total Units"
L["Totem"] = "Totem"
--[[Translation missing --]]
L["Totem #%i"] = "Totem #%i"
--[[Translation missing --]]
L["Totem Icon"] = "Totem Icon"
L["Totem Name"] = "Nome do totem"
--[[Translation missing --]]
L["Totem Name Pattern Match"] = "Totem Name Pattern Match"
--[[Translation missing --]]
L["Totem Number"] = "Totem Number"
--[[Translation missing --]]
L["Track Cooldowns"] = "Track Cooldowns"
--[[Translation missing --]]
L["Tracking Charge %i"] = "Tracking Charge %i"
--[[Translation missing --]]
L["Tracking Charge CDs"] = "Tracking Charge CDs"
--[[Translation missing --]]
L["Tracking Only Cooldown"] = "Tracking Only Cooldown"
L["Transmission error"] = "Erro de transmisso"
L["Trigger"] = "Gatilho"
L["Trigger %i"] = "Gatilho %i"
--[[Translation missing --]]
L["Trigger %s"] = "Trigger %s"
L["Trigger 1"] = "Gatilho 1"
--[[Translation missing --]]
L["Trigger State Updater (Advanced)"] = "Trigger State Updater (Advanced)"
L["Trigger Update"] = "Atualizao do gatilho"
L["Trigger:"] = "Gatilho:"
--[[Translation missing --]]
L["Trivial (Low Level)"] = "Trivial (Low Level)"
--[[Translation missing --]]
L["True"] = "True"
--[[Translation missing --]]
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "Trying to repair broken conditions in %s likely caused by a WeakAuras bug."
--[[Translation missing --]]
L["Twin Emperors"] = "Twin Emperors"
L["Type"] = "Tipo"
--[[Translation missing --]]
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."
--[[Translation missing --]]
L["Unaffected"] = "Unaffected"
L["Undefined"] = "Indefinido"
--[[Translation missing --]]
L["Unholy"] = "Unholy"
--[[Translation missing --]]
L["Unholy Rune #1"] = "Unholy Rune #1"
--[[Translation missing --]]
L["Unholy Rune #2"] = "Unholy Rune #2"
L["Unit"] = "Unidade"
L["Unit Characteristics"] = "Caractersticas da unidade"
L["Unit Destroyed"] = "Unidade destruda"
L["Unit Died"] = "Unidade morte"
--[[Translation missing --]]
L["Unit Dissipates"] = "Unit Dissipates"
--[[Translation missing --]]
L["Unit Frame"] = "Unit Frame"
--[[Translation missing --]]
L["Unit Frames"] = "Unit Frames"
--[[Translation missing --]]
L["Unit is Unit"] = "Unit is Unit"
--[[Translation missing --]]
L["Unit Name"] = "Unit Name"
--[[Translation missing --]]
L["Unit Name/Realm"] = "Unit Name/Realm"
--[[Translation missing --]]
L["Units Affected"] = "Units Affected"
--[[Translation missing --]]
L["Units of affected Players in a table format"] = "Units of affected Players in a table format"
--[[Translation missing --]]
L["Units of unaffected Players in a table format"] = "Units of unaffected Players in a table format"
--[[Translation missing --]]
L["Unknown action %q"] = "Unknown action %q"
--[[Translation missing --]]
L["Unknown feature %q"] = "Unknown feature %q"
--[[Translation missing --]]
L["unknown location"] = "unknown location"
--[[Translation missing --]]
L["Unlimited"] = "Unlimited"
--[[Translation missing --]]
L["Untrigger %s"] = "Untrigger %s"
L["Up"] = "Acima"
--[[Translation missing --]]
L["Up, then Centered Horizontal"] = "Up, then Centered Horizontal"
--[[Translation missing --]]
L["Up, then Left"] = "Up, then Left"
--[[Translation missing --]]
L["Up, then Right"] = "Up, then Right"
--[[Translation missing --]]
L["Update Position"] = "Update Position"
--[[Translation missing --]]
L["Usage:"] = "Usage:"
--[[Translation missing --]]
L["Use /wa minimap to show the minimap icon again."] = "Use /wa minimap to show the minimap icon again."
--[[Translation missing --]]
L["Use Custom Color"] = "Use Custom Color"
--[[Translation missing --]]
L["Use Legacy floor rounding"] = "Use Legacy floor rounding"
--[[Translation missing --]]
L["Use Texture"] = "Use Texture"
--[[Translation missing --]]
L["Use Watched Faction"] = "Use Watched Faction"
--[[Translation missing --]]
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."
--[[Translation missing --]]
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."
--[[Translation missing --]]
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."
--[[Translation missing --]]
L["Vaelastrasz the Corrupt"] = "Vaelastrasz the Corrupt"
--[[Translation missing --]]
L["Versatility (%)"] = "Versatility (%)"
--[[Translation missing --]]
L["Versatility Rating"] = "Versatility Rating"
--[[Translation missing --]]
L["Vertical"] = "Vertical"
--[[Translation missing --]]
L["Viscidus"] = "Viscidus"
--[[Translation missing --]]
L["Visibility"] = "Visibility"
--[[Translation missing --]]
L["Visions of N'Zoth"] = "Visions of N'Zoth"
--[[Translation missing --]]
L["Warband Quantity Total"] = "Warband Quantity Total"
--[[Translation missing --]]
L["Warband Transfer Percentage"] = "Warband Transfer Percentage"
--[[Translation missing --]]
L["Warband Transferred Quantity"] = "Warband Transferred Quantity"
--[[Translation missing --]]
L["Warfront (Heroic)"] = "Warfront (Heroic)"
--[[Translation missing --]]
L["Warfront (Normal)"] = "Warfront (Normal)"
--[[Translation missing --]]
L["Warlords of Draenor"] = "Warlords of Draenor"
--[[Translation missing --]]
L["Warning"] = "Warning"
--[[Translation missing --]]
L["Warning for unknown aura:"] = "Warning for unknown aura:"
--[[Translation missing --]]
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"
--[[Translation missing --]]
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = "Warning: Full Scan auras checking for both name and spell id can't be converted."
--[[Translation missing --]]
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."
--[[Translation missing --]]
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = "Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."
--[[Translation missing --]]
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"
--[[Translation missing --]]
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."
--[[Translation missing --]]
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=]
--[[Translation missing --]]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."
--[[Translation missing --]]
L["WeakAuras Profiling"] = "WeakAuras Profiling"
--[[Translation missing --]]
L["WeakAuras Profiling Report"] = "WeakAuras Profiling Report"
--[[Translation missing --]]
L["WeakAuras Version: %s"] = "WeakAuras Version: %s"
L["Weapon"] = "Arma"
--[[Translation missing --]]
L["Weapon Enchant"] = "Weapon Enchant"
--[[Translation missing --]]
L["Weapon Enchant / Fishing Lure"] = "Weapon Enchant / Fishing Lure"
L["Whisper"] = "Sussurro"
L["Width"] = "Largura"
L["Wobble"] = "Oscilar"
--[[Translation missing --]]
L["World Boss"] = "World Boss"
--[[Translation missing --]]
L["World Bosses"] = "World Bosses"
--[[Translation missing --]]
L["Wrap"] = "Wrap"
--[[Translation missing --]]
L["Wrath of the Lich King"] = "Wrath of the Lich King"
--[[Translation missing --]]
L["Writing to the WeakAuras table is not allowed."] = "Writing to the WeakAuras table is not allowed."
--[[Translation missing --]]
L["X-Offset"] = "X-Offset"
L["Yell"] = "Gritar"
--[[Translation missing --]]
L["Y-Offset"] = "Y-Offset"
--[[Translation missing --]]
L["You have new auras ready to be installed!"] = "You have new auras ready to be installed!"
--[[Translation missing --]]
L["Your next encounter will automatically be profiled."] = "Your next encounter will automatically be profiled."
--[[Translation missing --]]
L["Your next instance of combat will automatically be profiled."] = "Your next instance of combat will automatically be profiled."
--[[Translation missing --]]
L["Your scheduled automatic profile has been cancelled."] = "Your scheduled automatic profile has been cancelled."
--[[Translation missing --]]
L["Your threat as a percentage of the tank's current threat."] = "Your threat as a percentage of the tank's current threat."
--[[Translation missing --]]
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."
--[[Translation missing --]]
L["Your total threat on the mob."] = "Your total threat on the mob."
--[[Translation missing --]]
L["Zone Group ID"] = "Zone Group ID"
--[[Translation missing --]]
L["Zone ID"] = "Zone ID"
L["Zone Name"] = "Nome da Zona"
--[[Translation missing --]]
L["Zoom"] = "Zoom"
--[[Translation missing --]]
L["Zoom Animation"] = "Zoom Animation"
--[[Translation missing --]]
L["Zul'Gurub"] = "Zul'Gurub"



-- ========================================
-- File: WeakAuras/Locales/ruRU.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "ruRU" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[ : , - , - .

   ,  .     ,      \]=]
L["%s Overlay Color"] = "%s ( )"
L["* Suffix"] = " *  "
L["/wa help - Show this message"] = "/wa help -   "
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap -      "
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint -    "
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = [=[/wa pstart -  .  :
[] -   ,      ;
[combat] -       ;
[encounter] -       .]=]
L["/wa pstop - Finish profiling"] = "/wa pstop -  "
L["/wa repair - Repair tool"] = "/wa repair -   "
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cFFEDA55F|r -     ."
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cFFEDA55F|r -     ."
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cFFEDA55F|r -     ."
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cFFEDA55FShift+|r -   ."
L["|cffff0000deprecated|r"] = "|cffff0000|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000|r ID   "
L["|cFFFF0000Not|r Item Equipped"] = " |cFFFF0000|r "
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000|r  /   "
L["|cFFFF0000Not|r Spell Known"] = " |cFFFF0000|r"
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = "|cFFFF0000  COMBAT_LOG_EVENT_UNFILTERED |r COMBAT_LOG_EVENT_UNFILTERED   ,       . : https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"
L["|cFFffcc00Extra Options:|r %s"] = "|cFFFFCC00 :|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFFFCC00 :|r "
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = " |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r  |cff00ff00Pet|r     unitID.  |cff00ff00Specific Unit|r     unitID  . |cffff0000|r:         unitID,         .  |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r  |cffffff00Nameplate|r     unitID.  |cffffff00Smart Group|r      ,   \"player\"   , \"party\"  ( \"player\")    \"raid\"   . |cffffff00*|r   Unit      unitID,        ."
L["1. Profession 1. Accessory"] = "1.  1. "
L["1. Profession 2. Accessory"] = "1.  2. "
L["1. Professsion Tool"] = "1.  "
L["10 Man Raid"] = "  10 "
L["10 Player Raid"] = "  10 "
L["10 Player Raid (Heroic)"] = "  10  ()"
L["10 Player Raid (Normal)"] = "  10  ()"
L["2. Profession 1. Accessory"] = "2.  1. "
L["2. Profession 2. Accessory"] = "2.  2. "
L["2. Professsion Tool"] = "2.  "
L["20 Man Raid"] = "  20 "
L["20 Player Raid"] = "  20 "
L["25 Man Raid"] = "  25 "
L["25 Player Raid"] = "  25 "
L["25 Player Raid (Heroic)"] = "  25  ()"
L["25 Player Raid (Normal)"] = "  25  ()"
L["40 Man Raid"] = "  40 "
L["40 Player Raid"] = "  40 "
L["5 Man Dungeon"] = ""
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = "      WeakAuras.     Discord Weakaura,    ."
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "         (soft target unit),        (CVars),    .            (SoftTargetEnemy / SoftTargetFriend)."
L["Abbreviate"] = ""
L["AbbreviateLargeNumbers (Blizzard)"] = "   (Blizzard)"
L["AbbreviateNumbers (Blizzard)"] = "  (Blizzard)"
L["Absorb"] = ""
L["Absorb and Healing"] = "  "
L["Absorb Heal Overlay"] = "  "
L["Absorb Overlay"] = " "
L["Absorbed"] = ""
L["Action Button Glow"] = "  "
L["Actions"] = ""
L["Active"] = ""
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "   : |cFFffcc00BigWigs|r :     BigWigs  DBM,   ,   ."
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "   : |cFFffcc00DBM|r :     DBM  BigWigs,   ,   ."
L["Add"] = " (Add)"
L["Add Missing Auras"] = "  "
L["Advanced Caster's Target Check"] = "   "
L["Affected"] = ""
L["Affected Unit Count"] = "- . "
L["Afk"] = " (AFK)"
L["Aggro"] = ""
L["Agility"] = ""
L["Ahn'Qiraj"] = "'"
L["Alert Type"] = " "
L["Alive"] = ""
L["All"] = ""
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = "        ,     ."
L["All States table contains a non table at key: '%s'."] = "    (allstates)    '%s'   ."
L["All Triggers"] = " "
L["Alliance"] = ""
L["Allow partial matches"] = "  "
L["Alpha"] = ""
L["Alternate Power"] = " "
L["Always"] = ""
L["Always active trigger"] = "  "
L["Always include realm"] = "  "
L["Always True"] = ""
L["Amount"] = ""
L["Anchoring"] = ""
L["And Talent"] = " "
L["Angle and Radius"] = "  "
L["Animations"] = ""
L["Anticlockwise"] = "  "
L["Anub'Rekhan"] = "'"
L["Any"] = ""
L["Any Triggers"] = " "
L["AOE"] = "   (AOE)"
L["Arcane Resistance"] = "  "
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = [=[ ,    |cFFFF0000|r   ?

 ,        ,  .

  : %s]=]
L["Arena"] = ""
L["Armor (%)"] = " (%)"
L["Armor against Target (%)"] = "    (%)"
L["Armor Rating"] = " "
L["Array"] = ""
L["Ascending"] = " "
L["Assigned Role"] = " "
L["Assigned Role Icon"] = "  "
L["Assist"] = ""
--[[Translation missing --]]
L["Assisted Combat Next Cast"] = "Assisted Combat Next Cast"
L["At Least One Enemy"] = "   "
L["At missing Value"] = "  "
L["At Percent"] = " "
L["At Value"] = " "
L["At War"] = " "
L["Attach to End"] = "  "
--[[Translation missing --]]
L["Attach to End, backwards"] = "Attach to End, backwards"
L["Attach to Point"] = "  "
L["Attach to Start"] = "  "
L["Attack Power"] = " "
L["Attackable"] = "  "
L["Attackable Target"] = "  "
L["Aura"] = ""
L["Aura '%s': %s"] = " %s - %s"
L["Aura Applied"] = " "
L["Aura Applied Dose"] = "  "
L["Aura Broken"] = " "
L["Aura Broken Spell"] = "  "
L["Aura is using deprecated SetDurationInfo"] = "   SetDurationInfo"
L["Aura loaded"] = " "
L["Aura Name"] = " "
L["Aura Names"] = " "
L["Aura Refresh"] = " "
L["Aura Removed"] = " "
L["Aura Removed Dose"] = "  "
L["Aura Stack"] = " "
L["Aura Type"] = " "
L["Aura Version: %s"] = " : %s"
L["Aura(s) Found"] = " "
L["Aura(s) Missing"] = " "
L["Aura:"] = ":"
L["Auras"] = ""
L["Auras:"] = ":"
L["Author Options"] = " "
L["Auto"] = ""
L["Autocast Shine"] = "  "
L["Automatic"] = ""
L["Automatic Length"] = " "
L["Automatic Rotation"] = " "
L["Available features: %s"] = " : %s"
L["Avoidance (%)"] = " (%)"
L["Avoidance Rating"] = " "
L["Ayamiss the Hunter"] = " "
L["Azuregos"] = ""
L["Back and Forth"] = "  "
L["Background"] = " "
L["Background Color"] = "  "
L["Balnazzar"] = ""
L["Bar Color/Gradient Start"] = "  /  "
--[[Translation missing --]]
L["Bar enabled in BigWigs settings"] = "Bar enabled in BigWigs settings"
--[[Translation missing --]]
L["Bar enabled in Boss Mod addon settings"] = "Bar enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Bar enabled in DBM settings"] = "Bar enabled in DBM settings"
L["Bar Texture"] = " "
--[[Translation missing --]]
L["Bar Type"] = "Bar Type"
L["Baron Geddon"] = " "
L["Battle for Azeroth"] = "Battle for Azeroth"
L["Battle.net Whisper"] = "   Battle.net"
L["Battleground"] = " "
L["Battleguard Sartura"] = "  "
L["Beastmaster"] = " "
L["Beatrix"] = ""
L["BG>Raid>Party>Say"] = "  >  >  > "
L["BG-System Alliance"] = " : "
L["BG-System Horde"] = " : "
L["BG-System Neutral"] = " : "
L["Big Number"] = " "
L["BigWigs Addon"] = " BigWigs"
L["BigWigs Message"] = " BigWigs"
L["BigWigs Stage"] = "    BigWigs"
L["BigWigs Timer"] = " BigWigs"
L["Black Wing Lair"] = "  "
L["Bleed"] = ""
L["Blizzard Combat Text"] = "  Blizzard"
L["Blizzard Cooldown Reduction"] = "  (Blizzard)"
L["Block"] = ""
L["Block (%)"] = " (%)"
L["Block against Target (%)"] = "    (%)"
L["Block Value"] = " "
L["Blocked"] = ""
L["Blood"] = ""
L["Blood Rune #1"] = "  #1"
L["Blood Rune #2"] = "  #2"
L["Bloodlord Mandokir"] = "  "
L["Bonus Reputation Gain"] = "   "
L["Border"] = ""
L["Boss"] = ""
L["Boss Emote"] = " -"
L["Boss Mod Announce"] = "   "
L["Boss Mod Stage"] = "   "
L["Boss Mod Stage (Event)"] = "    ()"
L["Boss Mod Timer"] = "Boss Mod "
L["Boss Whisper"] = " -"
L["Bottom"] = ""
L["Bottom Left"] = " "
L["Bottom Right"] = " "
L["Bottom to Top"] = " "
L["Bounce"] = ""
L["Bounce with Decay"] = "  "
L["Break"] = ""
L["BreakUpLargeNumbers (Blizzard)"] = " (Blizzard)"
L["Broodlord Lashlayer"] = "   "
L["Buff"] = ""
L["Buff/Debuff"] = " / "
L["Buffed/Debuffed"] = "  / "
L["Burning Crusade"] = "Burning Crusade"
L["Buru the Gorger"] = " "
L["Caldoran"] = ""
L["Callback function"] = "  "
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = [=[    ,    -     , .
:            "boss1target",  ,     .]=]
L["Cancel"] = ""
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "      .    : https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = "    %i c. -  WoW (),         - %i . ,  ."
L["Capped"] = " "
L["Capped at Season Max"] = "   "
L["Capped at Weekly Max"] = "   "
L["Cast"] = " "
L["Cast Bar"] = "  "
L["Cast Failed"] = "  "
L["Cast Start"] = " "
L["Cast Success"] = "  "
L["Cast Type"] = " "
L["Caster"] = ""
L["Caster Name"] = " "
L["Caster Realm"] = "  "
L["Caster Unit"] = ""
L["Casters Name/Realm"] = " / .  "
L["Caster's Target"] = " "
L["Cataclysm"] = "Cataclysm"
L["Ceil"] = "Ceil (  )"
L["Center"] = ""
L["Center, then alternating bottom and top"] = " >    "
L["Center, then alternating left and right"] = " >    "
L["Center, then alternating right and left"] = " >  c  c"
L["Center, then alternating top and bottom"] = " >    "
L["Centered Horizontal"] = "   "
L["Centered Horizontal, then Centered Vertical"] = " :  . >  ."
L["Centered Horizontal, then Down"] = "    > "
L["Centered Horizontal, then Up"] = "    > "
L["Centered Vertical"] = "   "
L["Centered Vertical, then Centered Horizontal"] = " :  . >  ."
L["Centered Vertical, then Left"] = "    > C"
L["Centered Vertical, then Right"] = "    > C"
L["Changed"] = ""
L["Channel"] = ""
L["Channel (Spell)"] = ""
--[[Translation missing --]]
L["Character GUID"] = "Character GUID"
L["Character Name"] = " "
L["Character Stats"] = " "
--[[Translation missing --]]
L["Character Transferred Quantity"] = "Character Transferred Quantity"
L["Character Type"] = " "
L["Charge gained/lost"] = " "
--[[Translation missing --]]
L["Charged Combo Points"] = "Charged Combo Points"
L["Charges"] = ""
L["Charges Changed Event"] = " "
L["Charging"] = ""
L["Chat Frame"] = " "
L["Chat Message"] = "  "
L["Check if a single talent match a Rank"] = ",     "
L["Check nameplate's target every 0.2s"] = "     0.2 "
L["Chromaggus"] = ""
L["Circle"] = ""
L["Circular Texture"] = " "
L["Clamp"] = " ( )"
L["Class"] = ""
L["Class and Specialization"] = "  "
L["Classic"] = "Classic"
L["Classification"] = ""
L["Clockwise"] = "  "
--[[Translation missing --]]
L["Clone per Character"] = "Clone per Character"
L["Clone per Event"] = "   "
L["Clone per Match"] = "   "
--[[Translation missing --]]
L["Coin Precision"] = "Coin Precision"
L["Color"] = ""
L["Color Animation"] = " "
L["Combat Log"] = " "
L["Communities"] = ""
--[[Translation missing --]]
L["Condition Custom Test"] = "Condition Custom Test"
L["Conditions"] = ""
L["Contains"] = ""
L["Continuously update Movement Speed"] = "     "
L["Cooldown"] = ""
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "     ,      . BigWigs       ."
L["Cooldown Progress (Item)"] = " ()"
L["Cooldown Progress (Slot)"] = " ()"
L["Cooldown Ready Event"] = " "
L["Cooldown Ready Event (Item)"] = "  ()"
L["Cooldown Ready Event (Slot)"] = "  ()"
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = "          ."
L["Cooldown/Charges/Count"] = " /  / "
L["Copper"] = ""
L["Could not load WeakAuras Archive, the addon is %s"] = "   WeakAuras Archive.  - %s"
L["Count"] = ""
L["Counter Clockwise"] = "  "
L["Create"] = ""
--[[Translation missing --]]
L["Creature Family"] = "Creature Family"
--[[Translation missing --]]
L["Creature Family Name"] = "Creature Family Name"
--[[Translation missing --]]
L["Creature Type"] = "Creature Type"
--[[Translation missing --]]
L["Creature Type Name"] = "Creature Type Name"
L["Critical"] = " "
L["Critical (%)"] = "  (%)"
L["Critical Rating"] = "  "
L["Crop X"] = " X"
L["Crop Y"] = " Y"
L["Crowd Controlled"] = "   "
L["Crushing"] = " "
L["C'thun"] = "'"
L["Cumulated time used during profiling"] = " ,   "
L["Currency"] = ""
L["Current Essence"] = "  "
L["Current Experience"] = "  "
L["Current Instance"] = " "
L["Current Movement Speed (%)"] = "   (%)"
L["Current Stage"] = "  "
L["Current Zone"] = " "
L["Current Zone Group"] = "  "
L["Curse"] = ""
L["Custom"] = ""
L["Custom Action"] = " "
L["Custom Anchor"] = " "
L["Custom Check"] = " "
L["Custom Color"] = ""
L["Custom Condition Code"] = "  "
L["Custom Configuration"] = " "
L["Custom Fade Animation"] = "  "
L["Custom Function"] = " "
L["Custom Grow"] = "  "
L["Custom Sort"] = "  "
L["Custom Text Function"] = "  "
L["Custom Trigger Combination"] = " "
L["Custom Variables"] = " "
L["Damage"] = ""
L["Damage Shield"] = "  "
L["Damage Shield Missed"] = "   ()"
L["Damage Split"] = " "
L["DBM Announce"] = " DBM"
L["DBM Stage"] = "    DBM"
L["DBM Timer"] = " DBM"
L["Dead"] = ""
L["Death"] = ""
L["Death Knight Rune"] = "  "
L["Debuff"] = ""
L["Debuff Class"] = " "
L["Debuff Class Icon"] = " "
L["Debuff Type"] = " "
L["Debug Log contains more than 1000 entries"] = "    1000 ."
L["Debug Logging enabled"] = "   "
L["Debug Logging enabled for '%s'"] = "      %s."
L["Defensive Stats"] = " "
L["Deflect"] = ""
L["Delve"] = ""
L["Desaturate"] = ""
L["Desaturate Background"] = "  "
L["Desaturate Foreground"] = "  "
L["Descending"] = " "
L["Description"] = ""
L["Dest Raid Mark"] = " "
L["Destination Affiliation"] = " "
L["Destination GUID"] = "GUID "
L["Destination Info"] = "   "
L["Destination Name"] = " "
L["Destination NPC Id"] = "ID NPC-"
L["Destination Object Type"] = "  "
L["Destination Reaction"] = " "
L["Destination Unit"] = ""
L["Destination unit's raid mark index"] = "  ()"
L["Destination unit's raid mark texture"] = "  ()"
L["Difficulty"] = ""
L["Disable Spell Known Check"] = " ,   "
--[[Translation missing --]]
L["Disabled"] = "Disabled"
L["Disabled feature %q"] = "  %q"
L["Disabled Spell Known Check"] = ",   , "
L["Discovered"] = ""
L["Disease"] = ""
L["Dispel"] = ""
L["Dispel Failed"] = "  "
L["Display"] = ""
L["Distance"] = ""
L["Do Not Disturb"] = "  (DND)"
L["Dodge"] = ""
L["Dodge (%)"] = " (%)"
L["Dodge Rating"] = " "
L["Down"] = ""
L["Down, then Centered Horizontal"] = " >    "
L["Down, then Left"] = " > "
L["Down, then Right"] = " > "
L["Dragonflight"] = "Dragonflight"
L["Drain"] = ""
L["Dropdown Menu"] = " "
L["Dumping table"] = " "
--[[Translation missing --]]
L["Dungeon (Celestial)"] = "Dungeon (Celestial)"
L["Dungeon (Heroic)"] = " ()"
L["Dungeon (Mythic)"] = " ()"
L["Dungeon (Mythic+)"] = " (+)"
L["Dungeon (Normal)"] = " ()"
L["Dungeon (Timewalking)"] = " (  )"
L["Dungeons"] = ""
L["Durability Damage"] = " "
L["Durability Damage All"] = "  "
L["Duration"] = ""
L["Duration Function"] = " "
L["Duration Function (fallback state)"] = "  ( )"
L["Ease In"] = " "
L["Ease In and Out"] = "   "
L["Ease Out"] = " "
L["Ebonroc"] = ""
L["Eclipse Direction"] = " "
L["Edge"] = " Edge ()"
L["Edge of Madness"] = " "
--[[Translation missing --]]
L["Effective Spell Id"] = "Effective Spell Id"
L["Elide"] = " "
L["Elite"] = ""
L["Emote"] = ""
L["Empower Cast End"] = " "
L["Empower Cast Interrupt"] = " "
L["Empower Cast Start"] = " "
L["Empowered"] = " "
L["Empowered 1"] = "  1"
L["Empowered 2"] = "  2"
L["Empowered 3"] = "  3"
L["Empowered 4"] = "  4"
L["Empowered 5"] = "  5"
L["Empowered Cast"] = " "
L["Empowered Cast Fully Charged"] = "  "
L["Empowered Fully Charged"] = "  "
L["Empty"] = ""
L["Enabled feature %q"] = "  %q"
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = "      .      ."
L["Enchant Applied"] = " "
L["Enchant Found"] = " "
L["Enchant ID"] = "ID "
L["Enchant Missing"] = " "
L["Enchant Name or ID"] = "   ID   "
L["Enchant Removed"] = " "
L["Enchanted"] = " "
L["Encounter ID(s)"] = "ID   "
L["Energize"] = ""
L["Enrage"] = ""
L["Enter a name or a spellId"] = "   ID "
L["Entering"] = ""
L["Entering/Leaving Combat"] = " /   "
L["Entering/Leaving Encounter"] = " /     "
L["Entry Order"] = " "
L["Environment Type"] = " "
L["Environmental"] = " "
L["Equipment"] = ""
L["Equipment Set"] = " "
L["Equipment Set Equipped"] = "  "
L["Equipment Slot"] = " "
L["Equipped"] = ""
L["Error"] = ""
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "       %s,   .    .    : https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Error decoding."] = " "
L["Error decompressing"] = " "
L["Error decompressing. This doesn't look like a WeakAuras import."] = " .       WeakAuras"
L["Error deserializing"] = " "
L["Error Frame"] = "  "
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "   %s.       %s."
--[[Translation missing --]]
L["Error in Aura '%s'"] = "Error in Aura '%s'"
L["Error not receiving display information from %s"] = [=[      
 %s]=]
L["Essence"] = ""
L["Essence #1"] = " #1"
L["Essence #2"] = " #2"
L["Essence #3"] = " #3"
L["Essence #4"] = " #4"
L["Essence #5"] = " #5"
L["Essence #6"] = " #6"
L["Evade"] = ""
L["Event"] = ""
L["Event(s)"] = ""
L["Every Frame"] = " "
L["Every Frame (High CPU usage)"] = "  (  )"
L["Evoker Essence"] = " "
L["Exact Spell ID(s)"] = "ID "
--[[Translation missing --]]
L["Execute Conditions"] = "Execute Conditions"
L["Experience (%)"] = " (%)"
L["Expertise Bonus"] = " "
L["Expertise Rating"] = " "
L["Extend Outside"] = "  "
L["Extra Amount"] = " "
L["Extra Attacks"] = " "
L["Extra Spell Id"] = "- ID "
L["Extra Spell Name"] = "-  "
L["Faction"] = ""
L["Faction Name"] = " "
L["Faction Reputation"] = "  "
L["Fade Animation"] = " "
L["Fade In"] = ""
L["Fade Out"] = ""
L["Fail Alert"] = ""
L["False"] = ""
L["Fankriss the Unyielding"] = " "
L["Feature %q is already disabled"] = " %q  "
L["Feature %q is already enabled"] = " %q  "
L["Fetch Absorb"] = " "
L["Fetch Heal Absorb"] = "  "
L["Fetch Legendary Power"] = "    "
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "     ,   ID "
--[[Translation missing --]]
L["Fill Area"] = "Fill Area"
L["Filter messages with format <message>"] = " ,   <...>"
L["Fire Resistance"] = " "
L["Firemaw"] = ""
L["First"] = ""
L["First Value of Tooltip Text"] = "    "
L["Fixed"] = ""
L["Fixed Names"] = " "
L["Fixed Size"] = " "
L["Flamegor"] = ""
L["Flash"] = ""
L["Flex Raid"] = " "
L["Flip"] = ""
L["Floor"] = "Floor (  )"
L["Focus"] = ""
L["Follower Dungeon"] = " "
L["Font"] = ""
L["Font Size"] = " "
L["Forbidden function or table: %s"] = "   : %s"
L["Foreground"] = " "
L["Foreground Color"] = "  "
L["Form"] = ""
L["Format"] = ""
L["Format Gold"] = " "
L["Formats |cFFFFCC00%unit|r"] = " |cFFFFCC00%unit|r"
L["Formats Player's |cFFFFCC00%guid|r"] = "  |cFFFFCC00%guid|r"
L["Forward"] = ""
L["Forward, Reverse Loop"] = " ( .  . )"
L["Fourth Value of Tooltip Text"] = "    "
L["Frame Selector"] = " "
L["Frequency"] = ""
L["Friendly"] = ""
L["Friendly Fire"] = "  "
L["Friendship Max Rank"] = "  "
L["Friendship Rank"] = " "
L["Friendship Reputation"] = " "
L["Frost"] = ""
L["Frost Resistance"] = "  "
L["Frost Rune #1"] = "  #1"
L["Frost Rune #2"] = "  #2"
L["Full"] = ""
--[[Translation missing --]]
L["Full Region"] = "Full Region"
L["Full/Empty"] = " / "
L["Gahz'ranka"] = "'"
L["Gained"] = ""
L["Garr"] = ""
L["Gehennas"] = ""
L["General"] = ""
L["General Rajaxx"] = " "
L["GetNameAndIcon Function (fallback state)"] = " GetNameAndIcon ( )"
L["Glancing"] = " "
L["Global Cooldown"] = "   (GCD)"
L["Glow"] = ""
L["Glow External Element"] = "  "
L["Gluth"] = ""
--[[Translation missing --]]
L["Glyph"] = "Glyph"
L["Gold"] = ""
L["Golemagg the Incinerator"] = " "
L["Gothik the Harvester"] = " "
L["Gradient"] = " HSV"
L["Gradient Enabled"] = ""
L["Gradient End"] = " "
L["Gradient Orientation"] = " "
L["Gradient Pulse"] = "  HSV"
L["Grand Widow Faerlina"] = "  "
L["Grid"] = ""
L["Grobbulus"] = ""
L["Group"] = ""
L["Group Arrangement"] = "     "
L["Group Leader/Assist"] = " /  "
L["Group Size"] = " "
L["Group Type"] = " "
L["Grow"] = ""
L["GTFO Alert"] = " GTFO"
L["Guardian"] = ""
L["Guild"] = ""
L["Hakkar"] = ""
L["Hardcore"] = ""
L["Has Target"] = " "
L["Has Vehicle UI"] = " UI "
L["HasPet"] = "   "
L["Haste (%)"] = " (%)"
L["Haste Rating"] = " "
L["Heal"] = ""
L["Heal Absorb"] = " "
L["Heal Absorbed"] = " "
L["Health"] = ""
L["Health (%)"] = " (%)"
L["Health Deficit"] = " "
L["Heigan the Unclean"] = " "
L["Height"] = ""
L["Hero Talent"] = " "
L["Heroic Party"] = " ()"
L["Hide"] = ""
L["Hide 0 cooldowns"] = " 0"
L["Hide Timer Text"] = "  "
L["High Damage"] = " "
L["High Priest Thekal"] = "  "
L["High Priest Venoxis"] = "  "
L["High Priestess Arlokk"] = "  "
L["High Priestess Jeklik"] = "  "
L["High Priestess Mar'li"] = "  '"
L["Higher Than Tank"] = "    "
--[[Translation missing --]]
L["Highest Spell Id"] = "Highest Spell Id"
L["Hit (%)"] = " (%)"
L["Hit Rating"] = " "
L["Holy Resistance"] = "  "
L["Horde"] = ""
L["Horizontal"] = ""
L["Hostile"] = ""
L["Hostility"] = ""
L["Humanoid"] = ""
L["Hybrid"] = ""
L["Icon"] = ""
L["Icon Function"] = " "
L["Icon Function (fallback state)"] = "  ( )"
L["Id"] = "ID"
L["ID"] = "ID"
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = "    , ,    GitHub      Discord   https://discord.gg/weakauras."
L["Ignore Dead"] = "   "
L["Ignore Disconnected"] = "     "
L["Ignore Rune CD"] = "   "
L["Ignore Rune CDs"] = "   "
L["Ignore Self"] = "  "
--[[Translation missing --]]
L["Ignore Spell Cooldown/Charges"] = "Ignore Spell Cooldown/Charges"
L["Ignore Spell Override"] = "  "
L["Immune"] = ""
L["Important"] = ""
L["Importing will start after combat ends."] = "    ."
L["In Combat"] = " "
L["In Encounter"] = "   "
L["In Group"] = "   "
L["In Party"] = " "
L["In Pet Battle"] = "  "
L["In Raid"] = " "
L["In Range"] = "  "
L["In Vehicle"] = " "
L["In War Mode"] = "  "
L["Include Bank"] = " "
L["Include Charges"] = " "
L["Include Death Runes"] = "  "
L["Include Pets"] = " "
L["Include War Band Bank"] = "  "
L["Incoming Heal"] = " "
L["Increase Precision Below"] = " ,  "
L["Increases by one per stage or intermission."] = "        "
L["Information"] = ""
L["Inherited"] = " "
L["Instakill"] = " "
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "  BugSack  BugGrabber      ."
L["Instance"] = ""
L["Instance Difficulty"] = " "
L["Instance Id"] = "ID "
L["Instance ID"] = " "
L["Instance Info"] = "  "
L["Instance Name"] = " "
L["Instance Size Type"] = "  "
L["Instance Type"] = " "
L["Instructor Razuvious"] = " "
L["Insufficient Resources"] = " "
L["Intellect"] = ""
L["Interrupt"] = ""
L["Interrupt School"] = " "
L["Interrupted School Text"] = "  "
L["Interruptible"] = "  "
L["Inverse"] = ""
L["Inverse Pet Behavior"] = "  "
L["Is Away from Keyboard"] = " (AFK)"
L["Is Current Specialization"] = " "
L["Is Death Rune"] = " "
L["Is Exactly"] = " "
L["Is Moving"] = ""
L["Is Off Hand"] = " "
L["Is Paragon Reputation"] = " ?"
L["Is Paused"] = ""
L["is useable"] = " "
L["Is Weekly Renown Capped"] = "   ?"
L["Island Expedition (Heroic)"] = "  ()"
L["Island Expedition (Mythic)"] = "  ()"
L["Island Expedition (Normal)"] = "  ()"
L["Island Expeditions (PvP)"] = "  (PvP)"
L["Item"] = ""
L["Item Bonus Id"] = "ID  "
L["Item Bonus Id Equipped"] = "ID   "
L["Item Count"] = " "
L["Item Equipped"] = " "
L["Item Id"] = "ID "
L["Item in Range"] = "   ()"
L["Item Name"] = " "
L["Item Set Equipped"] = "  "
L["Item Set Id"] = "ID  "
L["Item Slot"] = " "
L["Item Slot String"] = "  "
L["Item Type"] = " "
L["Item Type Equipped"] = "  "
--[[Translation missing --]]
L["ItemId"] = "ItemId"
L["Jin'do the Hexxer"] = "' "
L["Journal Stage"] = ""
L["Kazzak"] = ""
L["Keep Inside"] = " "
L["Kel'Thuzad"] = "'"
L["Kurinnaxx"] = ""
L["Large"] = ""
L["Latency"] = ""
L["Leader"] = ""
L["Least remaining time"] = "  "
L["Leaving"] = ""
L["Leech"] = ""
L["Leech (%)"] = "C (%)"
L["Leech Rating"] = " "
L["Left"] = ""
L["Left to Right"] = " "
L["Left, then Centered Vertical"] = " >    "
L["Left, then Down"] = " > "
L["Left, then Up"] = " > "
L["Legacy Looking for Raid"] = "  (  5.4)"
L["Legacy RGB Gradient"] = " RGB"
L["Legacy RGB Gradient Pulse"] = "  RGB"
L["Legion"] = "Legion"
L["Length"] = ""
L["Level"] = ""
L["LibSharedMedia"] = "LibSharedMedia"
L["Lillian Voss"] = " "
L["Limited"] = ""
L["Linear Texture"] = " "
L["Lines & Particles"] = "  "
L["Load Conditions"] = " "
L["Loatheb"] = ""
L["Location"] = ""
L["Looking for Raid"] = " "
L["Loop"] = ""
L["Loot"] = ""
L["Loot Specialization"] = " "
L["Loot Specialization Id"] = "  "
L["Loot Specialization Name"] = "  "
--[[Translation missing --]]
L["Lorewalking"] = "Lorewalking"
L["Lost"] = ""
L["Low Damage"] = " "
L["Lower Than Tank"] = "    "
--[[Translation missing --]]
L["Lowest Spell Id"] = "Lowest Spell Id"
L["Lua error"] = " Lua"
--[[Translation missing --]]
L["Lua error in Aura '%s': %s"] = "Lua error in Aura '%s': %s"
L["Lucifron"] = ""
L["Maexxna"] = ""
L["Magic"] = ""
L["Magmadar"] = ""
L["Main Character"] = " "
L["Main Stat"] = " "
L["Majordomo Executus"] = " "
L["Malformed WeakAuras link"] = "  WeakAuras"
L["Manual"] = ""
L["Manual Icon"] = " "
L["Manual Rotation"] = " "
L["Marked First"] = "  "
L["Marked Last"] = "  "
--[[Translation missing --]]
L["Mason"] = "Mason"
L["Master"] = ""
L["Mastery (%)"] = " (%)"
L["Mastery Rating"] = " "
L["Match Count"] = " "
L["Match Count per Unit"] = "-   "
L["Matches (Pattern)"] = "  "
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = [=[        .     x.5
: 1, 2, 1, 2, 2.5, 3.]=]
L["Max Char "] = ".  "
--[[Translation missing --]]
L["Max Char"] = "Max Char"
L["Max Charges"] = ".  "
L["Max Health"] = ".  "
L["Max Power"] = ".  "
L["Max Quantity"] = " "
L["Maximum Estimate"] = ". "
L["Maximum Progress"] = " "
L["Maximum time used on a single frame"] = " ,    "
L["Media"] = ""
L["Medium"] = ""
L["Melee"] = " "
L["Melee Haste (%)"] = "   (%)"
L["Message"] = ""
L["Message Type"] = " "
L["Message type:"] = " :"
L["Meta Data"] = "  "
L["Mine"] = ""
L["Minimum Estimate"] = ". "
L["Minimum Progress"] = " "
L["Minus (Small Nameplate)"] = ""
L["Mirror"] = ""
L["Miscellaneous"] = ""
L["Miss"] = ""
L["Miss Type"] = " "
L["Missed"] = ""
L["Missing"] = " "
L["Mists of Pandaria"] = "Mists of Pandaria"
L["Moam"] = ""
L["Model"] = ""
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = "Blizzard ():  1. 3. | 3. 7. | 10. | 2.4"
L["Modernize"] = ""
L["Molten Core"] = " "
L["Money"] = ""
L["Monochrome"] = " "
L["Monochrome Outline"] = " ; "
L["Monochrome Thick Outline"] = "- ;  "
L["Monster Emote"] = " "
L["Monster Party"] = "   "
L["Monster Say"] = " "
L["Monster Whisper"] = " "
L["Monster Yell"] = " "
L["Moon"] = ""
L["Most remaining time"] = "  "
L["Mounted"] = ""
L["Mouse Cursor"] = " "
L["Movement Speed Rating"] = "  "
L["Multi-target"] = " "
L["Mythic Keystone"] = " "
L["Mythic+ Affix"] = "  "
L["Name"] = ""
L["Name Function"] = " "
L["Name Function (fallback state)"] = "  ( )"
L["Name of Caster's Target"] = "  "
L["Name of the (sub-)zone currently shown above the minimap."] = " (),      -."
L["Name(s)"] = ""
L["Name/Realm of Caster's Target"] = " / .   "
L["Nameplate"] = " "
L["Nameplates"] = " "
L["Names of affected Players"] = "  "
L["Names of unaffected Players"] = "  "
L["Nature Resistance"] = "  "
L["Naxxramas"] = ""
L["Nefarian"] = ""
L["Neutral"] = ""
L["Never"] = ""
L["Next Combat"] = " "
L["Next Encounter"] = "  "
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "    . .     BigWigs  DBM (  ,    )."
L["No Extend"] = " "
L["No Instance"] = "   (instance)"
L["No Profiling information saved."] = "  ."
--[[Translation missing --]]
L["No Progress Information available."] = "No Progress Information available."
L["None"] = ""
L["Non-player Character"] = "  (NPC)"
L["Normal"] = ""
L["Normal Party"] = " ()"
L["Not in Group"] = "  "
L["Not in Smart Group"] = " "
L["Not on Cooldown"] = " "
L["Not On Threat Table"] = "   "
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "|cFFFFCC00.|r -    Swing   API   Blizzard     ."
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = "|cFFFFCC00.|r  \"    \"     .          ."
L["Note: The available text replacements for multi triggers match the normal triggers now."] = "|cFFFFCC00.|r      ( )      ,    ."
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = ":      ,        , ,   ."
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "|cFFFFCC00.|r    API WoW,       ."
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "|cFFFFCC00.|r   ( )    .        3   .        ,       .        NPC. |n|n|cFFAAFFAAC:|r %s|n|cFFFFAAAA:|r %s|n|cFFAAAAFF :|r %s"
L["Noth the Plaguebringer"] = " "
L["NPC"] = "NPC"
L["Npc ID"] = "ID NPC"
L["Number"] = ""
L["Number Affected"] = " "
L["Object"] = ""
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = "          ,     : 2- 5-  6- : 2, 5, 6 2-  6-: 2-6  2 : /2  3 ,   2-: 2/3  3 ,   2-   11-: 2-11/3        "
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = "  ,    .    .    ,    . : 2-, 5-  6- : 2, 5, 6; 2-  6-: 2-6;  2 : /2;  3 ,   2-: 2/3;  3 ,   2-   11-: 2-11/3.   DBM     ."
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = "  ,    .    .    ,    . : 2-, 5-  6- : 2, 5, 6; 2-  6-: 2-6;  2 : /2;  3 ,   2-: 2/3;  3 ,   2-   11-: 2-11/3.   DBM     ."
L["Officer"] = ""
L["Offset from progress"] = "  "
L["Offset Timer"] = "  (.)"
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = "Blizzard ():  2. | 3. | 10. | 2.4"
L["On Cooldown"] = ""
L["On Taxi"] = " "
L["Only if on a different realm"] = "    . "
L["Only if Primary"] = "  "
L["Onyxia"] = ""
L["Opaque"] = ""
L["Option Group"] = " "
L["Options could not be loaded, the addon is %s"] = "   WeakAuras Options.  - %s"
L["Options will finish loading after combat ends."] = "    ."
L["Options will open after the login process has completed."] = "       ."
L["Or Talent"] = " "
L["Orbit"] = "  "
L["Orientation"] = ""
L["Ossirian the Unscarred"] = " "
L["Other"] = ""
L["Other Addons"] = " "
L["Other Events"] = " "
L["Ouro"] = ""
L["Outline"] = ""
--[[Translation missing --]]
L["Over Energize"] = "Over Energize"
L["Overhealing"] = " "
L["Overkill"] = " "
L["Overlay %s"] = " %s"
L["Overlay Charged Combo Points"] = "     ()"
L["Overlay Cost of Casts"] = "    ()"
L["Overlay Latency"] = "  ()"
--[[Translation missing --]]
L["Pad"] = "Pad"
--[[Translation missing --]]
L["Pad Mode"] = "Pad Mode"
--[[Translation missing --]]
L["Pad to"] = "Pad to"
L["Paragon Reputation"] = " "
L["Paragon Reward Pending"] = "   "
L["Parent Frame"] = " "
L["Parent Zone"] = " "
L["Parry"] = ""
L["Parry (%)"] = " (%)"
L["Parry Rating"] = " "
L["Party"] = ""
L["Party Kill"] = ""
L["Patchwerk"] = ""
L["Path of Ascension: Courage"] = " : "
L["Path of Ascension: Humility"] = " : "
L["Path of Ascension: Loyalty"] = " : "
L["Path of Ascension: Wisdom"] = " : "
L["Paused"] = ""
L["Periodic Spell"] = " "
L["Personal Resource Display"] = "  "
L["Pet"] = ""
L["Pet Behavior"] = " "
L["Pet Specialization"] = " "
L["Pet Spell"] = " "
L["Pets only"] = " "
L["Phase"] = ""
L["Pixel Glow"] = " "
L["Placement"] = ""
L["Placement %i"] = " %i"
L["Placement Mode"] = " "
L["Play"] = ""
L["Player"] = ""
L["Player Character"] = " "
L["Player Class"] = " "
L["Player Effective Level"] = "  "
L["Player Experience"] = " "
L["Player Faction"] = " "
L["Player Level"] = " "
L["Player Location ID(s)"] = "()  "
L["Player Money"] = " "
L["Player Name/Realm"] = " /   "
L["Player Race"] = " "
L["Player(s) Affected"] = " "
L["Player(s) Not Affected"] = " "
L["Player/Unit Info"] = "   / "
L["Players and Pets"] = "  "
L["Poison"] = ""
L["Power"] = ""
L["Power (%)"] = " (%)"
L["Power Deficit"] = " "
L["Power Type"] = " "
L["Precision"] = ""
L["Preset"] = " "
L["Primary Stats"] = " "
L["Princess Huhuran"] = " "
L["Print Profiling Results"] = "  "
L["Proc Glow"] = "  "
L["Profiling already started."] = "  ."
L["Profiling automatically started."] = "  ."
L["Profiling not running."] = "  ."
L["Profiling started."] = " ."
L["Profiling started. It will end automatically in %d seconds"] = "      %d |4::;."
L["Profiling still running, stop before trying to print."] = "   ;     ."
L["Profiling stopped."] = " ."
L["Progress"] = ""
L["Progress Source"] = " "
L["Progress Total"] = " "
L["Progress Value"] = " "
--[[Translation missing --]]
L["Pull"] = "Pull"
L["Pulse"] = ""
L["PvP Flagged"] = "  PvP"
L["PvP Talent selected"] = "PvP  "
L["PvP Talent Selected"] = "PvP  "
L["Quality Id"] = "ID "
L["Quantity"] = ""
L["Quantity earned this week"] = "   "
L["Quest Party"] = " "
L["Queued Action"] = "  "
L["Radius"] = ""
L["Ragnaros"] = ""
L["Raid"] = ""
L["Raid (Heroic)"] = " ()"
L["Raid (Mythic)"] = " ()"
L["Raid (Normal)"] = " ()"
L["Raid (Timewalking)"] = " (  )"
L["Raid Mark"] = " "
L["Raid Mark Icon"] = "  "
L["Raid Role"] = "  "
L["Raid Warning"] = " "
L["Raids"] = ""
L["Range"] = " "
L["Range Check"] = " "
L["Ranged"] = " "
L["Rank"] = ""
L["Rare"] = ""
L["Rare Elite"] = " "
L["Rated Arena"] = " "
L["Rated Battleground"] = "  "
L["Raw Threat Percent"] = "  "
L["Razorgore the Untamed"] = " "
L["Ready Check"] = " "
L["Reagent Quality"] = " "
L["Reagent Quality Texture"] = "  "
L["Realm"] = " "
L["Realm Name"] = "  "
L["Realm of Caster's Target"] = "   "
--[[Translation missing --]]
L["Reborn Council"] = "Reborn Council"
--[[Translation missing --]]
L["Receiving %s Bytes"] = "Receiving %s Bytes"
L["Receiving display information"] = "     %s ..."
L["Reflect"] = ""
L["Region type %s not supported"] = "  \"%s\"  "
L["Relative"] = ""
L["Relative X-Offset"] = "   X"
L["Relative Y-Offset"] = "   Y"
L["Remaining Duration"] = " "
L["Remaining Time"] = " "
L["Remove Obsolete Auras"] = "  "
L["Renown Level"] = " "
L["Renown Max Level"] = "  "
L["Renown Reputation"] = " "
L["Repair"] = ""
L["Repeat"] = ""
L["Report Summary"] = ""
L["Reputation"] = ""
L["Reputation (%)"] = " (%)"
L["Requested display does not exist"] = "   "
L["Requested display not authorized"] = "   "
L["Requesting display information from %s ..."] = "     %s ..."
L["Require Valid Target"] = "  "
L["Requires syncing the specialization via LibSpecialization."] = "    LibSpecialization."
L["Resilience (%)"] = " (%)"
L["Resilience Rating"] = " "
L["Resist"] = ""
L["Resistances"] = ""
L["Resisted"] = ""
L["Rested"] = ".   "
L["Rested Experience"] = ".   "
L["Rested Experience (%)"] = ".    (%)"
L["Resting"] = ""
L["Resurrect"] = ""
--[[Translation missing --]]
L["Resurrect Pending"] = "Resurrect Pending"
L["Right"] = ""
L["Right to Left"] = " "
L["Right, then Centered Vertical"] = " >    "
L["Right, then Down"] = " > "
L["Right, then Up"] = " > "
L["Role"] = ""
L["Rollback snapshot is complete. Thank you for your patience!"] = "  .    !"
L["Rotate Animation"] = " "
L["Rotate Left"] = " "
L["Rotate Right"] = " "
L["Rotation"] = ""
L["Round"] = "Round (  )"
L["Round Mode"] = " "
L["Ruins of Ahn'Qiraj"] = " '"
L["Run Custom Code"] = "  "
L["Run Speed (%)"] = "  (%)"
L["Rune"] = ""
L["Rune #1"] = " #1"
L["Rune #2"] = " #2"
L["Rune #3"] = " #3"
L["Rune #4"] = " #4"
L["Rune #5"] = " #5"
L["Rune #6"] = " #6"
L["Rune Count"] = " "
L["Rune Count - Blood"] = "  "
L["Rune Count - Frost"] = "  "
L["Rune Count - Unholy"] = "  "
L["Sapphiron"] = ""
L["Say"] = ""
L["Scale"] = ""
L["Scarlet Enclave"] = "  "
L["Scenario"] = ""
L["Scenario (Heroic)"] = " ()"
L["Scenario (Normal)"] = " ()"
L["Screen"] = ""
L["Screen/Parent Group"] = " /  "
L["Season of Discovery"] = " "
L["Second"] = ""
L["Second Value of Tooltip Text"] = "    "
L["Secondary Stats"] = " "
L["Seconds"] = ""
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = [=[  .    :
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=]
L["Select Frame"] = " "
--[[Translation missing --]]
L["Select the type of timer to filter"] = "Select the type of timer to filter"
L["Selection Mode"] = " "
L["Separator"] = ""
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = "     - wowhead.com/cata/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/classic/item-sets"
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = "ID     ru.wowhead.com/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"
L["Shadow Resistance"] = "  "
L["Shadowlands"] = "Shadowlands"
L["Shake"] = ""
L["Shazzrah"] = ""
L["Shift-Click to resume addon execution."] = "Shift+,    ."
L["Show"] = ""
L["Show CD of Charge"] = "  "
L["Show charged duration for empowered casts"] = "    "
L["Show GCD"] = "   "
L["Show Global Cooldown"] = "    (GCD)"
L["Show Incoming Heal"] = "  "
L["Show Loss of Control"] = "    "
L["Show On"] = ""
L["Show Rested Overlay"] = "     ()"
L["Shrink"] = ""
L["Silithid Royalty"] = " "
L["Silver"] = ""
L["Simple"] = ""
--[[Translation missing --]]
L["Since Active"] = "Since Active"
L["Since Apply"] = "   ."
L["Since Apply/Refresh"] = "   ."
L["Since Charge Gain"] = "   "
L["Since Charge Lost"] = "  . "
L["Since Ready"] = "   "
L["Since Stack Gain"] = "   "
L["Since Stack Lost"] = "   "
L["Size & Position"] = "  "
L["Skyriding"] = " "
L["Slide Animation"] = " "
L["Slide from Bottom"] = " "
L["Slide from Left"] = " "
L["Slide from Right"] = " "
L["Slide from Top"] = " "
L["Slide to Bottom"] = " "
L["Slide to Left"] = " "
L["Slide to Right"] = " "
L["Slide to Top"] = " "
L["Slider"] = ""
L["Small"] = ""
L["Smart Group"] = " >  > "
L["Soft Enemy"] = "  . "
L["Soft Friend"] = "  . "
L["Solistrasza"] = ""
L["Sound"] = ""
L["Sound by Kit ID"] = "  ID "
L["Source"] = ""
L["Source Affiliation"] = " "
L["Source GUID"] = "GUID "
L["Source Info"] = " "
L["Source Name"] = " "
L["Source NPC Id"] = "ID NPC-"
L["Source Object Type"] = "  "
L["Source Raid Mark"] = " "
L["Source Reaction"] = " "
L["Source Unit"] = ""
L["Source Unit Name/Realm"] = " / .  "
L["Source unit's raid mark index"] = "  ()"
L["Source unit's raid mark texture"] = "  ()"
L["Space"] = ""
L["Spacing"] = ""
L["Spark"] = ""
L["Spec Position"] = " "
L["Spec Role"] = " "
L["Specialization"] = ""
L["Specific Currency"] = " "
L["Specific Type"] = " "
L["Specific Unit"] = " "
L["Spell"] = ""
L["Spell (Building)"] = " ()"
L["Spell Activation Overlay Glow"] = "   "
L["Spell Cast Succeeded"] = "  "
L["Spell Cost"] = " "
L["Spell Count"] = " "
L["Spell ID"] = "ID "
L["Spell Id"] = "ID "
L["Spell ID:"] = "ID :"
L["Spell IDs:"] = "ID :"
L["Spell in Range"] = "   ()"
L["Spell Known"] = " "
L["Spell Name"] = " "
L["Spell Peneration Percent"] = ".  "
L["Spell Power"] = " "
L["Spell School"] = " "
L["Spell Usable"] = " "
L["Spellname"] = " "
L["Spike"] = ""
L["Spin"] = ""
L["Spiral"] = ""
L["Spiral In And Out"] = " (-)"
L["Spirit"] = ""
L["Stack Count"] = " "
L["Stack trace:"] = " :"
L["Stacks"] = ""
L["Stacks Function"] = " "
L["Stacks Function (fallback state)"] = "  ( )"
L["Stage"] = ""
L["Stage Counter"] = " "
--[[Translation missing --]]
L["Stagger"] = "Stagger"
L["Stagger (%)"] = " (%)"
L["Stagger against Target (%)"] = "    (%)"
L["Stagger Scale"] = [=[ 
(  )]=]
L["Stamina"] = ""
L["Stance/Form/Aura"] = " /  / "
L["Standing"] = ""
L["Star Shake"] = "   "
L["Start Animation"] = " "
L["Start Now"] = " "
L["Start Profiling"] = " "
L["Status"] = ""
L["Status Bar"] = " "
L["Stolen"] = ""
L["Stop"] = ""
L["Stop Motion"] = "-"
L["Story Raid"] = "  "
L["Strength"] = ""
L["String"] = ""
L["Subevent Info"] = "  "
L["Subtract Cast"] = "  "
L["Subtract Channel"] = "  "
L["Subtract GCD"] = " GCD"
L["Subzone Name"] = " "
L["Success"] = ""
L["Sulfuron Harbinger"] = " "
L["Summon"] = ""
--[[Translation missing --]]
L["Summon Pending"] = "Summon Pending"
L["Sun"] = ""
L["Supports multiple entries, separated by commas"] = "   ,  ."
L[ [=[Supports multiple entries, separated by commas
]=] ] = [=[   ,  .
]=]
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = "  ,  .  ','  \\.  '-'  ."
--[[Translation missing --]]
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = "Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = "  ,  .   '-'  ."
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = "  ,  .     ,   'c', , 'c2022'. IDs      'g', , 'g277'.  IDs   https://wago.tools/db2/AreaTable   'a'.  IDs    'i'.     '-'  ."
L["Swing"] = " "
L["Swing Timer"] = " Swing (  )"
L["Swipe"] = " Swipe ()"
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = " /wa feature <toggle|on|enable|disable|off> <feature>"
L["System"] = ""
L["Systems"] = ""
L["Tab "] = " "
L["Talent"] = ""
L["Talent |cFFFF0000Not|r Known"] = " |cFFFF0000|r"
L["Talent |cFFFF0000Not|r Selected"] = " |cFFFF0000|r "
L["Talent Known"] = " "
L["Talent Selected"] = " "
L["Talent selected"] = " "
L["Talent Specialization"] = ""
L["Tanking And Highest"] = "  ; . "
L["Tanking But Not Highest"] = "  ;  . "
L["Target"] = ""
L["Targeted"] = ""
L["Tertiary Stats"] = " "
--[[Translation missing --]]
L["Test if bar is enabled in BigWigs settings"] = "Test if bar is enabled in BigWigs settings"
--[[Translation missing --]]
L["Test if bar is enabled in Boss Mod addon settings"] = "Test if bar is enabled in Boss Mod addon settings"
--[[Translation missing --]]
L["Test if bar is enabled in DBM settings"] = "Test if bar is enabled in DBM settings"
L["Text"] = ""
L["Text To Speech"] = "  "
L["Text-to-speech"] = "  "
L["Texture"] = ""
L["Texture Function"] = " "
L["Texture Function (fallback state)"] = "  ( )"
L["Texture Picker"] = " "
L["Texture Rotation"] = " "
L["Thaddius"] = ""
L["The aura has overwritten the global '%s', this might affect other auras."] = "     %s.       ,     !"
--[[Translation missing --]]
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "The aura tried to overwrite the aura_env global, which is not allowed."
L["The effective level differs from the level in e.g. Time Walking dungeons."] = "       (  )    ( )"
L["The Four Horsemen"] = " "
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = " ID     BigWigs   "
L["The Prophet Skeram"] = " "
--[[Translation missing --]]
L["The total quantity a warband character can transfer after paying the transfer cost"] = "The total quantity a warband character can transfer after paying the transfer cost"
--[[Translation missing --]]
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = "The total quantity after transferring everything to your current character and paying the transfer cost"
L["The War Within"] = " "
L["There are %i updates to your auras ready to be installed!"] = "   %i |4::;."
L["Thick Outline"] = " "
L["Thickness"] = ""
L["Third"] = ""
L["Third Value of Tooltip Text"] = "    "
L["This aura calls GetData a lot, which is a slow function."] = "     GetData,   ."
L["This aura has caused a Lua error."] = "   Lua."
L["This aura is saving %s KB of data"] = "  %s  ."
L["This aura plays a sound via a condition."] = "     ."
L["This aura plays a sound via an action."] = "     ."
L["This aura plays a Text To Speech via a condition."] = "        ."
L["This aura plays a Text To Speech via an action."] = "        ."
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "      .   ,     ,     Discord WeakAuras   ."
L["Threat Percent"] = " "
L["Threat Situation"] = "   "
L["Threat Value"] = " "
L["Tick"] = ""
L["Time"] = ""
L["Time Format"] = ""
L["Time in GCDs"] = "  GCD"
L["Time since initial application"] = "    "
L["Time since last refresh"] = "    "
L["Time since stack gain"] = "    "
L["Time since stack lost"] = "    "
L["Timed"] = "  "
L["Timed Progress"] = "  "
--[[Translation missing --]]
L["Timer"] = "Timer"
L["Timer Id"] = "ID "
L["Toggle"] = " ()"
L["Toggle List"] = "  ()"
L["Toggle Options Window"] = "  "
L["Toggle Performance Profiling Window"] = "  "
L["Tooltip"] = ""
L["Tooltip 1"] = " 1"
L["Tooltip 2"] = " 2"
L["Tooltip 3"] = " 3"
L["Tooltip Value 1"] = "1   "
L["Tooltip Value 2"] = "2   "
L["Tooltip Value 3"] = "3   "
L["Tooltip Value 4"] = "4   "
L["Top"] = ""
L["Top Left"] = " "
L["Top Right"] = " "
L["Top to Bottom"] = " "
L["Torghast"] = ""
L["Total Duration"] = " "
L["Total Earned in this Season"] = "   "
L["Total Essence"] = "  "
L["Total Experience"] = "  "
L["Total Match Count"] = " "
L["Total Reputation"] = " "
L["Total Stacks"] = "  "
L["Total stacks over all matches"] = "    "
L["Total Stages"] = "  "
L["Total Unit Count"] = "  "
L["Total Units"] = "  "
L["Totem"] = ""
L["Totem #%i"] = " #%i"
L["Totem Icon"] = " "
L["Totem Name"] = " "
L["Totem Name Pattern Match"] = "    "
L["Totem Number"] = " "
L["Track Cooldowns"] = ""
L["Tracking Charge %i"] = "  %i- "
L["Tracking Charge CDs"] = " "
L["Tracking Only Cooldown"] = " "
L["Transmission error"] = "  "
L["Trigger"] = ""
L["Trigger %i"] = " %i"
L["Trigger %s"] = " %s"
L["Trigger 1"] = " 1"
L["Trigger State Updater (Advanced)"] = "   (TSU)"
L["Trigger Update"] = "   "
L["Trigger:"] = ":"
L["Trivial (Low Level)"] = " ( )"
L["True"] = ""
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "      %s,     ."
L["Twin Emperors"] = "-"
L["Type"] = ""
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "   '%s'. ,        .     WeakAuras."
L["Unaffected"] = ""
L["Undefined"] = " "
L["Unholy"] = ""
L["Unholy Rune #1"] = "  #1"
L["Unholy Rune #2"] = "  #2"
L["Unit"] = ""
L["Unit Characteristics"] = " "
L["Unit Destroyed"] = " "
L["Unit Died"] = " "
L["Unit Dissipates"] = " "
L["Unit Frame"] = " "
L["Unit Frames"] = " "
L["Unit is Unit"] = "  "
L["Unit Name"] = " "
L["Unit Name/Realm"] = " /   "
L["Units Affected"] = "  "
L["Units of affected Players in a table format"] = "     "
L["Units of unaffected Players in a table format"] = "     "
L["Unknown action %q"] = "  %q"
L["Unknown feature %q"] = "  %q"
L["unknown location"] = " "
L["Unlimited"] = ""
L["Untrigger %s"] = " %s"
L["Up"] = ""
L["Up, then Centered Horizontal"] = " >    "
L["Up, then Left"] = " > "
L["Up, then Right"] = " > "
L["Update Position"] = " "
L["Usage:"] = " :"
L["Use /wa minimap to show the minimap icon again."] = "  /wa minimap,      ."
L["Use Custom Color"] = "  "
L["Use Legacy floor rounding"] = "   Floor"
L["Use Texture"] = " "
L["Use Watched Faction"] = " ,      "
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "  UnitInRange  ,       .         (raid frames).    25  40        ."
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "WeakAuras.clones  .   WeakAuras.GetRegion(id, cloneId)."
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "WeakAuras.regions  .   WeakAuras.GetRegion(id)."
L["Vaelastrasz the Corrupt"] = " "
L["Versatility (%)"] = " (%)"
L["Versatility Rating"] = " "
L["Vertical"] = ""
L["Viscidus"] = ""
L["Visibility"] = ""
L["Visions of N'Zoth"] = " '"
--[[Translation missing --]]
L["Warband Quantity Total"] = "Warband Quantity Total"
--[[Translation missing --]]
L["Warband Transfer Percentage"] = "Warband Transfer Percentage"
--[[Translation missing --]]
L["Warband Transferred Quantity"] = "Warband Transferred Quantity"
L["Warfront (Heroic)"] = " ()"
L["Warfront (Normal)"] = " ()"
L["Warlords of Draenor"] = "Warlords of Draenor"
L["Warning"] = ""
L["Warning for unknown aura:"] = "   ."
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = ":    '%s'  -  "
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = "|cFFFFCC00.|r     ,    ,   ID ,  ."
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = "|cFFFFCC00.|r         %affected  %unaffected;     - %unitCount.    .     ."
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = "|cFFFFCC00.|r        %tooltip1, %tooltip2  %tooltip3.     ."
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras ():  63:42 | 3:07 | 10 | 2.4"
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras   .    ,     https://discord.gg/weakauras."
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras ,      ( downgrade).       .

 |cFFFF0000|r   ?  ,        ,  .

  : %s

|cffff0000      WTF  ,  .|r]=]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras     .          ,  -   .           ."
L["WeakAuras Profiling"] = " WeakAuras"
L["WeakAuras Profiling Report"] = " "
L["WeakAuras Version: %s"] = " WeakAuras: %s"
L["Weapon"] = ""
L["Weapon Enchant"] = "  "
L["Weapon Enchant / Fishing Lure"] = "   /  "
L["Whisper"] = ""
L["Width"] = ""
L["Wobble"] = ""
L["World Boss"] = " "
L["World Bosses"] = " "
L["Wrap"] = " "
L["Wrath of the Lich King"] = "Wrath of the Lich King"
L["Writing to the WeakAuras table is not allowed."] = "   WeakAuras ."
L["X-Offset"] = "  X"
L["Yell"] = ""
L["Y-Offset"] = "  Y"
L["You have new auras ready to be installed!"] = "    ,   !"
L["Your next encounter will automatically be profiled."] = "      ."
L["Your next instance of combat will automatically be profiled."] = "    ."
L["Your scheduled automatic profile has been cancelled."] = "    ."
L["Your threat as a percentage of the tank's current threat."] = "          ().   255.  ,     ."
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "      ,        ().   100.       ."
L["Your total threat on the mob."] = "      "
L["Zone Group ID"] = "ID  "
L["Zone ID"] = " "
L["Zone Name"] = "  "
L["Zoom"] = ""
L["Zoom Animation"] = " "
L["Zul'Gurub"] = "'"



-- ========================================
-- File: WeakAuras/Locales/zhCN.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "zhCN" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=['''-''-'


 \  - ]=]
L["%s Overlay Color"] = "%s "
L["* Suffix"] = "* "
L["/wa help - Show this message"] = "/wa help - "
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - /"
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - "
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = "/wa pstart - \"combat\"encounter"
L["/wa pstop - Finish profiling"] = "/wa pstop - "
L["/wa repair - Repair tool"] = "/wa repair - "
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55f|r/"
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55f|r/"
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55f|r/"
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fShift + |r"
L["|cffff0000deprecated|r"] = "|cffff0000|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000|r ID"
L["|cFFFF0000Not|r Item Equipped"] = "|cFFFF0000|r"
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000|r/"
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000|r"
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = "|cFFFF0000 COMBAT_LOG_EVENT_UNFILTERED|r  COMBAT_LOG_EVENT_UNFILTERED https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00|r%s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00|r"
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = [=[ |cff00ff00|r|cff00ff00|r|cff00ff00|r|cff00ff00|rID
 |cff00ff00|rID
|cffff0000|rID
 |cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|rID
 |cffffff00|r""""""""

|cffffff00*|r]=]
L["1. Profession 1. Accessory"] = "11"
L["1. Profession 2. Accessory"] = "12"
L["1. Professsion Tool"] = "1"
L["10 Man Raid"] = "10"
L["10 Player Raid"] = "10"
L["10 Player Raid (Heroic)"] = "10"
L["10 Player Raid (Normal)"] = "10"
L["2. Profession 1. Accessory"] = "21"
L["2. Profession 2. Accessory"] = "22"
L["2. Professsion Tool"] = "2"
L["20 Man Raid"] = "20"
L["20 Player Raid"] = "20"
L["25 Man Raid"] = "25"
L["25 Player Raid"] = "25"
L["25 Player Raid (Heroic)"] = "25"
L["25 Player Raid (Normal)"] = "25"
L["40 Man Raid"] = "40"
L["40 Player Raid"] = "40"
L["5 Man Dungeon"] = "5"
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = [=[WeakAuras
WeakAuras Discord]=]
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = "CVarCVar"
L["Abbreviate"] = ""
L["AbbreviateLargeNumbers (Blizzard)"] = ""
L["AbbreviateNumbers (Blizzard)"] = ""
L["Absorb"] = ""
L["Absorb and Healing"] = ""
L["Absorb Heal Overlay"] = ""
L["Absorb Overlay"] = ""
L["Absorbed"] = ""
L["Action Button Glow"] = ""
L["Actions"] = ""
L["Active"] = ""
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Boss|cFFffcc00BigWigs|r

BigWigsDBM]=]
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Boss|cFFffcc00DBM|r

BigWigsDBM]=]
L["Add"] = ""
L["Add Missing Auras"] = ""
L["Advanced Caster's Target Check"] = ""
L["Affected"] = ""
L["Affected Unit Count"] = ""
L["Afk"] = ""
L["Aggro"] = ""
L["Agility"] = ""
L["Ahn'Qiraj"] = ""
L["Alert Type"] = ""
L["Alive"] = ""
L["All"] = ""
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = ""
L["All States table contains a non table at key: '%s'."] = "'%s'table"
L["All Triggers"] = ""
L["Alliance"] = ""
L["Allow partial matches"] = ""
L["Alpha"] = ""
L["Alternate Power"] = ""
L["Always"] = ""
L["Always active trigger"] = ""
L["Always include realm"] = ""
L["Always True"] = ""
L["Amount"] = ""
L["Anchoring"] = ""
L["And Talent"] = ""
L["Angle and Radius"] = ""
L["Animations"] = ""
L["Anticlockwise"] = ""
L["Anub'Rekhan"] = ""
L["Any"] = ""
L["Any Triggers"] = ""
L["AOE"] = ""
L["Arcane Resistance"] = ""
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = "|cffff0000|r%s"
L["Arena"] = ""
L["Armor (%)"] = " (%)"
L["Armor against Target (%)"] = " (%)"
L["Armor Rating"] = ""
L["Array"] = ""
L["Ascending"] = ""
L["Assigned Role"] = ""
L["Assigned Role Icon"] = ""
L["Assist"] = ""
--[[Translation missing --]]
L["Assisted Combat Next Cast"] = "Assisted Combat Next Cast"
L["At Least One Enemy"] = ""
L["At missing Value"] = ""
L["At Percent"] = ""
L["At Value"] = ""
L["At War"] = ""
L["Attach to End"] = ""
L["Attach to End, backwards"] = ""
L["Attach to Point"] = ""
L["Attach to Start"] = ""
L["Attack Power"] = ""
L["Attackable"] = ""
L["Attackable Target"] = ""
L["Aura"] = ""
L["Aura '%s': %s"] = " '%s'%s"
L["Aura Applied"] = ""
L["Aura Applied Dose"] = ""
L["Aura Broken"] = ""
L["Aura Broken Spell"] = ""
L["Aura is using deprecated SetDurationInfo"] = "SetDurationInfo"
L["Aura loaded"] = ""
L["Aura Name"] = ""
L["Aura Names"] = ""
L["Aura Refresh"] = ""
L["Aura Removed"] = ""
L["Aura Removed Dose"] = ""
L["Aura Stack"] = ""
L["Aura Type"] = ""
L["Aura Version: %s"] = "%s"
L["Aura(s) Found"] = ""
L["Aura(s) Missing"] = ""
L["Aura:"] = ""
L["Auras"] = ""
L["Auras:"] = ""
L["Author Options"] = ""
L["Auto"] = ""
L["Autocast Shine"] = ""
L["Automatic"] = ""
L["Automatic Length"] = ""
L["Automatic Rotation"] = ""
L["Available features: %s"] = "%s"
L["Avoidance (%)"] = " (%)"
L["Avoidance Rating"] = ""
L["Ayamiss the Hunter"] = ""
L["Azuregos"] = ""
L["Back and Forth"] = ""
L["Background"] = ""
L["Background Color"] = ""
L["Balnazzar"] = ""
L["Bar Color/Gradient Start"] = "/"
L["Bar enabled in BigWigs settings"] = "BigWigs "
L["Bar enabled in Boss Mod addon settings"] = ""
L["Bar enabled in DBM settings"] = "DBM "
L["Bar Texture"] = ""
--[[Translation missing --]]
L["Bar Type"] = "Bar Type"
L["Baron Geddon"] = ""
L["Battle for Azeroth"] = ""
L["Battle.net Whisper"] = ""
L["Battleground"] = ""
L["Battleguard Sartura"] = ""
L["Beastmaster"] = ""
L["Beatrix"] = ""
L["BG>Raid>Party>Say"] = ">>>"
L["BG-System Alliance"] = ""
L["BG-System Horde"] = ""
L["BG-System Neutral"] = ""
L["Big Number"] = ""
L["BigWigs Addon"] = "BigWigs "
L["BigWigs Message"] = "BigWigs "
L["BigWigs Stage"] = "BigWigs "
L["BigWigs Timer"] = "BigWigs "
L["Black Wing Lair"] = ""
L["Bleed"] = ""
L["Blizzard Combat Text"] = ""
L["Blizzard Cooldown Reduction"] = ""
L["Block"] = ""
L["Block (%)"] = " (%)"
L["Block against Target (%)"] = " (%)"
L["Block Value"] = ""
L["Blocked"] = ""
L["Blood"] = ""
L["Blood Rune #1"] = " #1"
L["Blood Rune #2"] = " #2"
L["Bloodlord Mandokir"] = ""
L["Bonus Reputation Gain"] = ""
L["Border"] = ""
L["Boss"] = ""
L["Boss Emote"] = ""
L["Boss Mod Announce"] = "Boss"
L["Boss Mod Stage"] = "Boss"
L["Boss Mod Stage (Event)"] = "Boss ()"
L["Boss Mod Timer"] = "Boss"
L["Boss Whisper"] = ""
L["Bottom"] = ""
L["Bottom Left"] = ""
L["Bottom Right"] = ""
L["Bottom to Top"] = ""
L["Bounce"] = ""
L["Bounce with Decay"] = ""
--[[Translation missing --]]
L["Break"] = "Break"
L["BreakUpLargeNumbers (Blizzard)"] = ""
L["Broodlord Lashlayer"] = ""
L["Buff"] = ""
L["Buff/Debuff"] = "/"
L["Buffed/Debuffed"] = "/"
L["Burning Crusade"] = ""
L["Buru the Gorger"] = ""
L["Caldoran"] = ""
L["Callback function"] = ""
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = "boss1targetplayer"
L["Cancel"] = ""
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = " %i %i"
L["Capped"] = ""
L["Capped at Season Max"] = ""
L["Capped at Weekly Max"] = ""
L["Cast"] = ""
L["Cast Bar"] = ""
L["Cast Failed"] = ""
L["Cast Start"] = ""
L["Cast Success"] = ""
L["Cast Type"] = ""
L["Caster"] = ""
L["Caster Name"] = ""
L["Caster Realm"] = ""
L["Caster Unit"] = ""
L["Casters Name/Realm"] = "/"
L["Caster's Target"] = ""
L["Cataclysm"] = ""
L["Ceil"] = ""
L["Center"] = ""
L["Center, then alternating bottom and top"] = ""
L["Center, then alternating left and right"] = ""
L["Center, then alternating right and left"] = ""
L["Center, then alternating top and bottom"] = ""
L["Centered Horizontal"] = ""
L["Centered Horizontal, then Centered Vertical"] = ""
L["Centered Horizontal, then Down"] = ""
L["Centered Horizontal, then Up"] = ""
L["Centered Vertical"] = ""
L["Centered Vertical, then Centered Horizontal"] = ""
L["Centered Vertical, then Left"] = ""
L["Centered Vertical, then Right"] = ""
L["Changed"] = ""
L["Channel"] = ""
L["Channel (Spell)"] = ""
L["Character GUID"] = "GUID"
L["Character Name"] = ""
L["Character Stats"] = ""
L["Character Transferred Quantity"] = ""
L["Character Type"] = ""
L["Charge gained/lost"] = "/"
L["Charged Combo Points"] = ""
L["Charges"] = ""
L["Charges Changed Event"] = ""
L["Charging"] = ""
L["Chat Frame"] = ""
L["Chat Message"] = ""
L["Check if a single talent match a Rank"] = ""
L["Check nameplate's target every 0.2s"] = "0.2"
L["Chromaggus"] = ""
L["Circle"] = ""
L["Circular Texture"] = ""
L["Clamp"] = ""
L["Class"] = ""
L["Class and Specialization"] = ""
L["Classic"] = ""
L["Classification"] = ""
L["Clockwise"] = ""
L["Clone per Character"] = ""
L["Clone per Event"] = ""
L["Clone per Match"] = ""
L["Coin Precision"] = ""
L["Color"] = ""
L["Color Animation"] = ""
L["Combat Log"] = ""
L["Communities"] = ""
L["Condition Custom Test"] = ""
L["Conditions"] = ""
L["Contains"] = ""
L["Continuously update Movement Speed"] = ""
L["Cooldown"] = ""
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "BigWigs'~'"
L["Cooldown Progress (Item)"] = ""
L["Cooldown Progress (Slot)"] = ""
L["Cooldown Ready Event"] = ""
L["Cooldown Ready Event (Item)"] = ""
L["Cooldown Ready Event (Slot)"] = ""
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = ""
L["Cooldown/Charges/Count"] = "//"
L["Copper"] = ""
L["Could not load WeakAuras Archive, the addon is %s"] = "WeakAuras Archive%s"
L["Count"] = ""
L["Counter Clockwise"] = ""
L["Create"] = ""
L["Creature Family"] = ""
L["Creature Family Name"] = ""
L["Creature Type"] = ""
L["Creature Type Name"] = ""
L["Critical"] = "()"
L["Critical (%)"] = " (%)"
L["Critical Rating"] = ""
L["Crop X"] = "X"
L["Crop Y"] = "Y"
L["Crowd Controlled"] = ""
L["Crushing"] = ""
L["C'thun"] = ""
L["Cumulated time used during profiling"] = ""
L["Currency"] = ""
L["Current Essence"] = ""
L["Current Experience"] = ""
L["Current Instance"] = ""
L["Current Movement Speed (%)"] = " (%)"
L["Current Stage"] = ""
L["Current Zone"] = ""
L["Current Zone Group"] = ""
L["Curse"] = ""
L["Custom"] = ""
L["Custom Action"] = ""
L["Custom Anchor"] = ""
L["Custom Check"] = ""
L["Custom Color"] = ""
L["Custom Condition Code"] = ""
L["Custom Configuration"] = ""
L["Custom Fade Animation"] = ""
L["Custom Function"] = ""
L["Custom Grow"] = ""
L["Custom Sort"] = ""
L["Custom Text Function"] = ""
L["Custom Trigger Combination"] = ""
L["Custom Variables"] = ""
L["Damage"] = ""
L["Damage Shield"] = ""
L["Damage Shield Missed"] = ""
L["Damage Split"] = ""
L["DBM Announce"] = "DBM "
L["DBM Stage"] = "DBM "
L["DBM Timer"] = "DBM "
L["Dead"] = ""
L["Death"] = ""
L["Death Knight Rune"] = ""
L["Debuff"] = ""
L["Debuff Class"] = ""
L["Debuff Class Icon"] = ""
L["Debuff Type"] = "Debuff "
L["Debug Log contains more than 1000 entries"] = "1000"
L["Debug Logging enabled"] = ""
L["Debug Logging enabled for '%s'"] = "'%s'"
L["Defensive Stats"] = ""
L["Deflect"] = ""
L["Delve"] = ""
L["Desaturate"] = ""
L["Desaturate Background"] = ""
L["Desaturate Foreground"] = ""
L["Descending"] = ""
L["Description"] = ""
L["Dest Raid Mark"] = ""
L["Destination Affiliation"] = ""
L["Destination GUID"] = "GUID"
L["Destination Info"] = ""
L["Destination Name"] = ""
L["Destination NPC Id"] = " NPC ID"
L["Destination Object Type"] = ""
L["Destination Reaction"] = ""
L["Destination Unit"] = ""
L["Destination unit's raid mark index"] = ""
L["Destination unit's raid mark texture"] = ""
L["Difficulty"] = ""
L["Disable Spell Known Check"] = ""
L["Disabled"] = ""
L["Disabled feature %q"] = "%q"
L["Disabled Spell Known Check"] = ""
L["Discovered"] = ""
L["Disease"] = ""
L["Dispel"] = ""
L["Dispel Failed"] = ""
L["Display"] = ""
L["Distance"] = ""
L["Do Not Disturb"] = ""
L["Dodge"] = ""
L["Dodge (%)"] = " (%)"
L["Dodge Rating"] = ""
L["Down"] = ""
L["Down, then Centered Horizontal"] = ""
L["Down, then Left"] = ""
L["Down, then Right"] = ""
L["Dragonflight"] = ""
L["Drain"] = ""
L["Dropdown Menu"] = ""
L["Dumping table"] = ""
--[[Translation missing --]]
L["Dungeon (Celestial)"] = "Dungeon (Celestial)"
L["Dungeon (Heroic)"] = ""
L["Dungeon (Mythic)"] = ""
L["Dungeon (Mythic+)"] = ""
L["Dungeon (Normal)"] = ""
L["Dungeon (Timewalking)"] = ""
L["Dungeons"] = ""
L["Durability Damage"] = ""
L["Durability Damage All"] = ""
L["Duration"] = ""
L["Duration Function"] = ""
L["Duration Function (fallback state)"] = ""
L["Ease In"] = ""
L["Ease In and Out"] = ""
L["Ease Out"] = ""
L["Ebonroc"] = ""
L["Eclipse Direction"] = ""
L["Edge"] = ""
L["Edge of Madness"] = ""
L["Effective Spell Id"] = " Id"
L["Elide"] = ""
L["Elite"] = ""
L["Emote"] = ""
L["Empower Cast End"] = ""
L["Empower Cast Interrupt"] = ""
L["Empower Cast Start"] = ""
L["Empowered"] = ""
L["Empowered 1"] = "1"
L["Empowered 2"] = "2"
L["Empowered 3"] = "3"
L["Empowered 4"] = "4"
L["Empowered 5"] = "5"
L["Empowered Cast"] = ""
L["Empowered Cast Fully Charged"] = ""
L["Empowered Fully Charged"] = ""
L["Empty"] = ""
L["Enabled feature %q"] = "%q"
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = ""
L["Enchant Applied"] = ""
L["Enchant Found"] = ""
L["Enchant ID"] = " ID"
L["Enchant Missing"] = ""
L["Enchant Name or ID"] = " ID"
L["Enchant Removed"] = ""
L["Enchanted"] = ""
L["Encounter ID(s)"] = " ID"
L["Energize"] = ""
L["Enrage"] = ""
L["Enter a name or a spellId"] = "ID"
L["Entering"] = ""
L["Entering/Leaving Combat"] = "/"
L["Entering/Leaving Encounter"] = "/"
L["Entry Order"] = ""
L["Environment Type"] = ""
L["Environmental"] = ""
L["Equipment"] = ""
L["Equipment Set"] = ""
L["Equipment Set Equipped"] = ""
L["Equipment Slot"] = ""
L["Equipped"] = ""
L["Error"] = ""
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "'%s'https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Error decoding."] = ""
L["Error decompressing"] = ""
L["Error decompressing. This doesn't look like a WeakAuras import."] = "WeakAuras"
L["Error deserializing"] = ""
L["Error Frame"] = ""
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = " %s  %s "
--[[Translation missing --]]
L["Error in Aura '%s'"] = "Error in Aura '%s'"
L["Error not receiving display information from %s"] = " %s "
L["Essence"] = ""
L["Essence #1"] = " #1"
L["Essence #2"] = " #2"
L["Essence #3"] = " #3"
L["Essence #4"] = " #4"
L["Essence #5"] = " #5"
L["Essence #6"] = " #6"
L["Evade"] = ""
L["Event"] = ""
L["Event(s)"] = ""
L["Every Frame"] = ""
L["Every Frame (High CPU usage)"] = "CPU"
L["Evoker Essence"] = ""
L["Exact Spell ID(s)"] = " ID"
L["Execute Conditions"] = ""
L["Experience (%)"] = " (%)"
L["Expertise Bonus"] = ""
L["Expertise Rating"] = ""
L["Extend Outside"] = ""
L["Extra Amount"] = ""
L["Extra Attacks"] = ""
L["Extra Spell Id"] = "ID"
L["Extra Spell Name"] = ""
L["Faction"] = ""
L["Faction Name"] = ""
L["Faction Reputation"] = ""
L["Fade Animation"] = ""
L["Fade In"] = ""
L["Fade Out"] = ""
L["Fail Alert"] = ""
L["False"] = ""
L["Fankriss the Unyielding"] = ""
L["Feature %q is already disabled"] = "%q"
L["Feature %q is already enabled"] = "%q"
L["Fetch Absorb"] = ""
L["Fetch Heal Absorb"] = ""
L["Fetch Legendary Power"] = ""
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = "ID"
L["Fill Area"] = ""
L["Filter messages with format <message>"] = " <message>"
L["Fire Resistance"] = ""
L["Firemaw"] = ""
L["First"] = ""
L["First Value of Tooltip Text"] = ""
L["Fixed"] = ""
L["Fixed Names"] = ""
L["Fixed Size"] = ""
L["Flamegor"] = ""
L["Flash"] = ""
L["Flex Raid"] = ""
L["Flip"] = ""
L["Floor"] = ""
L["Focus"] = ""
L["Follower Dungeon"] = ""
L["Font"] = ""
L["Font Size"] = ""
L["Forbidden function or table: %s"] = "%s"
L["Foreground"] = ""
L["Foreground Color"] = ""
L["Form"] = ""
L["Format"] = ""
L["Format Gold"] = ""
L["Formats |cFFFFCC00%unit|r"] = "|cFFFFCC00%unit|r"
L["Formats Player's |cFFFFCC00%guid|r"] = "|cFFFFCC00%guid|r"
L["Forward"] = ""
L["Forward, Reverse Loop"] = ""
L["Fourth Value of Tooltip Text"] = ""
L["Frame Selector"] = ""
L["Frequency"] = ""
L["Friendly"] = ""
L["Friendly Fire"] = ""
L["Friendship Max Rank"] = ""
L["Friendship Rank"] = ""
L["Friendship Reputation"] = ""
L["Frost"] = ""
L["Frost Resistance"] = ""
L["Frost Rune #1"] = " #1"
L["Frost Rune #2"] = " #2"
L["Full"] = ""
L["Full Region"] = ""
L["Full/Empty"] = " / "
L["Gahz'ranka"] = ""
L["Gained"] = ""
L["Garr"] = ""
L["Gehennas"] = ""
L["General"] = ""
L["General Rajaxx"] = ""
L["GetNameAndIcon Function (fallback state)"] = ""
L["Glancing"] = ""
L["Global Cooldown"] = ""
L["Glow"] = ""
L["Glow External Element"] = ""
L["Gluth"] = ""
--[[Translation missing --]]
L["Glyph"] = "Glyph"
L["Gold"] = ""
L["Golemagg the Incinerator"] = ""
L["Gothik the Harvester"] = ""
L["Gradient"] = ""
L["Gradient Enabled"] = ""
L["Gradient End"] = ""
L["Gradient Orientation"] = ""
L["Gradient Pulse"] = ""
L["Grand Widow Faerlina"] = ""
L["Grid"] = ""
L["Grobbulus"] = ""
L["Group"] = ""
L["Group Arrangement"] = ""
L["Group Leader/Assist"] = "/"
L["Group Size"] = ""
L["Group Type"] = ""
L["Grow"] = ""
L["GTFO Alert"] = "GTFO "
L["Guardian"] = ""
L["Guild"] = ""
L["Hakkar"] = ""
L["Hardcore"] = ""
L["Has Target"] = ""
L["Has Vehicle UI"] = " UI"
L["HasPet"] = ""
L["Haste (%)"] = " (%)"
L["Haste Rating"] = ""
L["Heal"] = ""
L["Heal Absorb"] = ""
L["Heal Absorbed"] = ""
L["Health"] = ""
L["Health (%)"] = " (%)"
L["Health Deficit"] = ""
L["Heigan the Unclean"] = ""
L["Height"] = ""
L["Hero Talent"] = ""
L["Heroic Party"] = ""
L["Hide"] = ""
L["Hide 0 cooldowns"] = "0"
L["Hide Timer Text"] = ""
L["High Damage"] = ""
L["High Priest Thekal"] = ""
L["High Priest Venoxis"] = ""
L["High Priestess Arlokk"] = ""
L["High Priestess Jeklik"] = ""
L["High Priestess Mar'li"] = ""
L["Higher Than Tank"] = "MT"
L["Highest Spell Id"] = " Id"
L["Hit (%)"] = " (%)"
L["Hit Rating"] = ""
L["Holy Resistance"] = ""
L["Horde"] = ""
L["Horizontal"] = ""
L["Hostile"] = ""
L["Hostility"] = ""
L["Humanoid"] = ""
L["Hybrid"] = ""
L["Icon"] = ""
L["Icon Function"] = ""
L["Icon Function (fallback state)"] = ""
L["Id"] = "ID"
L["ID"] = "ID"
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = " GitHub  Discordhttps://discord.gg/weakauras"
L["Ignore Dead"] = ""
L["Ignore Disconnected"] = ""
L["Ignore Rune CD"] = "CD"
L["Ignore Rune CDs"] = ""
L["Ignore Self"] = ""
L["Ignore Spell Cooldown/Charges"] = "/"
L["Ignore Spell Override"] = ""
L["Immune"] = ""
L["Important"] = ""
L["Importing will start after combat ends."] = ""
L["In Combat"] = ""
L["In Encounter"] = ""
L["In Group"] = ""
L["In Party"] = ""
L["In Pet Battle"] = ""
L["In Raid"] = ""
L["In Range"] = ""
L["In Vehicle"] = ""
L["In War Mode"] = ""
L["Include Bank"] = ""
L["Include Charges"] = ""
L["Include Death Runes"] = ""
L["Include Pets"] = ""
L["Include War Band Bank"] = ""
L["Incoming Heal"] = ""
L["Increase Precision Below"] = ""
L["Increases by one per stage or intermission."] = "1"
L["Information"] = ""
L["Inherited"] = ""
L["Instakill"] = ""
L["Install the addons BugSack and BugGrabber for detailed error logs."] = "BugSackBugGrabber"
L["Instance"] = ""
L["Instance Difficulty"] = ""
L["Instance Id"] = "ID"
L["Instance ID"] = "ID"
L["Instance Info"] = ""
L["Instance Name"] = ""
L["Instance Size Type"] = ""
L["Instance Type"] = ""
L["Instructor Razuvious"] = ""
L["Insufficient Resources"] = ""
L["Intellect"] = ""
L["Interrupt"] = ""
L["Interrupt School"] = ""
L["Interrupted School Text"] = ""
L["Interruptible"] = ""
L["Inverse"] = ""
L["Inverse Pet Behavior"] = ""
L["Is Away from Keyboard"] = ""
L["Is Current Specialization"] = ""
L["Is Death Rune"] = ""
L["Is Exactly"] = ""
L["Is Moving"] = ""
L["Is Off Hand"] = ""
L["Is Paragon Reputation"] = ""
L["Is Paused"] = ""
L["is useable"] = ""
L["Is Weekly Renown Capped"] = ""
L["Island Expedition (Heroic)"] = ""
L["Island Expedition (Mythic)"] = ""
L["Island Expedition (Normal)"] = ""
L["Island Expeditions (PvP)"] = "PvP"
L["Item"] = ""
L["Item Bonus Id"] = "ID"
L["Item Bonus Id Equipped"] = "ID"
L["Item Count"] = ""
L["Item Equipped"] = ""
L["Item Id"] = "ID"
L["Item in Range"] = ""
L["Item Name"] = ""
L["Item Set Equipped"] = ""
L["Item Set Id"] = " ID"
L["Item Slot"] = ""
L["Item Slot String"] = ""
L["Item Type"] = ""
L["Item Type Equipped"] = ""
L["ItemId"] = "Id"
L["Jin'do the Hexxer"] = ""
L["Journal Stage"] = ""
L["Kazzak"] = ""
L["Keep Inside"] = ""
L["Kel'Thuzad"] = ""
L["Kurinnaxx"] = ""
L["Large"] = ""
L["Latency"] = ""
L["Leader"] = ""
L["Least remaining time"] = ""
L["Leaving"] = ""
L["Leech"] = ""
L["Leech (%)"] = " (%)"
L["Leech Rating"] = ""
L["Left"] = ""
L["Left to Right"] = ""
L["Left, then Centered Vertical"] = ""
L["Left, then Down"] = ""
L["Left, then Up"] = ""
L["Legacy Looking for Raid"] = ""
L["Legacy RGB Gradient"] = " RGB "
L["Legacy RGB Gradient Pulse"] = " RGB "
L["Legion"] = ""
L["Length"] = ""
L["Level"] = ""
L["LibSharedMedia"] = "LibSharedMedia"
L["Lillian Voss"] = ""
L["Limited"] = ""
L["Linear Texture"] = ""
L["Lines & Particles"] = ""
L["Load Conditions"] = ""
L["Loatheb"] = ""
L["Location"] = ""
L["Looking for Raid"] = ""
L["Loop"] = ""
L["Loot"] = ""
L["Loot Specialization"] = ""
L["Loot Specialization Id"] = "ID"
L["Loot Specialization Name"] = ""
--[[Translation missing --]]
L["Lorewalking"] = "Lorewalking"
L["Lost"] = ""
L["Low Damage"] = ""
L["Lower Than Tank"] = "MT"
L["Lowest Spell Id"] = " Id"
L["Lua error"] = "Lua"
--[[Translation missing --]]
L["Lua error in Aura '%s': %s"] = "Lua error in Aura '%s': %s"
L["Lucifron"] = ""
L["Maexxna"] = ""
L["Magic"] = ""
L["Magmadar"] = ""
L["Main Character"] = ""
L["Main Stat"] = ""
L["Majordomo Executus"] = ""
L["Malformed WeakAuras link"] = " WeakAuras "
L["Manual"] = ""
L["Manual Icon"] = ""
L["Manual Rotation"] = ""
L["Marked First"] = ""
L["Marked Last"] = ""
L["Mason"] = ""
L["Master"] = ""
L["Mastery (%)"] = " (%)"
L["Mastery Rating"] = ""
L["Match Count"] = ""
L["Match Count per Unit"] = ""
L["Matches (Pattern)"] = ""
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = ".51;2;1;2;2.5;3"
L["Max Char "] = ""
L["Max Char"] = ""
L["Max Charges"] = ""
L["Max Health"] = ""
L["Max Power"] = ""
L["Max Quantity"] = ""
L["Maximum Estimate"] = ""
L["Maximum Progress"] = ""
L["Maximum time used on a single frame"] = ""
L["Media"] = ""
L["Medium"] = ""
L["Melee"] = ""
L["Melee Haste (%)"] = ""
L["Message"] = ""
L["Message Type"] = ""
L["Message type:"] = ""
L["Meta Data"] = ""
L["Mine"] = ""
L["Minimum Estimate"] = ""
L["Minimum Progress"] = ""
L["Minus (Small Nameplate)"] = ""
L["Mirror"] = ""
L["Miscellaneous"] = ""
L["Miss"] = ""
L["Miss Type"] = ""
L["Missed"] = ""
L["Missing"] = ""
L["Mists of Pandaria"] = ""
L["Moam"] = ""
L["Model"] = ""
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = " 1 3 | 3 7 | 10 | 2.4"
L["Modernize"] = ""
L["Molten Core"] = ""
L["Money"] = ""
L["Monochrome"] = ""
L["Monochrome Outline"] = ""
L["Monochrome Thick Outline"] = ""
L["Monster Emote"] = ""
L["Monster Party"] = ""
L["Monster Say"] = ""
L["Monster Whisper"] = ""
L["Monster Yell"] = ""
L["Moon"] = ""
L["Most remaining time"] = ""
L["Mounted"] = ""
L["Mouse Cursor"] = ""
L["Movement Speed Rating"] = ""
L["Multi-target"] = ""
L["Mythic Keystone"] = ""
L["Mythic+ Affix"] = ""
L["Name"] = ""
L["Name Function"] = ""
L["Name Function (fallback state)"] = ""
L["Name of Caster's Target"] = ""
L["Name of the (sub-)zone currently shown above the minimap."] = ""
L["Name(s)"] = ""
L["Name/Realm of Caster's Target"] = "/"
L["Nameplate"] = ""
L["Nameplates"] = ""
L["Names of affected Players"] = ""
L["Names of unaffected Players"] = ""
L["Nature Resistance"] = ""
L["Naxxramas"] = ""
L["Nefarian"] = ""
L["Neutral"] = ""
L["Never"] = ""
L["Next Combat"] = ""
L["Next Encounter"] = ""
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = [=[Boss

BigWigsDBM]=]
L["No Extend"] = ""
L["No Instance"] = ""
L["No Profiling information saved."] = ""
L["No Progress Information available."] = ""
L["None"] = ""
L["Non-player Character"] = "NPC"
L["Normal"] = ""
L["Normal Party"] = ""
L["Not in Group"] = ""
L["Not in Smart Group"] = ""
L["Not on Cooldown"] = ""
L["Not On Threat Table"] = ""
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = "API"
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = ""
L["Note: The available text replacements for multi triggers match the normal triggers now."] = ""
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = ""
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "WoW API"
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = " 3 NPC|n|n|cFFAAFFAA|r %s|n|cFFFFAAAA|r %s|n|cFFAAAAFF|r %s"
L["Noth the Plaguebringer"] = ""
L["NPC"] = "NPC"
L["Npc ID"] = "NPC ID"
L["Number"] = ""
L["Number Affected"] = ""
L["Object"] = ""
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = [=[




2, 5, 6
2-6
/2
2/3
2-11/3

 Boss Mod 
2/3
2-11/3

Boss]=]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[




2, 5, 6
2-6
/2
2/3
2-11/3

BigWigs]=]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[




2, 5, 6
2-6
/2
2/3
2-11/3

DBM]=]
L["Officer"] = ""
L["Offset from progress"] = ""
L["Offset Timer"] = ""
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = " 2h | 3m | 10s | 2.4"
L["On Cooldown"] = ""
L["On Taxi"] = ""
L["Only if on a different realm"] = ""
L["Only if Primary"] = ""
L["Onyxia"] = ""
L["Opaque"] = ""
L["Option Group"] = ""
L["Options could not be loaded, the addon is %s"] = "Options%s"
L["Options will finish loading after combat ends."] = ""
L["Options will open after the login process has completed."] = ""
L["Or Talent"] = ""
L["Orbit"] = ""
L["Orientation"] = ""
L["Ossirian the Unscarred"] = ""
L["Other"] = ""
L["Other Addons"] = ""
L["Other Events"] = ""
L["Ouro"] = ""
L["Outline"] = ""
--[[Translation missing --]]
L["Over Energize"] = "Over Energize"
L["Overhealing"] = ""
L["Overkill"] = ""
L["Overlay %s"] = " %s"
L["Overlay Charged Combo Points"] = ""
L["Overlay Cost of Casts"] = ""
L["Overlay Latency"] = ""
L["Pad"] = ""
L["Pad Mode"] = ""
L["Pad to"] = ""
L["Paragon Reputation"] = ""
L["Paragon Reward Pending"] = ""
L["Parent Frame"] = ""
L["Parent Zone"] = ""
L["Parry"] = ""
L["Parry (%)"] = " (%)"
L["Parry Rating"] = ""
L["Party"] = ""
L["Party Kill"] = "/"
L["Patchwerk"] = ""
L["Path of Ascension: Courage"] = ""
L["Path of Ascension: Humility"] = ""
L["Path of Ascension: Loyalty"] = ""
L["Path of Ascension: Wisdom"] = ""
L["Paused"] = ""
L["Periodic Spell"] = ""
L["Personal Resource Display"] = ""
L["Pet"] = ""
L["Pet Behavior"] = ""
L["Pet Specialization"] = ""
L["Pet Spell"] = ""
L["Pets only"] = ""
L["Phase"] = ""
L["Pixel Glow"] = ""
L["Placement"] = ""
L["Placement %i"] = "%i"
L["Placement Mode"] = ""
L["Play"] = ""
L["Player"] = ""
L["Player Character"] = ""
L["Player Class"] = ""
L["Player Effective Level"] = ""
L["Player Experience"] = ""
L["Player Faction"] = ""
L["Player Level"] = ""
L["Player Location ID(s)"] = "ID"
L["Player Money"] = ""
L["Player Name/Realm"] = "/"
L["Player Race"] = ""
L["Player(s) Affected"] = ""
L["Player(s) Not Affected"] = ""
L["Player/Unit Info"] = "/"
L["Players and Pets"] = ""
L["Poison"] = ""
L["Power"] = ""
L["Power (%)"] = " (%)"
L["Power Deficit"] = ""
L["Power Type"] = ""
L["Precision"] = ""
L["Preset"] = ""
L["Primary Stats"] = ""
L["Princess Huhuran"] = ""
L["Print Profiling Results"] = ""
L["Proc Glow"] = ""
L["Profiling already started."] = ""
L["Profiling automatically started."] = ""
L["Profiling not running."] = ""
L["Profiling started."] = ""
L["Profiling started. It will end automatically in %d seconds"] = "%d"
L["Profiling still running, stop before trying to print."] = ""
L["Profiling stopped."] = ""
L["Progress"] = ""
L["Progress Source"] = ""
L["Progress Total"] = ""
L["Progress Value"] = ""
--[[Translation missing --]]
L["Pull"] = "Pull"
L["Pulse"] = ""
L["PvP Flagged"] = "PvP "
L["PvP Talent selected"] = "PvP "
L["PvP Talent Selected"] = "PvP"
L["Quality Id"] = "ID"
L["Quantity"] = ""
L["Quantity earned this week"] = ""
L["Quest Party"] = ""
L["Queued Action"] = ""
L["Radius"] = ""
L["Ragnaros"] = ""
L["Raid"] = ""
L["Raid (Heroic)"] = ""
L["Raid (Mythic)"] = ""
L["Raid (Normal)"] = ""
L["Raid (Timewalking)"] = ""
L["Raid Mark"] = ""
L["Raid Mark Icon"] = ""
L["Raid Role"] = ""
L["Raid Warning"] = ""
L["Raids"] = ""
L["Range"] = ""
L["Range Check"] = ""
L["Ranged"] = ""
L["Rank"] = ""
L["Rare"] = ""
L["Rare Elite"] = ""
L["Rated Arena"] = ""
L["Rated Battleground"] = ""
L["Raw Threat Percent"] = ""
L["Razorgore the Untamed"] = ""
L["Ready Check"] = ""
L["Reagent Quality"] = ""
L["Reagent Quality Texture"] = ""
L["Realm"] = ""
L["Realm Name"] = ""
L["Realm of Caster's Target"] = ""
L["Reborn Council"] = ""
L["Receiving %s Bytes"] = " %s "
L["Receiving display information"] = " %s "
L["Reflect"] = ""
L["Region type %s not supported"] = " %s"
L["Relative"] = ""
L["Relative X-Offset"] = " X "
L["Relative Y-Offset"] = " Y "
L["Remaining Duration"] = ""
L["Remaining Time"] = ""
L["Remove Obsolete Auras"] = ""
L["Renown Level"] = ""
L["Renown Max Level"] = ""
L["Renown Reputation"] = ""
L["Repair"] = ""
L["Repeat"] = ""
L["Report Summary"] = ""
L["Reputation"] = ""
L["Reputation (%)"] = " (%)"
L["Requested display does not exist"] = ""
L["Requested display not authorized"] = ""
L["Requesting display information from %s ..."] = " %s "
L["Require Valid Target"] = ""
L["Requires syncing the specialization via LibSpecialization."] = "LibSpecialization"
L["Resilience (%)"] = " (%)"
L["Resilience Rating"] = ""
L["Resist"] = ""
L["Resistances"] = ""
L["Resisted"] = ""
L["Rested"] = ""
L["Rested Experience"] = ""
L["Rested Experience (%)"] = " (%)"
L["Resting"] = ""
L["Resurrect"] = ""
L["Resurrect Pending"] = ""
L["Right"] = ""
L["Right to Left"] = ""
L["Right, then Centered Vertical"] = ""
L["Right, then Down"] = ""
L["Right, then Up"] = ""
L["Role"] = ""
L["Rollback snapshot is complete. Thank you for your patience!"] = ""
L["Rotate Animation"] = ""
L["Rotate Left"] = ""
L["Rotate Right"] = ""
L["Rotation"] = ""
L["Round"] = ""
L["Round Mode"] = ""
L["Ruins of Ahn'Qiraj"] = ""
L["Run Custom Code"] = ""
L["Run Speed (%)"] = " (%)"
L["Rune"] = ""
L["Rune #1"] = " #1"
L["Rune #2"] = " #2"
L["Rune #3"] = " #3"
L["Rune #4"] = " #4"
L["Rune #5"] = " #5"
L["Rune #6"] = " #6"
L["Rune Count"] = ""
L["Rune Count - Blood"] = " - "
L["Rune Count - Frost"] = " - "
L["Rune Count - Unholy"] = " - "
L["Sapphiron"] = ""
L["Say"] = ""
L["Scale"] = ""
L["Scarlet Enclave"] = ""
L["Scenario"] = ""
L["Scenario (Heroic)"] = ""
L["Scenario (Normal)"] = ""
L["Screen"] = ""
L["Screen/Parent Group"] = "/"
L["Season of Discovery"] = ""
L["Second"] = ""
L["Second Value of Tooltip Text"] = ""
L["Secondary Stats"] = ""
L["Seconds"] = ""
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Select Frame"] = ""
--[[Translation missing --]]
L["Select the type of timer to filter"] = "Select the type of timer to filter"
L["Selection Mode"] = ""
L["Separator"] = ""
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = " ID wowhead.com/cata/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/classic/item-sets"
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = " ID wowhead.com/item-sets"
--[[Translation missing --]]
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = "Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"
L["Shadow Resistance"] = ""
L["Shadowlands"] = ""
L["Shake"] = ""
L["Shazzrah"] = ""
L["Shift-Click to resume addon execution."] = "Shift + "
L["Show"] = ""
L["Show CD of Charge"] = " CD"
L["Show charged duration for empowered casts"] = ""
L["Show GCD"] = " GCD"
L["Show Global Cooldown"] = ""
L["Show Incoming Heal"] = ""
L["Show Loss of Control"] = ""
L["Show On"] = ""
L["Show Rested Overlay"] = ""
L["Shrink"] = ""
L["Silithid Royalty"] = ""
L["Silver"] = ""
L["Simple"] = ""
L["Since Active"] = ""
L["Since Apply"] = ""
L["Since Apply/Refresh"] = "/"
L["Since Charge Gain"] = ""
L["Since Charge Lost"] = ""
L["Since Ready"] = ""
L["Since Stack Gain"] = ""
L["Since Stack Lost"] = ""
L["Size & Position"] = ""
L["Skyriding"] = ""
L["Slide Animation"] = ""
L["Slide from Bottom"] = ""
L["Slide from Left"] = ""
L["Slide from Right"] = ""
L["Slide from Top"] = ""
L["Slide to Bottom"] = ""
L["Slide to Left"] = ""
L["Slide to Right"] = ""
L["Slide to Top"] = ""
L["Slider"] = ""
L["Small"] = ""
L["Smart Group"] = ""
L["Soft Enemy"] = ""
L["Soft Friend"] = ""
L["Solistrasza"] = ""
L["Sound"] = ""
L["Sound by Kit ID"] = " ID "
L["Source"] = ""
L["Source Affiliation"] = ""
L["Source GUID"] = "GUID"
L["Source Info"] = ""
L["Source Name"] = ""
L["Source NPC Id"] = " NPC ID"
L["Source Object Type"] = ""
L["Source Raid Mark"] = ""
L["Source Reaction"] = ""
L["Source Unit"] = ""
L["Source Unit Name/Realm"] = "/"
L["Source unit's raid mark index"] = ""
L["Source unit's raid mark texture"] = ""
L["Space"] = ""
L["Spacing"] = ""
L["Spark"] = ""
L["Spec Position"] = ""
L["Spec Role"] = ""
L["Specialization"] = ""
L["Specific Currency"] = ""
L["Specific Type"] = ""
L["Specific Unit"] = ""
L["Spell"] = ""
L["Spell (Building)"] = "()"
L["Spell Activation Overlay Glow"] = ""
L["Spell Cast Succeeded"] = ""
L["Spell Cost"] = ""
L["Spell Count"] = ""
L["Spell ID"] = " ID"
L["Spell Id"] = " ID"
L["Spell ID:"] = " ID"
L["Spell IDs:"] = " ID"
L["Spell in Range"] = ""
L["Spell Known"] = ""
L["Spell Name"] = ""
L["Spell Peneration Percent"] = ""
L["Spell Power"] = ""
L["Spell School"] = ""
L["Spell Usable"] = ""
L["Spellname"] = ""
L["Spike"] = ""
L["Spin"] = ""
L["Spiral"] = ""
L["Spiral In And Out"] = ""
L["Spirit"] = ""
L["Stack Count"] = ""
L["Stack trace:"] = ""
L["Stacks"] = ""
L["Stacks Function"] = ""
L["Stacks Function (fallback state)"] = ""
L["Stage"] = ""
L["Stage Counter"] = ""
--[[Translation missing --]]
L["Stagger"] = "Stagger"
L["Stagger (%)"] = " (%)"
L["Stagger against Target (%)"] = " (%)"
L["Stagger Scale"] = ""
L["Stamina"] = ""
L["Stance/Form/Aura"] = "//"
L["Standing"] = ""
L["Star Shake"] = ""
L["Start Animation"] = ""
L["Start Now"] = ""
L["Start Profiling"] = ""
L["Status"] = ""
L["Status Bar"] = ""
L["Stolen"] = ""
L["Stop"] = ""
L["Stop Motion"] = ""
L["Story Raid"] = ""
L["Strength"] = ""
L["String"] = ""
L["Subevent Info"] = ""
L["Subtract Cast"] = ""
L["Subtract Channel"] = ""
L["Subtract GCD"] = " GCD"
L["Subzone Name"] = ""
L["Success"] = ""
L["Sulfuron Harbinger"] = ""
L["Summon"] = ""
L["Summon Pending"] = ""
L["Sun"] = ""
L["Supports multiple entries, separated by commas"] = ""
L[ [=[Supports multiple entries, separated by commas
]=] ] = ""
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = " \\  ',' '-' "
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = " \\  '-' "
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = " '-' "
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = [=[ ID 'c' 'c2022' ID  
 'g'  'g277' ID  'a'  https://wago.tools/db2/AreaTable  '-' ]=]
L["Swing"] = ""
L["Swing Timer"] = ""
L["Swipe"] = ""
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = " /wa feature <toggle|on|enable|disable|off> <feature>"
L["System"] = ""
L["Systems"] = ""
L["Tab "] = " "
L["Talent"] = ""
L["Talent |cFFFF0000Not|r Known"] = "|cFFFF0000|r"
L["Talent |cFFFF0000Not|r Selected"] = "|cFFFF0000|r"
L["Talent Known"] = ""
L["Talent Selected"] = ""
L["Talent selected"] = ""
L["Talent Specialization"] = ""
L["Tanking And Highest"] = "T"
L["Tanking But Not Highest"] = "T"
L["Target"] = ""
L["Targeted"] = ""
L["Tertiary Stats"] = ""
L["Test if bar is enabled in BigWigs settings"] = " BigWigs "
L["Test if bar is enabled in Boss Mod addon settings"] = ""
L["Test if bar is enabled in DBM settings"] = " DBM "
L["Text"] = ""
L["Text To Speech"] = ""
L["Text-to-speech"] = ""
L["Texture"] = ""
L["Texture Function"] = ""
L["Texture Function (fallback state)"] = ""
L["Texture Picker"] = ""
L["Texture Rotation"] = ""
L["Thaddius"] = ""
L["The aura has overwritten the global '%s', this might affect other auras."] = "'%s'"
--[[Translation missing --]]
L["The aura tried to overwrite the aura_env global, which is not allowed."] = "The aura tried to overwrite the aura_env global, which is not allowed."
L["The effective level differs from the level in e.g. Time Walking dungeons."] = ""
L["The Four Horsemen"] = ""
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = "'ID'BigWigs"
L["The Prophet Skeram"] = ""
L["The total quantity a warband character can transfer after paying the transfer cost"] = ""
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = ""
L["The War Within"] = ""
L["There are %i updates to your auras ready to be installed!"] = " %i "
L["Thick Outline"] = ""
L["Thickness"] = ""
L["Third"] = ""
L["Third Value of Tooltip Text"] = ""
L["This aura calls GetData a lot, which is a slow function."] = "GetData"
L["This aura has caused a Lua error."] = "Lua"
L["This aura is saving %s KB of data"] = "%s KB"
L["This aura plays a sound via a condition."] = ""
L["This aura plays a sound via an action."] = ""
L["This aura plays a Text To Speech via a condition."] = ""
L["This aura plays a Text To Speech via an action."] = ""
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = "WeakAuras Discord"
L["Threat Percent"] = ""
L["Threat Situation"] = ""
L["Threat Value"] = ""
L["Tick"] = ""
L["Time"] = ""
L["Time Format"] = ""
L["Time in GCDs"] = "GCD "
L["Time since initial application"] = ""
L["Time since last refresh"] = ""
L["Time since stack gain"] = ""
L["Time since stack lost"] = ""
L["Timed"] = ""
L["Timed Progress"] = ""
--[[Translation missing --]]
L["Timer"] = "Timer"
L["Timer Id"] = " ID"
L["Toggle"] = ""
L["Toggle List"] = ""
L["Toggle Options Window"] = ""
L["Toggle Performance Profiling Window"] = "/"
L["Tooltip"] = ""
L["Tooltip 1"] = "1"
L["Tooltip 2"] = "2"
L["Tooltip 3"] = "3"
L["Tooltip Value 1"] = " 1"
L["Tooltip Value 2"] = " 2"
L["Tooltip Value 3"] = " 3"
L["Tooltip Value 4"] = " 4"
L["Top"] = ""
L["Top Left"] = ""
L["Top Right"] = ""
L["Top to Bottom"] = ""
L["Torghast"] = ""
L["Total Duration"] = ""
L["Total Earned in this Season"] = ""
L["Total Essence"] = ""
L["Total Experience"] = ""
L["Total Match Count"] = ""
L["Total Reputation"] = ""
L["Total Stacks"] = ""
L["Total stacks over all matches"] = ""
L["Total Stages"] = ""
L["Total Unit Count"] = ""
L["Total Units"] = ""
L["Totem"] = ""
L["Totem #%i"] = " #%i"
L["Totem Icon"] = ""
L["Totem Name"] = ""
L["Totem Name Pattern Match"] = ""
L["Totem Number"] = ""
L["Track Cooldowns"] = ""
L["Tracking Charge %i"] = " %i"
L["Tracking Charge CDs"] = ""
L["Tracking Only Cooldown"] = ""
L["Transmission error"] = ""
L["Trigger"] = ""
L["Trigger %i"] = " %i"
L["Trigger %s"] = "%s"
L["Trigger 1"] = " 1"
L["Trigger State Updater (Advanced)"] = ""
L["Trigger Update"] = ""
L["Trigger:"] = ""
L["Trivial (Low Level)"] = ""
L["True"] = ""
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = "WeakAurasBug%s"
L["Twin Emperors"] = ""
L["Type"] = ""
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = "'%s'WeakAuras"
L["Unaffected"] = ""
L["Undefined"] = ""
L["Unholy"] = ""
L["Unholy Rune #1"] = " #1"
L["Unholy Rune #2"] = " #2"
L["Unit"] = ""
L["Unit Characteristics"] = ""
L["Unit Destroyed"] = ""
L["Unit Died"] = ""
L["Unit Dissipates"] = ""
L["Unit Frame"] = ""
L["Unit Frames"] = ""
L["Unit is Unit"] = ""
L["Unit Name"] = ""
L["Unit Name/Realm"] = "/"
L["Units Affected"] = ""
L["Units of affected Players in a table format"] = "table"
L["Units of unaffected Players in a table format"] = "table"
L["Unknown action %q"] = "%q"
L["Unknown feature %q"] = "%q"
L["unknown location"] = ""
L["Unlimited"] = ""
L["Untrigger %s"] = " %s"
L["Up"] = ""
L["Up, then Centered Horizontal"] = ""
L["Up, then Left"] = ""
L["Up, then Right"] = ""
L["Update Position"] = ""
L["Usage:"] = ""
L["Use /wa minimap to show the minimap icon again."] = " /wa minimap "
L["Use Custom Color"] = ""
L["Use Legacy floor rounding"] = ""
L["Use Texture"] = ""
L["Use Watched Faction"] = ""
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = "UnitInRange()2540"
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "WeakAuras.clonesWeakAuras.GetRegion(id, cloneId)"
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "WeakAuras.regionsWeakAuras.GetRegion(id)"
L["Vaelastrasz the Corrupt"] = ""
L["Versatility (%)"] = " (%)"
L["Versatility Rating"] = ""
L["Vertical"] = ""
L["Viscidus"] = ""
L["Visibility"] = ""
L["Visions of N'Zoth"] = ""
L["Warband Quantity Total"] = ""
L["Warband Transfer Percentage"] = ""
L["Warband Transferred Quantity"] = ""
L["Warfront (Heroic)"] = ""
L["Warfront (Normal)"] = ""
L["Warlords of Draenor"] = ""
L["Warning"] = ""
L["Warning for unknown aura:"] = ""
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = "%s"
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = " ID "
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = " %affected, %unaffected %unitCount "
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = " %tooltip1, %tooltip2, %tooltip3  %s "
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras 63:42 | 3:07 | 10 | 2.4"
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras  https://discord.gg/weakauras "
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras

|cffff0000|r
%s

|cffff0000WTF|r]=]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras "
L["WeakAuras Profiling"] = "WeakAuras"
L["WeakAuras Profiling Report"] = "WeakAuras"
L["WeakAuras Version: %s"] = "WeakAuras %s"
L["Weapon"] = ""
L["Weapon Enchant"] = ""
L["Weapon Enchant / Fishing Lure"] = " / "
L["Whisper"] = ""
L["Width"] = ""
L["Wobble"] = ""
L["World Boss"] = ""
L["World Bosses"] = ""
L["Wrap"] = ""
L["Wrath of the Lich King"] = ""
L["Writing to the WeakAuras table is not allowed."] = "WeakAuras"
L["X-Offset"] = "X "
L["Yell"] = ""
L["Y-Offset"] = "Y "
L["You have new auras ready to be installed!"] = ""
L["Your next encounter will automatically be profiled."] = ""
L["Your next instance of combat will automatically be profiled."] = ""
L["Your scheduled automatic profile has been cancelled."] = ""
L["Your threat as a percentage of the tank's current threat."] = ""
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = "100"
L["Your total threat on the mob."] = ""
L["Zone Group ID"] = "ID"
L["Zone ID"] = "ID"
L["Zone Name"] = ""
L["Zoom"] = ""
L["Zoom Animation"] = ""
L["Zul'Gurub"] = ""



-- ========================================
-- File: WeakAuras/Locales/zhTW.lua
-- ========================================

if (GAME_LOCALE or GetLocale()) ~= "zhTW" then
  return
end

local L = WeakAuras.L

-- WeakAuras
L[ [=[ Filter formats: 'Name', 'Name-Realm', '-Realm'. 

Supports multiple entries, separated by commas
Can use \ to escape -.]=] ] = [=[: '''-''-'


 -  \]=]
L["%s Overlay Color"] = "%s "
L["* Suffix"] = "* "
L["/wa help - Show this message"] = "/wa help - "
L["/wa minimap - Toggle the minimap icon"] = "/wa minimap - "
L["/wa pprint - Show the results from the most recent profiling"] = "/wa pprint - "
L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."] = [=[/wa pstart -  () / "combat"  "encounter" 
]=]
L["/wa pstop - Finish profiling"] = "/wa pstop - "
L["/wa repair - Repair tool"] = "/wa repair - "
L["|cffeda55fLeft-Click|r to toggle showing the main window."] = "|cffeda55f|r "
L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."] = "|cffeda55f|r "
L["|cffeda55fRight-Click|r to toggle performance profiling window."] = "|cffeda55f|r "
L["|cffeda55fShift-Click|r to pause addon execution."] = "|cffeda55fShift-|r "
L["|cffff0000deprecated|r"] = "|cffff0000|r"
L["|cFFFF0000Not|r Item Bonus Id Equipped"] = "|cFFFF0000|r ID"
L["|cFFFF0000Not|r Item Equipped"] = "|cFFFF0000|r"
L["|cFFFF0000Not|r Player Name/Realm"] = "|cFFFF0000|r/"
L["|cFFFF0000Not|r Spell Known"] = "|cFFFF0000|r"
L[ [=[|cFFFF0000Support for unfiltered COMBAT_LOG_EVENT_UNFILTERED is deprecated|r
COMBAT_LOG_EVENT_UNFILTERED without a filter are disabled as its very performance costly.
Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events]=] ] = "|cFFFF0000 COMBAT_LOG_EVENT_UNFILTERED|r  COMBAT_LOG_EVENT_UNFILTERED: https://github.com/WeakAuras/WeakAuras2/wiki/Custom-Triggers#events"
L["|cFFffcc00Extra Options:|r %s"] = "|cFFffcc00:|r %s"
L["|cFFffcc00Extra Options:|r None"] = "|cFFffcc00:|r "
L[ [=[ |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.
 |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.
|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.
 |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.
 |cffffff00Smart Group|r adjusts to your current group type, matching just the "player" when solo, "party" units (including "player") in a party or "raid" units in a raid.

|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura.]=] ] = " |cff00ff00|r|cff00ff00|r|cff00ff00|r|cff00ff00|r |cff00ff00|r|cffff0000|r |cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|r|cffffff00|r  |cffffff00|r |cffffff00*|r"
L["1. Profession 1. Accessory"] = "1. 1."
L["1. Profession 2. Accessory"] = "1. 2."
L["1. Professsion Tool"] = "1."
L["10 Man Raid"] = "10 "
L["10 Player Raid"] = "10"
L["10 Player Raid (Heroic)"] = "10  ()"
L["10 Player Raid (Normal)"] = "10  ()"
L["2. Profession 1. Accessory"] = "2. 1."
L["2. Profession 2. Accessory"] = "2. 2."
L["2. Professsion Tool"] = "2."
L["20 Man Raid"] = "20"
L["20 Player Raid"] = "20"
L["25 Man Raid"] = "25 "
L["25 Player Raid"] = "25"
L["25 Player Raid (Heroic)"] = "25  ()"
L["25 Player Raid (Normal)"] = "25  ()"
L["40 Man Raid"] = "40"
L["40 Player Raid"] = "40 "
L["5 Man Dungeon"] = "5 "
L[ [=[A detailed overview of your auras and WeakAuras systems
Copy the whole text to Weakaura's Discord if you need assistance.]=] ] = "WeakAuras WeakauraDiscord"
L["A trigger in this aura is set up to track a soft target unit, but you don't have the CVars set up for this to work correctly. Consider either changing the unit tracked, or configuring the Soft Target CVars."] = " CVars  CVars"
L["Abbreviate"] = ""
L["AbbreviateLargeNumbers (Blizzard)"] = " ()"
L["AbbreviateNumbers (Blizzard)"] = " ()"
L["Absorb"] = ""
L["Absorb and Healing"] = ""
L["Absorb Heal Overlay"] = ""
L["Absorb Overlay"] = ""
L["Absorbed"] = ""
L["Action Button Glow"] = ""
L["Actions"] = ""
L["Active"] = "/"
L[ [=[Active boss mod addon: |cFFffcc00BigWigs|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "|cFFffcc00BigWigs|r  BigWigs  DBM"
L[ [=[Active boss mod addon: |cFFffcc00DBM|r

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = "|cFFffcc00DBM|r  BigWigs  DBM"
L["Add"] = ""
L["Add Missing Auras"] = ""
L["Advanced Caster's Target Check"] = ""
L["Affected"] = ""
L["Affected Unit Count"] = ""
L["Afk"] = ""
L["Aggro"] = ""
L["Agility"] = ""
L["Ahn'Qiraj"] = ""
L["Alert Type"] = ""
L["Alive"] = ""
L["All"] = ""
L["All children of this aura will also not be loaded, to minimize the chance of further corruption."] = ""
L["All States table contains a non table at key: '%s'."] = " key : '%s'"
L["All Triggers"] = ""
L["Alliance"] = ""
L["Allow partial matches"] = ""
L["Alpha"] = ""
L["Alternate Power"] = ""
L["Always"] = ""
L["Always active trigger"] = ""
L["Always include realm"] = ""
L["Always True"] = " True"
L["Amount"] = ""
L["Anchoring"] = ""
L["And Talent"] = ""
L["Angle and Radius"] = ""
L["Animations"] = ""
L["Anticlockwise"] = ""
L["Anub'Rekhan"] = ""
L["Any"] = ""
L["Any Triggers"] = ""
L["AOE"] = " (AOE)"
L["Arcane Resistance"] = ""
L[ [=[Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?
This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s]=] ] = "|cffff0000|r%s"
L["Arena"] = ""
L["Armor (%)"] = " (%)"
L["Armor against Target (%)"] = " (%)"
L["Armor Rating"] = ""
L["Array"] = ""
L["Ascending"] = ""
L["Assigned Role"] = ""
L["Assigned Role Icon"] = ""
L["Assist"] = ""
L["Assisted Combat Next Cast"] = ""
L["At Least One Enemy"] = ""
L["At missing Value"] = ""
L["At Percent"] = ""
L["At Value"] = ""
L["At War"] = ""
L["Attach to End"] = ""
L["Attach to End, backwards"] = ""
L["Attach to Point"] = ""
L["Attach to Start"] = ""
L["Attack Power"] = ""
L["Attackable"] = ""
L["Attackable Target"] = ""
L["Aura"] = ""
L["Aura '%s': %s"] = " '%s': %s"
L["Aura Applied"] = ""
L["Aura Applied Dose"] = ""
L["Aura Broken"] = ""
L["Aura Broken Spell"] = ""
L["Aura is using deprecated SetDurationInfo"] = " SetDurationInfo"
L["Aura loaded"] = ""
L["Aura Name"] = ""
L["Aura Names"] = ""
L["Aura Refresh"] = ""
L["Aura Removed"] = ""
L["Aura Removed Dose"] = ""
L["Aura Stack"] = ""
L["Aura Type"] = ""
L["Aura Version: %s"] = ": %s"
L["Aura(s) Found"] = ""
L["Aura(s) Missing"] = ""
L["Aura:"] = ":"
L["Auras"] = ""
L["Auras:"] = ":"
L["Author Options"] = ""
L["Auto"] = ""
L["Autocast Shine"] = ""
L["Automatic"] = ""
L["Automatic Length"] = ""
L["Automatic Rotation"] = ""
L["Available features: %s"] = ": %s"
L["Avoidance (%)"] = " (%)"
L["Avoidance Rating"] = ""
L["Ayamiss the Hunter"] = ""
L["Azuregos"] = ""
L["Back and Forth"] = ""
L["Background"] = ""
L["Background Color"] = ""
L["Balnazzar"] = ""
L["Bar Color/Gradient Start"] = "/"
L["Bar enabled in BigWigs settings"] = "BigWigs "
L["Bar enabled in Boss Mod addon settings"] = ""
L["Bar enabled in DBM settings"] = "DBM "
L["Bar Texture"] = ""
L["Bar Type"] = ""
L["Baron Geddon"] = ""
L["Battle for Azeroth"] = ""
L["Battle.net Whisper"] = "Battle.net "
L["Battleground"] = ""
L["Battleguard Sartura"] = ""
L["Beastmaster"] = ""
--[[Translation missing --]]
L["Beatrix"] = "Beatrix"
L["BG>Raid>Party>Say"] = ">>>"
L["BG-System Alliance"] = ""
L["BG-System Horde"] = ""
L["BG-System Neutral"] = ""
L["Big Number"] = ""
L["BigWigs Addon"] = "BigWigs "
L["BigWigs Message"] = "BigWigs "
L["BigWigs Stage"] = "BigWigs "
L["BigWigs Timer"] = "BigWigs "
L["Black Wing Lair"] = ""
L["Bleed"] = ""
L["Blizzard Combat Text"] = ""
L["Blizzard Cooldown Reduction"] = ""
L["Block"] = ""
L["Block (%)"] = " (%)"
L["Block against Target (%)"] = " (%)"
L["Block Value"] = ""
L["Blocked"] = ""
L["Blood"] = ""
L["Blood Rune #1"] = " #1"
L["Blood Rune #2"] = " #2"
L["Bloodlord Mandokir"] = ""
L["Bonus Reputation Gain"] = ""
L["Border"] = ""
L["Boss"] = ""
L["Boss Emote"] = ""
L["Boss Mod Announce"] = ""
L["Boss Mod Stage"] = ""
L["Boss Mod Stage (Event)"] = "()"
L["Boss Mod Timer"] = ""
L["Boss Whisper"] = ""
L["Bottom"] = ""
L["Bottom Left"] = ""
L["Bottom Right"] = ""
L["Bottom to Top"] = ""
L["Bounce"] = ""
L["Bounce with Decay"] = ""
L["Break"] = ""
L["BreakUpLargeNumbers (Blizzard)"] = "BreakUpLargeNumbers ()"
L["Broodlord Lashlayer"] = ""
L["Buff"] = ""
L["Buff/Debuff"] = "/"
L["Buffed/Debuffed"] = "/"
L["Burning Crusade"] = ""
L["Buru the Gorger"] = ""
--[[Translation missing --]]
L["Caldoran"] = "Caldoran"
L["Callback function"] = ""
L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] = " \"boss1target\"  \"player\" "
L["Cancel"] = ""
L[ [=[Cannot change secure frame in combat lockdown. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."] = " bug  (: %i) %i "
L["Capped"] = ""
L["Capped at Season Max"] = ""
L["Capped at Weekly Max"] = ""
L["Cast"] = ""
L["Cast Bar"] = ""
L["Cast Failed"] = ""
L["Cast Start"] = ""
L["Cast Success"] = ""
L["Cast Type"] = ""
L["Caster"] = ""
L["Caster Name"] = ""
L["Caster Realm"] = ""
L["Caster Unit"] = ""
L["Casters Name/Realm"] = "/"
L["Caster's Target"] = ""
L["Cataclysm"] = ""
L["Ceil"] = ""
L["Center"] = ""
L["Center, then alternating bottom and top"] = ""
L["Center, then alternating left and right"] = ""
L["Center, then alternating right and left"] = ""
L["Center, then alternating top and bottom"] = ""
L["Centered Horizontal"] = ""
L["Centered Horizontal, then Centered Vertical"] = ""
L["Centered Horizontal, then Down"] = ""
L["Centered Horizontal, then Up"] = ""
L["Centered Vertical"] = ""
L["Centered Vertical, then Centered Horizontal"] = ""
L["Centered Vertical, then Left"] = ""
L["Centered Vertical, then Right"] = ""
L["Changed"] = ""
L["Channel"] = ""
L["Channel (Spell)"] = " ()"
L["Character GUID"] = "GUID"
L["Character Name"] = ""
L["Character Stats"] = ""
L["Character Transferred Quantity"] = ""
L["Character Type"] = ""
L["Charge gained/lost"] = "/"
L["Charged Combo Points"] = ""
L["Charges"] = ""
L["Charges Changed Event"] = ""
L["Charging"] = ""
L["Chat Frame"] = ""
L["Chat Message"] = ""
L["Check if a single talent match a Rank"] = ""
L["Check nameplate's target every 0.2s"] = "0.2"
L["Chromaggus"] = ""
L["Circle"] = ""
L["Circular Texture"] = ""
L["Clamp"] = ""
L["Class"] = ""
L["Class and Specialization"] = ""
L["Classic"] = ""
L["Classification"] = ""
L["Clockwise"] = ""
L["Clone per Character"] = ""
L["Clone per Event"] = ""
L["Clone per Match"] = ""
L["Coin Precision"] = ""
L["Color"] = ""
L["Color Animation"] = ""
L["Combat Log"] = ""
L["Communities"] = ""
L["Condition Custom Test"] = ""
L["Conditions"] = ""
L["Contains"] = ""
L["Continuously update Movement Speed"] = ""
L["Cooldown"] = ""
L["Cooldown bars show time before an ability is ready to be use, BigWigs prefix them with '~'"] = "BigWigs ~"
L["Cooldown Progress (Item)"] = " ()"
L["Cooldown Progress (Slot)"] = " ()"
L["Cooldown Ready Event"] = ""
L["Cooldown Ready Event (Item)"] = " ()"
L["Cooldown Ready Event (Slot)"] = " ()"
L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."] = ""
L["Cooldown/Charges/Count"] = "//"
L["Copper"] = ""
L["Could not load WeakAuras Archive, the addon is %s"] = "WeakAuras Archive %s"
L["Count"] = ""
L["Counter Clockwise"] = ""
L["Create"] = ""
L["Creature Family"] = ""
L["Creature Family Name"] = ""
L["Creature Type"] = ""
L["Creature Type Name"] = ""
L["Critical"] = ""
L["Critical (%)"] = " (%)"
L["Critical Rating"] = ""
L["Crop X"] = ""
L["Crop Y"] = ""
L["Crowd Controlled"] = ""
L["Crushing"] = ""
L["C'thun"] = ""
L["Cumulated time used during profiling"] = ""
L["Currency"] = ""
L["Current Essence"] = ""
L["Current Experience"] = ""
L["Current Instance"] = ""
L["Current Movement Speed (%)"] = " (%)"
L["Current Stage"] = ""
L["Current Zone"] = ""
L["Current Zone Group"] = ""
L["Curse"] = ""
L["Custom"] = ""
L["Custom Action"] = ""
L["Custom Anchor"] = ""
L["Custom Check"] = ""
L["Custom Color"] = ""
L["Custom Condition Code"] = ""
L["Custom Configuration"] = ""
L["Custom Fade Animation"] = ""
L["Custom Function"] = ""
L["Custom Grow"] = ""
L["Custom Sort"] = ""
L["Custom Text Function"] = ""
L["Custom Trigger Combination"] = ""
L["Custom Variables"] = ""
L["Damage"] = ""
L["Damage Shield"] = ""
L["Damage Shield Missed"] = ""
L["Damage Split"] = ""
L["DBM Announce"] = "BigWigs "
L["DBM Stage"] = "DBM "
L["DBM Timer"] = "DBM "
L["Dead"] = ""
L["Death"] = ""
L["Death Knight Rune"] = ""
L["Debuff"] = ""
L["Debuff Class"] = ""
L["Debuff Class Icon"] = ""
L["Debuff Type"] = ""
L["Debug Log contains more than 1000 entries"] = "1000"
L["Debug Logging enabled"] = ""
L["Debug Logging enabled for '%s'"] = "'%s'"
L["Defensive Stats"] = ""
L["Deflect"] = ""
L["Delve"] = ""
L["Desaturate"] = ""
L["Desaturate Background"] = ""
L["Desaturate Foreground"] = ""
L["Descending"] = ""
L["Description"] = ""
L["Dest Raid Mark"] = ""
L["Destination Affiliation"] = ""
L["Destination GUID"] = " GUID"
L["Destination Info"] = ""
L["Destination Name"] = ""
L["Destination NPC Id"] = " NPC ID"
L["Destination Object Type"] = ""
L["Destination Reaction"] = ""
L["Destination Unit"] = ""
L["Destination unit's raid mark index"] = ""
L["Destination unit's raid mark texture"] = ""
L["Difficulty"] = ""
L["Disable Spell Known Check"] = ""
L["Disabled"] = ""
L["Disabled feature %q"] = " %q"
L["Disabled Spell Known Check"] = ""
L["Discovered"] = ""
L["Disease"] = ""
L["Dispel"] = ""
L["Dispel Failed"] = ""
L["Display"] = ""
L["Distance"] = ""
L["Do Not Disturb"] = ""
L["Dodge"] = ""
L["Dodge (%)"] = " (%)"
L["Dodge Rating"] = ""
L["Down"] = ""
L["Down, then Centered Horizontal"] = ""
L["Down, then Left"] = ""
L["Down, then Right"] = ""
L["Dragonflight"] = ""
L["Drain"] = ""
L["Dropdown Menu"] = ""
L["Dumping table"] = ""
L["Dungeon (Celestial)"] = " ()"
L["Dungeon (Heroic)"] = " ()"
L["Dungeon (Mythic)"] = " ()"
L["Dungeon (Mythic+)"] = " (M+)"
L["Dungeon (Normal)"] = " ()"
L["Dungeon (Timewalking)"] = " ()"
L["Dungeons"] = ""
L["Durability Damage"] = ""
L["Durability Damage All"] = ""
L["Duration"] = ""
L["Duration Function"] = ""
L["Duration Function (fallback state)"] = " ()"
L["Ease In"] = ""
L["Ease In and Out"] = ""
L["Ease Out"] = ""
L["Ebonroc"] = ""
L["Eclipse Direction"] = ""
L["Edge"] = ""
L["Edge of Madness"] = ""
L["Effective Spell Id"] = " ID"
L["Elide"] = ""
L["Elite"] = ""
L["Emote"] = ""
L["Empower Cast End"] = ""
L["Empower Cast Interrupt"] = ""
L["Empower Cast Start"] = ""
L["Empowered"] = ""
L["Empowered 1"] = " 1"
L["Empowered 2"] = " 2"
L["Empowered 3"] = " 3"
L["Empowered 4"] = " 4"
L["Empowered 5"] = " 5"
L["Empowered Cast"] = ""
L["Empowered Cast Fully Charged"] = ""
L["Empowered Fully Charged"] = ""
L["Empty"] = ""
L["Enabled feature %q"] = " %q"
L["Enables (incorrect) round down of seconds, which was the previous default behavior."] = ""
L["Enchant Applied"] = ""
L["Enchant Found"] = ""
L["Enchant ID"] = "ID"
L["Enchant Missing"] = ""
L["Enchant Name or ID"] = " ID"
L["Enchant Removed"] = ""
L["Enchanted"] = ""
L["Encounter ID(s)"] = " ID"
L["Energize"] = ""
L["Enrage"] = ""
L["Enter a name or a spellId"] = "ID"
L["Entering"] = ""
L["Entering/Leaving Combat"] = "/"
L["Entering/Leaving Encounter"] = "/ "
L["Entry Order"] = ""
L["Environment Type"] = ""
L["Environmental"] = ""
L["Equipment"] = ""
L["Equipment Set"] = ""
L["Equipment Set Equipped"] = ""
L["Equipment Slot"] = ""
L["Equipped"] = ""
L["Error"] = ""
L[ [=[Error '%s' created a secure clone. We advise deleting the aura. For more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = " '%s' https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Error decoding."] = ""
L["Error decompressing"] = ""
L["Error decompressing. This doesn't look like a WeakAuras import."] = " WeakAuras "
L["Error deserializing"] = ""
L["Error Frame"] = ""
L["ERROR in '%s' unknown or incompatible sub element type '%s'"] = "'%s'  '%s'"
L["Error in Aura '%s'"] = "WA  '%s' "
L["Error not receiving display information from %s"] = " %s "
L["Essence"] = ""
L["Essence #1"] = " #1"
L["Essence #2"] = " #2"
L["Essence #3"] = " #3"
L["Essence #4"] = " #4"
L["Essence #5"] = " #5"
L["Essence #6"] = " #6"
L["Evade"] = ""
L["Event"] = ""
L["Event(s)"] = ""
L["Every Frame"] = ""
L["Every Frame (High CPU usage)"] = " ( CPU )"
L["Evoker Essence"] = ""
L["Exact Spell ID(s)"] = "ID"
L["Execute Conditions"] = ""
L["Experience (%)"] = " (%)"
L["Expertise Bonus"] = ""
L["Expertise Rating"] = ""
L["Extend Outside"] = ""
L["Extra Amount"] = ""
L["Extra Attacks"] = ""
L["Extra Spell Id"] = "ID"
L["Extra Spell Name"] = ""
L["Faction"] = ""
L["Faction Name"] = ""
L["Faction Reputation"] = ""
L["Fade Animation"] = ""
L["Fade In"] = ""
L["Fade Out"] = ""
L["Fail Alert"] = ""
L["False"] = " (False)"
L["Fankriss the Unyielding"] = ""
L["Feature %q is already disabled"] = " %q "
L["Feature %q is already enabled"] = " %q "
L["Fetch Absorb"] = ""
L["Fetch Heal Absorb"] = ""
L["Fetch Legendary Power"] = ""
L["Fetches the name and icon of the Legendary Power that matches this bonus id."] = " ID "
L["Fill Area"] = ""
L["Filter messages with format <message>"] = " <> "
L["Fire Resistance"] = ""
L["Firemaw"] = ""
L["First"] = ""
L["First Value of Tooltip Text"] = ""
L["Fixed"] = ""
L["Fixed Names"] = ""
L["Fixed Size"] = ""
L["Flamegor"] = ""
L["Flash"] = ""
L["Flex Raid"] = ""
L["Flip"] = ""
L["Floor"] = ""
L["Focus"] = ""
L["Follower Dungeon"] = ""
L["Font"] = ""
L["Font Size"] = ""
L["Forbidden function or table: %s"] = ": "
L["Foreground"] = ""
L["Foreground Color"] = ""
L["Form"] = ""
L["Format"] = ""
L["Format Gold"] = ""
L["Formats |cFFFFCC00%unit|r"] = " |cFFFFCC00%unit|r"
L["Formats Player's |cFFFFCC00%guid|r"] = " |cFFFFCC00%guid|r"
L["Forward"] = ""
L["Forward, Reverse Loop"] = ""
L["Fourth Value of Tooltip Text"] = ""
L["Frame Selector"] = ""
L["Frequency"] = ""
L["Friendly"] = ""
L["Friendly Fire"] = ""
L["Friendship Max Rank"] = ""
L["Friendship Rank"] = ""
L["Friendship Reputation"] = ""
L["Frost"] = ""
L["Frost Resistance"] = ""
L["Frost Rune #1"] = " #1"
L["Frost Rune #2"] = " #2"
L["Full"] = ""
L["Full Region"] = ""
L["Full/Empty"] = "/"
L["Gahz'ranka"] = ""
L["Gained"] = ""
L["Garr"] = ""
L["Gehennas"] = ""
L["General"] = ""
L["General Rajaxx"] = ""
L["GetNameAndIcon Function (fallback state)"] = "GetNameAndIcon  ("
L["Glancing"] = ""
L["Global Cooldown"] = " (GCD)"
L["Glow"] = ""
L["Glow External Element"] = ""
L["Gluth"] = ""
L["Glyph"] = ""
L["Gold"] = ""
L["Golemagg the Incinerator"] = ""
L["Gothik the Harvester"] = ""
L["Gradient"] = ""
L["Gradient Enabled"] = ""
L["Gradient End"] = ""
L["Gradient Orientation"] = ""
L["Gradient Pulse"] = ""
L["Grand Widow Faerlina"] = ""
L["Grid"] = ""
L["Grobbulus"] = ""
L["Group"] = ""
L["Group Arrangement"] = ""
L["Group Leader/Assist"] = "/"
L["Group Size"] = ""
L["Group Type"] = ""
L["Grow"] = ""
L["GTFO Alert"] = "GTFO "
L["Guardian"] = ""
L["Guild"] = ""
L["Hakkar"] = ""
L["Hardcore"] = ""
L["Has Target"] = ""
L["Has Vehicle UI"] = ""
L["HasPet"] = " ()"
L["Haste (%)"] = " (%)"
L["Haste Rating"] = ""
L["Heal"] = ""
L["Heal Absorb"] = ""
L["Heal Absorbed"] = ""
L["Health"] = ""
L["Health (%)"] = " (%)"
L["Health Deficit"] = ""
L["Heigan the Unclean"] = ""
L["Height"] = ""
L["Hero Talent"] = ""
L["Heroic Party"] = ""
L["Hide"] = ""
L["Hide 0 cooldowns"] = " 0 "
L["Hide Timer Text"] = ""
L["High Damage"] = ""
L["High Priest Thekal"] = ""
L["High Priest Venoxis"] = ""
L["High Priestess Arlokk"] = ""
L["High Priestess Jeklik"] = ""
L["High Priestess Mar'li"] = ""
L["Higher Than Tank"] = ""
L["Highest Spell Id"] = " ID"
L["Hit (%)"] = " (%)"
L["Hit Rating"] = ""
L["Holy Resistance"] = ""
L["Horde"] = ""
L["Horizontal"] = ""
L["Hostile"] = ""
L["Hostility"] = ""
L["Humanoid"] = ""
L["Hybrid"] = ""
L["Icon"] = ""
L["Icon Function"] = ""
L["Icon Function (fallback state)"] = " ()"
L["Id"] = "Id"
L["ID"] = "ID"
L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"] = " GitHub  Discord https://discord.gg/weakauras!"
L["Ignore Dead"] = ""
L["Ignore Disconnected"] = ""
L["Ignore Rune CD"] = ""
L["Ignore Rune CDs"] = ""
L["Ignore Self"] = ""
L["Ignore Spell Cooldown/Charges"] = "/"
L["Ignore Spell Override"] = ""
L["Immune"] = ""
L["Important"] = ""
L["Importing will start after combat ends."] = ""
L["In Combat"] = ""
L["In Encounter"] = ""
L["In Group"] = ""
L["In Party"] = ""
L["In Pet Battle"] = ""
L["In Raid"] = ""
L["In Range"] = ""
L["In Vehicle"] = ""
L["In War Mode"] = ""
L["Include Bank"] = ""
L["Include Charges"] = ""
L["Include Death Runes"] = ""
L["Include Pets"] = ""
L["Include War Band Bank"] = ""
L["Incoming Heal"] = ""
L["Increase Precision Below"] = ""
L["Increases by one per stage or intermission."] = ""
L["Information"] = ""
L["Inherited"] = ""
L["Instakill"] = ""
L["Install the addons BugSack and BugGrabber for detailed error logs."] = " BugSack  BugGrabber "
L["Instance"] = ""
L["Instance Difficulty"] = ""
L["Instance Id"] = " ID"
L["Instance ID"] = " ID"
L["Instance Info"] = ""
L["Instance Name"] = ""
L["Instance Size Type"] = ""
L["Instance Type"] = ""
L["Instructor Razuvious"] = ""
L["Insufficient Resources"] = ""
L["Intellect"] = ""
L["Interrupt"] = ""
L["Interrupt School"] = ""
L["Interrupted School Text"] = ""
L["Interruptible"] = ""
L["Inverse"] = ""
L["Inverse Pet Behavior"] = ""
L["Is Away from Keyboard"] = ""
L["Is Current Specialization"] = ""
L["Is Death Rune"] = ""
L["Is Exactly"] = ""
L["Is Moving"] = ""
L["Is Off Hand"] = ""
L["Is Paragon Reputation"] = ""
L["Is Paused"] = ""
L["is useable"] = ""
L["Is Weekly Renown Capped"] = ""
L["Island Expedition (Heroic)"] = " ()"
L["Island Expedition (Mythic)"] = " ()"
L["Island Expedition (Normal)"] = " ()"
L["Island Expeditions (PvP)"] = " (PvP)"
L["Item"] = ""
L["Item Bonus Id"] = " ID"
L["Item Bonus Id Equipped"] = " ID"
L["Item Count"] = ""
L["Item Equipped"] = ""
L["Item Id"] = " ID"
L["Item in Range"] = ""
L["Item Name"] = ""
L["Item Set Equipped"] = ""
L["Item Set Id"] = " ID"
L["Item Slot"] = ""
L["Item Slot String"] = ""
L["Item Type"] = ""
L["Item Type Equipped"] = ""
L["ItemId"] = ""
L["Jin'do the Hexxer"] = ""
L["Journal Stage"] = ""
L["Kazzak"] = ""
L["Keep Inside"] = ""
L["Kel'Thuzad"] = ""
L["Kurinnaxx"] = ""
L["Large"] = ""
L["Latency"] = ""
L["Leader"] = ""
L["Least remaining time"] = ""
L["Leaving"] = ""
L["Leech"] = ""
L["Leech (%)"] = " (%)"
L["Leech Rating"] = ""
L["Left"] = ""
L["Left to Right"] = ""
L["Left, then Centered Vertical"] = ""
L["Left, then Down"] = ""
L["Left, then Up"] = ""
L["Legacy Looking for Raid"] = ""
L["Legacy RGB Gradient"] = " RGB "
L["Legacy RGB Gradient Pulse"] = " RGB "
L["Legion"] = ""
L["Length"] = ""
L["Level"] = ""
L["LibSharedMedia"] = "LibSharedMedia"
L["Lillian Voss"] = ""
L["Limited"] = ""
L["Linear Texture"] = ""
L["Lines & Particles"] = " & "
L["Load Conditions"] = ""
L["Loatheb"] = ""
L["Location"] = ""
L["Looking for Raid"] = ""
L["Loop"] = ""
L["Loot"] = ""
L["Loot Specialization"] = ""
L["Loot Specialization Id"] = "ID"
L["Loot Specialization Name"] = ""
--[[Translation missing --]]
L["Lorewalking"] = "Lorewalking"
L["Lost"] = ""
L["Low Damage"] = ""
L["Lower Than Tank"] = ""
L["Lowest Spell Id"] = " ID"
L["Lua error"] = "Lua "
L["Lua error in Aura '%s': %s"] = "WA  '%s'  Lua : %s"
L["Lucifron"] = ""
L["Maexxna"] = ""
L["Magic"] = ""
L["Magmadar"] = ""
L["Main Character"] = ""
L["Main Stat"] = ""
L["Majordomo Executus"] = ""
L["Malformed WeakAuras link"] = " WeakAuras "
L["Manual"] = ""
L["Manual Icon"] = ""
L["Manual Rotation"] = ""
L["Marked First"] = ""
L["Marked Last"] = ""
--[[Translation missing --]]
L["Mason"] = "Mason"
L["Master"] = ""
L["Mastery (%)"] = " (%)"
L["Mastery Rating"] = ""
L["Match Count"] = ""
L["Match Count per Unit"] = ""
L["Matches (Pattern)"] = " (Pattern)"
L[ [=[Matches stage number of encounter journal.
Intermissions are .5
E.g. 1;2;1;2;2.5;3]=] ] = " 0.5 1;2;1;2;2.5;3"
L["Max Char "] = ""
L["Max Char"] = ""
L["Max Charges"] = ""
L["Max Health"] = ""
L["Max Power"] = ""
L["Max Quantity"] = ""
L["Maximum Estimate"] = ""
L["Maximum Progress"] = ""
L["Maximum time used on a single frame"] = ""
L["Media"] = ""
L["Medium"] = ""
L["Melee"] = ""
L["Melee Haste (%)"] = " (%)"
L["Message"] = ""
L["Message Type"] = ""
L["Message type:"] = ":"
L["Meta Data"] = "Meta Data"
L["Mine"] = ""
L["Minimum Estimate"] = ""
L["Minimum Progress"] = ""
L["Minus (Small Nameplate)"] = " (/)"
L["Mirror"] = ""
L["Miscellaneous"] = ""
L["Miss"] = ""
L["Miss Type"] = ""
L["Missed"] = ""
L["Missing"] = ""
L["Mists of Pandaria"] = ""
L["Moam"] = ""
L["Model"] = ""
L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"] = " (1h 3m | 3m 7s | 10s | 2.4)"
L["Modernize"] = ""
L["Molten Core"] = ""
L["Money"] = ""
L["Monochrome"] = ""
L["Monochrome Outline"] = ""
L["Monochrome Thick Outline"] = ""
L["Monster Emote"] = ""
L["Monster Party"] = ""
L["Monster Say"] = ""
L["Monster Whisper"] = ""
L["Monster Yell"] = ""
L["Moon"] = ""
L["Most remaining time"] = ""
L["Mounted"] = ""
L["Mouse Cursor"] = ""
L["Movement Speed Rating"] = ""
L["Multi-target"] = ""
L["Mythic Keystone"] = ""
L["Mythic+ Affix"] = "+ "
L["Name"] = ""
L["Name Function"] = ""
L["Name Function (fallback state)"] = " ()"
L["Name of Caster's Target"] = ""
L["Name of the (sub-)zone currently shown above the minimap."] = " () "
L["Name(s)"] = ""
L["Name/Realm of Caster's Target"] = "/"
L["Nameplate"] = "/"
L["Nameplates"] = "/"
L["Names of affected Players"] = ""
L["Names of unaffected Players"] = ""
L["Nature Resistance"] = ""
L["Naxxramas"] = ""
L["Nefarian"] = ""
L["Neutral"] = ""
L["Never"] = ""
L["Next Combat"] = ""
L["Next Encounter"] = ""
L[ [=[No active boss mod addon detected.

Note: This trigger will use BigWigs or DBM, in that order if both are installed.]=] ] = " BigWigs  DBM"
L["No Extend"] = ""
L["No Instance"] = ""
L["No Profiling information saved."] = ""
L["No Progress Information available."] = ""
L["None"] = ""
L["Non-player Character"] = " (NPC)"
L["Normal"] = ""
L["Normal Party"] = ""
L["Not in Group"] = ""
L["Not in Smart Group"] = ""
L["Not on Cooldown"] = ""
L["Not On Threat Table"] = ""
L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."] = ":  API"
L["Note: 'Hide Alone' is not available in the new aura tracking system. A load option can be used instead."] = ":  ''"
L["Note: The available text replacements for multi triggers match the normal triggers now."] = ": "
L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."] = ": "
L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."] = "WoWAPI"
L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"] = "3NPC|n|n|cFFAAFFAA|r%s|n|n|cFFAAFFAA|r%s|n|cFFAAAAFF|r%s"
L["Noth the Plaguebringer"] = ""
L["NPC"] = "NPC"
L["Npc ID"] = "NPC ID"
L["Number"] = ""
L["Number Affected"] = ""
L["Object"] = ""
L[ [=[Occurrence of the event
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Works only if Boss Mod addon show counter]=] ] = "2562,5,6 262-6 /2 22/3 2112-11/3"
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if BigWigs shows it on it's bar]=] ] = [=[



:
256: 2, 5, 6
26: 2-6
2: /2
23: 2/3
2113: 2-11/3

 BigWigs ]=]
L[ [=[Occurrence of the event, reset when aura is unloaded
Can be a range of values
Can have multiple values separated by a comma or a space

Examples:
2nd 5th and 6th events: 2, 5, 6
2nd to 6th: 2-6
every 2 events: /2
every 3 events starting from 2nd: 2/3
every 3 events starting from 2nd and ending at 11th: 2-11/3

Only if DBM shows it on it's bar]=] ] = [=[



:
256: 2, 5, 6
26: 2-6
2: /2
23: 2/3
2113: 2-11/3

 DBM ]=]
L["Officer"] = ""
L["Offset from progress"] = ""
L["Offset Timer"] = ""
L["Old Blizzard (2h | 3m | 10s | 2.4)"] = " (2h | 3m | 10s | 2.4)"
L["On Cooldown"] = ""
L["On Taxi"] = "/"
L["Only if on a different realm"] = ""
L["Only if Primary"] = ""
L["Onyxia"] = ""
L["Opaque"] = ""
L["Option Group"] = ""
L["Options could not be loaded, the addon is %s"] = " %s"
L["Options will finish loading after combat ends."] = ""
L["Options will open after the login process has completed."] = ""
L["Or Talent"] = ""
L["Orbit"] = ""
L["Orientation"] = ""
L["Ossirian the Unscarred"] = ""
L["Other"] = ""
L["Other Addons"] = ""
L["Other Events"] = ""
L["Ouro"] = ""
L["Outline"] = ""
L["Over Energize"] = ""
L["Overhealing"] = ""
L["Overkill"] = ""
L["Overlay %s"] = " %s"
L["Overlay Charged Combo Points"] = ""
L["Overlay Cost of Casts"] = ""
L["Overlay Latency"] = ""
L["Pad"] = ""
L["Pad Mode"] = ""
L["Pad to"] = ""
L["Paragon Reputation"] = ""
L["Paragon Reward Pending"] = ""
L["Parent Frame"] = ""
L["Parent Zone"] = ""
L["Parry"] = ""
L["Parry (%)"] = " (%)"
L["Parry Rating"] = ""
L["Party"] = ""
L["Party Kill"] = ""
L["Patchwerk"] = ""
L["Path of Ascension: Courage"] = ""
L["Path of Ascension: Humility"] = ""
L["Path of Ascension: Loyalty"] = ""
L["Path of Ascension: Wisdom"] = ""
L["Paused"] = ""
L["Periodic Spell"] = ""
L["Personal Resource Display"] = ""
L["Pet"] = ""
L["Pet Behavior"] = ""
L["Pet Specialization"] = ""
L["Pet Spell"] = ""
L["Pets only"] = ""
L["Phase"] = ""
L["Pixel Glow"] = ""
L["Placement"] = ""
L["Placement %i"] = " %i"
L["Placement Mode"] = ""
L["Play"] = ""
L["Player"] = ""
L["Player Character"] = ""
L["Player Class"] = ""
L["Player Effective Level"] = ""
L["Player Experience"] = ""
L["Player Faction"] = ""
L["Player Level"] = ""
L["Player Location ID(s)"] = " ID"
L["Player Money"] = ""
L["Player Name/Realm"] = "/"
L["Player Race"] = ""
L["Player(s) Affected"] = ""
L["Player(s) Not Affected"] = ""
L["Player/Unit Info"] = "/"
L["Players and Pets"] = ""
L["Poison"] = ""
L["Power"] = ""
L["Power (%)"] = " (%)"
L["Power Deficit"] = ""
L["Power Type"] = ""
L["Precision"] = ""
L["Preset"] = ""
L["Primary Stats"] = ""
L["Princess Huhuran"] = ""
L["Print Profiling Results"] = ""
L["Proc Glow"] = ""
L["Profiling already started."] = ""
L["Profiling automatically started."] = ""
L["Profiling not running."] = ""
L["Profiling started."] = ""
L["Profiling started. It will end automatically in %d seconds"] = " %d "
L["Profiling still running, stop before trying to print."] = ""
L["Profiling stopped."] = ""
L["Progress"] = ""
L["Progress Source"] = ""
L["Progress Total"] = ""
L["Progress Value"] = ""
L["Pull"] = ""
L["Pulse"] = ""
L["PvP Flagged"] = "PvP "
L["PvP Talent selected"] = " PvP "
L["PvP Talent Selected"] = " PvP "
L["Quality Id"] = "id"
L["Quantity"] = ""
L["Quantity earned this week"] = ""
L["Quest Party"] = ""
L["Queued Action"] = ""
L["Radius"] = ""
L["Ragnaros"] = ""
L["Raid"] = ""
L["Raid (Heroic)"] = " ()"
L["Raid (Mythic)"] = " ()"
L["Raid (Normal)"] = " ()"
L["Raid (Timewalking)"] = " ()"
L["Raid Mark"] = ""
L["Raid Mark Icon"] = ""
L["Raid Role"] = ""
L["Raid Warning"] = ""
L["Raids"] = ""
L["Range"] = ""
L["Range Check"] = ""
L["Ranged"] = ""
L["Rank"] = ""
L["Rare"] = ""
L["Rare Elite"] = ""
L["Rated Arena"] = ""
L["Rated Battleground"] = ""
L["Raw Threat Percent"] = ""
L["Razorgore the Untamed"] = ""
L["Ready Check"] = ""
L["Reagent Quality"] = ""
L["Reagent Quality Texture"] = ""
L["Realm"] = ""
L["Realm Name"] = ""
L["Realm of Caster's Target"] = ""
L["Reborn Council"] = ""
L["Receiving %s Bytes"] = " %s Bytes"
L["Receiving display information"] = ""
L["Reflect"] = ""
L["Region type %s not supported"] = " %s"
L["Relative"] = ""
L["Relative X-Offset"] = ""
L["Relative Y-Offset"] = ""
L["Remaining Duration"] = ""
L["Remaining Time"] = ""
L["Remove Obsolete Auras"] = ""
L["Renown Level"] = ""
L["Renown Max Level"] = ""
L["Renown Reputation"] = ""
L["Repair"] = ""
L["Repeat"] = ""
L["Report Summary"] = ""
L["Reputation"] = ""
L["Reputation (%)"] = " (%)"
L["Requested display does not exist"] = ""
L["Requested display not authorized"] = ""
L["Requesting display information from %s ..."] = " %s ..."
L["Require Valid Target"] = ""
L["Requires syncing the specialization via LibSpecialization."] = "LibSpecialization"
L["Resilience (%)"] = " (%)"
L["Resilience Rating"] = ""
L["Resist"] = ""
L["Resistances"] = ""
L["Resisted"] = ""
L["Rested"] = ""
L["Rested Experience"] = ""
L["Rested Experience (%)"] = " (%)"
L["Resting"] = ""
L["Resurrect"] = ""
L["Resurrect Pending"] = ""
L["Right"] = ""
L["Right to Left"] = ""
L["Right, then Centered Vertical"] = ""
L["Right, then Down"] = ""
L["Right, then Up"] = ""
L["Role"] = ""
L["Rollback snapshot is complete. Thank you for your patience!"] = "!"
L["Rotate Animation"] = ""
L["Rotate Left"] = ""
L["Rotate Right"] = ""
L["Rotation"] = ""
L["Round"] = ""
L["Round Mode"] = ""
L["Ruins of Ahn'Qiraj"] = ""
L["Run Custom Code"] = ""
L["Run Speed (%)"] = " (%)"
L["Rune"] = ""
L["Rune #1"] = " #1"
L["Rune #2"] = " #2"
L["Rune #3"] = " #3"
L["Rune #4"] = " #4"
L["Rune #5"] = " #5"
L["Rune #6"] = " #6"
L["Rune Count"] = ""
L["Rune Count - Blood"] = " - "
L["Rune Count - Frost"] = " - "
L["Rune Count - Unholy"] = " - "
L["Sapphiron"] = ""
L["Say"] = ""
L["Scale"] = ""
--[[Translation missing --]]
L["Scarlet Enclave"] = "Scarlet Enclave"
L["Scenario"] = ""
L["Scenario (Heroic)"] = " ()"
L["Scenario (Normal)"] = " ()"
L["Screen"] = ""
L["Screen/Parent Group"] = "/"
L["Season of Discovery"] = ""
L["Second"] = ""
L["Second Value of Tooltip Text"] = ""
L["Secondary Stats"] = ""
L["Seconds"] = ""
L[ [=[Secure frame detected. Find more information:
https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames]=] ] = "https://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"
L["Select Frame"] = ""
L["Select the type of timer to filter"] = ""
L["Selection Mode"] = ""
L["Separator"] = ""
L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"] = " ID  wowhead.com/cata/item-sets "
L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"] = " wowhead.com/classic/item-sets  Set ID"
L["Set IDs can be found on websites such as wowhead.com/item-sets"] = " ID wowhead.com/item-sets"
L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"] = " wowhead.com/mop-classic/item-sets  Set ID"
L["Shadow Resistance"] = ""
L["Shadowlands"] = ""
L["Shake"] = ""
L["Shazzrah"] = ""
L["Shift-Click to resume addon execution."] = "Shift- "
L["Show"] = ""
L["Show CD of Charge"] = ""
L["Show charged duration for empowered casts"] = ""
L["Show GCD"] = " (GCD)"
L["Show Global Cooldown"] = " (GCD)"
L["Show Incoming Heal"] = ""
L["Show Loss of Control"] = ""
L["Show On"] = ""
L["Show Rested Overlay"] = ""
L["Shrink"] = ""
L["Silithid Royalty"] = ""
L["Silver"] = ""
L["Simple"] = ""
L["Since Active"] = ""
L["Since Apply"] = ""
L["Since Apply/Refresh"] = "/"
L["Since Charge Gain"] = ""
L["Since Charge Lost"] = ""
L["Since Ready"] = ""
L["Since Stack Gain"] = ""
L["Since Stack Lost"] = ""
L["Size & Position"] = " & "
L["Skyriding"] = ""
L["Slide Animation"] = ""
L["Slide from Bottom"] = ""
L["Slide from Left"] = ""
L["Slide from Right"] = ""
L["Slide from Top"] = ""
L["Slide to Bottom"] = ""
L["Slide to Left"] = ""
L["Slide to Right"] = ""
L["Slide to Top"] = ""
L["Slider"] = ""
L["Small"] = ""
L["Smart Group"] = ""
L["Soft Enemy"] = ""
L["Soft Friend"] = ""
--[[Translation missing --]]
L["Solistrasza"] = "Solistrasza"
L["Sound"] = ""
L["Sound by Kit ID"] = " Sound Kit ID"
L["Source"] = ""
L["Source Affiliation"] = ""
L["Source GUID"] = " GUID"
L["Source Info"] = ""
L["Source Name"] = ""
L["Source NPC Id"] = " NPC ID"
L["Source Object Type"] = ""
L["Source Raid Mark"] = ""
L["Source Reaction"] = ""
L["Source Unit"] = ""
L["Source Unit Name/Realm"] = "/"
L["Source unit's raid mark index"] = ""
L["Source unit's raid mark texture"] = ""
L["Space"] = ""
L["Spacing"] = ""
L["Spark"] = ""
L["Spec Position"] = ""
L["Spec Role"] = ""
L["Specialization"] = ""
L["Specific Currency"] = ""
L["Specific Type"] = ""
L["Specific Unit"] = ""
L["Spell"] = ""
L["Spell (Building)"] = " ()"
L["Spell Activation Overlay Glow"] = ""
L["Spell Cast Succeeded"] = ""
L["Spell Cost"] = ""
L["Spell Count"] = ""
L["Spell ID"] = " ID"
L["Spell Id"] = " ID"
L["Spell ID:"] = " ID:"
L["Spell IDs:"] = " ID:"
L["Spell in Range"] = ""
L["Spell Known"] = ""
L["Spell Name"] = ""
L["Spell Peneration Percent"] = ""
L["Spell Power"] = ""
L["Spell School"] = ""
L["Spell Usable"] = ""
L["Spellname"] = ""
L["Spike"] = ""
L["Spin"] = ""
L["Spiral"] = ""
L["Spiral In And Out"] = ""
L["Spirit"] = ""
L["Stack Count"] = ""
L["Stack trace:"] = ":"
L["Stacks"] = ""
L["Stacks Function"] = ""
L["Stacks Function (fallback state)"] = " ()"
L["Stage"] = ""
L["Stage Counter"] = ""
L["Stagger"] = ""
L["Stagger (%)"] = " (%)"
L["Stagger against Target (%)"] = " (%)"
L["Stagger Scale"] = ""
L["Stamina"] = ""
L["Stance/Form/Aura"] = "//"
L["Standing"] = ""
L["Star Shake"] = ""
L["Start Animation"] = ""
L["Start Now"] = ""
L["Start Profiling"] = ""
L["Status"] = ""
L["Status Bar"] = ""
L["Stolen"] = ""
L["Stop"] = ""
L["Stop Motion"] = ""
L["Story Raid"] = ""
L["Strength"] = ""
L["String"] = ""
L["Subevent Info"] = ""
L["Subtract Cast"] = ""
L["Subtract Channel"] = ""
L["Subtract GCD"] = " GCD"
L["Subzone Name"] = ""
L["Success"] = ""
L["Sulfuron Harbinger"] = ""
L["Summon"] = ""
L["Summon Pending"] = ""
L["Sun"] = ""
L["Supports multiple entries, separated by commas"] = ""
L[ [=[Supports multiple entries, separated by commas
]=] ] = ""
L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."] = " \\  ',' '-' "
L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."] = " \\  '-' "
L["Supports multiple entries, separated by commas. Prefix with '-' for negation."] = " '-' "
L[ [=[Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.
Group Zone IDs must be prefixed with 'g', e.g. 'g277'. 
Supports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. 
Supports Instance IDs prefixed with 'i'.
Entries can be prefixed with '-' to negate.]=] ] = [=[ ID 'c'c2022
 ID  'g'  'g277'
 https://wago.tools/db2/AreaTable  'a'  ID
 'i'  ID
 '-' ]=]
L["Swing"] = ""
L["Swing Timer"] = ""
L["Swipe"] = ""
L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"] = " /wa feature <toggle|on|enable|disable|off> <>"
L["System"] = ""
L["Systems"] = ""
L["Tab "] = ""
L["Talent"] = ""
L["Talent |cFFFF0000Not|r Known"] = "|cFFFF0000|r"
L["Talent |cFFFF0000Not|r Selected"] = "|cFFFF0000|r"
L["Talent Known"] = ""
L["Talent Selected"] = ""
L["Talent selected"] = ""
L["Talent Specialization"] = ""
L["Tanking And Highest"] = ""
L["Tanking But Not Highest"] = ""
L["Target"] = ""
L["Targeted"] = ""
L["Tertiary Stats"] = ""
L["Test if bar is enabled in BigWigs settings"] = " BigWigs "
L["Test if bar is enabled in Boss Mod addon settings"] = ""
L["Test if bar is enabled in DBM settings"] = " DBM "
L["Text"] = ""
L["Text To Speech"] = ""
L["Text-to-speech"] = ""
L["Texture"] = ""
L["Texture Function"] = ""
L["Texture Function (fallback state)"] = " ()"
L["Texture Picker"] = ""
L["Texture Rotation"] = ""
L["Thaddius"] = ""
L["The aura has overwritten the global '%s', this might affect other auras."] = "  '%s'"
L["The aura tried to overwrite the aura_env global, which is not allowed."] = " aura_env "
L["The effective level differs from the level in e.g. Time Walking dungeons."] = " (: ) "
L["The Four Horsemen"] = ""
L["The 'ID' value can be found in the BigWigs options of a specific spell"] = " 'ID'  BigWigs "
L["The Prophet Skeram"] = ""
L["The total quantity a warband character can transfer after paying the transfer cost"] = ""
L["The total quantity after transferring everything to your current character and paying the transfer cost"] = ""
L["The War Within"] = ""
L["There are %i updates to your auras ready to be installed!"] = " %i !"
L["Thick Outline"] = ""
L["Thickness"] = ""
L["Third"] = ""
L["Third Value of Tooltip Text"] = ""
L["This aura calls GetData a lot, which is a slow function."] = " GetData"
L["This aura has caused a Lua error."] = " Lua "
L["This aura is saving %s KB of data"] = " %s KB "
L["This aura plays a sound via a condition."] = ""
L["This aura plays a sound via an action."] = ""
L["This aura plays a Text To Speech via a condition."] = ""
L["This aura plays a Text To Speech via an action."] = ""
L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."] = " WeakAuras Discord "
L["Threat Percent"] = ""
L["Threat Situation"] = ""
L["Threat Value"] = ""
L["Tick"] = ""
L["Time"] = ""
L["Time Format"] = ""
L["Time in GCDs"] = "GCD "
L["Time since initial application"] = ""
L["Time since last refresh"] = ""
L["Time since stack gain"] = ""
L["Time since stack lost"] = ""
L["Timed"] = ""
L["Timed Progress"] = ""
L["Timer"] = ""
L["Timer Id"] = " ID"
L["Toggle"] = ""
L["Toggle List"] = ""
L["Toggle Options Window"] = ""
L["Toggle Performance Profiling Window"] = ""
L["Tooltip"] = ""
L["Tooltip 1"] = " 1"
L["Tooltip 2"] = " 2"
L["Tooltip 3"] = " 3"
L["Tooltip Value 1"] = " 1"
L["Tooltip Value 2"] = " 2"
L["Tooltip Value 3"] = " 3"
L["Tooltip Value 4"] = " 4"
L["Top"] = ""
L["Top Left"] = ""
L["Top Right"] = ""
L["Top to Bottom"] = ""
L["Torghast"] = ""
L["Total Duration"] = ""
L["Total Earned in this Season"] = ""
L["Total Essence"] = ""
L["Total Experience"] = ""
L["Total Match Count"] = ""
L["Total Reputation"] = ""
L["Total Stacks"] = ""
L["Total stacks over all matches"] = ""
L["Total Stages"] = ""
L["Total Unit Count"] = ""
L["Total Units"] = ""
L["Totem"] = ""
L["Totem #%i"] = " #%i"
L["Totem Icon"] = ""
L["Totem Name"] = ""
L["Totem Name Pattern Match"] = ""
L["Totem Number"] = ""
L["Track Cooldowns"] = ""
L["Tracking Charge %i"] = " %i"
L["Tracking Charge CDs"] = ""
L["Tracking Only Cooldown"] = ""
L["Transmission error"] = ""
L["Trigger"] = ""
L["Trigger %i"] = " %i"
L["Trigger %s"] = " %s"
L["Trigger 1"] = " 1"
L["Trigger State Updater (Advanced)"] = " ()"
L["Trigger Update"] = ""
L["Trigger:"] = ":"
L["Trivial (Low Level)"] = " ()"
L["True"] = " (True)"
L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."] = " %s  WeakAuras  bug "
L["Twin Emperors"] = ""
L["Type"] = ""
L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."] = " %s WeakAuras "
L["Unaffected"] = ""
L["Undefined"] = ""
L["Unholy"] = ""
L["Unholy Rune #1"] = " #1"
L["Unholy Rune #2"] = " #2"
L["Unit"] = ""
L["Unit Characteristics"] = ""
L["Unit Destroyed"] = ""
L["Unit Died"] = ""
L["Unit Dissipates"] = ""
L["Unit Frame"] = ""
L["Unit Frames"] = ""
L["Unit is Unit"] = ""
L["Unit Name"] = ""
L["Unit Name/Realm"] = "/"
L["Units Affected"] = ""
L["Units of affected Players in a table format"] = " (table)"
L["Units of unaffected Players in a table format"] = " (table)"
L["Unknown action %q"] = " %q"
L["Unknown feature %q"] = " %q"
L["unknown location"] = ""
L["Unlimited"] = ""
L["Untrigger %s"] = " %s"
L["Up"] = ""
L["Up, then Centered Horizontal"] = ""
L["Up, then Left"] = ""
L["Up, then Right"] = ""
L["Update Position"] = ""
L["Usage:"] = ":"
L["Use /wa minimap to show the minimap icon again."] = " /wa minimap "
L["Use Custom Color"] = ""
L["Use Legacy floor rounding"] = ""
L["Use Texture"] = ""
L["Use Watched Faction"] = ""
L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."] = " UnitInRange()  25  40 "
L["Using WeakAuras.clones is deprecated. Use WeakAuras.GetRegion(id, cloneId) instead."] = "WeakAuras.clones  WeakAuras.GetRegion(id, cloneId)"
L["Using WeakAuras.regions is deprecated. Use WeakAuras.GetRegion(id) instead."] = "WeakAuras.regions  WeakAuras.GetRegion(id)"
L["Vaelastrasz the Corrupt"] = ""
L["Versatility (%)"] = " (%)"
L["Versatility Rating"] = ""
L["Vertical"] = ""
L["Viscidus"] = ""
L["Visibility"] = ""
L["Visions of N'Zoth"] = ""
L["Warband Quantity Total"] = ""
L["Warband Transfer Percentage"] = ""
L["Warband Transferred Quantity"] = ""
L["Warfront (Heroic)"] = " ()"
L["Warfront (Normal)"] = " ()"
L["Warlords of Draenor"] = ""
L["Warning"] = ""
L["Warning for unknown aura:"] = ":"
L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"] = ":  '%s' "
L["Warning: Full Scan auras checking for both name and spell id can't be converted."] = ":  ID"
L["Warning: Name info is now available via %affected, %unaffected. Number of affected group members via %unitCount. Some options behave differently now. This is not automatically adjusted."] = ":  %affected, %unaffected  %unitCount "
L["Warning: Tooltip values are now available via %tooltip1, %tooltip2, %tooltip3 instead of %s. This is not automatically adjusted."] = ":  %tooltip1, %tooltip2, %tooltip3  %s"
L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"] = "WeakAuras  (63:42 | 3:07 | 10 | 2.4)"
L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."] = "WeakAuras  https://discord.gg/weakauras "
L[ [=[WeakAuras has detected that it has been downgraded.
Your saved auras may no longer work properly.
Would you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.
Last upgrade: %s

|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r]=] ] = [=[WeakAuras 
|cffff0000|r? 
: %s 

|cffff0000 WTF |r]=]
L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."] = "WeakAuras "
L["WeakAuras Profiling"] = "WeakAuras "
L["WeakAuras Profiling Report"] = "WeakAuras "
L["WeakAuras Version: %s"] = "WeakAuras : %s"
L["Weapon"] = ""
L["Weapon Enchant"] = ""
L["Weapon Enchant / Fishing Lure"] = "/"
L["Whisper"] = ""
L["Width"] = ""
L["Wobble"] = ""
L["World Boss"] = ""
L["World Bosses"] = ""
L["Wrap"] = ""
L["Wrath of the Lich King"] = ""
L["Writing to the WeakAuras table is not allowed."] = " WeakAuras table"
L["X-Offset"] = ""
L["Yell"] = ""
L["Y-Offset"] = ""
L["You have new auras ready to be installed!"] = "!"
L["Your next encounter will automatically be profiled."] = ""
L["Your next instance of combat will automatically be profiled."] = ""
L["Your scheduled automatic profile has been cancelled."] = ""
L["Your threat as a percentage of the tank's current threat."] = ""
L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."] = " 100 "
L["Your total threat on the mob."] = ""
L["Zone Group ID"] = " ID"
L["Zone ID"] = " ID"
L["Zone Name"] = ""
L["Zoom"] = ""
L["Zoom Animation"] = ""
L["Zul'Gurub"] = ""



-- ========================================
-- File: WeakAuras/Modernize.lua
-- ========================================

if not WeakAuras.IsLibsOK() then
  return
end

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
local L = WeakAuras.L

-- Takes as input a table of display data and attempts to update it to be compatible with the current version
--- Modernizes the aura data
---@param data auraData
function Private.Modernize(data, oldSnapshot)
  if not data.internalVersion or data.internalVersion < 2 then
    WeakAuras.prettyPrint(string.format("Data for '%s' is too old, can't modernize.", data.id))
    data.internalVersion = 2
  end

  -- Version 3 was introduced April 2018 in Legion
  if data.internalVersion < 3 then
    if data.parent then
      local parentData = WeakAuras.GetData(data.parent)
      if parentData and parentData.regionType == "dynamicgroup" then
        -- Version 3 allowed for offsets for dynamic groups, before that they were ignored
        -- Thus reset them in the V2 to V3 upgrade
        data.xOffset = 0
        data.yOffset = 0
      end
    end
  end

  -- Version 4 was introduced July 2018 in BfA
  if data.internalVersion < 4 then
    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        if condition.check then
          local triggernum = condition.check.trigger
          if triggernum then
            local trigger
            if triggernum == 0 then
              trigger = data.trigger
            elseif data.additional_triggers and data.additional_triggers[triggernum] then
              trigger = data.additional_triggers[triggernum].trigger
            end
            if trigger and trigger.event == "Cooldown Progress (Spell)" then
              if condition.check.variable == "stacks" then
                condition.check.variable = "charges"
              end
            end
          end
        end
      end
    end
  end

  -- Version 5 was introduced July 2018 in BfA
  if data.internalVersion < 5 then
    -- this is to fix hybrid sorting
    if data.sortHybridTable then
      if data.controlledChildren then
        local newSortTable = {}
        for index, isHybrid in pairs(data.sortHybridTable) do
          local childID = data.controlledChildren[index]
          if childID then
            newSortTable[childID] = isHybrid
          end
        end
        data.sortHybridTable = newSortTable
      end
    end
  end

  -- Version 6 was introduced July 30 2018 in BfA
  if data.internalVersion < 6 then
    if data.triggers then
      for triggernum, triggerData in ipairs(data.triggers) do
        local trigger = triggerData.trigger
        if trigger and trigger.type == "aura" then
          if trigger.showOn == "showOnMissing" then
            trigger.buffShowOn = "showOnMissing"
          elseif trigger.showOn == "showActiveOrMissing" then
            trigger.buffShowOn = "showAlways"
          else
            trigger.buffShowOn = "showOnActive"
          end
          trigger.showOn = nil
        elseif trigger and trigger.type ~= "aura" then
          trigger.genericShowOn = trigger.showOn or "showOnActive"
          trigger.showOn = nil
          trigger.use_genericShowOn = trigger.use_showOn
        end
      end
    end
  end

  -- Version 7 was introduced September 1 2018 in BfA
  -- Triggers were cleaned up into a 1-indexed array
  if data.internalVersion < 7 then
    -- migrate trigger data
    data.triggers = data.additional_triggers or {}
    tinsert(data.triggers, 1, {
      trigger = data.trigger or {},
      untrigger = data.untrigger or {},
    })
    data.additional_triggers = nil
    data.trigger = nil
    data.untrigger = nil
    data.numTriggers = nil
    data.triggers.customTriggerLogic = data.customTriggerLogic
    data.customTriggerLogic = nil
    local activeTriggerMode = data.activeTriggerMode or Private.trigger_modes.first_active
    if activeTriggerMode ~= Private.trigger_modes.first_active then
      activeTriggerMode = activeTriggerMode + 1
    end
    data.triggers.activeTriggerMode = activeTriggerMode
    data.activeTriggerMode = nil
    data.triggers.disjunctive = data.disjunctive
    data.disjunctive = nil
    -- migrate condition trigger references
    local function recurseRepairChecks(checks)
      if not checks then
        return
      end
      for _, check in pairs(checks) do
        if check.trigger and check.trigger >= 0 then
          check.trigger = check.trigger + 1
        end
        recurseRepairChecks(check.checks)
      end
    end
    for _, condition in pairs(data.conditions) do
      if condition.check.trigger and condition.check.trigger >= 0 then
        condition.check.trigger = condition.check.trigger + 1
      end
      recurseRepairChecks(condition.check.checks)
    end
  end

  -- Version 8 was introduced in September 2018
  -- Changes are in PreAdd

  -- Version 9 was introduced in September 2018
  if data.internalVersion < 9 then
    local function repairCheck(check)
      if check and check.variable == "buffed" then
        local trigger = check.trigger and data.triggers[check.trigger] and data.triggers[check.trigger].trigger
        if trigger then
          if trigger.buffShowOn == "showOnActive" then
            check.variable = "show"
          elseif trigger.buffShowOn == "showOnMissing" then
            check.variable = "show"
            check.value = check.value == 0 and 1 or 0
          end
        end
      end
    end

    local function recurseRepairChecks(checks)
      if not checks then
        return
      end
      for _, check in pairs(checks) do
        repairCheck(check)
        recurseRepairChecks(check.checks)
      end
    end
    for _, condition in pairs(data.conditions) do
      repairCheck(condition.check)
      recurseRepairChecks(condition.check.checks)
    end
  end

  -- Version 10 is skipped, due to a bad migration script (see https://github.com/WeakAuras/WeakAuras2/pull/1091)

  -- Version 11 was introduced in January 2019
  if data.internalVersion < 11 then
    if data.url and data.url ~= "" then
      local slug, version = data.url:match("wago.io/([^/]+)/([0-9]+)")
      if not slug and not version then
        version = 1
      end
      if version and tonumber(version) then
        data.version = tonumber(version)
      end
    end
  end

  -- Version 12 was introduced February 2019 in BfA
  if data.internalVersion < 12 then
    if data.cooldownTextEnabled ~= nil then
      data.cooldownTextDisabled = not data.cooldownTextEnabled
      data.cooldownTextEnabled = nil
    end
  end

  -- Version 13 was introduced March 2019 in BfA
  if data.internalVersion < 13 then
    if data.regionType == "dynamicgroup" then
      local selfPoints = {
        default = "CENTER",
        RIGHT = function(data)
          if data.align == "LEFT" then
            return "TOPLEFT"
          elseif data.align == "RIGHT" then
            return "BOTTOMLEFT"
          else
            return "LEFT"
          end
        end,
        LEFT = function(data)
          if data.align == "LEFT" then
            return "TOPRIGHT"
          elseif data.align == "RIGHT" then
            return "BOTTOMRIGHT"
          else
            return "RIGHT"
          end
        end,
        UP = function(data)
          if data.align == "LEFT" then
            return "BOTTOMLEFT"
          elseif data.align == "RIGHT" then
            return "BOTTOMRIGHT"
          else
            return "BOTTOM"
          end
        end,
        DOWN = function(data)
          if data.align == "LEFT" then
            return "TOPLEFT"
          elseif data.align == "RIGHT" then
            return "TOPRIGHT"
          else
            return "TOP"
          end
        end,
        HORIZONTAL = function(data)
          if data.align == "LEFT" then
            return "TOP"
          elseif data.align == "RIGHT" then
            return "BOTTOM"
          else
            return "CENTER"
          end
        end,
        VERTICAL = function(data)
          if data.align == "LEFT" then
            return "LEFT"
          elseif data.align == "RIGHT" then
            return "RIGHT"
          else
            return "CENTER"
          end
        end,
        CIRCLE = "CENTER",
        COUNTERCIRCLE = "CENTER",
      }
      local selfPoint = selfPoints[data.grow or "DOWN"] or selfPoints.DOWN
      if type(selfPoint) == "function" then
        selfPoint = selfPoint(data)
      end
      data.selfPoint = selfPoint
    end
  end

  -- Version 14 was introduced March 2019 in BfA
  if data.internalVersion < 14 then
    if data.triggers then
      for triggerId, triggerData in pairs(data.triggers) do
        if
          type(triggerData) == "table"
          and triggerData.trigger
          and triggerData.trigger.debuffClass
          and type(triggerData.trigger.debuffClass) == "string"
          and triggerData.trigger.debuffClass ~= ""
        then
          local idx = triggerData.trigger.debuffClass
          data.triggers[triggerId].trigger.debuffClass = { [idx] = true }
        end
      end
    end
  end

  -- Version 15 was introduced April 2019 in BfA
  if data.internalVersion < 15 then
    if data.triggers then
      for triggerId, triggerData in ipairs(data.triggers) do
        if triggerData.trigger.type == "status" and triggerData.trigger.event == "Spell Known" then
          triggerData.trigger.use_exact_spellName = true
        end
      end
    end
  end

  -- Version 16 was introduced May 2019 in BfA
  if data.internalVersion < 16 then
    -- first conversion: attempt to migrate texture paths to file ids
    if data.regionType == "texture" and type(data.texture) == "string" then
      local textureId = GetFileIDFromPath(data.texture:gsub("\\\\", "\\"))
      if textureId and textureId > 0 then
        data.texture = tostring(textureId)
      end
    end
    if data.regionType == "progresstexture" then
      if type(data.foregroundTexture) == "string" then
        local textureId = GetFileIDFromPath(data.foregroundTexture:gsub("\\\\", "\\"))
        if textureId and textureId > 0 then
          data.foregroundTexture = tostring(textureId)
        end
      end
      if type(data.backgroundTexture) == "string" then
        local textureId = GetFileIDFromPath(data.backgroundTexture:gsub("\\\\", "\\"))
        if textureId and textureId > 0 then
          data.backgroundTexture = tostring(textureId)
        end
      end
    end
    -- second conversion: migrate name/realm conditions to tristate
    if data.load.use_name == false then
      data.load.use_name = nil
    end
    if data.load.use_realm == false then
      data.load.use_realm = nil
    end
  end

  -- Version 18 was a migration for stance/form trigger, but deleted later because of migration issue

  -- Version 19 were introduced in July 2019 in BfA
  if data.internalVersion < 19 then
    if data.triggers then
      for triggerId, triggerData in ipairs(data.triggers) do
        if triggerData.trigger.type == "status" and triggerData.trigger.event == "Cast" and triggerData.trigger.unit == "multi" then
          triggerData.trigger.unit = "nameplate"
        end
      end
    end
  end

  -- Version 20 was introduced July 2019 in BfA
  if data.internalVersion < 20 then
    if data.regionType == "icon" then
      local convertPoint = function(containment, point)
        if not point or point == "CENTER" then
          return "CENTER"
        elseif containment == "INSIDE" then
          return "INNER_" .. point
        elseif containment == "OUTSIDE" then
          return "OUTER_" .. point
        end
      end

      local text1 = {
        ["type"] = "subtext",
        text_visible = data.text1Enabled ~= false,
        text_color = data.text1Color,
        text_text = data.text1,
        text_font = data.text1Font,
        text_fontSize = data.text1FontSize,
        text_fontType = data.text1FontFlags,
        text_selfPoint = "AUTO",
        text_anchorPoint = convertPoint(data.text1Containment, data.text1Point),
        anchorXOffset = 0,
        anchorYOffset = 0,
        text_shadowColor = { 0, 0, 0, 1 },
        text_shadowXOffset = 0,
        text_shadowYOffset = 0,
      }

      local usetext2 = data.text2Enabled

      local text2 = {
        ["type"] = "subtext",
        text_visible = data.text2Enabled or false,
        text_color = data.text2Color,
        text_text = data.text2,
        text_font = data.text2Font,
        text_fontSize = data.text2FontSize,
        text_fontType = data.text2FontFlags,
        text_selfPoint = "AUTO",
        text_anchorPoint = convertPoint(data.text2Containment, data.text2Point),
        anchorXOffset = 0,
        anchorYOffset = 0,
        text_shadowColor = { 0, 0, 0, 1 },
        text_shadowXOffset = 0,
        text_shadowYOffset = 0,
      }

      data.text1Enabled = nil
      data.text1Color = nil
      data.text1 = nil
      data.text1Font = nil
      data.text1FontSize = nil
      data.text1FontFlags = nil
      data.text1Containment = nil
      data.text1Point = nil

      data.text2Enabled = nil
      data.text2Color = nil
      data.text2 = nil
      data.text2Font = nil
      data.text2FontSize = nil
      data.text2FontFlags = nil
      data.text2Containment = nil
      data.text2Point = nil

      local propertyRenames = {
        text1Color = "sub.1.text_color",
        text1FontSize = "sub.1.text_fontSize",
        text2Color = "sub.2.text_color",
        text2FontSize = "sub.2.text_fontSize",
      }

      data.subRegions = data.subRegions or {}
      tinsert(data.subRegions, text1)
      if usetext2 then
        tinsert(data.subRegions, text2)
      end

      if data.conditions then
        for conditionIndex, condition in ipairs(data.conditions) do
          for changeIndex, change in ipairs(condition.changes) do
            if propertyRenames[change.property] then
              change.property = propertyRenames[change.property]
            end
          end
        end
      end
    end
  end

  -- Version 20 was introduced May 2019 in BfA
  if data.internalVersion < 20 then
    if data.regionType == "aurabar" then
      local orientationToPostion = {
        HORIZONTAL_INVERSE = { "INNER_LEFT", "INNER_RIGHT" },
        HORIZONTAL = { "INNER_RIGHT", "INNER_LEFT" },
        VERTICAL_INVERSE = { "INNER_BOTTOM", "INNER_TOP" },
        VERTICAL = { "INNER_TOP", "INNER_BOTTOM" },
      }

      local positions = orientationToPostion[data.orientation] or { "INNER_LEFT", "INNER_RIGHT" }

      local text1 = {
        ["type"] = "subtext",
        text_visible = data.timer,
        text_color = data.timerColor,
        text_text = data.displayTextRight,
        text_font = data.timerFont,
        text_fontSize = data.timerSize,
        text_fontType = data.timerFlags,
        text_selfPoint = "AUTO",
        text_anchorPoint = positions[1],
        anchorXOffset = 0,
        anchorYOffset = 0,
        text_shadowColor = { 0, 0, 0, 1 },
        text_shadowXOffset = 1,
        text_shadowYOffset = -1,
        rotateText = data.rotateText,
      }

      local text2 = {
        ["type"] = "subtext",
        text_visible = data.text,
        text_color = data.textColor,
        text_text = data.displayTextLeft,
        text_font = data.textFont,
        text_fontSize = data.textSize,
        text_fontType = data.textFlags,
        text_selfPoint = "AUTO",
        text_anchorPoint = positions[2],
        anchorXOffset = 0,
        anchorYOffset = 0,
        text_shadowColor = { 0, 0, 0, 1 },
        text_shadowXOffset = 1,
        text_shadowYOffset = -1,
        rotateText = data.rotateText,
      }

      local text3 = {
        ["type"] = "subtext",
        text_visible = data.stacks,
        text_color = data.stacksColor,
        text_text = "%s",
        text_font = data.stacksFont,
        text_fontSize = data.stacksSize,
        text_fontType = data.stacksFlags,
        text_selfPoint = "AUTO",
        text_anchorPoint = "ICON_CENTER",
        anchorXOffset = 0,
        anchorYOffset = 0,
        text_shadowColor = { 0, 0, 0, 1 },
        text_shadowXOffset = 1,
        text_shadowYOffset = -1,
        rotateText = data.rotateText,
      }

      data.timer = nil
      data.textColor = nil
      data.displayTextRight = nil
      data.textFont = nil
      data.textSize = nil
      data.textFlags = nil
      data.text = nil
      data.timerColor = nil
      data.displayTextLeft = nil
      data.timerFont = nil
      data.timerSize = nil
      data.timerFlags = nil
      data.stacks = nil
      data.stacksColor = nil
      data.stacksFont = nil
      data.stacksSize = nil
      data.stacksFlags = nil
      data.rotateText = nil

      local propertyRenames = {
        timerColor = "sub.1.text_color",
        timerSize = "sub.1.text_fontSize",
        textColor = "sub.2.text_color",
        textSize = "sub.2.text_fontSize",
        stacksColor = "sub.3.text_color",
        stacksSize = "sub.3.text_fontSize",
      }

      data.subRegions = data.subRegions or {}
      tinsert(data.subRegions, text1)
      tinsert(data.subRegions, text2)
      tinsert(data.subRegions, text3)

      if data.conditions then
        for conditionIndex, condition in ipairs(data.conditions) do
          for changeIndex, change in ipairs(condition.changes) do
            if propertyRenames[change.property] then
              change.property = propertyRenames[change.property]
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 21 then
    if data.regionType == "dynamicgroup" then
      data.border = data.background and data.background ~= "None"
      data.borderEdge = data.border
      data.borderBackdrop = data.background ~= "None" and data.background
      data.borderInset = data.backgroundInset
      data.background = nil
      data.backgroundInset = nil
    end
  end

  if data.internalVersion < 22 then
    if data.regionType == "aurabar" then
      data.subRegions = data.subRegions or {}

      local border = {
        ["type"] = "subborder",
        border_visible = data.border,
        border_color = data.borderColor,
        border_edge = data.borderEdge,
        border_offset = data.borderOffset,
        border_size = data.borderSize,
        border_anchor = "bar",
      }

      data.border = nil
      data.borderColor = nil
      data.borderEdge = nil
      data.borderOffset = nil
      data.borderInset = nil
      data.borderSize = nil
      if data.borderInFront then
        tinsert(data.subRegions, border)
      else
        tinsert(data.subRegions, 1, border)
      end

      local propertyRenames = {
        borderColor = "sub." .. #data.subRegions .. ".border_color",
      }

      if data.conditions then
        for conditionIndex, condition in ipairs(data.conditions) do
          for changeIndex, change in ipairs(condition.changes) do
            if propertyRenames[change.property] then
              change.property = propertyRenames[change.property]
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 23 then
    if data.triggers then
      for triggerId, triggerData in ipairs(data.triggers) do
        local trigger = triggerData.trigger
        -- Stance/Form/Aura form field type changed from type="select" to type="multiselect"
        if trigger and trigger.type == "status" and trigger.event == "Stance/Form/Aura" then
          local value = trigger.form
          if type(value) ~= "table" then
            if trigger.use_form == false then
              if value then
                trigger.form = { multi = { [value] = true } }
              else
                trigger.form = { multi = {} }
              end
            elseif trigger.use_form then
              trigger.form = { single = value }
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 24 then
    if data.triggers then
      for triggerId, triggerData in ipairs(data.triggers) do
        local trigger = triggerData.trigger
        if trigger and trigger.type == "status" and trigger.event == "Weapon Enchant" then
          if trigger.use_inverse then
            trigger.showOn = "showOnMissing"
          else
            trigger.showOn = "showOnActive"
          end
          trigger.use_inverse = nil
          if not trigger.use_weapon then
            trigger.use_weapon = "true"
            trigger.weapon = "main"
          end
        end
      end
    end
  end

  if data.internalVersion < 25 then
    if data.regionType == "icon" then
      data.subRegions = data.subRegions or {}
      -- Need to check if glow is needed

      local prefix = "sub." .. #data.subRegions + 1 .. "."
      -- For Conditions
      local propertyRenames = {
        glow = prefix .. "glow",
        useGlowColor = prefix .. "useGlowColor",
        glowColor = prefix .. "glowColor",
        glowType = prefix .. "glowType",
        glowLines = prefix .. "glowLines",
        glowFrequency = prefix .. "glowFrequency",
        glowLength = prefix .. "glowLength",
        glowThickness = prefix .. "glowThickness",
        glowScale = prefix .. "glowScale",
        glowBorder = prefix .. "glowBorder",
        glowXOffset = prefix .. "glowXOffset",
        glowYOffset = prefix .. "glowYOffset",
      }

      local needsGlow = data.glow
      if not needsGlow and data.conditions then
        for conditionIndex, condition in ipairs(data.conditions) do
          for changeIndex, change in ipairs(condition.changes) do
            if propertyRenames[change.property] then
              needsGlow = true
              break
            end
          end
        end
      end

      if needsGlow then
        local glow = {
          ["type"] = "subglow",
          glow = data.glow,
          useGlowColor = data.useGlowColor,
          glowColor = data.glowColor,
          glowType = data.glowType,
          glowLines = data.glowLines,
          glowFrequency = data.glowFrequency,
          glowLength = data.glowLength,
          glowThickness = data.glowThickness,
          glowScale = data.glowScale,
          glowBorder = data.glowBorder,
          glowXOffset = data.glowXOffset,
          glowYOffset = data.glowYOffset,
        }
        tinsert(data.subRegions, glow)
      end

      data.glow = nil
      data.useglowColor = nil
      data.useGlowColor = nil
      data.glowColor = nil
      data.glowType = nil
      data.glowLines = nil
      data.glowFrequency = nil
      data.glowLength = nil
      data.glowThickness = nil
      data.glowScale = nil
      data.glowBorder = nil
      data.glowXOffset = nil
      data.glowYOffset = nil

      if data.conditions then
        for conditionIndex, condition in ipairs(data.conditions) do
          for changeIndex, change in ipairs(condition.changes) do
            if propertyRenames[change.property] then
              change.property = propertyRenames[change.property]
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 26 then
    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if change.property == "xOffset" or change.property == "yOffset" then
            change.value = (change.value or 0) - (data[change.property] or 0)
            change.property = change.property .. "Relative"
          end
        end
      end
    end
  end

  if data.internalVersion < 28 then
    if data.actions then
      if data.actions.start and data.actions.start.do_glow then
        data.actions.start.glow_frame_type = "FRAMESELECTOR"
      end
      if data.actions.finish and data.actions.finish.do_glow then
        data.actions.finish.glow_frame_type = "FRAMESELECTOR"
      end
    end
  end

  if data.internalVersion < 29 then
    if data.actions then
      if data.actions.start and data.actions.start.do_glow and data.actions.start.glow_type == nil then
        data.actions.start.glow_type = "buttonOverlay"
      end
      if data.actions.finish and data.actions.finish.do_glow and data.actions.finish.glow_type == nil then
        data.actions.finish.glow_type = "buttonOverlay"
      end
    end
  end

  if data.internalVersion < 30 then
    local convertLegacyPrecision = function(precision)
      if not precision then
        return 1
      end
      if precision < 4 then
        return precision, false
      else
        return precision - 3, true
      end
    end

    local progressPrecision = data.progressPrecision
    local totalPrecision = data.totalPrecision
    if data.regionType == "text" then
      local seenSymbols = {}
      Private.ParseTextStr(data.displayText, function(symbol)
        if not seenSymbols[symbol] then
          local triggerNum, sym = string.match(symbol, "(.+)%.(.+)")
          sym = sym or symbol
          if sym == "p" or sym == "t" then
            data["displayText_format_" .. symbol .. "_format"] = "timed"
            data["displayText_format_" .. symbol .. "_time_precision"], data["displayText_format_" .. symbol .. "_time_dynamic"] =
              convertLegacyPrecision(sym == "p" and progressPrecision or totalPrecision)
          end
        end
        seenSymbols[symbol] = symbol
      end)
    end

    if data.subRegions then
      for index, subRegionData in ipairs(data.subRegions) do
        if subRegionData.type == "subtext" then
          local seenSymbols = {}
          Private.ParseTextStr(subRegionData.text_text, function(symbol)
            if not seenSymbols[symbol] then
              local triggerNum, sym = string.match(symbol, "(.+)%.(.+)")
              sym = sym or symbol
              if sym == "p" or sym == "t" then
                subRegionData["text_text_format_" .. symbol .. "_format"] = "timed"
                subRegionData["text_text_format_" .. symbol .. "_time_precision"], subRegionData["text_text_format_" .. symbol .. "_time_dynamic"] =
                  convertLegacyPrecision(sym == "p" and progressPrecision or totalPrecision)
              end
            end
            seenSymbols[symbol] = symbol
          end)
        end
      end
    end

    if data.actions then
      for _, when in ipairs({ "start", "finish" }) do
        if data.actions[when] then
          local seenSymbols = {}
          Private.ParseTextStr(data.actions[when].message, function(symbol)
            if not seenSymbols[symbol] then
              local triggerNum, sym = string.match(symbol, "(.+)%.(.+)")
              sym = sym or symbol
              if sym == "p" or sym == "t" then
                data.actions[when]["message_format_" .. symbol .. "_format"] = "timed"
                data.actions[when]["message_format_" .. symbol .. "_time_precision"], data.actions[when]["message_format_" .. symbol .. "_time_dynamic"] =
                  convertLegacyPrecision(sym == "p" and progressPrecision or totalPrecision)
              end
            end
            seenSymbols[symbol] = symbol
          end)
        end
      end
    end

    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if change.property == "chat" and change.value then
            local seenSymbols = {}
            Private.ParseTextStr(change.value.message, function(symbol)
              if not seenSymbols[symbol] then
                local triggerNum, sym = string.match(symbol, "(.+)%.(.+)")
                sym = sym or symbol
                if sym == "p" or sym == "t" then
                  change.value["message_format_" .. symbol .. "_format"] = "timed"
                  change.value["message_format_" .. symbol .. "_time_precision"], change.value["message_format_" .. symbol .. "_time_dynamic"] =
                    convertLegacyPrecision(sym == "p" and progressPrecision or totalPrecision)
                end
              end
              seenSymbols[symbol] = symbol
            end)
          end
        end
      end
    end

    data.progressPrecision = nil
    data.totalPrecision = nil
  end

  -- Introduced in June 2020 in BfA
  if data.internalVersion < 31 then
    local allowedNames
    local ignoredNames
    if data.load.use_name == true and data.load.name then
      allowedNames = data.load.name
    elseif data.load.use_name == false and data.load.name then
      ignoredNames = data.load.name
    end

    if data.load.use_realm == true and data.load.realm then
      allowedNames = (allowedNames or "") .. "-" .. data.load.realm
    elseif data.load.use_realm == false and data.load.realm then
      ignoredNames = (ignoredNames or "") .. "-" .. data.load.realm
    end

    if allowedNames then
      data.load.use_namerealm = true
      data.load.namerealm = allowedNames
    end

    if ignoredNames then
      data.load.use_namerealmblack = true
      data.load.namerealmblack = ignoredNames
    end

    data.load.use_name = nil
    data.load.name = nil
    data.load.use_realm = nil
    data.load.realm = nil
  end

  -- Introduced in June 2020 in BfA
  if data.internalVersion < 32 then
    local replacements = {}
    local function repairCheck(replacements, check)
      if check and check.trigger then
        if replacements[check.trigger] then
          if replacements[check.trigger][check.variable] then
            check.variable = replacements[check.trigger][check.variable]
          end
        end
      end
    end

    if data.triggers then
      for triggerId, triggerData in ipairs(data.triggers) do
        if triggerData.trigger.type == "status" then
          local event = triggerData.trigger.event
          if event == "Unit Characteristics" or event == "Health" or event == "Power" then
            replacements[triggerId] = {}
            replacements[triggerId]["use_name"] = "use_namerealm"
            replacements[triggerId]["name"] = "namerealm"
          elseif event == "Alternate Power" then
            replacements[triggerId] = {}
            replacements[triggerId]["use_unitname"] = "use_namerealm"
            replacements[triggerId]["unitname"] = "namerealm"
          elseif event == "Cast" then
            replacements[triggerId] = {}
            replacements[triggerId]["use_sourceName"] = "use_sourceNameRealm"
            replacements[triggerId]["sourceName"] = "sourceNameRealm"
            replacements[triggerId]["use_destName"] = "use_destNameRealm"
            replacements[triggerId]["destName"] = "destNameRealm"
          end

          if replacements[triggerId] then
            for old, new in pairs(replacements[triggerId]) do
              triggerData.trigger[new] = triggerData.trigger[old]
              triggerData.trigger[old] = nil
            end

            local function recurseRepairChecks(replacements, checks)
              if not checks then
                return
              end
              for _, check in pairs(checks) do
                repairCheck(replacements, check)
                recurseRepairChecks(replacements, check.checks)
              end
            end
            for _, condition in pairs(data.conditions) do
              repairCheck(replacements, condition.check)
              recurseRepairChecks(replacements, condition.check.checks)
            end
          end
        end
      end
    end
  end

  -- Introduced in July 2020 in BfA
  if data.internalVersion < 33 then
    data.load.use_ignoreNameRealm = data.load.use_namerealmblack
    data.load.ignoreNameRealm = data.load.namerealmblack
    data.load.use_namerealmblack = nil
    data.load.namerealmblack = nil

    -- trigger.useBlackExactSpellId and trigger.blackauraspellids
    if data.triggers then
      for triggerId, triggerData in ipairs(data.triggers) do
        triggerData.trigger.useIgnoreName = triggerData.trigger.useBlackName
        triggerData.trigger.ignoreAuraNames = triggerData.trigger.blackauranames
        triggerData.trigger.useIgnoreExactSpellId = triggerData.trigger.useBlackExactSpellId
        triggerData.trigger.ignoreAuraSpellids = triggerData.trigger.blackauraspellids

        triggerData.trigger.useBlackName = nil
        triggerData.trigger.blackauranames = nil
        triggerData.trigger.useBlackExactSpellId = nil
        triggerData.trigger.blackauraspellids = nil
      end
    end
  end

  -- Introduced in July 2020 in Shadowlands
  if data.internalVersion < 34 then
    if data.regionType == "dynamicgroup" and (data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE") then
      if data.arcLength == 360 then
        data.fullCircle = true
      else
        data.fullCircle = false
      end
    end
  end

  if data.internalVersion < 35 then
    if data.regionType == "texture" then
      data.textureWrapMode = "CLAMP"
    end
  end

  if data.internalVersion < 36 then
    data.ignoreOptionsEventErrors = true
  end

  if data.internalVersion < 37 then
    for triggerId, triggerData in ipairs(data.triggers) do
      if triggerData.trigger.type == "aura2" then
        local group_role = triggerData.trigger.group_role
        if group_role then
          triggerData.trigger.group_role = {}
          triggerData.trigger.group_role[group_role] = true
        end
      end
    end
  end

  if data.internalVersion < 38 then
    for triggerId, triggerData in ipairs(data.triggers) do
      if triggerData.trigger.type == "status" then
        if triggerData.trigger.event == "Item Type Equipped" then
          if triggerData.trigger.itemTypeName then
            if triggerData.trigger.itemTypeName.single then
              triggerData.trigger.itemTypeName.single = triggerData.trigger.itemTypeName.single + 2 * 256
            end
            if triggerData.trigger.itemTypeName.multi then
              local converted = {}
              for v in pairs(triggerData.trigger.itemTypeName.multi) do
                converted[v + 512] = true
              end
              triggerData.trigger.itemTypeName.multi = converted
            end
          end
        end
      end
    end
    if data.load.itemtypeequipped then
      if data.load.itemtypeequipped.single then
        data.load.itemtypeequipped.single = data.load.itemtypeequipped.single + 2 * 256
      end
      if data.load.itemtypeequipped.multi then
        local converted = {}
        for v in pairs(data.load.itemtypeequipped.multi) do
          converted[v + 512] = true
        end
        data.load.itemtypeequipped.multi = converted
      end
    end
  end

  if data.internalVersion < 39 then
    if data.regionType == "icon" or data.regionType == "aurabar" then
      if data.auto then
        data.iconSource = -1
      else
        data.iconSource = 0
      end
    end
  end

  if data.internalVersion < 40 then
    data.information = data.information or {}
    if data.regionType == "group" then
      data.information.groupOffset = true
    end
    data.information.ignoreOptionsEventErrors = data.ignoreOptionsEventErrors
    data.ignoreOptionsEventErrors = nil
  end

  if data.internalVersion < 41 then
    local newTypes = {
      ["Cooldown Ready (Spell)"] = "spell",
      ["Queued Action"] = "spell",
      ["Charges Changed"] = "spell",
      ["Action Usable"] = "spell",
      ["Chat Message"] = "event",
      ["Unit Characteristics"] = "unit",
      ["Cooldown Progress (Spell)"] = "spell",
      ["Power"] = "unit",
      ["PvP Talent Selected"] = "unit",
      ["Combat Log"] = "combatlog",
      ["Item Set"] = "item",
      ["Health"] = "unit",
      ["Cooldown Progress (Item)"] = "item",
      ["Conditions"] = "unit",
      ["Spell Known"] = "spell",
      ["Cooldown Ready (Item)"] = "item",
      ["Faction Reputation"] = "unit",
      ["Pet Behavior"] = "unit",
      ["Range Check"] = "unit",
      ["Character Stats"] = "unit",
      ["Talent Known"] = "unit",
      ["Threat Situation"] = "unit",
      ["Equipment Set"] = "item",
      ["Death Knight Rune"] = "unit",
      ["Cast"] = "unit",
      ["Item Count"] = "item",
      ["BigWigs Timer"] = "addons",
      ["Spell Activation Overlay"] = "spell",
      ["DBM Timer"] = "addons",
      ["Item Type Equipped"] = "item",
      ["Alternate Power"] = "unit",
      ["Item Equipped"] = "item",
      ["Item Bonus Id Equipped"] = "item",
      ["DBM Announce"] = "addons",
      ["Swing Timer"] = "unit",
      ["Totem"] = "spell",
      ["Ready Check"] = "event",
      ["BigWigs Message"] = "addons",
      ["Class/Spec"] = "unit",
      ["Stance/Form/Aura"] = "unit",
      ["Weapon Enchant"] = "item",
      ["Global Cooldown"] = "spell",
      ["Experience"] = "unit",
      ["GTFO"] = "addons",
      ["Cooldown Ready (Equipment Slot)"] = "item",
      ["Crowd Controlled"] = "unit",
      ["Cooldown Progress (Equipment Slot)"] = "item",
      ["Combat Events"] = "event",
    }

    for triggerId, triggerData in ipairs(data.triggers) do
      if triggerData.trigger.type == "status" or triggerData.trigger.type == "event" then
        local newType = newTypes[triggerData.trigger.event]
        if newType then
          triggerData.trigger.type = newType
        else
          WeakAuras.prettyPrint("Unknown trigger type found in, please report: ", data.id, triggerData.trigger.event)
        end
      end
    end
  end

  if data.internalVersion < 43 then
    -- The merging of zone ids and group ids went a bit wrong,
    -- fortunately that was caught before a actual release
    -- still try to recover the data
    if data.internalVersion == 42 then
      if data.load.zoneIds then
        local newstring = ""
        local first = true
        for id in data.load.zoneIds:gmatch("%d+") do
          if not first then
            newstring = newstring .. ", "
          end

          -- If the id is potentially a group, assume it is a group
          if C_Map.GetMapGroupMembersInfo(tonumber(id)) then
            newstring = newstring .. "g" .. id
          else
            newstring = newstring .. id
          end
          first = false
        end
        data.load.zoneIds = newstring
      end
    else
      if data.load.use_zoneId == data.load.use_zonegroupId then
        data.load.use_zoneIds = data.load.use_zoneId

        local zoneIds = strtrim(data.load.zoneId or "")
        local zoneGroupIds = strtrim(data.load.zonegroupId or "")

        zoneGroupIds = zoneGroupIds:gsub("(%d+)", "g%1")

        if zoneIds ~= "" or zoneGroupIds ~= "" then
          data.load.zoneIds = zoneIds .. ", " .. zoneGroupIds
        else
          -- One of them is empty
          data.load.zoneIds = zoneIds .. zoneGroupIds
        end
      elseif data.load.use_zoneId then
        data.load.use_zoneIds = true
        data.load.zoneIds = data.load.zoneId
      elseif data.load.use_zonegroupId then
        data.load.use_zoneIds = true
        local zoneGroupIds = strtrim(data.load.zonegroupId or "")
        zoneGroupIds = zoneGroupIds:gsub("(%d+)", "g%1")
        data.load.zoneIds = zoneGroupIds
      end
      data.load.use_zoneId = nil
      data.load.use_zonegroupId = nil
      data.load.zoneId = nil
      data.load.zonegroupId = nil
    end
  end

  if data.internalVersion < 44 then
    local function fixUp(data, prefix)
      local pattern = prefix .. "(.*)_format"

      local found = false
      for property in pairs(data) do
        local symbol = property:match(pattern)
        if symbol then
          found = true
          break
        end
      end

      if not found then
        return
      end

      local old = CopyTable(data)
      for property in pairs(old) do
        local symbol = property:match(pattern)
        if symbol then
          if data[property] == "timed" then
            data[prefix .. symbol .. "_time_format"] = 0

            local oldDynamic = data[prefix .. symbol .. "_time_dynamic"]
            data[prefix .. symbol .. "_time_dynamic_threshold"] = oldDynamic and 3 or 60
          end
          data[prefix .. symbol .. "_time_dynamic"] = nil
          if data[prefix .. symbol .. "_time_precision"] == 0 then
            data[prefix .. symbol .. "_time_precision"] = 1
            data[prefix .. symbol .. "_time_dynamic_threshold"] = 0
          end
        end
      end
    end

    if data.regionType == "text" then
      fixUp(data, "displayText_format_")
    end

    if data.subRegions then
      for index, subRegionData in ipairs(data.subRegions) do
        if subRegionData.type == "subtext" then
          fixUp(subRegionData, "text_text_format_")
        end
      end
    end

    if data.actions then
      for _, when in ipairs({ "start", "finish" }) do
        if data.actions[when] then
          fixUp(data.actions[when], "message_format_")
        end
      end
    end

    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if change.property == "chat" and change.value then
            fixUp(change.value, "message_format_")
          end
        end
      end
    end
  end

  if data.internalVersion < 45 then
    for triggerId, triggerData in ipairs(data.triggers) do
      local trigger = triggerData.trigger
      if trigger.type == "unit" and trigger.event == "Conditions" then
        if trigger.use_instance_size then
          -- Single Selection
          if trigger.instance_size.single then
            if trigger.instance_size.single == "arena" then
              trigger.use_instance_size = false
              trigger.instance_size.multi = {
                arena = true,
                ratedarena = true,
              }
            elseif trigger.instance_size.single == "pvp" then
              trigger.use_instance_size = false
              trigger.instance_size.multi = {
                pvp = true,
                ratedpvp = true,
              }
            end
          end
        elseif trigger.use_instance_size == false then
          -- Multi selection
          if trigger.instance_size.multi then
            if trigger.instance_size.multi.arena then
              trigger.instance_size.multi.ratedarena = true
            end
            if trigger.instance_size.multi.pvp then
              trigger.instance_size.multi.ratedpvp = true
            end
          end
        end
      end
    end

    if data.load.use_size == true then
      if data.load.size.single == "arena" then
        data.load.use_size = false
        data.load.size.multi = {
          arena = true,
          ratedarena = true,
        }
      elseif data.load.size.single == "pvp" then
        data.load.use_size = false
        data.load.size.multi = {
          pvp = true,
          ratedpvp = true,
        }
      end
    elseif data.load.use_size == false then
      if data.load.size.multi then
        if data.load.size.multi.arena then
          data.load.size.multi.ratedarena = true
        end
        if data.load.size.multi.pvp then
          data.load.size.multi.ratedpvp = true
        end
      end
    end
  end

  if data.internalVersion < 46 then
    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        if condition.check then
          local triggernum = condition.check.trigger
          if triggernum then
            local trigger = data.triggers[triggernum]
            if trigger and trigger.trigger and trigger.trigger.event == "Power" then
              if condition.check.variable == "chargedComboPoint" then
                condition.check.variable = "chargedComboPoint1"
              end
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 49 then
    if not data.regionType:match("group") then
      data.subRegions = data.subRegions or {}
      -- rename aurabar_bar into subforeground, and subbarmodel into submodel
      for index, subRegionData in ipairs(data.subRegions) do
        if subRegionData.type == "aurabar_bar" then
          subRegionData.type = "subforeground"
        elseif subRegionData.type == "subbarmodel" then
          subRegionData.type = "submodel"
        end
        if subRegionData.bar_model_visible ~= nil then
          subRegionData.model_visible = subRegionData.bar_model_visible
          subRegionData.bar_model_visible = nil
        end
        if subRegionData.bar_model_alpha ~= nil then
          subRegionData.model_alpha = subRegionData.bar_model_alpha
          subRegionData.bar_model_alpha = nil
        end
      end
      -- rename conditions for bar_model_visible and bar_model_alpha
      if data.conditions then
        for conditionIndex, condition in ipairs(data.conditions) do
          if type(condition.changes) == "table" then
            for changeIndex, change in ipairs(condition.changes) do
              if change.property then
                local prefix, property = change.property:match("(sub%.%d+%.)(.*)")
                if prefix and property then
                  if property == "bar_model_visible" then
                    change.property = prefix .. "model_visible"
                  elseif property == "bar_model_alpha" then
                    change.property = prefix .. "model_alpha"
                  end
                end
              end
            end
          end
        end
      end
    end
  end

  if data.internalVersion == 49 then
    -- Version 49 was a dud and contained a broken validation. Try to salvage the data, as
    -- best as we can.
    local broken = false
    local properties = {}
    Private.GetSubRegionProperties(data, properties)
    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        if type(condition.changes) == "table" then
          for changeIndex, change in ipairs(condition.changes) do
            if change.property then
              if not properties[change.property] then
                -- The property does not exist, so maybe it's one that was accidentally not moved
                local subRegionIndex, property = change.property:match("^sub%.(%d+)%.(.*)")
                if subRegionIndex and property then
                  broken = true
                  for _, offset in ipairs({ -1, 1 }) do
                    local newProperty = "sub." .. subRegionIndex + offset .. "." .. property
                    if properties[newProperty] then
                      change.property = newProperty
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if broken then
      WeakAuras.prettyPrint(L["Trying to repair broken conditions in %s likely caused by a WeakAuras bug."]:format(data.id))
    end
  end

  if data.internalVersion < 51 then
    for triggerId, triggerData in ipairs(data.triggers) do
      if triggerData.trigger.event == "Threat Situation" then
        triggerData.trigger.unit = triggerData.trigger.threatUnit
        triggerData.trigger.use_unit = triggerData.trigger.use_threatUnit
        triggerData.trigger.threatUnit = nil
        triggerData.trigger.use_threatUnit = nil
      end
    end
  end

  if data.internalVersion < 52 then
    local function matchTarget(input)
      return input == "target" or input == "'target'" or input == '"target"' or input == "%t" or input == "'%t'" or input == '"%t"'
    end

    if data.conditions then
      for _, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if change.property == "chat" and change.value then
            if matchTarget(change.value.message_dest) then
              change.value.message_dest = "target"
              change.value.message_dest_isunit = true
            end
          end
        end
      end
    end

    if data.actions.start.do_message and data.actions.start.message_type == "WHISPER" and matchTarget(data.actions.start.message_dest) then
      data.actions.start.message_dest = "target"
      data.actions.start.message_dest_isunit = true
    end

    if data.actions.finish.do_message and data.actions.finish.message_type == "WHISPER" and matchTarget(data.actions.finish.message_dest) then
      data.actions.finish.message_dest = "target"
      data.actions.finish.message_dest_isunit = true
    end
  end

  if data.internalVersion < 53 then
    local function ReplaceIn(text, table, prefix)
      local seenSymbols = {}
      Private.ParseTextStr(text, function(symbol)
        if not seenSymbols[symbol] then
          if table[prefix .. symbol .. "_format"] == "timed" and table[prefix .. symbol .. "_time_format"] == 0 then
            table[prefix .. symbol .. "_time_legacy_floor"] = true
          end
        end
        seenSymbols[symbol] = symbol
      end)
    end

    if data.regionType == "text" then
      ReplaceIn(data.displayText, data, "displayText_format_")
    end

    if data.subRegions then
      for index, subRegionData in ipairs(data.subRegions) do
        if subRegionData.type == "subtext" then
          ReplaceIn(subRegionData.text_text, subRegionData, "text_text_format_")
        end
      end
    end

    if data.actions then
      if data.actions.start then
        ReplaceIn(data.actions.start.message, data.actions.start, "message_format_")
      end
      if data.actions.finish then
        ReplaceIn(data.actions.finish.message, data.actions.finish, "message_format_")
      end
    end

    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if change.property == "chat" and change.value then
            ReplaceIn(change.value.message, change.value, "message_format_")
          end
        end
      end
    end
  end

  if data.internalVersion < 54 then
    for triggerId, triggerData in ipairs(data.triggers) do
      if triggerData.trigger.type == "aura" then
        triggerData.trigger.type = "unit"
        triggerData.trigger.event = "Conditions"
        triggerData.trigger.use_alwaystrue = false
      end
    end
  end

  if data.internalVersion < 55 then
    data.forceEvents = true
  end

  -- Internal version 55 contained a incorrect Modernize
  if data.internalVersion < 56 then
    data.information.forceEvents = data.forceEvents
    data.forceEvents = nil
  end

  if data.internalVersion < 57 then
    if WeakAuras.IsRetail() then
      local function GetField(load, field)
        local data = {}
        if load["use_" .. field] == true then
          if load[field].single then
            table.insert(data, load[field].single)
          end
        elseif load["use_" .. field] == false then
          for d in pairs(load[field].multi) do
            table.insert(data, d)
          end
        end
        return data
      end
      local function GetClassId(classFile)
        for classID = 1, GetNumClasses() do
          local _, thisClassFile = GetClassInfo(classID)
          if classFile == thisClassFile then
            return classID
          end
        end
      end
      local function SetSpec(load, specID)
        if load.use_class_and_spec == true then
          load.use_class_and_spec = false -- multi
        elseif load.use_class_and_spec == nil then
          load.use_class_and_spec = true -- single
        end
        load.class_and_spec = load.class_and_spec or {}
        load.class_and_spec.single = specID
        load.class_and_spec.multi = load.class_and_spec.multi or {}
        load.class_and_spec.multi[specID] = true
      end
      local load = data.load
      if load.use_class_and_spec == nil then
        local classes = GetField(load, "class")
        local specs = GetField(load, "spec")
        for i, class in ipairs(classes) do
          local classID = GetClassId(class)
          if #specs == 0 then -- add all specs
            for specIndex = 1, 4 do
              local specID = GetSpecializationInfoForClassID(classID, specIndex)
              if specID then
                SetSpec(load, specID)
              end
            end
          else
            for j, specIndex in ipairs(specs) do
              local specID = GetSpecializationInfoForClassID(classID, specIndex)
              if specID then
                SetSpec(load, specID)
              end
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 58 then
    -- convert key use for talent load condition from talent's index to spellId
    if WeakAuras.IsRetail() then
      local function migrateTalent(load, specId, field)
        if load[field] and load[field].multi then
          local newData = {}
          for key, value in pairs(load[field].multi) do
            if value ~= nil then
              local talentData = Private.GetTalentData(specId)
              if type(talentData) == "table" and talentData[key] then
                newData[talentData[key][2]] = value
              end
            end
          end
          load[field].multi = newData
        end
      end
      local load = data.load
      local specId = Private.checkForSingleLoadCondition(load, "class_and_spec")
      if specId then
        migrateTalent(load, specId, "talent")
        migrateTalent(load, specId, "talent2")
        migrateTalent(load, specId, "talent3")
      end
    end
  end

  if data.internalVersion < 59 then
    -- convert key use for talent known trigger from talent's index to spellId
    if WeakAuras.IsRetail() then
      local function migrateTalent(load, specId, field)
        if load[field] and load[field].multi then
          local newData = {}
          for key, value in pairs(load[field].multi) do
            if value ~= nil then
              local talentData = Private.GetTalentData(specId)
              if type(talentData) == "table" and talentData[key] then
                newData[talentData[key][2]] = value
              end
            end
          end
          load[field].multi = newData
        end
      end
      for triggerId, triggerData in ipairs(data.triggers) do
        if triggerData.trigger.type == "unit" and triggerData.trigger.event == "Talent Known" then
          local classId
          for i = 1, GetNumClasses() do
            if select(2, GetClassInfo(i)) == triggerData.trigger.class then
              classId = i
            end
          end
          if classId and triggerData.trigger.spec then
            local specId = GetSpecializationInfoForClassID(classId, triggerData.trigger.spec)
            if specId then
              migrateTalent(triggerData.trigger, specId, "talent")
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 60 then
    -- convert texture rotation
    if data.regionType == "texture" then
      if data.rotate then
        -- Full Rotate is enabled
        data.legacyZoomOut = true
      else
        -- Discrete Rotation
        data.rotation = data.discrete_rotation
      end
      data.discrete_rotation = nil
    end
  end

  if data.internalVersion < 61 then
    -- convert texture rotation
    if data.regionType == "texture" then
      if data.legacyZoomOut then
        data.rotate = true
      else
        data.rotate = false
        data.discrete_rotation = data.rotation
      end
      data.legacyZoomOut = nil
    end
  end

  -- version 62 became 64 to fix a broken modernize

  if data.internalVersion < 63 then
    if data.regionType == "texture" then
      local GetAtlasInfo = C_Texture and C_Texture.GetAtlasInfo or GetAtlasInfo
      local function IsAtlas(input)
        return type(input) == "string" and GetAtlasInfo(input) ~= nil
      end

      if not data.rotate or IsAtlas(data.texture) then
        data.rotation = data.discrete_rotation
      end
    end
  end

  if data.internalVersion < 64 then
    if data.regionType == "dynamicgroup" then
      if data.sort == "custom" and type(data.sortOn) ~= "string" or data.sortOn == "" then
        data.sortOn = "changed"
      end
      if data.grow == "CUSTOM" and type(data.growOn) ~= "string" then
        data.growOn = "changed"
      end
    end
  end

  if data.internalVersion < 65 then
    for triggerId, triggerData in ipairs(data.triggers) do
      if triggerData.trigger.type == "item"
      and triggerData.trigger.event == "Item Count"
      and type(triggerData.trigger.itemName) == "number"
      then
        triggerData.trigger.use_exact_itemName = true
      end
    end
  end

  local function spellIdToTalent(specId, spellId)
    local talents = Private.GetTalentData(specId)
    for _, talent in ipairs(talents) do
      if talent[2] == spellId then
        return talent[1]
      end
    end
  end

  if data.internalVersion < 66 then
    if WeakAuras.IsRetail() then
      for triggerId, triggerData in ipairs(data.triggers) do
        if triggerData.trigger.type == "unit"
          and triggerData.trigger.event == "Talent Known"
          and triggerData.trigger.talent
          and triggerData.trigger.talent.multi
        then
          local classId
          for i = 1, GetNumClasses() do
            if select(2, GetClassInfo(i)) == triggerData.trigger.class then
              classId = i
            end
          end
          if classId and triggerData.trigger.spec then
            local specId = GetSpecializationInfoForClassID(classId, triggerData.trigger.spec)
            if specId then
              local newMulti = { }
              for spellId, value in pairs(triggerData.trigger.talent.multi) do
                local talentId = spellIdToTalent(specId, spellId)
                if talentId then
                  newMulti[talentId] = value
                end
              end
              triggerData.trigger.talent.multi = newMulti
            end
          end
        end
      end
      local specId = Private.checkForSingleLoadCondition(data.load, "class_and_spec")


      if specId then
        for _, property in ipairs({"talent", "talent2", "talent3"}) do
          local use = "use_" .. property
          if data.load[use] ~= nil and data.load[property] and data.load[property].multi then
            local newMulti = { }
            for spellId, value in pairs(data.load[property].multi) do
              local talentId = spellIdToTalent(specId, spellId)
              if talentId then
                newMulti[talentId] = value
              end
            end
            data.load[property].multi = newMulti
          end

        end
      end
    end
  end

  local function migrateToTable(tab, field)
    local value = tab[field]
    if value ~= nil and type(value) ~= "table" then
      tab[field] = { value }
    end
  end

  if data.internalVersion < 67 then
    do
      local trigger_migration = {
        ["Cast"] = {
          "stage",
          "stage_operator",
        },
        ["Experience"] = {
          "level",
          "level_operator",
          "currentXP",
          "currentXP_operator",
          "totalXP",
          "totalXP_operator",
          "percentXP",
          "percentXP_operator",
          "restedXP",
          "restedXP_operator",
          "percentrested",
          "percentrested_operator",
        },
        ["Health"] = {
          "health",
          "health_operator",
          "percenthealth",
          "percenthealth_operator",
          "deficit",
          "deficit_operator",
          "maxhealth",
          "maxhealth_operator",
          "absorb",
          "absorb_operator",
          "healabsorb",
          "healabsorb_operator",
          "healprediction",
          "healprediction_operator",
        },
        ["Power"] = {
          "power",
          "power_operator",
          "percentpower",
          "percentpower_operator",
          "deficit",
          "deficit_operator",
          "maxpower",
          "maxpower_operator",
        },
        ["Character Stats"] = {
          "mainstat",
          "mainstat_operator",
          "strength",
          "strength_operator",
          "agility",
          "agility_operator",
          "intellect",
          "intellect_operator",
          "spirit",
          "spirit_operator",
          "stamina",
          "stamina_operator",
          "criticalrating",
          "criticalrating_operator",
          "criticalpercent",
          "criticalpercent_operator",
          "hitrating",
          "hitrating_operator",
          "hitpercent",
          "hitpercent_operator",
          "hasterating",
          "hasterating_operator",
          "hastepercent",
          "hastepercent_operator",
          "meleehastepercent",
          "meleehastepercent_operator",
          "expertiserating",
          "expertiserating_operator",
          "expertisebonus",
          "expertisebonus_operator",
          "armorpenrating",
          "armorpenrating_operator",
          "armorpenpercent",
          "armorpenpercent_operator",
          "resiliencerating",
          "resiliencerating_operator",
          "resiliencepercent",
          "resiliencepercent_operator",
          "spellpenpercent",
          "spellpenpercent_operator",
          "masteryrating",
          "masteryrating_operator",
          "masterypercent",
          "masterypercent_operator",
          "versatilityrating",
          "versatilityrating_operator",
          "versatilitypercent",
          "versatilitypercent_operator",
          "attackpower",
          "attackpower_operator",
          "resistanceholy",
          "resistanceholy_operator",
          "resistancefire",
          "resistancefire_operator",
          "resistancenature",
          "resistancenature_operator",
          "resistancefrost",
          "resistancefrost_operator",
          "resistanceshadow",
          "resistanceshadow_operator",
          "resistancearcane",
          "resistancearcane_operator",
          "leechrating",
          "leechrating_operator",
          "leechpercent",
          "leechpercent_operator",
          "movespeedrating",
          "movespeedrating_operator",
          "movespeedpercent",
          "movespeedpercent_operator",
          "runspeedpercent",
          "runspeedpercent_operator",
          "avoidancerating",
          "avoidancerating_operator",
          "avoidancepercent",
          "avoidancepercent_operator",
          "defense",
          "defense_operator",
          "dodgerating",
          "dodgerating_operator",
          "dodgepercent",
          "dodgepercent_operator",
          "parryrating",
          "parryrating_operator",
          "parrypercent",
          "parrypercent_operator",
          "blockpercent",
          "blockpercent_operator",
          "blocktargetpercent",
          "blocktargetpercent_operator",
          "blockvalue",
          "blockvalue_operator",
          "staggerpercent",
          "staggerpercent_operator",
          "staggertargetpercent",
          "staggertargetpercent_operator",
          "armorrating",
          "armorrating_operator",
          "armorpercent",
          "armorpercent_operator",
          "armortargetpercent",
          "armortargetpercent_operator",
        },
        ["Threat Situation"] = {
          "threatpct",
          "threatpct_operator",
          "rawthreatpct",
          "rawthreatpct_operator",
          "threatvalue",
          "threatvalue_operator",
        },
        ["Unit Characteristics"] = {
          "level",
          "level_operator",
        },
        ["Combat Log"] = {
          "spellId",
          "spellName",
        },
        ["Spell Cast Succeeded"] = {
          "spellId"
        }
      }
      for _, triggerData in ipairs(data.triggers) do
        local t = triggerData.trigger
        local fieldsToMigrate = trigger_migration[t.event]
        if fieldsToMigrate then
          for _, field in ipairs(fieldsToMigrate) do
            migrateToTable(t, field)
          end
        end
        -- cast trigger move data from 'spell' & 'spellId' to 'spellIds' & 'spellNames'
        if t.event == "Cast" and t.type == "unit" then
          if t.spellId then
            if t.useExactSpellId then
              t.use_spellIds = t.use_spellId
              t.spellIds = t.spellIds or {}
              tinsert(t.spellIds, t.spellId)
            else
              t.use_spellNames = t.use_spellId
              t.spellNames = t.spellNames or {}
              tinsert(t.spellNames, t.spellId)
            end
          end
          if t.use_spell and t.spell then
            t.use_spellNames = true
            t.spellNames = t.spellNames or {}
            tinsert(t.spellNames, t.spell)
          end
          t.use_spellId = nil
          t.spellId = nil
          t.use_spell = nil
          t.spell = nil
        end
      end
    end
    do
      local loadFields = {
        "level", "effectiveLevel"
      }

      for _, field in ipairs(loadFields) do
        migrateToTable(data.load, field)
        migrateToTable(data.load, field .. "_operator")
      end
    end
  end

  if data.internalVersion < 68 then
    if data.parent then
      local parentData = WeakAuras.GetData(data.parent)
      if parentData and parentData.regionType == "dynamicgroup" then
        if data.anchorFrameParent == nil then
          data.anchorFrameParent = false
        end
      end
    end
  end

  if data.internalVersion < 69 then
    migrateToTable(data.load, "itemequiped")
  end

  if data.internalVersion < 70 then
    local trigger_migration = {
      Power = {
        "power",
        "power_operator"
      }
    }
    for _, triggerData in ipairs(data.triggers) do
      local t = triggerData.trigger
      local fieldsToMigrate = trigger_migration[t.event]
      if fieldsToMigrate then
        for _, field in ipairs(fieldsToMigrate) do
          migrateToTable(t, field)
        end
      end
    end
  end

  if data.internalVersion < 71 then
    if data.regionType == 'icon' or data.regionType == 'aurabar'
       or data.regionType == 'progresstexture'
       or data.regionType == 'stopmotion'
    then
      data.progressSource = {-1, ""}
    else
      data.progressSource = nil
    end
    if data.subRegions then
      for index, subRegionData in ipairs(data.subRegions) do
        if subRegionData.type == "subtick" then
          local tick_placement = subRegionData.tick_placement
          subRegionData.tick_placements = {}
          subRegionData.tick_placements[1] = tick_placement
          subRegionData.progressSources = {{-2, ""}}
          subRegionData.tick_placement = nil
        end
      end
    end
  end

  if data.internalVersion < 72 then
    if WeakAuras.IsClassic() then
      if data.model_path and data.modelIsUnit then
        data.model_fileId = data.model_path
      end
    end
  end

  if data.internalVersion < 73 then
    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if type(change.property) == "string" then
            change.property = string.gsub(change.property, "(sub.%d.tick_placement)(%d)", "%1s.%2")
          end
        end
      end
    end
  end

  if data.internalVersion < 74 then
    for _, triggerData in ipairs(data.triggers) do
      local t = triggerData.trigger
      if t.type == "spell" and t.event == "Cooldown Progress (Spell)" then
        if t.use_exact_spellName then
          t.use_ignoreoverride = true
        end
      end
    end
  end

  if data.internalVersion < 75 then
    -- this commit from nov 2019 https://github.com/WeakAuras/WeakAuras2/commit/6d8f11c17422aeffdb82a0aa05181edfdd137896
    -- changed adjustedMin & adjustedMax type from number to string (range => input)
    -- but didn't include a migration
    if type(data.adjustedMin) == "number" then
      data.adjustedMin = tostring(data.adjustedMin)
    end
    if type(data.adjustedMax) == "number" then
      data.adjustedMax = tostring(data.adjustedMax)
    end
    -- this commit https://github.com/WeakAuras/WeakAuras2/commit/dbcb70b1e4df262af82f63620b3b0d80741e6df2
    -- set a default for adjustedMin & adjustedMax with an empty string
    -- in Private.validate if type of value is different from type of default, value is set to default
    -- which had effect to lose data if aura was made before nov 2019 ~ 2020
    -- try detect data loss and restore from Archivist
    if data.internalVersion == 74 and oldSnapshot then
      local restoreMin = data.useAdjustededMin and data.adjustedMin == ""
      local restoreMax = data.useAdjustededMax and data.adjustedMax == ""
      if restoreMin or restoreMax then
        if restoreMin and type(oldSnapshot.adjustedMin) == "number" then
          data.adjustedMin = tostring(oldSnapshot.adjustedMin)
        end
        if restoreMax and type(oldSnapshot.adjustedMax) == "number" then
          data.adjustedMax = tostring(oldSnapshot.adjustedMax)
        end
      end
    end
  end

  if data.internalVersion < 76 then
    local function removeHoles(t)
      local keys = {}
      for key in pairs(t) do
        table.insert(keys, key)
      end
      if #keys ~= #t then
        table.sort(keys)
        local newTable = {}
        for i, key in ipairs(keys) do
          newTable[i] = t[key]
        end
        return newTable
      else
        return t
      end
    end
    local trigger_migration = {
      ["Spell Cast Succeeded"] = {
        "spellId",
      },
      ["Unit Characteristics"] = {
        "level",
      },
      ["Power"] = {
        "power",
        "percentpower",
        "deficit",
        "maxpower",
      },
      ["Combat Log"] = {
        "spellId",
        "spellName",
      },
      ["Health"] = {
        "health",
        "percenthealth",
        "deficit",
        "maxhealth",
        "absorb",
        "healabsorb",
        "healprediction",
      },
      ["Faction Reputation"] = {
        "value",
        "total",
        "percentRep",
      },
      ["Location"] = {
        "zone",
        "subzone",
      },
      ["Threat Situation"] = {
        "threatpct",
        "rawthreatpct",
        "threatvalue",
      },
      ["Character Stats"] = {
        "mainstat",
        "strength",
        "agility",
        "intellect",
        "spirit",
        "stamina",
        "criticalrating",
        "criticalpercent",
        "hitrating",
        "hitpercent",
        "hasterating",
        "hastepercent",
        "meleehastepercent",
        "expertiserating",
        "expertisebonus",
        "spellpenpercent",
        "masteryrating",
        "masterypercent",
        "versatilityrating",
        "versatilitypercent",
        "attackpower",
        "leechrating",
        "leechpercent",
        "movespeedrating",
        "movespeedpercent",
        "runspeedpercent",
        "avoidancerating",
        "avoidancepercent",
        "dodgerating",
        "dodgepercent",
        "parryrating",
        "parrypercent",
        "blockpercent",
        "blocktargetpercent",
        "blockvalue",
        "staggerpercent",
        "staggertargetpercent",
        "armorrating",
        "armorpercent",
        "armortargetpercent",
        "resistanceholy",
        "resistancefire",
        "resistancenature",
        "resistancefrost",
        "resistanceshadow",
        "resistancearcane",
      },
      ["Cast"] = {
        "spellNames",
        "spellIds",
        "stage",
      },
      ["Alternate Power"] = {
        "power",
      },
      ["Experience"] = {
        "level",
        "currentXP",
        "totalXP",
        "percentXP",
        "restedXP",
        "percentrested",
      }
    }
    for _, triggerData in ipairs(data.triggers) do
      local trigger = triggerData.trigger
      local fieldsToMigrate = trigger_migration[trigger.event]
      if fieldsToMigrate then
        for _, field in ipairs(fieldsToMigrate) do
          if type(trigger[field]) == "table" then
            trigger[field] = removeHoles(trigger[field])
          end
        end
      end
    end
  end

  if data.internalVersion < 77 then
    -- fix data broken by wago export
    local triggerFix = {
      talent = {
        multi = true
      },
      herotalent = {
        multi = true
      },
      form = {
        multi = true
      },
      specId = {
        multi = true
      },
      actualSpec = true,
      arena_spec = true
    }
    local loadFix = {
      talent = {
        multi = true
      },
      talent2 = {
        multi = true
      },
      talent3 = {
        multi = true
      },
      herotalent = {
        multi = true
      },
      class_and_spec = {
        multi = true
      }
    }

    local function fixData(data, fields)
      for k, v in pairs(fields) do
        if v == true and type(data[k]) == "table" then
          -- fix field k
          local tofix = {}
          for key in pairs(data[k]) do
              if type(key) == "string" then
                table.insert(tofix, key)
              end
          end
          for _, oldkey in ipairs(tofix) do
              local newkey = tonumber(oldkey)
              if newkey then
                data[k][newkey] = data[k][oldkey]
              end
              data[k][oldkey] = nil
          end
        elseif type(v) == "table" and type(data[k]) == "table" then
          -- recurse
          fixData(data[k], fields[k])
        end
      end
    end

    for _, triggerData in ipairs(data.triggers) do
      fixData(triggerData.trigger, triggerFix)
    end
    fixData(data.load, loadFix)
  end

  if data.internalVersion < 78 then
    if data.triggers then
      for triggerId, triggerData in ipairs(data.triggers) do
        local trigger = triggerData.trigger
        -- Item Type is now always a multi selection
        if trigger and trigger.type == "item" and trigger.event == "Item Type Equipped" then
          local value = trigger.itemTypeName and trigger.itemTypeName.single or nil
          if trigger.use_itemTypeName and value then
            trigger.use_itemTypeName = false
            trigger.itemTypeName = {multi = {[value] = true}}
          else
            trigger.itemTypeName = {multi = {}}
          end
        end
      end
    end
  end

  if data.internalVersion < 79 then
    if data.triggers then
      for _, triggerData in ipairs(data.triggers) do
        local trigger = triggerData.trigger
        if trigger and trigger.type == "unit" and trigger.event == "Unit Characteristics" then
          if trigger.use_ignoreDead then
            if trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party" then
              trigger.use_dead = false
            else
              -- since this option was previously only available for group units,
              -- nil it out if the unit isn't group to avoid surprises from vestigial data
              trigger.use_dead = nil
            end
          end
          trigger.use_ignoreDead = nil
        end
      end
    end
  end


  if data.internalVersion < 80 then
    -- Use common names for anchor areas/points so
    -- that up/down of sub regions can adapt that

    local conversions = {
      subborder = {
        border_anchor = "anchor_area",
      },
      subglow = {
        glow_anchor = "anchor_area"
      },
      subtext = {
        text_anchorPoint = "anchor_point"
      }
    }

    if data.subRegions then
      for index, subRegionData in ipairs(data.subRegions) do
        if conversions[subRegionData.type] then
          for oldKey, newKey in pairs(conversions[subRegionData.type]) do
            subRegionData[newKey] = subRegionData[oldKey]
            subRegionData[oldKey] = nil
          end
        end
      end
    end
  end

  if data.internalVersion < 81 then
    -- Rename 'progressSources' to 'progressSource' for Linear/CircularProgressTexture/StopMotion sub elements
    local conversions = {
      sublineartexture = {
        progressSources = "progressSource",
      },
      subcirculartexture = {
        progressSources = "progressSource",
      },
      substopmotion = {
        progressSources = "progressSource",
      }
    }
    if data.subRegions then
      for index, subRegionData in ipairs(data.subRegions) do
        if conversions[subRegionData.type] then
          for oldKey, newKey in pairs(conversions[subRegionData.type]) do
            subRegionData[newKey] = subRegionData[oldKey]
            subRegionData[oldKey] = nil
          end
        end
      end
    end
  end

  if data.internalVersion < 82 then
    -- noMerge for separator custom option doesn't make sense,
    -- and groups achieve the desired effect better,
    -- so drop the feature
    if data.authorOptions then
      for _, optionData in ipairs(data.authorOptions) do
        if optionData.type == "header" then
          optionData.noMerge = nil
        end
      end
    end
  end

  if data.internalVersion < 83 then
    local propertyRenames = {
      cooldownText = "cooldownTextDisabled",
    }

    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if propertyRenames[change.property] then
            change.property = propertyRenames[change.property]
          end
        end
      end
    end
  end

  if data.internalVersion < 84 then
    if data.triggers then
      for _, triggerData in ipairs(data.triggers) do
        local trigger = triggerData.trigger
        if trigger and trigger.type == "addons" then
          if trigger.event == "Boss Mod Timer" or trigger.event == "BigWigs Timer" or trigger.event == "DBM Timer" then
            -- if trigger don't filter bars, show only those active in the addon config for triggers made before this option was added
            -- show disabled bars when looking for specific ids/name
            if not (trigger.use_message or trigger.use_spellId) then
              trigger.use_isBarEnabled = true
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 85 then
    if data.triggers then
      local eventTypes = {
        ["Unit Characteristics"] = true,
        ["Health"] = true,
        ["Power"] = true,
        ["Alternate Power"] = true,
        ["Cast"] = true
      }
      for _, triggerData in ipairs(data.triggers) do
        local trigger = triggerData.trigger
        if trigger and trigger.type == "unit" then
          if eventTypes[trigger.event] then
            local rt = trigger.raidMarkIndex
            if type(rt) == "number" then
              trigger.raidMarkIndex = {
                single = rt
              }
            end
            if trigger.use_raidMarkIndex == false then
              trigger.use_raidMarkIndex = nil
            end
          end
        end
      end
    end
  end

  if data.internalVersion < 86 then
    if data.subRegions then
      for index, subRegionData in ipairs(data.subRegions) do
        if subRegionData.type == "submodel" then
          subRegionData.bar_model_attach = subRegionData.bar_model_clip
          subRegionData.bar_model_clip = nil
          if subRegionData.bar_model_attach then
            subRegionData.bar_model_stretch = true
          end
        end
      end
    end
  end

  data.internalVersion = max(data.internalVersion or 0, WeakAuras.InternalVersion())
end

--- Returns true if Modernize will use data from last snapshot before a new one is done
function Private.ModernizeNeedsOldSnapshot(data)
  if data.internalVersion == 74 then
    local restoreMin = data.useAdjustededMin and data.adjustedMin == ""
    local restoreMax = data.useAdjustededMax and data.adjustedMax == ""
    if restoreMin or restoreMax then
      return true
    end
  end
end


-- ========================================
-- File: WeakAuras/PatreonList.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
Private.DiscordList = {

}
Private.DiscordListCJ = {

}
Private.DiscordListK = {

}


-- ========================================
-- File: WeakAuras/Profiling.lua
-- ========================================

if not WeakAuras.IsLibsOK() then
  return
end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L
local prettyPrint = WeakAuras.prettyPrint
local LGF = LibStub("LibGetFrame-1.0")

local profileData = {}
profileData.systems = {}
profileData.auras = {}

local currentProfileState, ProfilingTimer

local table_to_string
table_to_string = function(tbl, depth)
  if depth and depth >= 3 then
    return "{ ... }"
  end
  local str
  for k, v in pairs(tbl) do
    if type(v) ~= "userdata" then
      if type(v) == "table" then
        v = table_to_string(v, (depth and depth + 1 or 1))
      elseif type(v) == "function" then
        v = "function"
      elseif type(v) == "string" then
        v = '"' .. v .. '"'
      end

      if type(k) == "string" then
        k = '"' .. k .. '"'
      end

      str = (str and str .. "|cff999999,|r " or "|cff999999{|r ") .. "|cffffff99[" .. tostring(k) .. "]|r |cff999999=|r |cffffffff" .. tostring(v) .. "|r"
    end
  end
  return (str or "{ ") .. " }"
end

WeakAurasProfilingReportMixin = {}
function WeakAurasProfilingReportMixin:OnShow()
  if self.initialised then
    return
  end
  self.initialised = true

  ButtonFrameTemplate_HidePortrait(self)
  self:SetTitle(L["WeakAuras Profiling Report"])
  self:SetSize(500, 300)
end

function WeakAurasProfilingReportMixin:ClearText()
  self.ScrollBox.messageFrame:SetText("")
end

function WeakAurasProfilingReportMixin:AddText(v)
  if not v then
    return
  end
  --- @type string?
  local m = self.ScrollBox.messageFrame:GetText()
  if m ~= "" then
    m = m .. "|n"
  end
  if type(v) == "table" then
    v = table_to_string(v)
  end
  self.ScrollBox.messageFrame.originalText = m .. v
  self.ScrollBox.messageFrame:SetText(self.ScrollBox.messageFrame.originalText)
end

local function StartProfiling(map, id)
  if not map[id] then
    map[id] = {}
    map[id].count = 1
    map[id].start = debugprofilestop()
    map[id].elapsed = 0
    map[id].spike = 0
    return
  end

  if map[id].count == 0 then
    map[id].count = 1
    map[id].start = debugprofilestop()
  else
    map[id].count = map[id].count + 1
  end
end

local function StopProfiling(map, id)
  map[id].count = map[id].count - 1
  if map[id].count == 0 then
    local elapsed = debugprofilestop() - map[id].start
    map[id].elapsed = map[id].elapsed + elapsed
    if elapsed > map[id].spike then
      map[id].spike = elapsed
    end
  end
end

local function StartProfileSystem(system)
  StartProfiling(profileData.systems, "wa")
  StartProfiling(profileData.systems, system)
end

local function StartProfileAura(id)
  StartProfiling(profileData.auras, id)
end

local function StopProfileSystem(system)
  StopProfiling(profileData.systems, "wa")
  StopProfiling(profileData.systems, system)
end

local function StopProfileAura(id)
  StopProfiling(profileData.auras, id)
end

local function StartProfileUID(uid)
  StartProfiling(profileData.auras, Private.UIDtoID(uid))
end

local function StopProfileUID(uid)
  StopProfiling(profileData.auras, Private.UIDtoID(uid))
end

function Private.ProfileRenameAura(oldid, id)
  profileData.auras[id] = profileData.auras[id]
  profileData.auras[oldid] = nil
end

local RegisterProfile = function(startType)
  if startType == "boss" then
    startType = "encounter"
  end
  local delayedStart
  if startType == "encounter" then
    WeakAurasProfilingFrame:UnregisterAllEvents()
    prettyPrint(L["Your next encounter will automatically be profiled."])
    WeakAurasProfilingFrame:RegisterEvent("ENCOUNTER_START")
    WeakAurasProfilingFrame:RegisterEvent("ENCOUNTER_END")
    currentProfileState = startType
    delayedStart = true
  elseif startType == "combat" then
    WeakAurasProfilingFrame:UnregisterAllEvents()
    prettyPrint(L["Your next instance of combat will automatically be profiled."])
    WeakAurasProfilingFrame:RegisterEvent("PLAYER_REGEN_DISABLED")
    WeakAurasProfilingFrame:RegisterEvent("PLAYER_REGEN_ENABLED")
    currentProfileState = startType
    delayedStart = true
  elseif startType == "autostart" then
    prettyPrint(L["Profiling automatically started."])
    currentProfileState = "profiling"
  elseif startType and startType:match("%d") then
    WeakAurasProfilingFrame:UnregisterAllEvents()
    local time = startType + 0
    prettyPrint(L["Profiling started. It will end automatically in %d seconds"]:format(time))
    ProfilingTimer = WeakAuras.timer:ScheduleTimer(WeakAuras.StopProfile, time)
    currentProfileState = "profiling"
  else
    WeakAurasProfilingFrame:UnregisterAllEvents()
    prettyPrint(L["Profiling started."])
    currentProfileState = "profiling"
  end
  WeakAurasProfilingFrame:UpdateButtons()
  return delayedStart
end

---@diagnostic disable-next-line: duplicate-set-field
function WeakAuras.StartProfile(startType)
  if currentProfileState == "profiling" then
    prettyPrint(L["Profiling already started."])
    return
  end

  if RegisterProfile(startType) then
    -- Scheduled for later
    return
  end

  profileData.systems = {}
  profileData.auras = {}
  profileData.systems.time = {}
  profileData.systems.time.start = debugprofilestop()
  profileData.systems.time.elapsed = nil
  profileData.systems.time.count = 1

  Private.StartProfileSystem = StartProfileSystem
  Private.StartProfileAura = StartProfileAura
  Private.StartProfileUID = StartProfileUID
  Private.StopProfileSystem = StopProfileSystem
  Private.StopProfileAura = StopProfileAura
  Private.StopProfileUID = StopProfileUID
  LGF.StartProfile()
end

local function doNothing() end

---@diagnostic disable-next-line: duplicate-set-field
function WeakAuras.StopProfile()
  if currentProfileState ~= "profiling" then
    prettyPrint(L["Profiling not running."])
    return
  end

  prettyPrint(L["Profiling stopped."])

  profileData.systems.time.elapsed = debugprofilestop() - profileData.systems.time.start
  profileData.systems.time.count = 0

  Private.StartProfileSystem = doNothing
  Private.StartProfileAura = doNothing
  Private.StartProfileUID = doNothing
  Private.StopProfileSystem = doNothing
  Private.StopProfileAura = doNothing
  Private.StopProfileUID = doNothing
  LGF.StopProfile()

  currentProfileState = nil
  if WeakAurasProfilingFrame then
    WeakAurasProfilingFrame:UnregisterAllEvents()
    WeakAurasProfilingFrame:UpdateButtons()
  end

  if ProfilingTimer then
    WeakAuras.timer:CancelTimer(ProfilingTimer)
    ProfilingTimer = nil
  end
end

function WeakAuras.ToggleProfile()
  if not profileData.systems.time or profileData.systems.time.count ~= 1 then
    WeakAuras.StartProfile()
  else
    WeakAuras.StopProfile()
  end
end

local function CancelScheduledProfile()
  prettyPrint(L["Your scheduled automatic profile has been cancelled."])
  currentProfileState = nil
  WeakAurasProfilingFrame:UnregisterAllEvents()
  WeakAurasProfilingFrame:UpdateButtons()
end

WeakAuras.CancelScheduledProfile = CancelScheduledProfile

local function AutoStartStopProfiling(frame, event)
  if event == "ENCOUNTER_START" or event == "PLAYER_REGEN_DISABLED" then
    WeakAuras.StartProfile("autostart")
  elseif event == "ENCOUNTER_END" or event == "PLAYER_REGEN_ENABLED" then
    WeakAuras.StopProfile()
  end
end

local function ColoredSpike(spike)
  local r, g, b
  if spike < 2 then
    r, g, b = WeakAuras.GetHSVTransition(spike / 2, 0, 1, 0, 1, 1, 1, 0, 1)
  elseif spike < 2.5 then
    r, g, b = WeakAuras.GetHSVTransition((spike - 2) * 2, 1, 1, 0, 1, 1, 0.65, 0, 1)
  elseif spike < 3 then
    r, g, b = WeakAuras.GetHSVTransition((spike - 2.5) * 2, 1, 0.65, 0, 1, 1, 0, 0, 1)
  else
    r, g, b = 1, 0, 0
  end
  return ("|cff%02x%02x%02x%.2fms|r"):format(r * 255, g * 255, b * 255, spike)
end

local function PrintOneProfile(popup, name, map, total)
  if map.count ~= 0 then
    popup:AddText(name .. "  ERROR: count is not zero:" .. " " .. map.count)
  end

  local percent = ""
  if total then
    percent = (", %.2f%%"):format(100 * map.elapsed / total)
  end

  local spikeInfo = ""
  if map.spike then
    spikeInfo = ColoredSpike(map.spike)
  end

  popup:AddText(("%s |cff999999%.2fms%s (%s)|r"):format(name, map.elapsed, percent, spikeInfo))
end

local function SortProfileMap(map, sortField)
  local result = {}
  for k in pairs(map) do
    tinsert(result, k)
  end

  sort(result, function(a, b)
    if sortField then
      local x, y = map[a][sortField], map[b][sortField]
      if x and y then
        return x > y
      end
    end

    return map[a].elapsed > map[b].elapsed
  end)

  return result
end

local function TotalProfileTime(map)
  local total = 0
  for k, v in pairs(map) do
    if k ~= "time" and k ~= "wa" then
      total = total + v.elapsed
    end
  end
  return total
end

local function unitEventToMultiUnit(event)
  local count
  event, count = event:gsub("nameplate%d+$", "nameplate")
  if count == 1 then
    return event
  end
  event, count = event:gsub("boss%d$", "boss")
  if count == 1 then
    return event
  end
  event, count = event:gsub("arena%d$", "arena")
  if count == 1 then
    return event
  end
  event, count = event:gsub("raid%d+$", "group")
  if count == 1 then
    return event
  end
  event, count = event:gsub("raidpet%d+$", "group")
  if count == 1 then
    return event
  end
  event, count = event:gsub("party%d$", "party")
  if count == 1 then
    return event
  end
  event, count = event:gsub("partypet%d$", "party")
  return event
end

---@diagnostic disable-next-line: duplicate-set-field
function WeakAuras.PrintProfile()
  local popup = WeakAurasProfilingReport
  if not profileData.systems.time then
    prettyPrint(L["No Profiling information saved."])
    return
  end

  if profileData.systems.time.count == 1 then
    prettyPrint(L["Profiling still running, stop before trying to print."])
    return
  end

  popup:ClearAllPoints()
  if WeakAurasProfilingFrame and WeakAurasProfilingFrame:IsShown() then
    popup:SetParent(WeakAurasProfilingFrame)
    popup:SetPoint("TOPLEFT", WeakAurasProfilingFrame, "TOPRIGHT", 5, 0)
  else
    popup:SetParent(UIParent)
    if WeakAurasSaved.ProfilingWindow then
      popup:SetPoint("TOPLEFT", UIParent, "TOPLEFT", WeakAurasSaved.ProfilingWindow.xOffset or 0, WeakAurasSaved.ProfilingWindow.yOffset or 0)
    else
      popup:SetPoint("CENTER")
    end
  end

  popup:ClearText()

  PrintOneProfile(popup, "|cff9900ffTotal time:|r", profileData.systems.time)
  PrintOneProfile(popup, "|cff9900ffTime inside WA:|r", profileData.systems.wa)
  popup:AddText(string.format("|cff9900ffTime spent inside WA:|r %.2f%%", 100 * profileData.systems.wa.elapsed / profileData.systems.time.elapsed))

  popup:AddText("")
  popup:AddText("Note: Not every aspect of each aura can be tracked.")
  popup:AddText("You can ask on our discord https://discord.gg/weakauras for help interpreting this output.")

  popup:AddText("")
  popup:AddText("|cff9900ffAuras:|r")
  local total = TotalProfileTime(profileData.auras)
  popup:AddText("Total time attributed to auras: ", floor(total) .. "ms")
  for _, k in ipairs(SortProfileMap(profileData.auras), "spike") do
    PrintOneProfile(popup, k, profileData.auras[k], total)
  end

  popup:AddText("")
  popup:AddText("|cff9900ffSystems:|r")

  -- make a new table for system data with multiUnits grouped
  local systemRegrouped = {}
  for k, v in pairs(profileData.systems) do
    local event = unitEventToMultiUnit(k)
    if systemRegrouped[event] == nil then
      systemRegrouped[event] = CopyTable(v)
    else
      if v.elapsed then
        systemRegrouped[event].elapsed = (systemRegrouped[event].elapsed or 0) + v.elapsed
      end
      if v.spike then
        systemRegrouped[event].spike = (systemRegrouped[event].spike or 0) + v.spike
      end
    end
  end

  for i, k in ipairs(SortProfileMap(systemRegrouped)) do
    if k ~= "time" and k ~= "wa" then
      PrintOneProfile(popup, k, systemRegrouped[k], profileData.systems.wa.elapsed)
    end
  end

  popup:AddText("")
  popup:AddText("|cff9900ffLibGetFrame:|r")
  for id, map in pairs(LGF.GetProfileData()) do
    PrintOneProfile(popup, id, map)
  end

  popup:Show()
end

WeakAurasProfilingLineMixin = {
  spikeTooltip = L["Maximum time used on a single frame"],
  timeTooltip = L["Cumulated time used during profiling"],
}

function WeakAurasProfilingLineMixin:Init(e)
  -- button.pct:SetText(pct)
  self.progressBar.name:SetText(e.name)
  self.time:SetText(("%.2fms"):format(e.time))
  self.spike:SetText(ColoredSpike(e.spike))
  self.progressBar:SetValue(e.pct)
end

local COLUMN_INFO = {
  {
    title = L["Name"],
    width = 1,
    attribute = "name",
  },
  {
    title = L["Time"],
    width = 100,
    attribute = "time",
  },
  {
    title = L["Spike"],
    width = 100,
    attribute = "spike",
  },
}

local function ApplyAlternateState(frame, alternate)
  if alternate then
    frame.progressBar:SetStatusBarColor(0.7, 0.7, 0.7, 0.7)
  else
    frame.progressBar:SetStatusBarColor(0.5, 0.5, 0.5, 0.7)
  end
end

local modes = {
  L["Auras"],
  L["Systems"],
}
WeakAurasProfilingMixin = {}

local MinPanelWidth, MinPanelHeight = 500, 300
local MinPanelMinimizedWidth, MinPanelMinimizedHeight = 250, 80
function WeakAurasProfilingMixin:OnShow()
  if self.initialised then
    return
  end
  self.initialised = true

  ButtonFrameTemplate_HidePortrait(self)
  self:SetTitle(L["WeakAuras Profiling"])
  self:SetSize(MinPanelWidth, MinPanelHeight)
  self.ResizeButton:Init(self, MinPanelMinimizedWidth, MinPanelMinimizedHeight)
  self:SetResizeBounds(MinPanelWidth, MinPanelHeight)
  self.mode = 1
  UIDropDownMenu_SetText(self.buttons.modeDropDown, modes[1])

  self.buttons.report:SetText(L["Report Summary"])
  self.buttons.report.tooltip = L["A detailed overview of your auras and WeakAuras systems\nCopy the whole text to Weakaura's Discord if you need assistance."]

  local minimizeButton = CreateFrame("Button", nil, self, "MaximizeMinimizeButtonFrameTemplate")
  minimizeButton:SetPoint("RIGHT", self.CloseButton, "LEFT")
  minimizeButton:SetOnMaximizedCallback(function()
    self.minimized = false
    self.buttons:Show()
    self.ResizeButton:Show()
    self.ColumnDisplay:Show()
    self.ScrollBox:Show()
    self.ScrollBar:Show()
    self.stats:Show()
    self:ClearAllPoints()
    self:SetPoint("TOPRIGHT", UIParent, "BOTTOMLEFT", self.right, self.top)
    self:SetHeight(self.prevHeight > MinPanelHeight and self.prevHeight or MinPanelHeight)
    self:SetWidth(self.prevWidth > MinPanelWidth and self.prevWidth or MinPanelWidth)
  end)
  minimizeButton:SetOnMinimizedCallback(function()
    self.minimized = true
    self.buttons:Hide()
    self.ResizeButton:Hide()
    self.ColumnDisplay:Hide()
    self.ScrollBox:Hide()
    self.ScrollBar:Hide()
    self.stats:Hide()
    self.right, self.top = self:GetRight(), self:GetTop()
    self:ClearAllPoints()
    self:SetPoint("TOPRIGHT", UIParent, "BOTTOMLEFT", self.right, self.top)
    self.prevHeight = self:GetHeight()
    self.prevWidth = self:GetWidth()
    self:SetHeight(MinPanelMinimizedHeight)
    self:SetWidth(MinPanelMinimizedWidth)
  end)

  self.ColumnDisplay:LayoutColumns(COLUMN_INFO)

  -- LayoutColumns doesn't handle resizable columns, fix it
  local headers = {}
  for header in self.ColumnDisplay.columnHeaders:EnumerateActive() do
    headers[header:GetID()] = header
  end
  local prevHeader
  for i, header in ipairs_reverse(headers) do
    header:ClearAllPoints()
    local info = COLUMN_INFO[i]
    if info.width ~= 1 then
      header:SetWidth(info.width)
    end
    if prevHeader == nil then
      header:SetPoint("BOTTOMRIGHT", -25, 1)
    else
      header:SetPoint("BOTTOMRIGHT", prevHeader, "BOTTOMLEFT", 2, 0)
    end
    if i == 1 then
      header:SetPoint("BOTTOMLEFT", 3, 0)
    end
    prevHeader = header
  end

  local view = CreateScrollBoxListLinearView()
  view:SetElementInitializer("WeakAurasProfilingLineTemplate", function(frame, elementData)
    frame:Init(elementData)
  end)
  ScrollUtil.InitScrollBoxListWithScrollBar(self.ScrollBox, self.ScrollBar, view)
  ScrollUtil.RegisterAlternateRowBehavior(self.ScrollBox, ApplyAlternateState)

  self.sortField = "time"
  self.bars = CreateDataProvider()
  self:SortByColumnIndex(2)
  self.ScrollBox:SetDataProvider(self.bars)

  self:InitDropDown()
  self:InitModeDropDown()
  self:SetScript("OnEvent", AutoStartStopProfiling)

  self:SetScript("OnUpdate", function()
    if profileData.systems.time and profileData.systems.time.count > 0 then
      self:RefreshBars()
    end
  end)
  self:UpdateButtons()
end

function WeakAurasProfilingResultButton_OnClick(self)
  WeakAuras.PrintProfile()
end

local function nextEncounterButton_OnClick(self)
  if currentProfileState ~= "encounter" then
    WeakAuras.StartProfile("encounter")
  end
  local parent = self:GetParent()
  local profilingFrame = parent.dropdown.Button:GetParent():GetParent():GetParent()
  profilingFrame:ResetBars()
  profilingFrame:UpdateButtons()
end

local function nextCombatButton_OnClick(self)
  if currentProfileState ~= "combat" then
    WeakAuras.StartProfile("combat")
  end
  local parent = self:GetParent()
  local profilingFrame = parent.dropdown.Button:GetParent():GetParent():GetParent()
  profilingFrame:ResetBars()
  profilingFrame:UpdateButtons()
end

local function startNowButton_OnClick(self)
  WeakAuras.StartProfile()
  local parent = self:GetParent()
  local profilingFrame = parent.dropdown.Button:GetParent():GetParent():GetParent()
  profilingFrame:ResetBars()
  profilingFrame:UpdateButtons()
end

function WeakAurasProfilingStopButton_OnClick(self)
  if currentProfileState == "profiling" then
    WeakAuras.StopProfile()
  else
    CancelScheduledProfile()
  end
  self:GetParent():GetParent():UpdateButtons()
end

function WeakAurasProfilingMixin:InitDropDown()
  local function Initializer(dropDown, level)
    local entries = {
      {
        text = L["Start Now"],
        func = startNowButton_OnClick,
      },
      {
        text = L["Next Encounter"],
        func = nextEncounterButton_OnClick,
      },
      {
        text = L["Next Combat"],
        func = nextCombatButton_OnClick,
      },
    }
    for _, entry in ipairs(entries) do
      local info = UIDropDownMenu_CreateInfo()
      info.notCheckable = true
      info.text = entry.text
      info.func = entry.func
      UIDropDownMenu_AddButton(info)
    end
  end

  local dropDown = self.buttons.startDropDown
  local dropDownButton = self.buttons.start
  UIDropDownMenu_SetInitializeFunction(dropDown, Initializer)
  UIDropDownMenu_SetDisplayMode(dropDown, "MENU")

  dropDownButton.Text:SetText(L["Start Profiling"])
  dropDownButton:SetScript("OnMouseDown", function(o, button)
    UIMenuButtonStretchMixin.OnMouseDown(dropDownButton, button)
    ToggleDropDownMenu(1, nil, dropDown, dropDownButton, 130, 20)
  end)
end

local function selectMode(self, mode)
  local parent = self:GetParent()
  local profilingFrame = parent.dropdown.Button:GetParent():GetParent():GetParent()
  profilingFrame.mode = mode
  UIDropDownMenu_SetText(profilingFrame.buttons.modeDropDown, modes[mode])
  profilingFrame:ResetBars()
  profilingFrame:RefreshBars(nil, true)
end

function WeakAurasProfilingMixin:InitModeDropDown()
  local function Initializer(dropDown, level)
    for i = 1, 2 do
      local info = UIDropDownMenu_CreateInfo()
      info.text = modes[i]
      info.func = selectMode
      info.checked = i == self.mode
      info.arg1 = i
      UIDropDownMenu_AddButton(info)
    end
  end

  local dropDown = self.buttons.modeDropDown
  UIDropDownMenu_SetWidth(dropDown, 120)
  UIDropDownMenu_JustifyText(dropDown, "LEFT")
  UIDropDownMenu_Initialize(dropDown, Initializer)
end


local lastRefresh
function WeakAurasProfilingMixin:RefreshBars(_, force)
  if force or (not lastRefresh or lastRefresh < GetTime() - 1) then
    lastRefresh = GetTime()
  else
    return
  end

  if not profileData.systems.time then
    return
  end

  local data
  if self.mode == 1 then -- auras
    data = profileData.auras
  elseif self.mode == 2 then -- systems
    data = {}
    for k, v in pairs(profileData.systems) do
      if k ~= "time" and k ~= "wa" then
        local event = unitEventToMultiUnit(k)
        if data[event] == nil then
          data[event] = CopyTable(v)
        else
          if v.elapsed then
            data[event].elapsed = (data[event].elapsed or 0) + v.elapsed
          end
          if v.spike then
            data[event].spike = (data[event].spike or 0) + v.spike
          end
        end
      end
    end
  end

  local total = TotalProfileTime(data)
  for _, name in ipairs(SortProfileMap(data)) do
    if name ~= "time" and name ~= "wa" then
      local elapsed = data[name].elapsed
      local pct = 100 * elapsed / total
      local spike = data[name].spike
      self:UpdateBar(name, elapsed, pct, spike)
    end
  end

  self.bars:Sort()
  if profileData.systems.wa then
    local timespent = profileData.systems.time.elapsed or (debugprofilestop() - profileData.systems.time.start)
    self.stats:SetText(
      ("|cFFFFFFFFTime in WA: %.2fs / %ds (%.1f%%)"):format(profileData.systems.wa.elapsed / 1000, timespent / 1000, 100 * profileData.systems.wa.elapsed / timespent)
    )
  end
end

function WeakAurasProfilingMixin:ResetBars()
  self.bars:Flush()
end

function WeakAurasProfilingMixin:UpdateBar(name, time, pct, spike)
  local elementData = self.bars:FindElementDataByPredicate(function(elementData)
    return elementData.name == name
  end)
  if elementData then
    elementData.time = time
    elementData.pct = pct
    elementData.spike = spike
    local button = WeakAurasProfilingFrame.ScrollBox:FindFrame(elementData)
    if button then
      button.time:SetText(("%.2fms"):format(time))
      button.spike:SetText(ColoredSpike(spike))
      button.progressBar:SetValue(pct)
    end
  else
    self.bars:Insert({ name = name, time = time, pct = pct, spike = spike })
  end
end

function WeakAurasProfilingMixin:SortByColumnIndex(index)
  local previousField = self.sortField
  self.sortField = COLUMN_INFO[index].attribute
  if previousField == self.sortField then
    self.sortDirection = not self.sortDirection
  else
    self.sortDirection = true
  end
  self.bars:SetSortComparator(function(lhs, rhs)
    local field = self.sortField
    local lhsF, rhsF = lhs[field] or 0, rhs[field] or 0
    if type(lhsF) == "string" then
      lhsF = lhsF:lower()
    end
    if type(rhsF) == "string" then
      rhsF = rhsF:lower()
    end
    if lhsF == rhsF then
      return lhs.name < rhs.name
    end
    if self.sortDirection then
      return lhsF > rhsF
    else
      return lhsF < rhsF
    end
  end)
end

function WeakAurasProfilingMixin:UpdateButtons()
  local b = self.buttons
  if currentProfileState == "combat" or currentProfileState == "encounter" then
    b.stop:SetText(L["Cancel"])
    b.stop:Show()
    b.start:Hide()
  elseif currentProfileState == "profiling" then
    b.stop:SetText(L["Stop"])
    b.stop:Show()
    b.start:Hide()
  else
    b.start:Show()
    b.stop:Hide()
    if profileData.systems.time then
      b.report:Show()
    end
  end
end

function WeakAurasProfilingMixin:Start()
  self:Show()
end

function WeakAurasProfilingMixin:Stop()
  WeakAuras.StopProfile()
  self:UpdateButtons()
  self:ResetBars()
end

function WeakAurasProfilingMixin:Toggle()
  if self:IsShown() then
    if currentProfileState == "profiling" then
      self:Stop()
    end
    self:Hide()
  else
    self:Start()
  end
end

function WeakAurasProfilingColumnDisplay_OnClick(self, columnIndex)
  self:GetParent():SortByColumnIndex(columnIndex)
end


-- ========================================
-- File: WeakAuras/Prototypes.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

-- Lua APIs
local tinsert, tsort = table.insert, table.sort
local tostring = tostring
local select, pairs, type = select, pairs, type
local ceil = ceil

-- WoW APIs
local UnitClass = UnitClass
local GetShapeshiftFormInfo, GetShapeshiftForm = GetShapeshiftFormInfo, GetShapeshiftForm
local GetRuneCooldown, UnitCastingInfo, UnitChannelInfo = GetRuneCooldown, UnitCastingInfo, UnitChannelInfo
local UnitDetailedThreatSituation = UnitDetailedThreatSituation
local MAX_NUM_TALENTS = MAX_NUM_TALENTS or 20

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

local SpellRange = LibStub("SpellRange-1.0")
function WeakAuras.IsSpellInRange(spellId, unit)
  return SpellRange.IsSpellInRange(spellId, unit)
end

local LibRangeCheck = LibStub("LibRangeCheck-3.0")

function WeakAuras.GetRange(unit, checkVisible)
  return LibRangeCheck:GetRange(unit, checkVisible);
end

function WeakAuras.CheckRange(unit, range, operator)
  local min, max = LibRangeCheck:GetRange(unit, true);
  if (type(range) ~= "number") then
    range = tonumber(range);
  end
  if (not range) then
    return
  end
  if (operator == "<=") then
    return (max or 999) <= range;
  else
    return (min or 0) >= range;
  end
end

local RangeCacheStrings = {friend = "", harm = "", misc = ""}
local function RangeCacheUpdate()
  local friend, harm, misc = {}, {}, {}
  local friendString, harmString, miscString

  for range in LibRangeCheck:GetFriendCheckers() do
    tinsert(friend, range)
  end
  tsort(friend)
  for range in LibRangeCheck:GetHarmCheckers() do
    tinsert(harm, range)
  end
  tsort(harm)
  for range in LibRangeCheck:GetMiscCheckers() do
    tinsert(misc, range)
  end
  tsort(misc)

  for _, key in pairs(friend) do
    friendString = (friendString and (friendString .. ", ") or "") .. key
  end
  for _, key in pairs(harm) do
    harmString = (harmString and (harmString .. ", ") or "") .. key
  end
  for _, key in pairs(misc) do
      miscString = (miscString and (miscString .. ", ") or "") .. key
  end
  RangeCacheStrings.friend, RangeCacheStrings.harm, RangeCacheStrings.misc = friendString, harmString, miscString
end

LibRangeCheck:RegisterCallback(LibRangeCheck.CHECKERS_CHANGED, RangeCacheUpdate)

function WeakAuras.UnitDetailedThreatSituation(unit1, unit2)
  local ok, aggro, status, threatpct, rawthreatpct, threatvalue = pcall(UnitDetailedThreatSituation, unit1, unit2)
  if ok then
    return aggro, status, threatpct, rawthreatpct, threatvalue
  end
end

WeakAuras.UnitCastingInfo = UnitCastingInfo

if WeakAuras.IsRetail() then
  local cacheEmpowered = {}
  WeakAuras.UnitChannelInfo = function(unit)
    local name, text, texture, startTime, endTime, isTradeSkill, notInterruptible, spellID, _, numStages = UnitChannelInfo(unit)
    if name == nil and cacheEmpowered[unit] then
      local holdAtMaxTime
      holdAtMaxTime, name, text, texture, startTime, endTime, isTradeSkill, notInterruptible, spellID, _, numStages = unpack(cacheEmpowered[unit])
      if endTime == nil
      or holdAtMaxTime == nil
      or endTime + holdAtMaxTime < GetTime()
      then -- invalid or too old data
        cacheEmpowered[unit] = nil
        return nil
      end
    end
    return name, text, texture, startTime, endTime, isTradeSkill, notInterruptible, spellID, _, numStages
  end
  local cacheEmpoweredFrame = CreateFrame("Frame")
  cacheEmpoweredFrame:RegisterEvent("UNIT_SPELLCAST_EMPOWER_START")
  cacheEmpoweredFrame:RegisterEvent("UNIT_SPELLCAST_EMPOWER_UPDATE")
  cacheEmpoweredFrame:RegisterEvent("UNIT_SPELLCAST_EMPOWER_STOP")
  cacheEmpoweredFrame:RegisterEvent("PLAYER_TARGET_CHANGED")
  cacheEmpoweredFrame:RegisterEvent("PLAYER_SOFT_FRIEND_CHANGED")
  cacheEmpoweredFrame:RegisterEvent("PLAYER_SOFT_ENEMY_CHANGED")
  cacheEmpoweredFrame:RegisterEvent("PLAYER_FOCUS_CHANGED")
  cacheEmpoweredFrame:SetScript("OnEvent", function(_, event, unit, ...)
    if Private.player_target_events[event] then
      unit = Private.player_target_events[event]
    end
    if event == "UNIT_SPELLCAST_EMPOWER_START"
    or event == "UNIT_SPELLCAST_EMPOWER_UPDATE"
    or (
      (Private.player_target_events[event])
      and (select(10, UnitChannelInfo(unit)) or 0) > 0  -- 10th arg of UnitChannelInfo is numStages for empowered spells
    )
    then
      cacheEmpowered[unit] = {GetUnitEmpowerHoldAtMaxTime(unit), UnitChannelInfo(unit)}
    else
      cacheEmpowered[unit] = nil
    end
    if unit == "player" and event == "UNIT_SPELLCAST_EMPOWER_START" or event == "UNIT_SPELLCAST_EMPOWER_STOP" then
      local castLatencyFrame = Private.frames["Cast Latency Handler"]
      if castLatencyFrame then
        castLatencyFrame:GetScript("OnEvent")(nil, event, unit, ...)
      end
    end
    Private.ScanUnitEvents(event.."_FAKE", unit, ...)
  end)
else
  WeakAuras.UnitChannelInfo = UnitChannelInfo
end

local constants = {
  nameRealmFilterDesc = L[" Filter formats: 'Name', 'Name-Realm', '-Realm'. \n\nSupports multiple entries, separated by commas\nCan use \\ to escape -."],
  instanceFilterDeprecated = L["This filter has been moved to the Location trigger. Change your aura to use the new Location trigger or join the WeakAuras Discord server for help."],
  guildFilterDesc = L["Supports multiple entries, separated by commas. Escape with \\. Prefix with '-' for negation."]
}

if WeakAuras.IsClassicOrCataOrMists() then
  ---@param unit UnitToken
  ---@return string? role
  WeakAuras.UnitRaidRole = function(unit)
    local raidID = UnitInRaid(unit)
    if raidID then
      return select(10, GetRaidRosterInfo(raidID)) or "NONE"
    end
  end
end

---@param school integer
---@return string school
function WeakAuras.SpellSchool(school)
  return Private.combatlog_spell_school_types[school] or ""
end

---@param flag integer
---@return integer index
function WeakAuras.RaidFlagToIndex(flag)
  return Private.combatlog_raidFlags[flag] or 0
end

local function get_zoneId_list()
  local currentmap_id = C_Map.GetBestMapForUnit("player")
  local instanceId = select(8, GetInstanceInfo())
  local bottomText = L["Supports multiple entries, separated by commas. To include child zone ids, prefix with 'c', e.g. 'c2022'.\nGroup Zone IDs must be prefixed with 'g', e.g. 'g277'. \nSupports Area IDs from https://wago.tools/db2/AreaTable prefixed with 'a'. \nSupports Instance IDs prefixed with 'i'.\nEntries can be prefixed with '-' to negate."]
  if not instanceId and not currentmap_id then
    return ("%s\n\n%s"):format(Private.get_zoneId_list(), bottomText)
  elseif not currentmap_id then
    return ("%s|cffffd200%s|r\n%s: %d\n\n%s"):format(Private.get_zoneId_list(), L["Current Instance"], L["Instance Id"], instanceId, bottomText)
  end
  local currentmap_info = C_Map.GetMapInfo(currentmap_id)
  local currentmap_name = currentmap_info and currentmap_info.name or ""
  local currentmap_zone_name = ""
  local parentmap_zone_name = ""
  local mapGroupId = C_Map.GetMapGroupID(currentmap_id)
  if mapGroupId then
    currentmap_zone_name = string.format("|cffffd200%s|r\n%s: g%d\n\n",
                                         L["Current Zone Group"], currentmap_name, mapGroupId)

    -- if map is in a group, its real name is (or should be?) found in GetMapGroupMembersInfo
    for k, map in ipairs(C_Map.GetMapGroupMembersInfo(mapGroupId)) do
      if map.mapID and map.mapID == currentmap_id and map.name then
        currentmap_name = map.name
        break
      end
    end
  end
  if currentmap_info and currentmap_info.parentMapID > 0  then
    local parentmap_info = C_Map.GetMapInfo(currentmap_info.parentMapID)
    local parentmap_name = parentmap_info and parentmap_info.name or ""
    parentmap_zone_name = string.format("|cffffd200%s|r\n%s: c%d\n\n",
                                         L["Parent Zone"], parentmap_name, currentmap_info.parentMapID)
  end

  return ("%s|cffffd200%s|r\n%s: %d\n\n%s%s|cffffd200%s|r\n%s: i%d\n\n%s"):format(
    Private.get_zoneId_list(),
    L["Current Zone"],
    currentmap_name,
    currentmap_id,
    parentmap_zone_name,
    currentmap_zone_name,
    L["Current Instance"],
    L["Instance Id"],
    instanceId,
    bottomText
  )
end

Private.function_strings = {
  count = [[
    return function(count)
      if(count %s %s) then
        return true
      else
        return false
      end
    end
  ]],
  count_fraction = [[
    return function(count, max)
      if max == 0 then
        return false
      end
      local fraction = count/max
      if(fraction %s %s) then
        return true
      else
        return false
      end
    end
  ]],
  always = [[
    return function()
      return true
    end
  ]]
};

local hsvFrame = CreateFrame("ColorSelect")

-- HSV transition, for a much prettier color transition in many cases
-- see http://www.wowinterface.com/forums/showthread.php?t=48236
---@param perc number
---@param r1 number
---@param g1 number
---@param b1 number
---@param a1 number
---@param r2 number
---@param g2 number
---@param b2 number
---@param a2 number
---@return number r
---@return number g
---@return number b
---@return number a
function WeakAuras.GetHSVTransition(perc, r1, g1, b1, a1, r2, g2, b2, a2)
  --get hsv color for colorA
  hsvFrame:SetColorRGB(r1, g1, b1)
  local h1, s1, v1 = hsvFrame:GetColorHSV() -- hue, saturation, value
  --get hsv color for colorB
  hsvFrame:SetColorRGB(r2, g2, b2)
  local h2, s2, v2 = hsvFrame:GetColorHSV() -- hue, saturation, value
  local h3 = floor(h1 - (h1 - h2) * perc)
  -- find the shortest arc through the color circle, then interpolate
  local diff = h2 - h1
  if diff < -180 then
    diff = diff + 360
  elseif diff > 180 then
    diff = diff - 360
  end

  h3 = (h1 + perc * diff) % 360
  local s3 = s1 - ( s1 - s2 ) * perc
  local v3 = v1 - ( v1 - v2 ) * perc
  --get the RGB values of the new color
  hsvFrame:SetColorHSV(h3, s3, v3)
  local r, g, b = hsvFrame:GetColorRGB()
  --interpolate alpha
  local a = a1 - ( a1 - a2 ) * perc
  --return the new color
  return r, g, b, a
end


Private.anim_function_strings = {
straight = [[
function(progress, start, delta)
    return start + (progress * delta)
end
]],

straightTranslate = [[
function(progress, startX, startY, deltaX, deltaY)
    return startX + (progress * deltaX), startY + (progress * deltaY)
end
]],

straightScale = [[
function(progress, startX, startY, scaleX, scaleY)
    return startX + (progress * (scaleX - startX)), startY + (progress * (scaleY - startY))
end
]],

straightColor = [[
function(progress, r1, g1, b1, a1, r2, g2, b2, a2)
    return r1 + (progress * (r2 - r1)), g1 + (progress * (g2 - g1)), b1 + (progress * (b2 - b1)), a1 + (progress * (a2 - a1))
end
]],

straightHSV = [[
function(progress, r1, g1, b1, a1, r2, g2, b2, a2)
    return WeakAuras.GetHSVTransition(progress, r1, g1, b1, a1, r2, g2, b2, a2)
end
]],

circle = [[
function(progress, startX, startY, deltaX, deltaY)
    local angle = progress * 2 * math.pi
    return startX + (deltaX * math.cos(angle)), startY + (deltaY * math.sin(angle))
end
]],

circle2 = [[
function(progress, startX, startY, deltaX, deltaY)
    local angle = progress * 2 * math.pi
    return startX + (deltaX * math.sin(angle)), startY + (deltaY * math.cos(angle))
end
]],

spiral = [[
function(progress, startX, startY, deltaX, deltaY)
    local angle = progress * 2 * math.pi
    return startX + (progress * deltaX * math.cos(angle)), startY + (progress * deltaY * math.sin(angle))
end
]],

spiralandpulse = [[
function(progress, startX, startY, deltaX, deltaY)
    local angle = (progress + 0.25) * 2 * math.pi
    return startX + (math.cos(angle) * deltaX * math.cos(angle*2)), startY + (math.abs(math.cos(angle)) * deltaY * math.sin(angle*2))
end
]],

shake = [[
function(progress, startX, startY, deltaX, deltaY)
    local prog
    if(progress < 0.25) then
        prog = progress * 4
    elseif(progress < .75) then
        prog = 2 - (progress * 4)
    else
        prog = (progress - 1) * 4
    end
    return startX + (prog * deltaX), startY + (prog * deltaY)
end
]],

starShakeDecay = [[
function(progress, startX, startY, deltaX, deltaY)
    local spokes = 10
    local fullCircles = 4

    local r = min(abs(deltaX), abs(deltaY))
    local xScale = deltaX / r
    local yScale = deltaY / r

    local deltaAngle = fullCircles *2 / spokes * math.pi
    local p = progress * spokes
    local i1 = floor(p)
    p = p - i1

    local angle1 = i1 * deltaAngle
    local angle2 = angle1 + deltaAngle

    local x1 = r * math.cos(angle1)
    local y1 = r * math.sin(angle1)

    local x2 = r * math.cos(angle2)
    local y2 = r * math.sin(angle2)

    local x, y = p * x2 + (1-p) * x1, p * y2 + (1-p) * y1
    local ease = math.sin(progress * math.pi / 2)
    return ease * x * xScale, ease * y * yScale
end
]],

bounceDecay = [[
function(progress, startX, startY, deltaX, deltaY)
    local prog = (progress * 3.5) % 1
    local bounce = math.ceil(progress * 3.5)
    local bounceDistance = math.sin(prog * math.pi) * (bounce / 4)
    return startX + (bounceDistance * deltaX), startY + (bounceDistance * deltaY)
end
]],

bounce = [[
function(progress, startX, startY, deltaX, deltaY)
    local bounceDistance = math.sin(progress * math.pi)
    return startX + (bounceDistance * deltaX), startY + (bounceDistance * deltaY)
end
]],

flash = [[
function(progress, start, delta)
    local prog
    if(progress < 0.5) then
        prog = progress * 2
    else
        prog = (progress - 1) * 2
    end
    return start + (prog * delta)
end
]],

pulse = [[
function(progress, startX, startY, scaleX, scaleY)
    local angle = (progress * 2 * math.pi) - (math.pi / 2)
    return startX + (((math.sin(angle) + 1)/2) * (scaleX - 1)), startY + (((math.sin(angle) + 1)/2) * (scaleY - 1))
end
]],

alphaPulse = [[
function(progress, start, delta)
    local angle = (progress * 2 * math.pi) - (math.pi / 2)
    return start + (((math.sin(angle) + 1)/2) * delta)
end
]],

pulseColor = [[
function(progress, r1, g1, b1, a1, r2, g2, b2, a2)
    local angle = (progress * 2 * math.pi) - (math.pi / 2)
    local newProgress = ((math.sin(angle) + 1)/2);
    return r1 + (newProgress * (r2 - r1)),
         g1 + (newProgress * (g2 - g1)),
         b1 + (newProgress * (b2 - b1)),
         a1 + (newProgress * (a2 - a1))
end
]],

pulseHSV = [[
function(progress, r1, g1, b1, a1, r2, g2, b2, a2)
    local angle = (progress * 2 * math.pi) - (math.pi / 2)
    local newProgress = ((math.sin(angle) + 1)/2);
    return WeakAuras.GetHSVTransition(newProgress, r1, g1, b1, a1, r2, g2, b2, a2)
end
]],

fauxspin = [[
function(progress, startX, startY, scaleX, scaleY)
    local angle = progress * 2 * math.pi
    return math.cos(angle) * scaleX, startY + (progress * (scaleY - startY))
end
]],

fauxflip = [[
function(progress, startX, startY, scaleX, scaleY)
    local angle = progress * 2 * math.pi
    return startX + (progress * (scaleX - startX)), math.cos(angle) * scaleY
end
]],

backandforth = [[
function(progress, start, delta)
    local prog
    if(progress < 0.25) then
        prog = progress * 4
    elseif(progress < .75) then
        prog = 2 - (progress * 4)
    else
        prog = (progress - 1) * 4
    end
    return start + (prog * delta)
end
]],

wobble = [[
function(progress, start, delta)
    local angle = progress * 2 * math.pi
    return start + math.sin(angle) * delta
end
]],

hide = [[
function()
    return 0
end
]]
};

Private.anim_presets = {
  -- Start and Finish
  slidetop = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = 0, y = 50,
    use_alpha = true,
    alpha = 0
  },
  slideleft = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = -50,
    y = 0,
    use_alpha = true,
    alpha = 0
  },
  slideright = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = 50,
    y = 0,
    use_alpha = true,
    alpha = 0
  },
  slidebottom = {
    type = "custom",
    duration = 0.25,
    use_translate = true,
    x = 0,
    y = -50,
    use_alpha = true,
    alpha = 0
  },
  fade = {
    type = "custom",
    duration = 0.25,
    use_alpha = true,
    alpha = 0
  },
  grow = {
    type = "custom",
    duration = 0.25,
    use_scale = true,
    scalex = 2,
    scaley = 2,
    use_alpha = true,
    alpha = 0
  },
  shrink = {
    type = "custom",
    duration = 0.25,
    use_scale = true,
    scalex = 0,
    scaley = 0,
    use_alpha = true,
    alpha = 0
  },
  spiral = {
    type = "custom",
    duration = 0.5,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "spiral",
    use_alpha = true,
    alpha = 0
  },
  bounceDecay = {
    type = "custom",
    duration = 1.5,
    use_translate = true,
    x = 50,
    y = 50,
    translateType = "bounceDecay",
    use_alpha = true,
    alpha = 0
  },
  starShakeDecay = {
    type = "custom",
    duration = 1,
    use_translate = true,
    x = 50,
    y = 50,
    translateType = "starShakeDecay",
    use_alpha = true,
    alpha = 0
  },
  -- Main
  shake = {
    type = "custom",
    duration = 0.5,
    use_translate = true,
    x = 10,
    y = 0,
    translateType = "circle2"
  },
  spin = {
    type = "custom",
    duration = 1,
    use_scale = true,
    scalex = 1,
    scaley = 1,
    scaleType = "fauxspin"
  },
  flip = {
    type = "custom",
    duration = 1,
    use_scale = true,
    scalex = 1,
    scaley = 1,
    scaleType = "fauxflip"
  },
  wobble = {
    type = "custom",
    duration = 0.5,
    use_rotate = true,
    rotate = 3,
    rotateType = "wobble"
  },
  pulse = {
    type = "custom",
    duration = 0.75,
    use_scale = true,
    scalex = 1.05,
    scaley = 1.05,
    scaleType = "pulse"
  },
  alphaPulse = {
    type = "custom",
    duration = 0.5,
    use_alpha = true,
    alpha = 0.5,
    alphaType = "alphaPulse"
  },
  rotateClockwise = {
    type = "custom",
    duration = 4,
    use_rotate = true,
    rotate = -360
  },
  rotateCounterClockwise = {
    type = "custom",
    duration = 4,
    use_rotate = true,
    rotate = 360
  },
  spiralandpulse = {
    type = "custom",
    duration = 6,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "spiralandpulse"
  },
  circle = {
    type = "custom",
    duration = 4,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "circle"
  },
  orbit = {
    type = "custom",
    duration = 4,
    use_translate = true,
    x = 100,
    y = 100,
    translateType = "circle",
    use_rotate = true,
    rotate = 360
  },
  bounce = {
    type = "custom",
    duration = 0.6,
    use_translate = true,
    x = 0,
    y = 25,
    translateType = "bounce"
  }
};

WeakAuras.class_ids = {}
WeakAuras.classes_sorted = {}
for classID = 1, 20 do -- GetNumClasses not supported by wow classic
  local classInfo = C_CreatureInfo.GetClassInfo(classID)
  if classInfo then
    WeakAuras.class_ids[classInfo.classFile] = classInfo.classID
    tinsert(WeakAuras.classes_sorted, classInfo.classFile)
  end
end
table.sort(WeakAuras.classes_sorted)

if WeakAuras.IsClassicOrCata() then
  ---@param index integer
  ---@param extraOption boolean?
  ---@return boolean? hasTalent
  function WeakAuras.CheckTalentByIndex(index, extraOption)
    local tab = ceil(index / MAX_NUM_TALENTS)
    local num_talent = (index - 1) % MAX_NUM_TALENTS + 1
    local name, _, _, _, rank  = Private.ExecEnv.GetTalentInfo(tab, num_talent)
    if name == nil then
      return nil
    end
    local result = rank and rank > 0
    if extraOption == 4 then
      return result
    elseif extraOption == 5 then
      return not result
    end
    return result;
  end
end

if WeakAuras.IsMists() then
  function WeakAuras.CheckTalentByIndex(index, extraOption)
    local talentInfo = C_SpecializationInfo.GetTalentInfo({
      tier = math.ceil(index / 3),
      column = (index - 1) % 3 + 1
    })
    if talentInfo == nil then
      return nil
    end
    local result = talentInfo.selected
    if extraOption == 4 then
      return result
    elseif extraOption == 5 then
      return not result
    end
    return result
  end
end

if WeakAuras.IsRetail() then
  local talentCheckFrame = CreateFrame("Frame")
  Private.frames["WeakAuras talentCheckFrame"] = talentCheckFrame
  talentCheckFrame:RegisterEvent("TRAIT_CONFIG_CREATED")
  talentCheckFrame:RegisterEvent("TRAIT_CONFIG_UPDATED")
  talentCheckFrame:RegisterEvent("PLAYER_TALENT_UPDATE")
  talentCheckFrame:RegisterEvent("PLAYER_SPECIALIZATION_CHANGED")
  talentCheckFrame:RegisterEvent("PLAYER_LOGIN")

  --- @type table<number, {rank: number, spellId: number}>
  local selectedTalentsById = {}

  Private.CheckTalentsForLoad = function(event)
    Private.StartProfileSystem("talent")
    selectedTalentsById = {}
    local configId = C_ClassTalents.GetActiveConfigID()
    if configId then
      local configInfo = C_Traits.GetConfigInfo(configId)
      if configInfo then
        for _, treeId in ipairs(configInfo.treeIDs) do
          local nodes = C_Traits.GetTreeNodes(treeId)
          for _, nodeId in ipairs(nodes) do
            local node = C_Traits.GetNodeInfo(configId, nodeId)
            if node.ID ~= 0 then
              for _, talentId in ipairs(node.entryIDs) do
                local entryInfo = C_Traits.GetEntryInfo(configId, talentId)
                if entryInfo.definitionID then
                  local definitionInfo = C_Traits.GetDefinitionInfo(entryInfo.definitionID)
                  local rank = node.activeRank
                  if node.activeEntry then
                    rank = node.activeEntry.entryID == talentId and node.activeEntry.rank or 0
                  end
                  if node.subTreeID then
                    local subTreeInfo = C_Traits.GetSubTreeInfo(configId, node.subTreeID)
                    if not subTreeInfo.isActive then
                      rank = 0
                    end
                  end
                  selectedTalentsById[talentId] = {
                    rank = rank,
                    spellId = definitionInfo.spellID
                  }
                end
              end
            end
          end
        end
      end
    end
    Private.ScanForLoads(nil, "WA_TALENT_UPDATE")
    Private.ScanEvents("WA_TALENT_UPDATE")

    if (event == "WA_DELAYED_PLAYER_ENTERING_WORLD" or event == "PLAYER_TALENT_UPDATE") then
      C_Timer.After(1, function()
        local spec = Private.ExecEnv.GetSpecialization()
        if type(spec) == "number" and spec > 0 then
          local specId = Private.ExecEnv.GetSpecializationInfo(spec)
          if specId then
            Private.talentInfo[specId] = nil
            Private.GetTalentData(specId)
          end
        end
      end)
    end

    Private.StopProfileSystem("talent")
  end

  talentCheckFrame:SetScript("OnEvent", Private.CheckTalentsForLoad)

  ---@param talentId integer
  ---@return string? spellName
  ---@return number? icon
  ---@return number? spellId
  ---@return number? rank
  function WeakAuras.GetTalentById(talentId)
    if selectedTalentsById[talentId] then
      local spellName, _, icon = Private.ExecEnv.GetSpellInfo(selectedTalentsById[talentId].spellId)
      return spellName, icon, selectedTalentsById[talentId].spellId, selectedTalentsById[talentId].rank
    end
  end

  ---@param talentId integer
  ---@return boolean hasTalent
  function WeakAuras.CheckTalentId(talentId)
    return selectedTalentsById[talentId] and selectedTalentsById[talentId].rank > 0
  end
end

---@param spellId integer
---@return boolean hasTalent
---@return number? spellid
function WeakAuras.CheckPvpTalentBySpellId(spellId)
  local checkTalentSlotInfo = C_SpecializationInfo.GetPvpTalentSlotInfo(1)
  if checkTalentSlotInfo then
    for i = 1, 3 do
      local talentSlotInfo = C_SpecializationInfo.GetPvpTalentSlotInfo(i)
      if talentSlotInfo and talentSlotInfo.selectedTalentID then
        local selectedSpellId = select(6, GetPvpTalentInfoByID(talentSlotInfo.selectedTalentID))
        if selectedSpellId == spellId then
          return true, spellId
        end
      end
    end
    return false, spellId
  end
  return false
end

---@param loadids string
---@param currentId string
---@return boolean result
function WeakAuras.CheckNumericIds(loadids, currentId)
  if (not loadids or not currentId) then
    return false;
  end

  local searchFrom = 0;
  local startI, endI = string.find(loadids, currentId, searchFrom);
  while (startI) do
    searchFrom = endI + 1; -- start next search from end
    if (startI == 1 or tonumber(string.sub(loadids, startI - 1, startI - 1)) == nil) then
      -- Either right at start, or character before is not a number
      if (endI == string.len(loadids) or tonumber(string.sub(loadids, endI + 1, endI + 1)) == nil) then
        return true;
      end
    end
    startI, endI = string.find(loadids, currentId, searchFrom);
  end
  return false;
end

---@param info any?
---@param val any
---@return boolean isNumeric
function WeakAuras.ValidateNumeric(info, val)
  if val ~= nil and val ~= "" and (not tonumber(val) or tonumber(val) >= 2^31) then
    return false;
  end
  return true
end

---@param info any?
---@param val any
---@return boolean isTime
function WeakAuras.ValidateTime(info, val)
  if val ~= nil and val ~= "" then
    if not tonumber(val) then
      if val:sub(1,1) == "-" then
        val = val:sub(2, #val)
      end
      return (val:match("^%d+:%d+:[%d%.]+$") or val:match("^%d+:[%d+%.]+$")) and true or false
    elseif tonumber(val) >= 2^31 then
      return false
    end
  end
  return true
end

---@param val number|string
---@return number? result
function WeakAuras.TimeToSeconds(val)
  if tonumber(val) then
    return tonumber(val)
  else
    local sign = 1
    if val:sub(1,1) == "-" then
      sign = -1
      val = val:sub(2, #val)
    end
    local h, m, s = val:match("^(%d+):(%d+):([%d%.]+)$")
    if h and m and s then
      return (h*3600 + m*60 + s) * sign
    else
      local m, s = val:match("^(%d+):([%d%.]+)$")
      if m and s then
        return (m*60 + s) * sign
      end
    end
  end
end

Private.tinySecondFormat = function(value)
  if type(value) == "string" then value = tonumber(value) end
  if type(value) == "number" then
     local negative = value < 0
     value = math.abs(value)
     local fraction = value - math.floor(value)
     local ret
     if value > 3600 then
        ret = ("%i:%02i:%02i"):format(math.floor(value / 3600), math.floor((value % 3600) / 60), value % 60)
     elseif value > 60 then
        ret = ("%i:%02i"):format(math.floor(value / 60), value % 60)
     else
        ret = ("%i"):format(value)
     end
     local negSign = negative and "-" or ""
     if fraction > 0 then
        return negSign .. ret .. tostring(Round(fraction * 100) / 100):sub(2)
     else
        return negSign .. ret
     end
  end
end

function Private.ExecEnv.ParseStringCheck(input)
  if not input then return end
  local matcher = {
    entries = {},
    negativeEntries = {},
    Check = function(self, e)
      return false
    end,
    CheckBoth = function(self, e)
      return self.entries[e] and not self.negativeEntries[e]
    end,
    CheckPositive = function(self, e)
      return self.entries[e]
    end,
    CheckNegative = function(self, e)
      return not self.negativeEntries[e]
    end,
    Add = function(self, e, negate)
      if negate then
        self.negativeEntries[e] = true
      else
        self.entries[e] = true
      end
    end
  }

  local start = 1
  local escaped = false
  local partial = ""
  local negate = false
  for i = 1, #input do
    local c = input:sub(i, i)
    if escaped then
      escaped = false
    elseif c == '\\' then
      partial = partial .. input:sub(start, i - 1)
      start = i + 1
      escaped = true
    elseif c == "," then
      matcher:Add(partial .. input:sub(start, i - 1):trim(), negate)
      start = i + 1
      partial = ""
      negate = false
    elseif c == "-" and partial:trim() == "" and input:sub(start, i - 1):trim() == "" then
      start = i + 1
      negate = true
    end
  end
  matcher:Add(partial .. input:sub(start, #input):trim(), negate)

  -- Update check function
  if next(matcher.entries) and next(matcher.negativeEntries) then
    matcher.Check = matcher.CheckBoth
  elseif next(matcher.entries) then
    matcher.Check = matcher.CheckPositive
  elseif next(matcher.negativeEntries) then
    matcher.Check = matcher.CheckNegative
  end

  return matcher
end

---@param info any?
---@param val string
---@return boolean result
function WeakAuras.ValidateNumericOrPercent(info, val)
  if val ~= nil and val ~= "" then
    local index = val:find("%% *$")
    local number = index and tonumber(val:sub(1, index-1)) or tonumber(val)
    if(not number or number >= 2^31) then
      return false;
    end
  end
  return true
end

function Private.ExecEnv.CheckMPlusAffixIds(loadids, currentId)
  if (not loadids or not currentId) or type(currentId) ~= "table" then
    return false
  end
  for i=1, #currentId do
    if loadids == currentId[i] then
      return true
    end
  end
  return false
end

function Private.ExecEnv.CheckGroupMemberType(loadSetting, currentFlags)
  if loadSetting == "LEADER" then
    return bit.band(currentFlags, 1) == 1
  elseif loadSetting == "ASSIST" then
    return bit.band(currentFlags, 2) == 2
  else
    return currentFlags == 0
  end
end

function Private.ExecEnv.CheckChargesDirection(direction, triggerDirection)
  return triggerDirection == "CHANGED"
    or (triggerDirection == "GAINED" and direction > 0)
    or (triggerDirection == "LOST" and direction < 0)
end

function Private.ExecEnv.CheckCombatLogFlags(flags, flagToCheck)
  if type(flags) ~= "number" then return end
  if(flagToCheck == "Mine") then
    return bit.band(flags, COMBATLOG_OBJECT_AFFILIATION_MINE) > 0
  elseif (flagToCheck == "InGroup") then
    return bit.band(flags, COMBATLOG_OBJECT_AFFILIATION_OUTSIDER) == 0
  elseif (flagToCheck == "InParty") then
    return bit.band(flags, COMBATLOG_OBJECT_AFFILIATION_PARTY) > 0
  elseif (flagToCheck == "NotInGroup") then
    return bit.band(flags, COMBATLOG_OBJECT_AFFILIATION_OUTSIDER) > 0
  end
end

function Private.ExecEnv.CheckCombatLogFlagsReaction(flags, flagToCheck)
  if type(flags) ~= "number" then return end
  if (flagToCheck == "Hostile") then
    return bit.band(flags, 64) ~= 0;
  elseif (flagToCheck == "Neutral") then
    return bit.band(flags, 32) ~= 0;
  elseif (flagToCheck == "Friendly") then
    return bit.band(flags, 16) ~= 0;
  end
end

local objectTypeToBit = {
  Object = 16384,
  Guardian = 8192,
  Pet = 4096,
  NPC = 2048,
  Player = 1024,
}

function Private.ExecEnv.CheckCombatLogFlagsObjectType(flags, flagToCheck)
  if type(flags) ~= "number" then return end
  local bitToCheck = objectTypeToBit[flagToCheck]
  if not bitToCheck then return end
  return bit.band(flags, bitToCheck) ~= 0;
end

function Private.ExecEnv.CheckRaidFlags(flags, flagToCheck)
  flagToCheck = tonumber(flagToCheck)
  if not flagToCheck or not flags then return end --bailout
  if flagToCheck == 0 then --no raid mark
    return bit.band(flags, COMBATLOG_OBJECT_RAIDTARGET_MASK) == 0
  elseif flagToCheck == 9 then --any raid mark
    return bit.band(flags, COMBATLOG_OBJECT_RAIDTARGET_MASK) > 0
  else -- specific raid mark
    return bit.band(flags, _G['COMBATLOG_OBJECT_RAIDTARGET'..flagToCheck]) > 0
  end
end

local function IsSpellKnownOrOverridesAndBaseIsKnown(spell, pet)
  if spell == 0 then return false end
  if IsSpellKnown(spell, pet) then
    return true
  end
  local baseSpell = FindBaseSpellByID(spell)
  if baseSpell and baseSpell ~= spell and baseSpell ~= 0 then
    if FindSpellOverrideByID(baseSpell) == spell then
      return IsSpellKnown(baseSpell, pet)
    end
  end
end

---@param spell string|number
---@return boolean result
function WeakAuras.IsPlayerSpellOrOverridesAndBaseIsPlayerSpell(spell)
  if spell == 0 or spell >= 2^31 then return false end
  if IsPlayerSpell(spell) then
    return true
  end
  local baseSpell = FindBaseSpellByID(spell)
  if baseSpell and baseSpell ~= spell and baseSpell ~= 0 then
    if FindSpellOverrideByID(baseSpell) == spell then
      return IsPlayerSpell(baseSpell)
    end
  end
  return false
end

---@private
function WeakAuras.IsSpellKnownForLoad(spell, exact)
  if spell == 0 or spell >= 2^31 then return false end
  local result = IsPlayerSpell(spell)
                 or IsSpellKnownOrOverridesAndBaseIsKnown(spell, false)
                 or IsSpellKnownOrOverridesAndBaseIsKnown(spell, true)
  if exact or result then
    return result
  end
  -- Dance through the spellname to the current spell id
  local spellName = Private.ExecEnv.GetSpellName(spell or "")
  if (spellName) then
    local otherSpell = select(7, Private.ExecEnv.GetSpellInfo(spellName))
    if otherSpell and otherSpell ~= spell then
      return WeakAuras.IsSpellKnownForLoad(otherSpell)
    end
  end
end

---@param spell string|number
---@param pet boolean?
---@return boolean result
function WeakAuras.IsSpellKnown(spell, pet)
  if spell == 0 or spell >= 2^31 then return false end
  if (pet) then
    return IsSpellKnownOrOverridesAndBaseIsKnown(spell, true)
  end
  return IsPlayerSpell(spell) or IsSpellKnownOrOverridesAndBaseIsKnown(spell, false)
end

---@param spell string|number
---@return boolean result
function WeakAuras.IsSpellKnownIncludingPet(spell)
  if (not tonumber(spell)) then
    spell = select(7, Private.ExecEnv.GetSpellInfo(spell));
  end
  if (not spell) then
    return false;
  end
  return WeakAuras.IsSpellKnown(spell, false) or WeakAuras.IsSpellKnown(spell, true)
end

if WeakAuras.IsMists() then
  function WeakAuras.IsGlyphActive(glyphID)
    local numSlots = NUM_GLYPH_SLOTS or 6 -- fallback if not defined
    for slot = 1, numSlots do
      local enabled, _, _, _ , _, id = GetGlyphSocketInfo(slot)
      if enabled and id == glyphID then
        return true
      end
    end
    return false
  end
end

do
-- A small helper to fire WA_DELAYED_SET_INFORMATION if GetNumSetItemsEquipped couldn't give
-- accurate information due to item information being unavailable
  local waitingFor = { }

  local itemDataLoadFrame = CreateFrame("Frame")

  itemDataLoadFrame:SetScript("OnEvent", function(frame, event, itemId, success)
    if waitingFor[itemId] then
      waitingFor[itemId] = nil
      if success then
        Private.ScanEvents("WA_DELAYED_SET_INFORMATION")
      end
      if next(waitingFor) == nil then
        itemDataLoadFrame:UnregisterEvent("GET_ITEM_INFO_RECEIVED")
      end
    end
  end)

  -- Returns the set id OR causes WA_DELAYED_SET_INFORMATION after the item information is available
  function Private.GetSetId(itemId)
    if itemId  then
      local name, _, _, _, _, _, _, _, _, _, _, _, _, _, _, setID = C_Item.GetItemInfo(itemId)
      if not name then
        if next(waitingFor) == nil then
          itemDataLoadFrame:RegisterEvent("GET_ITEM_INFO_RECEIVED")
        end
        waitingFor[itemId] = true
      else
        return setID
      end
    end
  end

end

---@param setID integer
---@return integer? quantity
---@return integer? maxQuantity
---@return string? setName
function WeakAuras.GetNumSetItemsEquipped(setID)
  if not setID or not type(setID) == "number" then return end
  local equipped = 0
  local setName = C_Item.GetItemSetInfo(setID)
  for i = 1, 18 do
    local item = GetInventoryItemID("player", i)
    if Private.GetSetId(item) == setID then
      equipped = equipped + 1
    end
  end
  return equipped, 18, setName
end

---@return number result
function WeakAuras.GetEffectiveAttackPower()
  local base, pos, neg = UnitAttackPower("player")
  return base + pos + neg
end

--- @type fun(): number
function WeakAuras.GetEffectiveSpellPower()
  -- Straight from the PaperDoll
  local spellPower = 0
  for i = 2, MAX_SPELL_SCHOOLS or 7 do
    spellPower = max(spellPower, GetSpellBonusDamage(i))
  end
  return spellPower
end

local function valuesForTalentFunction(trigger)
  return function()
    local single_class = Private.checkForSingleLoadCondition(trigger, "class")
    if not single_class then
      single_class = select(2, UnitClass("player"));
    end

    -- If a single specific class was found, load the specific list for it
    if WeakAuras.IsRetail() then
      local single_class_and_spec = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
      if single_class_and_spec then
        return Private.GetTalentData(single_class_and_spec)
      else
        -- this should never happen
        return {}
      end
    elseif WeakAuras.IsCataClassic() then
      return Private.talentInfo[single_class]
    elseif WeakAuras.IsMists() then
      return Private.talentInfo[single_class]
    else -- classic & tbc
      if single_class and Private.talent_types_specific[single_class] then
        return Private.talent_types_specific[single_class]
      else
        return Private.talent_types
      end
    end
  end
end

local function valuesForHeroTalentFunction(trigger)
  return function()
    local single_class_and_spec = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
    if single_class_and_spec then
      return select(2, Private.GetTalentData(single_class_and_spec))
    else
      -- this should never happen
      return {}
    end
  end
end

---helper to check if a condition is checked and have a single value, and return it
---@param trigger table
---@param name string
---@param validateFn? fun(value: any): boolean values that do not validate are ignored
---@return any
function Private.checkForSingleLoadCondition(trigger, name, validateFn)
  local use_name = "use_"..name
  local trigger_use_name = trigger[use_name]
  local trigger_name = trigger[name]
  if trigger_use_name == true
  and trigger_name
  and trigger_name.single ~= nil
  and (validateFn == nil or validateFn(trigger_name.single))
  then
    return trigger_name.single
  end
  if trigger_use_name == false and trigger_name and trigger_name.multi ~= nil then
    local count = 0
    local key
    for k, v in pairs(trigger_name.multi) do
      if v ~= nil
      and (validateFn == nil or validateFn(k))
      then
        count = count + 1
        key = k
      end
    end
    if count == 1 then
      return key
    end
  end
end

Private.load_prototype = {
  -- Each entry
  --   name: name of argument for load function/option for options/setting in saved data
  --   Options data
  --     display: name to be displayed in the options
  --     type: type to be used for the options
  --     width: width in the options
  --     hidden: whether the option is shown in the options, defaults to false
  --   Load Function Data
  --     enable: whether the test should be tested or not, defaults to true
  --     test: overrides the default test
  --     init: whether the argument should be a function parameter or not. "arg" for yes. Defaults to no argument
  --     events: the events on which the test must be reevaluated
  --     optional: whether the test is relevant for the options classification between loaded and unloaded, defaults to false
  args = {
    {
      name ="generalTitle",
      display = L["General"],
      type = "description",
    },
    {
      name = "combat",
      display = L["In Combat"],
      type = "tristate",
      width = WeakAuras.normalWidth,
      init = "arg",
      optional = true,
      events = {"PLAYER_REGEN_DISABLED", "PLAYER_REGEN_ENABLED"}
    },
    {
      name = "never",
      display = L["Never"],
      type = "toggle",
      width = WeakAuras.normalWidth,
      test = "false",
    },
    {
      name = "alive",
      display = L["Alive"],
      type = "tristate",
      init = "arg",
      width = WeakAuras.normalWidth,
      optional = true,
      events = {"PLAYER_DEAD", "PLAYER_ALIVE", "PLAYER_UNGHOST"}
    },
    {
      name = "encounter",
      display = L["In Encounter"],
      type = "tristate",
      width = WeakAuras.normalWidth,
      init = "arg",
      optional = true,
      events = {"ENCOUNTER_START", "ENCOUNTER_END"}
    },
    {
      name = "warmode",
      display = L["In War Mode"],
      type = "tristate",
      init = WeakAuras.IsRetail() and "arg" or nil,
      width = WeakAuras.normalWidth,
      optional = true,
      enable = WeakAuras.IsRetail(),
      hidden = not WeakAuras.IsRetail(),
      events = {"PLAYER_FLAGS_CHANGED"}
    },
    {
      name = "petbattle",
      display = L["In Pet Battle"],
      type = "tristate",
      init = WeakAuras.IsMistsOrRetail() and "arg" or nil,
      width = WeakAuras.normalWidth,
      optional = true,
      enable = WeakAuras.IsMistsOrRetail(),
      hidden = not WeakAuras.IsMistsOrRetail(),
      events = {"PET_BATTLE_OPENING_START", "PET_BATTLE_CLOSE"}
    },
    {
      name = "vehicle",
      display = (WeakAuras.IsClassicEra()) and L["On Taxi"] or L["In Vehicle"],
      type = "tristate",
      init = "arg",
      width = WeakAuras.normalWidth,
      optional = true,
      events = (WeakAuras.IsClassicEra()) and {"UNIT_FLAGS"}
               or {"VEHICLE_UPDATE", "UNIT_ENTERED_VEHICLE", "UNIT_EXITED_VEHICLE", "UPDATE_OVERRIDE_ACTIONBAR", "UNIT_FLAGS"}
    },
    {
      name = "vehicleUi",
      display = L["Has Vehicle UI"],
      type = "tristate",
      init = WeakAuras.IsCataOrMistsOrRetail() and "arg" or nil,
      width = WeakAuras.normalWidth,
      optional = true,
      enable = WeakAuras.IsCataOrMistsOrRetail(),
      hidden = not WeakAuras.IsCataOrMistsOrRetail(),
      events = {"VEHICLE_UPDATE", "UNIT_ENTERED_VEHICLE", "UNIT_EXITED_VEHICLE", "UPDATE_OVERRIDE_ACTIONBAR", "UPDATE_VEHICLE_ACTIONBAR"}
    },
    {
      name = "dragonriding",
      display = L["Skyriding"],
      type = "tristate",
      init = WeakAuras.IsRetail() and "arg" or nil,
      width = WeakAuras.normalWidth,
      optional = true,
      enable = WeakAuras.IsRetail(),
      hidden = not WeakAuras.IsRetail(),
      events = {"WA_DRAGONRIDING_UPDATE"}
    },
    {
      name = "mounted",
      display = L["Mounted"],
      type = "tristate",
      init = "arg",
      width = WeakAuras.normalWidth,
      optional = true,
      events = {"PLAYER_MOUNT_DISPLAY_CHANGED"}
    },
    {
      name = "hardcore",
      display = L["Hardcore"],
      type = "tristate",
      init = WeakAuras.IsClassicEra() and "arg" or nil,
      width = WeakAuras.normalWidth,
      enable = WeakAuras.IsClassicEra(),
      hidden = not WeakAuras.IsClassicEra(),
    },
    {
      name = "engraving",
      display = L["Season of Discovery"],
      type = "tristate",
      init = WeakAuras.IsClassicEra() and "arg" or nil,
      width = WeakAuras.normalWidth,
      enable = WeakAuras.IsClassicEra(),
      hidden = not WeakAuras.IsClassicEra(),
    },
    {
      name ="playerTitle",
      display = L["Player"],
      type = "description",
    },
    {
      name = "class",
      display = L["Player Class"],
      type = "multiselect",
      values = "class_types",
      init = not WeakAuras.IsRetail() and "arg" or nil,
      enable = not WeakAuras.IsRetail(),
      hidden = WeakAuras.IsRetail(),
    },
    {
      name = "class_and_spec",
      display = L["Class and Specialization"],
      type = "multiselect",
      values = "spec_types_all",
      init = WeakAuras.IsCataOrMistsOrRetail() and "arg" or nil,
      enable = WeakAuras.IsCataOrMistsOrRetail(),
      hidden = not WeakAuras.IsCataOrMistsOrRetail(),
      events = {"PLAYER_TALENT_UPDATE"},
      sorted = true,
      sortOrder = Private.specs_sorted,
    },
    {
      name = "talent",
      display = L["Talent"],
      type = "multiselect",
      values = valuesForTalentFunction,
      test = WeakAuras.IsRetail() and "WeakAuras.CheckTalentId(%d) == (%d == 4)" or "WeakAuras.CheckTalentByIndex(%d, %d)",
      enableTest = function(trigger, talent, arg)
        if WeakAuras.IsRetail() then
          local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
          if specId then
            local talentData = Private.GetTalentData(specId)
            if type(talentData) == "table" then
              for _, v in ipairs(talentData) do
                if talent == v[1] then
                  return true
                end
              end
            end
          end
        else
          return WeakAuras.CheckTalentByIndex(talent, arg) ~= nil
        end
      end,
      multiConvertKey = WeakAuras.IsRetail() and function(trigger, key)
        local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
        if specId then
          local talentData = Private.GetTalentData(specId)
          if type(talentData) == "table" and talentData[key] then
            return talentData[key][1]
          end
        end
      end or nil,
      events = (WeakAuras.IsClassicOrCataOrMists() and {"CHARACTER_POINTS_CHANGED", "PLAYER_TALENT_UPDATE", "ACTIVE_TALENT_GROUP_CHANGED"})
        or (WeakAuras.IsRetail() and {"WA_TALENT_UPDATE"}),
      inverse = function(load)
        -- Check for multi select!
        return WeakAuras.IsClassicEra() and (load.talent_extraOption == 2 or load.talent_extraOption == 3)
      end,
      extraOption = WeakAuras.IsClassicEra() and {
        display = "",
        values = function()
          return Private.talent_extra_option_types
        end
      },
      control = WeakAuras.IsCataOrMistsOrRetail() and "WeakAurasMiniTalent" or nil,
      multiNoSingle = WeakAuras.IsCataOrMistsOrRetail(), -- no single mode
      multiTristate = WeakAuras.IsCataOrMistsOrRetail(), -- values can be true/false/nil
      multiAll = WeakAuras.IsCataOrMistsOrRetail(), -- require all tests
      orConjunctionGroup = WeakAuras.IsCataOrMistsOrRetail() and "talent",
      multiUseControlWhenFalse = WeakAuras.IsCataOrMistsOrRetail(),
      enable = function(trigger)
        return WeakAuras.IsClassicEra()
            or (WeakAuras.IsCataOrMists() and Private.checkForSingleLoadCondition(trigger, "class") ~= nil)
            or (WeakAuras.IsRetail() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil)
      end,
      hidden = function(trigger)
        return not (
            WeakAuras.IsClassicEra()
            or (WeakAuras.IsCataOrMists() and Private.checkForSingleLoadCondition(trigger, "class") ~= nil)
            or (WeakAuras.IsRetail() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil))
      end,
    },
    {
      name = "talent2",
      display = WeakAuras.IsCataOrMistsOrRetail() and L["Or Talent"] or L["And Talent"],
      type = "multiselect",
      values = valuesForTalentFunction,
      test = WeakAuras.IsRetail() and "WeakAuras.CheckTalentId(%d) == (%d == 4)" or "WeakAuras.CheckTalentByIndex(%d, %d)",
      enableTest = function(trigger, talent, arg)
        if WeakAuras.IsRetail() then
          local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
          if specId then
            local talentData = Private.GetTalentData(specId)
            if type(talentData) == "table" then
              for _, v in ipairs(talentData) do
                if talent == v[1] then
                  return true
                end
              end
            end
          end
        else
          return WeakAuras.CheckTalentByIndex(talent, arg) ~= nil
        end
      end,
      multiConvertKey = WeakAuras.IsRetail() and function(trigger, key)
        local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
        if specId then
          local talentData = Private.GetTalentData(specId)
          if type(talentData) == "table" and talentData[key] then
            return talentData[key][1]
          end
        end
      end or nil,
      events = (WeakAuras.IsClassicEra() and {"CHARACTER_POINTS_CHANGED"})
        or (WeakAuras.IsCataOrMists() and {"CHARACTER_POINTS_CHANGED", "PLAYER_TALENT_UPDATE"})
        or (WeakAuras.IsRetail() and {"WA_TALENT_UPDATE"}),
      inverse = function(load)
        return WeakAuras.IsClassicEra() and (load.talent2_extraOption == 2 or load.talent2_extraOption == 3)
      end,
      extraOption = WeakAuras.IsClassicEra() and {
        display = "",
        values = function()
          return Private.talent_extra_option_types
        end,
      },
      control = WeakAuras.IsCataOrMistsOrRetail() and "WeakAurasMiniTalent" or nil,
      multiNoSingle = WeakAuras.IsCataOrMistsOrRetail(), -- no single mode
      multiTristate = WeakAuras.IsCataOrMistsOrRetail(), -- values can be true/false/nil
      multiAll = WeakAuras.IsCataOrMistsOrRetail(), -- require all tests
      orConjunctionGroup  = WeakAuras.IsCataOrMistsOrRetail() and "talent",
      multiUseControlWhenFalse = WeakAuras.IsCataOrMistsOrRetail(),
      enable = function(trigger)
        return (trigger.use_talent ~= nil or trigger.use_talent2 ~= nil) and (
          WeakAuras.IsClassicEra()
          or (WeakAuras.IsCataOrMists() and Private.checkForSingleLoadCondition(trigger, "class") ~= nil)
          or (WeakAuras.IsRetail() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil)
        )
      end,
      hidden = function(trigger)
        return not((trigger.use_talent ~= nil or trigger.use_talent2 ~= nil) and (
          WeakAuras.IsClassicEra()
          or (WeakAuras.IsCataOrMists() and Private.checkForSingleLoadCondition(trigger, "class") ~= nil)
          or (WeakAuras.IsRetail() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil))
        )
      end,
    },
    {
      name = "talent3",
      display = WeakAuras.IsCataOrMistsOrRetail() and L["Or Talent"] or L["And Talent"],
      type = "multiselect",
      values = valuesForTalentFunction,
      test = WeakAuras.IsRetail() and "WeakAuras.CheckTalentId(%d) == (%d == 4)" or "WeakAuras.CheckTalentByIndex(%d, %d)",
      enableTest = function(trigger, talent, arg)
        if WeakAuras.IsRetail() then
          local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
          if specId then
            local talentData = Private.GetTalentData(specId)
            if type(talentData) == "table" then
              for _, v in ipairs(talentData) do
                if talent == v[1] then
                  return true
                end
              end
            end
          end
        else
          return WeakAuras.CheckTalentByIndex(talent, arg) ~= nil
        end
      end,
      multiConvertKey = WeakAuras.IsRetail() and function(trigger, key)
        local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
        if specId then
          local talentData = Private.GetTalentData(specId)
          if type(talentData) == "table" and talentData[key] then
            return talentData[key][1]
          end
        end
      end or nil,
      events = (WeakAuras.IsClassicEra() and {"CHARACTER_POINTS_CHANGED"})
        or (WeakAuras.IsCataOrMists() and {"CHARACTER_POINTS_CHANGED", "PLAYER_TALENT_UPDATE"})
        or (WeakAuras.IsRetail() and {"WA_TALENT_UPDATE"}),
      inverse = function(load)
        return WeakAuras.IsClassicEra() and (load.talent3_extraOption == 2 or load.talent3_extraOption == 3)
      end,
      extraOption = WeakAuras.IsClassicEra() and {
        display = "",
        values = function()
          return Private.talent_extra_option_types
        end,
      },
      control = WeakAuras.IsCataOrMistsOrRetail() and "WeakAurasMiniTalent" or nil,
      multiNoSingle = WeakAuras.IsCataOrMists(), -- no single mode
      multiTristate = WeakAuras.IsCataOrMistsOrRetail(), -- values can be true/false/nil
      multiAll = WeakAuras.IsCataOrMistsOrRetail(), -- require all tests
      orConjunctionGroup  = WeakAuras.IsCataOrMistsOrRetail() and "talent",
      multiUseControlWhenFalse = WeakAuras.IsCataOrMistsOrRetail(),
      enable = function(trigger)
        return ((trigger.use_talent ~= nil and trigger.use_talent2 ~= nil) or trigger.use_talent3 ~= nil) and (
          WeakAuras.IsClassicEra()
          or (WeakAuras.IsCataOrMists() and Private.checkForSingleLoadCondition(trigger, "class") ~= nil)
          or (WeakAuras.IsRetail() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil)
        )
      end,
      hidden = function(trigger)
        return not(((trigger.use_talent ~= nil and trigger.use_talent2 ~= nil) or trigger.use_talent3 ~= nil) and (
          WeakAuras.IsClassicEra()
          or (WeakAuras.IsCataOrMists() and Private.checkForSingleLoadCondition(trigger, "class") ~= nil)
          or (WeakAuras.IsRetail() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil)
        ))
      end
    },
    {
      name = "herotalent",
      display = L["Hero Talent"],
      type = "multiselect",
      values = valuesForHeroTalentFunction,
      test = "WeakAuras.CheckTalentId(%d) == (%d == 4)",
      enableTest = function(trigger, talent, arg)
        local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
        if specId then
          local _, heroData = Private.GetTalentData(specId)
          if type(heroData) == "table" then
            for _, v in ipairs(heroData) do
              if talent == v[1] then
                return true
              end
            end
          end
        end
      end,
      multiConvertKey = function(trigger, key)
        local specId = Private.checkForSingleLoadCondition(trigger, "class_and_spec")
        if specId then
          local _, heroData = Private.GetTalentData(specId)
          if type(heroData) == "table" and type(heroData[key]) == "table" then
            return heroData[key][1]
          end
        end
      end or nil,
      events = {"WA_TALENT_UPDATE"},
      control = "WeakAurasMiniTalent",
      multiNoSingle = true, -- no single mode
      multiTristate = true, -- values can be true/false/nil
      multiAll = true, -- require all tests
      orConjunctionGroup = "herotalent",
      multiUseControlWhenFalse = true,
      enable = function(trigger)
        return WeakAuras.IsTWW() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil
      end,
      hidden = function(trigger)
        return not (WeakAuras.IsTWW() and Private.checkForSingleLoadCondition(trigger, "class_and_spec") ~= nil)
      end,
    },
    {
      name = "pvptalent",
      display = L["PvP Talent selected"],
      type = "multiselect",
      values = function(trigger)
        return function()
          local single_class;
          -- First check to use if the class load is on multi-select with only one class selected
          if(trigger.use_class == false and trigger.class and trigger.class.multi) then
            local num_classes = 0;
            for class in pairs(trigger.class.multi) do
              single_class = class;
              num_classes = num_classes + 1;
            end
            if(num_classes ~= 1) then
              single_class = nil;
            end
          end
          -- If that is not the case, see if it is on single-select
          if((not single_class) and trigger.use_class and trigger.class and trigger.class.single) then
            single_class = trigger.class.single
          end

          if (trigger.use_class == nil) then -- no class selected, fallback to current class
            single_class = select(2, UnitClass("player"));
          end

          local single_spec;
          if (single_class) then
            if(trigger.use_spec == false and trigger.spec and trigger.spec.multi) then
              local num_specs = 0;
              for spec in pairs(trigger.spec.multi) do
                single_spec = spec;
                num_specs = num_specs + 1;
              end
              if (num_specs ~= 1) then
                single_spec = nil;
              end
            end
          end
          if ((not single_spec) and trigger.use_spec and trigger.spec and trigger.spec.single) then
            single_spec = trigger.spec.single;
          end

          if (trigger.use_spec == nil) then
            single_spec = Private.ExecEnv.GetSpecialization();
          end

          -- If a single specific class was found, load the specific list for it
          if not single_class then
            single_class = select(2, UnitClass("player"))
          end
          if not single_spec then
            single_spec = Private.ExecEnv.GetSpecialization()
          end

          if(single_class and Private.pvp_talent_types_specific[single_class]
            and single_spec and Private.pvp_talent_types_specific[single_class][single_spec]) then
            return Private.pvp_talent_types_specific[single_class][single_spec];
          else
            return {}
          end
        end
      end,
      test = "WeakAuras.CheckPvpTalentBySpellId(%d)",
      enable = WeakAuras.IsRetail(),
      hidden = not WeakAuras.IsRetail(),
      events = {"PLAYER_PVP_TALENT_UPDATE"}
    },
    {
      name = "glyph",
      display = L["Glyph"],
      type = "multiselect",
      values = "glyph_types",
      sorted = true,
      sortOrder = Private.glyph_sorted or {},
      test = "WeakAuras.IsGlyphActive(%s)",
      events = {"GLYPH_ADDED", "GLYPH_REMOVED", "GLYPH_UPDATED", "USE_GLYPH"},
      enable = WeakAuras.IsMists(),
    },
    {
      name = "spellknown",
      display = L["Spell Known"],
      type = "spell",
      test = "WeakAuras.IsSpellKnownForLoad(%s, %s)",
      events = WeakAuras.IsCataOrMists() and {"SPELLS_CHANGED", "UNIT_PET", "PLAYER_TALENT_UPDATE"} or {"SPELLS_CHANGED", "UNIT_PET"},
      showExactOption = true
    },
    {
      name = "not_spellknown",
      display = WeakAuras.newFeatureString .. L["|cFFFF0000Not|r Spell Known"],
      type = "spell",
      test = "not WeakAuras.IsSpellKnownForLoad(%s, %s)",
      events = WeakAuras.IsCataOrMists() and {"SPELLS_CHANGED", "UNIT_PET", "PLAYER_TALENT_UPDATE"} or {"SPELLS_CHANGED", "UNIT_PET"},
      showExactOption = true
    },
    {
      name = "player",
      init = "arg",
      enable = false,
      hidden = true
    },
    {
      name = "realm",
      init = "arg",
      enable = false,
      hidden = true
    },
    {
      name = "guild",
      init = "arg",
      enable = false,
      hidden = true
    },
    {
      name = "namerealm",
      display = L["Player Name/Realm"],
      type = "string",
      multiline = true,
      test = "nameRealmChecker:Check(player, realm)",
      preamble = "local nameRealmChecker = Private.ExecEnv.ParseNameCheck(%q)",
      desc = constants.nameRealmFilterDesc,
    },
    {
      name = "ignoreNameRealm",
      display = L["|cFFFF0000Not|r Player Name/Realm"],
      type = "string",
      multiline = true,
      test = "not nameRealmIgnoreChecker:Check(player, realm)",
      preamble = "local nameRealmIgnoreChecker = Private.ExecEnv.ParseNameCheck(%q)",
      desc = constants.nameRealmFilterDesc,
    },
    {
      name = "guildcheck",
      display = L["Guild"],
      type = "string",
      multiline = true,
      test = "guildChecker:Check(guild)",
      preamble = "local guildChecker = Private.ExecEnv.ParseStringCheck(%q)",
      desc = constants.guildFilterDesc,
      events = {"PLAYER_GUILD_UPDATE"}
    },
    {
      name = "race",
      display = L["Player Race"],
      type = "multiselect",
      values = "race_types",
      init = "arg"
    },
    {
      name = "faction",
      display = L["Player Faction"],
      type = "multiselect",
      values = "faction_group",
      init = "arg"
    },
    {
      name = "level",
      display = L["Player Level"],
      type = "number",
      init = "arg",
      events = {"PLAYER_LEVEL_UP"},
      multiEntry = {
        operator = "and",
        limit = 2
      },
    },
    {
      name = "effectiveLevel",
      display = L["Player Effective Level"],
      type = "number",
      init = WeakAuras.IsRetail() and "arg" or nil,
      desc = L["The effective level differs from the level in e.g. Time Walking dungeons."],
      enable = WeakAuras.IsRetail(),
      hidden = not WeakAuras.IsRetail(),
      events = {"PLAYER_LEVEL_UP", "UNIT_FLAGS", "ZONE_CHANGED", "ZONE_CHANGED_INDOORS", "ZONE_CHANGED_NEW_AREA"},
      multiEntry = {
        operator = "and",
        limit = 2
      },
    },
    {
      name = "role",
      display = L["Spec Role"],
      type = "multiselect",
      values = "role_types",
      init = WeakAuras.IsCataOrMistsOrRetail() and "arg" or nil,
      enable = WeakAuras.IsCataOrMistsOrRetail(),
      hidden = not WeakAuras.IsCataOrMistsOrRetail(),
      events = {"PLAYER_ROLES_ASSIGNED", "PLAYER_TALENT_UPDATE"}
    },
    {
      name = "spec_position",
      display = WeakAuras.newFeatureString .. L["Spec Position"],
      type = "multiselect",
      values = "spec_position_types",
      init = WeakAuras.IsCataOrMistsOrRetail() and "arg" or nil,
      enable = WeakAuras.IsCataOrMistsOrRetail(),
      hidden = not WeakAuras.IsCataOrMistsOrRetail(),
      events = {"ACTIVE_TALENT_GROUP_CHANGED"}
    },
    {
      name = "raid_role",
      display = L["Raid Role"],
      type = "multiselect",
      values = "raid_role_types",
      init = WeakAuras.IsClassicOrCataOrMists() and "arg" or nil,
      enable = WeakAuras.IsClassicOrCataOrMists(),
      hidden = WeakAuras.IsRetail(),
      events = {"PLAYER_ROLES_ASSIGNED"}
    },
    {
      name = "ingroup",
      display = L["Group Type"],
      type = "multiselect",
      width = WeakAuras.normalWidth,
      init = "arg",
      values = "group_types",
      events = {"GROUP_ROSTER_UPDATE"},
      optional = true,
    },
    {
      name = "groupSize",
      display = L["Group Size"],
      type = "number",
      init = "arg",
      events = {"GROUP_ROSTER_UPDATE"},
      multiEntry = {
        operator = "and",
        limit = 2
      },
      optional = true,
    },
    {
      name = "group_leader",
      display = WeakAuras.newFeatureString .. L["Group Leader/Assist"],
      type = "multiselect",
      init = "arg",
      events = {"PARTY_LEADER_CHANGED", "GROUP_ROSTER_UPDATE"},
      width = WeakAuras.doubleWidth,
      values = "group_member_types",
      test = "Private.ExecEnv.CheckGroupMemberType(%s, group_leader)",
      optional = true,
    },
    {
      name ="locationTitle",
      display = L["Location"],
      type = "description",
    },
    {
      name = "zone",
      display = L["Zone Name"],
      type = "string",
      multiline = true,
      init = "arg",
      preamble = "local checker = Private.ExecEnv.ParseStringCheck(%q)",
      test = "checker:Check(zone)",
      events = {"ZONE_CHANGED", "ZONE_CHANGED_INDOORS", "ZONE_CHANGED_NEW_AREA", "VEHICLE_UPDATE"},
      desc = L["Supports multiple entries, separated by commas. Escape ',' with \\. Prefix with '-' for negation."],
      optional = true,
    },
    {
      name = "zoneId",
      enable = false,
      hidden = true,
      init = "arg",
      optional = true,
    },
    {
      name = "zonegroupId",
      enable = false,
      hidden = true,
      init = "arg",
      optional = true,
    },
    {
      name = "instanceId",
      enable = false,
      hidden = true,
      init = "arg",
      optional = true,
    },
    {
      name = "minimapZoneText",
      enable = false,
      hidden = true,
      init = "arg",
      optional = true,
    },
    {
      name = "zoneIds",
      display = L["Player Location ID(s)"],
      type = "string",
      multiline = true,
      events = {"ZONE_CHANGED", "ZONE_CHANGED_INDOORS", "ZONE_CHANGED_NEW_AREA", "VEHICLE_UPDATE", "WA_DELAYED_PLAYER_ENTERING_WORLD"},
      desc = get_zoneId_list,
      preamble = "local zoneChecker = Private.ExecEnv.ParseZoneCheck(%q)",
      test = "zoneChecker:Check(zoneId, zonegroupId, instanceId, minimapZoneText)",
      optional = true,
    },
    {
      name = "encounterid",
      display = L["Encounter ID(s)"],
      type = "string",
      init = "arg",
      multiline = true,
      desc = Private.get_encounters_list,
      test = "WeakAuras.CheckNumericIds(%q, encounterid)",
      events = {"ENCOUNTER_START", "ENCOUNTER_END"},
      optional = true,
    },
    {
      name = "size",
      display = L["Instance Size Type"],
      type = "multiselect",
      values = "instance_types",
      sorted = true,
      init = "arg",
      events = {"ZONE_CHANGED", "ZONE_CHANGED_INDOORS", "ZONE_CHANGED_NEW_AREA", "WA_DELAYED_PLAYER_ENTERING_WORLD"},
      optional = true,
    },
    {
      name = "difficulty",
      display = L["Instance Difficulty"],
      type = "multiselect",
      values = "difficulty_types",
      init = not WeakAuras.IsClassicEra() and "arg" or nil,
      enable = not WeakAuras.IsClassicEra(),
      hidden = WeakAuras.IsClassicEra(),
      events = {"PLAYER_DIFFICULTY_CHANGED", "ZONE_CHANGED", "ZONE_CHANGED_INDOORS", "ZONE_CHANGED_NEW_AREA", "WA_DELAYED_PLAYER_ENTERING_WORLD"},
      optional = true,
    },
    {
      name = "instance_type",
      display = L["Instance Type"],
      type = "multiselect",
      values = "instance_difficulty_types",
      sorted = true,
      init = not WeakAuras.IsClassicEra() and "arg" or nil,
      enable = not WeakAuras.IsClassicEra(),
      hidden = WeakAuras.IsClassicEra(),
      events = {"PLAYER_DIFFICULTY_CHANGED", "ZONE_CHANGED", "ZONE_CHANGED_INDOORS", "ZONE_CHANGED_NEW_AREA", "WA_DELAYED_PLAYER_ENTERING_WORLD"},
      optional = true,
    },
    {
      name = "affixes",
      display = L["Mythic+ Affix"],
      type = "multiselect",
      values = "mythic_plus_affixes",
      init = WeakAuras.IsRetail() and "arg" or nil,
      test = "Private.ExecEnv.CheckMPlusAffixIds(%d, affixes)",
      enable = WeakAuras.IsRetail(),
      hidden = not WeakAuras.IsRetail(),
      events = {"CHALLENGE_MODE_START", "CHALLENGE_MODE_COMPLETED"},
      optional = true,
    },
    {
      name ="equipmentTitle",
      display = L["Equipment"],
      type = "description",
    },
    {
      name = "itemequiped",
      display = L["Item Equipped"],
      type = "item",
      multiEntry = {
        operator = "or"
      },
      test = "C_Item.IsEquippedItem(%s or '')",
      events = { "UNIT_INVENTORY_CHANGED", "PLAYER_EQUIPMENT_CHANGED"},
      only_exact = true,
    },
    {
      name = "not_itemequiped",
      display = WeakAuras.newFeatureString .. L["|cFFFF0000Not|r Item Equipped"],
      type = "item",
      multiEntry = {
        operator = "or"
      },
      test = "not C_Item.IsEquippedItem(%s or '')",
      events = { "UNIT_INVENTORY_CHANGED", "PLAYER_EQUIPMENT_CHANGED"},
      only_exact = true,
    },
    {
      name = "itemtypeequipped",
      display = L["Item Type Equipped"],
      type = "multiselect",
      test = "C_Item.IsEquippedItemType(Private.ExecEnv.GetItemSubClassInfo(%s) or '')",
      events = { "UNIT_INVENTORY_CHANGED", "PLAYER_EQUIPMENT_CHANGED"},
      values = "item_weapon_types"
    },
    {
      name = "item_bonusid_equipped",
      display =  L["Item Bonus Id Equipped"],
      type = "string",
      test = "WeakAuras.CheckForItemBonusId(%q)",
      events = { "UNIT_INVENTORY_CHANGED", "PLAYER_EQUIPMENT_CHANGED"},
      desc = L["Supports multiple entries, separated by commas"]
    },
    {
      name = "not_item_bonusid_equipped",
      display =  WeakAuras.newFeatureString .. L["|cFFFF0000Not|r Item Bonus Id Equipped"],
      type = "string",
      test = "not WeakAuras.CheckForItemBonusId(%q)",
      events = { "UNIT_INVENTORY_CHANGED", "PLAYER_EQUIPMENT_CHANGED"},
      desc = L["Supports multiple entries, separated by commas"]
    }
  }
};

local function AddUnitChangeInternalEvents(triggerUnit, t, includePets, unitisunit)
  if (triggerUnit == nil) then
    return
  end
  if (triggerUnit == "multi") then
    -- Handled by normal events"
  elseif triggerUnit == "pet" then
    tinsert(t, "PET_UPDATE")
  else
    if Private.multiUnitUnits[triggerUnit] then
      local isPet
      for unit in pairs(Private.multiUnitUnits[triggerUnit]) do
        isPet = WeakAuras.UnitIsPet(unit)
        if (includePets ~= nil and isPet) or (includePets ~= "PetsOnly" and not isPet) then
          tinsert(t, "UNIT_CHANGED_" .. string.lower(unit))
          if unitisunit then
            tinsert(t, "UNIT_IS_UNIT_CHANGED_" .. string.lower(unit) .. "_" .. string.lower(unitisunit))
          end
        end
      end
    else
      tinsert(t, "UNIT_CHANGED_" .. string.lower(triggerUnit))
      if unitisunit then
        tinsert(t, "UNIT_IS_UNIT_CHANGED_" .. string.lower(triggerUnit) .. "_" .. string.lower(unitisunit))
      end
    end
  end
end

local function AddWatchedUnits(triggerUnit, includePets, unitisunit)
  if (triggerUnit == nil) then
    return
  end
  if (triggerUnit == "multi") then
    -- Handled by normal events"
  elseif triggerUnit == "pet" then
    WeakAuras.WatchForPetDeath();
  else
    if Private.multiUnitUnits[triggerUnit] then
      local isPet
      for unit in pairs(Private.multiUnitUnits[triggerUnit]) do
        isPet = WeakAuras.UnitIsPet(unit)
        if (includePets ~= nil and isPet) or (includePets ~= "PetsOnly" and not isPet) then
          if unitisunit then
            WeakAuras.WatchUnitChange(unitisunit)
          end
          WeakAuras.WatchUnitChange(unit)
        end
      end
    else
      if unitisunit then
        WeakAuras.WatchUnitChange(unitisunit)
      end
      WeakAuras.WatchUnitChange(triggerUnit)
    end
  end
end

local function AddUnitSpecChangeInternalEvents(triggerUnit, t)
  if Private.multiUnitUnits[triggerUnit] then
    for unit in pairs(Private.multiUnitUnits[triggerUnit]) do
      local isPet = WeakAuras.UnitIsPet(unit)
      if (not isPet) then
        tinsert(t, "UNIT_SPEC_CHANGED_" .. string.lower(unit))
      end
    end
  end
end

local function AddUnitRoleChangeInternalEvents(triggerUnit, t)
  if (triggerUnit == nil) then
    return
  end

  if Private.multiUnitUnits[triggerUnit] then
    for unit in pairs(Private.multiUnitUnits[triggerUnit]) do
      if not WeakAuras.UnitIsPet(unit) then
        tinsert(t, "UNIT_ROLE_CHANGED_" .. string.lower(unit))
      end
    end
  else
    if not WeakAuras.UnitIsPet(triggerUnit) then
      tinsert(t, "UNIT_ROLE_CHANGED_" .. string.lower(triggerUnit))
    end
  end
end

local function AddRemainingCastInternalEvents(triggerUnit, t)
  if (triggerUnit == nil) then
    return
  end

  if Private.multiUnitUnits[triggerUnit] then
    for unit in pairs(Private.multiUnitUnits[triggerUnit]) do
      tinsert(t, "CAST_REMAINING_CHECK_" .. string.lower(unit))
    end
  else
    tinsert(t, "CAST_REMAINING_CHECK_" .. string.lower(triggerUnit))
  end
end

local function AddUnitEventForEvents(result, unit, event)
  if unit then
    if not result.unit_events then
      result.unit_events = {}
    end
    if not result.unit_events[unit] then
      result.unit_events[unit] = {}
    end
    tinsert(result.unit_events[unit], event)
  else
    if not result.events then
      result.events = {}
    end
    tinsert(result.events, event)
  end
end

local function AddTargetConditionEvents(result, useFocus)
  if WeakAuras.IsCataOrMistsOrRetail() then
    if useFocus then
      tinsert(result, "PLAYER_FOCUS_CHANGED")
    end
  end
  tinsert(result, "PLAYER_SOFT_ENEMY_CHANGED")
  tinsert(result, "PLAYER_SOFT_FRIEND_CHANGED")
  tinsert(result, "PLAYER_TARGET_CHANGED")
  return result
end

Private.AddTargetConditionEvents = AddTargetConditionEvents

local unitHelperFunctions = {
  UnitChangedForceEventsWithPets = function(trigger)
    local events = {}
    local includePets = trigger.use_includePets == true and trigger.includePets or nil
    if Private.multiUnitUnits[trigger.unit] then
      local isPet
      for unit in pairs(Private.multiUnitUnits[trigger.unit]) do
        isPet = WeakAuras.UnitIsPet(unit)
        if (includePets ~= nil and isPet) or (includePets ~= "PetsOnly" and not isPet) then
          tinsert(events, {"UNIT_CHANGED_" .. unit, unit})
        end
      end
    else
      if trigger.unit then
        tinsert(events, {"UNIT_CHANGED_" .. trigger.unit, trigger.unit})
      end
    end
    return events
  end,

  UnitChangedForceEvents = function(trigger)
    local events = {}
    if Private.multiUnitUnits[trigger.unit] then
      for unit in pairs(Private.multiUnitUnits[trigger.unit]) do
        if not WeakAuras.UnitIsPet(unit) then
          tinsert(events, {"UNIT_CHANGED_" .. unit, unit})
        end
      end
    else
      if trigger.unit then
        tinsert(events, {"UNIT_CHANGED_" .. trigger.unit, trigger.unit})
      end
    end
    return events
  end,

  SpecificUnitCheck = function(trigger)
    if not trigger.use_specific_unit then
      return "local specificUnitCheck = true\n"
    end

    if trigger.unit == nil then
      return "local specificUnitCheck = false\n"
    end

    return string.format([=[
      local specificUnitCheck = UnitIsUnit(%q, unit)
    ]=], trigger.unit or "")
  end
}

Private.event_categories = {
  spell = {
    name = L["Spell"],
    default = "Cooldown Progress (Spell)"
  },
  item = {
    name = L["Item"],
    default = "Cooldown Progress (Item)"
  },
  unit = {
    name = L["Player/Unit Info"],
    default = "Health"
  },
  addons = {
    name = L["Other Addons"],
    default = "GTFO"
  },
  combatlog = {
    name = L["Combat Log"],
    default = "Combat Log",
  },
  event = {
    name = L["Other Events"],
    default = "Chat Message"
  },
  custom = {
    name = L["Custom"],
  }
}

local GetNameAndIconForSpellName = function(trigger)
  if type(trigger.spellName) == "table" then return end
  local effectiveSpellId = Private.ExecEnv.GetEffectiveSpellId(trigger.spellName, trigger.use_exact_spellName, not trigger.use_ignoreoverride)
  local name, _, icon = Private.ExecEnv.GetSpellInfo(effectiveSpellId)
  return name, icon
end

Private.event_prototypes = {
  ["Unit Characteristics"] = {
    type = "unit",
    events = function(trigger)
      local unit = trigger.unit
      local result = {}
      AddUnitEventForEvents(result, unit, "UNIT_LEVEL")
      AddUnitEventForEvents(result, unit, "UNIT_FACTION")
      AddUnitEventForEvents(result, unit, "UNIT_NAME_UPDATE")
      AddUnitEventForEvents(result, unit, "UNIT_FLAGS")
      AddUnitEventForEvents(result, unit, "PLAYER_FLAGS_CHANGED")
      AddUnitEventForEvents(result, unit, "INCOMING_RESURRECT_CHANGED")
      AddUnitEventForEvents(result, unit, "INCOMING_SUMMON_CHANGED")
      if trigger.use_inRange then
        AddUnitEventForEvents(result, unit, "UNIT_IN_RANGE_UPDATE")
      end
      return result;
    end,
    internal_events = function(trigger)
      local unit = trigger.unit
      local result = {}
      AddUnitChangeInternalEvents(unit, result, nil, trigger.use_unitisunit and trigger.unitisunit or nil)
      AddUnitRoleChangeInternalEvents(unit, result)
      AddUnitSpecChangeInternalEvents(unit, result)
      return result
    end,
    loadFunc = function(trigger)
      AddWatchedUnits(trigger.unit, nil, trigger.use_unitisunit and trigger.unitisunit or nil)
    end,
    force_events = unitHelperFunctions.UnitChangedForceEvents,
    name = L["Unit Characteristics"],
    init = function(trigger)
      trigger.unit = trigger.unit or "target";
      local ret = [=[
        unit = string.lower(unit)
        local smart = %s
        local extraUnit = %q;
        local name, realm = WeakAuras.UnitNameWithRealm(unit)
      ]=];

      ret = ret .. unitHelperFunctions.SpecificUnitCheck(trigger)

      return ret:format(trigger.unit == "group" and "true" or "false", trigger.unitisunit or "");
    end,
    statesParameter = "unit",
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_cast",
        desc = Private.actual_unit_types_cast_tooltip,
        test = "true",
        store = true,
        reloadOptions = true,
      },
      {
        name = "unitisunit",
        display = L["Unit is Unit"],
        type = "unit",
        init = "UnitIsUnit(unit, extraUnit)",
        values = function(trigger)
          if Private.multiUnitUnits[trigger.unit] then
            return Private.actual_unit_types
          else
            return Private.actual_unit_types_with_specific
          end
        end,
        test = "unitisunit",
        desc = function() return L["Can be used for e.g. checking if \"boss1target\" is the same as \"player\"."] end,
      },
      {
        name = "name",
        display = L["Name"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "realm",
        display = L["Realm"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "namerealm",
        display = L["Unit Name/Realm"],
        desc = constants.nameRealmFilterDesc,
        type = "string",
        multiline = true,
        preamble = "local nameRealmChecker = Private.ExecEnv.ParseNameCheck(%q)",
        test = "nameRealmChecker:Check(name, realm)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseNameCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.name, state.realm)
        end,
        operator_types = "none",
      },
      {
        name = "class",
        display = L["Class"],
        type = "select",
        init = "select(2, UnitClass(unit))",
        values = "class_types",
        store = true,
        conditionType = "select"
      },
      {
        name = "specId",
        display = L["Specialization"],
        type = "multiselect",
        init = "WeakAuras.SpecForUnit(unit)",
        values = "spec_types_all",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsCataOrMistsOrRetail() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end,
        desc = L["Requires syncing the specialization via LibSpecialization."],
        sorted = true,
        sortOrder = Private.specs_sorted,
      },
      {
        name = "classification",
        display = L["Classification"],
        type = "multiselect",
        init = "UnitClassification(unit)",
        values = "classification_types",
        store = true,
        conditionType = "select"
      },
      {
        name = "creatureTypeIndex",
        display = L["Creature Type"],
        type = "multiselect",
        init = "select(2, UnitCreatureType(unit))",
        values = "creature_type_types",
        store = true,
        sorted = true,
        conditionType = "select",
        enable = WeakAuras.IsMistsOrRetail(),
        hidden = not WeakAuras.IsMistsOrRetail(),
      },
      {
        name = "creatureType",
        display = L["Creature Type Name"],
        init = "UnitCreatureType(unit)",
        store = true,
        test = "true",
        hidden = true,
        enable = WeakAuras.IsMistsOrRetail(),
      },
      {
        name = "creatureFamilyIndex",
        display = L["Creature Family"],
        type = "multiselect",
        init = "select(2, UnitCreatureFamily(unit))",
        values = "creature_family_types",
        store = true,
        sorted = true,
        conditionType = "select",
        enable = WeakAuras.IsMistsOrRetail(),
        hidden = not WeakAuras.IsMistsOrRetail(),
      },
      {
        name = "creatureFamily",
        display = L["Creature Family Name"],
        init = "UnitCreatureFamily(unit)",
        store = true,
        test = "true",
        hidden = true,
        enable = WeakAuras.IsMistsOrRetail(),
      },
      {
        name = "role",
        display = L["Assigned Role"],
        type = "select",
        init = "UnitGroupRolesAssigned(unit)",
        values = "role_types",
        store = true,
        conditionType = "select",
      },
      {
        name = "raid_role",
        display = L["Raid Role"],
        type = "select",
        init = "WeakAuras.UnitRaidRole(unit)",
        values = "raid_role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsClassicOrCataOrMists() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end
      },
      {
        name = "raidMarkIndex",
        display = L["Raid Mark"],
        type = "multiselect",
        values = "raid_mark_check_type",
        store = true,
        conditionType = "select",
        init = "GetRaidTargetIndex(unit) or 0"
      },
      {
        name = "raidMark",
        display = L["Raid Mark Icon"],
        store = true,
        hidden = true,
        test = "true",
        init = "raidMarkIndex > 0 and '{rt'..raidMarkIndex..'}' or ''"
      },
      {
        name = "dead",
        display = L["Dead"],
        type = "tristate",
        width = WeakAuras.doubleWidth,
        init = "UnitIsDeadOrGhost(unit)",
        store = true,
        conditionType = "bool",
      },
      {
        name = "resurrectPending",
        display = L["Resurrect Pending"],
        type = "tristate",
        width = WeakAuras.doubleWidth,
        init = "UnitHasIncomingResurrection(unit)",
        store = true,
        conditionType = "bool",
      },
      {
        name = "summonPending",
        display = L["Summon Pending"],
        type = "tristate",
        width = WeakAuras.doubleWidth,
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
        init = "C_IncomingSummon.HasIncomingSummon(unit)",
        store = true,
        conditionType = "bool",
      },
      {
        name = "ignoreSelf",
        display = L["Ignore Self"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsUnit(\"player\", unit)"
      },
      {
        name = "ignoreDisconnected",
        display = L["Ignore Disconnected"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "UnitIsConnected(unit)"
      },
      {
        name = "inRange",
        display = L["In Range"],
        desc = L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return WeakAuras.IsRetail() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end,
        init = "Private.ExecEnv.UnitInRangeFixed(unit)"
      },
      {
        name = "hostility",
        display = L["Hostility"],
        type = "select",
        init = "WeakAuras.GetPlayerReaction(unit)",
        values = "hostility_types",
        store = true,
        conditionType = "select",
      },
      {
        name = "character",
        display = L["Character Type"],
        type = "select",
        init = "UnitIsPlayer(unit) and 'player' or 'npc'",
        values = "character_types",
        store = true,
        conditionType = "select"
      },
      {
        name = "level",
        display = L["Level"],
        type = "number",
        init = "UnitLevel(unit)",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "npcId",
        display = L["Npc ID"],
        type = "string",
        multiline = true,
        store = true,
        init = "select(6, strsplit('-', UnitGUID(unit) or ''))",
        conditionType = "string",
        preamble = "local npcIdChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "npcIdChecker:Check(npcId)",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.npcId)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."]
      },
      {
        name = "attackable",
        display = L["Attackable"],
        type = "tristate",
        init = "UnitCanAttack('player', unit)",
        store = true,
        conditionType = "bool"
      },
      {
        name = "inCombat",
        display = L["In Combat"],
        type = "tristate",
        init = "UnitAffectingCombat(unit)",
        store = true,
        conditionType = "bool"
      },
      {
        name = "afk",
        display = L["Afk"],
        type = "tristate",
        init = "UnitIsAFK(unit)",
        store = true,
        conditionType = "bool"
      },
      {
        name = "dnd",
        display = L["Do Not Disturb"],
        type = "tristate",
        init = "UnitIsDND(unit)",
        store = true,
        conditionType = "bool"
      },
      {
        hidden = true,
        test = "WeakAuras.UnitExistsFixed(unit, smart) and specificUnitCheck"
      }
    },
    automaticrequired = true,
    progressType = "none"
  },
  ["Faction Reputation"] = {
    type = "unit",
    progressType = "static",
    events = {
      ["events"] = {
        "UPDATE_FACTION",
      }
    },
    internal_events = {"WA_DELAYED_PLAYER_ENTERING_WORLD"},
    force_events = "UPDATE_FACTION",
    name = L["Faction Reputation"],
    statesParameter = "one",
    automaticrequired = true,
    init = function(trigger)
      local ret = [=[
        local useWatched = %s
        local factionID = useWatched and Private.ExecEnv.GetWatchedFactionId() or %q
        local minValue, maxValue, currentValue
        local factionData = Private.ExecEnv.GetFactionDataByID(factionID)
        if not factionData then return end;

        local name, description = factionData.name, factionData.description
        local standingID = factionData.reaction
        local hasRep = factionData.isHeaderWithRep
        local barMin, barMax, barValue = factionData.currentReactionThreshold, factionData.nextReactionThreshold, factionData.currentStanding
        local atWarWith, canToggleAtWar, isHeader, isCollapsed, isWatched, isChild, hasBonusRepGain, canSetInactive = factionData.atWarWith, factionData. canToggleAtWar, factionData.isHeader, factionData.isCollapsed, factionData.isWatched, factionData.isChild, factionData.hasBonusRepGain, factionData.canSetInactive
        minValue, maxValue, currentValue = barMin, barMax, barValue
        local standing
        if tonumber(standingID) then
           standing = GetText("FACTION_STANDING_LABEL"..standingID, UnitSex("player"))
        end
        local isCapped = standingID == 8 and currentValue >= 42999
      ]=]
      if WeakAuras.IsRetail() then
        ret = ret .. [=[
          isCapped = standingID == MAX_REPUTATION_REACTION

          -- check if this is a friendship faction
          local friendshipRank, friendshipMaxRank
          local repInfo = factionID and C_GossipInfo.GetFriendshipReputation(factionID);
          if repInfo and repInfo.friendshipFactionID > 0 then
            standing = repInfo.reaction
            if repInfo.nextThreshold then
              minValue, maxValue, currentValue = repInfo.reactionThreshold, repInfo.nextThreshold, repInfo.standing
            else
              -- max rank, make it look like a full bar
              minValue, maxValue, currentValue = 0, 1, 1
              isCapped = true
            end
            local rankInfo = C_GossipInfo.GetFriendshipReputationRanks(factionID)
            if rankInfo.maxLevel > 0 then
              friendshipRank, friendshipMaxRank = rankInfo.currentLevel, rankInfo.maxLevel
            else
              friendshipRank, friendshipMaxRank = 1, 1
            end
          end

          -- check if this is a Major faction (renown)
          local renownLevel, maxRenownLevel, isWeeklyRenownCapped
          local isMajorFaction = factionID and C_Reputation.IsMajorFaction(factionID)
          if isMajorFaction then
            local majorFactionData = C_MajorFactions.GetMajorFactionData(factionID)
            minValue, maxValue = 0, majorFactionData.renownLevelThreshold
            isCapped = C_MajorFactions.HasMaximumRenown(factionID)
		        currentValue = isCapped and majorFactionData.renownLevelThreshold or majorFactionData.renownReputationEarned or 0
            standing = RENOWN_LEVEL_LABEL:format(majorFactionData.renownLevel)
            renownLevel = majorFactionData.renownLevel
            local renownLevels = C_MajorFactions.GetRenownLevels(factionID)
            maxRenownLevel = renownLevels and renownLevels[#renownLevels].level
            isWeeklyRenownCapped = C_MajorFactions.IsWeeklyRenownCapped(factionID)
          end

          -- check if this is a faction with a paragon track
          local paragonRewardPending = false
          local isParagon = factionID and C_Reputation.IsFactionParagon(factionID)
          if isParagon then
            local paragonCurrentValue, paragonBarMax, rewardQuestID, hasRewardPending, tooLowLevelForParagon = C_Reputation.GetFactionParagonInfo(factionID)
            if paragonCurrentValue then
              minValue, maxValue = 0, paragonBarMax
              currentValue = paragonCurrentValue %% paragonBarMax
              paragonRewardPending = hasRewardPending
            else
              minValue, maxValue, currentValue = 0, 0, 0
            end
          end
        ]=]
      end
      return ret:format(trigger.use_watched and "true" or "false", trigger.factionID or 0)
    end,
    args = {
      {
        name = "progressType",
        hidden = true,
        init = "'static'",
        store = true,
        test = "true"
      },
      {
        name = "watched",
        display = L["Use Watched Faction"],
        type = "toggle",
        test = "true",
        reloadOptions = true,
      },
      {
        name = "factionID",
        display = L["Faction"],
        required = true,
        type = "select",
        itemControl = "Dropdown-Currency",
        values = Private.GetReputations,
        headers = Private.GetReputationsHeaders,
        sorted = true,
        sortOrder = function()
          local sorted = Private.GetReputationsSorted()
          local sortOrder = {}
          for key, value in pairs(Private.GetReputations()) do
            tinsert(sortOrder, key)
          end
          table.sort(sortOrder, function(aKey, bKey)
            local aValue = sorted[aKey]
            local bValue = sorted[bKey]
            return aValue < bValue
          end)
          return sortOrder
        end,
        conditionType = "select",
        enable = function(trigger)
          return not trigger.use_watched
        end,
        reloadOptions = true,
        test = "true",
      },
      {
        name = "name",
        display = L["Faction Name"],
        type = "string",
        store = true,
        hidden = "true",
        init = "name",
        test = "true"
      },
      {
        name = "value",
        display = L["Reputation"],
        type = "number",
        store = true,
        init = [[currentValue - minValue]],
        conditionType = "number",
        progressTotal = "total",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "total",
        display = L["Total Reputation"],
        type = "number",
        store = true,
        init = [[maxValue - minValue]],
        conditionType = "number",
        noProgressSource = true,
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "percentRep",
        display = L["Reputation (%)"],
        type = "number",
        init = "total ~= 0 and (value / total) * 100 or nil",
        store = true,
        conditionType = "number",
        noProgressSource = true,
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "standing",
        display = L["Standing"],
        type = "string",
        init = "standing",
        store = true,
        hidden = "true",
        test = "true"
      },
      {
        name = "standingId",
        display = L["Standing"],
        type = "select",
        values = function()
          local ret = {}
          for i = 1, 8 do
            ret[i] = GetText("FACTION_STANDING_LABEL"..i, UnitSex("player"))
          end
          return ret
        end,
        init = "standingID",
        store = true,
        conditionType = "select",
      },
      {
        name = "capped",
        display = L["Capped"],
        type = "tristate",
        init = "isCapped",
        conditionType = "bool",
        store = true,
      },
      {
        name = "atWar",
        display = L["At War"],
        type = "tristate",
        init = "atWarWith",
        conditionType = "bool",
        store = true,
      },
      {
        name = "hasBonusRepGain",
        display = L["Bonus Reputation Gain"],
        type = "tristate",
        init = "hasBonusRepGain",
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
      },
      {
        type = "header",
        name = "paragonReputationHeader",
        display = L["Paragon Reputation"],
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
      },
      {
        name = "isParagon",
        display = L["Is Paragon Reputation"],
        type = "tristate",
        init = "isParagon",
        store = true,
        conditionType = "bool",
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
      },
      {
        name = "paragonRewardPending",
        display = L["Paragon Reward Pending"],
        type = "tristate",
        init = "paragonRewardPending",
        store = true,
        conditionType = "bool",
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
      },
      {
        type = "header",
        name = "friendshipReputationHeader",
        display = L["Friendship Reputation"],
        enable = WeakAuras.IsRetail() and function(trigger)
          local repInfo = trigger.factionID and C_GossipInfo.GetFriendshipReputation(trigger.factionID);
          return repInfo and repInfo.friendshipFactionID > 0
        end,
        hidden = not WeakAuras.IsRetail(),
      },
      {
        name = "friendshipRank",
        display = L["Friendship Rank"],
        type = "number",
        init = "friendshipRank",
        store = true,
        conditionType = "number",
        enable = WeakAuras.IsRetail() and function(trigger)
          local repInfo = trigger.factionID and C_GossipInfo.GetFriendshipReputation(trigger.factionID);
          return repInfo and repInfo.friendshipFactionID > 0
        end,
        hidden = not WeakAuras.IsRetail(),
        progressTotal = "friendshipMaxRank",
      },
      {
        name = "friendshipMaxRank",
        display = L["Friendship Max Rank"],
        type = "number",
        init = "friendshipMaxRank",
        store = true,
        conditionType = "number",
        enable = WeakAuras.IsRetail() and function(trigger)
          local repInfo = trigger.factionID and C_GossipInfo.GetFriendshipReputation(trigger.factionID);
          return repInfo and repInfo.friendshipFactionID > 0
        end,
        hidden = not WeakAuras.IsRetail(),
        noProgressSource = true,
      },
      {
        type = "header",
        name = "renownReputationHeader",
        display = L["Renown Reputation"],
        enable = WeakAuras.IsRetail() and function(trigger)
          local majorFactionData = trigger.factionID and C_MajorFactions.GetMajorFactionData(trigger.factionID)
          return majorFactionData and majorFactionData.renownLevel
        end,
        hidden = not WeakAuras.IsRetail(),
      },
      {
        name = "renownLevel",
        display = L["Renown Level"],
        type = "number",
        conditionType = "number",
        init = "renownLevel",
        store = true,
        enable = WeakAuras.IsRetail() and function(trigger)
          local majorFactionData = trigger.factionID and C_MajorFactions.GetMajorFactionData(trigger.factionID)
          return majorFactionData and majorFactionData.renownLevel
        end,
        hidden = not WeakAuras.IsRetail(),
        progressTotal = "maxRenownLevel",
      },
      {
        name = "maxRenownLevel",
        display = L["Renown Max Level"],
        type = "number",
        conditionType = "number",
        init = "maxRenownLevel",
        store = true,
        enable = WeakAuras.IsRetail() and function(trigger)
          local majorFactionData = trigger.factionID and C_MajorFactions.GetMajorFactionData(trigger.factionID)
          return majorFactionData and majorFactionData.renownLevel
        end,
        hidden = not WeakAuras.IsRetail(),
        noProgressSource = true,
      },
      {
        name = "isWeeklyRenownCapped",
        display = L["Is Weekly Renown Capped"],
        type = "tristate",
        conditionType = "bool",
        init = "isWeeklyRenownCapped",
        store = true,
        enable = WeakAuras.IsRetail() and function(trigger)
          local majorFactionData = trigger.factionID and C_MajorFactions.GetMajorFactionData(trigger.factionID)
          return majorFactionData and majorFactionData.renownLevel
        end,
        hidden = not WeakAuras.IsRetail(),
      },
    }
  },
  ["Experience"] = {
    type = "unit",
    progressType = "static",
    events = {
      ["events"] = {
        "PLAYER_XP_UPDATE",
      }
    },
    internal_events = {"WA_DELAYED_PLAYER_ENTERING_WORLD"},
    force_events = "PLAYER_XP_UPDATE",
    name = L["Player Experience"],
    init = function(trigger)
      return ""
    end,
    statesParameter = "one",
    args = {
      {
        name = "level",
        display = L["Level"],
        required = false,
        type = "number",
        store = true,
        init = [[UnitLevel("player")]],
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "currentXP",
        display = L["Current Experience"],
        type = "number",
        store = true,
        init = [[UnitXP("player")]],
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        progressTotal = "totalXP"
      },
      {
        name = "totalXP",
        display = L["Total Experience"],
        type = "number",
        store = true,
        init = [[UnitXPMax("player")]],
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "value",
        type = "number",
        store = true,
        init = "currentXP",
        hidden = true,
        test = "true",
      },
      {
        name = "total",
        type = "number",
        store = true,
        init = "totalXP",
        hidden = true,
        test = "true",
      },
      {
        name = "progressType",
        hidden = true,
        init = "'static'",
        store = true,
        test = "true"
      },
      {
        name = "percentXP",
        display = L["Experience (%)"],
        type = "number",
        init = "total ~= 0 and (value / total) * 100 or nil",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        type = "header",
        name = "restedExperienceHeader",
        display = L["Rested Experience"],
      },
      {
        name = "showRested",
        display = L["Show Rested Overlay"],
        type = "toggle",
        test = "true",
        reloadOptions = true,
      },
      {
        name = "restedXP",
        display = L["Rested Experience"],
        init = [[GetXPExhaustion() or 0]],
        type = "number",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "percentrested",
        display = L["Rested Experience (%)"],
        init = "total ~= 0 and (restedXP / total) * 100 or nil",
        type = "number",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
    },
    overlayFuncs = {
      {
        name = L["Rested"],
        func = function(trigger, state)
          return "forward", state.restedXP
        end,
        enable = function(trigger)
          return trigger.use_showRested
        end
      },
    },
    automaticrequired = true
  },
  ["Health"] = {
    type = "unit",
    includePets = "true",
    progressType = "static",
    events = function(trigger)
      local unit = trigger.unit
      local result = {}
      if WeakAuras.IsClassicEra() then
        AddUnitEventForEvents(result, unit, "UNIT_HEALTH_FREQUENT")
      else
        AddUnitEventForEvents(result, unit, "UNIT_HEALTH")
      end
      AddUnitEventForEvents(result, unit, "UNIT_MAXHEALTH")
      AddUnitEventForEvents(result, unit, "UNIT_NAME_UPDATE")
      if WeakAuras.IsMistsOrRetail() then
        if trigger.use_showAbsorb then
          AddUnitEventForEvents(result, unit, "UNIT_ABSORB_AMOUNT_CHANGED")
        end
        if trigger.use_showHealAbsorb then
          AddUnitEventForEvents(result, unit, "UNIT_HEAL_ABSORB_AMOUNT_CHANGED")
        end
      end
      if trigger.use_showIncomingHeal then
        AddUnitEventForEvents(result, unit, "UNIT_HEAL_PREDICTION")
      end
      if trigger.use_ignoreDead or trigger.use_ignoreDisconnected then
        AddUnitEventForEvents(result, unit, "UNIT_FLAGS")
      end
      if trigger.use_inRange then
        AddUnitEventForEvents(result, unit, "UNIT_IN_RANGE_UPDATE")
      end
      return result
    end,
    internal_events = function(trigger)
      local unit = trigger.unit
      local result = {}
      local includePets = trigger.use_includePets == true and trigger.includePets or nil
      AddUnitChangeInternalEvents(unit, result, includePets)
      if includePets ~= "PetsOnly" then
        AddUnitRoleChangeInternalEvents(unit, result)
      end
      AddUnitSpecChangeInternalEvents(unit, result)
      return result
    end,
    loadFunc = function(trigger)
      local includePets = trigger.use_includePets == true and trigger.includePets or nil
      AddWatchedUnits(trigger.unit, includePets)
    end,
    force_events = unitHelperFunctions.UnitChangedForceEventsWithPets,
    name = L["Health"],
    init = function(trigger)
      trigger.unit = trigger.unit or "player";
      local ret = [=[
        unit = string.lower(unit)
        local name, realm = WeakAuras.UnitNameWithRealm(unit)
        local smart = %s
      ]=];

      ret = ret .. unitHelperFunctions.SpecificUnitCheck(trigger)

      return ret:format(trigger.unit == "group" and "true" or "false");
    end,
    statesParameter = "unit",
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_cast",
        desc = Private.actual_unit_types_cast_tooltip,
        test = "true",
        store = true
      },
      {
        name = "health",
        display = L["Health"],
        type = "number",
        init = "UnitHealth(unit)",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        progressTotal = "maxhealth",
        formatter = "BigNumber",
      },
      {
        name = "value",
        hidden = true,
        init = "health",
        store = true,
        test = "true"
      },
      {
        name = "total",
        hidden = true,
        init = "UnitHealthMax(unit)",
        store = true,
        test = "true"
      },
      {
        name = "progressType",
        hidden = true,
        init = "'static'",
        store = true,
        test = "true"
      },
      {
        name = "percenthealth",
        display = L["Health (%)"],
        type = "number",
        init = "total ~= 0 and (value / total) * 100 or nil",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "deficit",
        display = L["Health Deficit"],
        type = "number",
        init = "total - value",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        progressTotal = "total",
        formatter = "BigNumber",
      },
      {
        name = "maxhealth",
        display = WeakAuras.newFeatureString .. L["Max Health"],
        type = "number",
        init = "total",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "BigNumber",
      },
      {
        type = "header",
        name = "absorbAndHealingHeader",
        display = L["Absorb and Healing"],
      },
      {
        name = "showAbsorb",
        display = L["Fetch Absorb"],
        type = "toggle",
        test = "true",
        reloadOptions = true,
        enable = WeakAuras.IsMistsOrRetail(),
        hidden = not WeakAuras.IsMistsOrRetail(),
      },
      {
        name = "absorbMode",
        display = L["Absorb Overlay"],
        type = "select",
        test = "true",
        values = "absorb_modes",
        required = true,
        enable = function(trigger) return WeakAuras.IsMistsOrRetail() and trigger.use_showAbsorb end,
        hidden = not WeakAuras.IsMistsOrRetail()
      },
      {
        name = "showHealAbsorb",
        display = L["Fetch Heal Absorb"],
        type = "toggle",
        test = "true",
        reloadOptions = true,
        enable = WeakAuras.IsMistsOrRetail(),
        hidden = not WeakAuras.IsMistsOrRetail()
      },
      {
        name = "absorbHealMode",
        display = L["Absorb Heal Overlay"],
        type = "select",
        test = "true",
        values = "absorb_modes",
        required = true,
        enable = function(trigger) return WeakAuras.IsMistsOrRetail() and trigger.use_showHealAbsorb end,
        hidden = not WeakAuras.IsMistsOrRetail()
      },
      {
        name = "absorb",
        type = "number",
        display = L["Absorb"],
        init = "UnitGetTotalAbsorbs(unit)",
        store = true,
        conditionType = "number",
        enable = function(trigger) return WeakAuras.IsMistsOrRetail() and trigger.use_showAbsorb end,
        hidden = not WeakAuras.IsMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        progressTotal = "total"
      },
      {
        name = "healabsorb",
        type = "number",
        display = L["Heal Absorb"],
        init = "UnitGetTotalHealAbsorbs(unit)",
        store = true,
        conditionType = "number",
        enable = function(trigger) return WeakAuras.IsMistsOrRetail() and trigger.use_showHealAbsorb end,
        hidden = not WeakAuras.IsMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "showIncomingHeal",
        display = L["Show Incoming Heal"],
        type = "toggle",
        test = "true",
        reloadOptions = true,
        progressTotal = "total"
      },
      {
        name = "healprediction",
        type = "number",
        display = L["Incoming Heal"],
        init = "UnitGetIncomingHeals(unit)",
        store = true,
        conditionType = "number",
        enable = function(trigger) return trigger.use_showIncomingHeal end,
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        type = "header",
        name = "unitCharacteristicsHeader",
        display = L["Unit Characteristics"],
      },
      {
        name = "name",
        display = L["Unit Name"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "realm",
        display = L["Realm"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "namerealm",
        display = L["Unit Name/Realm"],
        type = "string",
        multiline = true,
        preamble = "local nameRealmChecker = Private.ExecEnv.ParseNameCheck(%q)",
        test = "nameRealmChecker:Check(name, realm)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseNameCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.name, state.realm)
        end,
        operator_types = "none",
        desc = constants.nameRealmFilterDesc,
      },
      {
        name = "npcId",
        display = L["Npc ID"],
        type = "string",
        multiline = true,
        store = true,
        init = "select(6, strsplit('-', UnitGUID(unit) or ''))",
        conditionType = "string",
        preamble = "local npcIdChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "npcIdChecker:Check(npcId)",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.npcId)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."]
      },
      {
        name = "class",
        display = L["Class"],
        type = "select",
        init = "select(2, UnitClass(unit))",
        values = "class_types",
        store = true,
        conditionType = "select"
      },
      {
        name = "specId",
        display = L["Specialization"],
        type = "multiselect",
        init = "WeakAuras.SpecForUnit(unit)",
        values = "spec_types_all",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsCataOrMistsOrRetail() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end,
        desc = L["Requires syncing the specialization via LibSpecialization."],
        sorted = true,
        sortOrder = Private.specs_sorted,
      },
      {
        name = "role",
        display = L["Assigned Role"],
        type = "select",
        init = "UnitGroupRolesAssigned(unit)",
        values = "role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end
      },
      {
        name = "raid_role",
        display = L["Raid Role"],
        type = "select",
        init = "WeakAuras.UnitRaidRole(unit)",
        values = "raid_role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsClassicOrCataOrMists() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end
      },
      {
        name = "raidMarkIndex",
        display = L["Raid Mark"],
        type = "multiselect",
        values = "raid_mark_check_type",
        store = true,
        conditionType = "select",
        init = "GetRaidTargetIndex(unit) or 0"
      },
      {
        name = "raidMark",
        display = L["Raid Mark Icon"],
        store = true,
        hidden = true,
        test = "true",
        init = "raidMarkIndex > 0 and '{rt'..raidMarkIndex..'}' or ''"
      },
      {
        type = "header",
        name = "miscellaneousHeader",
        display = L["Miscellaneous"],
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
      },
      {
        name = "includePets",
        display = L["Include Pets"],
        type = "select",
        values = "include_pets_types",
        width = WeakAuras.normalWidth,
        test = "true",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end
      },
      {
        name = "ignoreSelf",
        display = L["Ignore Self"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsUnit(\"player\", unit)"
      },
      {
        name = "ignoreDead",
        display = L["Ignore Dead"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsDeadOrGhost(unit)"
      },
      {
        name = "ignoreDisconnected",
        display = L["Ignore Disconnected"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "UnitIsConnected(unit)"
      },
      {
        name = "inRange",
        display = L["In Range"],
        desc = L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return WeakAuras.IsRetail() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end,
        init = "Private.ExecEnv.UnitInRangeFixed(unit)"
      },
      {
        name = "nameplateType",
        display = L["Hostility"],
        type = "select",
        init = "WeakAuras.GetPlayerReaction(unit)",
        values = "hostility_types",
        conditionType = "select",
        store = true,
      },
      {
        name = "name",
        hidden = true,
        init = "UnitName(unit)",
        test = "true"
      },
      {
        hidden = true,
        test = "WeakAuras.UnitExistsFixed(unit, smart) and specificUnitCheck"
      }
    },
    overlayFuncs = {
      {
        name = L["Absorb"],
        func = function(trigger, state)
          local absorb = state.absorb
          if not absorb then
            return
          end
          if (trigger.absorbMode == "OVERLAY_FROM_START") then
            return 0, absorb;
          elseif (trigger.absorbMode == "OVERLAY_FROM_END") then
            return "forward", absorb;
          else
            if not state.total then
              return
            end
            local total = state.total
            if not total then
              return
            end
            return total - absorb, total
          end
        end,
        enable = function(trigger)
          return WeakAuras.IsMistsOrRetail() and trigger.use_showAbsorb;
        end
      },
      {
        name = L["Heal Absorb"],
        func = function(trigger, state)
          local healabsorb = state.healabsorb
          if not healabsorb then
            return
          end
          if (trigger.absorbHealMode == "OVERLAY_FROM_START") then
            return 0, healabsorb;
          elseif (trigger.absorbMode == "OVERLAY_FROM_END") then
            return "forward", healabsorb;
          else
            local total = state.total
            if not total then
              return
            end
            return total - healabsorb, total
          end
        end,
        enable = function(trigger)
          return WeakAuras.IsMistsOrRetail() and trigger.use_showHealAbsorb;
        end
      },
      {
        name = L["Incoming Heal"],
        func = function(trigger, state)
          if (trigger.use_showIncomingHeal) then
            local heal = state.healprediction;
            return "forward", heal;
          end
        end,
        enable = function(trigger)
          return trigger.use_showIncomingHeal;
        end
      }
    },
    automaticrequired = true
  },
  ["Power"] = {
    type = "unit",
    progressType = "static",
    events = function(trigger)
      local unit = trigger.unit
      local result = {}
      AddUnitEventForEvents(result, unit, "UNIT_POWER_FREQUENT")
      AddUnitEventForEvents(result, unit, "UNIT_MAXPOWER")
      AddUnitEventForEvents(result, unit, "UNIT_DISPLAYPOWER")
      AddUnitEventForEvents(result, unit, "UNIT_NAME_UPDATE")

      -- The api for spell power costs is not meant to be for other units
      if trigger.use_showCost and trigger.unit == "player" then
        AddUnitEventForEvents(result, "player", "UNIT_SPELLCAST_START")
        AddUnitEventForEvents(result, "player", "UNIT_SPELLCAST_STOP")
        AddUnitEventForEvents(result, "player", "UNIT_SPELLCAST_FAILED")
        AddUnitEventForEvents(result, "player", "UNIT_SPELLCAST_SUCCEEDED")
      end

      if trigger.use_ignoreDead or trigger.use_ignoreDisconnected then
        AddUnitEventForEvents(result, unit, "UNIT_FLAGS")
      end

      if trigger.use_powertype and trigger.powertype == 4 then
        if WeakAuras.IsRetail() then
          AddUnitEventForEvents(result, unit, "UNIT_POWER_POINT_CHARGE")
        elseif WeakAuras.IsCataClassic() then
          AddUnitEventForEvents(result, unit, "UNIT_TARGET")
        else
          AddUnitEventForEvents(result, unit, "UNIT_TARGET")
        end
      end
      if trigger.use_inRange then
        AddUnitEventForEvents(result, unit, "UNIT_IN_RANGE_UPDATE")
      end
      return result;
    end,
    internal_events = function(trigger)
      local unit = trigger.unit
      local result = {}
      local includePets = trigger.use_includePets == true and trigger.includePets or nil
      AddUnitChangeInternalEvents(unit, result, includePets)
      if includePets ~= "PetsOnly" then
        AddUnitRoleChangeInternalEvents(unit, result)
      end
      AddUnitSpecChangeInternalEvents(unit, result)
      if trigger.use_powertype and trigger.powertype == 99 and trigger.unit == "player" then
        Private.WatchStagger()
        tinsert(result, "WA_UNIT_STAGGER_CHANGED");
      end
      if WeakAuras.IsClassicEra() and trigger.use_showCost and trigger.unit == "player" then
        tinsert(result, "WA_UNIT_QUEUED_SPELL_CHANGED");
      end
      if WeakAuras.IsCataOrMists() and trigger.unit == "player" and trigger.use_powertype and trigger.powertype == 26 then
        tinsert(result, "ECLIPSE_DIRECTION_CHANGE");
      end
      if WeakAuras.IsCataOrMists() and trigger.unit == "player" and trigger.use_powertype and trigger.powertype == 4 then
        Private.WatchCOMBO_TARGET_CHANGED()
        tinsert(result, "WA_COMBO_TARGET_CHANGED");
      end
      return result
    end,
    loadFunc = function(trigger)
      if WeakAuras.IsClassicEra() and trigger.use_showCost and trigger.unit == "player" then
        WeakAuras.WatchForQueuedSpell()
      end
      local includePets = trigger.use_includePets == true and trigger.includePets or nil
      AddWatchedUnits(trigger.unit, includePets)
    end,
    force_events = unitHelperFunctions.UnitChangedForceEventsWithPets,
    name = L["Power"],
    init = function(trigger)
      trigger.unit = trigger.unit or "player";
      local ret = {}
      table.insert(ret, ([=[
        unit = string.lower(unit)
        local name, realm = WeakAuras.UnitNameWithRealm(unit)
        local smart = %s
        local powerType = %s;
        local unitPowerType = UnitPowerType(unit);
        local powerTypeToCheck = powerType or unitPowerType;
        if not WeakAuras.IsRetail() and powerType == 99 then powerType = 1 end
      ]=]):format(trigger.unit == "group" and "true" or "false", trigger.use_powertype and trigger.powertype or "nil"))

      local powerType = trigger.use_powertype and trigger.powertype or nil
      if WeakAuras.IsRetail() then
        if powerType == 7 then
          -- Soul Shards, this mirrors the ShardBar in the wow sources
          table.insert(ret, [[
            local shardModifier = UnitPowerDisplayMod(powerType)
            local power = UnitPower(unit, powerType, true) / shardModifier
            local total = math.max(1, UnitPowerMax(unit, powerType, true)) / shardModifier
            if Private.ExecEnv.GetSpecialization() ~= SPEC_WARLOCK_DESTRUCTION then
              power = floor(power)
            end
          ]])
        elseif powerType == 99 then
          table.insert(ret, ([[
            local power = UnitStagger(unit) or 0
            local scaleStagger = %s
            local total = math.max(1, UnitHealthMax(unit) * scaleStagger)
          ]]):format(trigger.use_scaleStagger and trigger.scaleStagger or 1))
        elseif powerType == 4 and trigger.unit == 'player' then
          table.insert(ret, ([[
            local comboPoint = UnitPower(unit, 4)
            local chargedComboPoint = GetUnitChargedPowerPoints('player') or {}
            local countCharged = #chargedComboPoint
            if state.countCharged ~= countCharged then
              state.countCharged = countCharged
              state.changed = true
            end

            local power = UnitPower(unit, powerType)
            local total = math.max(1, UnitPowerMax(unit, powerType))
          ]]))
        else
          table.insert(ret, [[
            local power = UnitPower(unit, powerType)
            local total = math.max(1, UnitPowerMax(unit, powerType))
          ]])
        end
      elseif WeakAuras.IsMists() and powerType == 99 then
        table.insert(ret, ([[
          local power = UnitStagger(unit) or 0
          local scaleStagger = %s
          local total = math.max(1, UnitHealthMax(unit) * scaleStagger)
        ]]):format(trigger.use_scaleStagger and trigger.scaleStagger or 1))
      elseif WeakAuras.IsMists() and (powerType == 14 or powerType == 7) then
        table.insert(ret, [[
          local displayMod = UnitPowerDisplayMod(powerType)
          local power = UnitPower(unit, powerType, true) / displayMod
          local total = math.max(1, UnitPowerMax(unit, powerType, true)) / displayMod
        ]])
      else
        -- Combo Points
        if powerType == 4 then
          table.insert(ret, [[
            local power = GetComboPoints(unit, unit .. '-target')
            local total = math.max(1, UnitPowerMax(unit, Enum.PowerType.ComboPoints))
          ]])
        else
          table.insert(ret, [[
            local power = UnitPower(unit, powerType)
            local total = math.max(1, UnitPowerMax(unit, powerType))
          ]])
        end
      end

      table.insert(ret, unitHelperFunctions.SpecificUnitCheck(trigger))

      local canEnableShowCost = (not trigger.use_powertype or trigger.powertype ~= 99) and trigger.unit == "player";
      if (canEnableShowCost and trigger.use_showCost) then
        table.insert(ret, [[
          if (event == "UNIT_DISPLAYPOWER") then
            local cost = WeakAuras.GetSpellCost(powerTypeToCheck)
            if state.cost ~= cost then
              state.cost = cost
              state.changed = true
            end
          elseif ( (event == "UNIT_SPELLCAST_START" or event == "UNIT_SPELLCAST_STOP" or event == "UNIT_SPELLCAST_FAILED" or event == "UNIT_SPELLCAST_SUCCEEDED") and unit == "player") or event == "WA_UNIT_QUEUED_SPELL_CHANGED" then
            local cost = WeakAuras.GetSpellCost(powerTypeToCheck)
            if state.cost ~= cost then
              state.cost = cost
              state.changed = true
            end
          end
        ]])
      end

      return table.concat(ret)
    end,
    statesParameter = "unit",
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_cast",
        desc = Private.actual_unit_types_cast_tooltip,
        test = "true",
        store = true
      },
      {
        name = "powertype",
        display = L["Power Type"],
        type = "select",
        values = "power_types",
        init = "powerTypeToCheck",
        test = "true",
        store = true,
        conditionType = "select",
        reloadOptions = true
      },
      {
        name = "requirePowerType",
        display = L["Only if Primary"],
        type = "toggle",
        test = "unitPowerType == powerType",
        enable = function(trigger)
          return trigger.use_powertype
        end,
      },
      {
        name = "showCost",
        display = L["Overlay Cost of Casts"],
        type = "toggle",
        test = "true",
        enable = function(trigger)
          return (not trigger.use_powertype or trigger.powertype ~= 99) and trigger.unit == "player";
        end,
        reloadOptions = true
      },
      {
        name = "showChargedComboPoints",
        display = L["Overlay Charged Combo Points"],
        type = "toggle",
        test = "true",
        reloadOptions = true,
        enable = function(trigger)
          return WeakAuras.IsRetail() and trigger.unit == 'player' and trigger.use_powertype and trigger.powertype == 4
        end,
        hidden = not WeakAuras.IsRetail()
      },
      {
        name = "countCharged",
        type = "number",
        display = L["Charged Combo Points"],
        conditionType = "number",
        enable = function(trigger)
          return WeakAuras.IsRetail() and trigger.unit == 'player'and trigger.use_powertype and trigger.powertype == 4
        end,
        hidden = true,
        test = "true"
      },
      {
        name = "scaleStagger",
        display = L["Stagger Scale"],
        type = "string",
        validate = WeakAuras.ValidateNumeric,
        enable = function(trigger)
          return trigger.use_powertype and trigger.powertype == 99
        end,
        test = "true"
      },
      {
        name = "eclipseDirection",
        display = L["Eclipse Direction"],
        type = "select",
        values = "eclipse_direction_types",
        init = "GetEclipseDirection()",
        conditionType = "select",
        store = true,
        enable = function(trigger)
          return WeakAuras.IsCataOrMists() and trigger.unit == "player" and trigger.use_powertype and trigger.powertype == 26
        end,
      },
      {
        name = "power",
        display = L["Power"],
        type = "number",
        init = "power",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        progressTotal = "total"
      },
      {
        name = "value",
        hidden = true,
        init = "power",
        store = true,
        test = "true"
      },
      {
        name = "total",
        hidden = true,
        init = "total",
        store = true,
        test = "true"
      },
      {
        name = "stacks",
        hidden = true,
        init = "power",
        store = true,
        test = "true"
      },
      {
        name = "progressType",
        hidden = true,
        init = "'static'",
        store = true,
        test = "true"
      },
      {
        name = "percentpower",
        display = L["Power (%)"],
        type = "number",
        init = "total ~= 0 and (value / total) * 100 or nil",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "deficit",
        display = L["Power Deficit"],
        type = "number",
        init = "total - value",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        progressTotal = "total"
      },
      {
        name = "maxpower",
        display = WeakAuras.newFeatureString .. L["Max Power"],
        type = "number",
        init = "total",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "name",
        display = L["Unit Name"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "realm",
        display = L["Realm"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        type = "header",
        name = "unitCharacteristicsHeader",
        display = L["Unit Characteristics"],
      },
      {
        name = "namerealm",
        display = L["Unit Name/Realm"],
        type = "string",
        multiline = true,
        preamble = "local nameRealmChecker = Private.ExecEnv.ParseNameCheck(%q)",
        test = "nameRealmChecker:Check(name, realm)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseNameCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.name, state.realm)
        end,
        operator_types = "none",
        desc = constants.nameRealmFilterDesc,
      },
      {
        name = "npcId",
        display = L["Npc ID"],
        type = "string",
        multiline = true,
        store = true,
        init = "select(6, strsplit('-', UnitGUID(unit) or ''))",
        conditionType = "string",
        preamble = "local npcIdChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "npcIdChecker:Check(npcId)",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.npcId)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."]
      },
      {
        name = "class",
        display = L["Class"],
        type = "select",
        init = "select(2, UnitClass(unit))",
        values = "class_types",
        store = true,
        conditionType = "select"
      },
      {
        name = "specId",
        display = L["Specialization"],
        type = "multiselect",
        init = "WeakAuras.SpecForUnit(unit)",
        values = "spec_types_all",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsCataOrMistsOrRetail() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end,
        desc = L["Requires syncing the specialization via LibSpecialization."],
        sorted = true,
        sortOrder = Private.specs_sorted,
      },
      {
        name = "role",
        display = L["Assigned Role"],
        type = "select",
        init = "UnitGroupRolesAssigned(unit)",
        values = "role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end
      },
      {
        name = "raid_role",
        display = L["Raid Role"],
        type = "select",
        init = "WeakAuras.UnitRaidRole(unit)",
        values = "raid_role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsClassicOrCataOrMists() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end
      },
      {
        name = "raidMarkIndex",
        display = L["Raid Mark"],
        type = "multiselect",
        values = "raid_mark_check_type",
        store = true,
        conditionType = "select",
        init = "GetRaidTargetIndex(unit) or 0"
      },
      {
        name = "raidMark",
        display = L["Raid Mark Icon"],
        store = true,
        hidden = true,
        test = "true",
        init = "raidMarkIndex > 0 and '{rt'..raidMarkIndex..'}' or ''"
      },
      {
        type = "header",
        name = "miscellaneousHeader",
        display = L["Miscellaneous"],
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
      },
      {
        name = "includePets",
        display = L["Include Pets"],
        type = "select",
        values = "include_pets_types",
        width = WeakAuras.normalWidth,
        test = "true",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end
      },
      {
        name = "ignoreSelf",
        display = L["Ignore Self"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsUnit(\"player\", unit)"
      },
      {
        name = "ignoreDead",
        display = L["Ignore Dead"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsDeadOrGhost(unit)"
      },
      {
        name = "ignoreDisconnected",
        display = L["Ignore Disconnected"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "UnitIsConnected(unit)"
      },
      {
        name = "inRange",
        display = L["In Range"],
        desc = L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return WeakAuras.IsRetail() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end,
        init = "Private.ExecEnv.UnitInRangeFixed(unit)"
      },
      {
        name = "nameplateType",
        display = L["Hostility"],
        type = "select",
        init = "WeakAuras.GetPlayerReaction(unit)",
        values = "hostility_types",
        store = true,
        conditionType = "select",
      },
      {
        hidden = true,
        test = "WeakAuras.UnitExistsFixed(unit, smart) and specificUnitCheck"
      }
    },
    overlayFuncs = {
      {
        name = L["Spell Cost"],
        func = function(trigger, state)
          return "back", type(state.cost) == "number" and state.cost;
        end,
        enable = function(trigger)
          return trigger.use_showCost and (not trigger.use_powertype or trigger.powertype ~= 99) and trigger.unit == "player";
        end
      },
      {
        name = L["Charged Combo Points"],
        func = function(trigger, state)
          if type(state.countCharged) == "number" then
            return 0, state.countCharged
          end
          return 0, 0
        end,
        enable = function(trigger)
          return WeakAuras.IsRetail() and trigger.unit == 'player' and trigger.use_powertype and trigger.powertype == 4 and trigger.use_showChargedComboPoints
        end,
      },
    },
    automaticrequired = true
  },
  ["Alternate Power"] = {
    type = "unit",
    progressType = "static",
    events = function(trigger)
      local unit = trigger.unit
      local result = {}
      AddUnitEventForEvents(result, unit, "UNIT_POWER_FREQUENT")
      AddUnitEventForEvents(result, unit, "UNIT_NAME_UPDATE")
      if trigger.use_ignoreDead or trigger.use_ignoreDisconnected then
        AddUnitEventForEvents(result, unit, "UNIT_FLAGS")
      end
      AddUnitEventForEvents(result, unit, "UNIT_POWER_BAR_SHOW")
      AddUnitEventForEvents(result, unit, "UNIT_POWER_BAR_HIDE")
      if trigger.use_inRange then
        AddUnitEventForEvents(result, unit, "UNIT_IN_RANGE_UPDATE")
      end
      return result
    end,
    internal_events = function(trigger)
      local unit = trigger.unit
      local result = { }
      AddUnitChangeInternalEvents(unit, result)
      AddUnitRoleChangeInternalEvents(unit, result)
      AddUnitSpecChangeInternalEvents(unit, result)
      return result
    end,
    loadFunc = function(trigger)
      AddWatchedUnits(trigger.unit)
    end,
    force_events = unitHelperFunctions.UnitChangedForceEvents,
    name = L["Alternate Power"],
    init = function(trigger)
      trigger.unit = trigger.unit or "player";
      local ret = [=[
        unit = string.lower(unit)
        local unitname, realm = WeakAuras.UnitNameWithRealm(unit)
        local smart = %s
      ]=]

      ret = ret .. unitHelperFunctions.SpecificUnitCheck(trigger)

      return ret:format(trigger.unit == "group" and "true" or "false");
    end,
    statesParameter = "unit",
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = "actual_unit_types_cast",
        desc = Private.actual_unit_types_cast_tooltip,
        test = "true",
        store = true
      },
      {
        name = "power",
        display = L["Alternate Power"],
        type = "number",
        init = "UnitPower(unit, 10)",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        progressTotal = "total"
      },
      {
        name = "value",
        hidden = true,
        init = "power",
        store = true,
        test = "true"
      },
      {
        name = "total",
        hidden = true,
        init = "UnitPowerMax(unit, 10)",
        store = true,
        test = "true"
      },
      {
        name = "progressType",
        hidden = true,
        init = "'static'",
        store = true,
        test = "true"
      },
      {
        name = "name",
        hidden = true,
        init = "GetUnitPowerBarStrings(unit)",
        store = true,
        test = "true"
      },
      {
        name = "unitname",
        display = L["Unit Name"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "unitrealm",
        display = L["Realm"],
        type = "string",
        store = true,
        hidden = true,
        test = "true"
      },
      {
        name = "namerealm",
        display = L["Unit Name/Realm"],
        type = "string",
        multiline = true,
        preamble = "local nameRealmChecker = Private.ExecEnv.ParseNameCheck(%q)",
        test = "nameRealmChecker:Check(unitname, unitrealm)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseNameCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.unitname, state.unitrealm)
        end,
        operator_types = "none",
        desc = constants.nameRealmFilterDesc,
      },
      {
        name = "icon",
        hidden = true,
        init = "GetUnitPowerBarTextureInfo(unit, 1)",
        store = true,
        test = "true"
      },
      {
        name = "class",
        display = L["Class"],
        type = "select",
        init = "select(2, UnitClass(unit))",
        values = "class_types",
        store = true,
        conditionType = "select"
      },
      {
        name = "specId",
        display = L["Specialization"],
        type = "multiselect",
        init = "WeakAuras.SpecForUnit(unit)",
        values = "spec_types_all",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        desc = L["Requires syncing the specialization via LibSpecialization."],
        sorted = true,
        sortOrder = Private.specs_sorted,
      },
      {
        name = "role",
        display = L["Assigned Role"],
        type = "select",
        init = "UnitGroupRolesAssigned(unit)",
        values = "role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end
      },
      {
        name = "raid_role",
        display = L["Raid Role"],
        type = "select",
        init = "WeakAuras.UnitRaidRole(unit)",
        values = "raid_role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsClassicOrCataOrMists() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end
      },
      {
        name = "raidMarkIndex",
        display = L["Raid Mark"],
        type = "multiselect",
        values = "raid_mark_check_type",
        store = true,
        conditionType = "select",
        init = "GetRaidTargetIndex(unit) or 0"
      },
      {
        name = "raidMark",
        display = L["Raid Mark Icon"],
        store = true,
        hidden = true,
        test = "true",
        init = "raidMarkIndex > 0 and '{rt'..raidMarkIndex..'}' or ''"
      },
      {
        type = "header",
        name = "miscellaneousHeader",
        display = L["Miscellaneous"],
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
      },
      {
        name = "ignoreSelf",
        display = L["Ignore Self"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsUnit(\"player\", unit)"
      },
      {
        name = "ignoreDead",
        display = L["Ignore Dead"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsDeadOrGhost(unit)"
      },
      {
        name = "ignoreDisconnected",
        display = L["Ignore Disconnected"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "UnitIsConnected(unit)"
      },
      {
        name = "inRange",
        display = L["In Range"],
        desc = L["Uses UnitInRange() to check if in range. Matches default raid frames out of range behavior, which is between 25 to 40 yards depending on your class and spec."],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return WeakAuras.IsRetail() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
        end,
        init = "Private.ExecEnv.UnitInRangeFixed(unit)"
      },
      {
        name = "nameplateType",
        display = L["Hostility"],
        type = "select",
        init = "WeakAuras.GetPlayerReaction(unit)",
        values = "hostility_types",
        store = true,
        conditionType = "select",
      },
      {
        hidden = true,
        test = "name and WeakAuras.UnitExistsFixed(unit, smart) and specificUnitCheck"
      }
    },
    automaticrequired = true
  },
  ["Combat Log"] = {
    type = "combatlog",
    events = {
      ["events"] = {"COMBAT_LOG_EVENT_UNFILTERED"}
    },
    init = function(trigger)
      local ret = [[
        local use_cloneId = %s;
      ]];
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    name = L["Combat Log"],
    statesParameter = "all",
    args = {
      {}, -- timestamp ignored with _ argument
      {}, -- messageType ignored with _ argument (it is checked before the dynamic function)
      {}, -- hideCaster ignored with _ argument
      {
        type = "header",
        name = "sourceHeader",
        display = L["Source Info"],
      },
      {
        name = "sourceGUID",
        init = "arg",
        hidden = "true",
        test = "true",
        store = true,
        display = L["Source GUID"],
        formatter = "guid",
        formatterArgs = { color = "class" }
      },
      {
        name = "sourceUnit",
        display = L["Source Unit"],
        type = "unit",
        test = "(sourceGUID or '') == (UnitGUID(%q) or '') and sourceGUID",
        values = "actual_unit_types_with_specific",
        enable = function(trigger)
          return not (trigger.subeventPrefix == "ENVIRONMENTAL")
        end,
        store = true,
        conditionType = "select",
        conditionTest = function(state, needle, op)
          return state and state.show and ((state.sourceGUID or '') == (UnitGUID(needle) or '')) == (op == "==")
        end
      },
      {
        name = "sourceName",
        display = L["Source Name"],
        type = "string",
        multiline = true,
        init = "arg",
        store = true,
        conditionType = "string",
        preamble = "local sourceNameChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "sourceNameChecker:Check(sourceName)",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."],
      },
      {
        name = "sourceNpcId",
        display = L["Source NPC Id"],
        type = "string",
        multiline = true,
        init = "select(6, strsplit('-', sourceGUID or ''))",
        store = true,
        conditionType = "string",
        preamble = "local sourceNpcIdChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "sourceNpcIdChecker:Check(sourceNpcId)",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.sourceNpcId)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."],
        enable = function(trigger)
          return not (trigger.subeventPrefix == "ENVIRONMENTAL")
        end,
      },
      {
        name = "sourceFlags",
        display = L["Source Affiliation"],
        type = "select",
        values = "combatlog_flags_check_type",
        init = "arg",
        store = true,
        test = "Private.ExecEnv.CheckCombatLogFlags(sourceFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckCombatLogFlags(state.sourceFlags, needle)  == (op == "==")
          end
        end
      },
      {
        name = "sourceFlags2",
        display = L["Source Reaction"],
        type = "select",
        values = "combatlog_flags_check_reaction",
        test = "Private.ExecEnv.CheckCombatLogFlagsReaction(sourceFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckCombatLogFlagsReaction(state.sourceFlags, needle)  == (op == "==")
          end
        end
      },
      {
        name = "sourceFlags3",
        display = L["Source Object Type"],
        type = "select",
        values = "combatlog_flags_check_object_type",
        test = "Private.ExecEnv.CheckCombatLogFlagsObjectType(sourceFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckCombatLogFlagsObjectType(state.sourceFlags, needle) == (op == "==")
          end
        end
      },
      {
        name = "sourceRaidFlags",
        display = L["Source Raid Mark"],
        type = "select",
        values = "combatlog_raid_mark_check_type",
        init = "arg",
        store = true,
        test = "Private.ExecEnv.CheckRaidFlags(sourceRaidFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckRaidFlags(state.sourceRaidFlags, needle) == (op == "==")
          end
        end
      },
      {
        name = "sourceRaidMarkIndex",
        display = WeakAuras.newFeatureString .. L["Source unit's raid mark index"],
        init = "WeakAuras.RaidFlagToIndex(sourceRaidFlags)",
        test = "true",
        store = true,
        hidden = true,
      },
      {
        name = "sourceRaidMark",
        display = WeakAuras.newFeatureString .. L["Source unit's raid mark texture"],
        test = "true",
        init = "sourceRaidMarkIndex > 0 and '{rt'..sourceRaidMarkIndex..'}' or ''",
        store = true,
        hidden = true,
      },
      {
        type = "header",
        name = "destHeader",
        display = L["Destination Info"],
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {
        name = "destGUID",
        init = "arg",
        hidden = "true",
        test = "true",
        store = true,
        display = L["Destination GUID"],
        formatter = "guid",
        formatterArgs = { color = "class" }
      },
      {
        name = "destUnit",
        display = L["Destination Unit"],
        type = "unit",
        test = "(destGUID or '') == (UnitGUID(%q) or '') and destGUID",
        values = "actual_unit_types_with_specific",
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
        store = true,
        conditionType = "select",
        conditionTest = function(state, needle, op)
          return state and state.show and ((state.destGUID or '') == (UnitGUID(needle) or '')) == (op == "==")
        end
      },
      {
        name = "destName",
        display = L["Destination Name"],
        type = "string",
        multiline = true,
        init = "arg",
        store = true,
        conditionType = "string",
        preamble = "local destNameChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "destNameChecker:Check(destName)",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."],
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {
        name = "destNpcId",
        display = L["Destination NPC Id"],
        type = "string",
        multiline = true,
        init = "select(6, strsplit('-', destGUID or ''))",
        store = true,
        conditionType = "string",
        preamble = "local destNpcIdChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "destNpcIdChecker:Check(destNpcId)",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.destNpcId)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."],
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      { -- destName ignore for SPELL_CAST_START
        enable = function(trigger)
          return (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end
      },
      {
        name = "destFlags",
        display = L["Destination Affiliation"],
        type = "select",
        values = "combatlog_flags_check_type",
        init = "arg",
        store = true,
        test = "Private.ExecEnv.CheckCombatLogFlags(destFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckCombatLogFlags(state.destFlags, needle) == (op == "==")
          end
        end,
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {
        name = "destFlags2",
        display = L["Destination Reaction"],
        type = "select",
        values = "combatlog_flags_check_reaction",
        test = "Private.ExecEnv.CheckCombatLogFlagsReaction(destFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckCombatLogFlagsReaction(state.destFlags, needle) == (op == "==")
          end
        end,
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {
        name = "destFlags3",
        display = L["Destination Object Type"],
        type = "select",
        values = "combatlog_flags_check_object_type",
        test = "Private.ExecEnv.CheckCombatLogFlagsObjectType(destFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckCombatLogFlagsObjectType(state.destFlags, needle) == (op == "==")
          end
        end,
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {-- destFlags ignore for SPELL_CAST_START
        enable = function(trigger)
          return (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {
        name = "destRaidFlags",
        display = L["Dest Raid Mark"],
        type = "select",
        values = "combatlog_raid_mark_check_type",
        init = "arg",
        store = true,
        test = "Private.ExecEnv.CheckRaidFlags(destRaidFlags, %q)",
        conditionType = "select",
        conditionTest = function(state, needle, op)
          if state and state.show then
            return Private.ExecEnv.CheckRaidFlags(state.destRaidFlags, needle) == (op == "==")
          end
        end,
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      { -- destRaidFlags ignore for SPELL_CAST_START
        enable = function(trigger)
          return (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end
      },
      {
        name = "destRaidMarkIndex",
        display = WeakAuras.newFeatureString .. L["Destination unit's raid mark index"],
        init = "WeakAuras.RaidFlagToIndex(destRaidFlags)",
        test = "true",
        store = true,
        hidden = true,
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {
        name = "destRaidMark",
        display = WeakAuras.newFeatureString .. L["Destination unit's raid mark texture"],
        test = "true",
        init = "destRaidMarkIndex > 0 and '{rt'..destRaidMarkIndex..'}' or ''",
        store = true,
        hidden = true,
        enable = function(trigger)
          return not (trigger.subeventPrefix == "SPELL" and trigger.subeventSuffix == "_CAST_START");
        end,
      },
      {
        type = "header",
        name = "subeventHeader",
        display = L["Subevent Info"],
        enable = function(trigger)
          return trigger.subeventPrefix and (
            trigger.subeventPrefix == "RANGE"
            or trigger.subeventPrefix == "ENVIRONMENTAL"
            or trigger.subeventPrefix:find("DAMAGE")
            or trigger.subeventPrefix:find("SPELL"))

            or trigger.subeventSuffix and (
              trigger.subeventSuffix == "_ABSORBED"
              or trigger.subeventSuffix == "_INTERRUPT"
              or trigger.subeventSuffix == "_DISPEL"
              or trigger.subeventSuffix == "_DISPEL_FAILED"
              or trigger.subeventSuffix == "_STOLEN"
              or trigger.subeventSuffix == "_AURA_BROKEN_SPELL"
              or trigger.subeventSuffix == "_DAMAGE"
              or trigger.subeventSuffix == "_HEAL"
              or trigger.subeventSuffix == "_ENERGIZE"
              or trigger.subeventSuffix == "_DRAIN"
              or trigger.subeventSuffix == "_LEECH"
              or trigger.subeventSuffix == "_DAMAGE"
              or trigger.subeventSuffix == "_MISSED"
              or trigger.subeventSuffix == "_EXTRA_ATTACKS"
              or trigger.subeventSuffix == "_CAST_FAILED"
              or trigger.subeventSuffix:find("DOSE")
              or trigger.subeventSuffix:find("AURA"))
        end,
      },
      {
        name = "spellId",
        display = L["Spell Id"],
        init = "arg",
        enable = function(trigger)
          return trigger.subeventPrefix and (trigger.subeventPrefix:find("SPELL") or trigger.subeventPrefix == "RANGE" or trigger.subeventPrefix:find("DAMAGE"))
        end,
        store = true,
        preambleGroup = "spell",
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddExact(%q)"
        },
        test = "spellChecker:Check(spellId)",
        conditionType = "number",
        type = "spell",
        showExactOption = false,
        noProgressSource = true
      },
      {
        name = "spellName",
        display = L["Spell Name"],
        type = "spell",
        noValidation = true,
        init = "arg",
        enable = function(trigger)
          return trigger.subeventPrefix and (trigger.subeventPrefix:find("SPELL") or trigger.subeventPrefix == "RANGE" or trigger.subeventPrefix:find("DAMAGE"))
        end,
        store = true,
        preambleGroup = "spell",
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddName(%q)"
        },
        test = "spellChecker:Check(spellId)",
        conditionType = "string"
      },
      {
        name = "spellSchool",
        display = WeakAuras.newFeatureString .. L["Spell School"],
        type = "select",
        values = "combatlog_spell_school_types_for_ui",
        sorted = true,
        test = "spellSchool == %d",
        init = "arg",
        conditionType = "select",
        store = true,
        enable = function(trigger)
          return trigger.subeventPrefix and (trigger.subeventPrefix:find("SPELL") or trigger.subeventPrefix == "RANGE" or trigger.subeventPrefix:find("DAMAGE"))
        end
      },
      {
        name = "environmentalType",
        display = L["Environment Type"],
        type = "select",
        init = "arg",
        values = "environmental_types",
        enable = function(trigger)
          return trigger.subeventPrefix == "ENVIRONMENTAL"
        end,
        store = true,
        conditionType = "select"
      },
      {
        name = "missType",
        display = L["Miss Type"],
        type = "select",
        init = "arg",
        values = "miss_types",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_MISSED" or trigger.subeventPrefix == "DAMAGE_SHIELD_MISSED")
        end,
        conditionType = "select",
        store = true
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ABSORBED")
        end
      }, -- source of absorb GUID ignored with SPELL_ABSORBED
      {
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ABSORBED")
        end
      }, -- source of absorb Name ignored with SPELL_ABSORBED
      {
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ABSORBED")
        end
      }, -- source of absorb Flags ignored with SPELL_ABSORBED
      {
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ABSORBED")
        end
      }, -- source of absorb Raid Flags ignored with SPELL_ABSORBED
      {
        name = "extraSpellId",
        display = WeakAuras.newFeatureString .. L["Extra Spell Id"],
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ABSORBED" or trigger.subeventSuffix == "_INTERRUPT" or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_DISPEL_FAILED" or trigger.subeventSuffix == "_STOLEN" or trigger.subeventSuffix == "_AURA_BROKEN_SPELL")
        end,
        test = WeakAuras.IsClassicEra() and "GetSpellInfo(%q or '') == extraSpellName" or nil,
        type = "spell",
        showExactOption = false,
        store = true,
        conditionType = "number",
        noProgressSource = true
      },
      {
        name = "extraSpellName",
        display = L["Extra Spell Name"],
        type = "spell",
        noValidation = true,
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ABSORBED" or trigger.subeventSuffix == "_INTERRUPT" or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_DISPEL_FAILED" or trigger.subeventSuffix == "_STOLEN" or trigger.subeventSuffix == "_AURA_BROKEN_SPELL")
        end,
        store = true,
        conditionType = "string"
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ABSORBED" or trigger.subeventSuffix == "_INTERRUPT" or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_DISPEL_FAILED" or trigger.subeventSuffix == "_STOLEN" or trigger.subeventSuffix == "_AURA_BROKEN_SPELL")
        end
      }, -- extraSchool ignored with _ argument
      {
        name = "auraType",
        display = L["Aura Type"],
        type = "select",
        init = "arg",
        values = "aura_types",
        store = true,
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix:find("AURA") or trigger.subeventSuffix == "_DISPEL" or trigger.subeventSuffix == "_STOLEN")
        end,
        conditionType = "select"
      },
      {
        name = "amount",
        display = L["Amount"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_ABSORBED" or trigger.subeventSuffix == "_DAMAGE" or trigger.subeventSuffix == "_HEAL" or trigger.subeventSuffix == "_ENERGIZE" or trigger.subeventSuffix == "_DRAIN" or trigger.subeventSuffix == "_LEECH" or trigger.subeventPrefix:find("DAMAGE"))
        end,
        store = true,
        conditionType = "number"
      },
      {
        name = "overkill",
        display = L["Overkill"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true,
        conditionType = "number"
      },
      {
        name = "overhealing",
        display = L["Overhealing"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventSuffix == "_HEAL"
        end,
        store = true,
        conditionType = "number"
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end
      }, -- damage school ignored with _ argument
      {
        name = "resisted",
        display = L["Resisted"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true,
        conditionType = "number"
      },
      {
        name = "blocked",
        display = L["Blocked"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true,
        conditionType = "number"
      },
      {
        name = "absorbed",
        display = L["Absorbed"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT" or trigger.subeventSuffix == "_HEAL")
        end,
        store = true,
        conditionType = "number"
      },
      {
        name = "critical",
        display = L["Critical"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT" or trigger.subeventSuffix == "_HEAL")
        end,
        store = true,
        conditionType = "bool"
      },
      {
        name = "glancing",
        display = L["Glancing"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true,
        conditionType = "bool"
      },
      {
        name = "crushing",
        display = L["Crushing"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT")
        end,
        store = true,
        conditionType = "bool"
      },
      {
        name = "isOffHand",
        display = L["Is Off Hand"],
        type = "tristate",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and trigger.subeventPrefix and (
                 trigger.subeventSuffix == "_DAMAGE" or trigger.subeventPrefix == "DAMAGE_SHIELD" or trigger.subeventPrefix == "DAMAGE_SPLIT"
                 or trigger.subeventSuffix == "_MISSED" or trigger.subeventPrefix == "DAMAGE_SHIELD_MISSED")
        end,
        store = true,
        conditionType = "bool"
      },
      {
        name = "number",
        display = L["Number"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_EXTRA_ATTACKS" or trigger.subeventSuffix:find("DOSE"))
        end,
        store = true,
        conditionType = "number"
      },
      {
        name = "overEnergize",
        display = L["Over Energize"],
        type = "number",
        init = "arg",
        store = true,
        conditionType = "number",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ENERGIZE")
        end
      },
      {
        name = "powerType",
        display = L["Power Type"],
        type = "select",
        init = "arg",
        values = "power_types",
        store = true,
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_ENERGIZE" or trigger.subeventSuffix == "_DRAIN" or trigger.subeventSuffix == "_LEECH")
        end,
        conditionType = "select"
      },
      {
        name = "extraAmount",
        display = L["Extra Amount"],
        type = "number",
        init = "arg",
        enable = function(trigger)
          return trigger.subeventSuffix and (trigger.subeventSuffix == "_DRAIN" or trigger.subeventSuffix == "_LEECH")
        end,
        store = true,
        conditionType = "number"
      },
      {
        enable = function(trigger)
          return trigger.subeventSuffix == "_CAST_FAILED"
        end
      }, -- failedType ignored with _ argument - theoretically this is not necessary because it is the last argument in the event, but it is added here for completeness
      {
        type = "header",
        name = "miscellaneousHeader",
        display = L["Miscellaneous"],
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''"
      },
      {
        hidden = true,
        name = "icon",
        init = "(spellId and Private.ExecEnv.GetSpellIcon(spellId)) or 'Interface\\\\Icons\\\\INV_Misc_QuestionMark'",
        store = true,
        test = "true"
      },
    },
    countEvents = true,
    delayEvents = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Spell Activation Overlay"] = {
    type = "spell",
    events = {
    },
    loadInternalEventFunc = function(trigger)
      local name
      if (trigger.use_exact_spellName) then
        name = tonumber(trigger.spellName)
      else
        name = type(trigger.spellName) == "number" and Private.ExecEnv.GetSpellName(trigger.spellName) or trigger.spellName
      end
      if name == nil then return {} end
      return { "WA_UPDATE_OVERLAY_GLOW:" .. name }
    end,
    force_events = "WA_UPDATE_OVERLAY_GLOW",
    name = L["Spell Activation Overlay Glow"],
    loadFunc = function(trigger)
      if (trigger.use_exact_spellName) then
        WeakAuras.WatchSpellActivation(tonumber(trigger.spellName));
      else
        WeakAuras.WatchSpellActivation(type(trigger.spellName) == "number" and Private.ExecEnv.GetSpellName(trigger.spellName) or trigger.spellName);
      end
    end,
    init = function(trigger)
      local spellName
      if (trigger.use_exact_spellName) then
        spellName = trigger.spellName
        local ret = [[
          local spellName = %s
          local icon = Private.ExecEnv.GetSpellIcon(spellName)
        ]]
        return string.format(ret, tonumber(spellName) or "nil");
      else
        spellName = type(trigger.spellName) == "number" and Private.ExecEnv.GetSpellName(trigger.spellName) or trigger.spellName;
        local ret = [[
          local spellName = %q
          local icon = Private.ExecEnv.GetSpellIcon(spellName)
        ]]
        return string.format(ret, spellName or "");
      end
    end,
    GetNameAndIcon = GetNameAndIconForSpellName,
    statesParameter = "one",
    args = {
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        test = "true",
        showExactOption = true
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        hidden = true,
        test = "WeakAuras.SpellActivationActive(spellName)";
      }
    },
    automaticrequired = true,
    progressType = "static"
  },
  ["Cooldown Progress (Spell)"] = {
    type = "spell",
    events = function(trigger)
      if trigger.use_showlossofcontrol then
        return {
          ["events"] = {"LOSS_OF_CONTROL_UPDATE", "LOSS_OF_CONTROL_ADDED"}
        }
      else
        return {}
      end
    end,
    loadInternalEventFunc = function(trigger, untrigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0;
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      if spellName == nil then return {} end
      local events = {
        "SPELL_COOLDOWN_CHANGED:" .. spellName,
        "COOLDOWN_REMAINING_CHECK:" .. spellName,
        "WA_DELAYED_PLAYER_ENTERING_WORLD"
      };
      if (trigger.use_showgcd) then
        tinsert(events, "GCD_START");
        tinsert(events, "GCD_CHANGE");
        tinsert(events, "GCD_END");
      end
      return events;
    end,
    force_events = "SPELL_COOLDOWN_FORCE",
    name = L["Cooldown/Charges/Count"],
    loadFunc = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0;
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local exactMatch = trigger.use_exact_spellName
      local followoverride = not trigger.use_ignoreoverride
      WeakAuras.WatchSpellCooldown(spellName, trigger.use_matchedRune, exactMatch, followoverride)
      if (trigger.use_showgcd) then
        WeakAuras.WatchGCD();
      end
    end,
    init = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local ret = {}

      local showOnCheck = "false";
      if (trigger.genericShowOn == "showOnReady") then
        showOnCheck = "startTime and startTime == 0 or gcdCooldown";
      elseif (trigger.genericShowOn == "showOnCooldown") then
        showOnCheck = "startTime and startTime > 0 and not gcdCooldown";
      elseif (trigger.genericShowOn == "showAlways") then
        showOnCheck = "startTime ~= nil";
      end

      local trackSpecificCharge = trigger.use_trackcharge and trigger.trackcharge and trigger.trackcharge ~= ""
      local track = trigger.track or "auto"
      if track == "auto" and trackSpecificCharge then
        track = "charges"
      end

      table.insert(ret, ([=[
        local spellname = %s
        local ignoreRuneCD = %s
        local showgcd = %s;
        local showlossofcontrol = %s;
        local ignoreSpellKnown = %s;
        local useExact = %s
        local followoverride = %s
        local track = %q
        local effectiveSpellId = Private.ExecEnv.GetEffectiveSpellId(spellname, useExact, followoverride)
        local name, _, icon = Private.ExecEnv.GetSpellInfo(effectiveSpellId)
        local startTime, duration, gcdCooldown, readyTime, modRate, paused = WeakAuras.GetSpellCooldown(effectiveSpellId, ignoreRuneCD, showgcd, ignoreSpellKnown, track)
        local charges, maxCharges, spellCount, chargeGainTime, chargeLostTime = WeakAuras.GetSpellCharges(effectiveSpellId, ignoreSpellKnown)
        local stacks = maxCharges and maxCharges ~= 1 and charges or (spellCount and spellCount > 0 and spellCount) or nil;
        if showlossofcontrol and startTime and duration then
          local locStart, locDuration = WeakAuras.GetSpellLossOfControlCooldown(spellname);
          if locStart and locDuration and (locStart + locDuration) > (startTime + duration) then
            startTime = locStart
            duration = locDuration
          end
        end
        if (charges == nil) then
          -- Use fake charges for spells that use GetSpellCooldown
          charges = (duration == 0 or gcdCooldown) and 1 or 0;
        end
        local genericShowOn = %s
        local expirationTime = startTime and duration and startTime + duration
        state.spellname = spellname;
      ]=]):format(
        spellName,
        (trigger.use_matchedRune and "true" or "false"),
        (trigger.use_showgcd and "true" or "false"),
        (trigger.use_showlossofcontrol and "true" or "false"),
        (trigger.use_ignoreSpellKnown and "true" or "false"),
        (trigger.use_exact_spellName and "true" or "false"),
        (not trigger.use_ignoreoverride and "true" or "false"),
        track,
        showOnCheck
      ))

      if (not trackSpecificCharge) then
        table.insert(ret, [=[
          if paused then
            if not state.paused then
              state.paused = true
              state.expirationTime = nil
              state.changed = true
            end
            if state.remaining ~= startTime then
              state.remaining = startTime
              state.changed = true
            end
          else
            if (state.expirationTime ~= expirationTime) then
              state.expirationTime = expirationTime;
              state.changed = true;
            end

            if state.paused then
              state.paused = false
              state.remaining = nil
              state.changed = true
            end
          end
          if (state.duration ~= duration) then
            state.duration = duration;
            state.changed = true;
          end
          if (state.modRate ~= modRate) then
            state.modRate = modRate;
            state.changed = true;
          end
          state.progressType = 'timed';
        ]=])
      else -- Tracking charges
        local trackedCharge = tonumber(trigger.trackcharge) or 1;
        table.insert(ret, ([=[
          local trackedCharge = %s
          if (charges > trackedCharge) then
            if (state.expirationTime ~= 0) then
              state.expirationTime = 0;
              state.changed = true;
            end
            if (state.duration ~= 0) then
              state.duration = 0;
              state.changed = true;
            end
            state.modRate = nil;
            state.value = nil;
            state.total = nil;
            state.progressType = 'timed';
          else
            if duration then
              expirationTime = expirationTime + (trackedCharge - charges) * duration
            end
            if (state.expirationTime ~= expirationTime) then
              state.expirationTime = expirationTime;
              state.changed = true;
            end
            if (state.duration ~= duration) then
              state.duration = duration;
              state.changed = true;
            end
            if (state.modRate ~= modRate) then
              state.modRate = modRate;
              state.changed = true;
            end
            state.value = nil;
            state.total = nil;
            state.progressType = 'timed';
          end
        ]=]):format(trackedCharge - 1))
      end
      if(trigger.use_remaining and trigger.genericShowOn ~= "showOnReady") then
        table.insert(ret, ([[
          local remaining = 0;
          if (not paused and expirationTime and expirationTime > 0) then
            remaining = expirationTime - GetTime();
            local remainingModRate = remaining / (modRate or 1);
            local remainingCheck = %s;
            if(remainingModRate >= remainingCheck and remainingModRate > 0) then
              local event = "COOLDOWN_REMAINING_CHECK:" .. %s
              Private.ExecEnv.ScheduleScan(expirationTime - remainingCheck * (modRate or 1), event);
            end
          end
        ]]):format(tonumber(trigger.remaining or 0) or 0, spellName))
      end

      return table.concat(ret)
    end,
    GetNameAndIcon = GetNameAndIconForSpellName,
    statesParameter = "one",
    progressType = "timed",
    useModRate = true,
    args = {
      {
      }, -- Ignore first argument (id)
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        test = "true",
        showExactOption = true,
      },
      {
        name = "extra Cooldown Progress (Spell)",
        display = function(trigger)
          return function()
            local text = "";
            if trigger.track == "charges" then
              text = L["Tracking Charge CDs"]
            elseif trigger.track == "cooldown" then
              text = L["Tracking Only Cooldown"]
            end

            if trigger.use_ignoreoverride
            then
              text = text .. L["Ignore Spell Override"]
            end

            if trigger.use_showgcd then
              if text ~= "" then text = text .. "; " end
              text = text .. L["Show GCD"]
            end

            if trigger.use_showlossofcontrol then
              if text ~= "" then text = text .. "; " end
              text = text .. L["Show Loss of Control"]
            end

            if trigger.use_matchedRune then
              if text ~= "" then text = text .. "; " end
              text = text ..L["Ignore Rune CDs"]
            end

            if trigger.use_ignoreSpellKnown then
              if text ~= "" then text = text .. "; " end
              text = text .. L["Disabled Spell Known Check"]
            end

            if trigger.genericShowOn ~= "showOnReady" and trigger.track ~= "cooldown" then
              if trigger.use_trackcharge and trigger.trackcharge ~= "" then
                if text ~= "" then text = text .. "; " end
                text = text .. L["Tracking Charge %i"]:format(trigger.trackcharge)
              end
            end
            if text == "" then
              return L["|cFFffcc00Extra Options:|r None"]
            end
            return L["|cFFffcc00Extra Options:|r %s"]:format(text)
          end
        end,
        type = "collapse",
      },
      {
        name = "track",
        display = L["Track Cooldowns"],
        type = "select",
        values = "cooldown_types",
        collapse = "extra Cooldown Progress (Spell)",
        test = "true",
        required = true,
        default = "auto"
      },
      {
        name = "showgcd",
        display = L["Show Global Cooldown"],
        type = "toggle",
        test = "true",
        collapse = "extra Cooldown Progress (Spell)"
      },
      {
        name = "ignoreoverride",
        display = L["Ignore Spell Override"],
        type = "toggle",
        test = "true",
        collapse = "extra Cooldown Progress (Spell)",
      },
      {
        name = "showlossofcontrol",
        display = WeakAuras.newFeatureString .. L["Show Loss of Control"],
        type = "toggle",
        test = "true",
        collapse = "extra Cooldown Progress (Spell)",
      },
      {
        name = "matchedRune",
        display = L["Ignore Rune CD"],
        type = "toggle",
        test = "true",
        collapse = "extra Cooldown Progress (Spell)"
      },
      {
        name = "ignoreSpellKnown",
        display = L["Disable Spell Known Check"],
        type = "toggle",
        test = "true",
        collapse = "extra Cooldown Progress (Spell)"
      },
      {
        name = "trackcharge",
        display = L["Show CD of Charge"],
        type = "number",
        enable = function(trigger)
          return (trigger.genericShowOn ~= "showOnReady") and trigger.track ~= "cooldown"
        end,
        test = "true",
        noOperator = true,
        collapse = "extra Cooldown Progress (Spell)"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return (trigger.genericShowOn ~= "showOnReady") end
      },
      {
        name = "charges",
        display = L["Charges"],
        type = "number",
        store = true,
        conditionType = "number",
        progressTotal = "maxCharges"
      },
      {
        name = "spellCount",
        display = L["Spell Count"],
        type = "number",
        store = true,
        conditionType = "number"
      },
      {
        name = "stacks",
        init = "stacks",
        hidden = true,
        test = "true",
        store = true
      },
      {
        hidden  = true,
        name = "maxCharges",
        store = true,
        display = L["Max Charges"],
        conditionType = "number",
        test = "true",
      },
      {
        hidden = true,
        name = "readyTime",
        display = L["Since Ready"],
        conditionType = "elapsedTimer",
        store = true,
        test = "true"
      },
      {
        hidden = true,
        name = "chargeGainTime",
        display = L["Since Charge Gain"],
        conditionType = "elapsedTimer",
        store = true,
        test = "true"
      },
      {
        hidden = true,
        name = "chargeLostTime",
        display = L["Since Charge Lost"],
        conditionType = "elapsedTimer",
        store = true,
        test = "true"
      },
      {
        hidden = true,
        name = "effectiveSpellId",
        display = L["Effective Spell Id"],
        conditionType = "number",
        store = true,
        test = "true",
        operator_types = "only_equal"
      },
      {
        name = "genericShowOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        required = true,
        default = "showOnCooldown"
      },
      {
        hidden = true,
        name = "onCooldown",
        test = "true",
        display = L["On Cooldown"],
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (state.paused or (not state.gcdCooldown and state.expirationTime and state.expirationTime > GetTime())) == (needle == 1)
        end,
      },
      {
        hidden = true,
        name = "gcdCooldown",
        store = true,
        test = "true"
      },
      {
        name = "spellUsable",
        display = L["Spell Usable"],
        hidden = true,
        test = "true",
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (Private.ExecEnv.IsUsableSpell(state.spellname or "") == (needle == 1))
        end,
        conditionEvents = AddTargetConditionEvents({
          "SPELL_UPDATE_USABLE",
          "UNIT_POWER_FREQUENT:player"
        }),
      },
      {
        name = "insufficientResources",
        display = L["Insufficient Resources"],
        hidden = true,
        test = "true",
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (select(2, Private.ExecEnv.IsUsableSpell(state.spellname or "")) == (needle == 1));
        end,
        conditionEvents = AddTargetConditionEvents({
          "SPELL_UPDATE_USABLE",
          "UNIT_POWER_FREQUENT:player"
        }),
      },
      {
        name = "spellInRange",
        display = L["Spell in Range"],
        hidden = true,
        test = "true",
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (UnitExists('target') and state.spellname and WeakAuras.IsSpellInRange(state.spellname, 'target') == needle)
        end,
        conditionEvents = AddTargetConditionEvents({
          "WA_SPELL_RANGECHECK",
        }),
      },
      {
        hidden = true,
        test = "genericShowOn"
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
    },
    hasSpellID = true,
    automaticrequired = true,
  },
  ["Cooldown Ready (Spell)"] = {
    type = "spell",
    events = {},
    loadInternalEventFunc = function(trigger, untrigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      if spellName == nil then return {} end
      return { "SPELL_COOLDOWN_READY:" .. spellName }
    end,
    name = L["Cooldown Ready Event"],
    loadFunc = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local useExact = trigger.use_exact_spellName
      local followoverride = not trigger.use_ignoreoverride
      WeakAuras.WatchSpellCooldown(spellName, false, useExact, followoverride)
    end,
    init = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local ret = [=[
        local triggerSpellName = %s
        local useExact = %s
        local followoverride = %s
        local name, _, icon = Private.ExecEnv.GetSpellInfo(overrideSpell)
        local effectiveTriggerSpellName = Private.ExecEnv.GetEffectiveSpellId(triggerSpellName, useExact, followoverride)
        local match = overrideSpell == effectiveTriggerSpellName
      ]=]
      return ret:format(spellName,
                        trigger.use_exact_spellName and "true" or "false",
                        not trigger.use_ignoreoverride and "true" or "false")
    end,
    GetNameAndIcon = GetNameAndIconForSpellName,
    statesParameter = "one",
    args = {
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        init = "arg",
        showExactOption = true,
        test = "match",
      },
      {
        name = "overrideSpell",
        init = "arg",
        hidden = true,
        test = "true"
      },
      {
        name = "ignoreoverride",
        display = L["Ignore Spell Override"],
        type = "toggle",
        test = "true",
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
    },
    hasSpellID = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Charges Changed"] = {
    type = "spell",
    events = {},
    loadInternalEventFunc = function(trigger, untrigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      if spellName == nil then return {} end
      return { "SPELL_CHARGES_CHANGED:" .. spellName }
    end,
    name = L["Charges Changed Event"],
    loadFunc = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local useExact = trigger.use_exact_spellName
      local followoverride = not trigger.use_ignoreoverride
      WeakAuras.WatchSpellCooldown(spellName, false, useExact, followoverride)
    end,
    init = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local ret = [=[
        local triggerSpellName = %s
        local useExact = %s
        local followoverride = %s
        local effectiveTriggerSpellName = Private.ExecEnv.GetEffectiveSpellId(triggerSpellName, useExact, followoverride)
        local name, _, icon = Private.ExecEnv.GetSpellInfo(overrideSpell)
        local match = overrideSpell == effectiveTriggerSpellName
      ]=]
      return ret:format(spellName,
                        trigger.use_exact_spellName and "true" or "false",
                        not trigger.use_ignoreoverride and "true" or "false")
    end,
    statesParameter = "one",
    GetNameAndIcon = GetNameAndIconForSpellName,
    args = {
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        init = "arg",
        showExactOption = true,
        test = "match",
      },
      {
        name = "overrideSpell",
        init = "arg",
        hidden = true,
        test = "true"
      },
      {
        name = "ignoreoverride",
        display = L["Ignore Spell Override"],
        type = "toggle",
        test = "true",
      },
      {
        name = "direction",
        required = true,
        display = L["Charge gained/lost"],
        type = "select",
        values = "charges_change_type",
        init = "arg",
        test = "Private.ExecEnv.CheckChargesDirection(direction, %q)",
        store = true,
        conditionType = "select",
        conditionValues = "charges_change_condition_type";
        conditionTest = function(state, needle)
          return state and state.show and state.direction and Private.ExecEnv.CheckChargesDirection(state.direction, needle)
        end,
      },
      {
        name = "charges",
        display = L["Charges"],
        type = "number",
        init = "arg",
        store = true,
        conditionType = "number"
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
    },
    hasSpellID = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Cooldown Progress (Item)"] = {
    type = "item",
    events = {},
    internal_events = function(trigger, untrigger)
      local itemName = type(trigger.itemName) == "number" and trigger.itemName or string.format("%q", trigger.itemName or "0")
      local events = {
        "ITEM_COOLDOWN_READY:" .. itemName,
        "ITEM_COOLDOWN_CHANGED:" .. itemName,
        "ITEM_COOLDOWN_STARTED:" .. itemName,
        "COOLDOWN_REMAINING_CHECK:" .. itemName,
      }
      if (trigger.use_showgcd) then
        tinsert(events, "GCD_START");
        tinsert(events, "GCD_CHANGE");
        tinsert(events, "GCD_END");
      end
      return events
    end,
    force_events = "ITEM_COOLDOWN_FORCE",
    name = L["Cooldown Progress (Item)"],
    loadFunc = function(trigger)
      WeakAuras.WatchItemCooldown(trigger.itemName or 0)
      if (trigger.use_showgcd) then
        WeakAuras.WatchGCD();
      end
    end,
    init = function(trigger)
      local itemName = type(trigger.itemName) == "number" and trigger.itemName or string.format("%q", trigger.itemName or "0")
      local ret = [=[
        local itemname = %s;
        local name = C_Item.GetItemInfo(itemname or 0) or "Invalid"
        local itemId, _, _, _, icon = C_Item.GetItemInfoInstant(itemname or 0)
        local showgcd = %s
        local startTime, duration, enabled, gcdCooldown = WeakAuras.GetItemCooldown(itemname, showgcd);
        local expirationTime = startTime + duration
        local genericShowOn = %s
        state.itemname = itemname;
      ]=];
      if(trigger.use_remaining and trigger.genericShowOn ~= "showOnReady") then
        local ret2 = [[
          local remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0;
          local remainingCheck = %s;
          if(remaining >= remainingCheck and remaining > 0) then
            local event = "COOLDOWN_REMAINING_CHECK:" .. %s
            Private.ExecEnv.ScheduleScan(expirationTime - remainingCheck, event);
          end
        ]];
        ret = ret..ret2:format(tonumber(trigger.remaining or 0) or 0, itemName);
      end
      return ret:format(itemName,
                        trigger.use_showgcd and "true" or "false",
                        "[[" .. (trigger.genericShowOn or "") .. "]]");
    end,
    GetNameAndIcon = function(trigger)
      local name = C_Item.GetItemInfo(trigger.itemName or 0)
      local _, _, _, _, icon = C_Item.GetItemInfoInstant(trigger.itemName or 0)
      return name, icon
    end,
    statesParameter = "one",
    args = {
      {
        name = "itemName",
        required = true,
        display = L["Item"],
        type = "item",
        test = "true"
      },
      {
        name = "itemId",
        display = WeakAuras.newFeatureString .. L["ItemId"],
        hidden = true,
        init = "itemId",
        test = "true",
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return (trigger.genericShowOn ~= "showOnReady") end,
        init = "remaining"
      },
      {
        name = "extra Cooldown Progress (Item)",
        display = function(trigger)
          return function()
            local text = "";
            if trigger.use_showgcd then
              if text ~= "" then text = text .. "; " end
              text = text .. L["Show GCD"]
            end
            if text == "" then
              return L["|cFFffcc00Extra Options:|r None"]
            end
            return L["|cFFffcc00Extra Options:|r %s"]:format(text)
          end
        end,
        type = "collapse",
      },
      {
        name = "showgcd",
        display = L["Show Global Cooldown"],
        type = "toggle",
        test = "true",
        collapse = "extra Cooldown Progress (Item)"
      },
      {
        name = "genericShowOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        required = true,
        default = "showOnCooldown"
      },
      {
        hidden = true,
        name = "enabled",
        store = true,
        test = "true",
      },
      {
        hidden = true,
        name = "onCooldown",
        test = "true",
        display = L["On Cooldown"],
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (not state.gcdCooldown and state.expirationTime and state.expirationTime > GetTime() or state.enabled == 0) == (needle == 1)
        end,
      },
      {
        hidden = true,
        name = "gcdCooldown",
        store = true,
        test = "true"
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "progressType",
        hidden = true,
        init = "'timed'",
        store = true,
        test = "true"
      },
      {
        name = "duration",
        hidden = true,
        init = "duration",
        test = "true",
        store = true
      },
      {
        name = "expirationTime",
        init = "expirationTime",
        hidden = true,
        test = "true",
        store = true
      },
      {
        hidden = true,
        test = "(genericShowOn == \"showOnReady\" and (startTime == 0 and enabled == 1 or gcdCooldown))" ..
        "or (genericShowOn == \"showOnCooldown\" and (startTime > 0 or enabled == 0) and not gcdCooldown) " ..
        "or (genericShowOn == \"showAlways\")"
      }
    },
    hasItemID = true,
    automaticrequired = true,
    progressType = "timed"
  },
  ["Cooldown Progress (Equipment Slot)"] = {
    type = "item",
    events = {
      ["unit_events"] = {
        ["player"] = {"UNIT_INVENTORY_CHANGED"}
      }
    },
    internal_events = function(trigger, untrigger)
      local slot = trigger.itemSlot or 0
      local events = {
        "ITEM_SLOT_COOLDOWN_STARTED:" .. slot,
        "ITEM_SLOT_COOLDOWN_CHANGED:" .. slot,
        "COOLDOWN_REMAINING_CHECK:" .. slot,
        "ITEM_SLOT_COOLDOWN_ITEM_CHANGED:" .. slot,
        "ITEM_SLOT_COOLDOWN_READY:" .. slot,
        "WA_DELAYED_PLAYER_ENTERING_WORLD"
      }

      if (trigger.use_showgcd) then
        tinsert(events, "GCD_START");
        tinsert(events, "GCD_CHANGE");
        tinsert(events, "GCD_END");
      end

      return events
    end,
    force_events = "ITEM_COOLDOWN_FORCE",
    name = L["Cooldown Progress (Slot)"],
    loadFunc = function(trigger)
      WeakAuras.WatchItemSlotCooldown(trigger.itemSlot);
      if (trigger.use_showgcd) then
        WeakAuras.WatchGCD();
      end
    end,
    init = function(trigger)
      local ret = [[
        local showgcd = %s
        local itemSlot = %s
        local startTime, duration, enable, gcdCooldown = WeakAuras.GetItemSlotCooldown(itemSlot, showgcd)
        local expirationTime = startTime + duration
        local genericShowOn = %s
        local remaining = startTime + duration - GetTime();

        local name = ""
        local item = GetInventoryItemID("player", itemSlot or 0)
        if item then
          name = (C_Item.GetItemInfo(item))
        end
        local icon = GetInventoryItemTexture("player", itemSlot or 0)
        local stacks = GetInventoryItemCount("player", itemSlot or 0)
        if ((stacks == 1) and (not GetInventoryItemTexture("player", itemSlot or 0))) then
          stacks = 0
        end
      ]];
      if(trigger.use_remaining and trigger.genericShowOn ~= "showOnReady") then
        local ret2 = [[
          local remaining = expirationTime > 0 and (expirationTime - GetTime()) or 0;
          local remainingCheck = %s;
          if(remaining >= remainingCheck and remaining > 0) then
            local event = "COOLDOWN_REMAINING_CHECK:" .. %s
            Private.ExecEnv.ScheduleScan(expirationTime - remainingCheck, event);
          end
        ]];
        ret = ret..ret2:format(tonumber(trigger.remaining or 0) or 0, trigger.itemSlot or 0);
      end
      return ret:format(trigger.use_showgcd and "true" or "false",
                        trigger.itemSlot or "0",
                        "[[" .. (trigger.genericShowOn or "") .. "]]");
    end,
    GetNameAndIcon = function(trigger)
      local item = GetInventoryItemID("player", trigger.itemSlot or 0);
      local name
      if (item) then
        name = C_Item.GetItemInfo(item)
      end
      local icon = GetInventoryItemTexture("player", trigger.itemSlot or 0)
      return name, icon
    end,
    statesParameter = "one",
    args = {
      {
        name = "itemId",
        display = WeakAuras.newFeatureString .. L["ItemId"],
        hidden = true,
        init = "item",
        test = "true",
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
      },
      {
        name = "itemSlot",
        required = true,
        display = L["Equipment Slot"],
        type = "select",
        values = "item_slot_types",
        test = "true"
      },
      {
        name = "extra Cooldown Progress (Equipment Slot)",
        display = function(trigger)
          return function()
            local text = "";
            if trigger.use_showgcd then
              if text ~= "" then text = text .. "; " end
              text = text .. L["Show GCD"]
            end
            if text == "" then
              return L["|cFFffcc00Extra Options:|r None"]
            end
            return L["|cFFffcc00Extra Options:|r %s"]:format(text)
          end
        end,
        type = "collapse",
      },
      {
        name = "showgcd",
        display = L["Show Global Cooldown"],
        type = "toggle",
        test = "true",
        collapse = "extra Cooldown Progress (Equipment Slot)"
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return (trigger.genericShowOn ~= "showOnReady") end,
        init = "remaining"
      },
      {
        name = "testForCooldown",
        display = L["is useable"],
        type = "toggle",
        test = "enable == 1"
      },
      {
        name = "genericShowOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        required = true,
        default = "showOnCooldown"
      },
      {
        name = "progressType",
        hidden = true,
        init = "'timed'",
        store = true,
        test = "true"
      },
      {
        name = "duration",
        hidden = true,
        init = "duration",
        test = "true",
        store = true
      },
      {
        name = "expirationTime",
        init = "expirationTime",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "itemId",
        display = L["ItemId"],
        hidden = true,
        init = "item",
        test = "true",
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "stacks",
        display = L["Stacks"],
        init = "stacks",
        hidden = true,
        test = "true",
        store = true,
        conditionType = "number"
      },
      {
        hidden = true,
        name = "onCooldown",
        test = "true",
        display = L["On Cooldown"],
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (not state.gcdCooldown and state.expirationTime and state.expirationTime > GetTime()) == (needle == 1);
        end,
      },
      {
        hidden = true,
        name = "gcdCooldown",
        store = true,
        test = "true"
      },
      {
        hidden = true,
        test = "(genericShowOn == \"showOnReady\" and (startTime == 0 or gcdCooldown)) " ..
        "or (genericShowOn == \"showOnCooldown\" and startTime > 0 and not gcdCooldown) " ..
        "or (genericShowOn == \"showAlways\")"
      }
    },
    automaticrequired = true,
    hasItemID = true,
    progressType = "timed"
  },
  ["Cooldown Ready (Item)"] = {
    type = "item",
    events = {},
    internal_events = function(trigger)
      return { "ITEM_COOLDOWN_READY:" .. (trigger.itemName or 0) }
    end,
    name = L["Cooldown Ready Event (Item)"],
    loadFunc = function(trigger)
      WeakAuras.WatchItemCooldown(trigger.itemName or 0)
    end,
    init = function(trigger)
      local ret = [[
        local itemName = %s
        local name = C_Item.GetItemInfo(itemName) or "Invalid"
        local itemId, _, _, _, icon = C_Item.GetItemInfoInstant(itemName)
      ]]

      local itemName = type(trigger.itemName) == "number" and trigger.itemName or string.format("%q", trigger.itemName or "0")
      return ret:format(itemName)
    end,
    GetNameAndIcon = function(trigger)
      local name = C_Item.GetItemInfo(trigger.itemName or 0)
      local _, _, _, _, icon = C_Item.GetItemInfoInstant(trigger.itemName or 0)
      return name, icon
    end,
    statesParameter = "one",
    args = {
      {
        name = "itemName",
        required = true,
        display = L["Item"],
        type = "item",
        init = "arg"
      },
      {
        name = "itemId",
        display = WeakAuras.newFeatureString .. L["ItemId"],
        hidden = true,
        init = "itemId",
        test = "true",
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
    },
    hasItemID = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Cooldown Ready (Equipment Slot)"] = {
    type = "item",
    events = {},
    internal_events = function(trigger)
      return {
        "ITEM_SLOT_COOLDOWN_READY:" .. (trigger.itemSlot or 0)
      }
    end,
    name = L["Cooldown Ready Event (Slot)"],
    loadFunc  = function(trigger)
      WeakAuras.WatchItemSlotCooldown(trigger.itemSlot);
    end,
    init = function(trigger)
      local ret = [[
        local itemSlot = %s
        local item = GetInventoryItemID("player", itemSlot)
        local name = ""
        if (item) then
          name = C_Item.GetItemInfo(item)
        end
        local icon = GetInventoryItemTexture("player", itemSlot)
      ]]

      return ret:format(trigger.itemSlot or 0)
    end,
    GetNameAndIcon = function(trigger)
      local item = GetInventoryItemID("player", trigger.itemSlot or 0)
      local name = item and C_Item.GetItemInfo(item) or nil
      local icon = GetInventoryItemTexture("player", trigger.itemSlot or 0)
      return name, icon
    end,
    statesParameter = "one",
    args = {
      {
        name = "itemSlot",
        required = true,
        display = L["Equipment Slot"],
        type = "select",
        values = "item_slot_types",
        init = "arg"
      },
      {
        name = "itemId",
        display = WeakAuras.newFeatureString .. L["ItemId"],
        hidden = true,
        init = "item",
        test = "true",
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
    },
    hasItemID = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["GTFO"] = {
    type = "addons",
    events = {
      ["events"] = {"GTFO_DISPLAY"}
    },
    name = L["GTFO Alert"],
    statesParameter = "one",
    args = {
      {
        name = "alertType",
        display = L["Alert Type"],
        type = "select",
        init = "arg",
        values = "gtfo_types",
        store = true,
        conditionType = "select"
      },
    },
    timedrequired = true,
    progressType = "timed"
  },
  ["Global Cooldown"] = {
    type = "spell",
    events = {},
    internal_events = {
      "GCD_START",
      "GCD_CHANGE",
      "GCD_END",
      "GCD_UPDATE",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = "GCD_UPDATE",
    name = L["Global Cooldown"],
    loadFunc = function(trigger)
      WeakAuras.WatchGCD();
    end,
    init = function(trigger)
      local ret = [[
        local inverse = %s;
        local duration, expirationTime, name, icon = WeakAuras.GetGCDInfo()
        local hasSpellName = WeakAuras.GcdSpellName();
      ]];
      return ret:format(trigger.use_inverse and "true" or "false");
    end,
    statesParameter = "one",
    args = {
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "duration",
        hidden = true,
        init = "duration",
        test = "true",
        store = true
      },
      {
        name = "expirationTime",
        init = "expirationTime",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "progressType",
        hidden = true,
        init = "'timed'",
        test = "true",
        store = true
      },
      {
        hidden = true,
        test = "(inverse and duration == 0) or (not inverse and duration > 0 and hasSpellName)"
      }
    },
    hasSpellID = true,
    automaticrequired = true,
    progressType = "timed"
  },
  ["Swing Timer"] = {
    type = "unit",
    events = {},
    internal_events = {
      "SWING_TIMER_UPDATE"
    },
    force_events = "SWING_TIMER_UPDATE",
    name = L["Swing Timer"],
    loadFunc = function()
      WeakAuras.InitSwingTimer();
    end,
    init = function(trigger)
      local ret = [=[
        local inverse = %s;
        local hand = %q;
        local triggerRemaining = %s
        local duration, expirationTime, name, icon = WeakAuras.GetSwingTimerInfo(hand)
        local remaining = expirationTime and expirationTime - GetTime()
        local remainingCheck = not triggerRemaining or remaining and remaining %s triggerRemaining

        if triggerRemaining and remaining and remaining >= triggerRemaining and remaining > 0 then
          Private.ExecEnv.ScheduleScan(expirationTime - triggerRemaining, "SWING_TIMER_UPDATE")
        end
      ]=];
      return ret:format(
        (trigger.use_inverse and "true" or "false"),
        trigger.hand or "main",
        trigger.use_remaining and tonumber(trigger.remaining or 0) or "nil",
        trigger.remaining_operator or "<"
      );
    end,
    args = {
      {
        name = "note",
        type = "description",
        display = "",
        text = function()
          if not WeakAuras.IsRetail() then
            return L["Note: Due to how complicated the swing timer behavior is and the lack of APIs from Blizzard, results are inaccurate in edge cases."]
          end
        end,

      },
      {
        name = "hand",
        required = true,
        display = L["Weapon"],
        type = "select",
        values = "swing_types",
        test = "true"
      },
      {
        name = "duration",
        hidden = true,
        init = "duration",
        test = "true",
        store = true
      },
      {
        name = "expirationTime",
        init = "expirationTime",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "progressType",
        hidden = true,
        init = "'timed'",
        test = "true",
        store = true
      },
      {
        name = "name",
        hidden = true,
        init = "name",
        test = "true",
        store = true
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return not trigger.use_inverse end,
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        test = "(inverse and duration == 0) or (not inverse and duration > 0)"
      },
      {
        hidden = true,
        test = "remainingCheck"
      }
    },
    automaticrequired = true,
    progressType = "timed",
    statesParameter = "one"
  },
  ["Action Usable"] = {
    type = "spell",
    events = function()
      local events = {
        "SPELL_UPDATE_USABLE",
        "PLAYER_TARGET_CHANGED",
        "RUNE_POWER_UPDATE",
        "PLAYER_SOFT_ENEMY_CHANGED",
        "PLAYER_SOFT_FRIEND_CHANGED"
      }
      if WeakAuras.IsCataOrMists() then
        tinsert(events, "RUNE_TYPE_UPDATE")
      end

      return {
        ["events"] = events,
        ["unit_events"] = {
          ["player"] = { "UNIT_POWER_FREQUENT" }
        }
      }
    end,
    loadInternalEventFunc = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      if spellName == nil then return {} end
      return { "SPELL_COOLDOWN_CHANGED:" .. spellName }
    end,
    force_events = "SPELL_UPDATE_USABLE",
    name = L["Spell Usable"],
    statesParameter = "one",
    loadFunc = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local useExact = trigger.use_exact_spellName
      local followoverride = not trigger.use_ignoreoverride
      WeakAuras.WatchSpellCooldown(spellName, false, useExact, followoverride)
    end,
    init = function(trigger)
      local spellName = type(trigger.spellName) ~= "table" and trigger.spellName or 0
      if type(trigger.spellName) == "string" then
        spellName = select(7, Private.ExecEnv.GetSpellInfo(spellName)) or 0
      end
      local ret = [=[
        local spellName = %s
        local useExact = %s
        local followoverride = %s
        local effectiveSpellId = Private.ExecEnv.GetEffectiveSpellId(spellName, useExact, followoverride)
        local name, _, icon = Private.ExecEnv.GetSpellInfo(effectiveSpellId)
      ]=]

      if trigger.use_ignoreSpellCooldown then
        ret = ret .. [=[local active = Private.ExecEnv.IsUsableSpell(spellName or "")]=]
      else
        ret = ret .. [=[
        local startTime, duration, gcdCooldown, readyTime, paused = WeakAuras.GetSpellCooldown(effectiveSpellId, nil, nil, nil, nil)
        local charges, maxCharges, spellCount, chargeGainTime, chargeLostTime = WeakAuras.GetSpellCharges(effectiveSpellId, nil)
        local stacks = maxCharges and maxCharges > 1 and charges
                       or spellCount and spellCount > 0 and spellCount
                       or nil
        if (charges == nil) then
          charges = (duration == 0 or gcdCooldown) and 1 or 0;
        end
        local ready = (startTime == 0 and not paused) or charges > 0
        local active = Private.ExecEnv.IsUsableSpell(spellName or "") and ready
        ]=]
      end
      if(trigger.use_targetRequired) then
        ret = ret.."active = active and WeakAuras.IsSpellInRange(spellName or '', 'target')\n";
      end
      if(trigger.use_inverse) then
        ret = ret.."active = not active\n";
      end

      if (type(spellName) == "string") then
        spellName = string.format("%q", spellName)
      end

      return ret:format(spellName,
                        trigger.use_exact_spellName and "true" or "false",
                        not trigger.use_ignoreoverride and "true" or "false")
    end,
    GetNameAndIcon = GetNameAndIconForSpellName,
    args = {
      {
        name = "spellName",
        display = L["Spell"],
        required = true,
        type = "spell",
        test = "true",
        showExactOption = true,
        store = true
      },
      {
        name = "ignoreoverride",
        display = L["Ignore Spell Override"],
        type = "toggle",
        test = "true",
      },
      -- This parameter uses the IsSpellInRange API function, but it does not check spell range at all
      -- IsSpellInRange returns nil for invalid targets, 0 for out of range, 1 for in range (0 and 1 are both "positive" values)
      {
        name = "targetRequired",
        display = L["Require Valid Target"],
        type = "toggle",
        test = "true"
      },
      {
        name = "ignoreSpellCooldown",
        display = L["Ignore Spell Cooldown/Charges"],
        type = "toggle",
        test = "true"
      },
      {
        name = "charges",
        display = L["Charges"],
        type = "number",
        enable = function(trigger) return not trigger.use_inverse and not trigger.use_ignoreSpellCooldown end,
        store = true,
        conditionType = "number",
      },
      {
        name = "spellCount",
        display = L["Spell Count"],
        type = "number",
        enable = function(trigger) return not trigger.use_ignoreSpellCooldown end,
        store = true,
        conditionType = "number",
      },
      {
        hidden = true,
        name = "readyTime",
        display = L["Since Ready"],
        conditionType = "elapsedTimer",
        store = true,
        test = "true",
        enable = function(trigger) return not trigger.use_ignoreSpellCooldown end,
      },
      {
        hidden = true,
        name = "chargeGainTime",
        display = L["Since Charge Gain"],
        conditionType = "elapsedTimer",
        store = true,
        test = "true",
        enable = function(trigger) return not trigger.use_ignoreSpellCooldown end,
      },
      {
        hidden = true,
        name = "chargeLostTime",
        display = L["Since Charge Lost"],
        conditionType = "elapsedTimer",
        store = true,
        test = "true",
        enable = function(trigger) return not trigger.use_ignoreSpellCooldown end,
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
        reloadOptions = true
      },
      {
        name = "spellInRange",
        display = L["Spell in Range"],
        hidden = true,
        test = "true",
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (UnitExists('target') and state.spellName and WeakAuras.IsSpellInRange(state.spellName, 'target') == needle)
        end,
        conditionEvents = AddTargetConditionEvents({
          "WA_SPELL_RANGECHECK",
        })
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "stacks",
        display = L["Stacks"],
        hidden = true,
        init = "stacks",
        test = "true",
        store = true,
        conditionType = "number",
        enable = function(trigger) return not trigger.use_ignoreSpellCooldown end,
      },
      {
        hidden = true,
        test = "active"
      }
    },
    hasSpellID = true,
    automaticrequired = true,
    progressType = "none"
  },
  ["Talent Known"] = {
    type = "unit",
    events = function()
      local events
      if WeakAuras.IsClassicEra() then
        events = {
          "CHARACTER_POINTS_CHANGED",
          "SPELLS_CHANGED"
        }
      elseif WeakAuras.IsCataOrMists() then
        events = {
          "CHARACTER_POINTS_CHANGED",
          "SPELLS_CHANGED",
          "PLAYER_TALENT_UPDATE"
        }
      elseif WeakAuras.IsRetail() then
        -- nothing
      end
      return {
        ["events"] = events
      }
    end,
    internal_events = WeakAuras.IsRetail() and  {"WA_TALENT_UPDATE"} or nil,
    force_events = (WeakAuras.IsRetail() and "TRAIT_CONFIG_UPDATED") or "CHARACTER_POINTS_CHANGED",
    name = L["Talent Known"],
    init = function(trigger)
      local inverse = trigger.use_inverse and not WeakAuras.IsMistsOrRetail()
      local ret = {}
      if (trigger.use_talent) then
        -- Single selection
        local index = trigger.talent and trigger.talent.single;
        local tier = index and ceil(index / MAX_NUM_TALENTS)
        local column = index and ((index - 1) % MAX_NUM_TALENTS + 1)
        table.insert(ret, ([[
          local tier = %s;
          local column = %s;
          local active = false
          local name, icon, _, _, rank = Private.ExecEnv.GetTalentInfo(tier, column)
          if rank and rank > 0 then
            active = true;
            activeName = name;
            activeIcon = icon;
          end
        ]]):format(tier or 0, column or 0))
        if (inverse) then
          table.insert(ret, [[
            active = not (active);
          ]])
        end
      elseif (trigger.use_talent == false) then
        if (trigger.talent.multi) then
          table.insert(ret, [[
            local active = true
            local activeIcon, activeName, _
          ]])
          if WeakAuras.IsRetail() then
            table.insert(ret, [[
              local index
              local rank = 0
            ]])
          else
            table.insert(ret, [[
              local tier
              local column
            ]])
          end
          for index, value in pairs(trigger.talent.multi) do
            if WeakAuras.IsClassicOrCata() then
              local tier = index and ceil(index / MAX_NUM_TALENTS)
              local column = index and ((index - 1) % MAX_NUM_TALENTS + 1)
              table.insert(ret, ([[
                if (not active) then
                  tier = %s
                  column = %s
                  local name, icon, _, _, rank = Private.ExecEnv.GetTalentInfo(tier, column)
                  if rank > 0 then
                    active = true;
                    activeName = name;
                    activeIcon = icon;
                  end
                end
              ]]):format(tier, column))
            elseif WeakAuras.IsMists() then
              local tier = index and math.ceil(index / 3)
              local column = index and (index - 1) % 3 + 1
              table.insert(ret, ([[
                tier = %s
                column = %s
                local shouldBeActive = %s
                local talentInfo = C_SpecializationInfo.GetTalentInfo({tier = tier, column = column})
                if talentInfo then
                  activeName = talentInfo.name
                  activeIcon = talentInfo.icon
                  if talentInfo.selected ~= shouldBeActive then
                    active = false
                  end
                end
              ]]):format(tier, column, value and "true" or "false"))
            elseif WeakAuras.IsRetail() then
              table.insert(ret, ([[
                local talentId = %s
                local shouldBeActive = %s
                if talentId then
                  activeName, activeIcon, _, rank = WeakAuras.GetTalentById(talentId)
                  if activeName ~= nil then
                    if rank > 0 ~= shouldBeActive then
                      active = false
                    end
                  end
                end
              ]]):format(index, value and "true" or "false"))
            end
          end
          if (inverse) then
            table.insert(ret, [[
              active = not (active);
            ]])
          end
        end
      end
      if (WeakAuras.IsTWW() and trigger.use_herotalent == false) then
        if (trigger.herotalent.multi) then
          table.insert(ret, [[
            local heroActive = true
            local activeIcon, activeName, _
            local index
          ]])
          for index, value in pairs(trigger.herotalent.multi) do
            table.insert(ret, ([[
              local talentId = %s
              local shouldBeActive = %s
              if talentId then
                activeName, activeIcon, _, rank = WeakAuras.GetTalentById(talentId)
                if activeName ~= nil then
                  if rank > 0 ~= shouldBeActive then
                    heroActive = false
                  end
                end
              end
            ]]):format(index, value and "true" or "false"))
          end
          if (inverse) then
            table.insert(ret, [[
              heroActive = not (heroActive);
            ]])
          end
        end
      end
      return table.concat(ret)
    end,
    args = {
      {
        name = "class",
        display = L["Class"],
        type = "select",
        init = "select(2, UnitClass('player'))",
        values = "class_types",
        store = true,
        conditionType = "select",
        required = true,
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
        reloadOptions = true,
      },
      {
        name = "spec",
        display = L["Talent Specialization"],
        type = "select",
        init = "WeakAuras.IsRetail() and Private.ExecEnv.GetSpecialization()",
        required = true,
        values = function(trigger)
          return WeakAuras.spec_types_specific[trigger.class]
        end,
        enable = function(trigger)
          if WeakAuras.IsRetail() and trigger.use_class and trigger.class then
            return true
          else
            return false
          end
        end,
        reloadOptions = true,
      },
      {
        name = "talent",
        display = L["Talent"],
        type = "multiselect",
        values = function(trigger)
          local class = select(2, UnitClass("player"));
          if WeakAuras.IsRetail() then
            local classId
            for i = 1, GetNumClasses() do
              if select(2, GetClassInfo(i)) == trigger.class then
                classId = i
              end
            end
            if classId and trigger.spec then
              local specId = GetSpecializationInfoForClassID(classId, trigger.spec)
              if specId then
                local talentData = Private.GetTalentData(specId)
                if talentData then
                  return talentData
                end
              end
            end
            return {}
          elseif WeakAuras.IsMists() then
            return Private.talentInfo[class]
          else
            if Private.talent_types_specific[class] then
              return Private.talent_types_specific[class];
            else
              return Private.talent_types;
            end
          end
        end,
        multiUseControlWhenFalse = WeakAuras.IsMistsOrRetail(),
        multiAll = WeakAuras.IsMistsOrRetail(),
        multiNoSingle = WeakAuras.IsMistsOrRetail(),
        multiTristate = WeakAuras.IsMistsOrRetail(), -- values can be true/false/nil
        control = WeakAuras.IsMistsOrRetail() and "WeakAurasMiniTalent" or nil,
        multiConvertKey = WeakAuras.IsRetail() and function(trigger, key)
          local classId
          for i = 1, GetNumClasses() do
            if select(2, GetClassInfo(i)) == trigger.class then
              classId = i
            end
          end
          if classId and trigger.spec then
            local specId = GetSpecializationInfoForClassID(classId, trigger.spec)
            if specId then
              local talentData = Private.GetTalentData(specId)
              if type(talentData) == "table" and talentData[key] then
                return talentData[key][1]
              end
            end
          end
        end or nil,
        enable = function(trigger)
          if WeakAuras.IsRetail() then
            if trigger.use_class and trigger.class and trigger.use_spec and trigger.spec then
              return true
            else
              return false
            end
          else
            return true
          end
        end,
        test = "active",
        reloadOptions = true,
      },
      {
        display = L["Rank"],
        desc = L["Check if a single talent match a Rank"],
        name = "stacks",
        type = "number",
        conditionType = "number",
        init = "rank",
        store = true,
        enable = function(trigger)
          if WeakAuras.IsRetail() then
            if trigger.use_class and trigger.class
            and trigger.use_spec and trigger.spec
            and trigger.use_talent == false
            and trigger.talent and type(trigger.talent.multi) == "table"
            then
              local count, value = 0, nil
              for _, v in pairs(trigger.talent.multi) do
                value = v
                count = count + 1
              end
              return count == 1 and value == true
            end
          end
          return false
        end,
      },
      {
        name = "herotalent",
        display = L["Hero Talent"],
        type = "multiselect",
        values = function(trigger)
          if not WeakAuras.IsTWW() then return {} end
          local classId
          for i = 1, GetNumClasses() do
            if select(2, GetClassInfo(i)) == trigger.class then
              classId = i
            end
          end
          if classId and trigger.spec then
            local specId = GetSpecializationInfoForClassID(classId, trigger.spec)
            if specId then
              local _, heroData = Private.GetTalentData(specId)
              if heroData then
                return heroData
              end
            end
          end
          return {}
        end,
        multiUseControlWhenFalse = true,
        multiAll = true,
        multiNoSingle = true,
        multiTristate = true,
        control = "WeakAurasMiniTalent",
        multiConvertKey = function(trigger, key)
          local classId
          for i = 1, GetNumClasses() do
            if select(2, GetClassInfo(i)) == trigger.class then
              classId = i
            end
          end
          if classId and trigger.spec then
            local specId = GetSpecializationInfoForClassID(classId, trigger.spec)
            if specId then
              local _, heroData = Private.GetTalentData(specId)
              if type(heroData) == "table" and type(heroData[key]) == "table" then
                return heroData[key][1]
              end
            end
          end
        end,
        enable = function(trigger)
          return WeakAuras.IsTWW() and trigger.use_class and trigger.class and trigger.use_spec and trigger.spec and true or false
        end,
        test = "heroActive",
        reloadOptions = true,
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
        enable = not WeakAuras.IsMistsOrRetail(),
        hidden = WeakAuras.IsMistsOrRetail(),
      },
      {
        hidden = true,
        name = "icon",
        init = "activeIcon",
        store = "true",
        test = "true"
      },
      {
        hidden = true,
        name = "name",
        init = "activeName",
        store = "true",
        test = "true"
      },
    },
    automaticrequired = true,
    statesParameter = "one",
    progressType = "none"
  },
  ["PvP Talent Selected"] = {
    type = "unit",
    events = function()
      return {
        ["events"] = { "PLAYER_PVP_TALENT_UPDATE" }
      }
    end,
    force_events = "PLAYER_PVP_TALENT_UPDATE",
    name = L["PvP Talent Selected"],
    init = function(trigger)
      local inverse = trigger.use_inverse;
      local ret = {}
      if (trigger.use_talent) then
        -- Single selection
        local index = trigger.talent and trigger.talent.single;
        table.insert(ret, ([[
          local index = %s
          local activeName, activeIcon, _

          local active, spellId = WeakAuras.CheckPvpTalentBySpellId(index)
          if spellId then
            activeName, _, activeIcon = Private.ExecEnv.GetSpellInfo(spellId)
          end
        ]]):format(index or 0))
        if (inverse) then
          table.insert(ret, [[
            active = not (active);
          ]])
        end
      elseif (trigger.use_talent == false) then
        if (trigger.talent.multi) then
          table.insert(ret, [[
            local active = false;
            local activeIcon;
            local activeName
            local talentId
            local _
          ]])
          for index in pairs(trigger.talent.multi) do
            table.insert(ret, ([[
              if (not active) then
                local index = %s
                active, spellId = WeakAuras.CheckPvpTalentBySpellId(index)
                if active and spellId then
                  activeName, _, activeIcon = Private.ExecEnv.GetSpellInfo(spellId)
                end
              end
            ]]):format(index))
          end
          if (inverse) then
            table.insert(ret, [[
              active = not (active);
            ]])
          end
        end
      end
      return table.concat(ret);
    end,
    args = {
      {
        name = "talent",
        display = L["Talent selected"],
        type = "multiselect",
        values = function()
          local class = select(2, UnitClass("player"));
          local spec = Private.ExecEnv.GetSpecialization();
          if(Private.pvp_talent_types_specific[class] and  Private.pvp_talent_types_specific[class][spec]) then
            return Private.pvp_talent_types_specific[class][spec];
          else
            return {}
          end
        end,
        test = "active",
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        hidden = true,
        name = "icon",
        init = "activeIcon",
        store = "true",
        test = "true"
      },
      {
        hidden = true,
        name = "name",
        init = "activeName",
        store = "true",
        test = "true"
      },
    },
    automaticrequired = true,
    statesParameter = "one",
    progressType = "none"
  },
  ["Class/Spec"] = {
    type = "unit",
    events = function()
      local events = { "PLAYER_TALENT_UPDATE" }
      return {
        ["events"] = events
      }
    end,
    force_events = "PLAYER_TALENT_UPDATE",
    name = L["Class and Specialization"],
    init = function(trigger)
      return [[
         local specId, specName, _, specIcon = Private.ExecEnv.GetSpecializationInfo(Private.ExecEnv.GetSpecialization())
      ]]
    end,
    args = {
      {
        name = "specId",
        display = L["Class and Specialization"],
        type = "multiselect",
        values = "spec_types_all",
        store = "true",
        conditionType = "select",
        sorted = true,
        sortOrder = Private.specs_sorted,
      },
      {
        hidden = true,
        name = "icon",
        init = "specIcon",
        store = "true",
        test = "true"
      },
      {
        hidden = true,
        name = "name",
        init = "specName",
        store = "true",
        test = "true"
      },
    },
    automaticrequired = true,
    statesParameter = "one",
    progressType = "none"
  },
  ["Loot Specialization"] = {
    type = "unit",
    events = function()
      local events = {"PLAYER_LOOT_SPEC_UPDATED", "PLAYER_SPECIALIZATION_CHANGED" }
      return {
        ["events"] = events
      }
    end,
    force_events = "PLAYER_LOOT_SPEC_UPDATED",
    name = L["Loot Specialization"],
    init = function(trigger)
      return [[
         local lootSpecId = GetLootSpecialization()
         local currentSpecId = Private.ExecEnv.GetSpecializationInfo(Private.ExecEnv.GetSpecialization())
         if lootSpecId == 0 then --Player chose 'Current Specialization'
          lootSpecId = currentSpecId
         end
         local _, lootSpecName, _, lootSpecIcon = GetSpecializationInfoByID(lootSpecId)
      ]]
    end,
    args = {
      {
        name = "lootSpecId",
        display = L["Loot Specialization Id"],
        type = "multiselect",
        init = "lootSpecId",
        values = "spec_types_all",
        conditionType = "select",
        store = true,
        sorted = true,
        sortOrder = Private.specs_sorted,
      },
      {
        name = "name",
        display = L["Loot Specialization Name"],
        init = "lootSpecName",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "isCurrentSpec",
        display = L["Is Current Specialization"],
        init = "lootSpecId == currentSpecId",
        type = "tristate",
        conditionType = "bool",
        store = true,
      },
      {
        hidden = true,
        name = "icon",
        init = "lootSpecIcon",
        store = "true",
        test = "true",
      },
    },
    automaticrequired = true,
    statesParameter = "one",
    progressType = "none"
  },
  ["Totem"] = {
    type = "spell",
    events = {
      ["events"] = {
        "PLAYER_TOTEM_UPDATE",
        "PLAYER_ENTERING_WORLD"
      }
    },
    internal_events = {
      "COOLDOWN_REMAINING_CHECK",
    },
    force_events = "PLAYER_ENTERING_WORLD",
    name = L["Totem"],
    statesParameter = "full",
    progressType = "timed",
    triggerFunction = function(trigger)
      local ret = [[return
      function (states, event, slotId)
        local totemType = %s;
        local triggerTotemName = %q
        local triggerTotemPattern = %q
        local triggerTotemPatternOperator = %q
        local triggerSpellId = %s
        local followoverride = %s
        local triggerTotemIcon = %s
        local triggerTotemIconOperator = %q
        local clone = %s
        local inverse = %s
        local remainingCheck = %s

        local function checkActive(remaining)
          return remaining %s remainingCheck;
        end

        if (totemType) then -- Check a specific totem slot
          if slotId and event == "PLAYER_TOTEM_UPDATE" and totemType ~= slotId then
            -- PLAYER_TOTEM_UPDATE for a different slot
            return false
          end

          local _, totemName, startTime, duration, icon, modRate, spellId = GetTotemInfo(totemType);
          active = (startTime and startTime ~= 0);

          if not Private.ExecEnv.CheckTotemName(totemName, triggerTotemName, triggerTotemPattern, triggerTotemPatternOperator) then
            active = false;
          end

          if not Private.ExecEnv.CheckTotemIcon(icon, triggerTotemIcon, triggerTotemIconOperator) then
            active = false
          end

          if not Private.ExecEnv.CheckTotemSpellId(spellId, triggerSpellId, followoverride) then
            active = false
          end

          if (inverse) then
            active = not active;
            if (triggerTotemName) then
              icon = Private.ExecEnv.GetSpellIcon(triggerTotemName);
            end
          elseif (active and remainingCheck) then
            local expirationTime = startTime and (startTime + duration) or 0;
            local remainingTime = expirationTime - GetTime()
            if (remainingTime >= remainingCheck) then
              Private.ExecEnv.ScheduleScan(expirationTime - remainingCheck);
            end
            active = checkActive(remainingTime);
          end
          states[""] = states[""] or {}
          local state = states[""];
          state.show = active;
          state.changed = true;
          if (active) then
            state.name = totemName;
            state.totemName = totemName;
            state.progressType = "timed";
            state.duration = duration;
            state.expirationTime = startTime and (startTime + duration);
            state.modRate = modRate
            state.spellId = spellId
            state.icon = icon;
          end
        elseif inverse then -- inverse without a specific slot
          local found = false;
          for i = 1, 5 do
            local _, totemName, startTime, duration, icon, modRate, spellId = GetTotemInfo(i);
            if ((startTime and startTime ~= 0)
              and Private.ExecEnv.CheckTotemName(totemName, triggerTotemName, triggerTotemPattern, triggerTotemPatternOperator)
              and Private.ExecEnv.CheckTotemIcon(icon, triggerTotemIcon, triggerTotemIconOperator)
              and Private.ExecEnv.CheckTotemSpellId(spellId, triggerSpellId, followoverride)
            ) then
              found = true;
            end
          end
          local cloneId = "";
          states[cloneId] = states[cloneId] or {};
          local state = states[cloneId];
          state.show = not found;
          state.changed = true;
          state.name = triggerTotemName;
          state.totemName = triggerTotemName;
          if (triggerTotemName) then
            state.icon = Private.ExecEnv.GetSpellIcon(triggerTotemName)
          end
        else -- cloning, check all slots
          for i = 1, 5 do
            local _, totemName, startTime, duration, icon, modRate, spellId = GetTotemInfo(i);
            active = (startTime and startTime ~= 0);

            if not Private.ExecEnv.CheckTotemName(totemName, triggerTotemName, triggerTotemPattern, triggerTotemPatternOperator)
              or not Private.ExecEnv.CheckTotemIcon(icon, triggerTotemIcon, triggerTotemIconOperator)
              or not Private.ExecEnv.CheckTotemSpellId(spellId, triggerSpellId, followoverride)
            then
              active = false;
            end
            if (active and remainingCheck) then
              local expirationTime = startTime and (startTime + duration) or 0;
              local remainingTime = expirationTime - GetTime()
              if (remainingTime >= remainingCheck) then
                Private.ExecEnv.ScheduleScan(expirationTime - remainingCheck);
              end
              active = checkActive(remainingTime);
            end

            local cloneId = clone and tostring(i) or "";
            states[cloneId] = states[cloneId] or {};
            local state = states[cloneId];
            state.show = active;
            state.changed = true;
            if (active) then
              state.name = totemName;
              state.totemName = totemName;
              state.progressType = "timed";
              state.duration = duration;
              state.modRate = modRate
              state.spellId = spellId
              state.expirationTime = startTime and (startTime + duration);
              state.icon = icon;
            end
            if (active and not clone) then
              break;
            end
          end
        end
        return true;
      end
      ]];
      local totemName = tonumber(trigger.totemName) and Private.ExecEnv.GetSpellName(tonumber(trigger.totemName)) or trigger.totemName;
      ret = ret:format(trigger.use_totemType and tonumber(trigger.totemType) or "nil",
        trigger.use_totemName and totemName or "",
        trigger.use_totemNamePattern and trigger.totemNamePattern or "",
        trigger.use_totemNamePattern and trigger.totemNamePattern_operator or "",
        WeakAuras.IsRetail() and trigger.use_totemSpellId and trigger.totemSpellId or "nil",
        WeakAuras.IsRetail() and not trigger.use_ignoreoverride and "true" or "false",
        trigger.use_icon and trigger.icon or "nil",
        trigger.use_icon and trigger.icon_operator or "",
        trigger.use_clones and "true" or "false",
        trigger.use_inverse and "true" or "false",
        trigger.use_remaining and tonumber(trigger.remaining or 0) or "nil",
        trigger.use_remaining and trigger.remaining_operator or "<");
      return ret;
    end,
    args = {
      {
        name = "totemType",
        display = L["Totem Number"],
        type = "select",
        values = "totem_types"
      },
      {
        name = "totemName",
        display = L["Totem Name"],
        type = "string",
        conditionType = "string",
        store = true,
        desc = L["Enter a name or a spellId"]
      },
      {
        name = "totemNamePattern",
        display = L["Totem Name Pattern Match"],
        type = "longstring",
      },
      {
        name = "totemSpellId",
        display = L["Spell Id"],
        type = "spell",
        conditionType = "number",
        operator_types = "only_equal",
        enable = WeakAuras.IsRetail(),
      },
      {
        name = "ignoreoverride",
        display = L["Ignore Spell Override"],
        type = "toggle",
        test = "true",
        enable = function(trigger)
          return trigger.use_totemSpellId and WeakAuras.IsRetail()
        end,
      },
      {
        name = "icon",
        display = L["Totem Icon"],
        type = "number",
        conditionType = "number",
        operator_types = "only_equal",
        store = true,
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
      },
      {
        name = "clones",
        display = L["Clone per Match"],
        type = "toggle",
        test = "true",
        enable = function(trigger) return not (trigger.use_totemType or trigger.use_inverse) end,
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return not(trigger.use_inverse) end
      },
    },
    automaticrequired = true
  },
  ["Item Count"] = {
    type = "item",
    events = {
      ["events"] = {
        "BAG_UPDATE_DELAYED",
        "PLAYER_ENTERING_WORLD"
      }
    },
    internal_events = {
      "ITEM_COUNT_UPDATE",
    },
    force_events = "BAG_UPDATE_DELAYED",
    name = L["Item Count"],
    loadFunc = function(trigger)
      if(trigger.use_includeCharges) then
        WeakAuras.RegisterItemCountWatch();
      end
    end,
    init = function(trigger)
      local itemName = type(trigger.itemName) == "number" and trigger.itemName or string.format("%q", trigger.itemName or "0")
      local ret = [[
        local itemName = %s
        local exactSpellMatch = %s
        local itemId = C_Item.GetItemInfo(itemName)
        if not exactSpellMatch and tonumber(itemName) then
          itemName = itemId
        end
        local count = C_Item.GetItemCount(itemName or "", %s, %s, nil, %s);
        local reagentQuality, reagentQualityTexture
        if WeakAuras.IsRetail() and itemName then
          reagentQuality = C_TradeSkillUI.GetItemReagentQualityByItemInfo(itemName)
          if reagentQuality then
            reagentQualityTexture = CreateAtlasMarkupWithAtlasSize("Professions-Icon-Quality-Tier" .. reagentQuality .. "-Small")
          end
        end
      ]];
      return ret:format(
        itemName,
        trigger.use_exact_itemName and "true" or "nil",
        trigger.use_includeBank and "true" or "nil",
        trigger.use_includeCharges and "true" or "nil",
        WeakAuras.IsRetail() and trigger.use_includeWarBandBank and "true" or "nil"
      )
    end,
    args = {
      {
        name = "itemName",
        required = true,
        display = L["Item"],
        type = "item",
        showExactOption = true,
        test = "true"
      },
      {
        name = "itemId",
        display = WeakAuras.newFeatureString .. L["ItemId"],
        hidden = true,
        init = "itemId",
        test = "true",
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
      },
      {
        name = "name",
        display = L["Name"],
        init = "itemName",
        type = "string",
        hidden = true,
        store = true,
        test = "true",
        conditionType = "string"
      },
      {
        name = "includeBank",
        display = L["Include Bank"],
        type = "toggle",
        test = "true"
      },
      {
        name = "includeWarBandBank",
        display = L["Include War Band Bank"],
        type = "toggle",
        test = "true",
        enable = WeakAuras.IsRetail(),
      },
      {
        name = "includeCharges",
        display = L["Include Charges"],
        type = "toggle",
        test = "true"
      },
      {
        name = "count",
        display = L["Item Count"],
        type = "number"
      },
      {
        name = "stacks",
        display = L["Stacks"],
        init = "count",
        hidden = true,
        store = true,
        test = "true",
        conditionType = "number"
      },
      {
        name = "value",
        init = "count",
        hidden = true,
        store = true,
        test = "true",
        display = L["Progress Value"],
        conditionType = "number"
      },
      {
        name = "total",
        init = 0,
        hidden = true,
        store = true,
        test = "true",
        display = L["Progress Total"],
        conditionType = "number"
      },
      {
        name = "progressType",
        init = "'static'",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "icon",
        init = "C_Item.GetItemIconByID(itemName or '')",
        hidden = true,
        store = true,
        test = "true"
      },
      {
        name = "name",
        init = "itemName and itemName ~= '' and C_Item.GetItemNameByID(itemName) or itemName",
        hidden = true,
        store = true,
        test = "true"
      },
      {
        name = "reagentQuality ",
        display = L["Reagent Quality"],
        store = true,
        test = "true",
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = true
      },
      {
        name = "reagentQualityTexture",
        display = L["Reagent Quality Texture"],
        store = true,
        test = "true",
        enable = WeakAuras.IsRetail(),
        hidden = true
      },
    },
    statesParameter = "one",
    hasItemID = true,
    automaticrequired = true,
    progressType = "static"
  },
  ["Stance/Form/Aura"] = {
    type = "unit",
    events = {
      ["events"] = {
        "UPDATE_SHAPESHIFT_FORM",
        "UPDATE_SHAPESHIFT_COOLDOWN"
      }
    },
    internal_events = { "WA_DELAYED_PLAYER_ENTERING_WORLD" },
    force_events = "WA_DELAYED_PLAYER_ENTERING_WORLD",
    name = L["Stance/Form/Aura"],
    init = function(trigger)
      local inverse = trigger.use_inverse;
      local ret = {[[
        local form = GetShapeshiftForm()
        local active = false
      ]]}
      if trigger.use_form and trigger.form and trigger.form.single then
        -- Single selection
        table.insert(ret, ([[
          local trigger_form = %d
          active = form == trigger_form
        ]]):format(trigger.form.single))
        if inverse then
          table.insert(ret, [[
            active = not active
          ]])
        end
      elseif trigger.use_form == false and trigger.form and trigger.form.multi then
        for index in pairs(trigger.form.multi) do
          table.insert(ret, ([[
            if not active then
              local index = %d
              active = form == index
            end
          ]]):format(index))
        end
        if inverse then
          table.insert(ret, [[
            active = not active
          ]])
        end
      elseif trigger.use_form == nil then
        table.insert(ret, [[
          active = true
        ]])
      end
      return table.concat(ret)
    end,
    statesParameter = "one",
    args = {
      {
        name = "note",
        type = "description",
        display = "",
        text = function()
          return L["Note: This trigger internally stores the shapeshift position, and thus is incompatible with learning stances on the fly, like e.g. the Gladiator Rune."]
        end,
        hidden = not (C_Seasons and C_Seasons.GetActiveSeason and C_Seasons.GetActiveSeason() == 2),
      },
      {
        name = "form",
        display = L["Form"],
        type = "multiselect",
        values = "form_types",
        test = "active",
        store = true,
        conditionType = "select"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
        enable = function(trigger) return type(trigger.use_form) == "boolean" end
      },
    },
    nameFunc = function(trigger)
      local _, class = UnitClass("player");
      local name
      if(class == trigger.class) then
        local form = GetShapeshiftForm();
        if form > 0 then
          local _, name = GetShapeshiftFormInfo(form);
        else
          name = "Humanoid";
        end
        return name;
      else
        local types = WeakAuras[class:lower().."_form_types"];
        if(types) then
          return types[GetShapeshiftForm()];
        end
      end
    end,
    iconFunc = function(trigger)
      local icon = "136116"
      local form = GetShapeshiftForm()
      if form and form > 0 then
        icon = GetShapeshiftFormInfo(form);
      end
      return icon or "136116"
    end,
    automaticrequired = true,
    progressType = "none"
  },
  ["Weapon Enchant"] = {
    type = "item",
    events = {},
    internal_events = {
      "TENCH_UPDATE",
    },
    force_events = "TENCH_UPDATE",
    name = WeakAuras.IsRetail() and L["Weapon Enchant / Fishing Lure"] or L["Weapon Enchant"],
    init = function(trigger)
      WeakAuras.TenchInit();

      local ret = [[
        local triggerWeaponType = %q
        local triggerName = %q
        local triggerStack = %s
        local triggerRemaining = %s
        local triggerShowOn = %q
        local _, expirationTime, duration, name, icon, stacks, enchantID

        if triggerWeaponType == "main" then
          expirationTime, duration, name, shortenedName, icon, stacks, enchantID = WeakAuras.GetMHTenchInfo()
        elseif triggerWeaponType == "off" then
          expirationTime, duration, name, shortenedName, icon, stacks, enchantID = WeakAuras.GetOHTenchInfo()
        elseif triggerWeaponType == "ranged" and WeakAuras.IsCataClassic() then
          expirationTime, duration, name, shortenedName, icon, stacks, enchantID = WeakAuras.GetRangeTenchInfo()
        end

        local remaining = expirationTime and expirationTime - GetTime()

        local nameCheck = triggerName == "" or name and triggerName == name or shortenedName and triggerName == shortenedName or tonumber(triggerName) and enchantID and tonumber(triggerName) == enchantID
        local stackCheck = not triggerStack or stacks and stacks %s triggerStack
        local remainingCheck = not triggerRemaining or remaining and remaining %s triggerRemaining
        local found = expirationTime and nameCheck and stackCheck and remainingCheck

        if(triggerRemaining and remaining and remaining >= triggerRemaining and remaining > 0) then
          Private.ExecEnv.ScheduleScan(expirationTime - triggerRemaining, "TENCH_UPDATE");
        end

        if not found then
          expirationTime = nil
          duration = nil
          remaining = nil
        end
      ]];

      local showOnActive = trigger.showOn == 'showOnActive' or not trigger.showOn

      return ret:format(trigger.weapon or "main",
      trigger.use_enchant and trigger.enchant or "",
      showOnActive and trigger.use_stacks and tonumber(trigger.stacks or 0) or "nil",
      showOnActive and trigger.use_remaining and tonumber(trigger.remaining or 0) or "nil",
      trigger.showOn or "showOnActive",
      trigger.stacks_operator or "<",
      trigger.remaining_operator or "<")
    end,
    args = {
      {
        name = "weapon",
        display = L["Weapon"],
        type = "select",
        values = "weapon_types",
        test = "true",
        default = "main",
        required = true
      },
      {
        name = "enchant",
        display = L["Weapon Enchant"],
        desc = L["Enchant Name or ID"],
        type = "string",
        test = "true"
      },
      {
        name = "enchantID",
        hidden = true,
        test = "true",
        display = L["Enchant ID"],
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
        noProgressSource = true
      },
      {
        name = "stacks",
        display = L["Stack Count"],
        type = "number",
        conditionType = "number",
        test = "true",
        enable = function(trigger)
          return not WeakAuras.IsRetail() and (not trigger.showOn or trigger.showOn == "showOnActive")
        end,
        hidden = WeakAuras.IsRetail(),
        store = true
      },
      {
        name = "duration",
        hidden = true,
        init = "duration",
        test = "true",
        store = true
      },
      {
        name = "expirationTime",
        init = "expirationTime",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "progressType",
        hidden = true,
        init = "duration and 'timed'",
        test = "true",
        store = true
      },
      {
        name = "name",
        hidden = true,
        init = "name",
        test = "true",
        store = true
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "enchanted",
        display = L["Enchanted"],
        hidden = true,
        init = "found == true",
        test = "true",
        store = true,
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and state.enchanted == (needle == 1)
        end,
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        test = "true",
        enable = function(trigger)
          return not trigger.showOn or trigger.showOn == "showOnActive"
        end
      },
      {
        name = "showOn",
        display = L["Show On"],
        type = "select",
        values = "weapon_enchant_types",
        test = 'true',
        default = "showOnActive",
        required = true
      },
      {
        hidden = true,
        test = "(triggerShowOn == 'showOnActive' and found) " ..
        "or (triggerShowOn == 'showOnMissing' and not found) "  ..
        "or (triggerShowOn == 'showAlways')"
      }
    },
    automaticrequired = true,
    progressType = "timed",
    statesParameter = "one"
  },
  ["Chat Message"] = {
    type = "event",
    events = function(trigger)
      if trigger.use_messageType and trigger.messageType and Private.chat_message_types[trigger.messageType] then
        local events = {trigger.messageType}
        if Private.chat_message_leader_event[trigger.messageType] then
          table.insert(events, Private.chat_message_leader_event[trigger.messageType])
        end
        if trigger.messageType == "CHAT_MSG_EMOTE" then
          table.insert(events, "CHAT_MSG_TEXT_EMOTE")
        end
        return { events = events }
      end
      return {
        ["events"] = {
          "CHAT_MSG_INSTANCE_CHAT",
          "CHAT_MSG_INSTANCE_CHAT_LEADER",
          "CHAT_MSG_BG_SYSTEM_ALLIANCE",
          "CHAT_MSG_BG_SYSTEM_HORDE",
          "CHAT_MSG_BG_SYSTEM_NEUTRAL",
          "CHAT_MSG_BN_WHISPER",
          "CHAT_MSG_CHANNEL",
          "CHAT_MSG_EMOTE",
          "CHAT_MSG_GUILD",
          "CHAT_MSG_MONSTER_EMOTE",
          "CHAT_MSG_MONSTER_PARTY",
          "CHAT_MSG_MONSTER_SAY",
          "CHAT_MSG_MONSTER_WHISPER",
          "CHAT_MSG_MONSTER_YELL",
          "CHAT_MSG_OFFICER",
          "CHAT_MSG_PARTY",
          "CHAT_MSG_PARTY_LEADER",
          "CHAT_MSG_RAID",
          "CHAT_MSG_RAID_LEADER",
          "CHAT_MSG_RAID_BOSS_EMOTE",
          "CHAT_MSG_RAID_BOSS_WHISPER",
          "CHAT_MSG_RAID_WARNING",
          "CHAT_MSG_SAY",
          "CHAT_MSG_WHISPER",
          "CHAT_MSG_YELL",
          "CHAT_MSG_SYSTEM",
          "CHAT_MSG_TEXT_EMOTE",
          "CHAT_MSG_LOOT",
          "CHAT_MSG_COMMUNITIES_CHANNEL"
        }
      }
    end,
    name = L["Chat Message"],
    init = function(trigger)
      local ret = [[
        if (event:find('LEADER')) then
          event = event:sub(1, -8);
        end
        if (event == 'CHAT_MSG_TEXT_EMOTE') then
          event = 'CHAT_MSG_EMOTE';
        end
        local use_cloneId = %s;
      ]];
      return ret:format(trigger.use_cloneId and "true" or "false");
    end,
    statesParameter = "all",
    args = {
      {
        name = "messageType",
        display = L["Message Type"],
        type = "select",
        values = "chat_message_types",
        sorted = true,
        test = "event == %q",
      },
      {
        name = "message",
        display = L["Message"],
        init = "arg",
        type = "longstring",
        canBeCaseInsensitive = true,
        store = true,
        conditionType = "string",
      },
      {
        name = "sourceName",
        display = L["Source Name"],
        init = "arg",
        type = "string",
        store = true,
        conditionType = "string",
      },
      { -- language Name
      },
      { -- Channel Name
      },
      {
        name = "destName",
        display = L["Destination Name"],
        init = "arg",
        type = "string",
        store = true,
        conditionType = "string",
      },
      {
        -- flags
      },
      {
        -- zone Channel id
      },
      {
        -- channel index
      },
      {
        -- channel base name
      },
      {
        -- language id
      },
      {
        -- line id
      },
      {
        name = "sourceGUID",
        display = L["Source GUID"],
        init = "arg",
        store = true,
        hidden = true,
        test = "true",
        formatter = "guid",
        formatterArgs = { color = "class" }
      },
      {
        name = "cloneId",
        display = L["Clone per Event"],
        type = "toggle",
        test = "true",
        init = "use_cloneId and WeakAuras.GetUniqueCloneId() or ''",
        reloadOptions = true
      },
    },
    countEvents = true,
    delayEvents = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Spell Cast Succeeded"] = {
    type = "event",
    events = function(trigger)
      local result = {}
      local unit = trigger.unit
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_SUCCEEDED")
      return result
    end,
    name = L["Spell Cast Succeeded"],
    statesParameter = "unit",
    args = {
      {
        name = "unit",
        init = "arg",
        display = L["Caster Unit"],
        type = "unit",
        test = "true",
        values = "actual_unit_types_cast",
        store = true,
        conditionType = "select",
        conditionTest = function(state, needle, op)
          return state and state.show and (UnitIsUnit(needle, state.unit or '') == (op == "=="))
        end
      },
      {
      },
      { -- castGUID
      },
      {
        name = "spellNames",
        display = L["Name(s)"],
        type = "spell",
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddName(%q)"
        },
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        preambleGroup = "spell",
        test = "spellChecker:Check(spellId)",
        noValidation = true,
      },
      {
        name = "spellId",
        display = L["Exact Spell ID(s)"],
        type = "spell",
        init = "arg",
        store = true,
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddExact(%q)"
        },
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        preambleGroup = "spell",
        test = "spellChecker:Check(spellId)",
        conditionType = "number",
        noProgressSource = true
      },
      {
        name = "icon",
        hidden = true,
        init = "Private.ExecEnv.GetSpellIcon(spellId or 0)",
        store = true,
        test = "true"
      },
      {
        name = "name",
        hidden = true,
        init = "Private.ExecEnv.GetSpellName(spellId or 0)",
        store = true,
        test = "true"
      },
    },
    countEvents = true,
    delayEvents = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Ready Check"] = {
    type = "event",
    events = {
      ["events"] = {"READY_CHECK"}
    },
    name = L["Ready Check"],
    args = {},
    statesParameter = "one",
    delayEvents = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Combat Events"] = {
    type = "event",
    events = {
      ["events"] = {
        "PLAYER_REGEN_ENABLED",
        "PLAYER_REGEN_DISABLED"
      }
    },
    name = L["Entering/Leaving Combat"],
    args = {
      {
        name = "eventtype",
        required = true,
        display = L["Type"],
        type = "select",
        values = "combat_event_type",
        test = "event == %q"
      }
    },
    statesParameter = "one",
    countEvents = true,
    delayEvents = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Encounter Events"] = {
    type = "event",
    events = {
      ["events"] = {
        "ENCOUNTER_START",
        "ENCOUNTER_END"
      }
    },
    name = L["Entering/Leaving Encounter"],
    args = {
      {
        name = "eventtype",
        required = true,
        display = L["Type"],
        type = "select",
        values = "encounter_event_type",
        test = "event == %q",
        reloadOptions = true
      },
      {
        name = "encounterId",
        display = L["Id"],
        type = "string",
        validate = WeakAuras.ValidateNumeric,
        conditionType = "number",
        store = true,
        init = "arg"
      },
      {
        name = "encounterName",
        display = L["Name"],
        type = "string",
        conditionType = "string",
        store = true,
        init = "arg"
      },
      {
        name = "difficulty",
        display = L["Difficulty"],
        type = "select",
        values = "difficulty_types",
        test = "%q == WeakAuras.InstanceDifficulty()",
        conditionType = "select",
        conditionTest = function(state, needle)
          return WeakAuras.InstanceDifficulty() == needle
        end,
        store = true,
        init = "arg"
      },
      {},
      {
        name = "success",
        display = L["Success"],
        type = "toggle",
        conditionType = "bool",
        enable = function(trigger)
          return trigger.eventtype == "ENCOUNTER_END"
        end,
        store = true,
        test = "success == 1",
        conditionTest = function(state, needle)
          return state and (state.success == needle)
        end,
        init = "arg"
      }
    },
    statesParameter = "one",
    countEvents = true,
    delayEvents = true,
    timedrequired = true,
    progressType = "timed"
  },
  ["Evoker Essence"] = {
    type = "unit",
    events = {},
    internal_events = {
      "ESSENCE_UPDATE"
    },
    force_events = "ESSENCE_UPDATE",
    name = L["Evoker Essence"],
    loadFunc = function()
      WeakAuras.InitEssenceCooldown()
    end,
    statesParameter = "one",
    init = function(trigger)
      trigger.essence = trigger.essence or 0
      local ret = [[
        local triggerEssence = %s
        local genericShowOn = %s
        local duration, expirationTime, remaining, paused, essence, total = WeakAuras.GetEssenceCooldown(triggerEssence)
        local ready = paused
        local onCooldown = paused == false
      ]]
      return ret:format(
        trigger.use_essence and trigger.essence or "nil",
        trigger.use_essence and trigger.essence and ("[[" .. (trigger.genericShowOn or "") .. "]]") or "[[showAlways]]"
      );
    end,
    args = {
      {
        name = "note",
        type = "description",
        display = "",
        text = function()
          return L["Note: This trigger relies on the WoW API, which returns incorrect information in some cases."]
        end
      },
      {
        name = "essence",
        display = L["Essence"],
        type = "select",
        values = "essence_specific_types",
        test = "(genericShowOn == \"showOnReady\" and ready) " ..
        "or (genericShowOn == \"showOnCooldown\" and onCooldown) " ..
        "or (genericShowOn == \"showAlways\" and paused ~= nil)",
        reloadOptions = true
      },
      {
        name = "genericShowOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        enable = function(trigger) return trigger.use_essence end,
        required = true
      },
      {
        hidden = true,
        name = "onCooldown",
        test = "true",
        display = L["On Cooldown"],
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and state.expirationTime and (state.expirationTime == math.huge) == (needle == 0)
        end,
        enable = function(trigger)
          return trigger.use_essence and type(trigger.essence) == "number" and trigger.essence > 0
        end
      },
      {
        hidden = true,
        name = "charging",
        test = "true",
        display = L["Charging"],
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (state.essence == (state.triggerEssence or 0) - 1) == (needle == 1)
        end,
        enable = function(trigger)
          return trigger.use_essence and type(trigger.essence) == "number" and trigger.essence > 0
        end
      },
      {
        name = "progressType",
        hidden = true,
        init = "'timed'",
        store = true,
        test = "true"
      },
      {
        name = "duration",
        hidden = true,
        init = "duration",
        test = "true",
        store = true
      },
      {
        name = "expirationTime",
        init = "expirationTime",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "remaining",
        init = "remaining",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "paused",
        init = "paused",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "triggerEssence",
        hidden = true,
        init = "triggerEssence",
        test = "true",
        store = true
      },
      {
        name = "essence",
        display = L["Current Essence"],
        hidden = true,
        init = "essence",
        test = "true",
        store = true
      },
      {
        name = "total",
        display = L["Total Essence"],
        hidden = true,
        init = "total",
        test = "true",
        store = true
      },
    },
    automaticrequired = true,
    progressType = "timed"
  },
  ["Death Knight Rune"] = {
    type = "unit",
    events = function()
      if WeakAuras.IsCataOrMists() then
        return { events = { "RUNE_POWER_UPDATE", "RUNE_TYPE_UPDATE"} }
      else
        return { events = { "RUNE_POWER_UPDATE" } }
      end
    end,
    internal_events = {
      "RUNE_COOLDOWN_READY",
      "RUNE_COOLDOWN_CHANGED",
      "RUNE_COOLDOWN_STARTED",
      "COOLDOWN_REMAINING_CHECK",
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = "RUNE_COOLDOWN_FORCE",
    name = L["Death Knight Rune"],
    loadFunc = function(trigger)
      trigger.rune = trigger.rune or 0;
      if (trigger.use_rune) then
        WeakAuras.WatchRuneCooldown(trigger.rune);
      else
        for i = 1, 6 do
          WeakAuras.WatchRuneCooldown(i);
        end
      end
    end,
    init = function(trigger)
      trigger.rune = trigger.rune or 0;
      local ret
      if WeakAuras.IsCataOrMists() then
        ret = [[
          local rune = %s;
          local genericShowOn = %s
          local includeDeathRunes = %s;
          local startTime, duration = WeakAuras.GetRuneCooldown(rune);
          local numBloodRunes = 0;
          local numUnholyRunes = 0;
          local numFrostRunes = 0;
          local numDeathRunes = 0;
          local numRunes = 0;
          local isDeathRune = GetRuneType(rune) == 4
          for index = 1, 6 do
            local startTime = GetRuneCooldown(index);
            if startTime == 0 then
              numRunes = numRunes + 1;
              local runeType = GetRuneType(index)
              if runeType == 1 then
                numBloodRunes = numBloodRunes + 1;
              elseif runeType == 2 then
                numFrostRunes = numFrostRunes + 1;
              elseif runeType == 3 then
                numUnholyRunes = numUnholyRunes + 1;
              elseif runeType == 4 then
                numDeathRunes = numDeathRunes + 1;
              end
            end
          end
          if includeDeathRunes then
            numBloodRunes  = numBloodRunes  + numDeathRunes;
            numUnholyRunes = numUnholyRunes + numDeathRunes;
            numFrostRunes  = numFrostRunes  + numDeathRunes;
          end
        ]];
      else
        ret = [[
          local rune = %s;
          local startTime, duration = WeakAuras.GetRuneCooldown(rune);
          local genericShowOn = %s
          local numRunes = 0;
          for index = 1, 6 do
            local startTime = WeakAuras.GetRuneCooldown(index);
            if startTime == 0 then
              numRunes = numRunes + 1;
            end
          end
        ]];
      end
      if trigger.use_remaining then
        local ret2 = [[
          local expirationTime = startTime + duration
          local remaining = expirationTime - GetTime();
          local remainingCheck = %s;
          if(remaining >= remainingCheck and remaining > 0) then
            Private.ExecEnv.ScheduleScan(expirationTime - remainingCheck);
          end
        ]];
        ret = ret..ret2:format(tonumber(trigger.remaining or 0) or 0);
      end
      if WeakAuras.IsCataOrMists() then
        return ret:format(
          trigger.rune,
          "[[" .. (trigger.genericShowOn or "") .. "]]",
          (trigger.use_includeDeathRunes and "true" or "false")
        );
      else
        return ret:format(
          trigger.rune,
          "[[" .. (trigger.genericShowOn or "") .. "]]"
        );
      end
    end,
    statesParameter = "one",
    args = {
      {
        name = "rune",
        display = L["Rune"],
        type = "select",
        values = "rune_specific_types",
        test = "(genericShowOn == \"showOnReady\" and (startTime == 0)) " ..
        "or (genericShowOn == \"showOnCooldown\" and startTime > 0) " ..
        "or (genericShowOn == \"showAlways\")",
        reloadOptions = true
      },
      {
        name = "isDeathRune",
        display = L["Is Death Rune"],
        type = "tristate",
        init = "isDeathRune",
        store = true,
        conditionType = "bool",
        enable = function(trigger) return WeakAuras.IsCataOrMists() and trigger.use_rune end,
        hidden = not WeakAuras.IsCataOrMists()
      },
      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return trigger.use_rune and not(trigger.genericShowOn == "showOnReady") end
      },
      {
        name = "genericShowOn",
        display =  L["Show"],
        type = "select",
        values = "cooldown_progress_behavior_types",
        test = "true",
        enable = function(trigger) return trigger.use_rune end,
        required = true
      },
      {
        name = "runesCount",
        display = L["Rune Count"],
        type = "number",
        init = "numRunes",
        enable = function(trigger) return not trigger.use_rune end
      },
      {
        hidden = true,
        name = "onCooldown",
        test = "true",
        display = L["On Cooldown"],
        conditionType = "bool",
        conditionTest = function(state, needle)
          return state and state.show and (state.expirationTime and state.expirationTime > GetTime()) == (needle == 1)
        end,
        enable = function(trigger) return trigger.use_rune end
      },
      {
        name = "bloodRunes",
        display = L["Rune Count - Blood"],
        type = "number",
        init = "numBloodRunes",
        store = true,
        conditionType = "number",
        enable = function(trigger) return WeakAuras.IsCataOrMists() and not trigger.use_rune end,
        hidden = not WeakAuras.IsCataOrMists()
      },
      {
        name = "frostRunes",
        display = L["Rune Count - Frost"],
        type = "number",
        init = "numFrostRunes",
        store = true,
        conditionType = "number",
        enable = function(trigger) return WeakAuras.IsCataOrMists() and not trigger.use_rune end,
        hidden = not WeakAuras.IsCataOrMists()
      },
      {
        name = "unholyRunes",
        display = L["Rune Count - Unholy"],
        type = "number",
        init = "numUnholyRunes",
        store = true,
        conditionType = "number",
        enable = function(trigger) return WeakAuras.IsCataOrMists() and not trigger.use_rune end,
        hidden = not WeakAuras.IsCataOrMists()
      },
      {
        name = "includeDeathRunes",
        display = L["Include Death Runes"],
        type = "toggle",
        test = "true",
        enable = function(trigger) return WeakAuras.IsCataOrMists() and trigger.use_bloodRunes or trigger.use_unholyRunes or trigger.use_frostRunes end,
        hidden = not WeakAuras.IsCataOrMists()
      },
    },
    durationFunc = function(trigger)
      if trigger.use_rune then
        local startTime, duration = WeakAuras.GetRuneCooldown(trigger.rune)
        return duration, startTime + duration
      else
        local numRunes = 0;
        for index = 1, 6 do
          if GetRuneCooldown(index) == 0 then
            numRunes = numRunes + 1;
          end
        end
        return numRunes, 6, true;
      end
    end,
    stacksFunc = function(trigger)
      local numRunes = 0;
      for index = 1, 6 do
        if GetRuneCooldown(index) == 0 then
          numRunes = numRunes  + 1;
        end
      end
      return numRunes;
    end,
    nameFunc = function(trigger)
      if WeakAuras.IsCataOrMists() then
        local runeNames = { L["Blood"], L["Frost"], L["Unholy"], L["Death"] }
        return runeNames[GetRuneType(trigger.rune)];
      end
    end,
    iconFunc = function(trigger)
      if WeakAuras.IsCataOrMists() then
        if trigger.rune then
          local runeIcons = {
            "Interface\\PlayerFrame\\UI-PlayerFrame-Deathknight-Blood",
            "Interface\\PlayerFrame\\UI-PlayerFrame-Deathknight-Frost",
            "Interface\\PlayerFrame\\UI-PlayerFrame-Deathknight-Unholy",
            "Interface\\PlayerFrame\\UI-PlayerFrame-Deathknight-Death"
          };
          return runeIcons[GetRuneType(trigger.rune)];
        end
      else
        return "Interface\\PlayerFrame\\UI-PlayerFrame-Deathknight-SingleRune";
      end
    end,
    automaticrequired = true,
    progressType = function(trigger)
      if trigger.use_rune then
        return "timed"
      else
        return "static"
      end
    end
  },
  ["Item Equipped"] = {
    type = "item",
    events = {
      ["events"] = {
        "PLAYER_EQUIPMENT_CHANGED",
      },
      ["unit_events"] = {
        ["player"] = {"UNIT_INVENTORY_CHANGED"}
      }
    },
    internal_events = { "WA_DELAYED_PLAYER_ENTERING_WORLD", },
    force_events = "UNIT_INVENTORY_CHANGED",
    name = L["Item Equipped"],
    init = function(trigger)
      local itemName = type(trigger.itemName) == "number" and trigger.itemName or string.format("%q", trigger.itemName or "0")

      local ret = [[
        local inverse = %s
        local triggerItemName = %s
        local itemId, _, _, _, icon = C_Item.GetItemInfoInstant(triggerItemName)
        local itemSlot = %s
      ]]

      ret = ret ..[[
        local itemName = triggerItemName
        local equipped = WeakAuras.CheckForItemEquipped(triggerItemName, itemSlot)
      ]]

      return ret:format(trigger.use_inverse and "true" or "false", itemName, trigger.use_itemSlot and trigger.itemSlot or "nil");
    end,
    GetNameAndIcon = function(trigger)
      local name = C_Item.GetItemInfo(trigger.itemName or 0)
      local _, _, _, _, icon = C_Item.GetItemInfoInstant(trigger.itemName or 0)
      return name, icon
    end,
    statesParameter = "one",
    args = {
      {
        name = "itemName",
        display = L["Item"],
        type = "item",
        required = true,
        test = "true",
        only_exact = true
      },
      {
        name = "itemId",
        display = WeakAuras.newFeatureString .. L["ItemId"],
        hidden = true,
        init = "itemId",
        test = "true",
        store = true,
        conditionType = "number",
        operator_types = "only_equal",
      },
      {
        name = "itemSlot",
        display = WeakAuras.newFeatureString .. L["Item Slot"],
        type = "select",
        values = "item_slot_types",
        test = "true",
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "itemName",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        hidden = true,
        test = "(inverse and not equipped) or (equipped and not inverse)"
      }
    },
    hasItemID = true,
    automaticrequired = true,
    progressType = "none"
  },
  ["Item Type Equipped"] = {
    type = "item",
    events = {
      ["events"] = {
        "PLAYER_EQUIPMENT_CHANGED",
      },
      ["unit_events"] = {
        ["player"] = {"UNIT_INVENTORY_CHANGED"}
      }
    },
    init = function(trigger)
      local ret
      if trigger.use_itemSlot then
        local itemSlot = trigger.itemSlot and tonumber(trigger.itemSlot)
        if itemSlot then
          ret = string.format("local itemSlot = %s\n", trigger.itemSlot)
        else
          ret = "local itemSlot = nil\n"
        end
      else
        ret = "local itemSlot = nil\n"
      end
      return ret
    end,
    internal_events = { "WA_DELAYED_PLAYER_ENTERING_WORLD", },
    force_events = "UNIT_INVENTORY_CHANGED",
    name = L["Item Type Equipped"],
    args = {
      {
          name = "itemSlot",
          required = false,
          display = L["Equipment Slot"],
          type = "select",
          values = "item_slot_types",
          test = "true"
      },
      {
        name = "itemTypeName",
        display = L["Item Type"],
        type = "multiselect",
        values = "item_weapon_types",
        required = true,
        test = "Private.ExecEnv.IsEquippedItemType(%s, itemSlot)",
        multiNoSingle = true
      },
    },
    automaticrequired = true,
    progressType = "none"
  },
  ["Item Bonus Id Equipped"] = {
    type = "item",
    events = {
      ["events"] = {
        "PLAYER_EQUIPMENT_CHANGED",
      },
      ["unit_events"] = {
        ["player"] = {"UNIT_INVENTORY_CHANGED"}
      }
    },
    internal_events = { "WA_DELAYED_PLAYER_ENTERING_WORLD", },
    force_events = "UNIT_INVENTORY_CHANGED",
    name = L["Item Bonus Id Equipped"],
    statesParameter = "one",
    init = function(trigger)
      local ret = [=[
        local fetchLegendaryPower = %s
        local item = %q
        local inverse = %s
        local useItemSlot, slotSelected = %s, %d

        local itemBonusId, itemId, itemName, icon, itemSlot, itemSlotString = WeakAuras.GetBonusIdInfo(item, useItemSlot and slotSelected)
        local itemBonusId = tonumber(itemBonusId)
        if fetchLegendaryPower then
          itemName, icon = WeakAuras.GetLegendaryData(itemBonusId or item)
        end

        local slotValidation = (useItemSlot and itemSlot == slotSelected) or (not useItemSlot)
      ]=]
      return ret:format(trigger.use_legendaryIcon and "true" or "false", trigger.itemBonusId or "", trigger.use_inverse and "true" or "false",
                        trigger.use_itemSlot and "true" or "false", trigger.itemSlot)
    end,
    args = {
      {
        name = "itemBonusId",
        display = L["Item Bonus Id"],
        type = "string",
        store = "true",
        test = "true",
        required = true,
        desc = L["Supports multiple entries, separated by commas"],
        conditionType = "number",
        noProgressSource = true
      },
      {
        name = "legendaryIcon",
        display = L["Fetch Legendary Power"],
        type = "toggle",
        test = "true",
        desc = L["Fetches the name and icon of the Legendary Power that matches this bonus id."],
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
      },
      {
        name = "name",
        display = L["Item Name"],
        hidden = "true",
        init = "itemName",
        store = "true",
        test = "true",
      },
      {
        name = "icon",
        hidden = "true",
        init = "icon",
        store = "true",
        test = "true",
      },
      {
        name = "itemId",
        display = L["Item Id"],
        hidden = "true",
        store = "true",
        test = "true",
        conditionType = "number",
        operator_types = "only_equal",
        noProgressSource = true
      },
      {
        name = "itemSlot",
        display = L["Item Slot"],
        type = "select",
        store = "true",
        conditionType = "select",
        values = "item_slot_types",
        test = "true",
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
      },
      {
        name = "itemSlotString",
        display = L["Item Slot String"],
        hidden = "true",
        store = "true",
        test = "true",
      },
      {
        hidden = true,
        test = "not inverse == (itemBonusId and slotValidation or false)",
      }
    },
    automaticrequired = true,
    progressType = "none"
  },
  ["Item Set"] = {
    type = "item",
    events = {
      ["events"] = {"PLAYER_EQUIPMENT_CHANGED"}
    },
    internal_events = {"WA_DELAYED_PLAYER_ENTERING_WORLD",
                       "WA_DELAYED_SET_INFORMATION"},
    force_events = "PLAYER_EQUIPMENT_CHANGED",
    name = L["Item Set Equipped"],
    automaticrequired = true,
    init = function(trigger)
      local ret = [[
        local setid = %s
        local value, total, name = WeakAuras.GetNumSetItemsEquipped(setid)
      ]]
      return string.format(ret, trigger.itemSetId and tonumber(trigger.itemSetId) or "0");
    end,
    GetNameAndIcon = function(trigger)
      local name = select(3, WeakAuras.GetNumSetItemsEquipped(trigger.itemSetId and tonumber(trigger.itemSetId) or 0))
      return name, nil
    end,
    statesParameter = "one",
    args = {
      {
        name = "itemSetId",
        display = L["Item Set Id"],
        type = "string",
        test = "true",
        store = "true",
        required = true,
        validate = WeakAuras.ValidateNumeric,
        desc = function()
          if WeakAuras.IsRetail() then
            return L["Set IDs can be found on websites such as wowhead.com/item-sets"]
          elseif WeakAuras.IsClassicEra() then
            return L["Set IDs can be found on websites such as wowhead.com/classic/item-sets"]
          elseif WeakAuras.IsCataClassic() then
            return L["Set IDs can be found on websites such as wowhead.com/cata/item-sets"]
          elseif WeakAuras.IsMists() then
            return L["Set IDs can be found on websites such as wowhead.com/mop-classic/item-sets"]
          end
        end
      },
      {
        name = "equipped",
        display = L["Equipped"],
        type = "number",
        init = "value",
        store = true,
        required = true,
        conditionType = "number"
      },
      {
        name = "progressType",
        hidden = true,
        init = "'static'",
        store = true,
        test = "true"
      },
      {
        name = "value",
        hidden = true,
        init = "value",
        store = true,
        test = "true"
      },
      {
        name = "total",
        hidden = true,
        init = "total",
        store = true,
        test = "true"
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        store = true,
        test = "true",
        conditionType = "string"
      },
    },
    progressType = "static"
  },
  ["Equipment Set"] = {
    type = "item",
    events = {
      ["events"] = {
        "PLAYER_EQUIPMENT_CHANGED",
        "WEAR_EQUIPMENT_SET",
        "EQUIPMENT_SETS_CHANGED",
        "EQUIPMENT_SWAP_FINISHED",
      }
    },
    internal_events = {"WA_DELAYED_PLAYER_ENTERING_WORLD"},
    force_events = "PLAYER_EQUIPMENT_CHANGED",
    name = L["Equipment Set Equipped"],
    init = function(trigger)
      trigger.itemSetName = trigger.itemSetName or "";
      local itemSetName = type(trigger.itemSetName) == "string" and ("[=[" .. trigger.itemSetName .. "]=]") or "nil";

      local ret = [[
        local useItemSetName = %s;
        local triggerItemSetName = %s;
        local inverse = %s;
        local partial = %s;

        local itemSetName, icon, numEquipped, numItems = WeakAuras.GetEquipmentSetInfo(useItemSetName and triggerItemSetName or nil, partial);
      ]];

      return ret:format(trigger.use_itemSetName and "true" or "false", itemSetName, trigger.use_inverse and "true" or "false", trigger.use_partial and "true" or "false");
    end,
    GetNameAndIcon = function(trigger)
      local name, icon = WeakAuras.GetEquipmentSetInfo(trigger.use_itemSetName and trigger.itemSetName or nil, true)
      return name, icon
    end,
    statesParameter = "one",
    args = {
      {
        name = "itemSetName",
        display = L["Equipment Set"],
        type = "string",
        test = "true",
        store = true,
        conditionType = "string",
        init = "itemSetName"
      },
      {
        name = "partial",
        display = L["Allow partial matches"],
        type = "toggle",
        test = "true"
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true"
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "value",
        init = "numEquipped",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "total",
        init = "numItems",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "progressType",
        init = "'static'",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        hidden = true,
        test = "(inverse and itemSetName == nil) or (not inverse and itemSetName)"
      }
    },
    automaticrequired = true,
    progressType = "static"
  },
  ["Threat Situation"] = {
    type = "unit",
    events = function(trigger)
      local unit = trigger.unit
      local result = {}
      if unit and unit ~= "none" then
        AddUnitEventForEvents(result, unit, "UNIT_THREAT_LIST_UPDATE")
      else
        AddUnitEventForEvents(result, "player", "UNIT_THREAT_SITUATION_UPDATE")
      end
      return result
    end,
    internal_events = function(trigger)
      local unit = trigger.unit
      local result = {}
      if unit and unit ~= "none" then
        AddUnitChangeInternalEvents(unit, result)
      end
      return result
    end,
    loadFunc = function(trigger)
      local unit = trigger.unit
      if unit and unit ~= "none" then
        AddWatchedUnits(unit)
      end
    end,
    force_events = unitHelperFunctions.UnitChangedForceEvents,
    name = L["Threat Situation"],
    init = function(trigger)
      trigger.unit = trigger.unit or "target";
      local ret = [[
        unit = string.lower(unit)
        local name = UnitName(unit, false)
        local ok = true
        local aggro, status, threatpct, rawthreatpct, threatvalue, threattotal
        if unit and unit ~= "none" then
          aggro, status, threatpct, rawthreatpct, threatvalue = WeakAuras.UnitDetailedThreatSituation('player', unit)
          threattotal = (threatvalue or 0) * 100 / (threatpct ~= 0 and threatpct or 1)
        else
          status = UnitThreatSituation('player')
          aggro = status == 2 or status == 3
          threatpct, rawthreatpct, threatvalue, threattotal = 100, 100, 0, 100
        end
      ]];
      return ret .. unitHelperFunctions.SpecificUnitCheck(trigger);
    end,
    progressType = "static",
    statesParameter = "unit",
    args = {
      {
        name = "unit",
        display = L["Unit"],
        required = true,
        type = "unit",
        init = "arg",
        values = "threat_unit_types",
        test = "true",
        store = true,
        default = "target"
      },
      {
        name = "status",
        display = L["Status"],
        type = "select",
        values = "unit_threat_situation_types",
        store = true,
        conditionType = "select"
      },
      {
        name = "aggro",
        display = L["Aggro"],
        type = "tristate",
        store = true,
        conditionType = "bool",
      },
      {
        name = "threatpct",
        display = L["Threat Percent"],
        desc = L["Your threat on the mob as a percentage of the amount required to pull aggro. Will pull aggro at 100."],
        type = "number",
        store = true,
        conditionType = "number",
        enable = function(trigger) return trigger.unit ~= "none" end,
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "rawthreatpct",
        display = L["Raw Threat Percent"],
        desc = L["Your threat as a percentage of the tank's current threat."],
        type = "number",
        store = true,
        conditionType = "number",
        enable = function(trigger) return trigger.unit ~= "none" end,
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "threatvalue",
        display = L["Threat Value"],
        desc = L["Your total threat on the mob."],
        type = "number",
        store = true,
        conditionType = "number",
        enable = function(trigger) return trigger.unit ~= "none" end,
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        type = "header",
        name = "unitCharacteristicsHeader",
        display = L["Unit Characteristics"],
      },
      {
        name = "name",
        display = L["Unit Name"],
        type = "string",
        store = true,
        multiline = true,
        preamble = "local nameChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "nameChecker:Check(name)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.name)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."]
      },
      {
        name = "npcId",
        display = L["Npc ID"],
        type = "string",
        multiline = true,
        store = true,
        init = "select(6, strsplit('-', UnitGUID(unit) or ''))",
        conditionType = "string",
        preamble = "local npcIdChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "npcIdChecker:Check(npcId)",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.npcId)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."]
      },
      {
        name = "value",
        hidden = true,
        init = "threatvalue",
        store = true,
        test = "true"
      },
      {
        name = "total",
        hidden = true,
        init = "threattotal",
        store = true,
        test = "true"
      },
      {
        name = "progressType",
        hidden = true,
        init = "'static'",
        store = true,
        test = "true"
      },
      {
        hidden = true,
        test = "status ~= nil and ok"
      },
      {
        hidden = true,
        test = "WeakAuras.UnitExistsFixed(unit, false) and specificUnitCheck"
      }
    },
    automaticrequired = true
  },
  ["Crowd Controlled"] = {
    type = "unit",
    events = {
      ["events"] = {
        "LOSS_OF_CONTROL_UPDATE",
        "PLAYER_ENTERING_WORLD"
      }
    },
    force_events = "LOSS_OF_CONTROL_UPDATE",
    name = L["Crowd Controlled"],
    statesParameter = "one",
    init = function(trigger)
      local ret = [=[
          local show = false
          local use_controlType = %s
          local controlType = %s
          local inverse = %s
          local use_interruptSchool = %s
          local interruptSchool = tonumber(%q)
          local duration, expirationTime, spellName, icon, spellName, spellId, locType, lockoutSchool, name, _
          for i = 1, C_LossOfControl.GetActiveLossOfControlDataCount() do
            local data = C_LossOfControl.GetActiveLossOfControlData(i)
            if data then
              if (not use_controlType)
              or (data.locType == controlType and (controlType ~= "SCHOOL_INTERRUPT" or ((not use_interruptSchool) or bit.band(data.lockoutSchool, interruptSchool) > 0)))
              then
                spellId = data.spellID
                spellName, _, icon = Private.ExecEnv.GetSpellInfo(data.spellID)
                duration = data.duration
                if data.startTime and data.duration then
                  expirationTime = data.startTime + data.duration
                end
                locType = data.locType
                lockoutSchool = data.lockoutSchool
                name = data.displayText
                show = true
                break
              end
            end
          end
      ]=]
      ret = ret:format(
        trigger.use_controlType and "true" or "false",
        type(trigger.controlType) == "string" and "[["..trigger.controlType.."]]" or [["STUN"]],
        trigger.use_inverse and "true" or "false",
        trigger.use_interruptSchool and "true" or "false",
        trigger.interruptSchool or 0
      )
      return ret
    end,
    args = {
      {
        name = "controlType",
        display = L["Specific Type"],
        type = "select",
        values = "loss_of_control_types",
        conditionType = "select",
        test = "true",
        default = "STUN",
        init = "locType",
        store = true,
      },
      {
        name = "interruptSchool",
        display = L["Interrupt School"],
        type = "select",
        values = "main_spell_schools",
        conditionType = "select",
        default = 1,
        test = "true",
        enable = function(trigger) return trigger.controlType == "SCHOOL_INTERRUPT" end,
        init = "lockoutSchool",
        store = true,
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        conditionType = "string",
        store = true,
        test = "true",
      },
      {
        name = "spellName",
        display = L["Spell Name"],
        hidden = true,
        conditionType = "string",
        store = true,
        test = "true",
      },
      {
        name = "spellId",
        display = L["Spell Id"],
        hidden = true,
        conditionType = "number",
        operator_types = "only_equal",
        store = true,
        test = "true",
        noProgressSource = true
      },
      {
        name = "lockoutSchool",
        display = L["Interrupted School Text"],
        hidden = true,
        init = "lockoutSchool and lockoutSchool > 0 and GetSchoolString(lockoutSchool) or nil",
        store = true,
        test = "true",
      },
      {
        name = "icon",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "duration",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "expirationTime",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "progressType",
        hidden = true,
        init = "'timed'",
        store = true,
        test = "true",
      },
      {
        hidden = true,
        test = "inverse ~= show",
      },
    },
    automaticrequired = true,
    progressType = "timed"
  },
  ["Cast"] = {
    type = "unit",
    events = function(trigger)
      local result = {}
      local unit = trigger.unit
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_START")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_DELAYED")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_STOP")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_CHANNEL_START")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_CHANNEL_UPDATE")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_CHANNEL_STOP")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_INTERRUPTIBLE")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_NOT_INTERRUPTIBLE")
      AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_INTERRUPTED")
      AddUnitEventForEvents(result, unit, "UNIT_NAME_UPDATE")
      if WeakAuras.IsRetail() then
        AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_EMPOWER_START_FAKE")
        AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_EMPOWER_UPDATE_FAKE")
        AddUnitEventForEvents(result, unit, "UNIT_SPELLCAST_EMPOWER_STOP_FAKE")
      end
      AddUnitEventForEvents(result, unit, "UNIT_TARGET")
      return result
    end,
    internal_events = function(trigger)
      local unit = trigger.unit
      local result = {}
      if unit == "nameplate" and trigger.use_onUpdateUnitTarget then
        tinsert(result, "WA_UNIT_TARGET_NAME_PLATE")
      end
      AddRemainingCastInternalEvents(unit, result)
      local includePets = trigger.use_includePets == true and trigger.includePets or nil
      AddUnitChangeInternalEvents(unit, result, includePets)
      if includePets ~= "PetsOnly" then
        AddUnitRoleChangeInternalEvents(unit, result)
      end
      return result
    end,
    loadFunc = function(trigger)
      if trigger.use_showLatency and trigger.unit == "player" then
        WeakAuras.WatchForCastLatency()
      end
      if trigger.unit == "nameplate" and trigger.use_onUpdateUnitTarget then
        WeakAuras.WatchForNameplateTargetChange()
      end
      local includePets = trigger.use_includePets == true and trigger.includePets or nil
      AddWatchedUnits(trigger.unit, includePets)
    end,
    force_events = unitHelperFunctions.UnitChangedForceEventsWithPets,
    progressType = "timed",
    name = L["Cast"],
    init = function(trigger)
      trigger.unit = trigger.unit or "player";
      local ret = [=[
        unit = string.lower(unit)
        local destUnit = unit .. '-target'
        local sourceName, sourceRealm = WeakAuras.UnitNameWithRealm(unit)
        local destName, destRealm = WeakAuras.UnitNameWithRealm(destUnit)
        destName = destName or ""
        destRealm = destRealm or ""
        local smart = %s
        local remainingCheck = %s
        local inverseTrigger = %s
        local showChargedDuration = %s
        local empowered = false
        local stage = 0
        local stagesData = {}

        local show, expirationTime, castType, spell, icon, startTime, endTime, interruptible, spellId, remaining, _, stageTotal

        spell, _, icon, startTime, endTime, _, _, interruptible, spellId = WeakAuras.UnitCastingInfo(unit)
        if spell then
          castType = "cast"
        else
          spell, _, icon, startTime, endTime, _, interruptible, spellId, _, stageTotal = WeakAuras.UnitChannelInfo(unit)
          if spell then
            castType = "channel"
            if stageTotal and stageTotal > 0 then
              empowered = true

              local lastFinish = 0
              for i = 1, stageTotal do
                stagesData[i] = {
                  start = lastFinish,
                  finish = lastFinish + GetUnitEmpowerStageDuration(unit, i - 1) / 1000
                }
                lastFinish = stagesData[i].finish
                if startTime / 1000 + lastFinish <= GetTime() then
                  stage = i
                end
                if Round(startTime/1000) == Round(GetTime()) then
                  Private.ExecEnv.ScheduleCastCheck(startTime / 1000 + lastFinish, unit)
                end
              end
            end
          end
        end
        if empowered and showChargedDuration then
          endTime = endTime + GetUnitEmpowerHoldAtMaxTime(unit)
        end
        interruptible = not interruptible
        expirationTime = endTime and endTime > 0 and (endTime / 1000) or 0
        remaining = expirationTime - GetTime()

        if remainingCheck and remaining >= remainingCheck and remaining > 0 then
          Private.ExecEnv.ScheduleCastCheck(expirationTime - remainingCheck, unit)
        end
      ]=];
      ret = ret:format(trigger.unit == "group" and "true" or "false",
                        trigger.use_remaining and tonumber(trigger.remaining or 0) or "nil",
                        trigger.use_inverse and "true" or "false",
                        trigger.use_showChargedDuration and "true" or "false"
                      );

      ret = ret .. unitHelperFunctions.SpecificUnitCheck(trigger)

      return ret
    end,
    statesParameter = "unit",
    args = {
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "arg",
        values = function(trigger)
          if trigger.use_inverse then
            return Private.actual_unit_types_with_specific
          else
            return Private.actual_unit_types_cast
          end
        end,
        desc = Private.actual_unit_types_cast_tooltip,
        test = "true",
        store = true
      },
      {
        name = "spellNames",
        display = L["Name(s)"],
        type = "spell",
        enable = function(trigger) return not trigger.use_inverse end,
        preambleGroup = "spell",
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddName(%q)"
        },
        test = "spellChecker:Check(spellId)",
        noValidation = true,
      },
      {
        name = "spellIds",
        display = L["Exact Spell ID(s)"],
        type = "spell",
        enable = function(trigger) return not trigger.use_inverse end,
        preambleGroup = "spell",
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddExact(%q)"
        },
        test = "spellChecker:Check(spellId)",
      },
      {
        name = "spellId",
        display = L["Spell ID"],
        conditionType = "number",
        store = true,
        test = "true",
        hidden = true,
        noProgressSource = true
      },
      {
        name = "spell",
        display = L["Spellname"],
        type = "string",
        conditionType = "string",
        store = true,
        test = "true",
        hidden = true
      },
      {
        name = "castType",
        display = L["Cast Type"],
        type = "select",
        values = "cast_types",
        enable = function(trigger) return not trigger.use_inverse end,
        store = true,
        conditionType = "select"
      },
      {
        name = "interruptible",
        display = L["Interruptible"],
        type = "tristate",
        enable = function(trigger) return not trigger.use_inverse end,
        store = true,
        conditionType = "bool",
      },

      {
        name = "remaining",
        display = L["Remaining Time"],
        type = "number",
        enable = function(trigger) return not trigger.use_inverse end,
      },
      {
        type = "header",
        name = "empoweredHeader",
        display = L["Empowered Cast"],
        enable = WeakAuras.IsRetail() and function(trigger) return not trigger.use_inverse end or false,
        hidden = not WeakAuras.IsRetail()
      },
      {
        name = "empowered",
        display = L["Empowered"],
        type = "tristate",
        enable = WeakAuras.IsRetail() and function(trigger) return not trigger.use_inverse end or false,
        store = true,
        conditionType = "bool",
        hidden = not WeakAuras.IsRetail()
      },
      {
        name = "showChargedDuration",
        display = L["Show charged duration for empowered casts"],
        type = "toggle",
        enable = WeakAuras.IsRetail() and function(trigger) return not trigger.use_inverse end or false,
        hidden = not WeakAuras.IsRetail(),
        reloadOptions = true,
      },
      {
        name = "stage",
        display = L["Current Stage"],
        type = "number",
        enable = WeakAuras.IsRetail() and function(trigger) return not trigger.use_inverse end or false,
        store = true,
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "stageTotal",
        display = L["Total Stages"],
        type = "number",
        enable = WeakAuras.IsRetail() and function(trigger) return not trigger.use_inverse end or false,
        store = true,
        conditionType = "number",
        hidden = not WeakAuras.IsRetail()
      },
      {
        name = "charged",
        display = L["Empowered Cast Fully Charged"],
        hidden = true,
        init = "stage == stageTotal",
        test = "true",
        enable = WeakAuras.IsRetail() and function(trigger) return not trigger.use_inverse end or false,
        store = true,
        type = "toggle",
        conditionType = "bool",
      },
      {
        name = "name",
        hidden = true,
        init = "spell",
        test = "true",
        store = true
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        name = "duration",
        hidden = true,
        init = "endTime and startTime and (endTime - startTime)/1000 or 0",
        test = "true",
        store = true
      },
      {
        name = "expirationTime",
        init = "expirationTime",
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "progressType",
        hidden = true,
        init = "'timed'",
        test = "true",
        store = true
      },
      {
        name = "inverse",
        hidden = true,
        init = "castType == 'cast'",
        test = "true",
        store = true
      },
      {
        name = "autoHide",
        hidden = true,
        init = "not empowered",
        test = "true",
        store = true,
        enable = function(trigger)
          return not trigger.use_inverse
        end
      },
      {
        type = "header",
        name = "unitCharacteristicsHeader",
        display = L["Unit Characteristics"],
      },
      {
        name = "npcId",
        display = L["Npc ID"],
        type = "string",
        multiline = true,
        store = true,
        init = "select(6, strsplit('-', UnitGUID(unit) or ''))",
        conditionType = "string",
        preamble = "local npcIdChecker = Private.ExecEnv.ParseStringCheck(%q)",
        test = "npcIdChecker:Check(npcId)",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseStringCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.npcId)
        end,
        operator_types = "none",
        desc = L["Supports multiple entries, separated by commas. Prefix with '-' for negation."],
        enable = function(trigger)
          return not trigger.use_inverse
        end,
      },
      {
        name = "class",
        display = L["Class"],
        type = "select",
        init = "select(2, UnitClass(unit))",
        values = "class_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return not trigger.use_inverse
        end
      },
      {
        name = "role",
        display = L["Assigned Role"],
        type = "select",
        init = "UnitGroupRolesAssigned(unit)",
        values = "role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
                 and not trigger.use_inverse
        end
      },
      {
        name = "raid_role",
        display = L["Raid Role"],
        type = "select",
        init = "WeakAuras.UnitRaidRole(unit)",
        values = "raid_role_types",
        store = true,
        conditionType = "select",
        enable = function(trigger)
          return WeakAuras.IsClassicOrCataOrMists() and (trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party")
                 and not trigger.use_inverse
        end
      },
      {
        name = "raidMarkIndex",
        display = L["Raid Mark"],
        type = "multiselect",
        values = "raid_mark_check_type",
        store = true,
        conditionType = "select",
        init = "GetRaidTargetIndex(unit) or 0"
      },
      {
        name = "raidMark",
        display = L["Raid Mark Icon"],
        store = true,
        hidden = true,
        test = "true",
        init = "raidMarkIndex > 0 and '{rt'..raidMarkIndex..'}' or ''"
      },
      {
        name = "nameplateType",
        display = L["Hostility"],
        type = "select",
        init = "WeakAuras.GetPlayerReaction(unit)",
        values = "hostility_types",
        store = true,
        conditionType = "select",
      },
      {
        name = "sourceUnit",
        init = "unit",
        display = L["Caster"],
        type = "unit",
        values = "actual_unit_types_with_specific",
        conditionType = "unit",
        conditionTest = function(state, unit, op)
          return state and state.show and state.unit and (UnitIsUnit(state.sourceUnit, unit) == (op == "=="))
        end,
        store = true,
        hidden = true,
        enable = function(trigger) return not trigger.use_inverse end,
        test = "true"
      },
      {
        name = "sourceName",
        display = L["Caster Name"],
        type = "string",
        store = true,
        hidden = true,
        test = "true",
        enable = function(trigger) return not trigger.use_inverse end,
      },
      {
        name = "sourceRealm",
        display = L["Caster Realm"],
        type = "string",
        store = true,
        hidden = true,
        test = "true",
        enable = function(trigger) return not trigger.use_inverse end,
      },
      {
        name = "sourceNameRealm",
        display = L["Source Unit Name/Realm"],
        type = "string",
        multiline = true,
        preamble = "local sourceNameRealmChecker = Private.ExecEnv.ParseNameCheck(%q)",
        test = "sourceNameRealmChecker:Check(sourceName, sourceRealm)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseNameCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.sourceName, state.sourceRealm)
        end,
        operator_types = "none",
        enable = function(trigger) return not trigger.use_inverse end,
        desc = constants.nameRealmFilterDesc,
      },
      {
        name = "destUnit",
        display = L["Caster's Target"],
        type = "unit",
        values = "actual_unit_types_with_specific",
        conditionType = "unit",
        conditionTest = function(state, unit, op)
          return state and state.show and state.destUnit and (UnitIsUnit(state.destUnit, unit) == (op == "=="))
        end,
        store = true,
        enable = function(trigger) return not trigger.use_inverse end,
        test = "UnitIsUnit(destUnit, [[%s]])"
      },
      {
        name = "destName",
        display = L["Name of Caster's Target"],
        type = "string",
        store = true,
        hidden = true,
        test = "true",
        enable = function(trigger) return not trigger.use_inverse end,
      },
      {
        name = "destRealm",
        display = L["Realm of Caster's Target"],
        type = "string",
        store = true,
        hidden = true,
        test = "true",
        enable = function(trigger) return not trigger.use_inverse end,
      },
      {
        name = "destNameRealm",
        display = L["Name/Realm of Caster's Target"],
        type = "string",
        multiline = true,
        preamble = "local destNameRealmChecker = Private.ExecEnv.ParseNameCheck(%q)",
        test = "destNameRealmChecker:Check(destName, destRealm)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseNameCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.destName, state.destRealm)
        end,
        operator_types = "none",
        enable = function(trigger) return not trigger.use_inverse end,
        desc = constants.nameRealmFilterDesc,
      },
      {
        type = "header",
        name = "miscellaneousHeader",
        display = L["Miscellaneous"],
      },
      {
        name = "showLatency",
        display = L["Overlay Latency"],
        type = "toggle",
        test = "true",
        enable = function(trigger)
          return trigger.unit == "player" and not trigger.use_inverse
        end,
        reloadOptions = true
      },
      {
        name = "includePets",
        display = L["Include Pets"],
        type = "select",
        values = "include_pets_types",
        width = WeakAuras.normalWidth,
        test = "true",
        enable = function(trigger)
          return trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end
      },
      {
        name = "ignoreSelf",
        display = L["Ignore Self"],
        type = "toggle",
        width = WeakAuras.doubleWidth,
        enable = function(trigger)
          return trigger.unit == "nameplate" or trigger.unit == "group" or trigger.unit == "raid" or trigger.unit == "party"
        end,
        init = "not UnitIsUnit(\"player\", unit)"
      },
      {
        name = "onUpdateUnitTarget",
        display = WeakAuras.newFeatureString .. L["Advanced Caster's Target Check"],
        desc = L["Check nameplate's target every 0.2s"],
        type = "toggle",
        test = "true",
        enable = function(trigger)
          return trigger.unit == "nameplate"
        end
      },
      {
        name = "inverse",
        display = L["Inverse"],
        type = "toggle",
        test = "true",
        reloadOptions = true
      },
      {
        hidden = true,
        test = "WeakAuras.UnitExistsFixed(unit, smart) and ((not inverseTrigger and spell) or (inverseTrigger and not spell)) and specificUnitCheck"
      },
      {
        name = "stagesData",
        hidden = true,
        test = "true",
        store = true,
        init = "stagesData",
      }
    },
    overlayFuncs = {
      {
        name = L["Latency"],
        func = function(trigger, state)
          local latency = WeakAuras.GetCastLatency()
          if not latency then return 0, 0 end
          return 0, latency
        end,
        enable = function(trigger)
          return trigger.use_showLatency and trigger.unit == "player"
        end
      },
      {
        name = L["Empowered 1"],
        func = function(trigger, state)
          if not state.stageTotal or state.stageTotal < 1 then return 0, 0 end
          return state.duration - state.stagesData[1].start, state.duration - state.stagesData[1].finish
        end,
        enable = WeakAuras.IsRetail()
      },
      {
        name = L["Empowered 2"],
        func = function(trigger, state)
          if not state.stageTotal or state.stageTotal < 2 then return 0, 0 end
          return state.duration - state.stagesData[2].start, state.duration - state.stagesData[2].finish
        end,
        enable = WeakAuras.IsRetail()
      },
      {
        name = L["Empowered 3"],
        func = function(trigger, state)
          if not state.stageTotal or state.stageTotal < 3 then return 0, 0 end
          return state.duration - state.stagesData[3].start, state.duration - state.stagesData[3].finish
        end,
        enable = WeakAuras.IsRetail()
      },
      {
        name = L["Empowered 4"],
        func = function(trigger, state)
          if not state.stageTotal or state.stageTotal < 4 then return 0, 0 end
          return state.duration - state.stagesData[4].start, state.duration - state.stagesData[4].finish
        end,
        enable = WeakAuras.IsRetail()
      },
      {
        name = L["Empowered 5"],
        func = function(trigger, state)
          if not state.stageTotal or state.stageTotal < 5 then return 0, 0 end
          return state.duration - state.stagesData[5].start, state.duration - state.stagesData[5].finish
        end,
        enable = WeakAuras.IsRetail()
      },
      {
        name = L["Empowered Fully Charged"],
        func = function(trigger, state)
          if not state.stageTotal or not state.stagesData[state.stageTotal]
            or not trigger.use_showChargedDuration
          then
            return 0, 0
          end
          return state.duration - state.stagesData[state.stageTotal].finish, 0
        end,
        enable = function(trigger)
          return WeakAuras.IsRetail() and trigger.use_showChargedDuration
        end
      }
    },
    GetNameAndIcon = function(trigger)
      local name, icon, spellId, _
      if trigger.use_spellNames and type(trigger.spellNames) == "table" then
        for _, spellName in ipairs(trigger.spellNames) do
          spellId = WeakAuras.SafeToNumber(spellName)
          if spellId then
            name, _, icon = Private.ExecEnv.GetSpellInfo(spellName)
            if name and icon then
              return name, icon
            end
          elseif not tonumber(spellName) then
            name, _, icon = Private.ExecEnv.GetSpellInfo(spellName)
            if name and icon then
              return name, icon
            end
          end
        end
      end
      if trigger.use_spellIds and type(trigger.spellIds) == "table" then
        for _, spellIdString in ipairs(trigger.spellIds) do
          spellId = WeakAuras.SafeToNumber(spellIdString)
          if spellId then
            name, _, icon = Private.ExecEnv.GetSpellInfo(spellIdString)
            if name and icon then
              return name, icon
            end
          end
        end
      end
    end,
    automaticrequired = true,
  },
  ["Character Stats"] = {
    type = "unit",
    name = L["Character Stats"],
    events = {
      ["events"] = {
        "COMBAT_RATING_UPDATE",
        "PLAYER_TARGET_CHANGED"
      },
      ["unit_events"] = {
        ["player"] = {"UNIT_STATS", "UNIT_ATTACK_POWER", "UNIT_AURA", "PLAYER_DAMAGE_DONE_MODS", "UNIT_RESISTANCES"}
      }
    },
    internal_events = function(trigger, untrigger)
      local events = { "WA_DELAYED_PLAYER_ENTERING_WORLD" }
      if trigger.use_moveSpeed then
        tinsert(events, "PLAYER_MOVE_SPEED_UPDATE")
      end
      return events
    end,
    loadFunc = function(trigger)
      if trigger.use_moveSpeed then
        WeakAuras.WatchForPlayerMoving()
      end
    end,
    init = function()
      local ret = [[
        local main_stat, _
        if WeakAuras.IsRetail() then
          _, _, _, _, _, main_stat = Private.ExecEnv.GetSpecializationInfo(Private.ExecEnv.GetSpecialization() or 0)
        end
      ]]
      return ret;
    end,
    force_events = "CONDITIONS_CHECK",
    statesParameter = "one",
    args = {
      {
        type = "header",
        name = "primaryStatsHeader",
        display = L["Primary Stats"],
      },
      {
        name = "mainstat",
        display = L["Main Stat"],
        type = "number",
        init = "UnitStat('player', main_stat or 1)",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "strength",
        display = L["Strength"],
        type = "number",
        init = "UnitStat('player', LE_UNIT_STAT_STRENGTH)",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "agility",
        display = L["Agility"],
        type = "number",
        init = "UnitStat('player', LE_UNIT_STAT_AGILITY)",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "intellect",
        display = L["Intellect"],
        type = "number",
        init = "UnitStat('player', LE_UNIT_STAT_INTELLECT)",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "spirit",
        display = L["Spirit"],
        type = "number",
        init = "UnitStat('player', 5)",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "stamina",
        display = L["Stamina"],
        type = "number",
        init = "select(2, UnitStat('player', LE_UNIT_STAT_STAMINA)) * GetUnitMaxHealthModifier('player')",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        type = "header",
        name = "secondaryStatsHeader",
        display = L["Secondary Stats"],
      },
      {
        name = "criticalrating",
        display = L["Critical Rating"],
        type = "number",
        init = "max(GetCombatRating(CR_CRIT_MELEE), GetCombatRating(CR_CRIT_RANGED), GetCombatRating(CR_CRIT_SPELL))",
        store = true,
        enable = WeakAuras.IsCataOrMistsOrRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "criticalpercent",
        display = L["Critical (%)"],
        type = "number",
        init = "WeakAuras.GetCritChance()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "hitrating",
        display = L["Hit Rating"],
        type = "number",
        init = "max(GetCombatRating(CR_HIT_MELEE), GetCombatRating(CR_HIT_RANGED), GetCombatRating(CR_HIT_SPELL))",
        store = true,
        enable = WeakAuras.IsCataOrMists(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "hitpercent",
        display = L["Hit (%)"],
        type = "number",
        init = "WeakAuras.GetHitChance()",
        store = true,
        conditionType = "number",
        enable = WeakAuras.IsCataOrMists(),
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "hasterating",
        display = L["Haste Rating"],
        type = "number",
        init = "GetCombatRating(CR_HASTE_SPELL)",
        store = true,
        enable = WeakAuras.IsCataOrMistsOrRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "hastepercent",
        display = L["Haste (%)"],
        type = "number",
        init = "GetHaste()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "meleehastepercent",
        display = L["Melee Haste (%)"],
        type = "number",
        init = "GetMeleeHaste()",
        store = true,
        conditionType = "number",
        enable = WeakAuras.IsCataOrMists(),
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "expertiserating",
        display = L["Expertise Rating"],
        type = "number",
        init = "GetCombatRating(CR_EXPERTISE)",
        store = true,
        enable = WeakAuras.IsCataOrMists(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "expertisebonus",
        display = L["Expertise Bonus"],
        type = "number",
        init = "GetCombatRatingBonus(CR_EXPERTISE)",
        store = true,
        conditionType = "number",
        enable = WeakAuras.IsCataOrMists(),
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "spellpenpercent",
        display = L["Spell Peneration Percent"],
        type = "number",
        init = "GetSpellPenetration()",
        store = true,
        enable = WeakAuras.IsCataOrMists(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "masteryrating",
        display = L["Mastery Rating"],
        type = "number",
        init = "GetCombatRating(CR_MASTERY)",
        store = true,
        enable = WeakAuras.IsCataOrMistsOrRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "masterypercent",
        display = L["Mastery (%)"],
        type = "number",
        init = "WeakAuras.IsCataOrMists() and GetMastery() or GetMasteryEffect()",
        store = true,
        enable = WeakAuras.IsCataOrMistsOrRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "versatilityrating",
        display = L["Versatility Rating"],
        type = "number",
        init = "GetCombatRating(CR_VERSATILITY_DAMAGE_DONE)",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "versatilitypercent",
        display = L["Versatility (%)"],
        type = "number",
        init = "GetCombatRatingBonus(CR_VERSATILITY_DAMAGE_DONE) + GetVersatilityBonus(CR_VERSATILITY_DAMAGE_DONE)",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "attackpower",
        display = L["Attack Power"],
        type = "number",
        init = "WeakAuras.GetEffectiveAttackPower()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "spellpower",
        display = L["Spell Power"],
        type = "number",
        init = "WeakAuras.GetEffectiveSpellPower()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        enable = WeakAuras.IsClassicOrCataOrMists(),
        hidden = not WeakAuras.IsClassicOrCataOrMists(),
      },
      {
        type = "header",
        name = "tertiaryStatsHeader",
        display = L["Tertiary Stats"],
      },
      {
        name = "leechrating",
        display = L["Leech Rating"],
        type = "number",
        init = "GetCombatRating(CR_LIFESTEAL)",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "leechpercent",
        display = L["Leech (%)"],
        type = "number",
        init = "GetLifesteal()",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "movespeedrating",
        display = L["Movement Speed Rating"],
        type = "number",
        init = "GetCombatRating(CR_SPEED)",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "moveSpeed",
        display = L["Continuously update Movement Speed"],
        type = "boolean",
        test = true,
        width = WeakAuras.doubleWidth
      },
      {
        name = "movespeedpercent",
        display = L["Current Movement Speed (%)"],
        type = "number",
        init = "GetUnitSpeed('player') / 7 * 100",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "runspeedpercent",
        display = L["Run Speed (%)"],
        type = "number",
        init = "select(2, GetUnitSpeed('player')) / 7 * 100",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "avoidancerating",
        display = L["Avoidance Rating"],
        type = "number",
        init = "GetCombatRating(CR_AVOIDANCE)",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "avoidancepercent",
        display = L["Avoidance (%)"],
        type = "number",
        init = "GetAvoidance()",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        type = "header",
        name = "defensiveStatsHeader",
        display = L["Defensive Stats"],
      },
      {
        name = "dodgerating",
        display = L["Dodge Rating"],
        type = "number",
        init = "GetCombatRating(CR_DODGE)",
        store = true,
        enable = WeakAuras.IsCataOrMistsOrRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "dodgepercent",
        display = L["Dodge (%)"],
        type = "number",
        init = "GetDodgeChance()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "parryrating",
        display = L["Parry Rating"],
        type = "number",
        init = "GetCombatRating(CR_PARRY)",
        store = true,
        enable = WeakAuras.IsCataOrMistsOrRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "parrypercent",
        display = L["Parry (%)"],
        type = "number",
        init = "GetParryChance()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "blockpercent",
        display = L["Block (%)"],
        type = "number",
        init = "GetBlockChance()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "blocktargetpercent",
        display = L["Block against Target (%)"],
        type = "number",
        init = "PaperDollFrame_GetArmorReductionAgainstTarget(GetShieldBlock())",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "blockvalue",
        display = L["Block Value"],
        type = "number",
        init = "GetShieldBlock()",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "staggerpercent",
        display = L["Stagger (%)"],
        type = "number",
        init = "C_PaperDollInfo.GetStaggerPercentage(\"player\")",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "staggertargetpercent",
        display = L["Stagger against Target (%)"],
        type = "number",
        init = "select(UnitExists(\"target\") and 2 or 1, C_PaperDollInfo.GetStaggerPercentage(\"player\"))",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "armorrating",
        display = L["Armor Rating"],
        type = "number",
        init = "select(2, UnitArmor('player'))",
        store = true,
        conditionType = "number",
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "armorpercent",
        display = L["Armor (%)"],
        type = "number",
        init = "PaperDollFrame_GetArmorReduction(select(2, UnitArmor('player')), UnitEffectiveLevel and UnitEffectiveLevel('player') or UnitLevel('player'))",
        store = true,
        enable = WeakAuras.IsCataOrMistsOrRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMistsOrRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "armortargetpercent",
        display = L["Armor against Target (%)"],
        type = "number",
        init = "PaperDollFrame_GetArmorReductionAgainstTarget(select(2, UnitArmor('player')))",
        store = true,
        enable = WeakAuras.IsRetail(),
        conditionType = "number",
        hidden = not WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        name = "resiliencerating",
        display = L["Resilience Rating"],
        type = "number",
        init = "GetCombatRating(COMBAT_RATING_RESILIENCE_PLAYER_DAMAGE_TAKEN)",
        store = true,
        enable = WeakAuras.IsCataOrMists(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "resiliencepercent",
        display = L["Resilience (%)"],
        type = "number",
        init = "GetCombatRatingBonus(COMBAT_RATING_RESILIENCE_PLAYER_DAMAGE_TAKEN)",
        store = true,
        enable = WeakAuras.IsCataOrMists(),
        conditionType = "number",
        hidden = not WeakAuras.IsCataOrMists(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
        formatter = "Number",
      },
      {
        type = "header",
        name = "resistanceHeader",
        display = L["Resistances"],
        hidden = WeakAuras.IsRetail(),
        enable = WeakAuras.IsClassicOrCataOrMists(),
      },
      {
        name = "resistanceholy",
        display = L["Holy Resistance"],
        type = "number",
        init = "select(2, UnitResistance('player', 1))",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "resistancefire",
        display = L["Fire Resistance"],
        type = "number",
        init = "select(2, UnitResistance('player', 2))",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "resistancenature",
        display = L["Nature Resistance"],
        type = "number",
        init = "select(2, UnitResistance('player', 3))",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "resistancefrost",
        display = L["Frost Resistance"],
        type = "number",
        init = "select(2, UnitResistance('player', 4))",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "resistanceshadow",
        display = L["Shadow Resistance"],
        type = "number",
        init = "select(2, UnitResistance('player', 5))",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
      {
        name = "resistancearcane",
        display = L["Arcane Resistance"],
        type = "number",
        init = "select(2, UnitResistance('player', 6))",
        store = true,
        enable = WeakAuras.IsClassicOrCataOrMists(),
        conditionType = "number",
        hidden = WeakAuras.IsRetail(),
        multiEntry = {
          operator = "and",
          limit = 2
        },
      },
    },
    automaticrequired = true,
    progressType = "none"
  },
  ["Conditions"] = {
    type = "unit",
    events = function(trigger, untrigger)
      local events = {}
      if trigger.use_incombat ~= nil then
        tinsert(events, "PLAYER_REGEN_ENABLED")
        tinsert(events, "PLAYER_REGEN_DISABLED")
        tinsert(events, "PLAYER_ENTERING_WORLD")
      end
      if trigger.use_pvpflagged ~= nil or trigger.use_afk ~= nil then
        tinsert(events, "PLAYER_FLAGS_CHANGED")
      end
      if trigger.use_alive ~= nil then
        tinsert(events, "PLAYER_DEAD")
        tinsert(events, "PLAYER_ALIVE")
        tinsert(events, "PLAYER_UNGHOST")
      end
      if trigger.use_resting ~= nil then
        tinsert(events, "PLAYER_UPDATE_RESTING")
        tinsert(events, "PLAYER_ENTERING_WORLD")
      end
      if trigger.use_mounted ~= nil then
        tinsert(events, "PLAYER_MOUNT_DISPLAY_CHANGED")
        tinsert(events, "PLAYER_ENTERING_WORLD")
      end
      local unit_events = {}
      local pet_unit_events = {}
      if trigger.use_vehicle ~= nil then
        if WeakAuras.IsClassicEra() then
          tinsert(unit_events, "UNIT_FLAGS")
        else
          tinsert(unit_events, "UNIT_ENTERED_VEHICLE")
          tinsert(unit_events, "UNIT_EXITED_VEHICLE")
        end
        tinsert(events, "PLAYER_ENTERING_WORLD")
      end
      if trigger.use_HasPet ~= nil then
        tinsert(pet_unit_events, "UNIT_HEALTH")
      end
      if trigger.use_ingroup ~= nil then
        tinsert(events, "GROUP_ROSTER_UPDATE")
      end
      if trigger.use_instance_difficulty ~= nil
         or trigger.use_instance_type ~= nil
         or trigger.use_instance_size ~= nil
      then
        tinsert(events, "PLAYER_DIFFICULTY_CHANGED")
      end

      return {
        ["events"] = events,
        ["unit_events"] = {
          ["player"] = unit_events,
          ["pet"] = pet_unit_events
        }
      }
    end,
    internal_events = function(trigger, untrigger)
      local events = { "CONDITIONS_CHECK"};

      if (trigger.use_ismoving ~= nil) then
        tinsert(events, "PLAYER_MOVING_UPDATE");
      end

      if trigger.use_instance_difficulty ~= nil
        or trigger.use_instance_type ~= nil
        or trigger.use_instance_size ~= nil
        or trigger.use_pvpflagged ~= nil
      then
        tinsert(events, "WA_DELAYED_PLAYER_ENTERING_WORLD")
      end

      if (trigger.use_HasPet ~= nil) then
        AddUnitChangeInternalEvents("pet", events)
      end

      return events;
    end,
    force_events = "CONDITIONS_CHECK",
    name = L["Conditions"],
    loadFunc = function(trigger)
      if (trigger.use_ismoving ~= nil) then
        WeakAuras.WatchForPlayerMoving();
      end
      if (trigger.use_HasPet ~= nil) then
        AddWatchedUnits("pet")
      end
    end,
    init = function(trigger)
      return "";
    end,
    args = {
      {
        name = "alwaystrue",
        display = L["Always active trigger"],
        type = "tristate",
        init = "true"
      },
      {
        name = "incombat",
        display = L["In Combat"],
        type = "tristate",
        init = "UnitAffectingCombat('player')"
      },
      {
        name = "pvpflagged",
        display = L["PvP Flagged"],
        type = "tristate",
        init = "UnitIsPVP('player')",
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail()
      },
      {
        name = "alive",
        display = L["Alive"],
        type = "tristate",
        init = "not UnitIsDeadOrGhost('player')"
      },
      {
        name = "vehicle",
        display = not WeakAuras.IsCataOrMistsOrRetail() and L["On Taxi"] or L["In Vehicle"],
        type = "tristate",
        init = not WeakAuras.IsCataOrMistsOrRetail() and "UnitOnTaxi('player')" or "UnitInVehicle('player')",
      },
      {
        name = "resting",
        display = L["Resting"],
        type = "tristate",
        init = "IsResting()"
      },
      {
        name = "mounted",
        display = L["Mounted"],
        type = "tristate",
        init = "IsMounted()"
      },
      {
        name = "HasPet",
        display = L["HasPet"],
        type = "tristate",
        init = "UnitExists('pet') and not UnitIsDead('pet')"
      },
      {
        name = "ismoving",
        display = L["Is Moving"],
        type = "tristate",
        init = "IsPlayerMoving()"
      },
      {
        name = "afk",
        display = L["Is Away from Keyboard"],
        type = "tristate",
        init = "UnitIsAFK('player')"
      },
      {
        name = "ingroup",
        display = L["Group Type"],
        type = "multiselect",
        values = "group_types",
        init = "Private.ExecEnv.GroupType()",
      },
      {
        name = "instance_size",
        display = L["Instance Size Type"].." "..L["|cffff0000deprecated|r"],
        desc = constants.instanceFilterDeprecated,
        type = "multiselect",
        values = "instance_types",
        sorted = true,
        init = "WeakAuras.InstanceType()",
      },
      {
        name = "instance_difficulty",
        display = L["Instance Difficulty"].." "..L["|cffff0000deprecated|r"],
        desc = constants.instanceFilterDeprecated,
        type = "multiselect",
        values = "difficulty_types",
        init = "WeakAuras.InstanceDifficulty()",
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
      },
      {
        name = "instance_type",
        display = L["Instance Type"].." "..L["|cffff0000deprecated|r"],
        desc = constants.instanceFilterDeprecated,
        type = "multiselect",
        values = "instance_difficulty_types",
        init = "WeakAuras.InstanceTypeRaw()",
        enable = WeakAuras.IsRetail(),
        hidden = not WeakAuras.IsRetail(),
      },
    },
    automaticrequired = true,
    progressType = "none"
  },

  ["Spell Known"] = {
    type = "spell",
    events = {
      ["events"] = WeakAuras.IsCataOrMists() and {"SPELLS_CHANGED","PLAYER_TALENT_UPDATE"} or {"SPELLS_CHANGED"},
      ["unit_events"] = {
        ["player"] = {"UNIT_PET"}
      }
    },
    internal_events = {
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = "SPELLS_CHANGED",
    name = L["Spell Known"],
    statesParameter = "one",
    init = function(trigger)
      local spellName;
      local ret = {};
      if (trigger.use_exact_spellName) then
        spellName = tonumber(trigger.spellName) or "nil";
        if spellName == 0 then
          spellName = "nil"
        end
        table.insert(ret, ([[
          local spellName = %s;
          local name, _, icon = Private.ExecEnv.GetSpellInfo(spellName)
        ]]):format(spellName))
      else
        local name = type(trigger.spellName) == "number" and Private.ExecEnv.GetSpellName(trigger.spellName) or trigger.spellName or "";
        table.insert(ret, ([[
          local spellName = select(7, Private.ExecEnv.GetSpellInfo(%q))
          local name, _, icon = Private.ExecEnv.GetSpellInfo(spellName)
        ]]):format(name))
      end
      if (trigger.use_inverse) then
        table.insert(ret, ([[
          local usePet = %s;
          local active = not spellName or not WeakAuras.IsSpellKnown(spellName, usePet)
        ]]):format(trigger.use_petspell and "true" or "false"))
      else
        table.insert(ret, ([[
          local usePet = %s;
          local active = spellName and WeakAuras.IsSpellKnown(spellName, usePet)
        ]]):format(trigger.use_petspell and "true" or "false"))
      end
      return table.concat(ret)
    end,
    GetNameAndIcon = function(trigger)
      local name, _, icon = Private.ExecEnv.GetSpellInfo(trigger.spellName)
      return name, icon
    end,
    args = {
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        test = "true",
        showExactOption = true,
      },
      {
        name = "petspell",
        display = L["Pet Spell"],
        type = "toggle",
        test = "true"
      },
      {
        name = "inverse",
        display = WeakAuras.newFeatureString .. L["Inverse"],
        type = "toggle",
        test = "true",
      },
      {
        name = "name",
        display = L["Name"],
        hidden = true,
        init = "name",
        test = "true",
        store = true,
        conditionType = "string"
      },
      {
        name = "icon",
        hidden = true,
        init = "icon",
        test = "true",
        store = true
      },
      {
        hidden = true,
        test = "active"
      }
    },
    automaticrequired = true,
    progressType = "none"
  },

  ["Pet Behavior"] = {
    type = "unit",
    events = function(trigger)
      local result = {};
      if (trigger.use_behavior) then
        tinsert(result, "PET_BAR_UPDATE");
      end
      if (trigger.use_petspec) then
        tinsert(result, "PET_SPECIALIZATION_CHANGED");
      end
      return {
        ["events"] = result,
        ["unit_events"] = {
          ["player"] = {"UNIT_PET"}
        }
      };
    end,
    internal_events = {
      "WA_DELAYED_PLAYER_ENTERING_WORLD"
    },
    force_events = "WA_DELAYED_PLAYER_ENTERING_WORLD",
    name = L["Pet"],
    init = function(trigger)
      local ret = "local activeIcon\n";
      if (trigger.use_behavior) then
        ret = [[
            local inverse = %s
            local check_behavior = %s
            local name, i, active, behavior, _
            for index = 1, NUM_PET_ACTION_SLOTS do
              name, i, _, active = GetPetActionInfo(index)
              if active then
                activeIcon = _G[i]
                if name == "PET_MODE_AGGRESSIVE" then
                  behavior = "aggressive"
                  break
                elseif name == "PET_MODE_ASSIST" then
                  behavior = "assist"
                  break
                elseif name == "PET_MODE_DEFENSIVEASSIST" then
                  behavior = "defensive"
                  break
                elseif name == "PET_MODE_DEFENSIVE" then
                  behavior = "defensive"
                  break
                elseif name == "PET_MODE_PASSIVE" then
                  behavior = "passive"
                  break
                end
              end
            end
        ]]
        ret = ret:format(trigger.use_inverse and "true" or "false", trigger.use_behavior and ('"' .. (trigger.behavior or "") .. '"') or "nil");
      end
      if (trigger.use_petspec) then
        ret = ret .. [[
          local petspec = Private.ExecEnv.GetSpecialization(false, true)
          if (petspec) then
            activeIcon = select(4, Private.ExecEnv.GetSpecializationInfo(petspec, false, true));
          end
        ]]
      end
      return ret;
    end,
    statesParameter = "one",
    args = {
      {
        name = "behavior",
        display = L["Pet Behavior"],
        type = "select",
        values = "pet_behavior_types",
        test = "UnitExists('pet') and (not check_behavior or (inverse and check_behavior ~= behavior) or (not inverse and check_behavior == behavior))",
      },
      {
        name = "inverse",
        display = L["Inverse Pet Behavior"],
        type = "toggle",
        test = "true",
        enable = function(trigger) return trigger.use_behavior end
      },
      {
        name = "petspec",
        display = L["Pet Specialization"],
        type = "select",
        values = "pet_spec_types",
      },
      {
        hidden = true,
        name = "icon",
        init = "activeIcon",
        store = "true",
        test = "true"
      },
    },
    automaticrequired = true,
    progressType = "none"
  },

  ["Queued Action"] = {
    type = "spell",
    events = {
      ["events"] = {"ACTIONBAR_UPDATE_STATE"}
    },
    internal_events = {
      "ACTIONBAR_SLOT_CHANGED",
      "ACTIONBAR_PAGE_CHANGED"
    },
    name = L["Queued Action"],
    init = function(trigger)
      trigger.spellName = trigger.spellName or 0
      local spellName
      if trigger.use_exact_spellName then
        spellName = trigger.spellName
      else
        spellName = type(trigger.spellName) == "number" and Private.ExecEnv.GetSpellInfo(trigger.spellName) or trigger.spellName
      end
      local ret = [=[
        local spellname = %q
      ]=]
      return ret:format(spellName)
    end,
    args = {
      {
        name = "spellName",
        required = true,
        display = L["Spell"],
        type = "spell",
        test = "true",
        showExactOption = true,
      },
      {
        hidden = true,
        test = "spellname and IsCurrentSpell(spellname)";
      },
    },
    iconFunc = function(trigger)
      return Private.ExecEnv.GetSpellIcon(trigger.spellName or 0);
    end,
    automaticrequired = true,
    progressType = "none"
  },

  ["Range Check"] = {
    type = "unit",
    events = {
      ["events"] = {"FRAME_UPDATE"}
    },
    name = L["Range Check"],
    init = function(trigger)
      trigger.unit = trigger.unit or "target";
      local ret = [=[
          local unit = %q;
          local min, max = WeakAuras.GetRange(unit, true);
          min = min or 0;
          max = max or 999;
          local triggerResult = true;
      ]=]
      if (trigger.use_range) then
        trigger.range = trigger.range or 8;
        if (trigger.range_operator == "<=") then
          ret = ret .. "triggerResult = max <= " .. tostring(trigger.range) .. "\n";
        else
          ret = ret .. "triggerResult = min >= " .. tostring(trigger.range).. "\n";
        end
      end
      return ret:format(trigger.unit);
    end,
    statesParameter = "one",
    args = {
      {
        name = "note",
        type = "description",
        display = "",
        text = function() return L["Note: This trigger type estimates the range to the hitbox of a unit. The actual range of friendly players is usually 3 yards more than the estimate. Range checking capabilities depend on your current class and known abilities as well as the type of unit being checked. Some of the ranges may also not work with certain NPCs.|n|n|cFFAAFFAAFriendly Units:|r %s|n|cFFFFAAAAHarmful Units:|r %s|n|cFFAAAAFFMiscellanous Units:|r %s"]:format(RangeCacheStrings.friend or "", RangeCacheStrings.harm or "", RangeCacheStrings.misc or "") end
      },
      {
        name = "unit",
        required = true,
        display = L["Unit"],
        type = "unit",
        init = "unit",
        values = "unit_types_range_check",
        test = "true",
        store = true
      },
      {
        hidden = true,
        name = "minRange",
        display = L["Minimum Estimate"],
        type = "number",
        init = "min",
        store = true,
        test = "true",
        conditionType = "number",
        operator_types = "without_equal",
      },
      {
        hidden = true,
        name = "maxRange",
        display = L["Maximum Estimate"],
        type = "number",
        init = "max",
        store = true,
        test = "true",
        conditionType = "number",
        operator_types = "without_equal",
      },
      {
        name = "range",
        display = L["Distance"],
        type = "number",
        operator_types = "without_equal",
        test = "triggerResult",
        conditionType = "number",
        conditionTest = function(state, needle, needle2)
          return state and state.show and WeakAuras.CheckRange(state.unit, needle, needle2);
        end,
        noProgressSource = true
      },
      {
        hidden = true,
        test = "UnitExists(unit)"
      }
    },
    automaticrequired = true,
    progressType = "none"
  },
  ["Money"] = {
    type = "unit",
    statesParameter = "one",
    progressType = "none",
    automaticrequired = true,
    events = {
      ["events"] = {"PLAYER_MONEY"}
    },
    internal_events = {"WA_DELAYED_PLAYER_ENTERING_WORLD"},
    force_events = "WA_DELAYED_PLAYER_ENTERING_WORLD",
    name = WeakAuras.newFeatureString..L["Player Money"],
    init = function()
      return [=[
        local money = GetMoney()
        local gold = floor(money / 1e4)
        local silver = floor(money / 100 % 100)
        local copper = money % 100
      ]=]
    end,
    args = {
      {
        name = "money",
        init = "money",
        type = "number",
        display = L["Money"],
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "gold",
        init = "gold",
        type = "number",
        display = Private.coin_icons.gold .. L["Gold"],
        store = true,
        conditionType = "number",
        formatter = "BigNumber"
      },
      {
        name = "silver",
        init = "silver",
        type = "number",
        display = Private.coin_icons.silver .. L["Silver"],
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "copper",
        init = "copper",
        type = "number",
        display = Private.coin_icons.copper .. L["Copper"],
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "icon",
        init = "C_CurrencyInfo.GetCoinIcon(money)",
        store = true,
        hidden = true,
        test = "true",
      },
    },
    GetNameAndIcon = function()
      return MONEY, C_CurrencyInfo.GetCoinIcon(GetMoney())
    end,
  },
  ["Currency"] = {
    type = "unit",
    progressType = "static",
    events = function()
      local events = {
        "CHAT_MSG_CURRENCY",
        "CURRENCY_DISPLAY_UPDATE",
      }
      if WeakAuras.IsRetail() then
        tinsert(events, "ACCOUNT_CHARACTER_CURRENCY_DATA_RECEIVED")
        tinsert(events, "CURRENCY_TRANSFER_LOG_UPDATE")
      end
      return {["events"] = events}
    end,
    internal_events = {"WA_DELAYED_PLAYER_ENTERING_WORLD"},
    force_events = "WA_DELAYED_PLAYER_ENTERING_WORLD",
    name = WeakAuras.newFeatureString..L["Currency"],
    triggerFunction = function(trigger)
      local quantityChecks, tristateChecks, cloneChecks = {}, {}, {}

      local function createQuantityCheck(property, operator, value, primary, use)
        if not use then return nil end
        if type(property) == "string" and type(operator) == "string" then
          return([[
            if not primaryCheckFailed and not ((currencyInfo["%s"] or 0) %s %s) then
              active = false
              %s
            end
          ]]):format(property, operator or "<", tonumber(value) or 0, primary and "primaryCheckFailed = true" or "")
        else
          return ""
        end
      end

      local function createTristateCheck(property, value, primary)
        if value == nil then return nil end
        return([[
          if currencyInfo["%s"] ~= %s then
            active = false
            %s
          end
        ]]):format(property, value and "true" or "false", primary and "primaryCheckFailed = true" or "")
      end

      local function createCloneCheck(property, operator, value, check_type, condition, use)
        if type(property) == "string" and type(operator) == "string" then
          if check_type == "number" and use then
            return([[
              if cloneActive and not ((currencyData["%s"] or 0) %s %s) then
                cloneActive = false
              end
            ]]):format(property, operator or "<", tonumber(value) or 0)
          elseif check_type == "tristate" and value ~= nil then
            return([[
              if cloneActive and %s ~= %s then
                cloneActive = false
              end
            ]]):format(condition, value and "true" or "false")
          else
          end
        end
        return ""
      end

      table.insert(quantityChecks, createQuantityCheck("quantity", trigger.value_operator, trigger.value, nil, trigger.use_value))
      table.insert(quantityChecks, createQuantityCheck("realCharacterQuantity", trigger.realCharacterQuantity_operator, trigger.realCharacterQuantity, nil, trigger.use_realCharacterQuantity))
      table.insert(quantityChecks, createQuantityCheck("accountQuantity", trigger.accountQuantity_operator, trigger.accountQuantity, true, trigger.use_accountQuantity))
      table.insert(quantityChecks, createQuantityCheck("realAccountQuantity", trigger.realAccountQuantity_operator, trigger.realAccountQuantity, true, trigger.use_realAccountQuantity))
      table.insert(quantityChecks, createQuantityCheck("maxQuantity", trigger.maxQuantity_operator, trigger.maxQuantity, true, trigger.use_maxQuantity))
      table.insert(quantityChecks, createQuantityCheck("quantityEarnedThisWeek", trigger.quantityEarnedThisWeek_operator, trigger.quantityEarnedThisWeek, true, trigger.use_quantityEarnedThisWeek))
      table.insert(quantityChecks, createQuantityCheck("totalEarned", trigger.totalEarned_operator, trigger.totalEarned, true, trigger.use_totalEarned))

      table.insert(tristateChecks, createTristateCheck("discovered", trigger.use_discovered))
      table.insert(tristateChecks, createTristateCheck("capped", trigger.use_capped))
      table.insert(tristateChecks, createTristateCheck("seasonCapped", trigger.use_seasonCapped, true))
      table.insert(tristateChecks, createTristateCheck("weeklyCapped", trigger.use_weeklyCapped, true))

      table.insert(cloneChecks, createCloneCheck("quantity", trigger.value_operator, trigger.value, "number", nil, trigger.use_value))
      table.insert(cloneChecks, createCloneCheck("realCharacterQuantity", trigger.realCharacterQuantity_operator, trigger.realCharacterQuantity, "number", nil, trigger.use_realCharacterQuantity))
      table.insert(cloneChecks, createCloneCheck("capped", nil, trigger.use_capped, "tristate", "(currencyData.quantity or 0) >= (currencyInfo.maxQuantity or 0)"))

      -- Concatenate checkstring-tables into strings
      local quantityCheckString = table.concat(quantityChecks, "\n")
      local tristateCheckString = table.concat(tristateChecks, "\n")
      local cloneCheckString = table.concat(cloneChecks, "\n")

      local ret = [=[return
      function(states)
        local currencyInfo = Private.ExecEnv.GetCurrencyAccountInfo(%d)
        local clone = %s
        local active = true
        local primaryCheckFailed = false
        local activeCharacterGUIDs = {}
        local changed

        -- Insert Quantity-related checks
        %s

        -- Insert Tristate checks
        %s

        local sharedStateValues = {
          name = currencyInfo.name,
          icon = currencyInfo.iconFileID,
          total = currencyInfo.maxQuantity,
          maxQuantity = currencyInfo.maxQuantity,
          progressType = "static",
          accountQuantity = currencyInfo.accountQuantity,
          realAccountQuantity = currencyInfo.realAccountQuantity,
          description = currencyInfo.description,
          quality = currencyInfo.quality,
          discovered = currencyInfo.discovered,
          transferPercentage = currencyInfo.transferPercentage,
          quantityEarnedThisWeek = currencyInfo.quantityEarnedThisWeek,
          totalEarned = currencyInfo.totalEarned,
        }

        if active then
          activeCharacterGUIDs[""] = true
          states[""] = states[""] or {}
          local state = states[""]

          if state.value ~= currencyInfo.quantity or state.realCharacterQuantity ~= currencyInfo.realCharacterQuantity then
            changed = true
            state.changed = true
            state.show = active
            state.value = currencyInfo.quantity
            state.realCharacterQuantity = currencyInfo.realCharacterQuantity
            state.capped = currencyInfo.capped
            state.seasonCapped = currencyInfo.seasonCapped
            state.weeklyCapped = currencyInfo.weeklyCapped
            state.characterName = UnitName("player")
            state.characterGUID = UnitGUID("player")
            state.mainCharacter = true
          end
        end

        -- Create clone states
        if clone and currencyInfo.accountCurrencyData and not primaryCheckFailed then
          for i, currencyData in ipairs(currencyInfo.accountCurrencyData) do
            local cloneActive = true

            -- Insert Clone-specific checks
            %s

            if cloneActive then
              local cloneId = currencyData.characterGUID or tostring(i)
              activeCharacterGUIDs[cloneId] = true
              states[cloneId] = states[cloneId] or {}
              local s = states[cloneId]

              if s.value ~= currencyData.quantity then
                changed = true
                s.changed = true
                s.value = currencyData.quantity
                s.realCharacterQuantity = currencyData.realCharacterQuantity
                s.characterName = currencyData.characterName
                s.characterGUID = currencyData.characterGUID
                s.mainCharacter = false
                s.show = true
              end
            end
          end
        end

        -- Remove inactive states or apply shared values
          for cloneId, state in pairs(states) do
            if not activeCharacterGUIDs[cloneId] then
              state.show = false
              state.changed = true
              changed = true
            else
              for key, value in pairs(sharedStateValues) do
                if state[key] ~= value then
                  state[key] = value
                  state.changed = true
                  changed = true
                end
              end
            end
          end

        return changed
      end
      ]=]

      return ret:format(
        trigger.currencyId or 1,
        trigger.use_clones and "true" or "false",
        quantityCheckString,
        tristateCheckString,
        cloneCheckString
      );
    end,
    statesParameter = "full",
    args = {
      {
        name = "currencyId",
        type = "currency",
        itemControl = "Dropdown-Currency",
        values = Private.GetDiscoveredCurrencies,
        headers = Private.GetDiscoveredCurrenciesHeaders,
        sorted = true,
        sortOrder = function()
          local discovered_currencies_sorted = Private.GetDiscoveredCurrenciesSorted()
          local sortOrder = {}
          for key, value in pairs(Private.GetDiscoveredCurrencies()) do
            tinsert(sortOrder, key)
          end
          table.sort(sortOrder, function(aKey, bKey)
            local aValue = discovered_currencies_sorted[aKey]
            local bValue = discovered_currencies_sorted[bKey]
            return aValue < bValue
          end)
          return sortOrder
        end,
        required = true,
        display = L["Currency"],
        store = true,
        test = "true",
      },
      {
        name = "name",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "value",
        type = "number",
        display = L["Quantity"],
        store = true,
        conditionType = "number",
      },
      {
        name = "total",
        type = "number",
        hidden = true,
        store = true,
        test = "true",
      },
      {
        name = "icon",
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "realCharacterQuantity",
        type = "number",
        display = L["Character Transferred Quantity"],
        desc = L["The total quantity a warband character can transfer after paying the transfer cost"],
        store = true,
        conditionType = "number",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.isAccountTransferable
        end
      },
      {
        name = "accountQuantity",
        type = "number",
        display = L["Warband Quantity Total"],
        store = true,
        conditionType = "number",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.isAccountTransferable
        end
      },
      {
        name = "realAccountQuantity",
        type = "number",
        display = L["Warband Transferred Quantity"],
        desc = L["The total quantity after transferring everything to your current character and paying the transfer cost"],
        store = true,
        conditionType = "number",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.isAccountTransferable
        end
      },
      {
        name = "maxQuantity",
        type = "number",
        display = L["Max Quantity"],
        store = true,
        conditionType = "number",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.maxQuantity and currencyInfo.maxQuantity > 0
        end
      },
      {
        name = "quantityEarnedThisWeek",
        type = "number",
        display = L["Quantity earned this week"],
        store = true,
        conditionType = "number",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.quantityEarnedThisWeek and currencyInfo.quantityEarnedThisWeek > 0
        end,
      },
      {
        name = "totalEarned",
        type = "number",
        display = L["Total Earned in this Season"],
        store = true,
        conditionType = "number",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.useTotalEarnedForMaxQty and currencyInfo.totalEarned and currencyInfo.totalEarned > 0
        end,
      },
      -- Various Capped properties
      {-- quantity / maxQuantity cap
        name = "capped",
        type = "tristate",
        display = L["Capped"],
        store = true,
        conditionType = "bool",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.maxQuantity and currencyInfo.maxQuantity > 0
        end
      },
      {-- "Season" Cap: totalEarned / maxQuantity
        name = "seasonCapped",
        type = "tristate",
        display = L["Capped at Season Max"],
        store = true,
        conditionType = "bool",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.useTotalEarnedForMaxQty == true
        end
      },
      {-- "Weekly" Cap: quantityEarnedThisWeek / maxWeeklyQuantity
        name = "weeklyCapped",
        type = "tristate",
        display = L["Capped at Weekly Max"],
        store = true,
        conditionType = "bool",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.maxWeeklyQuantity and currencyInfo.maxWeeklyQuantity > 0
        end
      },
      {
        name = "description",
        type = "string",
        display = L["Description"],
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "quality",
        type = "number",
        display = L["Quality Id"],
        hidden = true,
        test = "true",
        store = true
      },
      {
        name = "discovered",
        type = "tristate",
        display = L["Discovered"],
        store = true,
        conditionType = "bool",
      },
      {
        name = "transferPercentage",
        type = "number",
        display = L["Warband Transfer Percentage"],
        store = true,
        conditionType = "number",
        hidden = true,
        test = "true",
      },
      {
        name = "characterName",
        type = "string",
        display = L["Character Name"],
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "characterGUID",
        type = "string",
        display = L["Character GUID"],
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "mainCharacter",
        type = "boolean",
        display = L["Main Character"],
        store = true,
        conditionType = "bool",
        hidden = true,
        test = "true",
      },
      {
        name = "clones",
        type = "toggle",
        display = L["Clone per Character"],
        test = "true",
        enable = function(trigger)
          local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
          return currencyInfo and currencyInfo.isAccountTransferable
        end
      },
    },
    GetNameAndIcon = function(trigger)
      local currencyInfo = Private.GetCurrencyInfoForTrigger(trigger)
      return currencyInfo and currencyInfo.name, currencyInfo and currencyInfo.iconFileID
    end,
    automaticrequired = true
  },
  ["Location"] = {
    type = "unit",
    events = {
      ["events"] = {
        "ZONE_CHANGED",
        "ZONE_CHANGED_INDOORS",
        "ZONE_CHANGED_NEW_AREA",
        "PLAYER_DIFFICULTY_CHANGED",
        "WA_DELAYED_PLAYER_ENTERING_WORLD"
      }
    },
    internal_events = {"INSTANCE_LOCATION_CHECK"},
    force_events = "INSTANCE_LOCATION_CHECK",
    name = WeakAuras.newFeatureString..L["Location"],
    init = function(trigger)
      local ret = [=[
        local uiMapId = C_Map.GetBestMapForUnit("player")
        local zonegroupId = uiMapId and C_Map.GetMapGroupID(uiMapId)
        local instanceName, _, _, _, _, _, _, instanceId = GetInstanceInfo()
        local minimapZoneText = GetMinimapZoneText()
        local zoneText = GetZoneText()
      ]=]
      return ret
    end,
    statesParameter = "one",
    args = {
      {
        name = "zoneIds",
        display = L["Player Location ID(s)"],
        type = "string",
        multiline = true,
        desc = get_zoneId_list,
        preamble = "local zoneChecker = Private.ExecEnv.ParseZoneCheck(%q)",
        test = "zoneChecker:Check(uiMapId, zonegroupId, instanceId, minimapZoneText)",
        conditionType = "string",
        conditionPreamble = function(input)
          return Private.ExecEnv.ParseZoneCheck(input)
        end,
        conditionTest = function(state, needle, op, preamble)
          return preamble:Check(state.zoneId, state.zonegroupId, state.instanceId, state.subzone)
        end,
        operator_types = "none",
      },
      {
        name = "zoneId",
        display = L["Zone ID"],
        init = "uiMapId",
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "zonegroupId",
        display = L["Zone Group ID"],
        init = "zonegroupId",
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "zone",
        display = L["Zone Name"],
        type = "string",
        conditionType = "string",
        store = true,
        init = "zoneText",
        multiEntry = {
          operator = "or",
        }
      },
      {
        name = "subzone",
        display = L["Subzone Name"],
        desc = L["Name of the (sub-)zone currently shown above the minimap."],
        type = "string",
        conditionType = "string",
        store = true,
        init = "minimapZoneText",
        multiEntry = {
          operator = "or",
        },
      },
      {
        type = "header",
        name = "instanceHeader",
        display = L["Instance Info"],
      },
      {
        name = "instanceId",
        display = L["Instance ID"],
        init = "instanceId",
        store = true,
        hidden = true,
        test = "true",
      },
      {
        name = "instance",
        display = L["Instance Name"],
        test = "true",
        hidden = "true",
        store = true,
      },
      {
        name = "instanceSize",
        display = L["Instance Size Type"],
        type = "multiselect",
        values = "instance_types",
        sorted = true,
        init = "WeakAuras.InstanceType()",
        conditionType = "select",
        store = true,
      },
      {
        name = "instanceDifficulty",
        display = L["Instance Difficulty"],
        type = "multiselect",
        values = "difficulty_types",
        init = "WeakAuras.InstanceDifficulty()",
        conditionType = "select",
        store = true,
        enable = not WeakAuras.IsClassicEra(),
        hidden = WeakAuras.IsClassicEra(),
      },
      {
        name = "instanceType",
        display = L["Instance Type"],
        type = "multiselect",
        values = "instance_difficulty_types",
        init = "WeakAuras.InstanceTypeRaw()",
        conditionType = "select",
        store = true,
        enable = not WeakAuras.IsClassicEra(),
        hidden = WeakAuras.IsClassicEra(),
      },
    },
    automaticrequired = true,
    progressType = "none"
  },
};

if C_AssistedCombat and C_AssistedCombat.GetNextCastSpell then
  Private.event_prototypes["Assisted Combat Next Cast"] = {
    type = "spell",
    events = { "SPELLS_CHANGED"},
    loadFunc = function()
      WeakAuras.WatchForAssistedCombatNextCast()
    end,
    internal_events = { "WA_ASSISTED_COMBAT_NEXT_CAST" },
    force_events = "WA_ASSISTED_COMBAT_NEXT_CAST",
    name = L["Assisted Combat Next Cast"],
    statesParameter = "one",
    args = {
      {
        name = "spellNames",
        display = L["Name(s)"],
        type = "spell",
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddName(%q)"
        },
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        preambleGroup = "spell",
        test = "spellChecker:Check(spellId)",
        noValidation = true,
      },
      {
        name = "spellId",
        display = L["Exact Spell ID(s)"],
        type = "spell",
        init = "C_AssistedCombat.GetNextCastSpell()",
        store = true,
        multiEntry = {
          operator = "preamble",
          preambleAdd = "spellChecker:AddExact(%q)"
        },
        preamble = "local spellChecker = Private.ExecEnv.CreateSpellChecker()",
        preambleGroup = "spell",
        test = "spellChecker:Check(spellId)",
        conditionType = "number",
        noProgressSource = true,
        operator_types = "only_equal"
      },
      {
        name = "icon",
        hidden = true,
        init = "Private.ExecEnv.GetSpellIcon(spellId or 0)",
        store = true,
        test = "true"
      },
      {
        name = "name",
        hidden = true,
        init = "Private.ExecEnv.GetSpellName(spellId or 0)",
        store = true,
        test = "true"
      },
    },
    automaticrequired = true,
    progressType = "static"
  }
end

if WeakAuras.IsClassicEra() then
  Private.event_prototypes["Death Knight Rune"] = nil
  Private.event_prototypes["Currency"] = nil
  Private.event_prototypes["Alternate Power"] = nil
  Private.event_prototypes["Spell Activation Overlay"] = nil
end
if WeakAuras.IsCataOrMists() then
  Private.event_prototypes["Swing Timer"] = nil
end
if WeakAuras.IsClassicOrCata() then
  if not UnitDetailedThreatSituation then
    Private.event_prototypes["Threat Situation"] = nil
  end
  Private.event_prototypes["Evoker Essence"] = nil
  Private.event_prototypes["Equipment Set"] = nil
  Private.event_prototypes["PvP Talent Selected"] = nil
  Private.event_prototypes["Class/Spec"] = nil
  Private.event_prototypes["Loot Specialization"] = nil
end
if WeakAuras.IsMists() then
  Private.event_prototypes["Evoker Essence"] = nil
  Private.event_prototypes["PvP Talent Selected"] = nil
  Private.event_prototypes["Loot Specialization"] = nil
end
if WeakAuras.IsRetail() then
  Private.event_prototypes["Queued Action"] = nil
end

Private.category_event_prototype = {}
for name, prototype in pairs(Private.event_prototypes) do
  Private.category_event_prototype[prototype.type] = Private.category_event_prototype[prototype.type] or {}
  Private.category_event_prototype[prototype.type][name] = prototype.name
end

Private.dynamic_texts = {
  ["p"] = {
    get = function(state)
      if not state then return nil end
      if state.progressType == "static" then
        return state.value or nil
      end
      if state.progressType == "timed" then
        if state.paused then
          return state.remaining and state.remaining >= 0 and state.remaining or nil
        end

        if not state.expirationTime or not state.duration then
          return nil
        end
        local remaining = state.expirationTime - GetTime();
        return remaining >= 0 and remaining or nil
      end
    end,
    func = function(remaining, state, progressPrecision)
      progressPrecision = progressPrecision or 1

      if not state or state.progressType ~= "timed" then
        return remaining
      end
      if type(remaining) ~= "number" then
        return ""
      end

      local remainingStr = "";
      if remaining == math.huge then
        remainingStr = " ";
      elseif remaining > 60 then
        remainingStr = string.format("%i:", math.floor(remaining / 60));
        remaining = remaining % 60;
        remainingStr = remainingStr..string.format("%02i", remaining);
      elseif remaining > 0 then
        if progressPrecision == 4 and remaining <= 3 then
          remainingStr = remainingStr..string.format("%.1f", remaining);
        elseif progressPrecision == 5 and remaining <= 3 then
          remainingStr = remainingStr..string.format("%.2f", remaining);
        elseif progressPrecision == 6 and remaining <= 3 then
          remainingStr = remainingStr..string.format("%.3f", remaining);
        elseif (progressPrecision == 4 or progressPrecision == 5 or progressPrecision == 6) and remaining > 3 then
          remainingStr = remainingStr..string.format("%d", remaining);
        else
          remainingStr = remainingStr..string.format("%.".. progressPrecision .."f", remaining);
        end
      else
        remainingStr = " ";
      end
      return remainingStr
    end
  },
  ["t"] = {
    get = function(state)
      if not state then return "" end
      if state.progressType == "static" then
        return state.total, false
      end
      if state.progressType == "timed" then
        if not state.duration then
          return nil
        end
        return state.duration, true
      end
    end,
    func = function(duration, state, totalPrecision)
      if not state or state.progressType ~= "timed" then
        return duration
      end
      if type(duration) ~= "number" then
        return ""
      end
      local durationStr = "";
      if math.abs(duration) == math.huge or tostring(duration) == "nan" then
        durationStr = " ";
      elseif duration > 60 then
        durationStr = string.format("%i:", math.floor(duration / 60));
        duration = duration % 60;
        durationStr = durationStr..string.format("%02i", duration);
      elseif duration > 0 then
        if totalPrecision == 4 and duration <= 3 then
          durationStr = durationStr..string.format("%.1f", duration);
        elseif totalPrecision == 5 and duration <= 3 then
          durationStr = durationStr..string.format("%.2f", duration);
        elseif totalPrecision == 6 and duration <= 3 then
          durationStr = durationStr..string.format("%.3f", duration);
        elseif (totalPrecision == 4 or totalPrecision == 5 or totalPrecision == 6) and duration > 3 then
          durationStr = durationStr..string.format("%d", duration);
        else
          durationStr = durationStr..string.format("%."..totalPrecision.."f", duration);
        end
      else
        durationStr = " ";
      end
      return durationStr
    end
  },
  ["n"] = {
    get = function(state)
      if not state then return "" end
      return state.name or state.id or "", true
    end,
    func = function(v)
      return v
    end
  },
  ["i"] = {
    get = function(state)
      if not state then return "" end
      return state.icon or "Interface\\Icons\\INV_Misc_QuestionMark"
    end,
    func = function(v)
      return "|T".. v ..":12:12:0:0:64:64:4:60:4:60|t"
    end
  },
  ["s"] = {
    get = function(state)
      if not state or state.stacks == 0 then return "" end
      return state.stacks
    end,
    func = function(v)
      return v
    end
  }
};

-- Events in that list can be filtered by unitID
Private.UnitEventList = {
  PLAYER_GUILD_UPDATE = true,
  MINIMAP_PING = true,
  PARTY_MEMBER_DISABLE = true,
  PARTY_MEMBER_ENABLE = true,
  READY_CHECK_CONFIRM = true,
  PLAYER_GAINS_VEHICLE_DATA = true,
  PLAYER_LOSES_VEHICLE_DATA = true,
  ARENA_COOLDOWNS_UPDATE = true,
  ARENA_CROWD_CONTROL_SPELL_UPDATE = true,
  HONOR_XP_UPDATE = true,
  INCOMING_RESURRECT_CHANGED = true,
  INCOMING_SUMMON_CHANGED = true,
  KNOWN_TITLES_UPDATE = true,
  PLAYER_DAMAGE_DONE_MODS = true,
  PLAYER_FLAGS_CHANGED = true,
  PLAYER_PVP_KILLS_CHANGED = true,
  PLAYER_PVP_RANK_CHANGED = true,
  PLAYER_SPECIALIZATION_CHANGED = true,
  PLAYER_TRIAL_XP_UPDATE = true,
  PLAYER_XP_UPDATE = true,
  PVP_TIMER_UPDATE = true
}

Private.InternalEventByIDList = {
  ITEM_COOLDOWN_STARTED = true,
  ITEM_COOLDOWN_CHANGED = true,
  ITEM_COOLDOWN_READY = true,
  ITEM_SLOT_COOLDOWN_STARTED = true,
  ITEM_SLOT_COOLDOWN_CHANGED = true,
  ITEM_SLOT_COOLDOWN_READY = true,
  ITEM_SLOT_COOLDOWN_ITEM_CHANGED = true,
  SPELL_COOLDOWN_CHANGED = true,
  SPELL_COOLDOWN_READY = true,
  SPELL_CHARGES_CHANGED = true,
  WA_UPDATE_OVERLAY_GLOW = true,
}


-- ========================================
-- File: WeakAuras/RegionTypes/AuraBar.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- Default settings
local default = {
  icon = false,
  desaturate = false,
  iconSource = -1,
  progressSource = {-1, "" },
  adjustedMax = "",
  adjustedMin = "",
  texture = "Blizzard",
  textureSource = "LSM",
  width = 200,
  height = 15,
  orientation = "HORIZONTAL",
  inverse = false,
  barColor = {1.0, 0.0, 0.0, 1.0},
  barColor2 = {1.0, 1.0, 0.0, 1.0},
  enableGradient = false,
  gradientOrientation = "HORIZONTAL",
  backgroundColor = {0.0, 0.0, 0.0, 0.5},
  spark = false,
  sparkWidth = 10,
  sparkHeight = 30,
  sparkColor = {1.0, 1.0, 1.0, 1.0},
  sparkTexture = "Interface\\CastingBar\\UI-CastingBar-Spark",
  sparkBlendMode = "ADD",
  sparkOffsetX = 0,
  sparkOffsetY = 0,
  sparkRotationMode = "AUTO",
  sparkRotation = 0,
  sparkHidden = "NEVER",
  selfPoint = "CENTER",
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  icon_side = "RIGHT",
  icon_color = {1.0, 1.0, 1.0, 1.0},
  frameStrata = 1,
  zoom = 0
};

Private.regionPrototype.AddProgressSourceToDefault(default)
Private.regionPrototype.AddAlphaToDefault(default);

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;

local properties = {
  textureSource = {
    display = {L["Bar Texture"], L["Selection Mode"]},
    setter = "SetStatusBarTextureMode",
    type = "list",
    values = {
      LSM = L["LibSharedMedia"],
      Picker = L["Texture Picker"]
    }
  },
  textureInput = {
    display = {L["Bar Texture"], L["Texture Picker"]},
    setter = "SetStatusBarTextureInput",
    type = "texture",
  },
  texture = {
    display = {L["Bar Texture"], L["LibSharedMedia"]},
    setter = "SetStatusBarTextureLSM",
    type = "textureLSM",
  },
  barColor = {
    display = L["Bar Color/Gradient Start"],
    setter = "Color",
    type = "color",
  },
  barColor2 = {
    display = L["Gradient End"],
    setter = "SetBarColor2",
    type = "color",
  },
  gradientOrientation = {
    display = L["Gradient Orientation"],
    setter = "SetGradientOrientation",
    type = "list",
    values = Private.gradient_orientations
  },
  enableGradient = {
    display = L["Gradient Enabled"],
    setter = "SetGradientEnabled",
    type = "bool",
  },
  icon_visible = {
    display = {L["Icon"], L["Visibility"]},
    setter = "SetIconVisible",
    type = "bool"
  },
  icon_color = {
    display = {L["Icon"], L["Color"]},
    setter = "SetIconColor",
    type = "color"
  },
  iconSource = {
    display = {L["Icon"], L["Source"]},
    setter = "SetIconSource",
    type = "list",
    values = {}
  },
  displayIcon = {
    display = {L["Icon"], L["Manual"]},
    setter = "SetIcon",
    type = "icon",
  },
  desaturate = {
    display = {L["Icon"], L["Desaturate"]},
    setter = "SetIconDesaturated",
    type = "bool",
  },
  backgroundColor = {
    display = L["Background Color"],
    setter = "SetBackgroundColor",
    type = "color"
  },
  sparkColor = {
    display = {L["Spark"], L["Color"]},
    setter = "SetSparkColor",
    type = "color"
  },
  sparkHeight = {
    display = {L["Spark"], L["Height"]},
    setter = "SetSparkHeight",
    type = "number",
    min = 1,
    softMax = screenHeight,
    bigStep = 1
  },
  sparkWidth = {
    display = {L["Spark"], L["Width"]},
    setter = "SetSparkWidth",
    type = "number",
    min = 1,
    softMax = screenWidth,
    bigStep = 1
  },
  width = {
    display = L["Width"],
    setter = "SetRegionWidth",
    type = "number",
    min = 1,
    softMax = screenWidth,
    bigStep = 1,
    default = 32,
  },
  height = {
    display = L["Height"],
    setter = "SetRegionHeight",
    type = "number",
    min = 1,
    softMax = screenHeight,
    bigStep = 1,
    default = 32
  },
  orientation = {
    display = L["Orientation"],
    setter = "SetOrientation",
    type = "list",
    values = Private.orientation_types
  },
  inverse = {
    display = L["Inverse"],
    setter = "SetInverse",
    type = "bool"
  },
};

Private.regionPrototype.AddProperties(properties, default);

local function GetProperties(data)
  local overlayInfo = Private.GetOverlayInfo(data);
  local auraProperties = CopyTable(properties)
  if (overlayInfo and next(overlayInfo)) then
    for id, display in ipairs(overlayInfo) do
      auraProperties["overlays." .. id] = {
        display = string.format(L["%s Overlay Color"], display),
        setter = "SetOverlayColor",
        arg1 = id,
        type = "color",
      }
    end
  end

  auraProperties.iconSource.values = Private.IconSources(data)
  auraProperties.progressSource.values = Private.GetProgressSourcesForUi(data)
  return auraProperties;
end

-- Returns tex Coord for 90 rotations + x or y flip

local texCoords = {
  0, 0, 1, 1,
  0, 0, 1, 1,
  0, 0, 1, 1
};

-- only supports multipliers of 90 degree
-- returns in order: TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy
local GetTexCoordSpark = function(degree, mirror)
  local offset = (degree or 0) / 90
  local TLx,  TLy = texCoords[2 + offset], texCoords[1 + offset]
  local TRx,  TRy = texCoords[3 + offset], texCoords[2 + offset]
  local BLx,  BLy = texCoords[1 + offset], texCoords[4 + offset]
  local BRx,  BRy = texCoords[4 + offset], texCoords[3 + offset]

  if (mirror) then
    TLx, TRx = TRx, TLx
    TLy, TRy = TRy, TLy
    BLx, BRx = BRx, BLx
    BLy, BRy = BRy, BLy
  end

  return TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy
end

local GetTexCoordFunctions =
  {
    ["HORIZONTAL"] = function(startProgress, endProgress)
      local TLx,  TLy = startProgress, 0;
      local TRx,  TRy = endProgress, 0;
      local BLx,  BLy = startProgress, 1;
      local BRx,  BRy = endProgress, 1;
      return TLx, TLy, BLx, BLy, TRx, TRy, BRx, BRy;
    end,
    ["HORIZONTAL_INVERSE"] = function(startProgress, endProgress)
      local TLx,  TLy = endProgress, 0;
      local TRx,  TRy = startProgress, 0;
      local BLx,  BLy = endProgress, 1;
      local BRx,  BRy = startProgress, 1;
      return TLx, TLy, BLx, BLy, TRx, TRy, BRx, BRy;
    end,
    ["VERTICAL"] = function(startProgress, endProgress)
      local TLx,  TLy = startProgress, 1;
      local TRx,  TRy = startProgress, 0;
      local BLx,  BLy = endProgress, 1;
      local BRx,  BRy = endProgress, 0;
      return TLx, TLy, BLx, BLy, TRx, TRy, BRx, BRy;
    end,
    ["VERTICAL_INVERSE"] = function(startProgress, endProgress)
      local TLx,  TLy = endProgress, 0;
      local TRx,  TRy = endProgress, 1;
      local BLx,  BLy = startProgress, 0;
      local BRx,  BRy = startProgress, 1;
      return TLx, TLy, BLx, BLy, TRx, TRy, BRx, BRy;
    end
  }

local anchorAlignment = {
  ["HORIZONTAL"] = { "TOPLEFT", "BOTTOMLEFT", "RIGHT" },
  ["HORIZONTAL_INVERSE"] = { "TOPRIGHT", "BOTTOMRIGHT", "LEFT" },
  ["VERTICAL"] = { "TOPLEFT", "TOPRIGHT", "BOTTOM" },
  ["VERTICAL_INVERSE"] = { "BOTTOMLEFT", "BOTTOMRIGHT", "TOP" }
}

local extraTextureWrapMode = "REPEAT";

-- Emulate blizzard statusbar with advanced features (more grow directions)
local barPrototype = {
  ["UpdateAnchors"] = function(self)
    -- Do not flip/rotate textures
    local orientation = self.orientation;
    if not self.rotate then
      if orientation == "HORIZONTAL_INVERSE" then
        orientation = "HORIZONTAL";
      elseif orientation == "VERTICAL_INVERSE" then
        orientation = "VERTICAL";
      end
    end

    self.GetTexCoord = GetTexCoordFunctions[orientation];
    local anchorAlignment = anchorAlignment[orientation];
    self.align1 = anchorAlignment[1];
    self.align2 = anchorAlignment[2];
    self.alignSpark = anchorAlignment[3];

    self.horizontal = (self.orientation == "HORIZONTAL_INVERSE") or (self.orientation == "HORIZONTAL")
    self.directionInverse = (self.orientation == "HORIZONTAL_INVERSE") or (self.orientation == "VERTICAL")

    local TLx,  TLy,  BLx,  BLy,  TRx,  TRy,  BRx,  BRy = self.GetTexCoord(0, 1);
    self.bg:SetTexCoord(TLx, TLy, BLx, BLy, TRx, TRy, BRx, BRy)
    self.fg:SetTexCoord(TLx, TLy, BLx, BLy, TRx, TRy, BRx, BRy)

    -- Set alignment
    self.fgMask:ClearAllPoints()
    self.fgMask:SetPoint(self.align1, self, self.align1)
    self.fgMask:SetPoint(self.align2, self, self.align2)

    self.spark:SetPoint("CENTER", self.fgMask, self.alignSpark, self.spark.sparkOffsetX or 0, self.spark.sparkOffsetY or 0);

    local sparkMirror = self.spark.sparkMirror;
    local sparkRotationMode = self.spark.sparkRotationMode;
    local sTLx, sTLy, sBLx, sBLy, sTRx, sTRy, sBRx, sBRy; -- spark rotation
    if (sparkRotationMode == "AUTO") then
      sTLx, sTLy, sBLx, sBLy, sTRx, sTRy, sBRx, sBRy = TLx, TLy, BLx, BLy, TRx, TRy, BRx, BRy;
    else
      local sparkRotation = tonumber(self.spark.sparkRotation);
      sTLx, sTLy, sTRx, sTRy, sBLx, sBLy, sBRx, sBRy = GetTexCoordSpark(sparkRotation, sparkMirror)
    end
    self.spark:SetTexCoord(sTLx , sTLy , sBLx , sBLy , sTRx , sTRy , sBRx , sBRy);
  end,

  ["UpdateProgress"] = function(self)
    -- Limit values
    local value = self.value;
    value = math.max(self.min, value);
    value = math.min(self.max, value);

    -- Alignment variables
    local progress = (value - self.min) / (self.max - self.min);

    -- Create statusbar illusion
    if (self.horizontal) then
      local xProgress = self:GetRealSize() * progress;
      local show = xProgress > 0.0001
      self.fgMask:SetWidth(show and (xProgress + 0.1) or 0.1);
      if show then
        self.fg:Show()
      else
        self.fg:Hide()
      end
    else
      local yProgress = select(2, self:GetRealSize()) * progress;
      local show = yProgress > 0.0001
      self.fgMask:SetHeight(show and (yProgress + 0.1) or 0.1);
      if show then
        self.fg:Show()
      else
        self.fg:Hide()
      end
    end

    local sparkHidden = self.spark.sparkHidden;
    local sparkVisible = sparkHidden == "NEVER"
      or (sparkHidden == "FULL" and progress < 1)
      or (sparkHidden == "EMPTY" and progress > 0)
      or (sparkHidden == "BOTH" and progress < 1 and progress > 0);

    if (sparkVisible) then
      self.spark:Show();
    else
      self.spark:Hide();
    end
  end,

  ["UpdateAdditionalBars"] = function(self)
    if (type(self.additionalBars) == "table") then
      for index, additionalBar in ipairs(self.additionalBars) do
        if (not self.extraTextures[index]) then
          local extraTexture = self:CreateTexture(nil, "ARTWORK");
          extraTexture:SetTexelSnappingBias(0)
          extraTexture:SetDrawLayer("ARTWORK", min(index, 7));
          self.extraTextures[index] = extraTexture;
        end

        local extraTexture = self.extraTextures[index];

        local valueStart = self.additionalBarsMin
        local valueWidth = self.additionalBarsMax - valueStart;

        local startProgress = 0;
        local endProgress = 0;

        if (additionalBar.min and additionalBar.max) then
          if (valueWidth ~= 0) then
            startProgress = (additionalBar.min - valueStart) / valueWidth;
            endProgress = (additionalBar.max - valueStart) / valueWidth;

            if (self.additionalBarsInverse) then
              startProgress = 1 - startProgress;
              endProgress = 1 - endProgress;
            end
          end
        elseif (additionalBar.direction) then
          local forwardDirection = (additionalBar.direction or "forward") == "forward";
          if (self.additionalBarsInverse) then
            forwardDirection = not forwardDirection;
          end

          local width = additionalBar.width or 0;
          local offset = additionalBar.offset or 0;

          if (width ~= 0 and valueWidth ~= 0) then
            if (forwardDirection) then
              startProgress = self.value + offset / valueWidth;
              endProgress = self.value + (width + offset) / valueWidth;
            else
              startProgress = self.value - (width + offset) / valueWidth;
              endProgress = self.value - offset / valueWidth;
            end
          end
        end

        if (self.additionalBarsClip) then
          startProgress = max(0, min(1, startProgress));
          endProgress = max(0, min(1, endProgress));
        else
          startProgress = max(-10, min(11, startProgress));
          endProgress = max(-10, min(11, endProgress));
        end

        if ((endProgress - startProgress) == 0) then
          extraTexture:Hide();
        else
          extraTexture:Show();
          local TLx_, TLy_, BLx_, BLy_, TRx_, TRy_, BRx_, BRy_ = self.GetTexCoord(startProgress, endProgress);
          extraTexture:SetTexCoord(TLx_, TLy_, BLx_, BLy_, TRx_, TRy_, BRx_, BRy_);

          local color = self.additionalBarsColors and self.additionalBarsColors[index];
          if (color) then
            extraTexture:SetVertexColor(unpack(color));
          else
            extraTexture:SetVertexColor(1, 1, 1, 1);
          end

          local texture = self.additionalBarsTextures and self.additionalBarsTextures[index];
          if texture then
            local texturePath = SharedMedia:Fetch("statusbar_atlas", texture, true) or SharedMedia:Fetch("statusbar", texture) or ""
            Private.SetTextureOrAtlas(extraTexture, texturePath, extraTextureWrapMode, extraTextureWrapMode)
          else
            Private.SetTextureOrAtlas(extraTexture, self:GetStatusBarTexture(), extraTextureWrapMode, extraTextureWrapMode)
          end

          local xOffset = 0;
          local yOffset = 0;
          local width, height = self:GetRealSize()
          if (self.horizontal) then
            xOffset = startProgress * width;
            local width = (endProgress - startProgress) * width;
            extraTexture:SetWidth( width  );
            extraTexture:SetHeight( height );
          else
            yOffset = startProgress * height;
            local height = (endProgress - startProgress) * height;
            extraTexture:SetWidth( width );
            extraTexture:SetHeight( height );
          end

          if (self.directionInverse) then
            xOffset = -xOffset;
            yOffset = -yOffset;
          end

          extraTexture:ClearAllPoints();
          extraTexture:SetPoint(self.align1, self, self.align1, xOffset, yOffset);
          extraTexture:SetPoint(self.align2, self, self.align2, xOffset, yOffset);
        end
      end

      if (#self.additionalBars < #self.extraTextures) then
        for i = #self.additionalBars + 1, #self.extraTextures do
          self.extraTextures[i]:Hide();
        end
      end
    else
      for i = 1, #self.extraTextures do
        self.extraTextures[i]:Hide();
      end
    end
  end,
  ["Update"] = function(self)
    self:UpdateAnchors();
    self:UpdateProgress();
    self:UpdateAdditionalBars();
  end,

  -- Need to update progress!
  ["OnSizeChanged"] = function(self, width, height)
    self:UpdateProgress();
    self:UpdateAdditionalBars();
    self:GetParent().subRegionEvents:Notify("OnRegionSizeChanged")
  end,

  -- Blizzard like SetMinMaxValues
  ["SetMinMaxValues"] = function(self, minVal, maxVal)
    local update = false;
    if minVal and type(minVal) == "number" then
      self.min = minVal;
      update = true;
    end

    if maxVal and type(maxVal) == "number" then
      self.max = maxVal;
      update = true;
    end

    if update then
      self:UpdateProgress();
      self:UpdateAdditionalBars();
    end
  end,

  ["GetMinMaxValues"] = function(self)
    return self.min, self.max
  end,

  -- Blizzard like SetValue
  ["SetValue"] = function(self, value)
    if value and type(value) == "number" then
      self.value = value;
      self:UpdateProgress();
      self:UpdateAdditionalBars();
    end
  end,

  ["SetAdditionalBars"] = function(self, additionalBars, colors, textures, min, max, inverse, overlayclip)
    self.additionalBars = additionalBars;
    self.additionalBarsColors = colors;
    self.additionalBarsTextures = textures;
    self.additionalBarsMin = min or 0;
    self.additionalBarsMax = max or 0;
    self.additionalBarsInverse = inverse;
    self.additionalBarsClip = overlayclip;
    self:UpdateAdditionalBars();
  end,

  ["GetAdditionalBarsInverse"] = function(self)
    return self.additionalBarsInverse
  end,

  ["SetAdditionalBarsInverse"] = function(self, value)
    self.additionalBarsInverse = value;
    self:UpdateAdditionalBars();
  end,

  ["SetAdditionalBarColor"] = function(self, id, color)
    self.additionalBarsColors[id] = color;
    if self.extraTextures[id] then
      self.extraTextures[id]:SetVertexColor(unpack(color));
    end
  end,

  ["GetValue"] = function(self)
    return self.value;
  end,

  -- Blizzard like SetOrientation (added: HORIZONTAL_INVERSE, VERTICAL_INVERSE)
  ["SetOrientation"] = function(self, orientation)
    if orientation == "HORIZONTAL"
      or orientation == "HORIZONTAL_INVERSE"
      or orientation == "VERTICAL"
      or orientation == "VERTICAL_INVERSE"
    then
      self.orientation = orientation;
      self:Update();
    end
  end,

  ["GetOrientation"] = function(self)
    return self.orientation;
  end,

  -- Blizzard like SetRotatesTexture (added: flip texture for right->left, bottom->top)
  ["SetRotatesTexture"] = function(self, rotate)
    if rotate and type(rotate) == "boolean" then
      self.rotate = rotate;
      self:Update();
    end
  end,

  ["GetRotatesTexture"] = function(self)
    return self.rotate;
  end,

  -- Blizzard like SetStatusBarTexture
  ["SetStatusBarTexture"] = function(self, texture)
    Private.SetTextureOrAtlas(self.fg, texture)
    Private.SetTextureOrAtlas(self.bg, texture)
    for index, extraTexture in ipairs(self.extraTextures) do
      Private.SetTextureOrAtlas(extraTexture, texture, extraTextureWrapMode, extraTextureWrapMode)
    end
  end,

  ["GetStatusBarTexture"] = function(self)
    return self.fg:GetAtlas() or self.fg:GetTexture()
  end,

  -- Set bar color
  ["SetForegroundColor"] = function(self, r, g, b, a)
    self.fg:SetVertexColor(r, g, b, a);
  end,

  ["SetForegroundGradient"] = function(self, orientation, r1, g1, b1, a1, r2, g2, b2, a2)
    if self.fg.SetGradientAlpha then
      self.fg:SetGradientAlpha(orientation, r1, g1, b1, a1, r2, g2, b2, a2)
    else
      self.fg:SetGradient(orientation, CreateColor(r1, g1, b1, a1),
                                       CreateColor(r2, g2, b2, a2))
    end
  end,

  -- Set background color
  ["SetBackgroundColor"] = function(self, r, g, b, a)
    self.bg:SetVertexColor(r, g, b, a);
  end,

  -- Convenience methods
  ["SetTexture"] = function(self, texture)
    self:SetStatusBarTexture(texture);
  end,

  ["GetTexture"] = function(self)
    return self:GetStatusBarTexture();
  end,

  ["SetVertexColor"] = function(self, r, g, b, a)
    self:SetForegroundColor(r, g, b, a);
  end,

  ["GetRealSize"] = function(self)
    return 0, 0
  end,

  -- Internal variables
  ["min"] = 0,
  ["max"] = 1,
  ["value"] = 0.5,
  ["rotate"] = true,
  ["orientation"] = "HORIZONTAL",
}

local GetRealSize = {
  ["HORIZONTAL"] = {
    [true] = function(self)
      return self.totalWidth - self.iconWidth, self.totalHeight
    end,
    [false] = function(self)
      return self.totalWidth, self.totalHeight
    end
  },
  ["VERTICAL"] = {
    [true] = function(self)
      return self.totalWidth, self.totalHeight - self.iconHeight
    end,
    [false] = function(self)
      return self.totalWidth, self.totalHeight
    end
  },
}

-- Orientation helper methods
local function orientHorizontalInverse(region)
  -- Localize
  local bar, icon = region.bar, region.icon;

  -- Reset
  icon:ClearAllPoints();
  bar:ClearAllPoints();

  bar.GetRealSize = GetRealSize["HORIZONTAL"][region.iconVisible or false]

  -- Align icon and bar
  if region.iconVisible then
    if region.icon_side == "LEFT" then
      icon:SetPoint("LEFT", region, "LEFT");
      bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
      bar:SetPoint("TOPLEFT", icon, "TOPRIGHT");
    else
      icon:SetPoint("RIGHT", region, "RIGHT");
      bar:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT");
      bar:SetPoint("TOPRIGHT", icon, "TOPLEFT");
    end
  else
    bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
    bar:SetPoint("TOPLEFT", region, "TOPLEFT");
  end

  -- Save orientation
  bar:SetOrientation(region.effectiveOrientation);
end

local function orientHorizontal(region)
  -- Localize
  local bar, icon = region.bar, region.icon;

  bar.GetRealSize = GetRealSize["HORIZONTAL"][region.iconVisible or false]

  -- Reset
  icon:ClearAllPoints();
  bar:ClearAllPoints();

  -- Align icon and bar
  if region.iconVisible then
    if region.icon_side == "LEFT" then
      icon:SetPoint("LEFT", region, "LEFT");
      bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
      bar:SetPoint("TOPLEFT", icon, "TOPRIGHT");
    else
      icon:SetPoint("RIGHT", region, "RIGHT");
      bar:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT");
      bar:SetPoint("TOPRIGHT", icon, "TOPLEFT");
    end
  else
    bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
    bar:SetPoint("TOPLEFT", region, "TOPLEFT");
  end

  -- Save orientation
  bar:SetOrientation(region.effectiveOrientation);
end

local function orientVerticalInverse(region)
  -- Localize
  local bar, icon = region.bar, region.icon;

  bar.GetRealSize = GetRealSize["VERTICAL"][region.iconVisible or false]

  -- Reset
  icon:ClearAllPoints();
  bar:ClearAllPoints();

  -- Align icon and bar
  if region.iconVisible then
    if region.icon_side == "LEFT" then
      icon:SetPoint("TOP", region, "TOP");
      bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
      bar:SetPoint("TOPLEFT", icon, "BOTTOMLEFT");
    else
      icon:SetPoint("BOTTOM", region, "BOTTOM");
      bar:SetPoint("TOPRIGHT", region, "TOPRIGHT");
      bar:SetPoint("BOTTOMLEFT", icon, "TOPLEFT");
    end
  else
    bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
    bar:SetPoint("TOPLEFT", region, "TOPLEFT");
  end

  -- Save orientation
  bar:SetOrientation("VERTICAL_INVERSE");
end

local function orientVertical(region)
  -- Localize
  local bar, icon = region.bar, region.icon;

  bar.GetRealSize = GetRealSize["VERTICAL"][region.iconVisible or false]

  -- Reset
  icon:ClearAllPoints();
  bar:ClearAllPoints();

  -- Align icon and bar
  if region.iconVisible then
    if region.icon_side == "LEFT" then
      icon:SetPoint("TOP", region, "TOP");
      bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
      bar:SetPoint("TOPLEFT", icon, "BOTTOMLEFT");
    else
      icon:SetPoint("BOTTOM", region, "BOTTOM");
      bar:SetPoint("TOPRIGHT", region, "TOPRIGHT");
      bar:SetPoint("BOTTOMLEFT", icon, "TOPLEFT");
    end
  else
    bar:SetPoint("BOTTOMRIGHT", region, "BOTTOMRIGHT");
    bar:SetPoint("TOPLEFT", region, "TOPLEFT");
  end

  -- Save orientation
  bar:SetOrientation("VERTICAL");
end

local function GetTexCoordZoom(texWidth)
  local texCoord = {texWidth, texWidth, texWidth, 1 - texWidth, 1 - texWidth, texWidth, 1 - texWidth, 1 - texWidth}
  return unpack(texCoord)
end

local function FrameTick(self)
  local expirationTime = self.expirationTime
  local remaining = expirationTime - GetTime()
  local duration = self.duration
  local progress = duration ~= 0 and remaining / duration or 0;
  if self.inverse then
    progress = 1 - progress;
  end
  self:SetProgress(progress)
end

local funcs = {
  AnchorSubRegion = function(self, subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
    if anchorPoint:sub(1, 4) == "sub." then
      Private.regionPrototype.AnchorSubRegion(self, subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
      return
    end
    if anchorType == "area" then
      local anchor = self

      if anchorPoint == "bar" then
        anchor = self
      elseif anchorPoint == "icon" then
        anchor = self.icon
      elseif anchorPoint == "fg" then
        anchor = self.bar.fgMask
      elseif anchorPoint == "bg" then
        anchor = self.bar.bg
      end

      anchorXOffset = anchorXOffset or 0
      anchorYOffset = anchorYOffset or 0
      subRegion:ClearAllPoints()
      subRegion:SetPoint("bottomleft", anchor, "bottomleft", -anchorXOffset, -anchorYOffset)
      subRegion:SetPoint("topright", anchor, "topright", anchorXOffset,  anchorYOffset)
    else
      subRegion:ClearAllPoints()
      anchorPoint = anchorPoint or "CENTER"

      local anchorRegion = self.bar

      anchorXOffset = anchorXOffset or 0
      anchorYOffset = anchorYOffset or 0

      if anchorPoint:sub(1, 5) == "ICON_" then
        anchorRegion = self.icon
        anchorPoint = anchorPoint:sub(6)
      elseif anchorPoint:sub(1, 6) == "INNER_" then
        anchorPoint = anchorPoint:sub(7)

        if anchorPoint:find("LEFT", 1, true) then
          anchorXOffset = anchorXOffset + 2
        elseif anchorPoint:find("RIGHT", 1, true) then
          anchorXOffset = anchorXOffset - 2
        end

        if anchorPoint:find("TOP", 1, true) then
          anchorYOffset = anchorYOffset - 2
        elseif anchorPoint:find("BOTTOM", 1, true) then
          anchorYOffset = anchorYOffset + 2
        end
      elseif anchorPoint == "SPARK" then
        anchorRegion = self.bar.spark
        anchorPoint = "CENTER"
      end

      selfPoint = selfPoint or "CENTER"

      if not Private.point_types[selfPoint] then
        selfPoint = "CENTER"
      end

      if not Private.point_types[anchorPoint] then
        anchorPoint = "CENTER"
      end

      subRegion:SetPoint(selfPoint, anchorRegion, anchorPoint, anchorXOffset, anchorYOffset)
    end
  end,
  SetIconColor = function(self, r, g, b, a)
    self.icon_color = {r, g, b, a}
    self.icon:SetVertexColor(r, g, b, a);
  end,
  SetIconDesaturated = function(self, b)
    self.desaturateIcon = b
    self.icon:SetDesaturated(b);
  end,
  SetBackgroundColor = function (self, r, g, b, a)
    self.bar:SetBackgroundColor(r, g, b, a);
  end,
  SetSparkColor = function(self, r, g, b, a)
    self.bar.spark:SetVertexColor(r, g, b, a);
  end,
  SetSparkHeight = function(self, height)
    self.bar.spark:SetHeight(height);
  end,
  SetSparkWidth = function(self, width)
    self.bar.spark:SetWidth(width);
  end,
  SetRegionWidth = function(self, width)
    self.width = width;
    self:Scale(self.scalex, self.scaley);
  end,
  SetRegionHeight = function(self, height)
    self.height = height;
    self:Scale(self.scalex, self.scaley);
  end,
  SetProgress = function(self, progress)
    if self.inverseDirection then
      progress = 1 - progress;
    end

    if (self.smoothProgress) then
      self.bar.targetValue = progress
      self.bar:SetSmoothedValue(progress);
    else
      self.bar:SetValue(progress);
    end
  end,
  UpdateValue = function(self)
    local progress = 0;
    if (self.total ~= 0) then
      progress = self.value / self.total;
    end

    self:SetProgress(progress)

    if self.FrameTick then
      self.FrameTick = nil
      self.subRegionEvents:RemoveSubscriber("FrameTick", self)
    end
  end,
  UpdateTime = function(self)
    local remaining = self.expirationTime - GetTime();
    local progress = self.duration ~= 0 and remaining / self.duration or 0;
    if self.inverse then
      progress = 1 - progress;
    end
    self:SetProgress(progress)

    if self.paused and self.FrameTick then
      self.FrameTick = nil
      self.subRegionEvents:RemoveSubscriber("FrameTick", self)
    end
    if not self.paused and not self.FrameTick then
      self.FrameTick = FrameTick
      self.subRegionEvents:AddSubscriber("FrameTick", self)
    end
  end,
  SetInverse = function(self, inverse)
    if (self.inverseDirection == inverse) then
      return;
    end
    self.inverseDirection = inverse;
    if (self.smoothProgress) then
      if (self.bar.targetValue) then
        self.bar.targetValue = 1 - self.bar.targetValue
        self.bar:SetSmoothedValue(self.bar.targetValue);
      end
    else
      self.bar:SetValue(1 - self.bar:GetValue());
    end
    self.bar:SetAdditionalBarsInverse(not self.bar:GetAdditionalBarsInverse())
    self.subRegionEvents:Notify("InverseChanged")
  end,
  SetOrientation = function(self, orientation)
    self.orientation = orientation
    self:UpdateEffectiveOrientation()
    if (self.smoothProgress) then
      if self.bar.targetValue then
        self.bar:SetSmoothedValue(self.bar.targetValue);
      end
    else
      self.bar:SetValue(self.bar:GetValue());
    end
  end,

  SetStatusBarTextureMode = function(self, mode)
    if self.textureSource == mode then
      return
    end
    self.textureSource = mode
    self:UpdateStatusBarTexture()
  end,

  SetStatusBarTextureInput = function(self, texture)
    if self.textureInput == texture then
      return
    end
    self.textureInput = texture
    self:UpdateStatusBarTexture()
  end,

  SetStatusBarTextureLSM = function(self, texture)
    if self.texture == texture then
      return
    end
    self.texture = texture
    self:UpdateStatusBarTexture()
  end,

  UpdateStatusBarTexture = function(self)
    local texturePath
    if self.textureSource == "Picker" then
      texturePath = self.textureInput or ""
    else
      texturePath = SharedMedia:Fetch("statusbar_atlas", self.texture, true) or SharedMedia:Fetch("statusbar", self.texture) or ""
    end
    self.bar:SetStatusBarTexture(texturePath)
  end,

  SetIconVisible = function(self, iconVisible)
    if (self.iconVisible == iconVisible) then
      return
    end

    self.iconVisible = iconVisible

    local icon = self.icon
    if self.iconVisible then
      -- Update icon
      local iconsize = math.min(self.height, self.width);
      icon:SetWidth(iconsize);
      icon:SetHeight(iconsize);
      self.bar.iconWidth = iconsize
      self.bar.iconHeight = iconsize
      local texWidth = 0.25 * self.zoom;
      icon:SetTexCoord(GetTexCoordZoom(texWidth))
      icon:SetDesaturated(self.desaturateIcon);
      icon:SetVertexColor(self.icon_color[1], self.icon_color[2], self.icon_color[3], self.icon_color[4]);

      -- Update icon visibility
      icon:Show();
    else
      self.bar.iconWidth = 0
      self.bar.iconHeight = 0
      icon:Hide();
    end

    self:ReOrient()
    self.subRegionEvents:Notify("OrientationChanged")
  end,
  SetIcon = function(self, iconPath)
    if self.displayIcon == iconPath then
      return
    end
    self.displayIcon = iconPath
    self:UpdateIcon()
  end,
  SetIconSource = function(self, source)
    if self.iconSource == source then
      return
    end

    self.iconSource = source
    self:UpdateIcon()
  end,
  UpdateIcon = function(self)
    local iconPath
    if self.iconSource == -1 then
      iconPath = self.state.icon
    elseif self.iconSource == 0 then
      iconPath = self.displayIcon
    else
      local triggernumber = self.iconSource
      if triggernumber and self.states[triggernumber] then
        iconPath = self.states[triggernumber].icon
      end
    end

    iconPath = iconPath or self.displayIcon or "Interface\\Icons\\INV_Misc_QuestionMark"
    Private.SetTextureOrAtlas(self.icon, iconPath)
  end,
  SetOverlayColor = function(self, id, r, g, b, a)
    self.bar:SetAdditionalBarColor(id, { r, g, b, a});
  end,
  GetEffectiveOrientation = function(self)
    return self.effectiveOrientation
  end,
  GetInverse = function(self)
    return self.inverseDirection
  end,
  ReOrient = function(self)
    if self.effectiveOrientation == "HORIZONTAL_INVERSE" then
      orientHorizontalInverse(self);
    elseif self.effectiveOrientation == "HORIZONTAL" then
      orientHorizontal(self);
    elseif self.effectiveOrientation == "VERTICAL_INVERSE" then
      orientVerticalInverse(self);
    elseif self.effectiveOrientation == "VERTICAL" then
      orientVertical(self);
    end
  end,
  UpdateEffectiveOrientation = function(self, force)
    local orientation = self.orientation

    if self.flipX then
      if self.orientation == "HORIZONTAL" then
        orientation = "HORIZONTAL_INVERSE"
      elseif self.orientation == "HORIZONTAL_INVERSE" then
        orientation = "HORIZONTAL"
      end
    end
    if self.flipY then
      if self.orientation == "VERTICAL" then
        orientation = "VERTICAL_INVERSE"
      elseif self.orientation == "VERTICAL_INVERSE" then
        orientation = "VERTICAL"
      end
    end

    if orientation ~= self.effectiveOrientation or force then
      self.effectiveOrientation = orientation
      self:ReOrient()
    end

    self.subRegionEvents:Notify("OrientationChanged")
  end,
  UpdateForegroundColor = function(self)
    if self.enableGradient then
      self.bar:SetForegroundGradient(self.gradientOrientation,
                                     self.color_anim_r or self.color_r,
                                     self.color_anim_g or self.color_g,
                                     self.color_anim_b or self.color_b,
                                     self.color_anim_a or self.color_a,
                                     self.barColor2[1],
                                     self.barColor2[2],
                                     self.barColor2[3],
                                     self.barColor2[4])
    else
      self.bar:SetForegroundColor(self.color_anim_r or self.color_r,
                                  self.color_anim_g or self.color_g,
                                  self.color_anim_b or self.color_b,
                                  self.color_anim_a or self.color_a);
    end
  end,
  SetBarColor2 = function(self, r, g, b, a)
    self.barColor2 = { r, g, b, a}
    self:UpdateForegroundColor()
  end,
  SetGradientOrientation = function(self, orientation)
    self.gradientOrientation = orientation
    self:UpdateForegroundColor()
  end,
  SetGradientEnabled = function(self, enable)
    self.enableGradient = enable
    self:UpdateForegroundColor()
  end,
  Color = function(self, r, g, b, a)
    self.color_r = r;
    self.color_g = g;
    self.color_b = b;
    self.color_a = a;
    self:UpdateForegroundColor()
  end,
  ColorAnim = function(self, r, g, b, a)
    self.color_anim_r = r;
    self.color_anim_g = g;
    self.color_anim_b = b;
    self.color_anim_a = a;
    self:UpdateForegroundColor()
  end,
  GetColor = function(self)
    return self.color_r, self.color_g, self.color_b, self.color_a
  end
}

-- Called when first creating a new region/display
local function create(parent)
  -- Create overall region (containing everything else)
  local region = CreateFrame("Frame", nil, parent);
  --- @cast region table|Frame
  region.regionType = "aurabar"
  region:SetMovable(true);
  region:SetResizable(true);
  region:SetResizeBounds(1, 1)

  local bar = CreateFrame("Frame", nil, region);
  --- @cast bar table|Frame
  Mixin(bar, Private.SmoothStatusBarMixin);

  -- Now create a bunch of textures
  local bg = region:CreateTexture(nil, "ARTWORK");
  bg:SetTexelSnappingBias(0)
  bg:SetSnapToPixelGrid(false)
  bg:SetAllPoints(bar);

  local fg = bar:CreateTexture(nil, "ARTWORK");
  fg:SetTexelSnappingBias(0)
  fg:SetSnapToPixelGrid(false)
  fg:SetAllPoints(bar)

  local fgMask = bar:CreateMaskTexture()
  fgMask:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite",
                    "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE", "NEAREST")
  fgMask:SetTexelSnappingBias(0)
  fgMask:SetSnapToPixelGrid(false)
  fg:AddMaskTexture(fgMask)

  local spark = bar:CreateTexture(nil, "ARTWORK");
  spark:SetSnapToPixelGrid(false)
  spark:SetTexelSnappingBias(0)
  fg:SetDrawLayer("ARTWORK", 0);
  bg:SetDrawLayer("ARTWORK", -1);
  spark:SetDrawLayer("ARTWORK", 7);
  bar.fg = fg;
  bar.fgMask = fgMask
  bar.bg = bg;
  bar.spark = spark;
  for key, value in pairs(barPrototype) do
    bar[key] = value;
  end
  bar.extraTextures = {};
  bar:SetRotatesTexture(true);
  bar:HookScript("OnSizeChanged", bar.OnSizeChanged);
  region.bar = bar;

  -- Create icon
  local iconFrame = CreateFrame("Frame", nil, region);
  region.iconFrame = iconFrame;
  local icon = iconFrame:CreateTexture(nil, "OVERLAY");
  icon:SetSnapToPixelGrid(false)
  icon:SetTexelSnappingBias(0)
  region.icon = icon;
  icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");

  local oldSetFrameLevel = region.SetFrameLevel;
  function region.SetFrameLevel(self, frameLevel)
    oldSetFrameLevel(self, frameLevel);

    if (self.__WAGlowFrame) then
      self.__WAGlowFrame:SetFrameLevel(frameLevel + 5);
    end
  end

  Private.regionPrototype.create(region);

  for k, f in pairs(funcs) do
    region[k] = f
  end

  -- Return new display/region
  return region;
end

-- Modify a given region/display
local function modify(parent, region, data)
  region.timer = nil
  region.text = nil
  region.stacks = nil

  Private.regionPrototype.modify(parent, region, data);
  -- Localize
  local bar, iconFrame, icon = region.bar, region.iconFrame, region.icon;

  region.iconSource = data.iconSource
  region.displayIcon = data.displayIcon

  -- Adjust region size
  region:SetWidth(data.width);
  region:SetHeight(data.height);
  region.bar.totalWidth = data.width
  region.bar.totalHeight = data.height

  region.width = data.width;
  region.height = data.height;
  region.scalex = 1;
  region.scaley = 1;
  region.flipX = false
  region.flipY = false
  region.orientation = data.orientation
  region.effectiveOrientation = nil

  -- region.barColor is special because of animations
  region.barColor2 = CopyTable(data.barColor2)
  region.enableGradient = data.enableGradient
  region.gradientOrientation = data.gradientOrientation
  region.overlayclip = data.overlayclip;
  region.iconVisible = data.icon
  region.icon_side = data.icon_side
  region.icon_color = CopyTable(data.icon_color)
  region.desaturateIcon = data.desaturate
  region.zoom = data.zoom

  if (data.overlays) then
    region.overlays = CopyTable(data.overlays);
  else
    region.overlays = {}
  end
  if data.overlaysTexture then
    region.overlaysTexture = CopyTable(data.overlaysTexture)
  else
    region.overlaysTexture = {}
  end

  -- Update texture settings
  region.textureSource = data.textureSource
  region.texture = data.texture
  region.textureInput = data.textureInput

  region:UpdateStatusBarTexture();
  bar:SetBackgroundColor(data.backgroundColor[1], data.backgroundColor[2], data.backgroundColor[3], data.backgroundColor[4]);
  -- Update spark settings
  Private.SetTextureOrAtlas(bar.spark, data.sparkTexture);
  bar.spark:SetVertexColor(data.sparkColor[1], data.sparkColor[2], data.sparkColor[3], data.sparkColor[4]);
  bar.spark:SetWidth(data.sparkWidth);
  bar.spark:SetHeight(data.sparkHeight);
  bar.spark.sparkHidden = data.spark and data.sparkHidden or "ALWAYS";
  bar.spark:SetBlendMode(data.sparkBlendMode);
  bar.spark:SetDesaturated(data.sparkDesaturate);
  bar.spark.sparkOffsetX = data.sparkOffsetX;
  bar.spark.sparkOffsetY = data.sparkOffsetY;
  bar.spark.sparkRotationMode = data.sparkRotationMode;
  bar.spark.sparkRotation = data.sparkRotation;
  bar.spark.sparkMirror = data.sparkMirror;

  region:Color(data.barColor[1], data.barColor[2], data.barColor[3], data.barColor[4]);

  -- Update icon visibility
  if region.iconVisible then
    -- Update icon
    local iconsize = math.min(region.height, region.width);
    icon:SetWidth(iconsize);
    icon:SetHeight(iconsize);
    region.bar.iconWidth = iconsize
    region.bar.iconHeight = iconsize
    local texWidth = 0.25 * data.zoom;
    icon:SetTexCoord(GetTexCoordZoom(texWidth))
    icon:SetDesaturated(data.desaturate);
    icon:SetVertexColor(data.icon_color[1], data.icon_color[2], data.icon_color[3], data.icon_color[4]);

    -- Update icon visibility
    icon:Show();

  else
    region.bar.iconWidth = 0
    region.bar.iconHeight = 0
    icon:Hide();
  end

  region.inverseDirection = data.inverse;

  -- Apply orientation alignment
  region:UpdateEffectiveOrientation()

  -- Update tooltip availability
  local tooltipType = Private.CanHaveTooltip(data);
  if tooltipType and data.useTooltip then
    -- Create and enable tooltip-hover frame
    if not region.tooltipFrame then
      region.tooltipFrame = CreateFrame("Frame", nil, region);
      region.tooltipFrame:SetAllPoints(icon);
      region.tooltipFrame:SetScript("OnEnter", function()
        Private.ShowMouseoverTooltip(region, region.tooltipFrame);
      end);
      region.tooltipFrame:SetScript("OnLeave", Private.HideTooltip);
    end
    region.tooltipFrame:EnableMouseMotion(true);
    region.tooltipFrame:SetMouseClickEnabled(false);
  elseif region.tooltipFrame then
    -- Disable tooltip
    region.tooltipFrame:EnableMouseMotion(false);
  end

  region.FrameTick = nil
  function region:Update()
    region:UpdateProgress()
    region:UpdateIcon()
  end

  function region:SetAdditionalProgress(additionalProgress, currentMin, currentMax, inverse)
    local effectiveInverse = (inverse and not region.inverseDirection) or (not inverse and region.inverseDirection);
    region.bar:SetAdditionalBars(additionalProgress, region.overlays, region.overlaysTexture, currentMin, currentMax, effectiveInverse, region.overlayclip);
  end

  -- Scale update function
  function region:Scale(scalex, scaley)
    region.scalex = scalex;
    region.scaley = scaley;
    -- Icon size
    local iconsize = math.min(region.height, region.width);

    -- Re-orientate region
    if scalex < 0 then
      scalex = -scalex;
      region.flipX = true
    else
      region.flipX = false
    end

    -- Update width
    self.bar.totalWidth = region.width * scalex
    self.bar.iconWidth = iconsize * scalex

    self:SetWidth(self.bar.totalWidth);
    icon:SetWidth(self.bar.iconWidth);

    -- Re-orientate region
    if scaley < 0 then
      scaley = -scaley;
      region.flipY = true
    else
      region.flipY = false
    end

    -- Update height
    self.bar.totalHeight = region.height * scaley
    self.bar.iconHeight = iconsize * scaley
    self:SetHeight(self.bar.totalHeight);
    icon:SetHeight(self.bar.iconHeight);

    region:UpdateEffectiveOrientation(true)
  end
  --  region:Scale(1.0, 1.0);
  if data.smoothProgress then
    region.PreShow = function()
      region.bar:ResetSmoothedValue();
    end
  else
    region.PreShow = nil
  end

  region.smoothProgress = data.smoothProgress
  --- Update internal bar alignment
  region.bar:Update();

  Private.regionPrototype.modifyFinish(parent, region, data);
end

local function validate(data)
  -- pre-migration
  if data.subRegions then
    for _, subRegionData in ipairs(data.subRegions) do
      if subRegionData.type == "aurabar_bar" then
        subRegionData.type = "subforeground"
      end
    end
  end
  Private.EnforceSubregionExists(data, "subforeground")
  Private.EnforceSubregionExists(data, "subbackground")
end

-- Register new region type with WeakAuras
Private.RegisterRegionType("aurabar", create, modify, default, GetProperties, validate);


-- ========================================
-- File: WeakAuras/RegionTypes/DynamicGroup.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L
local SharedMedia = LibStub("LibSharedMedia-3.0")

local default = {
  controlledChildren = {},
  border = false,
  borderColor = {0, 0, 0, 1},
  backdropColor = {1, 1, 1, 0.5},
  borderEdge = "Square Full White",
  borderOffset = 4,
  borderInset = 1,
  borderSize = 2,
  borderBackdrop = "Blizzard Tooltip",
  grow = "DOWN",
  selfPoint = "TOP",
  align = "CENTER",
  space = 2,
  stagger = 0,
  sort = "none",
  animate = false,
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  radius = 200,
  rotation = 0,
  stepAngle = 15,
  fullCircle = true,
  arcLength = 360,
  constantFactor = "RADIUS",
  frameStrata = 1,
  scale = 1,
  useLimit = false,
  limit = 5,
  gridType = "RD",
  centerType = "LR",
  gridWidth = 5,
  rowSpace = 1,
  columnSpace = 1
}

Private.regionPrototype.AddAlphaToDefault(default);

local controlPointFunctions = {
  ["SetAnchorPoint"] = function(self, point, relativeFrame, relativePoint, offsetX, offsetY)
    self:ClearAllPoints();
    self.point, self.relativeFrame, self.relativePoint, self.offsetX, self.offsetY
      = point, relativeFrame, relativePoint, offsetX, offsetY
    self.totalOffsetX = (self.animOffsetX or 0) + (self.offsetX or 0)
    self.totalOffsetY = (self.animOffsetY or 0) + (self.offsetY or 0)
    if self.relativeFrame and self.relativePoint then
      self:SetPoint(self.point, self.relativeFrame, self.relativePoint, self.totalOffsetX, self.totalOffsetY)
    else
      self:SetPoint(self.point, self.totalOffsetX, self.totalOffsetY)
    end
  end,
  ["ClearAnchorPoint"] = function(self)
    self.point, self.relativeFrame, self.relativePoint, self.offsetX, self.offsetY = nil, nil, nil, nil, nil
  end,
  ["ReAnchor"] = function(self, frame)
    self:ClearAllPoints()
    self.relativeFrame = frame
    if self.relativeFrame and self.relativePoint then
      self:SetPoint(self.point, self.relativeFrame, self.relativePoint, self.totalOffsetX, self.totalOffsetY)
    else
      self:SetPoint(self.point, self.totalOffsetX, self.totalOffsetY)
    end
  end,
  ["SetOffsetAnim"] = function(self, x, y)
    self.animOffsetX, self.animOffsetY = x, y
    self.totalOffsetX = (self.animOffsetX or 0) + (self.offsetX or 0)
    self.totalOffsetY = (self.animOffsetY or 0) + (self.offsetY or 0)
    if not self.point then
      -- Nothing to do
    elseif self.relativeFrame and self.relativePoint then
      self:SetPoint(self.point, self.relativeFrame, self.relativePoint, self.totalOffsetX, self.totalOffsetY)
    else
      self:SetPoint(self.point, self.totalOffsetX, self.totalOffsetY)
    end
  end
}

local function createControlPoint(self)
  local controlPoint = CreateFrame("Frame", nil, self.parent)
  Mixin(controlPoint, controlPointFunctions)

  controlPoint:SetWidth(16)
  controlPoint:SetHeight(16)
  controlPoint:Show()
  controlPoint:SetAnchorPoint(self.parent.selfPoint)
  return controlPoint
end

local function releaseControlPoint(self, controlPoint)
  controlPoint:Hide()
  controlPoint:SetAnchorPoint(self.parent.selfPoint)
  local regionData = controlPoint.regionData
  if regionData then
    if self.parent.anchorPerUnit == "UNITFRAME" then
      Private.dyngroup_unitframe_monitor[regionData] = nil
    end
    controlPoint.regionData = nil
    regionData.controlPoint = nil
  end
end

local function create(parent)
  local region = CreateFrame("Frame", nil, parent)
  region.regionType = "dynamicgroup"
  region:SetSize(16, 16)
  region:SetMovable(true)
  region.sortedChildren = {}
  region.controlledChildren = {}
  region.updatedChildren = {}
  region.sortStates = {}
  region.growStates = {}
  local background = CreateFrame("Frame", nil, region, "BackdropTemplate")
  region.background = background
  region.selfPoint = "TOPLEFT"
  region.controlPoints = CreateObjectPool(createControlPoint, releaseControlPoint)
  region.controlPoints.parent = region
  Private.regionPrototype.create(region)
  region.suspended = 0

  local oldSetFrameLevel = region.SetFrameLevel
  region.SetFrameLevel = function(self, level)
    oldSetFrameLevel(self, level)
    self.background:SetFrameLevel(level)
  end

  return region
end

function WeakAuras.GetPolarCoordinates(x, y, originX, originY)
  local dX, dY = x - originX, y - originY;

  local r = math.sqrt(dX * dX + dY * dY);
  local theta = atan2(dY, dX);

  return r, theta;
end

function WeakAuras.InvertSort(sortFunc)
  -- takes a comparator and returns the "inverse"
  -- i.e. when sortFunc returns true/false, inverseSortFunc returns false/true
  -- nils are preserved to ensure that inverseSortFunc composes well
  if type(sortFunc) ~= "function" then
    error("InvertSort requires a function to invert.")
  else
    return function(...)
      local result = sortFunc(...)
      if result == nil then return nil end
      return not result
    end
  end
end

function WeakAuras.SortNilLast(a, b)
  -- sorts nil values to the end
  -- only returns nil if both values are non-nil
  -- Useful as a high priority sorter in a composition,
  -- to ensure that children with missing data
  -- don't ever sit in the middle of a row
  -- and interrupt the sorting algorithm
  if a == nil and b == nil then
    -- guarantee stability in the nil region
    return false
  elseif a == nil then
    return false
  elseif b == nil then
    return true
  else
    return nil
  end
end

local sortNilFirst = WeakAuras.InvertSort(WeakAuras.SortNilLast)
function WeakAuras.SortNilFirst(a, b)
  if a == nil and b == nil then
    -- we want SortNil to always prevent nils from propagating
    -- as well as to sort nils onto one side
    -- to maintain stability, we need SortNil(nil, nil) to always be false
    -- hence this special case
    return false
  else
    return sortNilFirst(a,b)
  end
end

function WeakAuras.SortGreaterLast(a, b)
  -- sorts values in ascending order
  -- values of disparate types are sorted according to the value of type(value)
  -- which is a bit weird but at least guarantees a stable sort
  -- can only sort comparable values (i.e. numbers and strings)
  -- no support currently for tables with __lt metamethods
  if a == b then
    return nil
  end
  if type(a) ~= type(b) then
    return type(a) > type(b)
  end
  if type(a) == "number" then
    if abs(b - a) < 0.001 then
      return nil
    else
      return a < b
    end
  elseif type(a) == "string" then
    return a < b
  else
    return nil
  end
end

WeakAuras.SortGreaterFirst = WeakAuras.InvertSort(WeakAuras.SortGreaterLast)

function WeakAuras.SortRegionData(path, sortFunc)
  -- takes an array-like table, and a function that takes 2 values and returns true/false/nil
  -- creates function that accesses the value indicated by path, and compares using sortFunc
  if type(path) ~= "table" then
    path = {}
  end
  if type(sortFunc) ~= "function" then
    -- if sortFunc not provided, compare by default as "<"
    sortFunc = WeakAuras.SortGreaterLast
  end
  return function(a, b)
    local aValue, bValue = a, b
    for _, key in ipairs(path) do
      if type(aValue) ~= "table" then return nil end
      if type(bValue) ~= "table" then return nil end
      aValue, bValue = aValue[key], bValue[key]
    end
    return sortFunc(aValue, bValue)
  end
end

function WeakAuras.SortAscending(path)
  return WeakAuras.SortRegionData(path, WeakAuras.ComposeSorts(WeakAuras.SortNilFirst, WeakAuras.SortGreaterLast))
end

function WeakAuras.SortDescending(path)
  return WeakAuras.InvertSort(WeakAuras.SortAscending(path))
end

function WeakAuras.ComposeSorts(...)
  -- accepts vararg of sort funcs
  -- returns new sort func that combines the functions passed in
  -- order of functions passed in determines their priority in new sort
  -- returns nil if all functions return nil,
  -- so that it can be composed or inverted without trouble
  local sorts = {}
  for i = 1, select("#", ...) do
    local sortFunc = select(i, ...)
    if type(sortFunc) == "function" then
      tinsert(sorts, sortFunc)
    end
  end
  return function(a, b)
    for _, sortFunc in ipairs(sorts) do
      local result = sortFunc(a, b)
      if result ~= nil then
        return result
      end
    end
    return nil
  end
end

local function noop() end

local sorters = {
  none = function(data)
    return WeakAuras.ComposeSorts(
      WeakAuras.SortAscending({"dataIndex"}),
      WeakAuras.SortAscending({"region", "state", "index"})
    ), { index = true }
  end,
  hybrid = function(data)
    local sortHybridTable = data.sortHybridTable or {}
    local hybridSortAscending = data.hybridSortMode == "ascending"
    local hybridFirst = data.hybridPosition == "hybridFirst"
    local function sortHybridStatus(a, b)
      if not b then return true end
      if not a then return false end

      local aIsHybrid = sortHybridTable[a.id]
      local bIsHybrid = sortHybridTable[b.id]

      if aIsHybrid and not bIsHybrid then
        return hybridFirst
      elseif bIsHybrid and not aIsHybrid then
        return not hybridFirst
      else
        return nil
      end
    end
    local sortExpirationTime
    if hybridSortAscending then
      sortExpirationTime = WeakAuras.SortAscending({"region", "state", "expirationTime"})
    else
      sortExpirationTime = WeakAuras.SortDescending({"region", "state", "expirationTime"})
    end
    return WeakAuras.ComposeSorts(
      sortHybridStatus,
      sortExpirationTime,
      WeakAuras.SortAscending({"dataIndex"})
    ), {expirationTime = true}
  end,
  ascending = function(data)
    return WeakAuras.ComposeSorts(
      WeakAuras.SortAscending({"region", "state", "expirationTime"}),
      WeakAuras.SortAscending({"dataIndex"})
    ), {expirationTime = true}
  end,
  descending = function(data)
    return WeakAuras.ComposeSorts(
      WeakAuras.SortDescending({"region", "state", "expirationTime"}),
      WeakAuras.SortAscending({"dataIndex"})
    ), {expirationTime = true}
  end,
  custom = function(data)
    local sortStr = data.customSort or ""
    local sortFunc = WeakAuras.LoadFunction("return " .. sortStr, data.id) or noop
    local sortOn = nil
    local events = WeakAuras.split(data.sortOn or "")
    if #events > 0 then
      sortOn = {}
      for _, event in ipairs(events) do
        sortOn[event] = true
      end
    end
    return function(a, b)
      Private.ActivateAuraEnvironment(data.id)
      local ok, result = xpcall(sortFunc, Private.GetErrorHandlerId(data.id, L["Custom Sort"]), a, b)
      Private.ActivateAuraEnvironment()
      if ok then
        return result
      end
    end, sortOn
  end
}
WeakAuras.SortFunctions = sorters

local function createSortFunc(data)
  local sorter = sorters[data.sort] or sorters.none
  return sorter(data)
end

local function polarToRect(r, theta)
  return r * math.cos(theta), r * math.sin(theta)
end

local function staggerCoefficient(alignment, stagger)
  if alignment == "LEFT" then
    if stagger < 0 then
      return 1
    else
      return 0
    end
  elseif alignment == "RIGHT" then
    if stagger > 0 then
      return 1
    else
      return 0
    end
  else
    return 0.5
  end
end

local anchorers = {
  ["NAMEPLATE"] = function(data)
    return function(frames, activeRegions)
      for _, regionData in ipairs(activeRegions) do
        local unit = regionData.region.state and regionData.region.state.unit
        local found
        if unit then
          local frame = WeakAuras.GetUnitNameplate(unit)
          if frame then
            frames[frame] = frames[frame] or {}
            tinsert(frames[frame], regionData)
            found = true
          end
        end
        if not found and WeakAuras.IsOptionsOpen() and regionData.region.state then
          Private.ensurePRDFrame()
          Private.personalRessourceDisplayFrame:anchorFrame(regionData.region.state.id, "NAMEPLATE")
          frames[Private.personalRessourceDisplayFrame] = frames[Private.personalRessourceDisplayFrame] or {}
          tinsert(frames[Private.personalRessourceDisplayFrame], regionData)
        end
      end
    end, {unit = true }
  end,
  ["UNITFRAME"] = function(data)
    return function(frames, activeRegions)
      for _, regionData in ipairs(activeRegions) do
        local unit = regionData.region.state and regionData.region.state.unit
        if unit then
          local frame = WeakAuras.GetUnitFrame(unit) or WeakAuras.HiddenFrames
          if frame then
            frames[frame] = frames[frame] or {}
            tinsert(frames[frame], regionData)
          end
        end
      end
    end, {unit = true }
  end,
  ["CUSTOM"] = function(data)
    local anchorStr = data.customAnchorPerUnit or ""
    local anchorFunc = WeakAuras.LoadFunction("return " .. anchorStr, data.id) or noop

    local anchorOn = nil
    local events = WeakAuras.split(data.anchorOn or "")
    if #events > 0 then
      anchorOn = {}
      for _, event in ipairs(events) do
        anchorOn[event] = true
      end
    end

    return function(frames, activeRegions)
      Private.ActivateAuraEnvironment(data.id)
      xpcall(anchorFunc, Private.GetErrorHandlerUid(data.uid, L["Custom Anchor"]), frames, activeRegions)
      Private.ActivateAuraEnvironment()
    end, anchorOn
  end
}

-- Names are based on the Left->Right layout,
local centeredIndexerStart = {
  -- Left to right, e.g: 1 2 3 4
  ["LR"] = function(maxIndex)
    return maxIndex > 0 and 1 or nil
  end,
  ["RL"] = function(maxIndex)
    return maxIndex > 0 and maxIndex or nil
  end,
  -- Center -> Left -> Right, e.g: 4 2 1 3
  ["CLR"] = function(maxIndex)
    if maxIndex >= 3 then
      return maxIndex - maxIndex % 2
    else
      return maxIndex > 0 and maxIndex or nil
    end
  end,
  -- Center -> Right -> Left, e.g: 3 1 2 4
  ["CRL"] = function(maxIndex)
    if maxIndex % 2 == 1 then
      return maxIndex
    else
     return maxIndex > 0 and maxIndex - 1 or nil
    end
  end
}

local centeredIndexerNext = {
  ["LR"] = function(index, maxIndex)
    index = index + 1
    return index <= maxIndex and index or nil
  end,
  ["RL"] = function(index, maxIndex)
    index = index - 1
    return index > 0 and index or nil
  end,
  ["CLR"] = function(index, maxIndex)
    -- Center -> Left -> Right
    -- So even -> odd
    if index % 2 == 0 then
      index = index - 2
      if index == 0 then
        index = 1
      end
    else
      index = index + 2
    end
    if index > maxIndex then
      return nil
    end
    return index
  end,
  ["CRL"] = function(index, maxIndex)
    -- Center -> Right -> Left
    -- So odd -> even
    if index % 2 == 1 then
      index = index - 2
      if index == -1 then
        index = 2
      end
    else
      index = index + 2
    end
    if index > maxIndex then
      return nil
    end
    return index
  end,
}

local function createAnchorPerUnitFunc(data)
  local anchorer = anchorers[data.anchorPerUnit] or anchorers.NAMEPLATE
  return anchorer(data)
end

local function getDimension(regionData, dim)
  return regionData.dimensions[dim]
end

local growers = {
  LEFT = function(data)
    local stagger = -(data.stagger or 0)
    local space = data.space or 0
    local limit = data.useLimit and data.limit or math.huge
    local startX, startY = 0, 0
    local coeff = staggerCoefficient(data.align, data.stagger)
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local x, y = startX, startY + (numVisible - 1) * stagger * coeff
        newPositions[frame] = {}
        for i, regionData in ipairs(regionDatas) do
          if i <= numVisible then
            newPositions[frame][regionData] = { x, y, true }
            x = x - regionData.dimensions.width - space
            y = y - stagger
          end
        end
      end
    end, anchorOn
  end,
  RIGHT = function(data)
    local stagger = data.stagger or 0
    local space = data.space or 0
    local limit = data.useLimit and data.limit or math.huge
    local startX, startY = 0, 0
    local coeff = 1 - staggerCoefficient(data.align, stagger)
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local x, y = startX, startY - (numVisible - 1) * stagger * coeff
        newPositions[frame] = {}
        for i, regionData in ipairs(regionDatas) do
          if i <= numVisible then
            newPositions[frame][regionData] = { x, y, true }
            x = x + (regionData.dimensions.width) + space
            y = y + stagger
          end
        end
      end
    end, anchorOn
  end,
  UP = function(data)
    local stagger = data.stagger or 0
    local space = data.space or 0
    local limit = data.useLimit and data.limit or math.huge
    local startX, startY = 0, 0
    local coeff = 1 - staggerCoefficient(data.align, stagger)
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local x, y = startX - (numVisible - 1) * stagger * coeff, startY
        newPositions[frame] = {}
        for i, regionData in ipairs(regionDatas) do
          if i <= numVisible then
            newPositions[frame][regionData] = { x, y, true }
            x = x + stagger
            y = y + (regionData.dimensions.height) + space
          end
        end
      end
    end, anchorOn
  end,
  DOWN = function(data)
    local stagger = data.stagger or 0
    local space = data.space or 0
    local limit = data.useLimit and data.limit or math.huge
    local startX, startY = 0, 0
    local coeff = staggerCoefficient(data.align, stagger)
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local x, y = startX - (numVisible - 1) * stagger * coeff, startY
        newPositions[frame] = {}
        for i, regionData in ipairs(regionDatas) do
          if i <= numVisible then
            newPositions[frame][regionData] = { x, y, true }
            x = x + stagger
            y = y - (regionData.dimensions.height) - space
          end
        end
      end
    end, anchorOn
  end,
  HORIZONTAL = function(data)
    local stagger = data.stagger or 0
    local space = data.space or 0
    local limit = data.useLimit and data.limit or math.huge
    local midX, midY = 0, 0
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    local FirstIndex = centeredIndexerStart[data.centerType]
    local NextIndex = centeredIndexerNext[data.centerType]
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local totalWidth = (numVisible - 1) * space
        for i = 1, numVisible do
          local regionData = regionDatas[i]
          totalWidth = totalWidth + (regionData.dimensions.width)
        end
        local x, y = midX - totalWidth/2, midY - (stagger * (numVisible - 1)/2)
        newPositions[frame] = {}

        --- @type integer?
        local i = FirstIndex(numVisible)
        while i do
          local regionData = regionDatas[i]
          x = x + (regionData.dimensions.width) / 2
          newPositions[frame][regionData] = { x, y, true }
          x = x + (regionData.dimensions.width) / 2 + space
          y = y + stagger
          i = NextIndex(i, numVisible)
        end
      end
    end, anchorOn
  end,
  VERTICAL = function(data)
    local stagger = -(data.stagger or 0)
    local space = data.space or 0
    local limit = data.useLimit and data.limit or math.huge
    local midX, midY = 0, 0
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    local FirstIndex = centeredIndexerStart[data.centerType]
    local NextIndex = centeredIndexerNext[data.centerType]
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local totalHeight = (numVisible - 1) * space
        for i = 1, numVisible do
          local regionData = regionDatas[i]
          totalHeight = totalHeight + (regionData.dimensions.height)
        end
        local x, y = midX - (stagger * (numVisible - 1)/2), midY - totalHeight/2
        newPositions[frame] = {}
        local i = FirstIndex(numVisible)
        while i do
          local regionData = regionDatas[i]
          y = y + (regionData.dimensions.height) / 2
          newPositions[frame][regionData] = { x, y, true }
          x = x + stagger
          y = y + (regionData.dimensions.height) / 2 + space
          i = NextIndex(i, numVisible)
        end
      end
    end, anchorOn
  end,
  CIRCLE = function(data)
    local oX, oY = 0, 0
    local constantFactor = data.constantFactor
    local space = data.space or 0
    local radius = data.radius or 0
    local stepAngle = (data.stepAngle or 0) * math.pi / 180
    local limit = data.useLimit and data.limit or math.huge
    local sAngle = (data.rotation or 0) * math.pi / 180
    local arc = (data.fullCircle and 360 or data.arcLength or 0) * math.pi / 180
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local r
        if constantFactor == "RADIUS" or constantFactor == "ANGLE" then
          r = radius
        else
          if numVisible <= 1 then
            r = 0
          else
            r = (numVisible * space) / (2 * math.pi)
          end
        end
        local theta = sAngle
        local dAngle
        if numVisible == 1 then
          dAngle = 0
        elseif constantFactor == "ANGLE" then
          dAngle = stepAngle
        elseif not data.fullCircle then
          dAngle = arc / (numVisible - 1)
        else
          dAngle = arc / numVisible
        end
        newPositions[frame] = {}
        for i, regionData in ipairs(regionDatas) do
          if i <= numVisible then
            local x, y = polarToRect(r, theta)
            newPositions[frame][regionData] = { x, y, true }
            theta = theta + dAngle
          end
        end
      end
    end, anchorOn
  end,
  COUNTERCIRCLE = function(data)
    local oX, oY = 0, 0
    local constantFactor = data.constantFactor
    local space = data.space or 0
    local radius = data.radius or 0
    local stepAngle = (data.stepAngle or 0) * math.pi / 180
    local limit = data.useLimit and data.limit or math.huge
    local sAngle = (data.rotation or 0) * math.pi / 180
    local arc = (data.fullCircle and 360 or data.arcLength or 0) * math.pi / 180
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        local r
        if constantFactor == "RADIUS" or constantFactor == "ANGLE" then
          r = radius
        else
          if numVisible <= 1 then
            r = 0
          else
            r = (numVisible * space) / (2 * math.pi)
          end
        end
        local theta = sAngle
        local dAngle
        if numVisible == 1 then
          dAngle = 0
        elseif constantFactor == "ANGLE" then
          dAngle = -stepAngle
        elseif not data.fullCircle then
          dAngle = arc / (1 - numVisible)
        else
          dAngle = arc / -numVisible
        end
        newPositions[frame] = {}
        for i, regionData in ipairs(regionDatas) do
          if i <= numVisible then
            local x, y = polarToRect(r, theta)
            newPositions[frame][regionData] = { x, y, true }
            theta = theta + dAngle
          end
        end
      end
    end, anchorOn
  end,
  GRID = function(data)
    local gridType = data.gridType
    local gridWidth = data.gridWidth
    local rowSpace = data.rowSpace
    local colSpace = data.columnSpace
    local rowFirst = (gridType:find("^[RLH]")) ~= nil
    local limit = data.useLimit and data.limit or math.huge
    local rowMul, colMul, primary_horizontal, secondary_horizontal, primary_vertical, secondary_vertical
    if gridType:find("D") then
      rowMul = -1
    else
      rowMul = 1
    end
    if gridType:find("L") then
      colMul = -1
    else
      colMul = 1
    end
    if gridType:sub(1, 1) == "H" then
      primary_horizontal = true
    elseif gridType:sub(2, 2) == "H" then
      secondary_horizontal = true
    end
    if gridType:sub(1, 1) == "V" then
      primary_vertical = true
    elseif gridType:sub(2, 2) == "V" then
      secondary_vertical = true
    end
    local primary = {
      -- x direction
      dim = "width",
      coord = 1,
      mul = colMul,
      space = colSpace,
      current = 0
    }
    local secondary = {
      -- y direction
      dim = "height",
      coord = 2,
      mul = rowMul,
      space = rowSpace,
      current = 0
    }
    if not rowFirst then
      primary, secondary = secondary, primary
    end
    local anchorPerUnitFunc, anchorOn
    if data.useAnchorPerUnit then
      anchorPerUnitFunc, anchorOn = createAnchorPerUnitFunc(data)
    end
    return function(newPositions, activeRegions)
      local frames = {}
      if anchorPerUnitFunc then
        anchorPerUnitFunc(frames, activeRegions)
      else
        frames[""] = activeRegions
      end
      for frame, regionDatas in pairs(frames) do
        local numVisible = min(limit, #regionDatas)
        primary.current = 0
        secondary.current = 0
        secondary.max = 0
        newPositions[frame] = {}
        local minX, maxX, minY, maxY, totalMinX, totalMaxX, totalMinY, totalMaxY
        local start
        for i, regionData in ipairs(regionDatas) do
          if i <= numVisible then
            newPositions[frame][regionData] = {
              [primary.coord] = primary.current,
              [secondary.coord] = secondary.current,
              [3] = true
            }
            local x, y = newPositions[frame][regionData][1], newPositions[frame][regionData][2]
            if minX == nil then
              minX, maxX, minY, maxY = x, x, y, y
              start = i
            else
              minX, maxX = math.min(minX, x), math.max(maxX, x)
              minY, maxY = math.min(minY, y), math.max(maxY, y)
            end
            if totalMinX == nil then
              totalMinX, totalMaxX, totalMinY, totalMaxY = x, x, y, y
            else
              totalMinX, totalMaxX = math.min(totalMinX, x), math.max(totalMaxX, x)
              totalMinY, totalMaxY = math.min(totalMinY, y), math.max(totalMaxY, y)
            end
            secondary.max = max(secondary.max, getDimension(regionData, secondary.dim))
            if i % gridWidth == 0 then
              if primary_horizontal then
                local offsetX = (maxX - minX) / 2
                for j = start, i do
                  newPositions[frame][regionDatas[j]][1] = newPositions[frame][regionDatas[j]][1] - offsetX
                end
              end
              if primary_vertical then
                local offsetY = (maxY - minY) / 2
                for j = start, i do
                  newPositions[frame][regionDatas[j]][2] = newPositions[frame][regionDatas[j]][2] - offsetY
                end
              end
              primary.current = 0
              secondary.current = secondary.current + (secondary.space + secondary.max) * secondary.mul
              secondary.max = 0
              minX, maxX = nil, nil
              minY, maxY = nil, nil
            else
              primary.current = primary.current + (primary.space + getDimension(regionData, primary.dim)) * primary.mul
            end
          end
        end
        if (primary_horizontal or primary_vertical) and minX then
          local offsetX = (maxX - minX) / 2
          local offsetY = (maxY - minY) / 2
          for j = start, #regionDatas do
            if j <= numVisible then
              if primary_horizontal then
                newPositions[frame][regionDatas[j]][1] = newPositions[frame][regionDatas[j]][1] - offsetX
              end
              if primary_vertical then
                newPositions[frame][regionDatas[j]][2] = newPositions[frame][regionDatas[j]][2] - offsetY
              end
            end
          end
        end
        if (secondary_horizontal or secondary_vertical) and totalMinX then
          local offsetX = (totalMaxX - totalMinX) / 2
          local offsetY = (totalMaxY - totalMinY) / 2
          for j = 1, #regionDatas do
            if j <= numVisible then
              if secondary_horizontal then
                newPositions[frame][regionDatas[j]][1] = newPositions[frame][regionDatas[j]][1] - offsetX
              end
              if secondary_vertical then
                newPositions[frame][regionDatas[j]][2] = newPositions[frame][regionDatas[j]][2] - offsetY
              end
            end
          end
        end
      end
    end, anchorOn
  end,
  CUSTOM = function(data)
    local growStr = data.customGrow or ""
    local growFunc = WeakAuras.LoadFunction("return " .. growStr, data.id) or noop
    local growOn = nil
    local events = WeakAuras.split(data.growOn or "")
    if #events > 0 then
      growOn = {}
      for _, event in ipairs(events) do
        growOn[event] = true
      end
    end
    return function(newPositions, activeRegions)
      Private.ActivateAuraEnvironment(data.id)
      local ok = xpcall(growFunc, Private.GetErrorHandlerId(data.id, L["Custom Grow"]), newPositions, activeRegions)
      Private.ActivateAuraEnvironment()
      if not ok then
        wipe(newPositions)
      end
    end, growOn
  end
}
WeakAuras.GrowFunctions = growers

local function createGrowFunc(data)
  local grower = growers[data.grow] or growers.DOWN
  return grower(data)
end

local nullErrorHandler = function()
end

local function SafeGetPos(region, func)
  local ok, value1, value2 = xpcall(func, nullErrorHandler, region)
  if ok then
    return value1, value2
  end
end

local function isDifferent(regionData, cache, events)
  local id = regionData.id
  local cloneId = regionData.cloneId or ""
  local state = regionData.region.state
  if not events then
    return false
  elseif events.changed then
    return true -- escape hatch, not super recommended
  else
    local isDifferent = false
    if not cache[id] then
      isDifferent = true
      local cachedState = {}
      cache[id] = {[cloneId] = cachedState}
      for event in pairs(events) do
        cachedState[event] = state[event]
      end
    elseif not cache[id][cloneId] then
      isDifferent = true
      local cachedState = {}
      cache[id][cloneId] = cachedState
      for event in pairs(events) do
        cachedState[event] = state[event]
      end
    else
      local cachedState = cache[id][cloneId]
      for event in pairs(events) do
        if regionData.region.state[event] ~= cachedState[event] then
          cachedState[event] = state[event]
          isDifferent = true
        end
      end
    end
    return isDifferent
  end
end

local function clearCache(cache, id, cloneId)
  cloneId = cloneId or ""
  if cache[id] then
    cache[id][cloneId] = nil
  end
end

local function modify(parent, region, data)
  Private.FixGroupChildrenOrderForGroup(data)
  region:SetScale(data.scale and data.scale > 0 and data.scale <= 10 and data.scale or 1)
  Private.regionPrototype.modify(parent, region, data)

  if data.border and not data.useAnchorPerUnit then
    local background = region.background
    background:SetBackdrop({
      edgeFile = data.borderEdge ~= "None" and SharedMedia:Fetch("border", data.borderEdge) or "",
      edgeSize = data.borderSize,
      bgFile = data.borderBackdrop ~= "None" and SharedMedia:Fetch("background", data.borderBackdrop) or "",
      insets = {
        left = data.borderInset,
        right = data.borderInset,
        top = data.borderInset,
        bottom  = data.borderInset,
      },
    });
    background:SetBackdropBorderColor(data.borderColor[1], data.borderColor[2],
                                      data.borderColor[3], data.borderColor[4]);
    background:SetBackdropColor(data.backdropColor[1], data.backdropColor[2],
                                data.backdropColor[3], data.backdropColor[4]);

    background:ClearAllPoints();
    background:SetPoint("bottomleft", region, "bottomleft", -1 * data.borderOffset, -1 * data.borderOffset)
    background:SetPoint("topright", region, "topright", data.borderOffset, data.borderOffset)
    background:Show();
  else
    region.background:Hide();
  end

  function region:IsSuspended()
    return not WeakAuras.IsLoginFinished() or self.suspended > 0
  end

  function region:Suspend()
    -- Stops group from repositioning and re-indexing children
    -- Calls to Activate, Deactivate, and Re-index will cache the relevant children
    -- Similarly, Sort, Position, and Resize will be stopped
    -- to be called on the next Resume
    -- for when the group is resumed
    self.suspended = self.suspended + 1
  end

  function region:Resume()
    -- Allows group to re-index and reposition.
    -- TriggersSortUpdatedChildren and PositionChildren to happen
    if self.suspended > 0 then
      self.suspended = self.suspended - 1
    end
    region:RunDelayedActions()
  end

  function region:RunDelayedActions()
    if not self:IsSuspended() then
      if self.needToReload then
        self:ReloadControlledChildren()
      end
      if self.needToSort then
        self:SortUpdatedChildren()
      end
      if self.needToPosition then
        self:PositionChildren()
      end
      if self.needToResize then
        self:Resize()
      end
    end
  end

  local function createRegionData(childData, childRegion, childID, cloneID, dataIndex)
    cloneID = cloneID or ""
    local controlPoint = region.controlPoints:Acquire()
    controlPoint:SetWidth(childRegion:GetWidth())
    controlPoint:SetHeight(childRegion:GetHeight())
    local regionData = {
      data = childData,
      region = childRegion,
      id = childID,
      cloneId = cloneID,
      dataIndex = dataIndex,
      controlPoint = controlPoint,
      parent = region
    }

    if childData.regionType == "text" then
      regionData.dimensions = childRegion
    else
      regionData.dimensions = childData
    end

    controlPoint.regionData = regionData
    childRegion:SetParent(controlPoint)
    region.controlledChildren[childID] = region.controlledChildren[childID] or {}
    region.controlledChildren[childID][cloneID] = controlPoint
    childRegion:SetAnchor(data.selfPoint, controlPoint, data.selfPoint)
    return regionData
  end

  local function getRegionData(childID, cloneID)
    cloneID = cloneID or ""
    local controlPoint
    controlPoint = region.controlledChildren[childID] and region.controlledChildren[childID][cloneID]
    if not controlPoint then return end
    return controlPoint.regionData
  end

  local function releaseRegionData(regionData)
    if region.controlledChildren[regionData.id] then
      region.controlledChildren[regionData.id][regionData.cloneId] = nil
    end
    region.controlPoints:Release(regionData.controlPoint)
  end

  function region:ReloadControlledChildren()
    -- 'forgets' about regions it controls and starts from scratch. Mostly useful when Add()ing the group
    if not self:IsSuspended() then
      Private.StartProfileSystem("dynamicgroup")
      Private.StartProfileAura(data.id)
      self.needToReload = false
      self.sortedChildren = {}
      self.sortStates = {}
      self.growStates = {}
      self.controlledChildren = {}
      self.updatedChildren = {}
      self.controlPoints:ReleaseAll()
      for dataIndex, childID in ipairs(data.controlledChildren) do
        local childRegion, childData = WeakAuras.GetRegion(childID), WeakAuras.GetData(childID)
        if childRegion and childData then
          local regionData = createRegionData(childData, childRegion, childID, nil, dataIndex)
          if childRegion.toShow then
            tinsert(self.sortedChildren, regionData)
            self.updatedChildren[regionData] = true
          end
        end
        if childData and Private.clones[childID] then
          for cloneID, cloneRegion in pairs(Private.clones[childID]) do
            local regionData = createRegionData(childData, cloneRegion, childID, cloneID, dataIndex)
            if cloneRegion.toShow then
              tinsert(self.sortedChildren, regionData)
              self.updatedChildren[regionData] = true
            end
          end
        end
      end
      Private.StopProfileSystem("dynamicgroup")
      Private.StopProfileAura(data.id)
      self:SortUpdatedChildren()
    else
      self.needToReload = true
    end
  end

  function region:AddChild(childID, cloneID)
    -- adds regionData to the store.
    -- this is useful mostly for when clones are created which we didn't know about last time Reload was called
    cloneID = cloneID or ""
    if self.controlledChildren[childID] and self.controlledChildren[childID][cloneID] then
      return
    end
    local dataIndex = tIndexOf(data.controlledChildren, childID)
    if not dataIndex then return end
    local childData = WeakAuras.GetData(childID)
    local childRegion = WeakAuras.GetRegion(childID, cloneID)
    if not childData or not childRegion then return end
    local regionData = createRegionData(childData, childRegion, childID, cloneID, dataIndex)
    if childRegion.toShow then
      tinsert(self.sortedChildren, regionData)
      self.updatedChildren[regionData] = true
    end
    self:SortUpdatedChildren()
  end

  function region:ActivateChild(childID, cloneID)
    -- Causes the group to start controlling its order and position
    -- Called in the child's Expand() method
    local regionData = getRegionData(childID, cloneID)
    if not regionData then
      return self:AddChild(childID, cloneID)
    end
    if not regionData.region.toShow then return end
    -- it's possible that while paused, we might get Activate, Deactivate, Activate on the same child
    -- so we need to check if this child has been updated since the last Sort
    -- if it has been, then don't insert it again
    if not regionData.active and self.updatedChildren[regionData] == nil then
      tinsert(self.sortedChildren, regionData)
      self.updatedChildren[regionData] = true
      self:SortUpdatedChildren()
    elseif isDifferent(regionData, self.sortStates, self.sortOn) then
      self.updatedChildren[regionData] = true
      self:SortUpdatedChildren()
    elseif isDifferent(regionData, self.growStates, self.growOn) then
      self:PositionChildren()
    end
  end

  function region:RemoveChild(childID, cloneID)
    -- removes something from the store. Mostly useful when a clone gets released
    -- so that we don't step on our own feet.
    local regionData = getRegionData(childID, cloneID)
    if not regionData then return end
    releaseRegionData(regionData)
    self.updatedChildren[regionData] = false
    clearCache(self.sortStates, childID, cloneID)
    clearCache(self.growStates, childID, cloneID)
    self:SortUpdatedChildren()
  end

  function region:DeactivateChild(childID, cloneID)
    -- Causes the group to stop controlling its order and position
    -- Called in the child's Collapse() method
    local regionData = getRegionData(childID, cloneID)
    if regionData and not regionData.region.toShow then
      self.updatedChildren[regionData] = false
    end
    clearCache(self.sortStates, childID, cloneID)
    clearCache(self.growStates, childID, cloneID)
    self:SortUpdatedChildren()
  end

  region.sortFunc, region.sortOn = createSortFunc(data)

  function region:SortUpdatedChildren()
    -- iterates through cache to insert all updated children in the right spot
    -- Called when the Group is Resume()d
    -- uses sort data to determine the correct spot
    if not self:IsSuspended() then
      Private.StartProfileSystem("dynamicgroup")
      Private.StartProfileAura(data.id)
      self.needToSort = false
      local i = 1
      while self.sortedChildren[i] do
        local regionData = self.sortedChildren[i]
        local active = self.updatedChildren[regionData]
        if active ~= nil then
          regionData.active = active
        end
        if active == false then
          -- i now refers to what was i + 1, so don't increment
          tremove(self.sortedChildren, i)
        else
          local j = i
          while j > 1 do
            local otherRegionData = self.sortedChildren[j - 1]
            if not (active or self.updatedChildren[otherRegionData])
            or not self.sortFunc(regionData, otherRegionData) then
              break
            else
              self.sortedChildren[j] = otherRegionData
              j = j - 1
              self.sortedChildren[j] = regionData
            end
          end
          i = i + 1
        end
      end
      self.updatedChildren = {}
      Private.StopProfileSystem("dynamicgroup")
      Private.StopProfileAura(data.id)
      self:PositionChildren()
    else
      self.needToSort = true
    end
  end

  region.growFunc, region.growOn = createGrowFunc(data)
  region.anchorPerUnit = data.useAnchorPerUnit and data.anchorPerUnit

  local animate = data.animate
  function region:PositionChildren()
    -- Repositions active children according to their index
    -- Positioning is based on grow information from the data
    if not self:IsSuspended() then
      self.needToPosition = false
      if #self.sortedChildren > 0 then
        if animate then
          Private.RegisterGroupForPositioning(data.uid, self)
        else
          self:DoPositionChildren()
        end
      else
        self:Resize()
      end
    else
      self.needToPosition = true
    end
  end

  function region:DoPositionChildrenPerFrame(frame, positions, handledRegionData)
    for regionData, pos in pairs(positions) do
      if type(regionData) ~= "table" then
        break;
      end
      handledRegionData[regionData] = true
      local x, y, show =  type(pos[1]) == "number" and pos[1] or 0,
                          type(pos[2]) == "number" and pos[2] or 0,
                          type(pos[3]) ~= "boolean" and true or pos[3]

      local controlPoint = regionData.controlPoint
      controlPoint:ClearAnchorPoint()
      if frame == "" then
        controlPoint:SetAnchorPoint(
          data.selfPoint,
          self,
          data.selfPoint,
          x, y
        )
      else
        controlPoint:SetAnchorPoint(
          data.selfPoint,
          frame,
          data.anchorPoint,
          x + data.xOffset, y + data.yOffset
        )
      end
      controlPoint:SetShown(show and frame ~= WeakAuras.HiddenFrames)
      controlPoint:SetWidth(regionData.dimensions.width)
      controlPoint:SetHeight(regionData.dimensions.height)
      if (data.anchorFrameParent or data.anchorFrameParent == nil)
      and (
        data.useAnchorPerUnit
        or (
          not data.useAnchorPerUnit
          and not (data.anchorFrameType == "SCREEN" or data.anchorFrameType == "UIPARENT" or data.anchorFrameType == "MOUSE")
        )
      )
      then
        local parent
        if frame == "" then
          parent = self.relativeTo
        else
          if type(frame) == "string" then
            parent = _G[frame]
          else
            parent = frame
          end
        end
        if parent and parent.IsObjectType and parent:IsObjectType("Frame") then
          controlPoint:SetParent(parent)
          controlPoint:SetScale(data.scale and data.scale > 0 and data.scale <= 10 and data.scale or 1)
        end
      else
        controlPoint:SetParent(self)
        controlPoint:SetScale(1)
      end

      local childData = controlPoint.regionData.data
      local childRegion = controlPoint.regionData.region
      if(childData.frameStrata == 1) then
        childRegion:SetFrameStrata(region:GetFrameStrata());
      else
        childRegion:SetFrameStrata(Private.frame_strata_types[childData.frameStrata]);
      end
      Private.ApplyFrameLevel(childRegion)

      if self.anchorPerUnit == "UNITFRAME" then
        Private.dyngroup_unitframe_monitor[regionData] = frame
      end
      if animate then
        Private.CancelAnimation(regionData.controlPoint, true)
        local xPrev = regionData.xOffset or x
        local yPrev = regionData.yOffset or y
        local xDelta = xPrev - x
        local yDelta = yPrev - y
        if show and (abs(xDelta) > 0.01 or abs(yDelta) > 0.01) then
          local anim
          if data.grow == "CIRCLE" or data.grow == "COUNTERCIRCLE" then
            local originX, originY = 0,0
            local radius1, previousAngle = WeakAuras.GetPolarCoordinates(xPrev, yPrev, originX, originY)
            local radius2, newAngle = WeakAuras.GetPolarCoordinates(x, y, originX, originY)
            local dAngle = newAngle - previousAngle
            dAngle = ((dAngle > 180 and dAngle - 360) or (dAngle < -180 and dAngle + 360) or dAngle)
            if(math.abs(radius1 - radius2) > 0.1) then
              local translateFunc = [[
                                function(progress, _, _, previousAngle, dAngle)
                                    local previousRadius, dRadius = %f, %f;
                                    local targetX, targetY = %f, %f
                                    local radius = previousRadius + (1 - progress) * dRadius;
                                    local angle = previousAngle + (1 - progress) * dAngle;
                                    return cos(angle) * radius - targetX, sin(angle) * radius - targetY;
                                end
                            ]]
              anim = {
                type = "custom",
                duration = 0.2,
                use_translate = true,
                translateType = "custom",
                translateFunc = translateFunc:format(radius1, radius2 - radius1, x, y),
                x = previousAngle,
                y = dAngle,
                selfPoint = data.selfPoint,
                anchor = self,
                anchorPoint = data.selfPoint,
              }
            else
              local translateFunc = [[
                                function(progress, _, _, previousAngle, dAngle)
                                    local radius = %f;
                                    local targetX, targetY = %f, %f
                                    local angle = previousAngle + (1 - progress) * dAngle;
                                    return cos(angle) * radius - targetX, sin(angle) * radius - targetY;
                                end
                            ]]
              anim = {
                type = "custom",
                duration = 0.2,
                use_translate = true,
                translateType = "custom",
                translateFunc = translateFunc:format(radius1, x, y),
                x = previousAngle,
                y = dAngle,
                selfPoint = data.selfPoint,
                anchor = self,
                anchorPoint = data.selfPoint,
              }
            end
          end
          if not(anim) then
            anim = {
              type = "custom",
              duration = 0.2,
              use_translate = true,
              x = xDelta,
              y = yDelta,
              selfPoint = data.selfPoint,
              anchor = self,
              anchorPoint = data.selfPoint,
            }
          end
          -- update animated expand & collapse for this child
          Private.Animate("controlPoint", data.uid, "controlPoint", anim, regionData.controlPoint, true)
        end
      end
      regionData.xOffset = x
      regionData.yOffset = y
      regionData.shown = show
    end
  end

  function region:DoPositionChildren()
    Private.StartProfileSystem("dynamicgroup")
    Private.StartProfileAura(data.id)

    local handledRegionData = {}

    local newPositions = {}
    self.growFunc(newPositions, self.sortedChildren)
    if #newPositions > 0 then
      for index = 1, #newPositions do
        if type(newPositions[index]) == "table" then
          local data = self.sortedChildren[index]
          if data then
            newPositions[data] = newPositions[index]
          else
            geterrorhandler()(("Error in '%s', Grow function return position for an invalid region"):format(region.id))
          end
          newPositions[index] = nil
        end
      end
      region:DoPositionChildrenPerFrame("", newPositions, handledRegionData)
    else
      for frame, positions in pairs(newPositions) do
        region:DoPositionChildrenPerFrame(frame, positions, handledRegionData)
      end
    end

    for index, child in ipairs(self.sortedChildren) do
      if not handledRegionData[child] then
        child.controlPoint:SetShown(false)
      end
    end

    Private.StopProfileSystem("dynamicgroup")
    Private.StopProfileAura(data.id)
    self:Resize()
  end


  function region:Resize()
    -- Resizes the dynamic group, for background and border purposes
    if not self:IsSuspended() then
      self.needToResize = false
      -- if self.dynamicAnchor then self:UpdateBorder(); return end
      Private.StartProfileSystem("dynamicgroup")
      Private.StartProfileAura(data.id)
      local numVisible, minX, maxX, maxY, minY = 0, nil, nil, nil, nil
      local isRestricted = region:IsAnchoringRestricted()
      if isRestricted and not WeakAuras.IsOptionsOpen() then
        -- workaround for restricted anchor families (mostly PRD)
        -- if region is in a restricted anchor family, we're not allowed to get the rect of its children
        -- and via Blizzard's extremely finite wisdom, the personal resource display is one such restricted family
        -- so, temporarily reanchor to unrestrict us & child auras
        region:RealClearAllPoints()
        region:SetPoint("CENTER", UIParent, "CENTER")
      end
      for active, regionData in ipairs(self.sortedChildren) do
        if regionData.shown then
          numVisible = numVisible + 1
          local childRegion = regionData.region
          local regionLeft, regionRight, regionTop, regionBottom
             = SafeGetPos(childRegion, childRegion.GetLeft), SafeGetPos(childRegion, childRegion.GetRight),
               SafeGetPos(childRegion, childRegion.GetTop), SafeGetPos(childRegion, childRegion.GetBottom)

          if(regionLeft and regionRight and regionTop and regionBottom) then
            minX = minX and min(regionLeft, minX) or regionLeft
            maxX = maxX and max(regionRight, maxX) or regionRight
            minY = minY and min(regionBottom, minY) or regionBottom
            maxY = maxY and max(regionTop, maxY) or regionTop
          end
        end
      end

      if numVisible > 0 then
        self:Show()
        minX, maxX, minY, maxY = (minX or 0), (maxX or 0), (minY or 0), (maxY or 0)

        local width, height = maxX - minX, maxY - minY
        width = width > 0 and width or 16
        height = height > 0 and height or 16

        self:SetWidth(width)
        self:SetHeight(height)
        self.currentWidth = width
        self.currentHeight = height

        if data.border and not data.useAnchorPerUnit then
          local regionLeft = SafeGetPos(region, region.GetLeft) or minX
          local regionBottom = SafeGetPos(region, region.GetBottom) or minY
          if regionLeft and regionBottom then
            self.background:ClearAllPoints()
            self.background:SetPoint("BOTTOMLEFT", region, "BOTTOMLEFT", minX + -1 * data.borderOffset - regionLeft, minY + -1 * data.borderOffset - regionBottom)
            self.background:SetPoint("TOPRIGHT", region, "BOTTOMLEFT", maxX + data.borderOffset - regionLeft, maxY + data.borderOffset - regionBottom)
          end
        end
      else
        self:Hide()
      end
      if WeakAuras.IsOptionsOpen() then
        Private.OptionsFrame().moversizer:ReAnchor()
      elseif isRestricted then
        self:ReAnchor()
      end
      Private.StopProfileSystem("dynamicgroup")
      Private.StopProfileAura(data.id)
    else
      self.needToResize = true
    end
  end

  region:ReloadControlledChildren()

  Private.regionPrototype.modifyFinish(parent, region, data)
end

Private.RegisterRegionType("dynamicgroup", create, modify, default)


-- ========================================
-- File: WeakAuras/RegionTypes/Empty.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

local default = {
  width = 200,
  height = 200,
  selfPoint = "CENTER",
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  frameStrata = 1
}

Private.regionPrototype.AddAlphaToDefault(default)

local properties = {
}


Private.regionPrototype.AddProperties(properties, default);

local function create(parent)
  local region = CreateFrame("Frame", nil, UIParent)
  region.regionType = "empty"
  region:SetMovable(true)
  region:SetResizable(true)
  region:SetResizeBounds(1, 1)

  region.Update = function()
    region:UpdateProgress()
  end

  Private.regionPrototype.create(region)
  return region
end

local function modify(parent, region, data)
  Private.regionPrototype.modify(parent, region, data)
  region:SetWidth(data.width)
  region:SetHeight(data.height)
  region.width = data.width
  region.height = data.height
  region.scalex = 1
  region.scaley = 1
  Private.regionPrototype.modifyFinish(parent, region, data)
end

Private.RegisterRegionType("empty", create, modify, default, properties)


-- ========================================
-- File: WeakAuras/RegionTypes/Group.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");

-- Default settings
local default = {
  controlledChildren = {},
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  frameStrata = 1,
  border = false,
  borderColor = { 0, 0, 0, 1 },
  backdropColor = { 1, 1, 1, 0.5 },
  borderEdge = "Square Full White",
  borderOffset = 4,
  borderInset = 1,
  borderSize = 2,
  borderBackdrop = "Blizzard Tooltip",
  scale = 1,
};

Private.regionPrototype.AddAlphaToDefault(default);

-- Called when first creating a new region/display
local function create(parent)
  -- Main region
  local region = CreateFrame("Frame", nil, parent);
  region.regionType = "group"
  region:SetMovable(true);
  region:SetWidth(2);
  region:SetHeight(2);

  -- Border region
  local border = CreateFrame("Frame", nil, region, "BackdropTemplate")
  region.border = border;

  Private.regionPrototype.create(region);

  local oldSetFrameLevel = region.SetFrameLevel
  region.SetFrameLevel = function(self, level)
    oldSetFrameLevel(self, level)
    self.border:SetFrameLevel(level)
  end

  return region;
end

-- Calculate bounding box
local function getRect(data, region)
  -- Temp variables
  local blx, bly, trx, try;
  blx, bly = data.xOffset or 0, data.yOffset or 0;

  local width = data.width or (region and  region.width)
  local height = data.height or (region and  region.height)

  if width == nil or height == nil then
    return blx, bly, blx, bly;
  end

  -- Calc bounding box
  if(data.selfPoint:find("LEFT")) then
    trx = blx + width;
  elseif(data.selfPoint:find("RIGHT")) then
    trx = blx;
    blx = blx - width;
  else
    blx = blx - (width/2);
    trx = blx + width;
  end
  if(data.selfPoint:find("BOTTOM")) then
    try = bly + height;
  elseif(data.selfPoint:find("TOP")) then
    try = bly;
    bly = bly - height;
  else
    bly = bly - (height/2);
    try = bly + height;
  end

  -- Return data
  return blx, bly, trx, try;
end

-- Modify a given region/display
local function modify(parent, region, data)
  if data.information.groupOffset then
    data.selfPoint = "BOTTOMLEFT";
  else
    data.selfPoint = "CENTER";
  end
  Private.regionPrototype.modify(parent, region, data);
  -- Localize
  local border = region.border;

  -- Scale
  region:SetScale(data.scale and data.scale > 0 and data.scale <= 10 and data.scale or 1)

  region.GetBoundingRect = function(self)
    if not self.boundingRect then
      local leftest, rightest, lowest, highest = 0, 0, 0, 0;
      for child in Private.TraverseLeafs(data) do
        local childRegion = WeakAuras.GetRegion(child.id)
        if(child) then
          local blx, bly, trx, try = getRect(child, childRegion);
          leftest = math.min(leftest, blx);
          rightest = math.max(rightest, trx);
          lowest = math.min(lowest, bly);
          highest = math.max(highest, try);
        end
      end
      self.blx = leftest
      self.bly = lowest
      self.trx = rightest
      self.try = highest
      self.boundingRect = true
    end
    return self.blx, self.bly, self.trx, self.try
  end
  region.boundingRect = false

  -- Adjust frame-level sorting
  Private.FixGroupChildrenOrderForGroup(data);

  local hasDynamicSubGroups = false
  for index, childId in pairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId);
    if childData.regionType == "dynamicgroup" then
      hasDynamicSubGroups = true
      break;
    end
  end

  if not hasDynamicSubGroups then
    -- Control children (does not happen with "group")
    function region:UpdateBorder(childRegion)
      local border = region.border;
      -- Apply border settings
      if data.border then
        -- Initial visibility (of child that originated UpdateBorder(...))
        local childVisible = childRegion and childRegion.toShow or false;

        -- Scan children for visibility
        if not childVisible then
          for child in Private.TraverseLeafs(data) do
            local childRegion = Private.regions[child.id] and Private.regions[child.id].region;
            if childRegion and childRegion.toShow then
              childVisible = true;
              break;
            end
          end
        end

        -- Show border if child is visible
        if childVisible then
          local blx, bly, trx, try = self:GetBoundingRect()

          border:SetBackdrop({
            edgeFile = data.borderEdge ~= "None" and SharedMedia:Fetch("border", data.borderEdge) or "",
            edgeSize = data.borderSize,
            bgFile = data.borderBackdrop ~= "None" and SharedMedia:Fetch("background", data.borderBackdrop) or "",
            insets = {
              left     = data.borderInset,
              right     = data.borderInset,
              top     = data.borderInset,
              bottom     = data.borderInset,
            },
          });
          border:SetBackdropBorderColor(data.borderColor[1], data.borderColor[2], data.borderColor[3], data.borderColor[4]);
          border:SetBackdropColor(data.backdropColor[1], data.backdropColor[2], data.backdropColor[3], data.backdropColor[4]);

          border:ClearAllPoints();
          border:SetPoint("bottomleft", region, "bottomleft", blx - data.borderOffset, bly - data.borderOffset);
          border:SetPoint("topright",   region, "topright",   trx + data.borderOffset, try + data.borderOffset);
          border:Show();
        else
          border:Hide();
        end
      else
        border:Hide();
      end
    end
    region:UpdateBorder()
  else
    region.UpdateBorder = function() end
    region.border:Hide()
  end

  Private.regionPrototype.modifyFinish(parent, region, data);
end

-- Register new region type with WeakAuras
Private.RegisterRegionType("group", create, modify, default);


-- ========================================
-- File: WeakAuras/RegionTypes/Icon.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L
local MSQ = LibStub("Masque", true);
if MSQ then
  MSQ:AddType("WA_Aura", {"Icon", "Cooldown"})
end

-- WoW API
local _G = _G

local default = {
  icon = true,
  desaturate = false,
  iconSource = -1,
  progressSource = {-1, "" },
  adjustedMax = "",
  adjustedMin = "",
  inverse = false,
  width = 64,
  height = 64,
  color = {1, 1, 1, 1},
  selfPoint = "CENTER",
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  zoom = 0,
  keepAspectRatio = false,
  frameStrata = 1,
  cooldown = true,
  cooldownTextDisabled = false,
  cooldownSwipe = true,
  cooldownEdge = false,
  useCooldownModRate = true
};

Private.regionPrototype.AddProgressSourceToDefault(default)
Private.regionPrototype.AddAlphaToDefault(default);

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;

local properties = {
  desaturate = {
    display = L["Desaturate"],
    setter = "SetDesaturated",
    type = "bool",
  },
  width = {
    display = L["Width"],
    setter = "SetRegionWidth",
    type = "number",
    min = 1,
    softMax = screenWidth,
    bigStep = 1,
    default = 32
  },
  height = {
    display = L["Height"],
    setter = "SetRegionHeight",
    type = "number",
    min = 1,
    softMax = screenHeight,
    bigStep = 1,
    default = 32
  },
  color = {
    display = L["Color"],
    setter = "Color",
    type = "color"
  },
  inverse = {
    display = L["Inverse"],
    setter = "SetInverse",
    type = "bool"
  },
  cooldownSwipe = {
    display = { L["Cooldown"], L["Swipe"], true},
    setter = "SetCooldownSwipe",
    type = "bool",
  },
  cooldownEdge = {
    display = { L["Cooldown"], L["Edge"]},
    setter = "SetCooldownEdge",
    type = "bool",
  },
  cooldownTextDisabled = {
    display = { L["Cooldown"], L["Hide Timer Text"]},
    setter = "SetHideCountdownNumbers",
    type = "bool",
  },
  zoom = {
    display = L["Zoom"],
    setter = "SetZoom",
    type = "number",
    min = 0,
    max = 1,
    step = 0.01,
    default = 0,
    isPercent = true
  },
  iconSource = {
    display = {L["Icon"], L["Source"]},
    setter = "SetIconSource",
    type = "list",
    values = {}
  },
  displayIcon = {
    display = {L["Icon"], L["Manual"]},
    setter = "SetIcon",
    type = "icon",
  }
};

Private.regionPrototype.AddProperties(properties, default);

local function GetProperties(data)
  local result = CopyTable(properties)
  result.iconSource.values = Private.IconSources(data)
  result.progressSource.values = Private.GetProgressSourcesForUi(data)
  return result
end

local function GetTexCoord(region, texWidth, aspectRatio, xOffset, yOffset)
  region.currentCoord = region.currentCoord or {}
  local usesMasque = false
  if region.MSQGroup then
    local db = region.MSQGroup.db
    if db and not db.Disabled then
      usesMasque = true
      region.currentCoord[1], region.currentCoord[2], region.currentCoord[3], region.currentCoord[4],
        region.currentCoord[5], region.currentCoord[6], region.currentCoord[7], region.currentCoord[8]
        = region.icon:GetTexCoord()
    end
  end
  if (not usesMasque) then
    region.currentCoord[1], region.currentCoord[2], region.currentCoord[3], region.currentCoord[4],
      region.currentCoord[5], region.currentCoord[6], region.currentCoord[7], region.currentCoord[8]
      = 0, 0, 0, 1, 1, 0, 1, 1;
  end

  local xRatio = aspectRatio < 1 and aspectRatio or 1;
  local yRatio = aspectRatio > 1 and 1 / aspectRatio or 1;
  for i, coord in ipairs(region.currentCoord) do
    if(i % 2 == 1) then
      region.currentCoord[i] = (coord - 0.5) * texWidth * xRatio + 0.5 - xOffset;
    else
      region.currentCoord[i] = (coord - 0.5) * texWidth * yRatio + 0.5 - yOffset;
    end
  end

  return unpack(region.currentCoord)
end

local function AnchorSubRegion(self, subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
  if type(anchorPoint) == "string" and anchorPoint:sub(1, 4) == "sub." then
    Private.regionPrototype.AnchorSubRegion(self, subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
    return
  end

  if anchorType == "area" then
    Private.regionPrototype.AnchorSubRegion(selfPoint == "region" and self or self.icon,
                    subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
  else
    subRegion:ClearAllPoints()
    anchorPoint = anchorPoint or "CENTER"
    local anchorRegion = self.icon
    if anchorPoint:sub(1, 6) == "INNER_" then
      if not self.inner then
        self.inner = CreateFrame("Frame", nil, self)
        self.inner:SetPoint("CENTER")
        self.UpdateInnerOuterSize()
      end
      anchorRegion = self.inner
      anchorPoint = anchorPoint:sub(7)
    elseif anchorPoint:sub(1, 6) == "OUTER_" then
      if not self.outer then
        self.outer = CreateFrame("Frame", nil, self)
        self.outer:SetPoint("CENTER")
        self.UpdateInnerOuterSize()
      end
      anchorRegion = self.outer
      anchorPoint = anchorPoint:sub(7)
    end
    anchorXOffset = anchorXOffset or 0
    anchorYOffset = anchorYOffset or 0

    if not Private.point_types[selfPoint] then
      selfPoint = "CENTER"
    end

    if not Private.point_types[anchorPoint] then
      anchorPoint = "CENTER"
    end

    subRegion:SetPoint(selfPoint, anchorRegion, anchorPoint, anchorXOffset, anchorYOffset)
  end
end

local function create(parent, data)
  local font = "GameFontHighlight";

  local region = CreateFrame("Frame", nil, parent);
  --- @cast region table|Frame
  region.regionType = "icon"
  region:SetMovable(true);
  region:SetResizable(true);
  region:SetResizeBounds(1, 1)

  function region.UpdateInnerOuterSize()
    local width = region.width * math.abs(region.scalex);
    local height = region.height * math.abs(region.scaley);

    local iconWidth
    local iconHeight

    if MSQ then
      iconWidth = region.button:GetWidth()
      iconHeight = region.button:GetHeight()
    else
      iconWidth = region:GetWidth()
      iconHeight = region:GetHeight()
    end

    if region.inner then
      region.inner:SetSize(iconWidth - 0.2 * width, iconHeight - 0.2 * height)
    end
    if region.outer then
      region.outer:SetSize(iconWidth + 0.1 * width, iconHeight + 0.1 * height)
    end
  end

  local button
  if MSQ then
    button = CreateFrame("Button", nil, region)
    --- @cast button table|Button
    button.data = data
    region.button = button;
    button:EnableMouse(false);
    button:Disable();
    button:SetAllPoints();
  end

  local icon = region:CreateTexture(nil, "BACKGROUND");
  icon:SetSnapToPixelGrid(false)
  icon:SetTexelSnappingBias(0)
  if MSQ then
    icon:SetAllPoints(button);
    button:SetScript("OnSizeChanged", region.UpdateInnerOuterSize);
  else
    icon:SetAllPoints(region);
    region:SetScript("OnSizeChanged", region.UpdateInnerOuterSize);
  end
  region.icon = icon;
  icon:SetTexture("Interface\\Icons\\INV_Misc_QuestionMark");

  --This section creates a unique frame id for the cooldown frame so that it can be created with a global reference
  --The reason is so that WeakAuras cooldown frames can interact properly with OmniCC
  -- (i.e., put on its ignore list for timer overlays)
  local id = data.id;
  local frameId = id:lower():gsub(" ", "_");
  if(_G["WeakAurasCooldown"..frameId]) then
    local baseFrameId = frameId;
    local num = 2;
    while(_G["WeakAurasCooldown"..frameId]) do
      frameId = baseFrameId..num;
      num = num + 1;
    end
  end
  region.frameId = frameId;

  local cooldown = CreateFrame("Cooldown", "WeakAurasCooldown"..frameId, region, "CooldownFrameTemplate");
  region.cooldown = cooldown;
  cooldown:SetAllPoints(icon);
  cooldown:SetDrawBling(false)
  cooldown.SetDrawSwipeOrg = cooldown.SetDrawSwipe
  cooldown.SetDrawSwipe = function() end

  if not OmniCC and ElvUI and ElvUI[1] and ElvUI[1].CooldownEnabled
     and ElvUI[1].RegisterCooldown and ElvUI[1]:CooldownEnabled()
  then
    ElvUI[1]:RegisterCooldown(cooldown, "WeakAuras");
  end

  local SetFrameLevel = region.SetFrameLevel;

  function region.SetFrameLevel(self, level)
    SetFrameLevel(region, level);
    cooldown:SetFrameLevel(level);
    if button then
      button:SetFrameLevel(level);
    end
  end

  Private.regionPrototype.create(region);

  region.AnchorSubRegion = AnchorSubRegion

  return region;
end

local function modify(parent, region, data)
  -- Legacy members stacks and text2
  region.stacks = nil
  region.text2 = nil

  Private.regionPrototype.modify(parent, region, data);

  local button, icon, cooldown = region.button, region.icon, region.cooldown;

  region.iconSource = data.iconSource
  region.displayIcon = data.displayIcon

  if MSQ then
    local masqueId = data.id:lower():gsub(" ", "_");
    if region.masqueId ~= masqueId then
      region.masqueId = masqueId
      region.MSQGroup = MSQ:Group("WeakAuras", region.masqueId, data.uid);
      region.MSQGroup:SetName(data.id)
      region.MSQGroup:AddButton(button, {Icon = icon, Cooldown = cooldown}, "WA_Aura", true);
      button.data = data
    end
  end

  function region:UpdateSize()
    local width = region.width * math.abs(region.scalex);
    local height = region.height * math.abs(region.scaley);
    region:SetWidth(width);
    region:SetHeight(height);
    if MSQ then
      button:SetWidth(width);
      button:SetHeight(height);
      button:SetAllPoints();
    end
    region:UpdateTexCoords();
  end

  function region:UpdateTexCoords()
    local mirror_h = region.scalex < 0;
    local mirror_v = region.scaley < 0;

    local texWidth = 1 - 0.5 * region.zoom;
    local aspectRatio
    if not region.keepAspectRatio then
      aspectRatio = 1;
    else
      local width = region.width * math.abs(region.scalex);
      local height = region.height * math.abs(region.scaley);

      if width == 0 or height == 0 then
        aspectRatio = 1;
      else
        aspectRatio = width / height;
      end
    end

    if region.MSQGroup then
      region.MSQGroup:ReSkin(button)
    end

    local ulx, uly, llx, lly, urx, ury, lrx, lry
      = GetTexCoord(region, texWidth, aspectRatio, region.texXOffset, -region.texYOffset)

    if(mirror_h) then
      if(mirror_v) then
        icon:SetTexCoord(lrx, lry, urx, ury, llx, lly, ulx, uly)
      else
        icon:SetTexCoord(urx, ury, lrx, lry, ulx, uly, llx, lly)
      end
    else
      if(mirror_v) then
        icon:SetTexCoord(llx, lly, ulx, uly, lrx, lry, urx, ury)
      else
        icon:SetTexCoord(ulx, uly, llx, lly, urx, ury, lrx, lry)
      end
    end
  end

  region.width = data.width;
  region.height = data.height;
  region.scalex = 1;
  region.scaley = 1;
  region.keepAspectRatio = data.keepAspectRatio;
  region.zoom = data.zoom;
  region.texXOffset = data.texXOffset or 0
  region.texYOffset = data.texYOffset or 0
  region:UpdateSize()

  icon:SetDesaturated(data.desaturate);

  local tooltipType = Private.CanHaveTooltip(data);
  if(tooltipType and data.useTooltip) then
    if not region.tooltipFrame then
      region.tooltipFrame = CreateFrame("Frame", nil, region);
      region.tooltipFrame:SetAllPoints(region);
      region.tooltipFrame:SetScript("OnEnter", function()
        Private.ShowMouseoverTooltip(region, region);
      end);
      region.tooltipFrame:SetScript("OnLeave", Private.HideTooltip);
    end
    region.tooltipFrame:EnableMouseMotion(true);
    region.tooltipFrame:SetMouseClickEnabled(false);
  elseif region.tooltipFrame then
    region.tooltipFrame:EnableMouseMotion(false);
  end

  function region:SetInverse(inverse)
    if region.inverseDirection == inverse then
      return
    end

    region.inverseDirection = inverse
    region:UpdateEffectiveInverse()
  end

  function region:UpdateEffectiveInverse()
    -- If cooldown.inverse == false then effectiveReverse = not inverse
    -- If cooldown.inverse == true then effectiveReverse = inverse
    local effectiveReverse = not region.inverseDirection == not cooldown.inverse
    cooldown:SetReverse(effectiveReverse)
    if (cooldown.expirationTime and cooldown.duration and cooldown:IsShown()) then
      -- WORKAROUND SetReverse not applying until next frame
      cooldown:SetCooldown(0, 0)
      cooldown:SetCooldown(cooldown.expirationTime - cooldown.duration,
                           cooldown.duration,
                           cooldown.useCooldownModRate and cooldown.modRate or nil)
    end
  end

  region:SetInverse(data.inverse)

  function region:SetHideCountdownNumbers(cooldownTextDisabled)
    if OmniCC and OmniCC.Cooldown and OmniCC.Cooldown.SetNoCooldownCount then
      cooldown:SetHideCountdownNumbers(true)
      OmniCC.Cooldown.SetNoCooldownCount(cooldown, cooldownTextDisabled)
    elseif ElvUI and ElvUI[1] and ElvUI[1].CooldownEnabled
           and ElvUI[1].ToggleCooldown and ElvUI[1]:CooldownEnabled()
    then
      cooldown:SetHideCountdownNumbers(true)
      ElvUI[1]:ToggleCooldown(cooldown, not cooldownTextDisabled);
    else
      cooldown:SetHideCountdownNumbers(cooldownTextDisabled);
    end
  end
  region:SetHideCountdownNumbers(data.cooldownTextDisabled)

  function region:Color(r, g, b, a)
    region.color_r = r;
    region.color_g = g;
    region.color_b = b;
    region.color_a = a;
    if (r or g or b) then
      a = a or 1;
    end
    icon:SetVertexColor(region.color_anim_r or r, region.color_anim_g or g,
                        region.color_anim_b or b, region.color_anim_a or a)
    if region.button then
      region.button:SetAlpha(region.color_anim_a or a or 1);
    end
  end

  function region:ColorAnim(r, g, b, a)
    region.color_anim_r = r;
    region.color_anim_g = g;
    region.color_anim_b = b;
    region.color_anim_a = a;
    if (r or g or b) then
      a = a or 1;
    end
    icon:SetVertexColor(r or region.color_r, g or region.color_g, b or region.color_b, a or region.color_a);
    if MSQ then
      region.button:SetAlpha(a or region.color_a or 1);
    end
  end

  function region:GetColor()
    return region.color_r or data.color[1], region.color_g or data.color[2],
      region.color_b or data.color[3], region.color_a or data.color[4];
  end

  region:Color(data.color[1], data.color[2], data.color[3], data.color[4]);

  function region:SetIcon(iconPath)
    if self.displayIcon == iconPath then
      return
    end
    self.displayIcon = iconPath
    self:UpdateIcon()
  end

  function region:SetIconSource(source)
    if self.iconSource == source then
      return
    end

    self.iconSource = source
    self:UpdateIcon()
  end

  function region:UpdateIcon()
    local iconPath
    if self.iconSource == -1 then
      iconPath = self.state.icon
    elseif self.iconSource == 0 then
      iconPath = self.displayIcon
    else
      local triggernumber = self.iconSource
      if triggernumber and self.states[triggernumber] then
        iconPath = self.states[triggernumber].icon
      end
    end

    iconPath = iconPath or self.displayIcon or "Interface\\Icons\\INV_Misc_QuestionMark"
    Private.SetTextureOrAtlas(self.icon, iconPath)
  end

  function region:Scale(scalex, scaley)
    if region.scalex == scalex and region.scaley == scaley then
      return
    end
    region.scalex = scalex;
    region.scaley = scaley;
    region:UpdateSize();
  end

  function region:SetDesaturated(b)
    icon:SetDesaturated(b);
  end

  function region:SetRegionWidth(width)
    region.width = width
    region:UpdateSize();
  end

  function region:SetRegionHeight(height)
    region.height = height
    region:UpdateSize();
  end



  function region:SetCooldownSwipe(cooldownSwipe)
    region.cooldownSwipe = cooldownSwipe;
    cooldown:SetDrawSwipeOrg(cooldownSwipe);
  end

  function region:SetCooldownEdge(cooldownEdge)
    region.cooldownEdge = cooldownEdge;
    cooldown:SetDrawEdge(cooldownEdge);
  end

  region:SetCooldownSwipe(data.cooldownSwipe)
  region:SetCooldownEdge(data.cooldownEdge)

  function region:SetZoom(zoom)
    region.zoom = zoom;
    region:UpdateTexCoords();
  end

  cooldown.expirationTime = nil;
  cooldown.duration = nil;
  cooldown.modRate = nil
  cooldown.useCooldownModRate = data.useCooldownModRate
  cooldown:Hide()
  if(data.cooldown) then
    function region:UpdateValue()
      cooldown.value = self.value
      cooldown.total = self.total
      cooldown.modRate = nil
      if (self.value >= 0 and self.value <= self.total) then
        cooldown:Show()
        cooldown:SetCooldown(GetTime() - (self.total - self.value), self.total)
        cooldown:Pause()
      else
        cooldown:Hide();
      end
    end

    function region:UpdateTime()
      if self.paused then
        cooldown:Pause()
      else
        cooldown:Resume()
      end
      if (self.duration > 0 and self.expirationTime > GetTime() and self.expirationTime ~= math.huge) then
        cooldown:Show();
        cooldown.expirationTime = self.expirationTime
        cooldown.duration = self.duration
        cooldown.modRate = self.modRate
        cooldown.inverse = self.inverse
        region:UpdateEffectiveInverse()
        cooldown:SetCooldown(self.expirationTime - self.duration, self.duration,
                             cooldown.useCooldownModRate and self.modRate or nil)
      else
        cooldown.expirationTime = self.expirationTime
        cooldown.duration = self.duration
        cooldown.modRate = self.modRate
        cooldown:Hide();
      end
    end

    function region:PreShow()
      if (cooldown.duration and cooldown.duration > 0.01 and cooldown.duration ~= math.huge and cooldown.expirationTime ~= math.huge) then
        cooldown:Show();
        cooldown:SetCooldown(cooldown.expirationTime - cooldown.duration,
                             cooldown.duration,
                             cooldown.useCooldownModRate and cooldown.modRate or nil);
        cooldown:Resume()
      end
    end

    function region:Update()
      region:UpdateProgress()
      region:UpdateIcon()
    end
  else
    region.UpdateValue = nil
    region.UpdateTime = nil

    function region:Update()
      region:UpdateProgress()
      region:UpdateIcon()
    end
  end

  -- Backwards compability function
  function region:SetGlow(glow)
    for index, subRegion in ipairs(self.subRegions) do
      if subRegion.type == "subglow" then
        subRegion:SetVisible(glow)
      end
    end
  end

  Private.regionPrototype.modifyFinish(parent, region, data);

  --- WORKAROUND
  -- This fixes a issue with barmodels not appearing on icons if the
  -- icon is shown delayed
  region:SetWidth(region:GetWidth())
  region:SetHeight(region:GetHeight())
end

local function validate(data)
  Private.EnforceSubregionExists(data, "subbackground")
end

Private.RegisterRegionType("icon", create, modify, default, GetProperties, validate)


-- ========================================
-- File: WeakAuras/RegionTypes/Model.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

-- Default settings
local default = {
  model_fileId = WeakAuras.IsClassic() and "165589" or "122968", -- spells/arcanepower_state_chest.m2 & Creature/Arthaslichking/arthaslichking.m2
  modelIsUnit = false,
  api = false, -- false ==> SetPosition + SetFacing; true ==> SetTransform
  model_x = 0,
  model_y = 0,
  model_z = 0,
  -- SetTransform
  model_st_tx = 40,
  model_st_ty = 0,
  model_st_tz = 0,
  model_st_rx = 90,
  model_st_ry = 0,
  model_st_rz = 90,
  model_st_us = 40,
  width = 200,
  height = 200,
  sequence = 1,
  advance = false,
  rotation = 0,
  scale = 1,
  selfPoint = "CENTER",
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  frameStrata = 1,
  border = false,
  borderColor = {1.0, 1.0, 1.0, 0.5},
  backdropColor = {1.0, 1.0, 1.0, 0.5},
  borderEdge = "None",
  borderOffset = 5,
  borderInset = 11,
  borderSize = 16,
  borderBackdrop = "Blizzard Tooltip"
};

Private.regionPrototype.AddAlphaToDefault(default)

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;

local properties = {
  width = {
    display = L["Width"],
    setter = "SetRegionWidth",
    type = "number",
    min = 1,
    softMax = screenWidth,
    bigStep = 1,
    default = 32
  },
  height = {
    display = L["Height"],
    setter = "SetRegionHeight",
    type = "number",
    min = 1,
    softMax = screenHeight,
    bigStep = 1,
    default = 32
  },
}

Private.regionPrototype.AddProperties(properties, default);

local function GetProperties(data)
  return properties;
end

local regionFunctions = {
  Update = function() end,
  SetAlpha = function(self, alpha)
    self.alpha = alpha
    if self.model then
      self.model:SetAlpha(alpha)
    end
  end
}

-- Called when first creating a new region/display
local function create(parent)
  -- Main region
  local region = CreateFrame("Frame", nil, UIParent);
  region.regionType = "model"
  region:SetMovable(true);
  region:SetResizable(true);
  region:SetResizeBounds(1, 1)

  -- Border region
  local border = CreateFrame("Frame", nil, region, "BackdropTemplate");
  region.border = border;

  Private.regionPrototype.create(region);

  for k, v in pairs (regionFunctions) do
    region[k] = v
  end

  -- Return complete region
  return region;
end

function Private.ModelSetTransformFixed(self, tx, ty, tz, rx, ry, rz, s)
  -- In Dragonflight the api changed, this converts to the new api
  self:SetTransform(CreateVector3D(tx, ty, tz), CreateVector3D(rx, ry, rz), -s)
end

local function CreateModel()
  local frame = CreateFrame("PlayerModel", nil, UIParent)
  frame.SetTransformFixed = Private.ModelSetTransformFixed
  return frame
end

-- Keep the two model apis separate
local poolOldApi = CreateObjectPool(CreateModel)
local poolNewApi = CreateObjectPool(CreateModel)

local function ConfigureModel(region, model, data)
  model.api = data.api

  model:ClearAllPoints()
  model:SetAllPoints(region)
  model:SetParent(region)
  model:SetKeepModelOnHide(true)
  model:Show()

  -- Adjust model
  WeakAuras.SetModel(model, nil, data.model_fileId, data.modelIsUnit, data.modelDisplayInfo)
  model:SetPortraitZoom(data.portraitZoom and 1 or 0);
  model:ClearTransform()
  if data.api then
    model:MakeCurrentCameraCustom()
    model:SetTransformFixed(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
      rad(data.model_st_rx), rad(data.model_st_ry), rad(region.rotation), data.model_st_us / 1000);
  else
    model:SetPosition(data.model_z, data.model_x, data.model_y);
    model:SetFacing(rad(region.rotation));
  end

  if data.modelIsUnit then
    model:RegisterEvent("UNIT_MODEL_CHANGED");

    local unit = data.model_fileId

    if (unit == "target") then
      model:RegisterEvent("PLAYER_TARGET_CHANGED");
    elseif not WeakAuras.IsClassicEra() and unit == "focus" then
      model:RegisterEvent("PLAYER_FOCUS_CHANGED");
    end
    model:SetScript("OnEvent", function(self, event, unitId)
      Private.StartProfileSystem("model");
      if (event ~= "UNIT_MODEL_CHANGED" or UnitIsUnit(unitId, unit)) then
        WeakAuras.SetModel(model, nil, data.model_fileId, data.modelIsUnit, data.modelDisplayInfo)
        if data.advance then
          model:SetAnimation(data.sequence)
        else
          model:SetAnimation(0)
        end
      end
      Private.StopProfileSystem("model");
    end
    );
  else
    model:UnregisterEvent("UNIT_MODEL_CHANGED");
    model:UnregisterEvent("PLAYER_TARGET_CHANGED");
    if not WeakAuras.IsClassicEra() then
      model:UnregisterEvent("PLAYER_FOCUS_CHANGED");
    end
    model:SetScript("OnEvent", nil);
  end

  -- Enable model animation
  if data.advance then
    model:SetAnimation(data.sequence)
  else
    model:SetAnimation(0)
  end
end

local function AcquireModel(region, data)
  local pool = data.api and poolNewApi or poolOldApi
  local model = pool:Acquire()
  ConfigureModel(region, model, data)
  return model
end

local function ReleaseModel(model)
  model:SetAlpha(1)
  model:SetKeepModelOnHide(false)
  model:Hide()
  model:UnregisterEvent("UNIT_MODEL_CHANGED");
  model:UnregisterEvent("PLAYER_TARGET_CHANGED");
  if not WeakAuras.IsClassicEra() then
    model:UnregisterEvent("PLAYER_FOCUS_CHANGED");
  end
  model:SetScript("OnEvent", nil);
  local pool = model.api and poolNewApi or poolOldApi
  pool:Release(model)
end

-- Modify a given region/display
local function modify(parent, region, data)
  Private.regionPrototype.modify(parent, region, data);
  -- Localize
  local border = region.border;

  if region.model then
    ReleaseModel(region.model)
    region.model = nil
  end

  -- Reset position and size
  region:SetWidth(data.width);
  region:SetHeight(data.height);
  region.width = data.width;
  region.height = data.height;
  region.scalex = 1;
  region.scaley = 1;

  -- Update border
  if data.border then
    border:SetBackdrop({
      edgeFile = SharedMedia:Fetch("border", data.borderEdge),
      edgeSize = data.borderSize,
      bgFile = SharedMedia:Fetch("background", data.borderBackdrop),
      insets = {
        left     = data.borderInset,
        right    = data.borderInset,
        top      = data.borderInset,
        bottom   = data.borderInset,
      },
    });
    border:SetBackdropBorderColor(data.borderColor[1], data.borderColor[2], data.borderColor[3], data.borderColor[4]);
    border:SetBackdropColor(data.backdropColor[1], data.backdropColor[2], data.backdropColor[3], data.backdropColor[4]);

    border:SetPoint("bottomleft", region, "bottomleft", -data.borderOffset, -data.borderOffset);
    border:SetPoint("topright",   region, "topright",    data.borderOffset,  data.borderOffset);

    border:Show();
  else
    border:Hide();
  end
  -- Rescale model display
  function region:Scale(scalex, scaley)
    if(scalex < 0) then
      region.mirror_h = true;
      scalex = scalex * -1;
    else
      region.mirror_h = nil;
    end
    region:SetWidth(region.width * scalex);
    if(scaley < 0) then
      scaley = scaley * -1;
      region.mirror_v = true;
    else
      region.mirror_v = nil;
    end
    region:SetHeight(region.height * scaley);
  end

  function region:SetRegionWidth(width)
    region.width = width;
    region:Scale(region.scalex, region.scaley);
  end

  function region:SetRegionHeight(height)
    region.height = height;
    region:Scale(region.scalex, region.scaley);
  end

  -- Rotate model
  function region:SetAnimRotation(degrees)
    region.animRotation = degrees
    region:UpdateEffectiveRotation()
  end

  function region:SetRotation(degrees)
    region.rotation = degrees
    region:UpdateEffectiveRotation()
  end

  function region:UpdateEffectiveRotation()
    region.effectiveRotation = region.animRotation or region.rotation
    if region.model then
      if data.api then
        region.model:SetTransformFixed(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
          rad(data.model_st_rx), rad(data.model_st_ry), rad(region.effectiveRotation), data.model_st_us / 1000)
      else
        region.model:SetFacing(rad(region.effectiveRotation))
      end
    end
  end

  if data.api then
    region:SetRotation(data.model_st_rz)
  else
    region:SetRotation(data.rotation)
  end

  -- Get model rotation
  function region:GetBaseRotation()
    return region.rotation
  end

  function region:PreShow()
    if not region.model then
      region.model = AcquireModel(self, data)
    else
      ConfigureModel(region, region.model, data)
    end
    if type(data.alpha) == "number" then
      region:SetAlpha(data.alpha)
    end
  end

  function region:PreHide()
    if region.model then
      ReleaseModel(region.model)
      region.model = nil
    end
  end

  Private.regionPrototype.modifyFinish(parent, region, data);
end

-- Work around for movies and world map hiding all models
do
  function Private.PreShowModels(self, event)
    Private.StartProfileSystem("model");
    for id, data in pairs(Private.regions) do
      Private.StartProfileAura(id);
      if data.region and data.region.toShow then
        if (data.regionType == "model") then
          data.region:PreShow();
        end
      end
      Private.StopProfileAura(id);
    end
    for model in pairs(Private.barmodels) do
      model:PreShow()
    end
    Private.StopProfileSystem("model");
  end
end

local function validate(data)
  Private.EnforceSubregionExists(data, "subbackground")
end

-- Register new region type with WeakAuras
Private.RegisterRegionType("model", create, modify, default, GetProperties, validate);


-- ========================================
-- File: WeakAuras/RegionTypes/ProgressTexture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L;

local defaultFont = WeakAuras.defaultFont
local defaultFontSize = WeakAuras.defaultFontSize

-- Credit to CommanderSirow for taking the time to properly craft the TransformPoint function
-- to the enhance the abilities of Progress Textures.
-- Also Credit to Semlar for explaining how circular progress can be shown

-- NOTES:
--  Most SetValue() changes are quite equal (among compress/non-compress)
--  (There is no GUI button for mirror_v, but mirror_h)
--  New/Used variables
--   region.user_x (0) - User defined center x-shift [-1, 1]
--   region.user_y (0) - User defined center y-shift [-1, 1]
--   region.mirror_v (false) - Mirroring along x-axis [bool]
--   region.mirror_h (false) - Mirroring along y-axis [bool]
--   region.scale (1.0) - user defined scaling [1, INF]
--   region.full_rotation (false) - Allow full rotation [bool]

local default = {
  progressSource = {-1, "" },
  adjustedMax = "",
  adjustedMin = "",
  foregroundTexture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura3",
  backgroundTexture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura3",
  desaturateBackground = false,
  desaturateForeground = false,
  sameTexture = true,
  compress = false,
  blendMode = "BLEND",
  textureWrapMode = "CLAMPTOBLACKADDITIVE",
  backgroundOffset = 2,
  width = 200,
  height = 200,
  orientation = "VERTICAL",
  inverse = false,
  foregroundColor = {1, 1, 1, 1},
  backgroundColor = {0.5, 0.5, 0.5, 0.5},
  startAngle = 0,
  endAngle = 360,
  user_x = 0,
  user_y = 0,
  crop_x = 0.41,
  crop_y = 0.41,
  rotation = 0, -- Uses tex coord rotation, called "legacy rotation" in the ui and texRotation in code everywhere else
  auraRotation = 0, -- Uses texture:SetRotation
  selfPoint = "CENTER",
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  font = defaultFont,
  fontSize = defaultFontSize,
  mirror = false,
  frameStrata = 1,
  slantMode = "INSIDE"
};

Private.regionPrototype.AddAlphaToDefault(default);

Private.regionPrototype.AddProgressSourceToDefault(default)

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;

local properties = {
  desaturateForeground = {
    display = L["Desaturate Foreground"],
    setter = "SetForegroundDesaturated",
    type = "bool",
  },
  desaturateBackground = {
    display = L["Desaturate Background"],
    setter = "SetBackgroundDesaturated",
    type = "bool",
  },
  foregroundColor = {
    display = L["Foreground Color"],
    setter = "Color",
    type = "color"
  },
  backgroundColor = {
    display = L["Background Color"],
    setter = "SetBackgroundColor",
    type = "color"
  },
  width = {
    display = L["Width"],
    setter = "SetRegionWidth",
    type = "number",
    min = 1,
    softMax = screenWidth,
    bigStep = 1,
    default = 32
  },
  height = {
    display = L["Height"],
    setter = "SetRegionHeight",
    type = "number",
    min = 1,
    softMax = screenHeight,
    bigStep = 1,
    default = 32
  },
  orientation = {
    display = L["Orientation"],
    setter = "SetOrientation",
    type = "list",
    values = Private.orientation_with_circle_types
  },
  auraRotation = {
    display = L["Rotation"],
    setter = "SetAuraRotation",
    type = "number",
    min = 0,
    max = 360,
    bigStep = 10,
    default = 0
  },
  inverse = {
    display = L["Inverse"],
    setter = "SetInverse",
    type = "bool"
  },
  mirror = {
    display = L["Mirror"],
    setter = "SetMirror",
    type = "bool",
  },
  rotation = {
    display = L["Texture Rotation"],
    setter = "SetTexRotation",
    type = "number",
    min = 0,
    max = 360,
    bigStep = 1,
    default = 0
  },
  crop_x = {
    display = L["Crop X"],
    setter = "SetCropX",
    type = "number",
    min = 0,
    softMax = 2,
    bigStep = 0.01,
    isPercent = true,
  },
  crop_y = {
    display = L["Crop Y"],
    setter = "SetCropY",
    type = "number",
    min = 0,
    softMax = 2,
    bigStep = 0.01,
    isPercent = true,
  },
}

Private.regionPrototype.AddProperties(properties, default);

local function GetProperties(data)
  local overlayInfo = Private.GetOverlayInfo(data);
  local auraProperties = CopyTable(properties)
  auraProperties.progressSource.values = Private.GetProgressSourcesForUi(data)
  if (overlayInfo and next(overlayInfo)) then
    for id, display in ipairs(overlayInfo) do
      auraProperties["overlays." .. id] = {
        display = string.format(L["%s Overlay Color"], display),
        setter = "SetOverlayColor",
        arg1 = id,
        type = "color",
      }
    end
    return auraProperties
  else
    return auraProperties
  end
end


local TextureSetValueFunction = function(self, progress)
  self.progress = progress;
  progress = max(0, progress);
  progress = min(1, progress);
  self.foreground:SetValue(0, progress);
end

local CircularSetValueFunctions = {
  ["CLOCKWISE"] = function(self, progress)
    local startAngle = self.startAngle;
    local endAngle = self.endAngle;
    progress = progress or 0;
    self.progress = progress;

    if (progress < 0) then
      progress = 0;
    end

    if (progress > 1) then
      progress = 1;
    end

    local pAngle = (endAngle - startAngle) * progress + startAngle;
    self.foregroundSpinner:SetProgress(startAngle, pAngle);
  end,
  ["ANTICLOCKWISE"] = function(self, progress)
    local startAngle = self.startAngle;
    local endAngle = self.endAngle;
    progress = progress or 0;
    self.progress = progress;

    if (progress < 0) then
      progress = 0;
    end

    if (progress > 1) then
      progress = 1;
    end
    progress = 1 - progress;

    local pAngle = (endAngle - startAngle) * progress + startAngle;
    self.foregroundSpinner:SetProgress(pAngle, endAngle);
  end
}

local function hideExtraTextures(extraTextures, from)
  for i = from, #extraTextures do
    extraTextures[i]:Hide();
  end
end

local function ensureExtraTextures(region, count)
  local auraRotationRadians = region.auraRotation / 180 * math.pi
  for i = #region.extraTextures + 1, count do
    local extraTexture = Private.LinearProgressTextureBase.create(region, "ARTWORK", min(i, 7));
    Private.LinearProgressTextureBase.modify(extraTexture, {
      offset = 0,
      blendMode = region.foreground:GetBlendMode(),
      desaturated = false,
      auraRotation = auraRotationRadians,
      texture = region.currentTexture,
      textureWrapMode = region.textureWrapMode,
      crop_x = region.crop_x,
      crop_y = region.crop_y,
      user_x = region.user_x,
      user_y = region.user_y,
      mirror = region.mirror,
      texRotation = region.effectiveTexRotation,
      width = region.width,
      height = region.height
    })
    extraTexture:SetOrientation(region.orientation, region.compress, region.slanted, region.slant,
                                region.slantFirst, region.slantMode)
    region.extraTextures[i] = extraTexture;
  end
end

local function ensureExtraSpinners(region, count)
  local auraRotationRadians = region.auraRotation / 180 * math.pi
  for i = #region.extraSpinners + 1, count do
    local extraSpinner = Private.CircularProgressTextureBase.create(region, "OVERLAY", min(i, 7))
    Private.CircularProgressTextureBase.modify(extraSpinner, {
      crop_x = region.crop_x,
      crop_y = region.crop_y,
      mirror = region.mirror,
      texRotation = region.effectiveTexRotation,
      texture = region.currentTexture,
      blendMode = region.foreground:GetBlendMode(),
      desaturated = false,
      auraRotation = auraRotationRadians,
      width = region.width,
      height = region.height,
      offset = 0
    })

    extraSpinner:SetScale(region.scalex, region.scaley)

    region.extraSpinners[i] = extraSpinner
  end
end

local function convertToProgress(rprogress, additionalProgress, adjustMin, totalWidth, inverse, clamp)
  local startProgress = 0;
  local endProgress = 0;

  if (additionalProgress.min and additionalProgress.max) then
    if (totalWidth ~= 0) then
      startProgress = (additionalProgress.min - adjustMin) / totalWidth;
      endProgress = (additionalProgress.max - adjustMin) / totalWidth;

      if (inverse) then
        startProgress = 1 - startProgress;
        endProgress = 1 - endProgress;
      end
    end
  elseif (additionalProgress.direction) then
    local forwardDirection = (additionalProgress.direction or "forward") == "forward";
    if (inverse) then
      forwardDirection = not forwardDirection;
    end
    local width = additionalProgress.width or 0;
    local offset = additionalProgress.offset or 0;
    if (width ~= 0) then
      if (forwardDirection) then
        startProgress = rprogress + offset / totalWidth ;
        endProgress = rprogress + (offset + width) / totalWidth;
      else
        startProgress = rprogress - (width + offset) / totalWidth;
        endProgress = rprogress - offset / totalWidth;
      end
    end
  end

  if (clamp) then
    startProgress = max(0, min(1, startProgress));
    endProgress = max(0, min(1, endProgress));
  end

  return startProgress, endProgress;
end

local function ApplyAdditionalProgressLinear(self, additionalProgress, min, max, inverse)
  self.additionalProgress = additionalProgress;
  self.additionalProgressMin = min;
  self.additionalProgressMax = max;
  self.additionalProgressInverse = inverse;

  local effectiveInverse = (inverse and not self.inverseDirection) or (not inverse and self.inverseDirection);

  if (additionalProgress) then
    ensureExtraTextures(self, #additionalProgress);
    local totalWidth = max - min;
    for index, additionalProgress in ipairs(additionalProgress) do
      local extraTexture = self.extraTextures[index];

      local startProgress, endProgress = convertToProgress(self.progress, additionalProgress, min,
                                                           totalWidth, effectiveInverse, self.overlayclip)
      if ((endProgress - startProgress) == 0) then
        extraTexture:Hide();
      else
        extraTexture:Show();
        local color = self.overlays[index];
        if (color) then
          extraTexture:SetColor(unpack(color));
        else
          extraTexture:SetColor(1, 1, 1, 1);
        end

        extraTexture:SetValue(startProgress, endProgress)
      end
    end

    hideExtraTextures(self.extraTextures, #additionalProgress + 1);
  else
    hideExtraTextures(self.extraTextures, 1);
  end
end

local function ApplyAdditionalProgressCircular(self, additionalProgress, min, max, inverse)
  self.additionalProgress = additionalProgress;
  self.additionalProgressMin = min;
  self.additionalProgressMax = max;
  self.additionalProgressInverse = inverse;

  local effectiveInverse = (inverse and not self.inverseDirection) or (not inverse and self.inverseDirection);

  if (additionalProgress) then
    ensureExtraSpinners(self, #additionalProgress);
    local totalWidth = max - min;
    for index, additionalProgress in ipairs(additionalProgress) do
      local extraSpinner = self.extraSpinners[index];

      local startProgress, endProgress = convertToProgress(self.progress, additionalProgress, min,
                                                           totalWidth, effectiveInverse, self.overlayclip)
      if (endProgress < startProgress) then
        startProgress, endProgress = endProgress, startProgress;
      end

      if (self.orientation == "ANTICLOCKWISE") then
        startProgress, endProgress = 1 - endProgress, 1 - startProgress;
      end

      if ((endProgress - startProgress) == 0) then
        extraSpinner:SetProgress(0, 0)
      else
        local color = self.overlays[index];
        if (color) then
          extraSpinner:SetColor(unpack(color));
        else
          extraSpinner:SetColor(1, 1, 1, 1);
        end

        local startAngle = self.startAngle;
        local diffAngle = self.endAngle - startAngle;
        local pAngleStart = diffAngle * startProgress + startAngle;
        local pAngleEnd = diffAngle * endProgress + startAngle;

        if (pAngleStart < 0) then
          pAngleStart = pAngleStart + 360;
          pAngleEnd = pAngleEnd + 360;
        end

        extraSpinner:SetProgress(pAngleStart, pAngleEnd)
      end
    end

  else
    hideExtraTextures(self.extraSpinners, 1);
  end
end

local function FrameTick(self)
  local duration = self.duration
  local expirationTime = self.expirationTime
  local inverse = self.inverse

  local progress = 1;
  if (duration ~= 0) then
    local remaining = expirationTime - GetTime();
    progress = remaining / duration;
    local inversed = not inverse ~= not self.inverseDirection
    if(inversed) then
      progress = 1 - progress;
    end
  end

  progress = progress > 0.0001 and progress or 0.0001;

  if (self.useSmoothProgress) then
    self.smoothProgress:SetSmoothedValue(progress);
  else
    self:SetValueOnTexture(progress);
    self:ReapplyAdditionalProgress()
  end
end

local funcs = {
  ForAllSpinners = function(self, f, ...)
    f(self.foregroundSpinner, ...)
    f(self.backgroundSpinner, ...)
    for i, extraSpinner in ipairs(self.extraSpinners) do
      f(extraSpinner, ...)
    end
  end,
  ForAllLinears = function(self, f, ...)
    f(self.foreground, ...)
    f(self.background, ...)
    for _, extraTexture in ipairs(self.extraTextures) do
      f(extraTexture, ...)
    end
  end,
  SetOrientation = function (self, orientation)
    self.orientation = orientation
    if(self.orientation == "CLOCKWISE" or self.orientation == "ANTICLOCKWISE") then
      self.circular = true
      self.foreground:Hide()
      self.background:Hide()
      self.foregroundSpinner:Show()
      self.backgroundSpinner:Show()

      for i = 1, #self.extraTextures do
        self.extraTextures[i]:Hide()
      end
      self.foregroundSpinner:UpdateTextures()
      self.backgroundSpinner:UpdateTextures()
      self.SetValueOnTexture = CircularSetValueFunctions[self.orientation]
      self.ApplyAdditionalProgress = ApplyAdditionalProgressCircular
    else
      self.circular = false
      self.foreground:Show()
      self.background:Show()
      self.foregroundSpinner:Hide()
      self.backgroundSpinner:Hide()

      for i = 1, #self.extraSpinners do
        self.extraSpinners[i]:Hide()
      end
      self.background:SetOrientation(orientation, nil, self.slanted, self.slant,
                                       self.slantFirst, self.slantMode)
      self.foreground:SetOrientation(orientation, self.compress, self.slanted, self.slant,
                                       self.slantFirst, self.slantMode)
      self.SetValueOnTexture = TextureSetValueFunction;
      self.ApplyAdditionalProgress = ApplyAdditionalProgressLinear

      for _, extraTexture in ipairs(self.extraTextures) do
        extraTexture:SetOrientation(orientation, self.compress, self.slanted, self.slant,
                                    self.slantFirst, self.slantMode)
      end
    end
    self:SetValueOnTexture(self.progress)
    self:ReapplyAdditionalProgress()
  end,
  SetAnimRotation = function(self, angle)
    self.texAnimationRotation = angle
    self:UpdateEffectiveRotation()
  end,
  SetTexRotation = function(self, angle)
    self.texRotation = angle
    self:UpdateEffectiveRotation()
  end,
  GetBaseRotation = function(self)
    return self.texRotation
  end,
  Color = function(self, r, g, b, a)
    self.color_r = r
    self.color_g = g
    self.color_b = b
    if (r or g or b) then
      a = a or 1
    end
    self.color_a = a
    self.foreground:SetColor(self.color_anim_r or r, self.color_anim_g or g,
                                   self.color_anim_b or b, self.color_anim_a or a)
    self.foregroundSpinner:SetColor(self.color_anim_r or r, self.color_anim_g or g,
                                    self.color_anim_b or b, self.color_anim_a or a)
  end,
  ColorAnim = function(self, r, g, b, a)
    self.color_anim_r = r
    self.color_anim_g = g
    self.color_anim_b = b
    self.color_anim_a = a
    if (r or g or b) then
      a = a or 1;
    end
    self.foreground:SetColor(r or self.color_r, g or self.color_g, b or self.color_b, a or self.color_a)
    self.foregroundSpinner:SetColor(r or self.color_r, g or self.color_g, b or self.color_b, a or self.color_a)
  end,
  GetColor = function(self)
    return self.color_r, self.color_g, self.color_b, self.color_a
  end,
  SetAuraRotation = function(self, auraRotation)
    self.auraRotation = auraRotation
    local auraRotationRadians = self.auraRotation / 180 * math.pi
    self:ForAllSpinners(self.foregroundSpinner.SetAuraRotation, auraRotationRadians)

    self.background:SetAuraRotation(auraRotationRadians)
    self.foreground:SetAuraRotation(auraRotationRadians)
    for _, extraTexture in ipairs(self.extraTextures) do
      extraTexture:SetAuraRotation(auraRotationRadians)
    end
  end,
  DoPosition = function(self)
    self:SetWidth(self.width * self.scalex);
    self:SetHeight(self.height * self.scaley);

    if self.orientation == "CLOCKWISE" or self.orientation == "ANTICLOCKWISE" then
      self:ForAllSpinners(self.foregroundSpinner.UpdateTextures)
    else
      self:ForAllLinears(self.foreground.Update)
    end
  end,
  SetMirror = function(self, mirror)
    self.mirror = mirror
    self:ForAllSpinners(self.foregroundSpinner.SetMirror, mirror)
    self:ForAllLinears(self.foreground.SetMirror, mirror)
  end,
  UpdateTextures = function(self)
    if self.circular then
      self:ForAllSpinners(self.foregroundSpinner.UpdateTextures)
    else
      self:ForAllLinears(self.foreground.UpdateTextures)
    end
  end,
  SetCropX = function(self, x)
    self.crop_x = 1 + x
    self:ForAllSpinners(self.foregroundSpinner.SetCropX, self.crop_x)
    self:ForAllLinears(self.foreground.SetCropX, self.crop_x)
  end,
  SetCropY = function(self, y)
    self.crop_y = 1 + y
    self:ForAllSpinners(self.foregroundSpinner.SetCropY, self.crop_y)
    self:ForAllLinears(self.foreground.SetCropX, self.crop_x)
  end,
  UpdateEffectiveRotation = function(self)
    self.effectiveTexRotation = self.texAnimationRotation or self.texRotation
    self:ForAllSpinners(self.foregroundSpinner.SetTexRotation, self.effectiveTexRotation)
    self:ForAllLinears(self.foreground.SetTexRotation, self.effectiveTexRotation)
  end,
  UpdateTime = function(self)
    local progress = 1
    if self.duration ~= 0 then
      local remaining = self.expirationTime - GetTime()
      progress = remaining / self.duration
      local inversed = not self.inverse ~= not self.inverseDirection
      if inversed then
        progress = 1 - progress
      end
    end

    progress = progress > 0.0001 and progress or 0.0001;
    if (self.useSmoothProgress) then
      self.smoothProgress:SetSmoothedValue(progress);
    else
      self:SetValueOnTexture(progress);
      self:ReapplyAdditionalProgress()
    end

    if self.paused and self.FrameTick then
      self.FrameTick = nil
      self.subRegionEvents:RemoveSubscriber("FrameTick", self)
    end
    if not self.paused and not self.FrameTick then
      self.FrameTick = FrameTick
      self.subRegionEvents:AddSubscriber("FrameTick", self)
    end
  end,
  UpdateValue = function(self)
    local progress = 1
    if(self.total > 0) then
      progress = self.value / self.total;
      if self.inverseDirection then
        progress = 1 - progress;
      end
    end
    progress = progress > 0.0001 and progress or 0.0001;
    if self.useSmoothProgress then
      self.smoothProgress:SetSmoothedValue(progress);
    else
      self:SetValueOnTexture(progress);
      self:ReapplyAdditionalProgress()
    end

    if self.FrameTick then
      self.FrameTick = nil
      self.subRegionEvents:RemoveSubscriber("FrameTick", self)
    end
  end,
  SetAdditionalProgress = function(self, additionalProgress, currentMin, currentMax, inverse)
    self:ApplyAdditionalProgress(additionalProgress, currentMin, currentMax, inverse)
  end,
  ReapplyAdditionalProgress = function(self)
    self:ApplyAdditionalProgress(self.additionalProgress, self.additionalProgressMin,
                                 self.additionalProgressMax, self.additionalProgressInverse)
  end,
  Update = function(self)
    self:UpdateProgress()
    local state = self.state

    if state.texture then
      self:SetTexture(state.texture)
    end
  end,
  SetTexture = function(self, texture)
    self.currentTexture = texture
    self.foreground:SetTextureOrAtlas(texture, self.textureWrapMode)
    self.foregroundSpinner:SetTextureOrAtlas(texture);
    if self.sameTexture then
      self.background:SetTextureOrAtlas(texture, self.textureWrapMode)
      self.backgroundSpinner:SetTextureOrAtlas(texture);
    end

    for _, extraTexture in ipairs(self.extraTextures) do
      extraTexture:SetTextureOrAtlas(texture, self.textureWrapMode)
    end

    for _, extraSpinner in ipairs(self.extraSpinners) do
      extraSpinner:SetTextureOrAtlas(texture);
    end
  end,
  SetForegroundDesaturated = function(self, b)
    self.foreground:SetDesaturated(b)
    self.foregroundSpinner:SetDesaturated(b)
  end,
  SetBackgroundDesaturated = function(self, b)
    self.background:SetDesaturated(b)
    self.backgroundSpinner:SetDesaturated(b)
  end,
  SetBackgroundColor = function(self, r, g, b, a)
    self.background:SetColor(r, g, b, a)
    self.backgroundSpinner:SetColor(r, g, b, a)
  end,
  SetRegionWidth = function(self, width)
    self.width = width;
    self:ForAllSpinners(self.foregroundSpinner.SetWidth, width)
    self:ForAllLinears(self.foreground.SetWidth, width)
    self:Scale(self.scalex, self.scaley)
  end,
  SetRegionHeight = function(self, height)
    self.height = height
    self:ForAllSpinners(self.foregroundSpinner.SetHeight, height)
    self:ForAllSpinners(self.foreground.SetHeight, height)
    self:Scale(self.scalex, self.scaley)
  end,
  Scale = function(self, scalex, scaley)
    if(scalex < 0) then
      self.mirror_h = true
      scalex = scalex * -1
    end

    if(scaley < 0) then
      self.mirror_v = true
      scaley = scaley * -1
    end

    self.scalex = scalex
    self.scaley = scaley

    self:ForAllSpinners(self.foregroundSpinner.SetScale, self.scalex, self.scaley)
    self:ForAllSpinners(self.foregroundSpinner.SetMirrorHV, self.mirror_h, self.mirror_v)
    self:ForAllLinears(self.foreground.SetMirrorHV, self.mirror_h, self.mirror_v)
    self:DoPosition()
  end,
  SetInverse = function(self, inverse)
    if self.inverseDirection == inverse then
      return
    end
    self.inverseDirection = inverse
    local progress = 1 - self.progress;
    progress = progress > 0.0001 and progress or 0.0001;
    self:SetValueOnTexture(progress)
    self:ReapplyAdditionalProgress()
  end,
  SetOverlayColor = function(self, id, r, g, b, a)
    self.overlays[id] = { r, g, b, a};
    if self.extraTextures[id] then
      self.extraTextures[id]:SetColor(r, g, b, a);
    end
    if self.extraSpinners[id] then
      self.extraSpinners[id]:SetColor(r, g, b, a);
    end
  end
}

local function create(parent)
  local region = CreateFrame("Frame", nil, parent);
  region.regionType = "progresstexture"
  region:SetMovable(true);
  region:SetResizable(true);
  region:SetResizeBounds(1, 1)

  local background = Private.LinearProgressTextureBase.create(region, "BACKGROUND", 0);
  region.background = background;

  -- For horizontal/vertical progress
  local foreground = Private.LinearProgressTextureBase.create(region, "ARTWORK", 0);
  region.foreground = foreground;

  region.foregroundSpinner = Private.CircularProgressTextureBase.create(region, "ARTWORK", 1)
  region.backgroundSpinner = Private.CircularProgressTextureBase.create(region, "BACKGROUND", 1)

  region.extraTextures = {};
  region.extraSpinners = {};

  -- Use a dummy object for the SmoothStatusBarMixin, because our SetValue
  -- is used for a different purpose
  region.smoothProgress = {};
  Mixin(region.smoothProgress, Private.SmoothStatusBarMixin);
  region.smoothProgress.SetValue = function(self, progress)
    region:SetValueOnTexture(progress);
    region:ReapplyAdditionalProgress()
  end

  region.smoothProgress.GetValue = function(self)
    return region.progress;
  end

  region.smoothProgress.GetMinMaxValues = function(self)
    return 0, 1;
  end

  for k, func in pairs(funcs) do
    region[k] = func
  end

  Private.regionPrototype.create(region);

  return region;
end


local function modify(parent, region, data)
  Private.regionPrototype.modify(parent, region, data);

  local background, foreground = region.background, region.foreground;
  local foregroundSpinner, backgroundSpinner = region.foregroundSpinner, region.backgroundSpinner;

  background:Hide()
  foreground:Hide()
  foregroundSpinner:Hide()
  backgroundSpinner:Hide()

  region:SetWidth(data.width);
  region:SetHeight(data.height);
  region.width = data.width;
  region.height = data.height;
  region.scalex = 1;
  region.scaley = 1;
  region.aspect =  data.width / data.height;
  region.overlayclip = data.overlayclip;

  region.textureWrapMode = data.textureWrapMode;
  region.useSmoothProgress = data.smoothProgress
  region.sameTexture = data.sameTexture
  region.mirror = data.mirror
  region.crop_x = 1 + data.crop_x
  region.crop_y = 1 + data.crop_y
  region.texRotation = data.rotation or 0
  region.user_x = -1 * (data.user_x or 0);
  region.user_y = data.user_y or 0;
  region.startAngle = (data.startAngle or 0) % 360;
  region.endAngle = (data.endAngle or 360) % 360;
  if (region.endAngle <= region.startAngle) then
    region.endAngle = region.endAngle + 360;
  end
  region.compress = data.compress;
  region.inverseDirection = data.inverse;
  region.progress = 0.667;
  if (data.overlays) then
    region.overlays = CopyTable(data.overlays)
  else
    region.overlays = {}
  end
  region.slanted = data.slanted;
  region.slant = data.slant;
  region.slantFirst = data.slantFirst;
  region.slantMode = data.slantMode;
  region.auraRotation = data.auraRotation
  region.texRotation = data.rotation

  if region.useSmoothProgress then
    region.PreShow = function()
      region.smoothProgress:ResetSmoothedValue();
    end
  else
    region.PreShow = nil
  end

  region.FrameTick = nil

  local auraRotationRadians = region.auraRotation / 180 * math.pi

  region.currentTexture = data.foregroundTexture

  Private.LinearProgressTextureBase.modify(region.background, {
    offset = data.backgroundOffset,
    texture = data.sameTexture and data.foregroundTexture or data.backgroundTexture,
    textureWrapMode = region.textureWrapMode,
    desaturated = data.desaturateBackground,
    blendMode = data.blendMode,
    auraRotation = auraRotationRadians,
    crop_x = region.crop_x,
    crop_y = region.crop_y,
    user_x = region.user_x,
    user_y = region.user_y,
    mirror = region.mirror,
    texRotation = region.texRotation,
    width = data.width,
    height = data.height
  })

  background:SetColor(data.backgroundColor[1], data.backgroundColor[2],
                      data.backgroundColor[3], data.backgroundColor[4])

  Private.LinearProgressTextureBase.modify(region.foreground, {
    offset = 0,
    texture = data.foregroundTexture,
    textureWrapMode = region.textureWrapMode,
    desaturated = data.desaturateForeground,
    blendMode = data.blendMode,
    auraRotation = auraRotationRadians,
    crop_x = region.crop_x,
    crop_y = region.crop_y,
    user_x = region.user_x,
    user_y = region.user_y,
    mirror = region.mirror,
    texRotation = region.texRotation,
    width = data.width,
    height = data.height
  })

  --- @type LinearProgressTextureOptions
  local linearOptions = {
    offset = 0,
    texture = data.foregroundTexture,
    textureWrapMode = region.textureWrapMode,
    desaturated = false,
    blendMode = data.blendMode,
    auraRotation = auraRotationRadians,
    crop_x = region.crop_x,
    crop_y = region.crop_y,
    user_x = region.user_x,
    user_y = region.user_y,
    mirror = region.mirror,
    texRotation = region.texRotation,
    width = data.width,
    height = data.height
  }
  for _, extraTexture in ipairs(region.extraTextures) do
    Private.LinearProgressTextureBase.modify(extraTexture, linearOptions)
  end

  Private.CircularProgressTextureBase.modify(region.foregroundSpinner, {
    crop_x = region.crop_x,
    crop_y = region.crop_y,
    mirror = data.mirror,
    texRotation = region.texRotation,
    texture = data.foregroundTexture,
    blendMode = data.blendMode,
    desaturated = data.desaturateForeground,
    auraRotation = auraRotationRadians,
    width = data.width,
    height = data.height,
    offset = 0
  })

  Private.CircularProgressTextureBase.modify(region.backgroundSpinner, {
    crop_x = region.crop_x,
    crop_y = region.crop_y,
    mirror = data.mirror,
    texRotation = region.texRotation,
    texture = data.sameTexture and data.foregroundTexture or data.backgroundTexture,
    blendMode = data.blendMode,
    desaturated = data.desaturateBackground,
    auraRotation = auraRotationRadians,
    width = data.width,
    height = data.height,
    offset = data.backgroundOffset
  })

  backgroundSpinner:SetColor(data.backgroundColor[1], data.backgroundColor[2],
                          data.backgroundColor[3], data.backgroundColor[4])
  backgroundSpinner:SetProgress(region.startAngle, region.endAngle)

  --- @type CircularProgressTextureOptions
  local spinnerOptions = {
    crop_x = region.crop_x,
    crop_y = region.crop_y,
    mirror = data.mirror,
    texRotation = region.texRotation,
    texture = data.foregroundTexture,
    blendMode = data.blendMode,
    desaturated = false,
    auraRotation = auraRotationRadians,
    width = data.width,
    height = data.height,
    offset = 0
  }
  for _, extraSpinner in ipairs(region.extraSpinners) do
    Private.CircularProgressTextureBase.modify(extraSpinner, spinnerOptions)
  end

  region:SetOrientation(data.orientation);
  region:DoPosition(region)
  region:Color(data.foregroundColor[1], data.foregroundColor[2], data.foregroundColor[3], data.foregroundColor[4]);

  Private.regionPrototype.modifyFinish(parent, region, data);
end

local function validate(data)
  Private.EnforceSubregionExists(data, "subbackground")
end

Private.RegisterRegionType("progresstexture", create, modify, default, GetProperties, validate);


-- ========================================
-- File: WeakAuras/RegionTypes/RegionPrototype.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;
local GetAtlasInfo = C_Texture and C_Texture.GetAtlasInfo or GetAtlasInfo

Private.regionPrototype = {};

-- Alpha
function Private.regionPrototype.AddAlphaToDefault(default)
  default.alpha = 1.0;
end

-- Progress Sources
function Private.regionPrototype.AddProgressSourceToDefault(default)
  default.progressSource = {-1, ""}
  default.useAdjustededMax = false
  default.useAdjustededMin = false
end

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;

function Private.GetAnchorsForData(data, filter)
  local result = {}
  if not data.controlledChildren then
    if not Private.regionOptions[data.regionType] then
      return
    end

    local anchors
    if Private.regionOptions[data.regionType].getAnchors then
      anchors = Private.regionOptions[data.regionType].getAnchors(data)
    else
      anchors = Private.default_types_for_anchor
    end

    for anchorId, anchorData in pairs(anchors) do
      if anchorData.type == filter then
        result[anchorId] = anchorData.display
      end
    end

    local subElementTypeCounter = {}
    for i, subRegion in ipairs(data.subRegions) do
      subElementTypeCounter[subRegion.type] = (subElementTypeCounter[subRegion.type] or 0) + 1
      local getAnchors = Private.subRegionOptions[subRegion.type].getAnchors
      if getAnchors then
        local subRegionTypeData = Private.subRegionTypes[subRegion.type]

        local anchors = getAnchors(subRegion)
        for key, anchorData in pairs(anchors) do
          if anchorData.type == filter then
            local subElementName = subRegionTypeData.displayName .. " " .. subElementTypeCounter[subRegion.type]
            local anchorId = "sub." .. i .. "." ..  key
            result[anchorId] = {subElementName, anchorData.display}
          end
        end
      end
    end

  end
  return result
end

-- Sound / Chat Message / Custom Code
function Private.regionPrototype.AddProperties(properties, defaultsForRegion)
  properties["sound"] = {
    display = L["Sound"],
    action = "SoundPlay",
    type = "sound",
  };
  properties["chat"] = {
    display = L["Chat Message"],
    action = "SendChat",
    type = "chat",
  };
  properties["customcode"] = {
    display = L["Run Custom Code"],
    action = "RunCode",
    type = "customcode"
  }
  properties["xOffsetRelative"] = {
    display = L["Relative X-Offset"],
    setter = "SetXOffsetRelative",
    type = "number",
    softMin = -screenWidth,
    softMax = screenWidth,
    bigStep = 1
  }
  properties["yOffsetRelative"] = {
    display = L["Relative Y-Offset"],
    setter = "SetYOffsetRelative",
    type = "number",
    softMin = -screenHeight,
    softMax = screenHeight,
    bigStep = 1
  }
  properties["glowexternal"] = {
    display = L["Glow External Element"],
    action = "GlowExternal",
    type = "glowexternal"
  }

  if (defaultsForRegion and defaultsForRegion.alpha) then
    properties["alpha"] = {
      display = L["Alpha"],
      setter = "SetRegionAlpha",
      type = "number",
      min = 0,
      max = 1,
      bigStep = 0.01,
      isPercent = true
    }
  end

  if defaultsForRegion and defaultsForRegion.progressSource then
    properties["progressSource"] = {
      display = L["Progress Source"],
      setter = "SetProgressSource",
      type = "progressSource",
      values = {},
    }

    properties["adjustedMin"] = {
      display = L["Minimum Progress"],
      setter = "SetAdjustedMin",
      type = "string",
      validate = WeakAuras.ValidateNumericOrPercent,
    }

    properties["adjustedMax"] = {
      display = L["Maximum Progress"],
      setter = "SetAdjustedMax",
      type = "string",
      validate = WeakAuras.ValidateNumericOrPercent,
    }
  end
end

local function SoundRepeatStop(self)
  Private.StartProfileSystem("sound");
  if (self.soundRepeatTimer) then
    WeakAuras.timer:CancelTimer(self.soundRepeatTimer);
    self.soundRepeatTimer = nil;
  end
  Private.StopProfileSystem("sound");
end

local function SoundStop(self, fadeoutTime)
  Private.StartProfileSystem("sound");
  if (self.soundHandle) then
    StopSound(self.soundHandle, fadeoutTime);
  end
  Private.StopProfileSystem("sound");
end

local function SoundPlayHelper(self)
  Private.StartProfileSystem("sound");
  local options = self.soundOptions;
  self.soundHandle = nil;
  if (not options or options.sound_type == "Stop") then
    Private.StopProfileSystem("sound");
    return;
  end

  if (WeakAuras.IsOptionsOpen() or Private.SquelchingActions() or WeakAuras.InLoadingScreen()) then
    Private.StopProfileSystem("sound");
    return;
  end

  if (options.sound == " custom") then
    local ok, _, handle = pcall(PlaySoundFile, options.sound_path, options.sound_channel or "Master")
    if ok then
      self.soundHandle = handle
    end
  elseif (options.sound == " KitID") then
    local ok, _, handle = pcall(PlaySound,options.sound_kit_id, options.sound_channel or "Master")
    if ok then
      self.soundHandle = handle
    end
  else
    local ok, _, handle = pcall(PlaySoundFile, options.sound, options.sound_channel or "Master")
    if ok then
      self.soundHandle = handle
    end
  end
  Private.StopProfileSystem("sound");
end

local function hasSound(options)
  if options.sound_type == "Stop" then
    return true
  end
  if (options.sound == " custom") then
    if (options.sound_path and options.sound_path ~= "") then
      return true
    end
  elseif (options.sound == " KitID") then
    if (options.sound_kit_id and options.sound_kit_id ~= "") then
      return true
    end
  else
    if options.sound and options.sound ~= "" then
      return true
    end
  end
  return false
end

local function SoundPlay(self, options)
  if (not options or WeakAuras.IsOptionsOpen()) then
    return
  end
  Private.StartProfileSystem("sound");
  if not hasSound(options) then
    Private.StopProfileSystem("sound")
    return
  end

  local fadeoutTime = options.sound_type == "Stop" and options.sound_fade and options.sound_fade * 1000 or 0
  self:SoundStop(fadeoutTime);
  self:SoundRepeatStop();

  self.soundOptions = options;
  SoundPlayHelper(self);

  local loop = options.do_loop or options.sound_type == "Loop";
  if (loop and options.sound_repeat and options.sound_repeat < Private.maxTimerDuration) then
    self.soundRepeatTimer = WeakAuras.timer:ScheduleRepeatingTimer(SoundPlayHelper, options.sound_repeat, self);
  end
  Private.StopProfileSystem("sound");
end

local function SendChat(self, options)
  if (not options or WeakAuras.IsOptionsOpen()) then
    return
  end
  Private.HandleChatAction(options.message_type, options.message, options.message_dest, options.message_dest_isunit, options.message_channel, options.r, options.g, options.b, self, {customFunc = options.message_custom}, nil, options.message_formaters);
end

local function RunCode(self, func)
  if func and not WeakAuras.IsOptionsOpen() then
    Private.ActivateAuraEnvironment(self.id, self.cloneId, self.state, self.states);
    xpcall(func, Private.GetErrorHandlerId(self.id, L["Custom Condition Code"]));
    Private.ActivateAuraEnvironment(nil);
  end
end

local function GlowExternal(self, options)
  if (not options or WeakAuras.IsOptionsOpen()) then
    return
  end
  Private.HandleGlowAction(options, self)
end

local function UpdatePosition(self)
  if (not self.anchorPoint or not self.relativeTo or not self.relativePoint) then
    return;
  end

  local xOffset = self.xOffset + (self.xOffsetAnim or 0) + (self.xOffsetRelative or 0)
  local yOffset = self.yOffset + (self.yOffsetAnim or 0) + (self.yOffsetRelative or 0)
  self:RealClearAllPoints();

  xpcall(self.SetPoint, Private.GetErrorHandlerId(self.id, L["Update Position"]), self, self.anchorPoint, self.relativeTo, self.relativePoint, xOffset, yOffset);
end

local function ResetPosition(self)
  self.anchorPoint = nil;
  self.relativeTo = nil;
  self.relativePoint = nil;
end

local function SetAnchor(self, anchorPoint, relativeTo, relativePoint)
  if self.anchorPoint == anchorPoint and self.relativeTo == relativeTo and self.relativePoint == relativePoint then
    return
  end

  self.anchorPoint = anchorPoint;
  self.relativeTo = relativeTo;
  self.relativePoint = relativePoint;

  UpdatePosition(self);
end

local function SetOffset(self, xOffset, yOffset)
  if (self.xOffset == xOffset and self.yOffset == yOffset) then
    return;
  end
  self.xOffset = xOffset;
  self.yOffset = yOffset;
  UpdatePosition(self);
end

local function SetXOffset(self, xOffset)
  self:SetOffset(xOffset, self:GetYOffset());
end

local function SetYOffset(self, yOffset)
  self:SetOffset(self:GetXOffset(), yOffset);
end

local function GetXOffset(self)
  return self.xOffset;
end

local function GetYOffset(self)
  return self.yOffset;
end

local function SetOffsetRelative(self, xOffsetRelative, yOffsetRelative)
  if (self.xOffsetRelative == xOffsetRelative and self.yOffsetRelative == yOffsetRelative) then
    return
  end
  self.xOffsetRelative = xOffsetRelative
  self.yOffsetRelative = yOffsetRelative
  UpdatePosition(self)
end

local function SetXOffsetRelative(self, xOffsetRelative)
  self:SetOffsetRelative(xOffsetRelative, self:GetYOffsetRelative())
end

local function SetYOffsetRelative(self, yOffsetRelative)
  self:SetOffsetRelative(self:GetXOffsetRelative(), yOffsetRelative)
end

local function GetXOffsetRelative(self)
  return self.xOffsetRelative
end

local function GetYOffsetRelative(self)
  return self.yOffsetRelative
end

local function SetOffsetAnim(self, xOffset, yOffset)
  if (self.xOffsetAnim == xOffset and self.yOffsetAnim == yOffset) then
    return;
  end
  self.xOffsetAnim = xOffset;
  self.yOffsetAnim = yOffset;
  UpdatePosition(self);
end

local function SetRegionAlpha(self, alpha)
  if (self.alpha == alpha) then
    return;
  end

  self.alpha = alpha;
  self:SetAlpha(self.animAlpha or self.alpha or 1);
  self.subRegionEvents:Notify("AlphaChanged")
end

local function GetRegionAlpha(self)
  return self.animAlpha or self.alpha or 1;
end

local function SetProgressSource(self, progressSource)
  self.progressSource = progressSource
  self:UpdateProgress()
end

local function SetAdjustedMin(self, adjustedMin)
  local index = adjustedMin:find("%% *$")
  if index then
    local percent = adjustedMin:sub(1, index-1)
    self.adjustedMinRelPercent = tonumber(percent) / 100
    self.adjustedMin = nil
  else
    self.adjustedMin = tonumber(adjustedMin)
    self.adjustedMinRelPercent = nil
  end
  self:UpdateProgress()
end

local function SetAdjustedMax(self, adjustedMax)
  local index = adjustedMax:find("%% *$")
  if index then
    local percent = adjustedMax:sub(1, index-1)
    self.adjustedMaxRelPercent = tonumber(percent) / 100
  else
    self.adjustedMax = tonumber(adjustedMax)
  end
  self:UpdateProgress()
end

local function GetProgressSource(self)
  return self.progressSource
end

local function GetMinMaxProgress(self)
  return self.minProgress or 0, self.maxProgress or 0
end

local function UpdateProgressFromState(self, minMaxConfig, state, progressSource)
  local progressType = progressSource[2]
  local property = progressSource[3]
  local totalProperty = progressSource[4]
  local modRateProperty = progressSource[5]
  local inverseProperty = progressSource[6]
  local pausedProperty = progressSource[7]
  local remainingProperty = progressSource[8]
  local useAdditionalProgress = progressSource[9]

  if not state then
    self.minProgress, self.maxProgress = nil, nil
    self.progressType = "timed"
    self.duration = 0
    self.expirationTime = math.huge
    self.modRate = nil
    self.inverse = false
    self.paused = true
    self.remaining = math.huge
    if self.UpdateTime then
      self:UpdateTime()
    end
    if self.SetAdditionalProgress then
      self:SetAdditionalProgress(nil)
    end
  elseif progressType == "number" then
    local value = state[property]
    if type(value) ~= "number" then value = 0 end
    local total = totalProperty and state[totalProperty]
    if type(total) ~= "number" then total = 0 end
    -- We don't care about inverse, modRate or paused
    local adjustMin
    if minMaxConfig.adjustedMin then
      adjustMin = minMaxConfig.adjustedMin
    elseif minMaxConfig.adjustedMinRelPercent then
      adjustMin = minMaxConfig.adjustedMinRelPercent * total
    else
      adjustMin = 0
    end
    local max
    if minMaxConfig.adjustedMax then
      max = minMaxConfig.adjustedMax
    elseif minMaxConfig.adjustedMaxRelPercent then
      max = minMaxConfig.adjustedMaxRelPercent * total
    else
      max = total
    end
    -- The output of UpdateProgress is setting various values on self
    -- and calling UpdateTime/UpdateValue. Not an ideal interface, but
    -- the animation code/sub elements needs those values in some convenient place
    self.minProgress, self.maxProgress = adjustMin, max
    self.progressType = "static"
    self.value = value - adjustMin
    self.total = max - adjustMin
    if self.UpdateValue then
      self:UpdateValue()
    end
    if self.SetAdditionalProgress then
      if useAdditionalProgress then
        self:SetAdditionalProgress(state.additionalProgress, adjustMin, max, false)
      else
        self:SetAdditionalProgress(nil)
      end
    end
  elseif progressType == "timer" then
    local expirationTime
    local paused = pausedProperty and state[pausedProperty]
    local inverse = inverseProperty and state[inverseProperty]
    local remaining
    if paused then
      remaining = remainingProperty and state[remainingProperty]
      expirationTime = GetTime() + (type(remaining) == "number" and remaining or 0)
    else
      expirationTime = state[property]
      if type(expirationTime) ~= "number" then
        expirationTime = math.huge
      end
    end

    local duration = totalProperty and state[totalProperty] or 0
    if type(duration) ~= "number" then
      duration = 0
    end
    local modRate = modRateProperty and state[modRateProperty] or nil
    local adjustMin
    if minMaxConfig.adjustedMin then
      adjustMin = minMaxConfig.adjustedMin
    elseif minMaxConfig.adjustedMinRelPercent then
      adjustMin = minMaxConfig.adjustedMinRelPercent * duration
    else
      adjustMin = 0
    end

    local max
    if duration == 0 then
      max = 0
    elseif minMaxConfig.adjustedMax then
      max = minMaxConfig.adjustedMax
    elseif minMaxConfig.adjustedMaxRelPercent then
      max = minMaxConfig.adjustedMaxRelPercent * duration
    else
      max = duration
    end
    self.minProgress, self.maxProgress = adjustMin, max
    self.progressType = "timed"
    self.duration = max - adjustMin
    self.expirationTime = expirationTime - adjustMin
    self.remaining = remaining
    self.modRate = modRate
    self.inverse = inverse
    self.paused = paused
    if self.UpdateTime then
      self:UpdateTime()
    end
    if self.SetAdditionalProgress then
      if useAdditionalProgress then
        self:SetAdditionalProgress(state.additionalProgress, adjustMin, max, inverse)
      else
        self:SetAdditionalProgress(nil)
      end
    end
  elseif progressType == "elapsedTimer" then
    local startTime = state[property] or math.huge
    local duration = totalProperty and state[totalProperty] or 0
    local adjustMin
    if minMaxConfig.adjustedMin then
      adjustMin = minMaxConfig.adjustedMin
    elseif minMaxConfig.adjustedMinRelPercent then
      adjustMin = minMaxConfig.adjustedMinRelPercent * duration
    else
      adjustMin = 0
    end

    local max
    if minMaxConfig.adjustedMax then
      max = minMaxConfig.adjustedMax
    elseif minMaxConfig.adjustedMaxRelPercent then
      max = minMaxConfig.adjustedMaxRelPercent * duration
    else
      max = duration
    end

    self.minProgress, self.maxProgress = adjustMin, max
    self.progressType = "timed"
    self.duration = max - adjustMin
    self.expirationTime = startTime + adjustMin + self.duration
    self.modRate = nil
    self.inverse = true
    self.paused = false
    self.remaining = nil
    if self.UpdateTime then
      self:UpdateTime()
    end
    if self.SetAdditionalProgress then
      if useAdditionalProgress then
        self:SetAdditionalProgress(state.additionalProgress, adjustMin, max, false)
      else
        self:SetAdditionalProgress(nil)
      end
    end
  end
end

local autoTimedProgressSource = {-1, "timer", "expirationTime", "duration", "modRate", "inverse", "paused", "remaining", true}
local autoStaticProgressSource = {-1, "number", "value", "total", nil, nil, nil, nil, true}
local function UpdateProgressFromAuto(self, minMaxConfig, state)
  if state.progressType == "timed"  then
    UpdateProgressFromState(self, minMaxConfig, state, autoTimedProgressSource)
  elseif state.progressType == "static"then
    UpdateProgressFromState(self, minMaxConfig, state, autoStaticProgressSource)
  else
    self.minProgress, self.maxProgress = nil, nil
    self.progressType = "timed"
    self.duration = 0
    self.expirationTime = math.huge
    self.modRate = nil
    self.inverse = false
    self.paused = true
    self.remaining = math.huge
    if self.UpdateTime then
      self:UpdateTime()
    end
    if self.SetAdditionalProgress then
      self:SetAdditionalProgress(nil)
    end
  end
end

local function UpdateProgressFromManual(self, minMaxConfig, state, value, total)
  value = type(value) == "number" and value or 0
  total = type(total) == "number" and total or 0
  local adjustMin
  if minMaxConfig.adjustedMin then
    adjustMin = minMaxConfig.adjustedMin
  elseif minMaxConfig.adjustedMinRelPercent then
    adjustMin = minMaxConfig.adjustedMinRelPercent * total
  else
    adjustMin = 0
  end
  local max
  if minMaxConfig.adjustedMax then
    max = minMaxConfig.adjustedMax
  elseif minMaxConfig.adjustedMaxRelPercent then
    max = minMaxConfig.adjustedMaxRelPercent * total
  else
    max = total
  end
  self.minProgress, self.maxProgress = adjustMin, max
  self.progressType = "static"
  self.value = value - adjustMin
  self.total = max - adjustMin
  if self.UpdateValue then
    self:UpdateValue()
  end
  if self.SetAdditionalProgress then
    self:SetAdditionalProgress(nil)
  end
end

local function UpdateProgressFrom(self, progressSource, minMaxConfig, state, states, parent)
  local trigger = progressSource and progressSource[1] or -1

  if trigger == -2 then
    -- sub element'a auto uses the whatever progress the main region has
    UpdateProgressFromAuto(self, minMaxConfig, parent)
  elseif trigger == -1 then
    -- auto for regions uses the state
    UpdateProgressFromAuto(self, minMaxConfig, state)
  elseif trigger == 0 then
    UpdateProgressFromManual(self, minMaxConfig, state, progressSource[3], progressSource[4])
  else
    UpdateProgressFromState(self, minMaxConfig, states and states[trigger] or {}, progressSource)
  end
end

-- For regions
local function UpdateProgress(self)
  UpdateProgressFrom(self, self.progressSource, self, self.state, self.states)
  self.subRegionEvents:Notify("UpdateProgress", self.state, self.states)
end

Private.UpdateProgressFrom = UpdateProgressFrom

local function SetAnimAlpha(self, alpha)
  if alpha then
    if alpha > 1 then
      alpha = 1
    elseif alpha < 0 then
      alpha = 0
    end
  end
  if (self.animAlpha == alpha) then
    return;
  end
  self.animAlpha = alpha;
  local errorHandler = Private.GetErrorHandlerId(self.id, L["Custom Fade Animation"])
  if (WeakAuras.IsOptionsOpen()) then
    xpcall(self.SetAlpha, errorHandler, self, max(self.animAlpha or self.alpha or 1, 0.5))
  else
    xpcall(self.SetAlpha, errorHandler, self, self.animAlpha or self.alpha or 1)
  end
  self.subRegionEvents:Notify("AlphaChanged")
end

local function UpdateTick(self)
  if self.subRegionEvents:HasSubscribers("FrameTick") and self.toShow then
    Private.FrameTick:AddSubscriber("Tick", self)
  else
    Private.FrameTick:RemoveSubscriber("Tick", self)
  end
end

local function Tick(self)
  Private.StartProfileAura(self.id)
  self.values.customTextUpdated = false
  self.subRegionEvents:Notify("FrameTick")
  Private.StopProfileAura(self.id)
end

local function ForwardAnchorToSubRegion(self, subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
  local nextdot = anchorPoint:find(".", 5, true)
  local index = tonumber(anchorPoint:sub(5, nextdot - 1))
  local subElement = index and self.subRegions[index] or nil
  if subElement then
    local key = anchorPoint:sub(nextdot + 1)
    if subElement.AnchorSubRegion then
      subElement:AnchorSubRegion(subRegion, anchorType, key, selfPoint, anchorXOffset, anchorYOffset)
    end
  end
end

local function AnchorSubRegion(self, subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
  if anchorPoint and anchorPoint:sub(1, 4) == "sub." then
    self:ForwardAnchorToSubRegion(subRegion, anchorType, anchorPoint, selfPoint, anchorXOffset, anchorYOffset)
    return
  end
  if anchorType == "point" then
    subRegion:ClearAllPoints()
    local xOffset = anchorXOffset or 0
    local yOffset = anchorYOffset or 0
    subRegion:SetPoint(Private.point_types[selfPoint] and selfPoint or "CENTER",
                       self, Private.point_types[anchorPoint] and anchorPoint or "CENTER",
                       xOffset, yOffset)
  else
    subRegion:ClearAllPoints()
    anchorXOffset = anchorXOffset or 0
    anchorYOffset = anchorYOffset or 0
    subRegion:SetPoint("bottomleft", self, "bottomleft", -anchorXOffset, -anchorYOffset)
    subRegion:SetPoint("topright", self, "topright", anchorXOffset,  anchorYOffset)
  end
end

Private.regionPrototype.AnchorSubRegion = AnchorSubRegion

function Private.regionPrototype.create(region)
  local defaultsForRegion = Private.regionTypes[region.regionType] and Private.regionTypes[region.regionType].default;
  region.SoundPlay = SoundPlay;
  region.SoundStop = SoundStop;
  region.SoundRepeatStop = SoundRepeatStop;
  region.SendChat = SendChat;
  region.RunCode = RunCode;
  region.GlowExternal = GlowExternal;

  region.ReAnchor = UpdatePosition;
  region.SetAnchor = SetAnchor;
  region.SetOffset = SetOffset;
  region.SetXOffset = SetXOffset;
  region.SetYOffset = SetYOffset;
  region.GetXOffset = GetXOffset;
  region.GetYOffset = GetYOffset;
  region.SetOffsetRelative = SetOffsetRelative
  region.SetXOffsetRelative = SetXOffsetRelative
  region.SetYOffsetRelative = SetYOffsetRelative
  region.GetXOffsetRelative = GetXOffsetRelative
  region.GetYOffsetRelative = GetYOffsetRelative
  region.SetOffsetAnim = SetOffsetAnim;
  region.ResetPosition = ResetPosition;
  region.RealClearAllPoints = region.ClearAllPoints;
  region.ClearAllPoints = function()
    region:RealClearAllPoints();
    region:ResetPosition();
  end
  if (defaultsForRegion and defaultsForRegion.alpha) then
    region.SetRegionAlpha = SetRegionAlpha;
    region.GetRegionAlpha = GetRegionAlpha;
  end
  if defaultsForRegion and defaultsForRegion.progressSource then
    region.SetProgressSource = SetProgressSource
    region.GetProgressSource = GetProgressSource
    region.SetAdjustedMin = SetAdjustedMin
    region.SetAdjustedMax = SetAdjustedMax
  end
  region.UpdateProgress = UpdateProgress
  region.GetMinMaxProgress = GetMinMaxProgress
  region.SetAnimAlpha = SetAnimAlpha;

  region.UpdateTick = UpdateTick
  region.Tick = Tick


  region.subRegionEvents = Private.CreateSubscribableObject()
  region.AnchorSubRegion = AnchorSubRegion
  region.ForwardAnchorToSubRegion = ForwardAnchorToSubRegion
  region.values = {} -- For SubText

  region:SetPoint("CENTER", UIParent, "CENTER")
end

function Private.regionPrototype.AddMinMaxProgressSource(hasProgressSource, region, parentData, data)
  local hasAdjustedMin = hasProgressSource and data.useAdjustededMin and data.adjustedMin
  local hasAdjustedMax = hasProgressSource and data.useAdjustededMax and data.adjustedMax

  region.progressSource = nil
  region.adjustedMin = nil
  region.adjustedMinRelPercent = nil
  region.adjustedMax = nil
  region.adjustedMaxRelPercent = nil

  if hasProgressSource then
    region.progressSource = Private.AddProgressSourceMetaData(parentData, data.progressSource)
  end

  if (hasAdjustedMin) then
    local percent = string.match(data.adjustedMin, "(%d+)%%")
    if percent then
      region.adjustedMinRelPercent = tonumber(percent) / 100
    else
      region.adjustedMin = tonumber(data.adjustedMin);
    end
  end
  if (hasAdjustedMax) then
    local percent = string.match(data.adjustedMax, "(%d+)%%")
    if percent then
      region.adjustedMaxRelPercent = tonumber(percent) / 100
    else
      region.adjustedMax = tonumber(data.adjustedMax)
    end
  end
end

function Private.regionPrototype.modify(parent, region, data)
  region.state = nil
  region.states = nil
  region.subRegionEvents:ClearSubscribers()
  region.subRegionEvents:ClearCallbacks()
  Private.FrameTick:RemoveSubscriber("Tick", region)

  local defaultsForRegion = Private.regionTypes[data.regionType] and Private.regionTypes[data.regionType].default;

  if region.SetRegionAlpha then
    region:SetRegionAlpha(data.alpha)
  end

  local hasProgressSource = defaultsForRegion and defaultsForRegion.progressSource

  Private.regionPrototype.AddMinMaxProgressSource(hasProgressSource, region, data, data)

  region:SetOffset(data.xOffset or 0, data.yOffset or 0);
  region:SetOffsetRelative(0, 0)
  region:SetOffsetAnim(0, 0);

  if data.anchorFrameType == "CUSTOM" and data.customAnchor then
    region.customAnchorFunc = WeakAuras.LoadFunction("return " .. data.customAnchor, data.id)
  else
    region.customAnchorFunc = nil
  end

  if not parent or parent.regionType ~= "dynamicgroup" then
    if
      -- Don't anchor single Auras that with custom anchoring,
      -- these will be anchored in expand
      not (
        data.anchorFrameType == "CUSTOM"
        or data.anchorFrameType == "UNITFRAME"
        or data.anchorFrameType == "NAMEPLATE"
      )
      -- Group Auras that will never be expanded, so those need
      -- to be always anchored here
      or data.regionType == "dynamicgroup"
      or data.regionType == "group"
    then
      Private.AnchorFrame(data, region, parent);
    end
  end

  region.startFormatters = Private.CreateFormatters(data.actions.start.message, function(key, default)
    local fullKey = "message_format_" .. key
    if data.actions.start[fullKey] == nil then
      data.actions.start[fullKey] = default
    end
    return data.actions.start[fullKey]
  end, true, data)

  region.finishFormatters = Private.CreateFormatters(data.actions.finish.message, function(key, default)
    local fullKey = "message_format_" .. key
    if data.actions.finish[fullKey] == nil then
      data.actions.finish[fullKey] = default
    end
    return data.actions.finish[fullKey]
  end, true, data)
end

function Private.regionPrototype.modifyFinish(parent, region, data)
  -- Sync subRegions
  if region.subRegions then
    for index, subRegion in pairs(region.subRegions) do
      Private.subRegionTypes[subRegion.type].release(subRegion)
    end

    wipe(region.subRegions)
  end

  if data.subRegions then
    region.subRegions = region.subRegions or {}
    local subRegionTypes = {}
    for index, subRegionData in pairs(data.subRegions) do
      if Private.subRegionTypes[subRegionData.type] then
        local subRegion = Private.subRegionTypes[subRegionData.type].acquire()
        subRegion.type = subRegionData.type

        if subRegion then
          Private.subRegionTypes[subRegionData.type].modify(region, subRegion, data, subRegionData, not subRegionTypes[subRegionData.type])
          subRegionTypes[subRegionData.type] = true
        end

        tinsert(region.subRegions, subRegion)
      end
    end

    for index, subRegion in pairs(region.subRegions) do
      if subRegion.Anchor then
        subRegion:Anchor()
      end
    end

  end

  region.subRegionEvents:SetOnSubscriptionStatusChanged("FrameTick", function()
    region:UpdateTick()
  end)
  region:UpdateTick()

  Private.ApplyFrameLevel(region)
end

local frameForFrameTick = CreateFrame("Frame");
Private.frames["Frame Tick Frame"] = frameForFrameTick

Private.FrameTick = Private.CreateSubscribableObject()
Private.FrameTick.OnUpdateHandler = function()
  Private.StartProfileSystem("frame tick")
  Private.FrameTick:Notify("Tick")
  Private.StopProfileSystem("frame tick")
end

Private.FrameTick:SetOnSubscriptionStatusChanged("Tick", function()
  if Private.FrameTick:HasSubscribers("Tick") then
    frameForFrameTick:SetScript("OnUpdate", Private.FrameTick.OnUpdateHandler);
  else
    frameForFrameTick:SetScript("OnUpdate", nil)
  end
end)

function Private.regionPrototype.AddSetDurationInfo(region, uid)
  if (region.UpdateValue and region.UpdateTime) then
    -- WeakAuras no longer calls SetDurationInfo, but some people do that
    region.SetDurationInfo = function(self, duration, expirationTime, customValue, inverse)
      -- For now don't warn against SetDurationInfo
      -- Private.AuraWarnings.UpdateWarning(uid, "SetDurationInfo", "warning", L["Aura is using deprecated SetDurationInfo"])
      if customValue then
        local adjustMin = region.adjustedMin or 0;
        local max = self.adjustedMax or expirationTime
        region.progressType = "static"
        region.value = duration - adjustMin
        region.total = max - adjustMin
        region:UpdateValue()
      else
        local adjustMin = self.adjustedMin or 0;
        self.progressType = "timed"
        self.duration = (duration ~= 0 and self.adjustedMax or duration) - adjustMin
        self.expirationTime = expirationTime - adjustMin
        self.modRate = nil
        self.inverse = inverse
        self.paused = false
        self.remaining = nil
        self:UpdateTime()
      end
    end
  end
end

-- Expand/Collapse function
function Private.regionPrototype.AddExpandFunction(data, region, cloneId, parent, parentRegionType)
  local uid = data.uid
  local id = data.id
  local inDynamicGroup = parentRegionType == "dynamicgroup";
  local inGroup = parentRegionType == "group";

  local startMainAnimation = function()
    Private.Animate("display", uid, "main", data.animation.main, region, false, nil, true, cloneId);
  end

  function region:OptionsClosed()
    region:EnableMouse(false)
    region:SetScript("OnMouseDown", nil)
  end

  function region:ClickToPick()
    region:EnableMouse(true)
    region:SetScript("OnMouseDown", function()
      WeakAuras.PickDisplay(region.id, nil, true)
    end)
    if region.GetFrameStrata and region:GetFrameStrata() == "TOOLTIP" then
      region:SetFrameStrata("HIGH")
    end
  end

  local hideRegion;
  if(inDynamicGroup) then
    hideRegion = function()
      if region.PreHide then
        region:PreHide()
      end

      Private.RunConditions(region, uid, true)
      region.subRegionEvents:Notify("PreHide")
      if region:IsProtected() then
        if InCombatLockdown() then
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame_error", "error",
          L["Cannot change secure frame in combat lockdown. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"],
            true)
        else
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame", "warning",
            L["Secure frame detected. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"])
          region:Hide()
        end
      else
        Private.AuraWarnings.UpdateWarning(uid, "protected_frame")
        region:Hide()
      end
      region.states = nil
      region.state = nil
      if (cloneId) then
        Private.ReleaseClone(region.id, cloneId, data.regionType);
        parent:RemoveChild(id, cloneId)
      else
        parent:DeactivateChild(id, cloneId);
      end
    end
  else
    hideRegion = function()
      if region.PreHide then
        region:PreHide()
      end
      Private.RunConditions(region, uid, true)
      region.subRegionEvents:Notify("PreHide")

      if region:IsProtected() then
        if InCombatLockdown() then
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame_error", "error",
          L["Cannot change secure frame in combat lockdown. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"],
            true)
        else
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame", "warning",
            L["Secure frame detected. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"])
          region:Hide()
        end
      else
        Private.AuraWarnings.UpdateWarning(uid, "protected_frame")
        region:Hide()
      end

      region.states = nil
      region.state = nil
      if (cloneId) then
        Private.ReleaseClone(region.id, cloneId, data.regionType);
      end
    end
  end

  if(inDynamicGroup) then
    function region:Collapse()
      if (not region.toShow) then
        return;
      end
      region.toShow = false;

      Private.PerformActions(data, "finish", region);
      if (not Private.Animate("display", data.uid, "finish", data.animation.finish, region, false, hideRegion, nil, cloneId)) then
        hideRegion();
      end

      if (region.SoundRepeatStop) then
        region:SoundRepeatStop();
      end

      region:UpdateTick()
    end
    function region:Expand()
      if (region.toShow) then
        return;
      end
      region.toShow = true;
      if(region.PreShow) then
        region:PreShow();
      end

      region.subRegionEvents:Notify("PreShow")

      Private.ApplyFrameLevel(region)
      if region:IsProtected() then
        if InCombatLockdown() then
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame_error", "error",
            L["Cannot change secure frame in combat lockdown. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"],
            true)
        else
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame", "warning",
            L["Secure frame detected. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"])
          region:Show()
        end
      else
        Private.AuraWarnings.UpdateWarning(uid, "protected_frame")
        region:Show()
      end

      Private.PerformActions(data, "start", region);
      if not(Private.Animate("display", data.uid, "start", data.animation.start, region, true, startMainAnimation, nil, cloneId)) then
        startMainAnimation();
      end
      parent:ActivateChild(data.id, cloneId);

      region:UpdateTick()
    end
  elseif not(data.controlledChildren) then
    function region:Collapse()
      if (not region.toShow) then
        return;
      end
      region.toShow = false;

      Private.PerformActions(data, "finish", region);
      if (not Private.Animate("display", data.uid, "finish", data.animation.finish, region, false, hideRegion, nil, cloneId)) then
        hideRegion();
      end

      if inGroup then
        parent:UpdateBorder(region);
      end

      if (region.SoundRepeatStop) then
        region:SoundRepeatStop();
      end

      region:UpdateTick()
    end
    function region:Expand()
      if data.anchorFrameType == "SELECTFRAME"
      or data.anchorFrameType == "CUSTOM"
      or data.anchorFrameType == "UNITFRAME"
      or data.anchorFrameType == "NAMEPLATE"
      then
        Private.AnchorFrame(data, region, parent);
      end

      if (region.toShow) then
        return;
      end
      region.toShow = true

      if(region.PreShow) then
        region:PreShow();
      end

      region.subRegionEvents:Notify("PreShow")
      Private.ApplyFrameLevel(region)

      if region:IsProtected() then
        if InCombatLockdown() then
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame_error", "error",
            L["Cannot change secure frame in combat lockdown. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"],
            true)
        else
          Private.AuraWarnings.UpdateWarning(uid, "protected_frame", "warning",
            L["Secure frame detected. Find more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"])
          region:Show()
        end
      else
        Private.AuraWarnings.UpdateWarning(uid, "protected_frame")
        region:Show()
      end

      Private.PerformActions(data, "start", region);
      if not(Private.Animate("display", data.uid, "start", data.animation.start, region, true, startMainAnimation, nil, cloneId)) then
        startMainAnimation();
      end

      if inGroup then
        parent:UpdateBorder(region);
      end

      region:UpdateTick()
    end
  end
  -- Stubs that allow for polymorphism
  if not region.Collapse then
    function region:Collapse() end
  end
  if not region.Expand then
    function region:Expand() end
  end
end

function Private.SetTextureOrAtlas(texture, path, wrapModeH, wrapModeV)
  texture.IsAtlas = type(path) == "string" and GetAtlasInfo(path) ~= nil
  if texture.IsAtlas then
    return texture:SetAtlas(path);
  else
    return texture:SetTexture(path, wrapModeH, wrapModeV);
  end
end

do
  local function move_condition_subregions(data, offset, afterPos)
    if data.conditions then
      for conditionIndex, condition in ipairs(data.conditions) do
        if type(condition.changes) == "table" then
          for changeIndex, change in ipairs(condition.changes) do
            if change.property then
              local subRegionIndex, property = change.property:match("^sub%.(%d+)%.(.*)")
              subRegionIndex = tonumber(subRegionIndex)
              if subRegionIndex and property then
                if (subRegionIndex >= afterPos) then
                  change.property = "sub." .. subRegionIndex + offset .. "." .. property
                end
              end
            end
          end
        end
      end
    end
  end

  function Private.EnforceSubregionExists(data, subregionType)
    data.subRegions = data.subRegions or {}
    -- search and save indexes of matching subregions
    local indexes = {}
    for index, subRegionData in ipairs(data.subRegions) do
      if subRegionData.type == subregionType then
        table.insert(indexes, index)
      end
    end
    -- add if missing
    if #indexes == 0 then
      tinsert(data.subRegions, 1, {
        ["type"] = subregionType
      })
      move_condition_subregions(data, 1, 1)
    -- delete duplicate
    elseif #indexes > 1 then
      for i = #indexes, 2, -1 do
        table.remove(data.subRegions, indexes[i])
        move_condition_subregions(data, -1, indexes[i])
      end
    end
  end
end


-- ========================================
-- File: WeakAuras/RegionTypes/SmoothStatusBarMixin.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

-- This is a more or less 1:1 copy of SmoothStatusBarMixin except that it
-- doesn't clamp the targetValue in ProcessSmoothStatusBars, because that's incorrect for us
local g_updatingBars = {};

local function IsCloseEnough(bar, newValue, targetValue)
        local min, max = bar:GetMinMaxValues();
        local range = max - min;
        if range > 0.0 then
                return math.abs((newValue - targetValue) / range) < .00001;
        end

        return true;
end

local function ProcessSmoothStatusBars()
        for bar, targetValue in pairs(g_updatingBars) do
                local newValue = FrameDeltaLerp(bar:GetValue(), targetValue, .25);

                if IsCloseEnough(bar, newValue, targetValue) then
                        g_updatingBars[bar] = nil;
                        bar:SetValue(targetValue);
                else
                        bar:SetValue(newValue);
                end
        end
end

C_Timer.NewTicker(0, ProcessSmoothStatusBars);

Private.SmoothStatusBarMixin = {};

function Private.SmoothStatusBarMixin:ResetSmoothedValue(value) --If nil, tries to set to the last target value
        local targetValue = g_updatingBars[self];
        if targetValue then
                g_updatingBars[self] = nil;
                self:SetValue(value or targetValue);
        elseif value then
                self:SetValue(value);
        end
end

function Private.SmoothStatusBarMixin:SetSmoothedValue(value)
        g_updatingBars[self] = value;
end

function Private.SmoothStatusBarMixin:SetMinMaxSmoothedValue(min, max)
        self:SetMinMaxValues(min, max);

        local targetValue = g_updatingBars[self];
        if targetValue then
                local ratio = 1;
                if max ~= 0 and self.lastSmoothedMax and self.lastSmoothedMax ~= 0 then
                        ratio = max / self.lastSmoothedMax;
                end

                g_updatingBars[self] = targetValue * ratio;
        end

        self.lastSmoothedMin = min;
        self.lastSmoothedMax = max;
end


-- ========================================
-- File: WeakAuras/RegionTypes/StopMotion.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L;

--- @class StopMotionRegion : WARegion
--- @field background StopMotionBaseInstance
--- @field foreground StopMotionBaseInstance
--- @field width number
--- @field height number
--- @field scalex number
--- @field scaley number
--- @field mirror_h boolean
--- @field mirror_v boolean
--- @field color_r number
--- @field color_g number
--- @field color_b number
--- @field color_a number
--- @field color_anim_r number
--- @field color_anim_g number
--- @field color_anim_b number
--- @field color_anim_a number

local default = {
    progressSource = {-1, "" },
    adjustedMax = "",
    adjustedMin = "",
    foregroundTexture = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\stopmotion",
    backgroundTexture = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\stopmotion",
    desaturateBackground = false,
    desaturateForeground = false,
    sameTexture = true,
    width = 128,
    height = 128,
    foregroundColor = {1, 1, 1, 1},
    backgroundColor = {0.5, 0.5, 0.5, 0.5},
    blendMode = "BLEND",
    mirror = false,
    selfPoint = "CENTER",
    anchorPoint = "CENTER",
    anchorFrameType = "SCREEN",
    xOffset = 0,
    yOffset = 0,
    frameStrata = 1,
    startPercent = 0,
    endPercent = 1,
    backgroundPercent = 1,
    frameRate = 15,
    animationType = "loop",
    inverse = false,
    customForegroundFrames = 0,
    customForegroundRows = 16,
    customForegroundColumns = 16,
    customBackgroundFrames = 0,
    customForegroundFileWidth = 0,
    customForegroundFileHeight = 0,
    customForegroundFrameWidth = 0,
    customForegroundFrameHeight = 0,
    customBackgroundRows = 16,
    customBackgroundColumns = 16,
    hideBackground = true
};

Private.regionPrototype.AddProgressSourceToDefault(default)

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;

local properties = {
  desaturateForeground = {
    display = L["Desaturate Foreground"],
    setter = "SetForegroundDesaturated",
    type = "bool",
  },
  desaturateBackground = {
    display = L["Desaturate Background"],
    setter = "SetBackgroundDesaturated",
    type = "bool",
  },
  foregroundColor = {
    display = L["Foreground Color"],
    setter = "Color",
    type = "color"
  },
  backgroundColor = {
    display = L["Background Color"],
    setter = "SetBackgroundColor",
    type = "color"
  },
  width = {
    display = L["Width"],
    setter = "SetRegionWidth",
    type = "number",
    min = 1,
    softMax = screenWidth,
    bigStep = 1,
  },
  height = {
    display = L["Height"],
    setter = "SetRegionHeight",
    type = "number",
    min = 1,
    softMax = screenHeight,
    bigStep = 1
  },
}

Private.regionPrototype.AddProperties(properties, default);

local function GetProperties(data)
  local result = CopyTable(properties)
  result.progressSource.values = Private.GetProgressSourcesForUi(data)
  return result
end

---@type fun(parent: WARegion) : StopMotionRegion
local function create(parent)
  local frame = CreateFrame("Frame", nil, UIParent)
  frame:SetMovable(true)
  frame:SetResizable(true)
  frame:SetResizeBounds(1, 1)

  --- @cast frame StopMotionRegion
  frame.background = Private.StopMotionBase.create(frame, "BACKGROUND")
  frame.foreground = Private.StopMotionBase.create(frame, "ARTWORK")

  frame.regionType = "stopmotion"
  Private.regionPrototype.create(frame)

  return frame
end

local FrameTickFunctions = {
  --- @type fun(self: StopMotionRegion)
  progressTimer = function(self)
    Private.StartProfileSystem("stopmotion")
    Private.StartProfileAura(self.id)

    local remaining = self.expirationTime - GetTime()
    local progress = 1 - (remaining / self.duration)

    self.foreground:SetProgress(progress)

    Private.StopProfileAura(self.id)
    Private.StopProfileSystem("stopmotion")
  end,
  --- @type fun(self: StopMotionRegion)
  timed = function(self)
    if (not self.foreground.startTime) then return end

    Private.StartProfileSystem("stopmotion")
    Private.StartProfileAura(self.id)

    self.foreground:TimedUpdate()

    Private.StopProfileAura(self.id)
    Private.StopProfileSystem("stopmotion")
  end,
}

---@type fun(parent: Region, region: StopMotionRegion, data: table)
local function modify(parent, region, data)
    Private.regionPrototype.modify(parent, region, data)

    Private.StopMotionBase.modify(region.foreground, {
      blendMode = data.blendMode,
      -- Foreground Data
      frameRate = data.frameRate,
      inverseDirection = data.inverse,
      animationType = data.animationType,
      texture = data.foregroundTexture,
      startPercent = data.startPercent,
      endPercent = data.endPercent,
      customFrames = data.customForegroundFrames,
      customRows = data.customForegroundRows,
      customColumns = data.customForegroundColumns,
      customFileWidth = data.customForegroundFileWidth,
      customFileHeight = data.customForegroundFileHeight,
      customFrameWidth = data.customForegroundFrameWidth,
      customFrameHeight = data.customForegroundFrameHeight,
    })

    if data.sameTexture then
      Private.StopMotionBase.modify(region.background, {
        blendMode = data.blendMode,
        animationType = "background",
        -- Background Data
        texture = data.foregroundTexture,
        startPercent = data.backgroundPercent,
        endPercent = data.backgroundPercent,
        customFrames = data.customForegroundFrames,
        customRows = data.customForegroundRows,
        customColumns = data.customForegroundColumns,
        customFileWidth = data.customForegroundFileWidth,
        customFileHeight = data.customForegroundFileHeight,
        customFrameWidth = data.customForegroundFrameWidth,
        customFrameHeight = data.customForegroundFrameHeight,
      })
    else
      Private.StopMotionBase.modify(region.background, {
        blendMode = data.blendMode,
        animationType = "background",
        -- Background Data
        texture = data.backgroundTexture,
        startPercent = data.backgroundPercent,
        endPercent = data.backgroundPercent,
        customFrames = data.customBackgroundFrames,
        customRows = data.customBackgroundRows,
        customColumns = data.customBackgroundColumns,
        customFileWidth = data.customBackgroundFileWidth,
        customFileHeight = data.customBackgroundFileHeight,
        customFrameWidth = data.customBackgroundFrameWidth,
        customFrameHeight = data.customBackgroundFrameHeight,
      })
    end

    region.background:SetVisible(not data.hideBackground)

    region.background:SetDesaturated(data.desaturateBackground)
    region.foreground:SetDesaturated(data.desaturateForeground)

    region:SetWidth(data.width);
    region:SetHeight(data.height);
    region.width = data.width;
    region.height = data.height;
    region.scalex = 1;
    region.scaley = 1;

    --- @class StopMotionRegion
    --- @field Scale fun(self: StopMotionRegion, scalex: number, scaley: number)
    function region:Scale(scalex, scaley)
      self.scalex = scalex
      self.scaley = scaley
      if(scalex < 0) then
        self.mirror_h = true
        scalex = scalex * -1
      else
        self.mirror_h = nil
      end
      self:SetWidth(self.width * scalex)
      if(scaley < 0) then
        scaley = scaley * -1
        self.mirror_v = true
      else
        self.mirror_v = nil
      end
      self:SetHeight(self.height * scaley)
    end

    -- Set colors
    region.background:SetColor(data.backgroundColor[1], data.backgroundColor[2],
                               data.backgroundColor[3], data.backgroundColor[4])

    --- @class StopMotionRegion
    --- @field SetBackgroundColor fun(self: StopMotionRegion, r: number, g: number, b: number, a: number)
    function region:SetBackgroundColor(r, g, b, a)
      self.background:SetColor(r, g, b, a)
    end

    --- @class StopMotionRegion
    --- @field GetColor fun(self: StopMotionRegion): number, number, number, number
    function region:GetColor()
      return region.color_r, region.color_g, region.color_b, region.color_a
    end

    --- @class StopMotionRegion
    --- @field Color fun(self: StopMotionRegion, r: number, g: number, b: number, a: number)
    function region:Color(r, g, b, a)
      region.color_r = r;
      region.color_g = g;
      region.color_b = b;
      region.color_a = a;
      if (r or g or b) then
        a = a or 1;
      end
      region.foreground:SetColor(region.color_anim_r or r, region.color_anim_g or g, region.color_anim_b or b, region.color_anim_a or a);
    end

    --- @class StopMotionRegion
    --- @field ColorAnim fun(self: StopMotionRegion, r: number, g: number, b: number, a: number)
    function region:ColorAnim(r, g, b, a)
      region.color_anim_r = r;
      region.color_anim_g = g;
      region.color_anim_b = b;
      region.color_anim_a = a;
      if (r or g or b) then
        a = a or 1;
      end
      region.foreground:SetColor(r or region.color_r, g or region.color_g, b or region.color_b, a or region.color_a);
    end

    region:Color(data.foregroundColor[1], data.foregroundColor[2], data.foregroundColor[3], data.foregroundColor[4]);

    --- @class StopMotionRegion
    --- @field PreShow fun(self: StopMotionRegion)
    function region:PreShow()
      region.foreground:SetStartTime(GetTime())
      if region.FrameTick then
        region:FrameTick()
      end
    end

    region.FrameTick = nil
    if data.animationType == "loop" or data.animationType == "bounce" or data.animationType == "once" then
      region.FrameTick = FrameTickFunctions.timed
      region.subRegionEvents:AddSubscriber("FrameTick", region, true)
      region.UpdateValue = nil
      region.UpdateTime = nil
      function region:Update()
        region:UpdateProgress()
      end
    elseif data.animationType == "progress" then
      function region:Update()
        region:UpdateProgress()
      end

      function region:UpdateValue()
        local progress = 0;
        if (self.total ~= 0) then
          progress = self.value / self.total
        end
        self.foreground:SetProgress(progress)
        if self.FrameTick then
          self.FrameTick = nil
          self.subRegionEvents:RemoveSubscriber("FrameTick", self)
        end
      end

      function region:UpdateTime()
        if self.paused  then
          if self.FrameTick then
            self.FrameTick = nil
            self.subRegionEvents:RemoveSubscriber("FrameTick", self)
          end
          local remaining = self.remaining
          local progress = 1 - (remaining / self.duration)
          self.foreground:SetProgress(progress)
        else
          if not self.FrameTick then
            self.FrameTick = FrameTickFunctions.progressTimer
            self.subRegionEvents:AddSubscriber("FrameTick", self)
          end

          self:FrameTick()
        end
      end
    end
    --- @class StopMotionRegion
    --- @field SetRegionWidth fun(self: StopMotionRegion, width: number)
    function region:SetRegionWidth(width)
      self.width = width
      self:Scale(self.scalex, self.scaley)
    end

    --- @class StopMotionRegion
    --- @field SetRegionHeight fun(self: StopMotionRegion, height: number)
    function region:SetRegionHeight(height)
      self.height = height
      self:Scale(self.scalex, self.scaley)
    end

    --- @class StopMotionRegion
    --- @field SetForegroundDesaturated fun(self: StopMotionRegion, b: boolean)
    function region:SetForegroundDesaturated(b)
      self.foreground:SetDesaturated(b)
    end

    --- @class StopMotionRegion
    --- @field SetBackgroundDesaturated fun(self: StopMotionRegion, b: boolean)
    function region:SetBackgroundDesaturated(b)
      self.background:SetDesaturated(b)
    end

    Private.regionPrototype.modifyFinish(parent, region, data)
end

local function validate(data)
  Private.EnforceSubregionExists(data, "subbackground")
end

Private.RegisterRegionType("stopmotion", create, modify, default, GetProperties, validate);


-- ========================================
-- File: WeakAuras/RegionTypes/Text.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

local defaultFont = WeakAuras.defaultFont
local defaultFontSize = WeakAuras.defaultFontSize

local default = {
  displayText = "%p",
  outline = "OUTLINE",
  color = {1, 1, 1, 1},
  justify = "LEFT",
  selfPoint = "BOTTOM",
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  font = defaultFont,
  fontSize = defaultFontSize,
  frameStrata = 1,
  customTextUpdate = "event",
  automaticWidth = "Auto",
  fixedWidth = 200,
  wordWrap = "WordWrap",

  shadowColor = { 0, 0, 0, 1},
  shadowXOffset = 1,
  shadowYOffset = -1
};

local properties = {
  color = {
    display = L["Color"],
    setter = "Color",
    type = "color",
  },
  fontSize = {
    display = L["Font Size"],
    setter = "SetTextHeight",
    type = "number",
    min = 6,
    softMax = 72,
    step = 1,
    default = 12
  },
  displayText = {
    display = L["Text"],
    setter = "ChangeText",
    type = "string",
    control = "WeakAurasInputWithIndentation"
  },
}

Private.regionPrototype.AddProperties(properties, default);

--- @class TextRegion : Region
--- @field displayText string
--- @field text FontString
--- @field width number
--- @field height number
--- @field color_r number
--- @field color_g number
--- @field color_b number
--- @field color_a number
--- @field color_anim_r number
--- @field color_anim_g number
--- @field color_anim_b number
--- @field color_anim_a number
--- @field tooltipFrame Frame
--- @field ConfigureTextUpdate fun(self: TextRegion)
--- @field Update fun(self: TextRegion)
--- @field FrameTick fun(self: TextRegion)
--- @field ConfigureSubscribers fun(self: TextRegion)
--- @field Color fun(self: TextRegion, r : number, g: number, a : number)
--- @field ColorAnim fun(self: TextRegion, r : number, g: number, a : number)
--- @field GetColor fun(self: TextRegion): number, number, number, number
--- @field SetTextHeight fun(self: TextRegion, size: number)
--- @field ChangeText fun(self: TextRegion, msg: string)

local function create(parent)
  local region = CreateFrame("Frame", nil, parent);
  region.regionType = "text"
  region:SetMovable(true);

  local text = region:CreateFontString(nil, "OVERLAY");
  region.text = text;
  text:SetWordWrap(true);
  text:SetNonSpaceWrap(true);

  Private.regionPrototype.create(region);

  return region;
end

--- @type fun(parent: Frame, region: TextRegion, data: AuraData)
local function modify(parent, region, data)
  Private.regionPrototype.modify(parent, region, data);
  local text = region.text;

  local fontPath = SharedMedia:Fetch("font", data.font);
  text:SetFont(fontPath, data.fontSize, data.outline);
  if not text:GetFont() and fontPath then -- workaround font not loading correctly
    local objectName = "WeakAuras-Font-" .. data.font
    local fontObject = _G[objectName] or CreateFont(objectName)
    fontObject:SetFont(fontPath, data.fontSize, data.outline == "None" and "" or data.outline)
    text:SetFontObject(fontObject)
  end
  if not text:GetFont() then -- Font invalid, set the font but keep the setting
    text:SetFont(STANDARD_TEXT_FONT, data.fontSize, data.outline);
  end

  text:SetJustifyH(data.justify);
  text:SetText("")

  text:ClearAllPoints();
  text:SetPoint("CENTER", UIParent, "CENTER");

  region.width = text:GetWidth();
  region.height = text:GetStringHeight();
  region:SetWidth(region.width);
  region:SetHeight(region.height);

  local tooltipType = Private.CanHaveTooltip(data);
  if(tooltipType and data.useTooltip) then
    if not region.tooltipFrame then
      region.tooltipFrame = CreateFrame("Frame", nil, region);
      region.tooltipFrame:SetAllPoints(region);
      region.tooltipFrame:SetScript("OnEnter", function()
        Private.ShowMouseoverTooltip(region, region);
      end);
      region.tooltipFrame:SetScript("OnLeave", Private.HideTooltip);
    end
    region.tooltipFrame:EnableMouseMotion(true);
    region.tooltipFrame:SetMouseClickEnabled(false);
  elseif region.tooltipFrame then
    region.tooltipFrame:EnableMouseMotion(false);
  end

  text:SetTextHeight(data.fontSize);
  text:SetShadowColor(unpack(data.shadowColor))
  text:SetShadowOffset(data.shadowXOffset, data.shadowYOffset)

  text:ClearAllPoints();
  text:SetPoint(data.justify, region, data.justify);

  local SetText;

  if (data.automaticWidth == "Fixed") then
    if (data.wordWrap == "WordWrap") then
      text:SetWordWrap(true);
      text:SetNonSpaceWrap(true);
    else
      text:SetWordWrap(false);
      text:SetNonSpaceWrap(false);
    end

    text:SetWidth(data.fixedWidth);
    region:SetWidth(data.fixedWidth);
    region.width = data.fixedWidth;
    SetText = function(textStr)
      if text:GetFont() then
        text:SetText(WeakAuras.ReplaceRaidMarkerSymbols(textStr));
      end

      local height = text:GetStringHeight();

      if(region.height ~= height) then
        region.height = height
        region:SetHeight(height)
        if data.parent then
          Private.EnsureRegion(data.parent)
          if Private.regions[data.parent].region.PositionChildren then
            Private.regions[data.parent].region:PositionChildren()
          end
        end
      end
    end
  else
    text:SetWidth(0);
    text:SetWordWrap(true);
    text:SetNonSpaceWrap(true);
    SetText = function(textStr)
      if(textStr ~= text.displayText) then
        if text:GetFont() then
          text:SetText(WeakAuras.ReplaceRaidMarkerSymbols(textStr));
        end
        -- If the text changes we need to figure out the text size
        -- To unset scaling we need to temporarily detach the text from
        -- the region
        text:SetParent(UIParent)
        local width = text:GetWidth();
        local height = text:GetStringHeight();
        if(width ~= region.width or height ~= region.height ) then
          region.width = width
          region.height = height
          region:SetWidth(region.width);
          region:SetHeight(region.height);
          if(data.parent and Private.regions[data.parent].region.PositionChildren) then
            Private.regions[data.parent].region:PositionChildren();
          end
        end
        text:SetParent(region)
      end
    end
  end

  local containsCustomText = false
  if Private.ContainsCustomPlaceHolder(data.displayText) then
    containsCustomText = true
  end

  local formatters, everyFrameFormatters
  do
    local getter = function(key, default)
      local fullKey = "displayText_format_" .. key
      if (data[fullKey] == nil) then
        data[fullKey] = default
      end
      return data[fullKey]
    end

    local texts = {}
    tinsert(texts, data.displayText)

    if type(data.conditions) == "table" then
      for _, condition in ipairs(data.conditions) do
        if type(condition.changes) == "table" then
          for _, change in ipairs(condition.changes) do
            if type(change.property) == "string"
            and change.property == "displayText"
            and type(change.value) == "string"
            and Private.ContainsAnyPlaceHolders(change.value)
            then
              if not containsCustomText and Private.ContainsCustomPlaceHolder(change.value) then
                containsCustomText = true
              end
              tinsert(texts, change.value)
            end
          end
        end
      end
    end

    formatters, everyFrameFormatters = Private.CreateFormatters(texts, getter, false, data)
  end

  local customTextFunc = nil
  if containsCustomText and data.customText and data.customText ~= "" then
    customTextFunc = WeakAuras.LoadFunction("return "..data.customText, data.id)
    region.values.customTextUpdateThrottle = data.customTextUpdateThrottle or 0
  end

  function region:ConfigureTextUpdate()
    local UpdateText
    if self.displayText and Private.ContainsAnyPlaceHolders(self.displayText) then
      UpdateText = function()
        local textStr = Private.ReplacePlaceHolders(self.displayText, self, nil, false, formatters);
        if textStr == "" then
          textStr = " "
        end

        SetText(textStr)
      end
    end

    local Update
    if customTextFunc and self.displayText and Private.ContainsCustomPlaceHolder(self.displayText) then
      Update = function(self)
        if not self.values.customTextUpdated then
          self.values.custom = Private.RunCustomTextFunc(self, customTextFunc)
          self.values.lastCustomTextUpdate = GetTime()
          self.values.customTextUpdated = true
        end
        UpdateText()
        self:UpdateProgress()
      end
    else
      if UpdateText then
        Update = function()
          UpdateText()
          self:UpdateProgress()
        end
      else
        Update = function() self:UpdateProgress() end
      end
    end

    local FrameTick
    if Private.ContainsPlaceHolders(self.displayText, "p")
      or Private.AnyEveryFrameFormatters(self.displayText, everyFrameFormatters)
    then
      FrameTick = UpdateText
    end

    if customTextFunc and data.customTextUpdate == "update" then
      if Private.ContainsCustomPlaceHolder(self.displayText) then
        FrameTick = function()
          if not self.values.lastCustomTextUpdate
          or self.values.lastCustomTextUpdate + self.values.customTextUpdateThrottle < GetTime()
          then
            self.values.custom = Private.RunCustomTextFunc(self, customTextFunc)
            self.values.lastCustomTextUpdate = GetTime()
            self.values.customTextUpdated = true
          end
          UpdateText()
        end
      end
    end

    self.Update = Update
    self.FrameTick = FrameTick

    if not UpdateText then
      local textStr = self.displayText
      textStr = textStr:gsub("\\n", "\n");
      SetText(textStr)
    end
  end

  function region:ConfigureSubscribers()
    if self.FrameTick then
      self.subRegionEvents:AddSubscriber("FrameTick", self)
    else
      self.subRegionEvents:RemoveSubscriber("FrameTick", self)
    end

    if self.Update and self.state then
      self:Update()
    end
  end

  function region:Color(r, g, b, a)
    region.color_r = r;
    region.color_g = g;
    region.color_b = b;
    region.color_a = a;
    if (r or g or b) then
      a = a or 1;
    end
    text:SetTextColor(region.color_anim_r or r, region.color_anim_g or g, region.color_anim_b or b, region.color_anim_a or a);
  end

  function region:ColorAnim(r, g, b, a)
    region.color_anim_r = r;
    region.color_anim_g = g;
    region.color_anim_b = b;
    region.color_anim_a = a;
    if (r or g or b) then
      a = a or 1;
    end
    text:SetTextColor(r or region.color_r, g or region.color_g, b or region.color_b, a or region.color_a);
  end

  function region:GetColor()
    return region.color_r or data.color[1], region.color_g or data.color[2],
      region.color_b or data.color[3], region.color_a or data.color[4];
  end

  region:Color(data.color[1], data.color[2], data.color[3], data.color[4]);

  function region:SetTextHeight(size)
    local fontPath = SharedMedia:Fetch("font", data.font);
    region.text:SetFont(fontPath, size, data.outline);
    region.text:SetTextHeight(size)
  end

  function region:ChangeText(msg)
    self.displayText = msg
    self:ConfigureTextUpdate()
    self:ConfigureSubscribers()
  end

  region.displayText = data.displayText
  region:ConfigureTextUpdate()
  region:ConfigureSubscribers()
  Private.regionPrototype.modifyFinish(parent, region, data);
end

local function validate(data)
  Private.EnforceSubregionExists(data, "subbackground")
end

Private.RegisterRegionType("text", create, modify, default, properties, validate);

-- Fallback region type

local function fallbackmodify(parent, region, data)
  Private.regionPrototype.modify(parent, region, data);
  local text = region.text;

  text:SetFont(STANDARD_TEXT_FONT, data.fontSize, data.outline and "OUTLINE" or nil);
  if text:GetFont() then
    text:SetText(WeakAuras.L["Region type %s not supported"]:format(data.regionType));
  end

  text:ClearAllPoints();
  text:SetPoint("CENTER", region, "CENTER");

  region:SetWidth(text:GetWidth());
  region:SetHeight(text:GetStringHeight());

  region.Update = function() end

  Private.regionPrototype.modifyFinish(parent, region, data);
end

Private.RegisterRegionType("fallback", create, fallbackmodify, default);


-- ========================================
-- File: WeakAuras/RegionTypes/Texture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L;

local default = {
  texture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura3",
  desaturate = false,
  width = 200,
  height = 200,
  color = {1, 1, 1, 1},
  blendMode = "BLEND",
  textureWrapMode = "CLAMPTOBLACKADDITIVE",
  rotation = 0,
  mirror = false,
  rotate = false,
  selfPoint = "CENTER",
  anchorPoint = "CENTER",
  anchorFrameType = "SCREEN",
  xOffset = 0,
  yOffset = 0,
  frameStrata = 1
};

Private.regionPrototype.AddAlphaToDefault(default);

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20;

local properties = {
  texture = {
    display = L["Texture"],
    setter = "SetTexture",
    type = "texture",
  },
  color = {
    display = L["Color"],
    setter = "Color",
    type = "color",
  },
  desaturate = {
    display = L["Desaturate"],
    setter = "SetDesaturated",
    type = "bool"
  },
  width = {
    display = L["Width"],
    setter = "SetRegionWidth",
    type = "number",
    min = 1,
    softMax = screenWidth,
    bigStep = 1,
    default = 32
  },
  height = {
    display = L["Height"],
    setter = "SetRegionHeight",
    type = "number",
    min = 1,
    softMax = screenHeight,
    bigStep = 1,
    default = 32
  },
  mirror = {
    display = L["Mirror"],
    setter = "SetMirror",
    type = "bool"
  },
  rotation = {
    display = L["Rotation"],
    setter = "SetRotation",
    type = "number",
    min = 0,
    max = 360,
    bigStep = 1,
    default = 0
  }
}

Private.regionPrototype.AddProperties(properties, default);

local function create(parent)
  local region = CreateFrame("Frame", nil, UIParent);
  region.regionType = "texture"
  region:SetMovable(true);
  region:SetResizable(true);
  region:SetResizeBounds(1, 1)

  local texture = Private.TextureBase.create(region)
  region.texture = texture;
  texture:SetAllPoints(region);

  Private.regionPrototype.create(region);

  return region;
end

local function modify(parent, region, data)
  Private.regionPrototype.modify(parent, region, data);
  region:SetWidth(data.width);
  region:SetHeight(data.height);
  region.width = data.width;
  region.height = data.height;
  region.scalex = 1;
  region.scaley = 1;

  Private.TextureBase.modify(region.texture, {
    canRotate = data.rotate,
    desaturate = data.desaturate,
    blendMode = data.blendMode,
    mirror = data.mirror,
    rotation = data.rotation,
    textureWrapMode = data.textureWrapMode
  })

  function region:Scale(scalex, scaley)
    region.scalex = scalex;
    region.scaley = scaley;
    local mirror_h, mirror_v
    if(scalex < 0) then
      mirror_h = true
      scalex = scalex * -1;
    end
    region:SetWidth(region.width * scalex);
    if(scaley < 0) then
      scaley = scaley * -1;
      mirror_v = true
    end
    region:SetHeight(region.height * scaley);

    region.texture:SetMirrorFromScale(mirror_h, mirror_v)
  end

  function region:SetRegionWidth(width)
    region.width = width;
    region:Scale(region.scalex, region.scaley);
  end

  function region:SetRegionHeight(height)
    region.height = height;
    region:Scale(region.scalex, region.scaley);
  end

  function region:SetMirror(mirror)
    self.texture:SetMirror(mirror)
  end

  function region:Update()
    if self.state.texture then
      self.texture:SetTexture(self.state.texture)
    end
    self:UpdateProgress()
  end

  function region:SetTexture(texture)
    self.texture:SetTexture(texture)
  end

  region.texture:SetTexture(data.texture)

  function region:Color(r, g, b, a)
    region.color_r = r;
    region.color_g = g;
    region.color_b = b;
    region.color_a = a;
    if (r or g or b) then
      a = a or 1;
    end
    region.texture:SetVertexColor(region.color_anim_r or r, region.color_anim_g or g, region.color_anim_b or b, region.color_anim_a or a);
  end

  function region:ColorAnim(r, g, b, a)
    region.color_anim_r = r;
    region.color_anim_g = g;
    region.color_anim_b = b;
    region.color_anim_a = a;
    if (r or g or b) then
      a = a or 1;
    end
    region.texture:SetVertexColor(r or region.color_r, g or region.color_g, b or region.color_b, a or region.color_a);
  end

  function region:GetColor()
    return region.color_r or data.color[1], region.color_g or data.color[2],
      region.color_b or data.color[3], region.color_a or data.color[4];
  end

  region:Color(data.color[1], data.color[2], data.color[3], data.color[4]);

  function region:SetDesaturated(b)
    self.texture:SetDesaturated(b)
  end

  --- @type fun(degrees: number?)
  function region:SetAnimRotation(degrees)
    self.texture:SetAnimRotation(degrees)
  end

  --- @type fun(degrees: number)
  function region:SetRotation(degrees)
    self.texture:SetRotation(degrees)
  end

  --- @type fun(): number
  function region:GetBaseRotation()
    return self.texture:GetBaseRotation()
  end
  region:SetRotation(data.rotation)

  Private.regionPrototype.modifyFinish(parent, region, data);
end

local function validate(data)
  Private.EnforceSubregionExists(data, "subbackground")
end

Private.RegisterRegionType("texture", create, modify, default, properties, validate);


-- ========================================
-- File: WeakAuras/SubRegionTypes/Background.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)
local L = WeakAuras.L;

do
  local function subSupports(regionType)
    return regionType ~= "group" and regionType ~= "dynamicgroup"
  end

  local function noop()
  end

  local function subSetFrameLevel(self, level)
    self.parent:SetFrameLevel(level)
  end

  local function subCreate()
    return { Update = noop, SetFrameLevel = subSetFrameLevel}
  end

  local function subModify(parent, region)
    region.parent = parent
  end

  WeakAuras.RegisterSubRegionType("subbackground", L["Background"], subSupports, subCreate, subModify,
                                  noop, noop, {}, nil, {}, false)
end

-- Foreground for aurabar

do
  local function subSupports(regionType)
    return regionType == "aurabar"
  end

  local function noop()
  end

  local function subSetFrameLevel(self, level)
    if self.parent.bar then
      self.parent.bar:SetFrameLevel(level)
    end
    if self.parent.iconFrame then
      self.parent.iconFrame:SetFrameLevel(level)
    end
  end

  local function subCreate()
    return { Update = noop, SetFrameLevel = subSetFrameLevel}
  end

  local function subModify(parent, region)
    region.parent = parent
  end

  WeakAuras.RegisterSubRegionType("subforeground", L["Foreground"], subSupports, subCreate, subModify,
                                  noop, noop, {}, nil, {}, false)
end


-- ========================================
-- File: WeakAuras/SubRegionTypes/Border.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

local default = function(parentType)
  local options = {
    border_visible = true,
    border_color = {1, 1, 1, 1},
    border_edge = "Square Full White",
    border_offset = 0,
    border_size = 2,
  }
  if parentType == "aurabar" then
    options["anchor_area"] = "bar"
  end
  return options
end

local properties = {
  border_visible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  border_color = {
    display = L["Color"],
    setter = "SetBorderColor",
    type = "color"
  },
}


local function create()
  local region = CreateFrame("Frame", nil, UIParent, "BackdropTemplate")
  return region
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local function modify(parent, region, parentData, data, first)
  region:SetParent(parent)

  local edgeFile = SharedMedia:Fetch("border", data.border_edge)
  if edgeFile and edgeFile ~= "" then
    region:SetBackdrop({
      edgeFile = edgeFile,
      edgeSize = data.border_size,
      bgFile = nil,
    })
    region:SetBackdropBorderColor(data.border_color[1], data.border_color[2],
                                  data.border_color[3], data.border_color[4])
    region:SetBackdropColor(0, 0, 0, 0)
  end

  function region:SetBorderColor(r, g, b, a)
    self:SetBackdropBorderColor(r, g, b, a or 1)
  end

  region:SetBorderColor(data.border_color[1], data.border_color[2], data.border_color[3], data.border_color[4]);

  function region:SetVisible(visible)
    if visible then
      self:Show()
    else
      self:Hide()
    end
  end

  region:SetVisible(data.border_visible)

  region.Anchor = function()
    parent:AnchorSubRegion(region, "area", parentData.regionType == "aurabar" and data.anchor_area or nil,
                           nil, data.border_offset, data.border_offset)
  end
end

local function supports(regionType)
  return regionType == "texture"
         or regionType == "progresstexture"
         or regionType == "icon"
         or regionType == "aurabar"
         or regionType == "empty"
end

WeakAuras.RegisterSubRegionType("subborder", L["Border"], supports, create, modify, onAcquire, onRelease,
                                default, nil, properties)


-- ========================================
-- File: WeakAuras/SubRegionTypes/CircularProgressTexture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

local default = function(parentType)
  local defaults = {
    circularTextureVisible = true,

    circularTextureTexture = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\square_border_5px.tga",
    circularTextureDesaturate = false,
    circularTextureColor = {1, 1, 1, 1},
    circularTextureBlendMode = "BLEND",
    circularTextureStartAngle = 0,
    circularTextureEndAngle = 360,
    circularTextureClockwise = true,

    circularTextureCrop_x = 0.41,
    circularTextureCrop_y = 0.41,
    circularTextureRotation = 0, -- Uses tex coord rotation, called "legacy rotation" in the ui and texRotation in code everywhere else
    circularTextureAuraRotation = 0, -- Uses texture:SetRotation
    circularTextureMirror = false,

    anchor_mode = "area",
    self_point = "CENTER",
    anchor_point = "CENTER",
    width = 32,
    height = 32,
    scale = 1,

    progressSource = {-2, ""},
  }

  if parentType == "aurabar" then
    defaults.anchor_area = "bar"
  else
    defaults.anchor_area = "ALL"
  end

  return defaults
end

local properties = {
  circularTextureVisible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  circularTextureDesaturate = {
    display = L["Desaturate"],
    setter = "SetDesaturated",
    type = "bool",
  },
  circularTextureInverse = {
    display = L["Inverse"],
    setter = "SetInverse",
    type = "bool",
  },
  circularTextureColor = {
    display = L["Color"],
    setter = "SetColor",
    type = "color"
  },
  circularTextureClockwise = {
    display = L["Clockwise"],
    setter = "SetClockwise",
    type = "bool",
  },
  circularTextureAuraRotation = {
    display = L["Rotation"],
    setter = "SetAuraRotation",
    type = "number",
    min = 0,
    max = 360,
    bigStep = 10,
    default = 0
  },
  circularTextureMirror = {
    display = L["Mirror"],
    setter = "SetMirror",
    type = "bool",
  },
  circularTextureCrop_x = {
    display = L["Crop X"],
    setter = "SetCropX",
    type = "number",
    min = 0,
    softMax = 2,
    bigStep = 0.01,
    isPercent = true,
  },
  circularTextureCrop_y = {
    display = L["Crop Y"],
    setter = "SetCropY",
    type = "number",
    min = 0,
    softMax = 2,
    bigStep = 0.01,
    isPercent = true,
  },
}

--- @class CircularProgressSubElement
--- @field circularTexture CircularProgressTextureInstance
--- @field startAngle number
--- @field endAngle number
--- @field visible boolean
--- @field ProgressToAngles fun(self: CircularProgressSubElement, progress: number): number, number
--- @field FrameTick fun(self: CircularProgressSubElement)?

--- @class CircularProgressTextureInstance
local funcs = {
  --- @type fun(self: CircularProgressSubElement, b: boolean)
  SetDesaturated = function(self, b)
    self.circularTexture:SetDesaturated(b)
  end,
  --- @type fun(self: CircularProgressSubElement, ...: any)
  SetColor = function(self, ...)
    self.circularTexture:SetColor(...)
  end,
  --- @type fun(self: CircularProgressSubElement, b: boolean)
  SetVisible = function(self, b)
    self.visible = b
    if b then
      self.circularTexture:Show()
      self:UpdateFrame()
    else
      self.circularTexture:Hide()
    end
    self:UpdateFrameTick()
  end,
  --- @type fun(self: CircularProgressSubElement, radians: number)
  SetAuraRotation = function(self, degrees)
    self.circularTexture:SetAuraRotation(degrees / 180 * math.pi)
  end,
  --- @type fun(self: CircularProgressSubElement, b: boolean)
  SetMirror = function(self, b)
    self.circularTexture:SetMirror(b)
  end,
  --- @type fun(self: CircularProgressSubElement, cropX: number)
  SetCropX = function(self, cropX)
    self.circularTexture:SetCropX(1 + cropX)
  end,
  --- @type fun(self: CircularProgressSubElement, cropY: number)
  SetCropY = function(self, cropY)
    self.circularTexture:SetCropY(1 + cropY)
  end,
  --- @type fun(self: CircularProgressSubElement)
  UpdateFrameTick = function(self)
    if self.visible and self.progressData.progressType == "timed" and not self.progressData.paused then
      if not self.FrameTick then
        self.FrameTick = self.UpdateFrame

        self.parent.subRegionEvents:AddSubscriber("FrameTick", self)
      end
    else
      if self.FrameTick then
        self.FrameTick = nil
        self.parent.subRegionEvents:RemoveSubscriber("FrameTick", self)
      end
    end
  end,
  --- @type fun(self: CircularProgressSubElement, startAngle: number, endAngle: number)
  SetAngles = function(self, startAngle, endAngle)
    self.startAngle = startAngle
    self.endAngle = endAngle
  end,
  --- @type fun(self: CircularProgressSubElement, progress: number): number, number
  ProgressToAnglesClockwise = function(self, progress)
    progress = Clamp(progress, 0, 1)
    local pAngle = (self.endAngle - self.startAngle) * progress + self.startAngle
    return self.startAngle, pAngle
  end,
  --- @type fun(self: CircularProgressSubElement, progress: number): number, number
  ProgressToAnglesAntiClockwise = function(self, progress)
    progress = Clamp(progress, 0, 1)
    progress = 1 - progress
    local pAngle = (self.endAngle - self.startAngle) * progress + self.startAngle
    return pAngle, self.endAngle
  end,
  --- @type fun(self: CircularProgressSubElement, b: boolean)
  SetClockwise = function(self, b)
    if b then
      self.ProgressToAngles = self.ProgressToAnglesClockwise
    else
      self.ProgressToAngles = self.ProgressToAnglesAntiClockwise
    end
    self:UpdateFrame()
  end,
  --- @type fun(self: CircularProgressSubElement)
  UpdateFrame = function(self)
    if self.visible then
      local progressData = self.progressData
      if progressData.progressType == "static" then
        local progress = 0
        if progressData.total ~= 0 then
          progress = progressData.value / progressData.total
        end
        if self.inverse then
          progress = 1 - progress
        end
        self.circularTexture:SetProgress(self:ProgressToAngles(progress))
      elseif progressData.progressType == "timed" then
        if progressData.paused then
          local remaining = self.progressData.remaining
          local duration = self.progressData.duration
          local progress
          if duration == 0 then
            progress = 0
          else
            progress = remaining / self.progressData.duration
            if self.inverse then
              progress = 1 - progress
            end
          end
          self.circularTexture:SetProgress(self:ProgressToAngles(progress))
        else
          local remaining = self.progressData.expirationTime - GetTime()
          local duration = self.progressData.duration
          local progress
          if duration == 0 then
            progress = 0
          else
            progress = remaining / self.progressData.duration
            if self.inverse then
              progress = 1 - progress
            end
          end
          self.circularTexture:SetProgress(self:ProgressToAngles(progress))
        end
      end
    end
  end,
  Update = function(self, state, states)
    Private.UpdateProgressFrom(self.progressData, self.progressSource, self, state, states, self.parent)
    self:UpdateFrame()
    self:UpdateFrameTick()
  end,
  OnSizeChanged = function(self)
    local w, h = self:GetSize()
    self.circularTexture:SetWidth(w)
    self.circularTexture:SetHeight(h)
    self.circularTexture:UpdateTextures()
  end,
  SetInverse = function(self, inverse)
    self.inverse = inverse
    self:UpdateFrame()
  end
}

local function create()
  local region = CreateFrame("Frame", nil, UIParent)
  region:SetFlattensRenderLayers(true)

  for k, v in pairs(funcs) do
    region[k] = v
  end

  region.circularTexture = Private.CircularProgressTextureBase.create(region, "ARTWORK", 1)
  region.progressData = {}
  region:SetScript("OnSizeChanged", region.OnSizeChanged)

  return region
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local function modify(parent, region, parentData, data, first)
  region.parent = parent
  region:SetParent(parent)
  region.scale = data.scale or 1
  region.Anchor = nil

  local arg1 = data.anchor_mode == "point" and data.anchor_point or data.anchor_area
  local arg2 = data.anchor_mode == "point" and data.self_point or nil

  if data.anchor_mode == "point" then
    region:SetSize(data.width or 0, data.height or 0)
  end


  region.Anchor = function()
    region:ClearAllPoints()
    parent:AnchorSubRegion(region, data.anchor_mode, arg1, arg2, data.xOffset, data.yOffset)
    region:OnSizeChanged()
  end

  region.inverse = data.circularTextureInverse

  Private.CircularProgressTextureBase.modify(region.circularTexture, {
    crop_x = 1 + data.circularTextureCrop_x,
    crop_y = 1 + data.circularTextureCrop_y,
    texRotation = data.circularTextureRotation,
    auraRotation = data.circularTextureAuraRotation / 180 * math.pi,
    mirror = data.circularTextureMirror,
    desaturated = data.circularTextureDesaturate,
    blendMode = data.circularTextureBlendMode,
    texture = data.circularTextureTexture,
    -- width and height will be set via the anchoring function
    width = 0,
    height = 0,
    offset = 0
  })

  Private.regionPrototype.AddMinMaxProgressSource(true, region, parentData, data)

  region.FrameTick = nil
  parent.subRegionEvents:AddSubscriber("Update", region)

  region:SetVisible(data.circularTextureVisible)
  region:SetAngles(data.circularTextureStartAngle, data.circularTextureEndAngle)
  region:SetClockwise(data.circularTextureClockwise)
  region:SetColor(data.circularTextureColor[1], data.circularTextureColor[2],
                  data.circularTextureColor[3], data.circularTextureColor[4])
end

local function supports(regionType)
  return regionType == "texture"
         or regionType == "progresstexture"
         or regionType == "icon"
         or regionType == "aurabar"
         or regionType == "text"
         or regionType == "empty"
end

WeakAuras.RegisterSubRegionType("subcirculartexture", L["Circular Texture"], supports, create, modify, onAcquire, onRelease,
                                default, nil, properties)


-- ========================================
-- File: WeakAuras/SubRegionTypes/Glow.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local LCG = LibStub("LibCustomGlow-1.0")

local MSQ = LibStub("Masque", true)
local L = WeakAuras.L

local default = function(parentType)
  local options = {
    glow = false,
    useGlowColor = false,
    glowColor = {1, 1, 1, 1},
    glowType = "buttonOverlay",
    glowLines = 8,
    glowFrequency = 0.25,
    glowDuration = 1,
    glowLength = 10,
    glowThickness = 1,
    glowScale = 1,
    glowBorder = false,
    glowXOffset = 0,
    glowYOffset = 0,
  }
  if parentType == "aurabar" then
    options["glowType"] = "Pixel"
    options["anchor_area"] = "bar"
  end
  return options
end

local properties = {
  glow = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  glowType = {
    display =L["Type"],
    setter = "SetGlowType",
    type = "list",
    values = Private.glow_types,
  },
  useGlowColor = {
    display = L["Use Custom Color"],
    setter = "SetUseGlowColor",
    type = "bool"
  },
  glowColor = {
    display = L["Custom Color"],
    setter = "SetGlowColor",
    type = "color"
  },
  glowLines = {
    display = L["Lines & Particles"],
    setter = "SetGlowLines",
    type = "number",
    min = 1,
    softMax = 30,
    bigStep = 1,
    default = 4
  },
  glowFrequency = {
    display = L["Frequency"],
    setter = "SetGlowFrequency",
    type = "number",
    softMin = -2,
    softMax = 2,
    bigStep = 0.1,
    default = 0.25
  },
  glowDuration = {
    display = L["Duration"],
    setter = "SetGlowDuration",
    type = "number",
    softMin = 0.01,
    softMax = 3,
    bigStep = 0.1,
    default = 1
  },
  glowLength = {
    display = L["Length"],
    setter = "SetGlowLength",
    type = "number",
    min = 1,
    softMax = 20,
    bigStep = 1,
    default = 10
  },
  glowThickness = {
    display = L["Thickness"],
    setter = "SetGlowThickness",
    type = "number",
    min = 1,
    softMax = 20,
    bigStep = 1,
    default = 1
  },
  glowScale = {
    display = L["Scale"],
    setter = "SetGlowScale",
    type = "number",
    min = 0.05,
    softMax = 10,
    bigStep = 0.05,
    default = 1,
    isPercent = true
  },
  glowBorder = {
    display = L["Border"],
    setter = "SetGlowBorder",
    type = "bool"
  },
  glowXOffset = {
    display = L["X-Offset"],
    setter = "SetGlowXOffset",
    type = "number",
    softMin = -100,
    softMax = 100,
    bigStep = 1,
    default = 0
  },
  glowYOffset = {
    display = L["Y-Offset"],
    setter = "SetGlowYOffset",
    type = "number",
    softMin = -100,
    softMax = 100,
    bigStep = 1,
    default = 0
  },
  glowStartAnim = {
    display = L["Start Animation"],
    setter = "SetGlowStartAnim",
    type = "bool",
  },
}

local function glowStart(self, frame, color)

  if frame:GetWidth() < 1 or frame:GetHeight() < 1 then
    self.glowStop(frame)
    return
  end

  if self.glowType == "buttonOverlay" then
    self.glowStart(frame, color, self.glowFrequency, 0)
  elseif self.glowType == "Pixel" then
    self.glowStart(
      frame,
      color,
      self.glowLines,
      self.glowFrequency,
      self.glowLength,
      self.glowThickness,
      self.glowXOffset,
      self.glowYOffset,
      self.glowBorder,
      nil,
      0
    )
  elseif self.glowType == "ACShine" then
    self.glowStart(
      frame,
      color,
      self.glowLines,
      self.glowFrequency,
      self.glowScale,
      self.glowXOffset,
      self.glowYOffset,
      nil,
      0
    )
  elseif self.glowType == "Proc" then
    self.glowStart(frame, {
      color = color,
      startAnim = self.glowStartAnim and true or false,
      duration = self.glowDuration,
      xOffset = self.glowXOffset,
      yOffset = self.glowYOffset,
      frameLevel = 0
    })
  end
end

local funcs = {
  SetVisible = function(self, visible)
    local color
    self.glow = visible

    if not self:IsRectValid() then
      -- This ensures that WoW tries to make the rect valid
      -- which helps the glow lib to apply the glow in the right size
      -- See Ticket: #2818
      self:GetWidth()
    end

    if self.useGlowColor then
      color = self.glowColor
    end

    if MSQ and self.parentType == "icon" then
      if (visible) then
        self.__MSQ_Shape = self:GetParent().button.__MSQ_Shape
        self:Show()
        glowStart(self, self, color)
      else
        self.glowStop(self)
        self:Hide()
      end
    elseif (visible) then
      self:Show()
      glowStart(self, self, color)
    else
      self.glowStop(self)
      self:Hide()
    end
  end,
  SetGlowType = function(self, newType)
    newType = newType or "buttonOverlay"
    if newType == self.glowType then
      return
    end

    local isGlowing = self.glow
    if isGlowing then
      self:SetVisible(false)
    end

    if newType == "buttonOverlay" then
      self.glowStart = LCG.ButtonGlow_Start
      self.glowStop = LCG.ButtonGlow_Stop
      if self.parentRegionType ~= "aurabar" then
        self.parent:AnchorSubRegion(self, "area", "region")
      end
    elseif newType == "ACShine" then
      self.glowStart = LCG.AutoCastGlow_Start
      self.glowStop = LCG.AutoCastGlow_Stop
      if self.parentRegionType ~= "aurabar" then
        self.parent:AnchorSubRegion(self, "area")
      end
    elseif newType == "Pixel" then
      self.glowStart = LCG.PixelGlow_Start
      self.glowStop = LCG.PixelGlow_Stop
      if self.parentRegionType ~= "aurabar" then
        self.parent:AnchorSubRegion(self, "area")
      end
    elseif newType == "Proc" then
      self.glowStart = LCG.ProcGlow_Start
      self.glowStop = LCG.ProcGlow_Stop
      if self.parentRegionType ~= "aurabar" then
        self.parent:AnchorSubRegion(self, "area", "region")
      end
    else -- noop function in case of unsupported glow
      self.glowStart = function() end
      self.glowStop = function() end
    end
    self.glowType = newType
    if isGlowing then
      self:SetVisible(true)
    end
  end,
  SetUseGlowColor = function(self, useGlowColor)
    self.useGlowColor = useGlowColor
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowColor = function(self, r, g, b, a)
    self.glowColor = {r, g, b, a}
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowLines = function(self, lines)
    self.glowLines = lines
    if self.glow then
      if self.glowType == "ACShine" then -- workaround ACShine not updating numbers of dots
        self:SetVisible(false)
      end
      self:SetVisible(true)
    end
  end,
  SetGlowFrequency = function(self, frequency)
    self.glowFrequency = frequency
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowDuration = function(self, duration)
    self.glowDuration = duration
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowLength = function(self, length)
    self.glowLength = length
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowThickness = function(self, thickness)
    self.glowThickness = thickness
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowScale = function(self, scale)
    self.glowScale = scale
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowBorder = function(self, border)
    self.glowBorder = border
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowStartAnim = function(self, enable)
    self.glowStartAnim = enable
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowXOffset = function(self, xoffset)
    self.glowXOffset = xoffset
    if self.glow then
      self:SetVisible(true)
    end
  end,
  SetGlowYOffset = function(self, yoffset)
    self.glowYOffset = yoffset
    if self.glow then
      self:SetVisible(true)
    end
  end,
  UpdateSize = function(self, ...)
    if self.glow then
      self:SetVisible(true)
    end
  end
}

local function create()
  local region = CreateFrame("Frame", nil, UIParent)

  for name, func  in pairs(funcs) do
    region[name] = func
  end

  return region
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion.glowType = nil
  if subRegion.glow then
    subRegion:SetVisible(false)
  end
  subRegion:Hide()
  subRegion:ClearAllPoints()
  subRegion:SetParent(UIParent)
end

local function modify(parent, region, parentData, data, first)
  region:SetParent(parent)
  region.parentRegionType = parentData.regionType
  region.parent = parent

  region.parentType = parentData.regionType
  region.useGlowColor = data.useGlowColor
  region.glowColor = data.glowColor
  region.glowLines = data.glowLines
  region.glowFrequency = data.glowFrequency
  region.glowLength = data.glowLength
  region.glowThickness = data.glowThickness
  region.glowScale = data.glowScale
  region.glowBorder = data.glowBorder
  region.glowXOffset = data.glowXOffset
  region.glowYOffset = data.glowYOffset
  region.glowStartAnim = data.glowStartAnim
  region.glowDuration = data.glowDuration

  region:SetGlowType(data.glowType)
  region:SetVisible(data.glow)

  region:SetScript("OnSizeChanged", region.UpdateSize)

  region.Anchor = function()
    if parentData.regionType == "aurabar" then
      parent:AnchorSubRegion(region, "area", data.anchor_area)
    else
      parent:AnchorSubRegion(region, "area", (data.glowType == "buttonOverlay" or data.glowType == "Proc") and "region")
    end
  end
end

-- This is used by the templates to add glow
function Private.getDefaultGlow(regionType)
  if regionType == "aurabar" then
    return {
      ["type"] = "subglow",
      glow = false,
      useGlowColor = false,
      glowColor = {1, 1, 1, 1},
      glowType = "Pixel",
      glowLines = 8,
      glowFrequency = 0.25,
      glowDuration = 1,
      glowLength = 10,
      glowThickness = 1,
      glowScale = 1,
      glowBorder = false,
      glowXOffset = 0,
      glowYOffset = 0,
      anchor_area = "bar"
    }
  else
    return {
      ["type"] = "subglow",
      glow = false,
      useGlowColor = false,
      glowColor = {1, 1, 1, 1},
      glowType = "buttonOverlay",
      glowLines = 8,
      glowFrequency = 0.25,
      glowDuration = 1,
      glowLength = 10,
      glowThickness = 1,
      glowScale = 1,
      glowBorder = false,
      glowXOffset = 0,
      glowYOffset = 0,
    }
  end
end

local supportedRegion = {
  icon = true,
  aurabar = true,
  texture = true,
  progresstexture = true,
  empty = true,
}
local function supports(regionType)
  return supportedRegion[regionType]
end

local function addDefaultsForNewAura(data)
  if data.regionType == "icon" then
    tinsert(data.subRegions, {
      ["type"] = "subglow",
      glow = false,
      useGlowColor = false,
      glowColor = {1, 1, 1, 1},
      glowType = "buttonOverlay",
      glowLines = 8,
      glowFrequency = 0.25,
      glowLength = 10,
      glowThickness = 1,
      glowScale = 1,
      glowBorder = false,
      glowXOffset = 0,
      glowYOffset = 0,
    })
  end
end

WeakAuras.RegisterSubRegionType("subglow", L["Glow"], supports, create, modify, onAcquire, onRelease,
                                default, addDefaultsForNewAura, properties)


-- ========================================
-- File: WeakAuras/SubRegionTypes/LinearProgressTexture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

local default = function(parentType)
  local defaults = {
    linearTextureVisible = true,
    linearTextureTexture = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite",
    linearTextureDesaturate = false,
    linearTextureColor = {1, 1, 1, 1},
    linearTextureBlendMode = "BLEND",
    linearTextureOrientation = "HORIZONTAL",
    linearTextureWrapMode = "CLAMPTOBLACKADDITIVE",

    linearTextureUser_x = 0,
    linearTextureUser_y = 0,
    linearTextureCrop_x = 0.41,
    linearTextureCrop_y = 0.41,
    linearTextureRotation = 0, -- Uses tex coord rotation, called "legacy rotation" in the ui and texRotation in code everywhere else
    linearTextureAuraRotation = 0, -- Uses texture:SetRotation
    linearTextureMirror = false,

    anchor_mode = "area",
    self_point = "CENTER",
    anchor_point = "CENTER",
    width = 32,
    height = 32,
    scale = 1,

    progressSource = {-2, ""},
  }

  if parentType == "aurabar" then
    defaults.anchor_area = "bar"
  else
    defaults.anchor_area = "ALL"
  end

  return defaults
end

local properties = {
  linearTextureVisible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  linearTextureDesaturate = {
    display = L["Desaturate"],
    setter = "SetDesaturated",
    type = "bool",
  },
  linearTextureInverse = {
    display = L["Inverse"],
    setter = "SetInverse",
    type = "bool",
  },
  linearTextureColor = {
    display = L["Color"],
    setter = "SetColor",
    type = "color"
  },
  linearTextureAuraRotation = {
    display = L["Rotation"],
    setter = "SetAuraRotation",
    type = "number",
    min = 0,
    max = 360,
    bigStep = 10,
    default = 0
  },
  linearTextureMirror = {
    display = L["Mirror"],
    setter = "SetMirror",
    type = "bool",
  },
  linearTextureCrop_x = {
    display = L["Crop X"],
    setter = "SetCropX",
    type = "number",
    min = 0,
    softMax = 2,
    bigStep = 0.01,
    isPercent = true,
  },
  linearTextureCrop_y = {
    display = L["Crop Y"],
    setter = "SetCropY",
    type = "number",
    min = 0,
    softMax = 2,
    bigStep = 0.01,
    isPercent = true,
  },
}

--- @class LinearProgressSubElement
--- @field linearTexture LinearProgressTextureInstance
--- @field visible boolean
--- @field FrameTick fun(self: LinearProgressSubElement)?

--- @class LinearProgressTextureInstance
local funcs = {
  --- @type fun(self: LinearProgressSubElement, b: boolean)
  SetDesaturated = function(self, b)
    self.linearTexture:SetDesaturated(b)
  end,
  --- @type fun(self: LinearProgressSubElement, ...: any)
  SetColor = function(self, ...)
    self.linearTexture:SetColor(...)
  end,
  --- @type fun(self: LinearProgressSubElement, b: boolean)
  SetVisible = function(self, b)
    self.visible = b
    if b then
      self.linearTexture:Show()
      self:UpdateFrame()
    else
      self.linearTexture:Hide()
    end
    self:UpdateFrameTick()
  end,
  --- @type fun(self: LinearProgressSubElement, radians: number)
  SetAuraRotation = function(self, degrees)
    self.linearTexture:SetAuraRotation(degrees / 180 * math.pi)
  end,
  --- @type fun(self: LinearProgressSubElement, b: boolean)
  SetMirror = function(self, b)
    self.linearTexture:SetMirror(b)
  end,
  --- @type fun(self: LinearProgressSubElement, cropX: number)
  SetCropX = function(self, cropX)
    self.linearTexture:SetCropX(1 + cropX)
  end,
  --- @type fun(self: LinearProgressSubElement, cropY: number)
  SetCropY = function(self, cropY)
    self.linearTexture:SetCropY(1 + cropY)
  end,
  --- @type fun(self: LinearProgressSubElement)
  UpdateFrameTick = function(self)
    if self.visible and self.progressData.progressType == "timed" and not self.progressData.paused then
      if not self.FrameTick then
        self.FrameTick = self.UpdateFrame

        self.parent.subRegionEvents:AddSubscriber("FrameTick", self)
      end
    else
      if self.FrameTick then
        self.FrameTick = nil
        self.parent.subRegionEvents:RemoveSubscriber("FrameTick", self)
      end
    end
  end,
  --- @type fun(self: LinearProgressSubElement)
  UpdateFrame = function(self)
    if self.visible then
      local progressData = self.progressData
      if progressData.progressType == "static" then
        local progress = 0
        if progressData.total ~= 0 then
          progress = progressData.value / progressData.total
        end
        if self.inverse then
          progress = 1 - progress
        end
        self.linearTexture:SetValue(0, progress)
      elseif progressData.progressType == "timed" then
        if progressData.paused then
          local remaining = self.progressData.remaining
          local duration = self.progressData.duration
          local progress
          if duration == 0 then
            progress = 0
          else
            progress = remaining / duration
            if self.inverse then
              progress = 1 - progress
            end
          end
          self.linearTexture:SetValue(0, progress)
        else
          local remaining = self.progressData.expirationTime - GetTime()
          local progress = remaining / self.progressData.duration
          if self.inverse then
            progress = 1 - progress
          end
          self.linearTexture:SetValue(0, progress)
        end
      end
    end
  end,
  Update = function(self, state, states)
    Private.UpdateProgressFrom(self.progressData, self.progressSource, self, state, states, self.parent)
    self:UpdateFrame()
    self:UpdateFrameTick()
  end,
  OnSizeChanged = function(self)
    local w, h = self:GetSize()
    self.linearTexture:SetWidth(w)
    self.linearTexture:SetHeight(h)
    self.linearTexture:UpdateTextures()
  end,
  SetInverse = function(self, inverse)
    self.inverse = inverse
    self:UpdateFrame()
  end
}

local function create()
  local region = CreateFrame("Frame", nil, UIParent)
  region:SetFlattensRenderLayers(true)

  for k, v in pairs(funcs) do
    region[k] = v
  end

  region.linearTexture = Private.LinearProgressTextureBase.create(region, "ARTWORK", 1)
  region.progressData = {}
  region:SetScript("OnSizeChanged", region.OnSizeChanged)

  return region
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local function modify(parent, region, parentData, data, first)
  region.parent = parent
  region:SetParent(parent)
  region.scale = data.scale or 1
  region.Anchor = nil

  local arg1 = data.anchor_mode == "point" and data.anchor_point or data.anchor_area
  local arg2 = data.anchor_mode == "point" and data.self_point or nil

  if data.anchor_mode == "point" then
    region:SetSize(data.width or 0, data.height or 0)
  end

  region.inverse = data.linearTextureInverse

  region.Anchor = function()
    region:ClearAllPoints()
    parent:AnchorSubRegion(region, data.anchor_mode, arg1, arg2, data.xOffset, data.yOffset)
    region:OnSizeChanged()
  end

  region.linearTexture:Hide()

  Private.LinearProgressTextureBase.modify(region.linearTexture, {
    user_x = -1 * (data.linearTextureUser_x or 0),
    user_y = data.linearTextureUser_y or 0,
    crop_x = 1 + data.linearTextureCrop_x,
    crop_y = 1 + data.linearTextureCrop_y,
    texRotation = data.linearTextureRotation,
    auraRotation = data.linearTextureAuraRotation / 180 * math.pi,
    mirror = data.linearTextureMirror,
    desaturated = data.linearTextureDesaturate,
    blendMode = data.linearTextureBlendMode,
    texture = data.linearTextureTexture,
    textureWrapMode = data.linearTextureWrapMode,
    -- width and height will be set via the anchoring function
    width = 0,
    height = 0,
    offset = 0
  })

  region.linearTexture:SetOrientation(data.linearTextureOrientation, false, false, 0, false, nil)
  Private.regionPrototype.AddMinMaxProgressSource(true, region, parentData, data)

  region.FrameTick = nil
  parent.subRegionEvents:AddSubscriber("Update", region)

  region:SetVisible(data.linearTextureVisible)
  region:SetColor(data.linearTextureColor[1], data.linearTextureColor[2],
                  data.linearTextureColor[3], data.linearTextureColor[4])
end

local function supports(regionType)
  return regionType == "texture"
         or regionType == "progresstexture"
         or regionType == "icon"
         or regionType == "aurabar"
         or regionType == "text"
         or regionType == "empty"
end

WeakAuras.RegisterSubRegionType("sublineartexture", L["Linear Texture"], supports, create, modify, onAcquire, onRelease,
                                default, nil, properties)


-- ========================================
-- File: WeakAuras/SubRegionTypes/Model.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L;

Private.barmodels = {}

local default = function(parentType)
  return {
    model_visible = true,
    model_alpha = 1,
    api = false,
    model_x = 0,
    model_y = 0,
    model_z = 0,
    rotation = 0,
    -- SetTransform
    model_st_tx = 0,
    model_st_ty = 0,
    model_st_tz = 0,
    model_st_rx = 270,
    model_st_ry = 0,
    model_st_rz = 0,
    model_st_us = 40,

    model_fileId = WeakAuras.IsClassic() and "165589" or "235338",
    bar_model_attach = true
  }
end

local properties = {
  model_visible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  model_alpha = {
    display = L["Alpha"],
    setter = "SetAlpha",
    type = "number",
    min = 0,
    max = 1,
    bigStep = 0.1
  }
}

local function PreShow(self)
  local data = self.data
  self:SetKeepModelOnHide(true)
  self:Show()

  -- Adjust model
  local modelId = tonumber(data.model_fileId)
  if modelId then
    pcall(self.SetModel, self, modelId)
  end

  self:ClearTransform()
  if (data.api) then
    self:MakeCurrentCameraCustom()
    self:SetTransformFixed(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
      rad(data.model_st_rx), rad(data.model_st_ry), rad(data.model_st_rz),
      data.model_st_us / 1000);
  else
    self:SetPosition(data.model_z, data.model_x, data.model_y);
    self:SetFacing(rad(data.rotation))
  end
  self:SetModelAlpha(self.region.alpha)
end

local function CreateModel()
  local model =  CreateFrame("PlayerModel", nil, UIParent)
  model.PreShow = PreShow;
  model.SetTransformFixed = Private.ModelSetTransformFixed
  return model
end

-- Keep the two model apis separate
local poolOldApi = CreateObjectPool(CreateModel)
local poolNewApi = CreateObjectPool(CreateModel)


local function AcquireModel(region, data)
  local pool = data.api and poolNewApi or poolOldApi
  local model = pool:Acquire()
  model.data = data
  Private.barmodels[model] = true
  model.api = data.api

  local anchor
  if region.parentType == "aurabar" then
    if data.bar_model_attach then
      if data.bar_model_stretch then
        anchor = region.parent.bar.fgMask
      else
        anchor = region.parent.bar
      end
    else
      anchor = region.parent.bar
    end
  else
    anchor = region.parent
  end


  local extra_width, extra_height = 0, 0
  if not(data.bar_model_attach and region.parentType == "aurabar") then
    extra_width = data.extra_width or 0
    extra_height = data.extra_height or 0
  end

  model:ClearAllPoints()
  model:SetPoint("TOPLEFT", anchor ,"TOPLEFT", -extra_width/2, extra_height/2)
  model:SetPoint("BOTTOMRIGHT", anchor ,"BOTTOMRIGHT", extra_width/2, -extra_height/2)

  model:SetParent(region)
  model:SetKeepModelOnHide(true)
  model:Show()

  -- Adjust model
  local modelId = tonumber(data.model_fileId)
  if modelId then
    pcall(model.SetModel, model, modelId)
  end

  model:ClearTransform()
  if (data.api) then
    model:MakeCurrentCameraCustom()
    model:SetTransformFixed(data.model_st_tx / 1000, data.model_st_ty / 1000, data.model_st_tz / 1000,
      rad(data.model_st_rx), rad(data.model_st_ry), rad(data.model_st_rz),
      data.model_st_us / 1000);
  else
    model:SetPosition(data.model_z, data.model_x, data.model_y);
    model:SetFacing(rad(data.rotation))
  end
  return model
end

local function ReleaseModel(model)
  model:SetKeepModelOnHide(false)
  model:Hide()
  local pool = model.api and poolNewApi or poolOldApi
  pool:Release(model)
  Private.barmodels[model] = nil
end

local funcs = {
  SetVisible = function(self, visible)
    self.visible = visible
    self:UpdateVisible()
  end,
  SetAlpha = function(self, alpha)
    if self.model then
      self.model:SetModelAlpha(alpha)
    end
    self.alpha = alpha
  end,
  AlphaChanged = function(self)
    self:SetAlpha(self.alpha)
  end,
  UpdateVisible = function(self)
    local effectiveVisible = self.parent_visible and self.visible and not self.toosmall
    if effectiveVisible then
      if not self.model then
        self.model = AcquireModel(self, self.data)
        self.model:SetModelAlpha(self.alpha)
        self.model.region = self
      end
    else
      if self.model then
        ReleaseModel(self.model)
        self.model = nil
      end
    end
  end,
  PreShow = function(self)
    self.parent_visible = true
    self:UpdateVisible()
  end,
  PreHide = function(self)
    self.parent_visible = false
    self:UpdateVisible()
  end,
  OnSizeChanged = function(self)
    -- WORKAROUND clipping being broken on the SL beta with some setups with bars of zero width
    if self:GetWidth() < 1 or self:GetHeight() < 1 then
      self.toosmall = true
    else
      self.toosmall = false
    end
    self:UpdateVisible()
  end
}

local function create()
  local subRegion = CreateFrame("Frame", nil, UIParent)
  subRegion:SetFlattensRenderLayers(true)
  subRegion:SetClipsChildren(true)

  for k, v in pairs(funcs) do
    subRegion[k] = v
  end

  subRegion:SetScript("OnSizeChanged", subRegion.OnSizeChanged)
  return subRegion
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local function modify(parent, region, parentData, data, first)
  if region.model then
    ReleaseModel(region.model)
    region.model = nil
  end

  region.data = data
  region.parentType = parentData.regionType
  region.parent = parent

  region:SetParent(parent)

  local anchor
  if parentData.regionType == "aurabar" then
    if data.bar_model_attach then
      anchor = parent.bar.fgMask
    else
      anchor = parent.bar
    end
  else
    anchor = parent
  end

  local extra_width, extra_height = 0, 0
  if not(data.bar_model_attach and parentData.regionType == "aurabar") then
    extra_width = data.extra_width or 0
    extra_height = data.extra_height or 0
  end

  region:ClearAllPoints()
  region:SetPoint("TOPLEFT", anchor ,"TOPLEFT", -extra_width/2, extra_height/2)
  region:SetPoint("BOTTOMRIGHT", anchor ,"BOTTOMRIGHT", extra_width/2, -extra_height/2)

  region:SetAlpha(data.model_alpha)
  region:SetVisible(data.model_visible)

  parent.subRegionEvents:AddSubscriber("AlphaChanged", region)
  parent.subRegionEvents:AddSubscriber("PreShow", region)
  parent.subRegionEvents:AddSubscriber("PreHide", region)
end

local function supports(regionType)
  return regionType == "texture"
         or regionType == "progresstexture"
         or regionType == "icon"
         or regionType == "aurabar"
         or regionType == "text"
         or regionType == "empty"
end

WeakAuras.RegisterSubRegionType("submodel", L["Model"], supports, create, modify, onAcquire, onRelease, default, nil, properties);


-- ========================================
-- File: WeakAuras/SubRegionTypes/StopMotion.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

local default = function(parentType)
  local defaults = {
    stopmotionVisible = true,
    barModelClip = true,

    stopmotionTexture = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\stopmotion",
    stopmotionDesaturate = false,
    stopmotionColor = {1, 1, 1, 1},
    stopmotionBlendMode = "BLEND",
    startPercent = 0,
    endPercent = 1,

    frameRate = 15,
    animationType = "loop",
    inverse = false,
    customFrames = 0,
    customRows = 16,
    customColumns = 16,
    customFileWidth = 0,
    customFileHeight = 0,
    customFrameWidth = 0,
    customFrameHeight = 0,

    anchor_mode = "area",
    self_point = "CENTER",
    anchor_point = "CENTER",
    width = 32,
    height = 32,
    scale = 1,

    progressSource = {-2, ""},
  }

  if C_AddOns.IsAddOnLoaded("WeakAurasStopMotion") then
    defaults.stopmotionTexture = "Interface\\AddOns\\WeakAurasStopMotion\\Textures\\IconOverlays\\ArcReactor"
    defaults.frameRate = 30
    defaults.scale = 3
  end

  if parentType == "aurabar" then
    defaults.anchor_area = "bar"
  else
    defaults.anchor_area = "ALL"
  end

  return defaults
end


local properties = {
  stopmotionVisible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  stopmotionDesaturate = {
    display = L["Desaturate"],
    setter = "SetDesaturated",
    type = "bool",
  },
  stopmotionColor = {
    display = L["Color"],
    setter = "SetColor",
    type = "color"
  },
}

local funcs = {
  OnSizeChanged = function(self)
    local w, h = self:GetSize()
    self.stopMotion:SetSize(w * self.scale, h * self.scale)
  end,
  SetDesaturated = function(self, b)
    self.stopMotion:SetDesaturated(b)
  end,
  SetColor = function(self, ...)
    self.stopMotion:SetColor(...)
  end,

}

local TimedFuncs = {
  SetVisible = function(self, visible)
    self.visible = visible
    if visible then
      self:Show()
      self.stopMotion:SetStartTime(GetTime())
      self.FrameTick = function()
        self.stopMotion:TimedUpdate()
      end
      self.parent.subRegionEvents:AddSubscriber("FrameTick", self)
    else
      self:Hide()
      self.FrameTick = nil
      self.parent.subRegionEvents:RemoveSubscriber("FrameTick", self)
    end
  end,
  Update = function(self) end,
}

local ProgressFuncs = {
  UpdateFrameTick = function(self)
    if self.visible and self.progressData.progressType == "timed" and not self.progressData.paused then
      if not self.FrameTick then
        self.FrameTick = self.UpdateFrame

        self.parent.subRegionEvents:AddSubscriber("FrameTick", self)
      end
    else
      if self.FrameTick then
        self.FrameTick = nil
        self.parent.subRegionEvents:RemoveSubscriber("FrameTick", self)
      end
    end
  end,
  SetVisible = function(self, visible)
    self.visible = visible
    if visible then
      self:Show()
    else
      self:Hide()
    end
    self:UpdateFrame()
    self:UpdateFrameTick()
  end,
  UpdateFrame = function(self)
    if self.visible then
      local progressData = self.progressData
      if progressData.progressType == "static" then
        local progress = 0
        if progressData.total ~= 0 then
          progress = progressData.value / progressData.total
        end
        self.stopMotion:SetProgress(progress)
      elseif progressData.progressType == "timed" then
        if progressData.paused then
          local remaining = self.progressData.remaining
          local progress = 1 - (remaining / self.progressData.duration)
          self.stopMotion:SetProgress(progress)
        else
          local remaining = self.progressData.expirationTime - GetTime()
          local progress = 1 - (remaining / self.progressData.duration)
          self.stopMotion:SetProgress(progress)
        end
      end
    end
  end,
  Update = function(self, state, states)
    Private.UpdateProgressFrom(self.progressData, self.progressSource, self, state, states, self.parent)
    self:UpdateFrame()
    self:UpdateFrameTick()
  end,
}

local function create()
  local region = CreateFrame("Frame", nil, UIParent)
  region:SetFlattensRenderLayers(true)

  for k, v in pairs(funcs) do
    region[k] = v
  end

  region.stopMotion = Private.StopMotionBase.create(region, "ARTWORK")
  region.progressData = {}

  return region
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local function modify(parent, region, parentData, data, first)
  region.parent = parent
  region:SetParent(parent)
  region.scale = data.scale or 1
  region.Anchor = nil

  if parentData.regionType == "aurabar"
    and data.anchor_mode == "area"
    and data.anchor_area == "fg"
    and data.barModelClip
  then
    -- Special anchoring for clipping !
    region:SetClipsChildren(true)
    region:SetScript("OnSizeChanged", nil)
    region:ClearAllPoints()
    region:SetAllPoints(parent.bar.fgMask)
    region.stopMotion:ClearAllPoints()
    region.stopMotion:SetAllPoints(region.parent.bar)
  else
    region:SetClipsChildren(false)
    local arg1 = data.anchor_mode == "point" and data.anchor_point or data.anchor_area
    local arg2 = data.anchor_mode == "point" and data.self_point or nil

    if data.anchor_mode == "area" and data.scale ~= 1 then
      -- Extra Scale mode
      region.stopMotion:ClearAllPoints()
      region.stopMotion:SetPoint("CENTER", region, "CENTER")
      region:SetScript("OnSizeChanged", region.OnSizeChanged)
      region:OnSizeChanged()
    else
      if data.anchor_mode == "point" then
        region:SetSize(data.width or 0, data.height or 0)
      end
      region.stopMotion:ClearAllPoints()
      region.stopMotion:SetAllPoints(region)
      region:SetScript("OnSizeChanged", nil)
    end

    region.Anchor = function()
      region:ClearAllPoints()
      parent:AnchorSubRegion(region, data.anchor_mode, arg1, arg2, data.xOffset, data.yOffset)
      if data.anchor_mode == "area" and data.scale ~= 1 then
        region:OnSizeChanged()
      end
    end
  end

  Private.StopMotionBase.modify(region.stopMotion, {
    blendMode = data.stopmotionBlendMode,
    frameRate = data.frameRate,
    inverseDirection = data.inverse,
    animationType = data.animationType,
    texture = data.stopmotionTexture,
    startPercent = data.startPercent,
    endPercent = data.endPercent,
    customFrames = data.customFrames,
    customRows = data.customRows,
    customColumns = data.customColumns,
    customFileWidth = data.customFileWidth,
    customFileHeight = data.customFileHeight,
    customFrameWidth = data.customFrameWidth,
    customFrameHeight = data.customFrameHeight,
  })

  region.stopMotion:SetColor(unpack(data.stopmotionColor))

  Private.regionPrototype.AddMinMaxProgressSource(true, region, parentData, data)

  region.FrameTick = nil
  if data.animationType == "loop" or data.animationType == "bounce" or data.animationType == "once" then
    region.Update = TimedFuncs.Update
    region.SetVisible = TimedFuncs.SetVisible
    region.UpdateFrameTick = nil
    region.UpdateFrame = nil

    parent.subRegionEvents:RemoveSubscriber("Update", region)
  else
    region.Update = ProgressFuncs.Update
    region.SetVisible = ProgressFuncs.SetVisible
    region.UpdateFrameTick = ProgressFuncs.UpdateFrameTick
    region.UpdateFrame = ProgressFuncs.UpdateFrame

    parent.subRegionEvents:AddSubscriber("Update", region)
  end

  region:SetVisible(data.stopmotionVisible)
  region:SetDesaturated(data.stopmotionDesaturate)
end

local function supports(regionType)
  return regionType == "texture"
         or regionType == "progresstexture"
         or regionType == "icon"
         or regionType == "aurabar"
         or regionType == "text"
         or regionType == "empty"
end

WeakAuras.RegisterSubRegionType("substopmotion", L["Stop Motion"], supports, create, modify, onAcquire, onRelease, default, nil, properties)


-- ========================================
-- File: WeakAuras/SubRegionTypes/SubText.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local SharedMedia = LibStub("LibSharedMedia-3.0");
local L = WeakAuras.L;

local screenWidth, screenHeight = math.ceil(GetScreenWidth() / 20) * 20, math.ceil(GetScreenHeight() / 20) * 20

local defaultFont = WeakAuras.defaultFont
local defaultFontSize = WeakAuras.defaultFontSize

local default = function(parentType)
  if parentType == "icon" then
    -- No Shadow, but Outline
    return {
      text_text = "%p",
      text_color = {1, 1, 1, 1},
      text_font = defaultFont,
      text_fontSize = defaultFontSize,
      text_fontType = "OUTLINE",
      text_visible = true,
      text_justify = "CENTER",

      text_selfPoint = "AUTO",
      anchor_point = "CENTER",
      anchorXOffset = 0,
      anchorYOffset = 0,

      text_shadowColor = { 0, 0, 0, 1},
      text_shadowXOffset = 0,
      text_shadowYOffset = 0,
      rotateText = "NONE",

      text_automaticWidth = "Auto",
      text_fixedWidth = 64,
      text_wordWrap = "WordWrap",
    }
  else
    -- With Shadow, without Outline
    return {
      text_text = "%n",
      text_color = {1, 1, 1, 1},
      text_font = defaultFont,
      text_fontSize = defaultFontSize,
      text_fontType = "None",
      text_visible = true,
      text_justify = "CENTER",

      text_selfPoint = "AUTO",
      anchor_point = parentType == "aurabar" and "INNER_RIGHT" or "BOTTOMLEFT",
      anchorXOffset = 0,
      anchorYOffset = 0,

      text_shadowColor = { 0, 0, 0, 1},
      text_shadowXOffset = 1,
      text_shadowYOffset = -1,
      rotateText = "NONE",

      text_automaticWidth = "Auto",
      text_fixedWidth = 64,
      text_wordWrap = "WordWrap",
    }
  end
end

local properties = {
  text_visible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  text_text = {
    display = L["Text"],
    setter = "ChangeText",
    type = "string",
    control = "WeakAurasInputWithIndentation"
  },
  text_color = {
    display = L["Color"],
    setter = "Color",
    type = "color",
  },
  text_fontSize = {
    display = L["Font Size"],
    setter = "SetTextHeight",
    type = "number",
    min = 6,
    softMax = 72,
    step = 1,
    default = 12
  },
  text_anchorXOffset = {
    display = L["X-Offset"],
    setter = "SetXOffset",
    type = "number",
    softMin = (-1 * screenWidth),
    softMax = screenWidth,
    bigStep = 10,
  },
  text_anchorYOffset = {
    display = L["Y-Offset"],
    setter = "SetYOffset",
    type = "number",
    softMin = (-1 * screenHeight),
    softMax = screenHeight,
    bigStep = 10,
  },
}


-- Rotate object around its origin
local function animRotate(object, degrees, anchor)
  if (not anchor) then
    anchor = "CENTER";
  end
  -- Something to rotate
  if object.animationGroup or degrees ~= 0 then
    -- Create AnimationGroup and rotation animation
    object.animationGroup = object.animationGroup or object:CreateAnimationGroup();
    local group = object.animationGroup;
    group.rotate = group.rotate or group:CreateAnimation("rotation");
    local rotate = group.rotate;

    if rotate:GetDegrees() == degrees and rotate:GetOrigin() == anchor then
      return
    end

    rotate:SetOrigin(anchor, 0, 0);
    rotate:SetDegrees(degrees);
    rotate:SetDuration(0);
    rotate:SetEndDelay(2147483647);
    group:Play();
    rotate:SetSmoothProgress(1);
    group:Pause();
  end
end

-- Calculate offset after rotation
local function getRotateOffset(object, degrees, point)
  -- Any rotation at all?
  if degrees ~= 0 then
    -- Basic offset
    local originoffset = object:GetStringHeight() / 2;
    local xo = -1 * originoffset * sin(degrees);
    local yo = originoffset * (cos(degrees) - 1);

    -- Alignment dependant offset
    if point:find("BOTTOM", 1, true) then
      yo = yo + (1 - cos(degrees)) * (object:GetStringWidth() / 2 - originoffset);
    elseif point:find("TOP", 1, true) then
      yo = yo - (1 - cos(degrees)) * (object:GetStringWidth() / 2 - originoffset);
    end
    if point:find("RIGHT", 1, true) then
      xo = xo + (1 - cos(degrees)) * (object:GetStringWidth() / 2 - originoffset);
    elseif point:find("LEFT", 1, true) then
      xo = xo - (1 - cos(degrees)) * (object:GetStringWidth() / 2 - originoffset);
    end

    -- Done
    return xo, yo;

  -- No rotation
  else
    return 0, 0;
  end
end

local function create()
  local region = CreateFrame("Frame", nil, UIParent);

  local text = region:CreateFontString(nil, "OVERLAY");
  region.text = text;

  -- WOW's layout system works best if frames and all their parents are anchored
  -- In this case, it appears that a text doesn't get the right size on the initial
  -- load with a custom font. (Though it works if the font is non-custom or after
  -- a ReloadUI). Just moving the normal AnchorSubRegion to the start of modify was not enough
  -- But anchoring the text to UIParent before re-anchoring it correctly does seem to fix
  -- the issue. Also see #1778
  text:SetPoint("CENTER", UIParent, "CENTER")

  text:SetWordWrap(true)
  text:SetNonSpaceWrap(true)

  return region;
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local function modify(parent, region, parentData, data, first)
  region:SetParent(parent)
  local text = region.text;

  local fontPath = SharedMedia:Fetch("font", data.text_font);
  text:SetFont(fontPath, data.text_fontSize, data.text_fontType);
  if not text:GetFont() and fontPath then -- workaround font not loading correctly
    local objectName = "WeakAuras-Font-" .. data.text_font
    local fontObject = _G[objectName] or CreateFont(objectName)
    fontObject:SetFont(fontPath, data.text_fontSize, data.text_fontType == "None" and "" or data.text_fontType)
    text:SetFontObject(fontObject)
  end
  if not text:GetFont() then -- Font invalid, set the font but keep the setting
    text:SetFont(STANDARD_TEXT_FONT, data.text_fontSize, data.text_fontType);
  end
  if text:GetFont() then
    text:SetText(WeakAuras.ReplaceRaidMarkerSymbols(data.text_text));
  end

  text:SetTextHeight(data.text_fontSize);

  text:SetShadowColor(unpack(data.text_shadowColor))
  text:SetShadowOffset(data.text_shadowXOffset, data.text_shadowYOffset)
  text:SetJustifyH(data.text_justify or "CENTER")

  if (data.text_automaticWidth == "Fixed") then
    if (data.text_wordWrap == "WordWrap") then
      text:SetWordWrap(true);
      text:SetNonSpaceWrap(true);
    else
      text:SetWordWrap(false);
      text:SetNonSpaceWrap(false);
    end

    text:SetWidth(data.text_fixedWidth);
    region:SetWidth(data.text_fixedWidth);
    region.width = data.text_fixedWidth;
  else
    text:SetWidth(0);
    text:SetWordWrap(true);
    text:SetNonSpaceWrap(true);
  end

  if first then
    local containsCustomText = false
    for index, subRegion in ipairs(parentData.subRegions) do
      if subRegion.type == "subtext" and Private.ContainsCustomPlaceHolder(subRegion.text_text) then
        containsCustomText = true
        break
      end
    end
    if not containsCustomText then
      if type(parentData.conditions) == "table" then
        for _, condition in ipairs(parentData.conditions) do
          if type(condition.changes) == "table" then
            for _, change in ipairs(condition.changes) do
              if type(change.property) == "string"
                and change.property:match("sub%.%d+%.text_text")
              then
                containsCustomText = true
                break
              end
            end
          end
        end
      end
    end
    if containsCustomText and parentData.customText and parentData.customText ~= "" then
      parent.customTextFunc = WeakAuras.LoadFunction("return "..parentData.customText, parentData.id)
      parent.values.customTextUpdateThrottle = parentData.customTextUpdateThrottle or 0
    else
      parent.customTextFunc = nil
      parent.values.customTextUpdateThrottle = 0
    end
    parent.values.custom = nil
    parent.values.lastCustomTextUpdate = nil
    parent.values.customTextUpdated = false
  end

  local texts = {}
  local textStr = data.text_text or ""
  if textStr ~= "" then
    tinsert(texts, textStr)
  end

  local subRegionIndex = 1
  for index, subRegion in ipairs(parentData.subRegions) do
    if subRegion == data then
      subRegionIndex = index
      break;
    end
  end
  if type(parentData.conditions) == "table" then
    local conditionName = "sub."..subRegionIndex..".text_text"
    for _, condition in ipairs(parentData.conditions) do
      if type(condition.changes) == "table" then
        for _, change in ipairs(condition.changes) do
          if type(change.property) == "string" and change.property == conditionName then
            if type(change.value ) == "string" and change.value ~= "" then
              tinsert(texts, change.value)
            end
          end
        end
      end
    end
  end

  local getter = function(key, default)
    local fullKey = "text_text_format_" .. key
    if (data[fullKey] == nil) then
      data[fullKey] = default
    end
    return data[fullKey]
  end

  region.subTextFormatters, region.everyFrameFormatters = Private.CreateFormatters(texts, getter, false, parentData)

  function region:ConfigureTextUpdate()
    local UpdateText
    if region.text_text and Private.ContainsAnyPlaceHolders(region.text_text) then
      UpdateText = function()
        local textStr = region.text_text or ""
        textStr = Private.ReplacePlaceHolders(textStr, parent, nil, false, self.subTextFormatters)

        if text:GetFont() then
          text:SetText(WeakAuras.ReplaceRaidMarkerSymbols(textStr))
        end
        region:UpdateAnchorOnTextChange()
      end
    end

    local Update
    if parent.customTextFunc and UpdateText then
      Update = function()
        if not parent.values.customTextUpdated then
          parent.values.custom = Private.RunCustomTextFunc(parent, parent.customTextFunc)
          parent.values.lastCustomTextUpdate = GetTime()
          parent.values.customTextUpdated = true
        end
        UpdateText()
      end
    else
      Update = UpdateText
    end

    local FrameTick
    if Private.ContainsPlaceHolders(region.text_text, "p")
       or Private.AnyEveryFrameFormatters(region.text_text, region.everyFrameFormatters)
    then
      FrameTick = UpdateText
    end

    if parent.customTextFunc and parentData.customTextUpdate == "update" then
      if Private.ContainsCustomPlaceHolder(region.text_text) then
        FrameTick = function()
          if not parent.values.lastCustomTextUpdate
          or parent.values.lastCustomTextUpdate + parent.values.customTextUpdateThrottle < GetTime()
          then
            parent.values.custom = Private.RunCustomTextFunc(parent, parent.customTextFunc)
            parent.values.lastCustomTextUpdate = GetTime()
            parent.values.customTextUpdated = true
          end
          UpdateText()
        end
      end
    end

    region.Update = Update
    region.FrameTick = FrameTick

    if not UpdateText then
      if text:GetFont() then
        local textStr = region.text_text
        textStr = textStr:gsub("\\n", "\n");
        text:SetText(WeakAuras.ReplaceRaidMarkerSymbols(textStr))
      end
    end
  end

  function region:ConfigureSubscribers()
    local visible = self:IsShown()
    if self.Update then
      if visible then
        parent.subRegionEvents:AddSubscriber("Update", region)
      end
    else
      parent.subRegionEvents:RemoveSubscriber("Update", region)
    end
    if self.FrameTick then
      if visible then
        parent.subRegionEvents:AddSubscriber("FrameTick", region)
      end
    else
      parent.subRegionEvents:RemoveSubscriber("FrameTick", region)
    end
    if self.Update and parent.state and visible then
      self:Update()
    end
  end

  function region:ChangeText(msg)
    region.text_text = msg
    region:ConfigureTextUpdate()
    region:ConfigureSubscribers()
  end

  region.text_text = data.text_text
  region:ConfigureTextUpdate()

  function region:SetTextHeight(size)
    local fontPath = SharedMedia:Fetch("font", data.text_font);
    if not text:GetFont() then -- Font invalid, set the font but keep the setting
      text:SetFont(STANDARD_TEXT_FONT, size, data.text_fontType);
    else
      region.text:SetFont(fontPath, size, data.text_fontType);
    end
    region.text:SetTextHeight(size)
    region:UpdateAnchorOnTextChange();
  end

  function region:SetVisible(visible)
    if visible then
      self:Show()
    else
      self:Hide()
    end
    region:ConfigureSubscribers()
  end

  function region:Color(r, g, b, a)
    region.color_r = r;
    region.color_g = g;
    region.color_b = b;
    region.color_a = a;
    if (r or g or b) then
      a = a or 1;
    end
    text:SetTextColor(region.color_anim_r or r, region.color_anim_g or g,
                      region.color_anim_b or b, region.color_anim_a or a)
  end

  local selfPoint = data.text_selfPoint
  if selfPoint == "AUTO" then
    if parentData.regionType == "icon" then
      local anchorPoint = data.anchor_point or "CENTER"
      if anchorPoint:sub(1, 6) == "INNER_" then
        selfPoint = anchorPoint:sub(7)
      elseif anchorPoint:sub(1, 6) == "OUTER_" then
        anchorPoint = anchorPoint:sub(7)
        selfPoint = Private.inverse_point_types[anchorPoint] or "CENTER"
      else
        selfPoint = "CENTER"
      end
    elseif parentData.regionType == "aurabar" then
      selfPoint = data.anchor_point or "CENTER"
      if selfPoint:sub(1, 5) == "ICON_" then
        selfPoint = selfPoint:sub(6)
      elseif selfPoint:sub(1, 6) == "INNER_" then
        selfPoint = selfPoint:sub(7)
      end
      selfPoint = Private.point_types[selfPoint] and selfPoint or "CENTER"
    else
      selfPoint = Private.inverse_point_types[data.anchor_point or "CENTER"] or "CENTER"
    end
  end

  region.text_anchorXOffset = data.text_anchorXOffset
  region.text_anchorYOffset = data.text_anchorYOffset

  local textDegrees = data.rotateText == "LEFT" and 90 or data.rotateText == "RIGHT" and -90 or 0;

  region.Anchor = function(self)
    local xo, yo = getRotateOffset(text, textDegrees, selfPoint)
    parent:AnchorSubRegion(text, "point", data.anchor_point, selfPoint,
                           (self.text_anchorXOffset or 0) + xo, (self.text_anchorYOffset or 0) + yo)
  end

  if textDegrees == 0 then
    region.UpdateAnchorOnTextChange = function() end
  else
    region.UpdateAnchorOnTextChange = region.Anchor
  end

  region.SetXOffset = function(self, xOffset)
    if self.text_anchorXOffset == xOffset then
      return
    end
    self.text_anchorXOffset = xOffset
    self:Anchor()
  end

  region.SetYOffset = function(self, yOffset)
    if self.text_anchorYOffset == yOffset then
      return
    end
    self.text_anchorYOffset = yOffset
    self:Anchor()
  end

  region:Color(data.text_color[1], data.text_color[2], data.text_color[3], data.text_color[4]);
  region:SetVisible(data.text_visible)
  animRotate(text, textDegrees, selfPoint)
end

local function addDefaultsForNewAura(data)
  if data.regionType == "aurabar" then
    tinsert(data.subRegions, {
      ["type"] = "subtext",
      text_text = "%p",
      text_color = {1, 1, 1, 1},
      text_font = defaultFont,
      text_fontSize = defaultFontSize,
      text_fontType = "None",
      text_justify = "CENTER",
      text_visible = true,

      text_selfPoint = "AUTO",
      anchor_point = "INNER_LEFT",
      anchorXOffset = 0,
      anchorYOffset = 0,

      text_shadowColor = { 0, 0, 0, 1},
      text_shadowXOffset = 1,
      text_shadowYOffset = -1,

      rotateText = "NONE",
    });

    tinsert(data.subRegions, {
      ["type"] = "subtext",
      text_text = "%n",
      text_color = {1, 1, 1, 1},
      text_font = defaultFont,
      text_fontSize = defaultFontSize,
      text_fontType = "None",
      text_justify = "CENTER",
      text_visible = true,

      text_selfPoint = "AUTO",
      anchor_point = "INNER_RIGHT",
      anchorXOffset = 0,
      anchorYOffset = 0,

      text_shadowColor = { 0, 0, 0, 1},
      text_shadowXOffset = 1,
      text_shadowYOffset = -1,

      rotateText = "NONE",
    });
  elseif data.regionType == "icon" then
    tinsert(data.subRegions, {
      ["type"] = "subtext",
      text_text = "%s",
      text_color = {1, 1, 1, 1},
      text_font = defaultFont,
      text_fontSize = defaultFontSize,
      text_fontType = "OUTLINE",
      text_justify = "CENTER",
      text_visible = true,

      text_selfPoint = "AUTO",
      anchor_point = "INNER_BOTTOMRIGHT",
      anchorXOffset = 0,
      anchorYOffset = 0,

      text_shadowColor = { 0, 0, 0, 1},
      text_shadowXOffset = 0,
      text_shadowYOffset = 0,

      rotateText = "NONE",
    });
  end
end

local function supports(regionType)
  return regionType == "texture"
         or regionType == "progresstexture"
         or regionType == "icon"
         or regionType == "aurabar"
         or regionType == "empty"
end

WeakAuras.RegisterSubRegionType("subtext", L["Text"], supports, create, modify, onAcquire, onRelease,
                                default, addDefaultsForNewAura, properties)


-- ========================================
-- File: WeakAuras/SubRegionTypes/Texture.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L

local default = function(parentType)
  local defaults = {
    textureVisible = true,

    textureTexture = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\Aura3",
    textureDesaturate = false,
    textureColor = {1, 1, 1, 1},
    textureBlendMode = "BLEND",
    textureMirror = false,
    textureRotate = false,
    textureRotation = 0,

    anchor_mode = "area",
    self_point = "CENTER",
    anchor_point = "CENTER",
    width = 32,
    height = 32,
    scale = 1,
    mirror = false,
    rotate = false,
  }

  if parentType == "aurabar" then
    defaults.anchor_area = "bar"
  else
    defaults.anchor_area = "ALL"
  end

  return defaults
end

local properties = {
  textureVisible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true
  },
  textureDesaturate = {
    display = L["Desaturate"],
    setter = "SetDesaturated",
    type = "bool",
  },
  textureColor = {
    display = L["Color"],
    setter = "SetColor",
    type = "color"
  },
  textureMirror = {
    display = L["Mirror"],
    setter = "SetMirror",
    type = "bool"
  },
  textureRotation = {
    display = L["Rotation"],
    setter = "SetRotation",
    type = "number",
    min = 0,
    max = 360,
    bigStep = 1,
    default = 0
  }
}

local funcs = {
  SetDesaturated = function(self, b)
    self.texture:SetDesaturated(b)
  end,
  SetColor = function(self, ...)
    self.texture:SetVertexColor(...)
  end,
  SetMirror = function(self, b)
    self.texture:SetMirror(b)
  end,
  SetRotation = function(self, rotation)
    self.texture:SetRotation(rotation)
  end,
  SetVisible = function(self, visible)
    self.visible = visible
    if visible then
      self:Show()
    else
      self:Hide()
    end
  end
}

local function create()
  local region = CreateFrame("Frame", nil, UIParent)
  region:SetFlattensRenderLayers(true)

  for k, v in pairs(funcs) do
    region[k] = v
  end

  region.texture = Private.TextureBase.create(region)
  region.texture:ClearAllPoints()
  region.texture:SetAllPoints(region)

  return region
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local function modify(parent, region, parentData, data, first)
  region.parent = parent
  region:SetParent(parent)
  region.scale = data.scale or 1

  local arg1 = data.anchor_mode == "point" and data.anchor_point or data.anchor_area
  local arg2 = data.anchor_mode == "point" and data.self_point or nil

  if data.anchor_mode == "point" then
    region:SetSize(data.width or 0, data.height or 0)
  end

  region.Anchor = function()
    region:ClearAllPoints()
    parent:AnchorSubRegion(region, data.anchor_mode, arg1, arg2, data.xOffset, data.yOffset)
  end

  Private.TextureBase.modify(region.texture, {
    canRotate = data.textureRotate,
    desaturate = data.textureDesaturate,
    blendMode = data.textureBlendMode,
    mirror = data.textureMirror,
    rotation = data.textureRotation,
    textureWrapMode = "CLAMPTOBLACKADDITIVE"
  })

  region:SetVisible(data.textureVisible)
  region:SetDesaturated(data.textureDesaturate)
  region:SetColor(data.textureColor[1], data.textureColor[2], data.textureColor[3], data.textureColor[4])
  region.texture:SetTexture(data.textureTexture)
end

local function supports(regionType)
  return regionType == "texture"
         or regionType == "progresstexture"
         or regionType == "icon"
         or regionType == "aurabar"
         or regionType == "text"
         or regionType == "empty"
end

WeakAuras.RegisterSubRegionType("subtexture", L["Texture"], supports, create, modify, onAcquire, onRelease, default, nil, properties)


-- ========================================
-- File: WeakAuras/SubRegionTypes/Tick.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local L = WeakAuras.L;

local default = function()
  return {
    tick_visible = true,
    tick_color = {1, 1, 1, 1},
    tick_placement_mode = "AtValue",
    tick_placements = {"50"},
    progressSources = {{-2, ""}},
    automatic_length = true,
    tick_thickness = 2,
    tick_length = 30,
    use_texture = false,
    tick_texture = [[Interface\CastingBar\UI-CastingBar-Spark]],
    tick_blend_mode = "ADD",
    tick_desaturate = false,
    tick_rotation = 0,
    tick_xOffset = 0,
    tick_yOffset = 0,
    tick_mirror = false,
  }
end

local properties = {
  tick_visible = {
    display = L["Visibility"],
    setter = "SetVisible",
    type = "bool",
    defaultProperty = true,
  },
  tick_color = {
    display = L["Color"],
    setter = "SetTickColor",
    type = "color",
  },
  tick_placement_mode = {
    display = L["Placement Mode"],
    setter = "SetTickPlacementMode",
    type = "list",
    values = Private.tick_placement_modes,
  },
  automatic_length = {
    display = L["Automatic Length"],
    setter = "SetAutomaticLength",
    type = "bool",
    defaultProperty = true,
  },
  tick_thickness = {
    display = L["Thickness"],
    setter = "SetTickThickness",
    type = "number",
    min = 0,
    bigStep = 1,
    default = 2,
  },
  tick_length = {
    display = L["Length"],
    setter = "SetTickLength",
    type = "number",
    min = 0,
    bigStep = 1,
    default = 30,
  },
  tick_desaturate = {
    display = L["Desaturate"],
    setter = "SetTickDesaturated",
    type = "bool",
    default = true,
  },
  tick_rotation = {
    display = L["Rotation"],
    setter = "SetTickRotation",
    type = "number",
    min = 0,
    max = 360,
    default = 0,
  },
  tick_mirror = {
    display = L["Mirror"],
    setter = "SetTickMirror",
    type = "bool",
    default = true,
  },
  tick_use_texture = {
    display = L["Use Texture"],
    setter = "SetUseTexture",
    type = "bool",
    default = true,
  },
  tick_texture = {
    display = L["Texture"],
    setter = "SetTexture",
    type = "texture"
  }
}

local function GetProperties(parentData, data)
  local result = CopyTable(properties)
  for i in ipairs(data.tick_placements) do

    result["tick_placements." .. i] = {
      display = #data.tick_placements > 1 and L["Placement %i"]:format(i) or L["Placement"],
      setter = "SetTickPlacementAt",
      type = "number",
      arg1 = i,
      validate = WeakAuras.ValidateNumeric,
    }
  end

  return result
end

local auraBarAnchor = {
  ["HORIZONTAL"] = "LEFT",
  ["HORIZONTAL_INVERSE"] = "RIGHT",
  ["VERTICAL"] = "TOP",
  ["VERTICAL_INVERSE"] = "BOTTOM",
}

local auraBarAnchorInverse = {
  ["HORIZONTAL"] = "RIGHT",
  ["HORIZONTAL_INVERSE"] = "LEFT",
  ["VERTICAL"] = "BOTTOM",
  ["VERTICAL_INVERSE"] = "TOP",
}

local function create()
  local subRegion = CreateFrame("Frame", nil, UIParent)
  subRegion.ticks = {}
  return subRegion
end

local function onAcquire(subRegion)
  subRegion:Show()
end

local function onRelease(subRegion)
  subRegion:Hide()
end

local funcs = {
  UpdateProgress = function(self, state, states)
    for i, progressSource in ipairs(self.progressSources) do
      self.progressData[i] = {}
      Private.UpdateProgressFrom(self.progressData[i], progressSource, {}, state, states, self.parent)
    end
    self:UpdateVisible()
    self:UpdateTickPlacement();
    self:UpdateFrameTick()
  end,
  OrientationChanged = function(self)
    self.orientation = self.parent:GetEffectiveOrientation()
    self.vertical = (self.orientation == "VERTICAL") or (self.orientation == "VERTICAL_INVERSE")

    self:UpdateTickPlacement()
    self:UpdateTickSize()
  end,
  OnRegionSizeChanged = function(self)
    if self.vertical then
      self.parentMinorSize, self.parentMajorSize = self.parent.bar:GetRealSize()
    else
      self.parentMajorSize, self.parentMinorSize = self.parent.bar:GetRealSize()
    end

    self:UpdateTickPlacement()
    self:UpdateTickSize()
  end,
  InverseChanged = function(self)
    self.inverse_direction = self.parent:GetInverse()
    self:UpdateTickPlacement()
  end,
  SetVisible = function(self, visible)
    if self.tick_visible ~= visible then
      self.tick_visible = visible
      self:UpdateVisible()
    end
  end,
  UpdateVisibleOne = function(self, i)
    if self.tick_visible and self.hasProgress[i] then
      self.ticks[i]:Show()
    else
      self.ticks[i]:Hide()
    end
  end,
  UpdateVisible = function(self)
    for i in ipairs(self.ticks) do
      self:UpdateVisibleOne(i)
    end
  end,
  SetTickColor = function(self, r, g, b, a)
    self.tick_color[1], self.tick_color[2], self.tick_color[3], self.tick_color[4] = r, g, b, a or 1
    if self.use_texture then
      for _, tick in ipairs(self.ticks) do
        tick:SetVertexColor(r, g, b, a or 1)
      end
      self:UpdateTickDesaturated()
    else
      for _, tick in ipairs(self.ticks) do
        tick:SetVertexColor(r, g, b, a or 1)
        tick:SetColorTexture(r, g, b, a or 1)
      end
    end
  end,
  SetTickPlacementMode = function(self, placement_mode)
    if self.tick_placement_mode ~= placement_mode then
      self.tick_placement_mode = placement_mode
      self:UpdateTickPlacement()
      self:UpdateVisible()
      self:UpdateFrameTick()
    end
  end,
  UpdateFrameTick = function(self)
    local requiresFrameTick = false
    if self.tick_placement_mode == "ValueOffset" then
      for i, progress in ipairs(self.progressData) do
        if progress.progressType == "timed" and not progress.paused then
          requiresFrameTick = true
          break
        end
      end
    end

    if requiresFrameTick then
      if not self.FrameTick then
        self.FrameTick = self.UpdateTickPlacement
        self.parent.subRegionEvents:AddSubscriber("FrameTick", self)
      end
    else
      if self.FrameTick then
        self.FrameTick = nil
        self.parent.subRegionEvents:RemoveSubscriber("FrameTick", self)
      end
    end
  end,
  SetTickPlacementAt = function(self, tick, placement)
    placement = tonumber(placement)
    if self.tick_placements[tick] ~= placement then
      self.tick_placements[tick] = placement
      self:UpdateTickPlacementOne(tick)
    end
  end,
  -- For backwards compability
  SetTickPlacement = function(self, placement)
    self:SetTickPlacementAt(1, placement)
  end,
  UpdateTickPlacement = function(self)
    for i in ipairs(self.tick_placements) do
      self:UpdateTickPlacementOne(i)
    end
  end,
  UpdateTickPlacementOne = function(self, i)
    local offsetx, offsety = 0, 0
    local width = self.parentMajorSize

    local minValue, maxValue = self.parent:GetMinMaxProgress()
    local valueRange = maxValue - minValue
    local inverse = self.inverse_direction

    if self.parent.inverse then
      inverse = not inverse
    end

    local tick_placement
    if self.tick_placement_mode == "AtValue" then
      tick_placement = self.tick_placements[i]
    elseif self.tick_placement_mode == "AtMissingValue" then
      tick_placement = maxValue - self.tick_placements[i]
    elseif self.tick_placement_mode == "AtPercent" then
      if self.tick_placements[i] >= 0 and self.tick_placements[i] <= 100 and maxValue then
        tick_placement = minValue + self.tick_placements[i] * valueRange / 100
      end
    elseif self.tick_placement_mode == "ValueOffset" then
      if maxValue ~= 0 and self.progressData[i] then
        if self.progressData[i].progressType == "timed" then
          if self.progressData[i].paused then
            if self.progressData[i].remaining then
              tick_placement = self.progressData[i].remaining + self.tick_placements[i]
            end
          else
            tick_placement = self.progressData[i].expirationTime - GetTime() + self.tick_placements[i]
          end
        elseif self.progressData[i].progressType == "static" then
          tick_placement = self.progressData[i].value + self.tick_placements[i]
        end
      end
    end

    local offset
    local percent = valueRange ~= 0 and tick_placement and (tick_placement - minValue) / valueRange
    if not percent or (percent and percent < 0 or percent > 1) then
      offset = 0
      self.hasProgress[i] = false
    else
      offset = percent * width
      self.hasProgress[i] = true
    end
    self:UpdateVisible(i)

    if (self.orientation == "HORIZONTAL_INVERSE") or (self.orientation == "VERTICAL") then
      offset = -offset
    end

    if inverse then
      offset = -offset
    end

    if (self.vertical) then
      offsety = offset
    else
      offsetx = offset
    end
    local side = inverse and auraBarAnchorInverse or auraBarAnchor
    self.ticks[i]:ClearAllPoints()
    self.ticks[i]:SetPoint("CENTER", self.parent.bar, side[self.orientation],
                       offsetx + self.tick_xOffset,
                       offsety + self.tick_yOffset)
  end,
  SetAutomaticLength = function(self, automatic_length)
    if self.automatic_length ~= automatic_length then
      self.automatic_length = automatic_length
      self:UpdateTickSize()
    end
  end,
  SetTickThickness = function(self, thickness, forced)
    if self.tick_thickness ~= thickness then
      self.tick_thickness = thickness
      self:UpdateTickSize()
    end
  end,
  SetTickLength = function(self, length, forced)
    if self.length ~= length then
      self.tick_length = length
      self:UpdateTickSize()
    end
  end,
  UpdateTickSize = function(self)
    if self.vertical then
      for i, tick in ipairs(self.ticks) do
        tick:SetHeight(self.tick_thickness)
      end
    else
      for i, tick in ipairs(self.ticks) do
        tick:SetWidth(self.tick_thickness)
      end
    end

    local length = self.automatic_length and self.parentMinorSize or self.tick_length
    if self.vertical then
      for i, tick in ipairs(self.ticks) do
        tick:SetWidth(length)
      end
    else
      for i, tick in ipairs(self.ticks) do
        tick:SetHeight(length)
      end
    end
  end,
  SetTickDesaturated = function(self, desaturate)
    if self.use_texture and self.tick_desaturate ~= desaturate then
      self.tick_desaturate = desaturate
      self:UpdateTickDesaturated()
    end
  end,
  UpdateTickDesaturated = function(self)
    for i, tick in ipairs(self.ticks) do
      tick:SetDesaturated(self.tick_desaturate)
    end
  end,
  SetTickRotation = function(self, degrees)
    if self.tick_rotation ~= degrees then
      self.tick_rotation = degrees
      self:UpdateTickRotation()
    end
  end,
  UpdateTickRotation = function(self)
    local rad = math.rad(self.tick_rotation)
    for _, tick in ipairs(self.ticks) do
      tick:SetRotation(rad)
    end
  end,
  SetTickMirror = function(self, mirror)
    if self.mirror ~= mirror then
      self.mirror = mirror
      self:UpdateTickMirror()
    end
  end,
  UpdateTickMirror = function(self)
    if self.mirror then
      for _, tick in ipairs(self.ticks) do
        tick:SetTexCoord(0,  1,  1,  1,  0,  0,  1,  0)
      end
    else
      for _, tick in ipairs(self.ticks) do
        tick:SetTexCoord(0,  0,  1,  0,  0,  1,  1,  1)
      end
    end
  end,
  SetTickBlendMode = function(self, mode)
    if self.tick_blend_mode ~= mode then
      self.tick_blend_mode = mode
      self:UpdateTickBlendMode()
    end
  end,
  UpdateTickBlendMode = function(self)
    if self.use_texture then
      for _, tick in ipairs(self.ticks) do
        tick:SetBlendMode(self.tick_blend_mode)
      end
    else
      for _, tick in ipairs(self.ticks) do
        tick:SetBlendMode("BLEND")
      end
    end
  end,
  UpdateTexture = function(self)
    if self.use_texture then
      for _, tick in ipairs(self.ticks) do
        Private.SetTextureOrAtlas(tick, self.tick_texture, "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE")
      end
    else
      for _, tick in ipairs(self.ticks) do
        tick:SetColorTexture(self.tick_color[1], self.tick_color[2], self.tick_color[3], self.tick_color[4])
      end
    end
  end,
  SetTexture = function(self, texture)
    if self.tick_texture == texture then
      return
    end
    self.tick_texture = texture
    self:UpdateTexture()
  end,
  SetUseTexture = function(self, use)
    if self.use_texture == use then
      return
    end
    self.use_texture = use
    self:UpdateTexture()
  end,

  AnchorSubRegion = function(self, subRegion, anchorType, anchorPoint, subRegionPoint, anchorXOffset, anchorYOffset)
    subRegion:ClearAllPoints()

    if anchorType == "point" then
      local xOffset = anchorXOffset or 0
      local yOffset = anchorYOffset or 0

      subRegionPoint = Private.point_types[subRegionPoint] and subRegionPoint or "CENTER"
      local tickIndex = tonumber(anchorPoint:sub(6))
      local anchorTo = tickIndex and self.ticks[tickIndex] or nil
      if anchorTo then
        subRegion:SetPoint(subRegionPoint, anchorTo, "CENTER", xOffset, yOffset)
      end
    else
      local tickIndex = tonumber(anchorPoint:sub(10))
      local anchorTo = tickIndex and self.ticks[tickIndex] or nil
      local xOffset = anchorXOffset or 0
      local yOffset = anchorYOffset or 0
      if anchorTo then
        subRegion:SetPoint("BOTTOMLEFT", anchorTo, "BOTTOMLEFT", -xOffset, -yOffset)
        subRegion:SetPoint("TOPRIGHT", anchorTo, "TOPRIGHT", xOffset,  yOffset)
      end
    end
  end
}

local function modify(parent, region, parentData, data, first)
  region:SetParent(parent)
  region.orientation = parent.effectiveOrientation
  region.inverse_direction = parentData.inverse
  region.inverse = false
  region.vertical = region.orientation == "VERTICAL" or region.orientation == "VERTICAL_INVERSE"
  if (region.vertical) then
    region.parentMinorSize, region.parentMajorSize = parent.bar:GetRealSize()
  else
    region.parentMajorSize, region.parentMinorSize = parent.bar:GetRealSize()
  end

  region.parent = parent
  region.parentData = parentData
  region.tick_visible = data.tick_visible
  region.tick_color = CopyTable(data.tick_color)
  region.tick_placement_mode = data.tick_placement_mode
  region.tick_placements = {}
  region.progressSources = {}
  region.progressData = {}
  for i, tick_placement in ipairs(data.tick_placements) do
    local value = tonumber(tick_placement)
    if region.tick_placement_mode == "ValueOffset" then
      local progressSource = Private.AddProgressSourceMetaData(parentData, data.progressSources[i] or {-2, ""})
      if value and progressSource then
        tinsert(region.tick_placements, value)
        tinsert(region.progressSources, progressSource or {})
      end
    else
      if value then
        tinsert(region.tick_placements, value)
      end
    end

    if region.ticks[i] == nil then
      local texture = region:CreateTexture()
      texture:SetSnapToPixelGrid(false)
      texture:SetTexelSnappingBias(0)
      texture:SetDrawLayer("ARTWORK", 3)
      texture:SetAllPoints()
      region.ticks[i] = texture
    end
  end

  for i = #data.tick_placements + 1, #region.ticks do
    region.ticks[i]:Hide()
  end

  region.automatic_length = data.automatic_length
  region.tick_thickness = data.tick_thickness
  region.tick_length = data.tick_length
  region.use_texture = data.use_texture
  region.tick_texture = data.tick_texture

  region.tick_xOffset = data.tick_xOffset
  region.tick_yOffset = data.tick_yOffset

  region.hasProgress = {}

  for k, v in pairs(funcs) do
    region[k] = v
  end

  if data.use_texture then
    for _, tick in ipairs(region.ticks) do
      Private.SetTextureOrAtlas(tick, data.tick_texture, "CLAMPTOBLACKADDITIVE", "CLAMPTOBLACKADDITIVE")
    end
  end

  region:SetVisible(data.tick_visible)
  region:SetTickColor(unpack(data.tick_color))
  region:SetTickDesaturated(data.tick_desaturate)
  region:SetTickBlendMode(data.tick_blend_mode)
  region:SetTickRotation(data.tick_rotation)
  region:SetTickMirror(data.tick_mirror)

  region:UpdateTickPlacement()
  region:UpdateTickSize()

  parent.subRegionEvents:AddSubscriber("UpdateProgress", region)
  parent.subRegionEvents:AddSubscriber("OrientationChanged", region)
  parent.subRegionEvents:AddSubscriber("InverseChanged", region)
  parent.subRegionEvents:AddSubscriber("OnRegionSizeChanged", region)

  region.FrameTick = nil
  region:ClearAllPoints()
  region:SetAllPoints(parent.bar)
end

local function supports(regionType)
  return regionType == "aurabar"
end

WeakAuras.RegisterSubRegionType("subtick", L["Tick"], supports, create, modify, onAcquire, onRelease,
                                default, nil, GetProperties);


-- ========================================
-- File: WeakAuras/SubscribableObject.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L

--- @class SubscribableObject
--- @field events table<string, frame[]> Subscribers ordered by "priority"
--- @field subscribers table<string, frame> Subscribers lookup
--- @field callbacks table<string, fun():nil>
--- @field ClearSubscribers fun(self: SubscribableObject)
--- @field ClearCallbacks fun(self: SubscribableObject)
--- @field AddSubscriber fun(self: SubscribableObject, event: string, subscriber: frame, highPriority: boolean?)
--- @field RemoveSubscriber fun(self: SubscribableObject, event: string, subscriber: frame)
--- @field SetOnSubscriptionStatusChanged fun(self: SubscribableObject, event: string, cb: fun())
--- @field Notify fun(self: SubscribableObject, event: type, ...: any)
--- @field HasSubscribers fun(self: SubscribableObject, event: string): boolean
local SubscribableObject =
{
  events = {},
  subscribers = {},
  callbacks = {},

  --- @type fun(self: SubscribableObject)
  ClearSubscribers = function(self)
    self.events = {}
    self.subscribers = {}
  end,

  --- @type fun(self: SubscribableObject)
  ClearCallbacks = function(self)
    self.callbacks = {}
  end,

  --- @type fun(self: SubscribableObject, event: string, subscriber: frame, highPriority: boolean?)
  AddSubscriber = function(self, event, subscriber, highPriority)
    if not subscriber[event] then
      print("Can't register for ", event, " ", subscriber, subscriber.type)
      return
    end

    self.events[event] = self.events[event] or {}
    self.subscribers[event] = self.subscribers[event] or {}
    if self.subscribers[event][subscriber] then
      -- Already subscribed, just return
      return
    end
    self.subscribers[event][subscriber] = true
    local pos = highPriority and 1 or (#self.events[event] + 1)
    if TableHasAnyEntries(self.events[event]) then
      tinsert(self.events[event], pos, subscriber)
    else
      tinsert(self.events[event], pos, subscriber)
      if self.callbacks[event] then
        self.callbacks[event]()
      end
    end
  end,

  --- @type fun(self: SubscribableObject, event: string, subscriber: frame)
  RemoveSubscriber = function(self, event, subscriber)
    if self.events[event] then
      if not self.subscribers[event][subscriber] then
        -- Not subscribed
        return
      end

      self.subscribers[event][subscriber] = nil
      local index = tIndexOf(self.events[event], subscriber)
      if index then
        tremove(self.events[event], index)
        if not TableHasAnyEntries(self.events[event]) then
          if self.callbacks[event] then
            self.callbacks[event]()
          end
        end
      end
    end
  end,

  --- @type fun(self: SubscribableObject, event: string, cb: fun())
  SetOnSubscriptionStatusChanged = function(self, event, cb)
    self.callbacks[event] = cb
  end,

  --- @type fun(self: SubscribableObject, event: type, ...: any)
  Notify = function(self, event, ...)
    if self.events[event] then
      for _, subscriber in ipairs(self.events[event]) do
        subscriber[event](subscriber, ...)
      end
    end
  end,

  --- @type fun(self: SubscribableObject, event: string): boolean
  HasSubscribers = function(self, event)
    return self.events[event] and TableHasAnyEntries(self.events[event])
  end
}

function Private.CreateSubscribableObject()
  return CopyTable(SubscribableObject)
end


-- ========================================
-- File: WeakAuras/TSUHelpers.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@alias key string | integer
---@alias states table<key, state>

---@type fun(state: state)
local function fixMissingFields(state)
  if type(state) ~= "table" then return end
  -- set show
  if state.show == nil then
    state.show = true
  end
end

---@type fun(states: states, key: key): boolean
local remove = function(states, key)
  local changed = false
  local state = states[key]
  if state then
    state.show = false
    state.changed = true
    states:SetChanged(true)
    changed = true
  end
  return changed
end

---@type fun(states: states): boolean
local removeAll = function(states)
  local changed = false
  for _, state in pairs(states) do
    state.show = false
    state.changed = true
    changed = true
  end
  if changed then
    states:SetChanged(true)
  end
  return changed
end

local skipKeys = {
  trigger = true,
  triggernum = true
}

local function recurseReplaceOrUpdate(t1, t2, isRoot, replace)
  local changed = false
  if replace then
    -- Remove keys in t1 that are not in t2
    for k in pairs(t1) do
      if t2[k] == nil then
        t1[k] = nil
        changed = true
      end
    end
  end
  for k, v in pairs(t2) do
    if isRoot and skipKeys[k] then
      -- skip this key
    else
      if type(v) == "table" then
        if type(t1[k]) ~= "table" then
          t1[k] = {}
          changed = true
        end
        if recurseReplaceOrUpdate(t1[k], v, false, replace) then
          changed = true
        end
      else
        if t1[k] ~= v then
          t1[k] = v
          changed = true
        end
      end
    end
  end
  return changed
end

---@type fun(states: states, key: key, newState: state): boolean
local replaceOrUpdate = function(states, key, newState, replace)
  local changed = false
  local state = states[key]
  if state then
    fixMissingFields(newState)
    changed = recurseReplaceOrUpdate(state, newState, true, replace)
    if changed then
      state.changed = true
      states:SetChanged(true)
    end
  end
  return changed
end

---@type fun(states: states, key: key, newState: state): boolean
local create = function(states, key, newState)
  states[key] = newState
  states[key].changed = true
  states:SetChanged(true)
  fixMissingFields(states[key])
  return true
end

---@type fun(states: states, key: key?, newState: state): boolean
local createOrUpdate = function(states, key, newState)
  key = key or ""
  if states[key] then
    return replaceOrUpdate(states, key, newState, false)
  else
    return create(states, key, newState)
  end
end

---@type fun(states: states, key: key, field: any?): any
---return a state for a key, or a field of a state for a key/field
local get = function(states, key, field)
  key = key or ""
  local state = states[key]
  if state then
    if field == nil then
      return state
    end
    return state[field] or nil
  end
  return nil
end

---@type fun(states: states, key: key?, newState: state): boolean
local createOrReplace = function(states, key, newState)
  key = key or ""
  if states[key] then
    return replaceOrUpdate(states, key, newState, true)
  else
    return create(states, key, newState)
  end
end

local changedStates = {}

local isChanged = function(states)
  return changedStates[states] == true
end

local setChanged = function(states, changed)
  changedStates[states] = changed
end

Private.allstatesMetatable = {
  __index = {
    Update = createOrUpdate,
    Replace = createOrReplace,
    Remove = remove,
    RemoveAll = removeAll,
    Get = get,
    IsChanged = isChanged,
    SetChanged = setChanged,
  }
}


-- ========================================
-- File: WeakAuras/TimeMachine.lua
-- ========================================

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

Private.Features:Register({
  id = "undo",
  autoEnable = {"dev", "pr", "alpha"},
  enabled = true,
  persist = true,
})

---@class TimeMachine
local TimeMachine = {
  ---@type change
  next = {
    forward = {},
    backward = {}
  },
  transaction = false,
  ---@type change[]
  changes = {},
  ---@type table<actionType, Action>
  actions = {},
  ---@type table<string, {idempotent: boolean, func: function}>
  effects = {},
  index = 0,
  sub = Private.CreateSubscribableObject(),
}

Private.TimeMachine = TimeMachine

---@alias keyPath key | (key)[]
---@alias Actor fun(data: table, path: keyPath, payload: any)
---@alias Inverter fun(data: table, path: keyPath, payload?: any): actionType, keyPath, any
---@alias actionType string
---@alias effectType string

---@class Action
---@field actor Actor
---@field inverter Inverter
---@field autoEffects? effectType[]

---@class actionRecord
---@field uid uid
---@field actionType actionType
---@field path keyPath
---@field payload any
---@field effects? effectType[]
---@field suppressAutoEffects? table<effectType, boolean>

---@class change
---@field forward actionRecord[]
---@field backward actionRecord[]

---@param data table
---@param path keyPath
---@return table, key
local function resolveKey(data, path)
  if type(path) ~= 'table' then
    return data, path
  end
  local tbl = data
  local i = 1
  while i < #path do
    if tbl[path[i]] == nil then
      tbl[path[i]] = {}
    elseif type(tbl[path[i]]) ~= 'table' then
      error("Path is not valid: " .. table.concat(path, '.') .. " at " .. path[i])
    end
    tbl = tbl[path[i]]
    i = i + 1
  end
  return tbl, path[#path]
end

local function copy(tbl, key)
  if type(tbl[key]) == "table" then
    return CopyTable(tbl[key])
  else
    return tbl[key]
  end
end

---@type fun(self: self, tag: effectType, func: fun(uid:uid, data: auraData), idempotent?: boolean)
function TimeMachine:RegisterEffect(tag, func, idempotent)
  if self.effects[tag] then
    error("Effect already registered: " .. tag)
  end
  self.effects[tag] = {
    idempotent = idempotent,
    func = func
  }
end

TimeMachine:RegisterEffect("add", function(uid, data)
  Private.Add(data)
end, true)

TimeMachine:RegisterEffect("options_cu", function(uid, data)
  if WeakAuras.IsOptionsOpen() then
    WeakAuras.ClearAndUpdateOptions(data.id, true)
  end
end, true)

---@type fun(self: self, actionType: actionType, action: Actor<any>, inverter: Inverter<any, any>, autoEffects?: effectType[])
function TimeMachine:RegisterAction(actionType, actor, inverter, autoEffects)
  if self.actions[actionType] then
    error("Action already registered: " .. actionType)
  end
  self.actions[actionType] = {
    actor = actor,
    inverter = inverter,
    autoEffects = autoEffects,
  }
end
TimeMachine:RegisterAction("none",
  function(_data, _path)
  end,
  function(_data, path)
    return 'none', path, nil
  end
)

TimeMachine:RegisterAction("set",
  function(data, path, value)
    local tbl, key = resolveKey(data, path)
    tbl[key] = value
  end,
  function(data, path)
    local tbl, key = resolveKey(data, path)
    return 'set', path, copy(tbl, key)
  end,
  {"add", "options_cu"}
)

TimeMachine:RegisterAction("setmany",
  function(data, path, values)
    local tbl, key = resolveKey(data, path)
    for k, v in pairs(values) do
      tbl[key][k] = v
    end
  end,
  function(data, path, values)
    local tbl, key = resolveKey(data, path)
    local inverse = {}
    for k, v in pairs(values) do
      inverse[k] = copy(tbl[key], k)
    end
    return 'setmany', path, inverse
  end,
  {"add", "options_cu"}
)

TimeMachine:RegisterAction("insert",
  function(data, path, payload)
    local tbl, key = resolveKey(data, path)
    if payload.index == nil then
      table.insert(tbl[key], payload.value)
    else
      table.insert(tbl[key], payload.index, payload.value)
    end
  end,
  function(data, path, payload)
    return 'remove', path, payload.index
  end,
  {"add", "options_cu"}
)

TimeMachine:RegisterAction("remove",
  function(data, path, payload)
    local tbl, key = resolveKey(data, path)
    if payload == nil then
      table.remove(tbl[key])
    else
      table.remove(tbl[key], payload)
    end
  end,
  function(data, path, payload)
    local tbl, key = resolveKey(data, path)
    return 'insert', path, {index = payload, value = copy(tbl[key], payload or #tbl[key])}
  end,
  {"add", "options_cu"}
)

TimeMachine:RegisterAction("swap",
  function(data, path, payload)
    local tbl, key = resolveKey(data, path)
    tbl[key][payload[1]], tbl[key][payload[2]] = tbl[key][payload[2]], tbl[key][payload[1]]
  end,
  function(data, path, payload)
    return 'swap', path, {payload[2], payload[1]}
  end,
  {"add", "options_cu"}
)

TimeMachine:RegisterAction("move",
  function(data, path, payload)
    local tbl, key = resolveKey(data, path)
    local value = table.remove(tbl, payload[1])
    table.insert(tbl[key], payload[2], value)
  end,
  function(data, path, payload)
    return 'move', path, {payload[2], payload[1]}
  end,
  {"add", "options_cu"}
)

---@param path keyPath
local function keyPathToString(path)
  if type(path) == 'table' then
    return table.concat(path, '.')
  else
    return path
  end
end

---@param effects effectType[]
local function invertEffects(effects)
  local inverted = {}
  for i = #effects, 1, -1 do
    table.insert(inverted, effects[i])
  end
  return inverted
end

function TimeMachine:StartTransaction()
  if self.transaction then
    WeakAuras.prettyPrint("If you're reading this, a time machine transaction was started, but there was already one in  progress. That's not supposed to happen. Please report this to the WeakAuras developers, thanks!")
    self:Reject()
  end
  self.transaction = true
end

---@param record actionRecord
function TimeMachine:Append(record)
  local action = self.actions[record.actionType]
  Private.DebugPrint("Forward action", record.actionType, "for", record.uid, "at", keyPathToString(record.path), "with", record.payload)
  if not action then
    error("No action for actionType: " .. record.actionType)
  end
  local inverter = action.inverter
  if not inverter then
    error("No inverter for action: " .. record.actionType)
  end
  local actionType, path, payload = inverter(Private.GetDataByUID(record.uid), record.path, record.payload)
  ---@type actionRecord
  local inverseRecord = {
    uid = record.uid,
    actionType = actionType,
    path = path,
    payload = payload,
    suppressAutoEffects = record.suppressAutoEffects and CopyTable(record.suppressAutoEffects) or nil,
    effects = record.effects and invertEffects(record.effects) or nil,
  }
  Private.DebugPrint("Backward action", actionType, "for", record.uid, "at", keyPathToString(path), "with", payload)
  table.insert(self.next.forward, record)
  table.insert(self.next.backward, 1, inverseRecord)
  if not self.transaction then
    self:Commit(true)
  end
end

---@param records actionRecord[]
function TimeMachine:AppendMany(records)
  local commit = false
  if not self.transaction then
    self:StartTransaction()
    commit = true
  end
  for _, record in ipairs(records) do
    self:Append(record)
  end
  if commit then
    self:Commit()
  end
end

function TimeMachine:Reject()
  self.next = {
    forward = {},
    backward = {}
  }
  self.transaction = false
end

---@param instant? boolean
function TimeMachine:Commit(instant)
  if not self.transaction and not instant then
    WeakAuras.prettyPrint("If you're reading this, a time machine transaction was committed, but there was no transaction in progress. That's not supposed to happen. Please report this to the WeakAuras developers, thanks!")
    return
  end
  while self.index < #self.changes do
    table.remove(self.changes)
  end
  table.insert(self.changes, self.next)
  self.next = {
    forward = {},
    backward = {}
  }
  self.transaction = false
  return self:StepForward()
end

---@param records actionRecord[]
---@param delayedEffects? table<uid, table<effectType, boolean>>
---@return {uid: uid, effect: effectType}[]?
function TimeMachine:Apply(records, delayedEffects)
  for _, record in ipairs(records) do
    local action = self.actions[record.actionType]
    if not action then
      error("No action for actionType: " .. record.actionType)
    end
    local data = Private.GetDataByUID(record.uid)
    action.actor(data, record.path, record.payload)
    if action.autoEffects or record.effects then
      ---@type effectType[]
      local effects = {}
      if action.autoEffects then
        for _, effect in ipairs(action.autoEffects) do
          if not record.suppressAutoEffects or not record.suppressAutoEffects[effect] then
            table.insert(effects, effect)
          end
        end
      end
      if record.effects then
        for _, effect in ipairs(record.effects) do
          table.insert(effects, effect)
        end
      end
      for _, effectType in ipairs(effects) do
        local effect = self.effects[effectType]
        if not effect then
          error("No effect for effectType: " .. effect)
        end
        if not delayedEffects or not effect.idempotent then
          if not record.effects or record.suppressAutoEffects then
            effect.func(record.uid, data)
          end
        else
          delayedEffects[record.uid] = delayedEffects[record.uid] or {}
          delayedEffects[record.uid][effectType] = true
        end
      end
    end
  end
  return delayedEffects
end

function TimeMachine:StepForward()
  if self.index < #self.changes then
    self.index = self.index + 1
    self:Apply(self.changes[self.index].forward)
    if self.sub:HasSubscribers("Step") then
      self.sub:Notify("Step", self.index)
    end
  end
end

function TimeMachine:StepBackward()
  if self.index > 0 then
    self:Apply(self.changes[self.index].backward)
    self.index = self.index - 1
    if self.sub:HasSubscribers("Step") then
      self.sub:Notify("Step", self.index)
    end
  end
end

--- much safer than the name suggests!
---@param id string
function TimeMachine:DestroyTheUniverse(id)
  if self.transaction then
    WeakAuras.prettyPrint("If you're reading this, a time machine transaction was destroyed, but there was one in progress. That's not supposed to happen. Please report this to the WeakAuras developers, thanks!")
    self:Reject()
  end
  if #self.changes > 0 then
    Private.DebugPrint(string.format("Destroying the universe where %i change(s) happpened, because an unexpected change happened to %q.", #self.changes, id))
  end
  self.changes = {}
  self.index = 0
  if self.sub:HasSubscribers("Step") then
    self.sub:Notify("Step", self.index)
  end
end

function TimeMachine:DescribeNext()
  return self.changes[self.index + 1] and self.changes[self.index + 1].forward
end

function TimeMachine:DescribePrevious()
  return self.changes[self.index] and self.changes[self.index].backward
end


-- ========================================
-- File: WeakAuras/Transmission.lua
-- ========================================

--[[ Transmisson.lua
This file contains all transmission related functionality, e.g. import/export and chat links.
For that it hooks into the chat frame and addon message channels.

Noteable functions in this file are:

DisplayToString(id, forChat)
Converts the display id to a plain text string

DataToString(id)
Converts the display id to a formatted table

SerializeTable(data)
Converts the table data to a formatted table

Import(str, [target])
Imports an aura from a table, which may or may not be encoded as a B64 string.
If target is installed data, or is a uid which points to installed data, then the import will be an update to that aura

]]--
if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

-- Lua APIs
local tinsert = table.insert
local tostring, string_char, strsplit = tostring, string.char, strsplit
local pairs, type, unpack = pairs, type, unpack
local error = error
local bit_band, bit_lshift, bit_rshift = bit.band, bit.lshift, bit.rshift

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local versionString = WeakAuras.versionString;

-- Local functions
local decodeB64, GenerateUniqueID
local CompressDisplay, ShowTooltip, TableToString, StringToTable
local RequestDisplay, TransmitError, TransmitDisplay

local bytetoB64 = {
  [0]="a","b","c","d","e","f","g","h",
  "i","j","k","l","m","n","o","p",
  "q","r","s","t","u","v","w","x",
  "y","z","A","B","C","D","E","F",
  "G","H","I","J","K","L","M","N",
  "O","P","Q","R","S","T","U","V",
  "W","X","Y","Z","0","1","2","3",
  "4","5","6","7","8","9","(",")"
}

local B64tobyte = {
  a =  0,  b =  1,  c =  2,  d =  3,  e =  4,  f =  5,  g =  6,  h =  7,
  i =  8,  j =  9,  k = 10,  l = 11,  m = 12,  n = 13,  o = 14,  p = 15,
  q = 16,  r = 17,  s = 18,  t = 19,  u = 20,  v = 21,  w = 22,  x = 23,
  y = 24,  z = 25,  A = 26,  B = 27,  C = 28,  D = 29,  E = 30,  F = 31,
  G = 32,  H = 33,  I = 34,  J = 35,  K = 36,  L = 37,  M = 38,  N = 39,
  O = 40,  P = 41,  Q = 42,  R = 43,  S = 44,  T = 45,  U = 46,  V = 47,
  W = 48,  X = 49,  Y = 50,  Z = 51,["0"]=52,["1"]=53,["2"]=54,["3"]=55,
  ["4"]=56,["5"]=57,["6"]=58,["7"]=59,["8"]=60,["9"]=61,["("]=62,[")"]=63
}

-- This code is based on the Encode7Bit algorithm from LibCompress
-- Credit goes to Galmok (galmok@gmail.com)
local decodeB64Table = {}

function decodeB64(str)
  local bit8 = decodeB64Table;
  local decoded_size = 0;
  local ch;
  local i = 1;
  local bitfield_len = 0;
  local bitfield = 0;
  local l = #str;
  while true do
    if bitfield_len >= 8 then
      decoded_size = decoded_size + 1;
      bit8[decoded_size] = string_char(bit_band(bitfield, 255));
      bitfield = bit_rshift(bitfield, 8);
      bitfield_len = bitfield_len - 8;
    end
    ch = B64tobyte[str:sub(i, i)];
    bitfield = bitfield + bit_lshift(ch or 0, bitfield_len);
    bitfield_len = bitfield_len + 6;
    if i > l then
      break;
    end
    i = i + 1;
  end
  return table.concat(bit8, "", 1, decoded_size)
end

function GenerateUniqueID()
  -- generates a unique random 11 digit number in base64
  local s = {}
  for i=1,11 do
    tinsert(s, bytetoB64[math.random(0, 63)])
  end
  return table.concat(s)
end
WeakAuras.GenerateUniqueID = GenerateUniqueID

local function stripNonTransmissableFields(datum, fieldMap)
  for k, v in pairs(fieldMap) do
    if type(v) == "table" and type(datum[k]) == "table" then
      stripNonTransmissableFields(datum[k], v)
    elseif v == true then
      datum[k] = nil
    end
  end
end

function CompressDisplay(data, version)
  -- Clean up custom trigger fields that are unused
  -- Those can contain lots of unnecessary data.
  -- Also we warn about any custom code, so removing unnecessary
  -- custom code prevents unnecessary warnings
  for triggernum, triggerData in ipairs(data.triggers) do
    local trigger, untrigger = triggerData.trigger, triggerData.untrigger

    if (trigger and trigger.type ~= "custom") then
      trigger.custom = nil;
      trigger.customDuration = nil;
      trigger.customName = nil;
      trigger.customIcon = nil;
      trigger.customTexture = nil;
      trigger.customStacks = nil;
      if (untrigger) then
        untrigger.custom = nil;
      end
    end
  end

  local copiedData = CopyTable(data)
  local non_transmissable_fields = version >= 2000 and Private.non_transmissable_fields_v2000
                                                       or Private.non_transmissable_fields
  stripNonTransmissableFields(copiedData, non_transmissable_fields)
  copiedData.tocversion = WeakAuras.BuildInfo
  return copiedData;
end

local function filterFunc(_, event, msg, player, l, cs, t, flag, channelId, ...)
  if flag == "GM" or flag == "DEV" or (event == "CHAT_MSG_CHANNEL" and type(channelId) == "number" and channelId > 0) then
    return
  end

  local newMsg = "";
  local remaining = msg;
  local done;
  local anyLinkFound = false
  repeat
    local start, finish, characterName, displayName = remaining:find("%[WeakAuras: ([^%s]+) %- (.*)%]");
    if(characterName and displayName) then
      characterName = characterName:gsub("|c[Ff][Ff]......", ""):gsub("|r", "");
      displayName = displayName:gsub("|c[Ff][Ff]......", ""):gsub("|r", "");
      newMsg = newMsg..remaining:sub(1, start-1);
      newMsg = newMsg.."|Hgarrmission:weakauras|h|cFF8800FF["..characterName.." |r|cFF8800FF- "..displayName.."]|h|r";
      remaining = remaining:sub(finish + 1);
      anyLinkFound = true
    else
      newMsg = newMsg .. remaining
      done = true;
    end
  until(done)
  if anyLinkFound then
    local trimmedPlayer = Ambiguate(player, "none")
    local guid = select(5, ...)
    if event == "CHAT_MSG_WHISPER" and not UnitInRaid(trimmedPlayer) and not UnitInParty(trimmedPlayer) and not (IsGuildMember and IsGuildMember(guid)) then
      local _, num = BNGetNumFriends()
      for i=1, num do
        if C_BattleNet then -- introduced in 8.2.5 PTR
          local toon = C_BattleNet.GetFriendNumGameAccounts(i)
          for j=1, toon do
            local gameAccountInfo = C_BattleNet.GetFriendGameAccountInfo(i, j);
            if gameAccountInfo.characterName == trimmedPlayer and gameAccountInfo.clientProgram == "WoW" then
              return false, newMsg, player, l, cs, t, flag, channelId, ...; -- Player is a real id friend, allow it
            end
          end
        else -- keep old method for 8.2 and Classic
          local toon = BNGetNumFriendGameAccounts(i)
          for j=1, toon do
            local _, rName, rGame = BNGetFriendGameAccountInfo(i, j)
            if rName == trimmedPlayer and rGame == "WoW" then
              return false, newMsg, player, l, cs, t, flag, channelId, ...; -- Player is a real id friend, allow it
            end
          end
        end
      end
      return true -- Filter strangers
    else
      return false, newMsg, player, l, cs, t, flag, channelId, ...;
    end
  end
end

ChatFrame_AddMessageEventFilter("CHAT_MSG_CHANNEL", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_YELL", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_GUILD", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_OFFICER", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_PARTY", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_PARTY_LEADER", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_RAID", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_RAID_LEADER", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_SAY", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_WHISPER", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_WHISPER_INFORM", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_BN_WHISPER", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_BN_WHISPER_INFORM", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_INSTANCE_CHAT", filterFunc)
ChatFrame_AddMessageEventFilter("CHAT_MSG_INSTANCE_CHAT_LEADER", filterFunc)

local Compresser = LibStub:GetLibrary("LibCompress")
local LibDeflate = LibStub:GetLibrary("LibDeflate")
local Serializer = LibStub:GetLibrary("AceSerializer-3.0")
local LibSerialize = LibStub("LibSerialize")
local Comm = LibStub:GetLibrary("AceComm-3.0")
local Chomp = LibStub:GetLibrary("Chomp")
-- the biggest bottleneck by far is in transmission and printing; so use maximal compression
local configForDeflate = {level = 9}
local configForLS = {
  errorOnUnserializableType =  false
}

local tooltipLoading;
local receivedData;

hooksecurefunc("SetItemRef", function(link, text)
  if(link == "garrmission:weakauras") then
    local _, _, characterName, displayName = text:find("|Hgarrmission:weakauras|h|cFF8800FF%[([^%s]+) |r|cFF8800FF%- (.*)%]|h");
    if(characterName and displayName) then
      characterName = characterName:gsub("|c[Ff][Ff]......", ""):gsub("|r", "");
      displayName = displayName:gsub("|c[Ff][Ff]......", ""):gsub("|r", "");
      if(IsShiftKeyDown()) then
        local editbox = GetCurrentKeyBoardFocus();
        if(editbox) then
          editbox:Insert("[WeakAuras: "..characterName.." - "..displayName.."]");
        end
      else
        characterName = characterName:gsub("%.", "")
        ShowTooltip({
          {2, "WeakAuras", displayName, 0.5, 0, 1, 1, 1, 1},
          {1, L["Requesting display information from %s ..."]:format(characterName), 1, 0.82, 0}
        });
        tooltipLoading = true;
        receivedData = false;
        RequestDisplay(characterName, displayName);
        WeakAuras.timer:ScheduleTimer(function()
          if (tooltipLoading and not receivedData and ItemRefTooltip:IsVisible()) then
            ShowTooltip({
              {2, "WeakAuras", displayName, 0.5, 0, 1, 1, 1, 1},
              {1, L["Error not receiving display information from %s"]:format(characterName), 1, 0, 0}
            })
          end
        end, 5);
      end
    else
      ShowTooltip({
        {1, "WeakAuras", 0.5, 0, 1},
        {1, L["Malformed WeakAuras link"], 1, 0, 0}
      });
    end
  end
end);

local compressedTablesCache = {}

function TableToString(inTable, forChat)
  local serialized = LibSerialize:SerializeEx(configForLS, inTable)
  local compressed
  -- get from / add to cache
  if compressedTablesCache[serialized] then
    compressed = compressedTablesCache[serialized].compressed
    compressedTablesCache[serialized].lastAccess = time()
  else
    compressed = LibDeflate:CompressDeflate(serialized, configForDeflate)
    compressedTablesCache[serialized] = {
      compressed = compressed,
      lastAccess = time(),
    }
  end
  -- remove cache items after 5 minutes
  for k, v in pairs(compressedTablesCache) do
    if v.lastAccess < (time() - 300) then
      compressedTablesCache[k] = nil
    end
  end
  local encoded = "!WA:2!"
  if(forChat) then
    encoded = encoded .. LibDeflate:EncodeForPrint(compressed)
  else
    encoded = encoded .. LibDeflate:EncodeForWoWAddonChannel(compressed)
  end
  return encoded
end

function StringToTable(inString, fromChat)
  -- encoding format:
  -- version 0: simple b64 string, compressed with LC and serialized with AS
  -- version 1: b64 string prepended with "!", compressed with LD and serialized with AS
  -- version 2+: b64 string prepended with !WA:N! (where N is encode version)
  --   compressed with LD and serialized with LS
  local _, _, encodeVersion, encoded = inString:find("^(!WA:%d+!)(.+)$")
  if encodeVersion then
    encodeVersion = tonumber(encodeVersion:match("%d+"))
  else
    encoded, encodeVersion = inString:gsub("^%!", "")
  end

  local decoded
  if(fromChat) then
    if encodeVersion > 0 then
      decoded = LibDeflate:DecodeForPrint(encoded)
    else
      decoded = decodeB64(encoded)
    end
  else
    decoded = LibDeflate:DecodeForWoWAddonChannel(encoded)
  end

  if not decoded then
    return L["Error decoding."]
  end

  local decompressed
  if encodeVersion > 0 then
    decompressed = LibDeflate:DecompressDeflate(decoded)
    if not(decompressed) then
      return L["Error decompressing"]
    end
  else
    -- We ignore the error message, since it's more likely not a weakaura.
    decompressed = Compresser:Decompress(decoded)
    if not(decompressed) then
      return L["Error decompressing. This doesn't look like a WeakAuras import."]
    end
  end


  local success, deserialized
  if encodeVersion < 2 then
    success, deserialized = Serializer:Deserialize(decompressed)
  else
    success, deserialized = LibSerialize:Deserialize(decompressed)
  end
  if not(success) then
    return L["Error deserializing"]
  end
  return deserialized
end
Private.StringToTable = StringToTable

function Private.DisplayToString(id, forChat)
  local data = WeakAuras.GetData(id);
  if(data) then
    data.uid = data.uid or GenerateUniqueID()
    -- Check which transmission version we want to use
    local version = 1421
    for child in Private.TraverseSubGroups(data) do -- luacheck: ignore
      version = 2000
      break;
    end
    local transmitData = CompressDisplay(data, version);
    local transmit = {
      m = "d",
      d = transmitData,
      v = version,
      s = versionString
    };
    if(data.controlledChildren) then
      transmit.c = {};
      local uids = {}
      local index = 1
      for child in Private.TraverseAllChildren(data) do
        if child.uid then
          if uids[child.uid] then
            child.uid = GenerateUniqueID()
          else
            uids[child.uid] = true
          end
        else
          child.uid = GenerateUniqueID()
        end
        transmit.c[index] = CompressDisplay(child, version);
        index = index + 1
      end
    end
    return TableToString(transmit, forChat);
  else
    return "";
  end
end

local orderedPairs
do
  local function __genOrderedIndex(t)
    local orderedIndex = {}
    for key in pairs(t) do
      if key ~= "__orderedIndex" then
        table.insert(orderedIndex, key)
      end
    end
    table.sort(orderedIndex, function(a, b)
      local typeA, typeB = type(a), type(b)
      if typeA ~= typeB then
        return typeA < typeB
      else
        return a < b
      end
    end)
    return orderedIndex
  end

  local function orderedNext(t, state)
    -- Equivalent of the next function, but returns the keys in the alphabetic
    -- order. We use a temporary ordered key table that is stored in the
    -- table being iterated.
    local key = nil
    if state == nil then
      -- the first time, generate the index
      t.__orderedIndex = __genOrderedIndex(t)
      key = t.__orderedIndex[1]
    else
      -- fetch the next value
      for i = 1, table.getn(t.__orderedIndex) do
        if t.__orderedIndex[i] == state then
          key = t.__orderedIndex[i+1]
        end
      end
    end

    if key then
      return key, t[key]
    end

    -- no more value to return, cleanup
    t.__orderedIndex = nil
  end

  function orderedPairs(t)
    return orderedNext, t, nil
  end
end

local function recurseStringify(data, level, lines, sorted)
  local pairsFn = sorted and orderedPairs or pairs
  for k, v in pairsFn(data) do
    local lineFormat = strrep("    ", level) .. "[%s] = %s"
    local form1, form2, value
    local kType, vType = type(k), type(v)
    if kType == "string" then
      form1 = "%q"
    elseif kType == "number" then
      form1 = "%d"
    else
      form1 = "%s"
    end
    if vType == "string" then
      form2 = "%q"
      v = v:gsub("\\", "\\\\"):gsub("\n", "\\n"):gsub("\"", "\\\"")
    elseif vType == "boolean" then
      v = tostring(v)
      form2 = "%s"
    else
      form2 = "%s"
    end
    lineFormat = lineFormat:format(form1, form2)
    if vType == "table" then
      tinsert(lines, lineFormat:format(k, "{"))
      recurseStringify(v, level + 1, lines, sorted)
      tinsert(lines, strrep("    ", level) .. "},")
    else
      tinsert(lines, lineFormat:format(k, v) .. ",")
    end
  end
end

function Private.DataToString(id, sorted)
  local data = WeakAuras.GetData(id)
  if data then
    return Private.SerializeTable(data, sorted):gsub("|", "||")
  end
end

function Private.SerializeTable(data, sorted)
  local lines = {"{"}
  recurseStringify(data, 1, lines, sorted)
  tinsert(lines, "}")
  return table.concat(lines, "\n")
end

function ShowTooltip(lines)
  ItemRefTooltip:Show();
  if not ItemRefTooltip:IsVisible() then
    ItemRefTooltip:SetOwner(UIParent, "ANCHOR_PRESERVE");
  end
  ItemRefTooltip:ClearLines();
  for i, line in ipairs(lines) do
    local sides, a1, a2, a3, a4, a5, a6, a7, a8 = unpack(line);
    if(sides == 1) then
      ItemRefTooltip:AddLine(a1, a2, a3, a4, a5);
    elseif(sides == 2) then
      ItemRefTooltip:AddDoubleLine(a1, a2, a3, a4, a5, a6, a7, a8);
    end
  end
  ItemRefTooltip:Show()
end

local delayedImport = CreateFrame("Frame")

local function ImportNow(data, children, target, linkedAuras, sender, callbackFunc)
  if InCombatLockdown() then
    WeakAuras.prettyPrint(L["Importing will start after combat ends."])

    delayedImport:RegisterEvent("PLAYER_REGEN_ENABLED")
    delayedImport:SetScript("OnEvent", function()
      delayedImport:UnregisterEvent("PLAYER_REGEN_ENABLED")
      ImportNow(data, children, target, linkedAuras, sender, callbackFunc)
    end)
    return
  end

  if Private.LoadOptions() then
    if not WeakAuras.IsOptionsOpen() then
      WeakAuras.OpenOptions()
    end
    Private.OpenUpdate(data, children, target, linkedAuras, sender, callbackFunc)
  end
end

function WeakAuras.Import(inData, target, callbackFunc, linkedAuras)
  local data, children, version
  if type(inData) == 'string' then
    -- encoded data
    local received = StringToTable(inData, true)
    if type(received) == 'string' then
      -- this is probably an error message from LibDeflate. Display it.
      ShowTooltip{
        {1, "WeakAuras", 0.5333, 0, 1},
        {1, received, 1, 0, 0, 1}
      }
      return nil, received
    elseif received.m == "d" then
      data = received.d
      children = received.c
      version = received.v
    end
  elseif type(inData.d) == 'table' then
    data = inData.d
    children = inData.c
    version = inData.v
  end
  if type(data) ~= "table" then
    return nil, "Invalid import data."
  end

  local highestVersion = data.internalVersion or 0
  if children then
    for _, child in ipairs(children) do
      highestVersion = max(highestVersion, child.internalVersion or 0)
    end
  end
  if highestVersion > WeakAuras.InternalVersion() then
    -- Do not run PreAdd but still show Import Window
    tooltipLoading = nil;
    return ImportNow(data, children, target, linkedAuras, nil, callbackFunc)
  end

  if version < 2000 then
    if children then
      data.controlledChildren = {}
      for i, child in ipairs(children) do
        tinsert(data.controlledChildren, child.id)
        child.parent = data.id
      end
    end
  end

  if type(target) ~= 'nil' then
    local uid = type(target) == 'table' and target.uid or target
    local targetData = Private.GetDataByUID(uid)
    if not targetData then
      return false, "Invalid update target."
    else
      target = targetData
    end
    if data.uid and data.uid ~= target.uid then
      return false, "Invalid update target, uids don't match."
    end
  end
  WeakAuras.PreAdd(data)
  if children then
    for _, child in ipairs(children) do
      WeakAuras.PreAdd(child)
    end
  end

  tooltipLoading = nil;
  return ImportNow(data, children, target, linkedAuras, nil, callbackFunc)
end

local safeSenders = {}
function RequestDisplay(characterName, displayName)
  local characterNameAmbiguate = Ambiguate(characterName, "none")
  safeSenders[characterName] = true
  safeSenders[characterNameAmbiguate] = true

  local version = nil
  if characterNameAmbiguate:find("-", 1, true) then
    -- Cross realm transfer, use chomp
    version = 2
  end

  local transmit = {
    m = "dR",
    d = displayName,
    v = version
  };
  local transmitString = TableToString(transmit);
  Comm:SendCommMessage("WeakAuras", transmitString, "WHISPER", characterName);
end

function TransmitError(errorMsg, characterName)
  local transmit = {
    m = "dE",
    eM = errorMsg
  };
  Comm:SendCommMessage("WeakAuras", TableToString(transmit), "WHISPER", characterName);
end

function TransmitDisplay(id, characterName, version)
  local encoded = Private.DisplayToString(id);
  if(encoded ~= "") then
    if version == 2  then
      -- Cross Realm communication
      local total = #encoded
      local messageOptions = {
        serialize = false,
        binaryBlob = true
      }

      Chomp.SmartAddonMessage("WeakAuras2", encoded, "WHISPER", characterName, messageOptions)
      -- Chomp has no progress callback for SmartAddonMessage. Send a -1 as progress info
      local done = -1
      Comm:SendCommMessage("WeakAurasProg", done.." "..total.." "..id, "WHISPER", characterName, "ALERT");
    else
      Comm:SendCommMessage("WeakAuras", encoded, "WHISPER", characterName, "BULK", function(displayName, done, total)
        Comm:SendCommMessage("WeakAurasProg", done.." "..total.." "..displayName, "WHISPER", characterName, "ALERT");
      end, id);
    end
  else
    TransmitError("dne", characterName);
  end
end

local function HandleProgressComm(prefix, message, distribution, sender)
  if tooltipLoading and ItemRefTooltip:IsVisible() and safeSenders[sender] then
    receivedData = true;
    local done, total, displayName = strsplit(" ", message, 3)
    done = tonumber(done)
    total = tonumber(total)
    if done and total then
      if done == -1 then
        ShowTooltip({
          {2, "WeakAuras", displayName, 0.5, 0, 1, 1, 1, 1},
          {1, L["Receiving display information"]:format(sender), 1, 0.82, 0},
          {2, L["No Progress Information available."]},
          {2, L["Receiving %s Bytes"]:format(total)}
        })
      elseif total >= done then
        local red = min(255, (1 - done / total) * 511)
        local green = min(255, (done / total) * 511)
        ShowTooltip({
          {2, "WeakAuras", displayName, 0.5, 0, 1, 1, 1, 1},
          {1, L["Receiving display information"]:format(sender), 1, 0.82, 0},
          {2, " ", ("|cFF%2x%2x00"):format(red, green)..done.."|cFF00FF00/"..total}
        })
      end
    end
  end
end

local function HandleComm(prefix, message, distribution, sender)
  local linkValidityDuration = 60 * 5
  local safeSender = safeSenders[sender]
  local validLink = false
  if Private.linked then
    local expiredLinkTime = GetTime() - linkValidityDuration
    for id, time in pairs(Private.linked) do
      if time > expiredLinkTime then
        validLink = true
      end
    end
  end
  if not safeSender and not validLink then
    return
  end

  local received = StringToTable(message);
  if(received and type(received) == "table" and received.m) then
    if(received.m == "d") then
      tooltipLoading = nil;
      local data, children, version = received.d, received.c, received.v
      WeakAuras.PreAdd(data)
      if children then
        for _, child in ipairs(children) do
          WeakAuras.PreAdd(child)
        end
      end
      if version < 2000 then
        if children then
          data.controlledChildren = {}
          for i, child in ipairs(children) do
            tinsert(data.controlledChildren, child.id)
            child.parent = data.id
          end
        end
      end

      ItemRefTooltip:Hide()
      ImportNow(data, children, nil, nil, sender)
    elseif(received.m == "dR") then
      if(Private.linked and Private.linked[received.d] and Private.linked[received.d] > GetTime() - linkValidityDuration) then
        TransmitDisplay(received.d, sender, received.v);
      end
    elseif(received.m == "dE") then
      tooltipLoading = nil;
      if(received.eM == "dne") then
        ShowTooltip({
          {1, "WeakAuras", 0.5333, 0, 1},
          {1, L["Requested display does not exist"], 1, 0, 0}
        });
      elseif(received.eM == "na") then
        ShowTooltip({
          {1, "WeakAuras", 0.5333, 0, 1},
          {1, L["Requested display not authorized"], 1, 0, 0}
        });
      end
    end
  elseif(ItemRefTooltip.WeakAuras_Tooltip_Thumbnail and ItemRefTooltip.WeakAuras_Tooltip_Thumbnail:IsVisible()) then
    ShowTooltip({
      {1, "WeakAuras", 0.5333, 0, 1},
      {1, L["Transmission error"], 1, 0, 0}
    });
  end
end

Comm:RegisterComm("WeakAurasProg", HandleProgressComm)
Comm:RegisterComm("WeakAuras", HandleComm)
Chomp.RegisterAddonPrefix("WeakAuras2", HandleComm)




-- ========================================
-- File: WeakAuras/Types.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local LSM = LibStub("LibSharedMedia-3.0");

local wipe, tinsert = wipe, tinsert
local GetNumShapeshiftForms, GetShapeshiftFormInfo = GetNumShapeshiftForms, GetShapeshiftFormInfo
local WrapTextInColorCode = WrapTextInColorCode
local MAX_NUM_TALENTS = MAX_NUM_TALENTS or 20

local function WA_GetClassColor(classFilename)
  local color = (CUSTOM_CLASS_COLORS or RAID_CLASS_COLORS)[classFilename]
  if color then
    return color.colorStr
  end

  return "ffffffff"
end

---@type table<string, string>
Private.glow_action_types = {
  show = L["Show"],
  hide = L["Hide"]
}

---@type table<string, string>
Private.glow_frame_types = {
  UNITFRAME = L["Unit Frame"],
  NAMEPLATE = L["Nameplate"],
  FRAMESELECTOR = L["Frame Selector"],
  PARENTFRAME = L["Parent Frame"]
}

---@type table<dynamicGroupCircularTypes, string>
Private.circular_group_constant_factor_types = {
  ANGLE = L["Angle and Radius"],
  RADIUS = L["Radius"],
  SPACING = L["Spacing"]
}

---@type table<number, string>
Private.frame_strata_types = {
  [1] = L["Inherited"],
  [2] = "BACKGROUND",
  [3] = "LOW",
  [4] = "MEDIUM",
  [5] = "HIGH",
  [6] = "DIALOG",
  [7] = "FULLSCREEN",
  [8] = "FULLSCREEN_DIALOG",
  [9] = "TOOLTIP"
}

---@type table<string, string>
Private.hostility_types = {
  hostile = L["Hostile"],
  friendly = L["Friendly"]
}

---@type table<string, string>
Private.character_types = {
  player = L["Player Character"],
  npc = L["Non-player Character"]
}

---@type table<string, string>
Private.spec_position_types = {
  RANGED = L["Ranged"],
  MELEE = L["Melee"]
}

---@type table<string, string>
Private.group_sort_types = {
  ascending = L["Ascending"],
  descending = L["Descending"],
  hybrid = L["Hybrid"],
  none = L["None"],
  custom = L["Custom"]
}

---@type table<string, string>
Private.group_hybrid_position_types = {
  hybridFirst = L["Marked First"],
  hybridLast = L["Marked Last"]
}

---@type table<string, string>
Private.group_hybrid_sort_types = {
  ascending = L["Ascending"],
  descending = L["Descending"]
}

---@type table<number, string>
Private.time_format_types = {
  [0] = L["WeakAuras Built-In (63:42 | 3:07 | 10 | 2.4)"],
  [1] = L["Old Blizzard (2h | 3m | 10s | 2.4)"],
  [2] = L["Modern Blizzard (1h 3m | 3m 7s | 10s | 2.4)"],
}

---@type table<number, string>
Private.time_precision_types = {
  [1] = "12.3",
  [2] = "12.34",
  [3] = "12.345",
}

---@type table<number, string>
Private.precision_types = {
  [0] = "12",
  [1] = "12.3",
  [2] = "12.34",
  [3] = "12.345",
}

---@type table<string, string>
Private.big_number_types = {
  ["AbbreviateNumbers"] = L["AbbreviateNumbers (Blizzard)"],
  ["AbbreviateLargeNumbers"] = L["AbbreviateLargeNumbers (Blizzard)"],
  ["BreakUpLargeNumbers"] = L["BreakUpLargeNumbers (Blizzard)"],
}
if WeakAuras.IsClassicEra() then
  Private.big_number_types.BreakUpLargeNumbers = nil
end
---@type table<string, string>
Private.big_number_types_with_disable = CopyTable(Private.big_number_types)
Private.big_number_types_with_disable["disable"] = L["Disabled"]

---@type table<string, string>
Private.round_types = {
  floor = L["Floor"],
  ceil = L["Ceil"],
  round = L["Round"]
}

---@type table<string, string>
Private.pad_types = {
  left = L["Left"],
  right = L["Right"]
}

---@type table<string, string>
Private.unit_color_types = {
  none = L["None"],
  class = L["Class"]
}

---@type table<string, string>
Private.unit_realm_name_types = {
  never = L["Never"],
  star = L["* Suffix"],
  differentServer = L["Only if on a different realm"],
  always = L["Always include realm"]
}

local timeFormatter = {}
Mixin(timeFormatter, SecondsFormatterMixin)
timeFormatter:Init(0, SecondsFormatter.Abbreviation.OneLetter)

-- The default time formatter adds a space between the value and the unit
-- While there is a API to strip it, that API does not work on all locales, e.g. german
-- Thus, copy the interval descriptions, strip the whitespace from them
-- and hack the timeFormatter to use our interval descriptions
local timeFormatIntervalDescriptionFixed = {}
timeFormatIntervalDescriptionFixed = CopyTable(SecondsFormatter.IntervalDescription)
for i, interval in ipairs(timeFormatIntervalDescriptionFixed) do
  interval.formatString = CopyTable(SecondsFormatter.IntervalDescription[i].formatString)
  for j, formatString in ipairs(interval.formatString) do
    interval.formatString[j] = formatString:gsub(" ", "")
  end
end

timeFormatter.GetIntervalDescription = function(self, interval)
  return timeFormatIntervalDescriptionFixed[interval]
end

timeFormatter.GetMaxInterval = function(self)
  return #timeFormatIntervalDescriptionFixed
end

local AbbreviateNumbers = AbbreviateNumbers
local gameLocale = GetLocale()
if gameLocale == "koKR" or gameLocale == "zhCN" or gameLocale == "zhTW" then
  -- Work around https://github.com/Stanzilla/WoWUIBugs/issues/515
  --
  local NUMBER_ABBREVIATION_DATA_FIXED={
    [1]={
      breakpoint = 10000 * 10000,
      significandDivisor = 10000 * 10000,
      abbreviation = SECOND_NUMBER_CAP_NO_SPACE,
      fractionDivisor = 1
    },
    [2]={
      breakpoint = 1000 * 10000,
      significandDivisor = 1000 * 10000,
      abbreviation = SECOND_NUMBER_CAP_NO_SPACE,
      fractionDivisor = 10
    },
    [3]={
      breakpoint = 10000,
      significandDivisor = 1000,
      abbreviation = FIRST_NUMBER_CAP_NO_SPACE,
      fractionDivisor = 10
    }
  }

  AbbreviateNumbers = function(value)
    for i, data in ipairs(NUMBER_ABBREVIATION_DATA_FIXED) do
      if value >= data.breakpoint then
              local finalValue = math.floor(value / data.significandDivisor) / data.fractionDivisor;
              return finalValue .. data.abbreviation;
      end
    end
    return tostring(value);
  end
end

local simpleFormatters = {
  AbbreviateNumbers = function(value)
    if type(value) == "string" then value = tonumber(value) end
    return (type(value) == "number") and AbbreviateNumbers(value) or value
  end,
  AbbreviateLargeNumbers = function(value)
    if type(value) == "string" then value = tonumber(value) end
    return (type(value) == "number") and AbbreviateLargeNumbers(Round(value)) or value
  end,
  BreakUpLargeNumbers = function(value)
    if type(value) == "string" then value = tonumber(value) end
    return (type(value) == "number") and BreakUpLargeNumbers(value) or value
  end,
  floor = function(value)
    if type(value) == "string" then value = tonumber(value) end
    return (type(value) == "number") and floor(value) or value
  end,
  ceil = function(value)
    if type(value) == "string" then value = tonumber(value) end
    return (type(value) == "number") and ceil(value) or value
  end,
  round = function(value)
    if type(value) == "string" then value = tonumber(value) end
    return (type(value) == "number") and Round(value) or value
  end,
  time = {
    [0] = function(value)
      if type(value) == "string" then value = tonumber(value) end
      if type(value) == "number" then
        if value > 60 then
          return string.format("%i:", math.floor(value / 60)) .. string.format("%02i", value % 60)
        else
          return string.format("%d", value)
        end
      end
    end,
    -- Old Blizzard
    [1] = function(value)
      local fmt, time = SecondsToTimeAbbrev(value)
      -- Remove the space between the value and unit
      return fmt:gsub(" ", ""):format(time)
    end,
    -- Modern Blizzard
    [2] = WeakAuras.IsRetail() and function(value)
      return timeFormatter:Format(value)
    end,
    -- Fixed built-in formatter
    [99] = function(value)
      if type(value) == "string" then value = tonumber(value) end
      if type(value) == "number" then
        value = ceil(value)
        if value > 60 then
          return string.format("%i:", math.floor(value / 60)) .. string.format("%02i", value % 60)
        else
          return string.format("%d", value)
        end
      end
    end,
  },
}

---@alias optionAdder fun(name: string, option: table)
---@alias optionGetter fun(name: string): any
---@alias formatter fun(input: any): string

---@class FormatType
---@field display string
---@field AddOptions fun(symbol: string, hidden: boolean, addOption: optionAdder, get: optionGetter)
---@field CreateFormatter fun(symbol: string, get: optionGetter, withoutColor: boolean, data: table): formatter?, boolean?

---@type table<string, FormatType>
Private.format_types = {
  none = {
    display = L["None"],
    AddOptions = function() end,
    CreateFormatter = function() return nil end
  },
  string = {
    display = L["String"],
    AddOptions = function(symbol, hidden, addOption, get)
      addOption(symbol .. "_abbreviate", {
        type = "toggle",
        name = L["Abbreviate"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_abbreviate_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Max Char "],
        width = WeakAuras.normalWidth,
        min = 1,
        softMax = 20,
        hidden = hidden,
        step = 1,
        disabled = function()
          return not get(symbol .. "_abbreviate")
        end
      })
      addOption(symbol .. "_pad", {
        type = "toggle",
        name = L["Pad"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_mode", {
        type = "select",
        name = L["Pad Mode"],
        width = WeakAuras.halfWidth,
        values = Private.pad_types,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Pad to"],
        width = WeakAuras.halfWidth,
        min = 1,
        max = 20,
        hidden = hidden,
        step = 1,
      })
    end,
    CreateFormatter = function(symbol, get)
      local abbreviate = get(symbol .. "_abbreviate", false)
      local abbreviateMax = get(symbol .. "_abbreviate_max", 8)
      local pad = get(symbol .. "_pad", false)
      local padMode = get(symbol .. "_pad_mode", "left")
      local padLength = get(symbol .. "_pad_max", 8)
      if abbreviate and pad then
        return function(input)
          return WeakAuras.PadString(WeakAuras.WA_Utf8Sub(input, abbreviateMax), padMode, padLength)
        end
      elseif pad then
        return function(input)
          return WeakAuras.PadString(input, padMode, padLength)
        end
      elseif abbreviate then
        return function(input)
          return WeakAuras.WA_Utf8Sub(input, abbreviateMax)
        end
      end
      return nil
    end
  },
  timed = {
    display = L["Time Format"],
    AddOptions = function(symbol, hidden, addOption, get)
      addOption(symbol .. "_time_format", {
        type = "select",
        name = L["Format"],
        width = WeakAuras.doubleWidth,
        values = Private.time_format_types,
        hidden = hidden
      })

      addOption(symbol .. "_time_dynamic_threshold", {
        type = "range",
        control = "WeakAurasSpinBox",
        min = 0,
        max = 60,
        step = 1,
        name = L["Increase Precision Below"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })

      addOption(symbol .. "_time_precision", {
        type = "select",
        name = L["Precision"],
        width = WeakAuras.normalWidth,
        values = Private.time_precision_types,
        hidden = hidden,
        disabled = function() return get(symbol .. "_time_dynamic_threshold") == 0 end
      })

      addOption(symbol .. "_time_mod_rate", {
        type = "toggle",
        name = L["Blizzard Cooldown Reduction"],
        desc = L["Cooldown Reduction changes the duration of seconds instead of showing the real time seconds."],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })

      addOption(symbol .. "_time_legacy_floor", {
        type = "toggle",
        name = L["Use Legacy floor rounding"],
        desc = L["Enables (incorrect) round down of seconds, which was the previous default behavior."],
        width = WeakAuras.normalWidth,
        hidden = hidden,
        disabled = function() return get(symbol .. "_time_format", 0) ~= 0 end
      })
    end,
    CreateFormatter = function(symbol, get, wihoutColor, data)
      local format = get(symbol .. "_time_format", 0)
      local threshold = get(symbol .. "_time_dynamic_threshold", 60)
      local precision = get(symbol .. "_time_precision", 1)
      local modRate = get(symbol .. "_time_mod_rate", true)
      local legacyRoundingMode = get(symbol .. "_time_legacy_floor", false)

      if format == 0 and not legacyRoundingMode then
        format = 99
      end
      if not simpleFormatters.time[format] then
        format = 99
      end
      local mainFormater = simpleFormatters.time[format]

      local modRateProperty = {}
      local timePointProperty = {}

      -- For the mod rate support, we need to know which state member is the modRate, as
      -- different progressSources can have different modRates
      -- Here, we only collect the names, so that the actual formatter can quickly lookup
      -- the property
      -- This is somewhat complicated by legacy behaviour (for %p, %t) and that %foo, can
      -- be the foo of different triggers that might use different modRate properties
      -- Similarly to distinguish between time formaters for durations and timepoints,
      -- we maintain a lookup table for time points
      -- Timepoint formatters need to run every frame, so we rturn true if we
      -- are formatting a timepoint
      local triggerNum, sym = string.match(symbol, "(.+)%.(.+)")
      triggerNum = triggerNum and tonumber(triggerNum)
      sym = sym or symbol

      if triggerNum then
        if sym == "p" or sym == "t" then
          if modRate then
            modRateProperty[triggerNum] = "modRate"
          end
        else
          local progressSource = Private.GetProgressSourceFor(data, triggerNum, sym)
          if progressSource then
            if modRate and progressSource[5] then
              modRateProperty[triggerNum] = progressSource[5]
            end
            if progressSource[2] == "timer" or progressSource[2] == "elapsedTimer" then
              timePointProperty[triggerNum] = true
            end
          end
        end
      else
        if symbol == "p" or symbol == "t" then
          for i = 1, #data.triggers do
            if modRate then
              modRateProperty[i] = "modRate"
            end
          end
        else
          for i = 1, #data.triggers do
            local progressSource = Private.GetProgressSourceFor(data, i, symbol)
            if progressSource then
              if modRate and progressSource[5] then
                modRateProperty[i] = progressSource[5]
              end
              if progressSource[2] == "timer" or progressSource[2] == "elapsedTimer" then
                timePointProperty[i] = true
              end
            end
          end
        end
      end

      local formatter
      if threshold == 0 then
        formatter = function(value, state, trigger)
          if type(value) ~= 'number' or value == math.huge then
            return ""
          end

          if timePointProperty[trigger] then
            value = abs(GetTime() - value)
          end

          if value <= 0 then
            return ""
          end

          if modRate and trigger and modRateProperty[trigger] then
            value = value / (state[modRateProperty[trigger]] or 1.0)
          end

          return mainFormater(value)
        end
      else
        local formatString = "%." .. precision .. "f"
        formatter = function(value, state, trigger)
          if type(value) ~= 'number' or value == math.huge then
            return ""
          end

          if timePointProperty[trigger] then
            value = abs(GetTime() - value)
          end

          if value <= 0 then
            return ""
          end
          if modRate and trigger and modRateProperty[trigger] then
            value = value / (state[modRateProperty[trigger]] or 1.0)
          end
          if value < threshold then
            return string.format(formatString, value)
          else
            return mainFormater(value)
          end
        end
      end

      if sym == "p" or sym == "t" then
        -- Special case %p and %t. Since due to how the formatting
        -- work previously, the time formatter only formats %p and %t
        -- if the progress type is timed!
        return function(value, state, trigger)
          if not state or state.progressType ~= "timed" then
            return value
          end
          return formatter(value, state, trigger)
        end, next(timePointProperty) ~= nil
      else
        return formatter, next(timePointProperty) ~= nil
      end
    end
  },
  Money = {
    display = L["Money"],
    AddOptions = function(symbol, hidden, addOption)
      addOption(symbol .. "_money_format", {
        type = "select",
        name = L["Format Gold"],
        width = WeakAuras.normalWidth,
        values = Private.big_number_types_with_disable,
        hidden = hidden
      })
      addOption(symbol .. "_money_precision", {
        type = "select",
        name = L["Coin Precision"],
        width = WeakAuras.normalWidth,
        values = Private.money_precision_types,
        hidden = hidden
      })
    end,
    CreateFormatter = function(symbol, get)
      local format = get(symbol .. "_money_format", "AbbreviateNumbers")
      local precision = get(symbol .. "_money_precision", 3)

      return function(value)
        if type(value) ~= "number" then
          return ""
        end
        local gold = floor(value / 1e4)
        local silver = floor(value / 100 % 100)
        local copper = value % 100

        if (format == "AbbreviateNumbers") then
          gold = simpleFormatters.AbbreviateNumbers(gold)
        elseif (format == "BreakUpLargeNumbers") then
          gold = simpleFormatters.BreakUpLargeNumbers(gold)
        elseif (format == "AbbreviateLargeNumbers") then
          gold = simpleFormatters.AbbreviateLargeNumbers(gold)
        end

        local formatCode
        if precision == 1 then
          formatCode = "%s%s"
        elseif precision == 2 then
          formatCode = "%s%s %d%s"
        else
          formatCode = "%s%s %d%s %d%s"
        end

        return string.format(formatCode,
          tostring(gold), Private.coin_icons.gold,
          silver, Private.coin_icons.silver,
          copper, Private.coin_icons.copper
        )
      end
    end
  },
  BigNumber = {
    display = L["Big Number"],
    AddOptions = function(symbol, hidden, addOption, get)
      addOption(symbol .. "_big_number_format", {
        type = "select",
        name = L["Format"],
        width = WeakAuras.normalWidth,
        values = Private.big_number_types,
        hidden = hidden
      })
      addOption(symbol .. "_big_number_space", {
        type = "description",
        name = "",
        width = WeakAuras.normalWidth,
        hidden = hidden
      })
      addOption(symbol .. "_pad", {
        type = "toggle",
        name = L["Pad"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_mode", {
        type = "select",
        name = L["Pad Mode"],
        width = WeakAuras.halfWidth,
        values = Private.pad_types,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Pad to"],
        width = WeakAuras.halfWidth,
        min = 1,
        max = 20,
        hidden = hidden,
        step = 1,
      })
    end,
    CreateFormatter = function(symbol, get)
      local format = get(symbol .. "_big_number_format", "AbbreviateNumbers")
      local pad = get(symbol .. "_pad", false)
      local padMode = get(symbol .. "_pad_mode", "left")
      local padLength = get(symbol .. "_pad_max", 8)
      local formatterFunc
      if (format == "AbbreviateNumbers") then
        formatterFunc = simpleFormatters.AbbreviateNumbers
      elseif (format == "BreakUpLargeNumbers") then
        formatterFunc = simpleFormatters.BreakUpLargeNumbers
      else
        formatterFunc = simpleFormatters.AbbreviateLargeNumbers
      end
      if pad then
        return function(input)
          return WeakAuras.PadString(formatterFunc(input), padMode, padLength)
        end
      end
      return formatterFunc
    end
  },
  Number = {
    display = L["Number"],
    AddOptions = function(symbol, hidden, addOption, get)
      addOption(symbol .. "_decimal_precision", {
        type = "select",
        name = L["Precision"],
        width = WeakAuras.normalWidth,
        values = Private.precision_types,
        hidden = hidden
      })
      addOption(symbol .. "_round_type", {
        type = "select",
        name = L["Round Mode"],
        width = WeakAuras.normalWidth,
        values = Private.round_types,
        hidden = hidden,
        disabled = function()
          return get(symbol .. "_decimal_precision") ~= 0
        end
      })
      addOption(symbol .. "_pad", {
        type = "toggle",
        name = L["Pad"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_mode", {
        type = "select",
        name = L["Pad Mode"],
        width = WeakAuras.halfWidth,
        values = Private.pad_types,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Pad to"],
        width = WeakAuras.halfWidth,
        min = 1,
        max = 20,
        hidden = hidden,
        step = 1,
      })
    end,
    CreateFormatter = function(symbol, get)
      local precision = get(symbol .. "_decimal_precision", 1)
      local pad = get(symbol .. "_pad", false)
      local padMode = get(symbol .. "_pad_mode", "left")
      local padLength = get(symbol .. "_pad_max", 8)
      local formatterFunc
      if precision == 0 then
        local type = get(symbol .. "_round_type", "floor")
        formatterFunc = simpleFormatters[type]
      else
        local format = "%." .. precision .. "f"
        formatterFunc = function(value)
          return (type(value) == "number") and string.format(format, value) or value
        end
      end
      if pad then
        return function(input)
          return WeakAuras.PadString(formatterFunc(input), padMode, padLength)
        end
      end
      return formatterFunc
    end
  },
  Unit = {
    display = L["Formats |cFFFFCC00%unit|r"],
    AddOptions = function(symbol, hidden, addOption, get, withoutColor)
      if not withoutColor then
        addOption(symbol .. "_color", {
          type = "select",
          name = L["Color"],
          width = WeakAuras.normalWidth,
          values = Private.unit_color_types,
          hidden = hidden,
        })
      end
      addOption(symbol .. "_realm_name", {
        type = "select",
        name = L["Realm Name"],
        width = WeakAuras.normalWidth,
        values = Private.unit_realm_name_types,
        hidden = hidden,
      })
      addOption(symbol .. "_abbreviate", {
        type = "toggle",
        name = L["Abbreviate"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_abbreviate_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Max Char"],
        width = WeakAuras.normalWidth,
        min = 1,
        max = 20,
        hidden = hidden,
        step = 1,
        disabled = function()
          return not get(symbol .. "_abbreviate")
        end
      })
      addOption(symbol .. "_pad", {
        type = "toggle",
        name = L["Pad"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_mode", {
        type = "select",
        name = L["Pad Mode"],
        width = WeakAuras.halfWidth,
        values = Private.pad_types,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Pad to"],
        width = WeakAuras.halfWidth,
        min = 1,
        max = 20,
        hidden = hidden,
        step = 1,
      })
    end,
    CreateFormatter = function(symbol, get, withoutColor)
      local color = not withoutColor and get(symbol .. "_color", true)
      local realm = get(symbol .. "_realm_name", "never")
      local abbreviate = get(symbol .. "_abbreviate", false)
      local abbreviateMax = get(symbol .. "_abbreviate_max", 8)
      local pad = get(symbol .. "_pad", false)
      local padMode = get(symbol .. "_pad_mode", "left")
      local padLength = get(symbol .. "_pad_max", 8)

      local nameFunc
      local colorFunc
      local abbreviateFunc
      if color == "class" then
        colorFunc = function(unit, text)
          if unit and Private.UnitPlayerControlledFixed(unit) then
            local classFilename = select(2, UnitClass(unit))
            if classFilename then
              return WrapTextInColorCode(text, WA_GetClassColor(classFilename))
            end
          end
          return text
        end
      end

      if realm == "never" then
        nameFunc = function(unit)
          return unit and WeakAuras.UnitName(unit) or ""
        end
      elseif realm == "star" then
        nameFunc = function(unit)
          if not unit then
            return ""
          end
          local name, realm = WeakAuras.UnitName(unit)
          if realm then
            return name .. "*"
          end
          return name or ""
        end
      elseif realm == "differentServer" then
        nameFunc = function(unit)
          if not unit then
            return ""
          end
          local name, realm = WeakAuras.UnitName(unit)
          if realm then
            return name .. "-" .. realm
          end
          return name or ""
        end
      elseif realm == "always" then
        nameFunc = function(unit)
          if not unit then
            return ""
          end
          local name, realm = WeakAuras.UnitNameWithRealmCustomName(unit)
          return name .. "-" .. realm
        end
      end

      if pad and abbreviate then
        abbreviateFunc = function(input)
          return WeakAuras.PadString(WeakAuras.WA_Utf8Sub(input, abbreviateMax), padMode, padLength)
        end
      elseif pad then
        abbreviateFunc = function(input)
          return WeakAuras.PadString(input, padMode, padLength)
        end
      elseif abbreviate then
        abbreviateFunc = function(input)
          return WeakAuras.WA_Utf8Sub(input, abbreviateMax)
        end
      end

      -- Do the checks on what is necessary here instead of inside the returned
      -- formatter
      if colorFunc then
        if abbreviateFunc then
          return function(unit)
            local name = abbreviateFunc(nameFunc(unit))
            return colorFunc(unit, name)
          end
        else
          return function(unit)
            local name = nameFunc(unit)
            return colorFunc(unit, name)
          end
        end
      else
        if abbreviateFunc then
          return function(unit)
            local name = nameFunc(unit)
            return abbreviateFunc(name)
          end
        else
          return nameFunc
        end
      end
    end
  },
  guid = {
    display = L["Formats Player's |cFFFFCC00%guid|r"],
    AddOptions = function(symbol, hidden, addOption, get, withoutColor)
      if not withoutColor then
        addOption(symbol .. "_color", {
          type = "select",
          name = L["Color"],
          width = WeakAuras.normalWidth,
          values = Private.unit_color_types,
          hidden = hidden,
        })
      end
      addOption(symbol .. "_realm_name", {
        type = "select",
        name = L["Realm Name"],
        width = WeakAuras.normalWidth,
        values = Private.unit_realm_name_types,
        hidden = hidden,
      })
      addOption(symbol .. "_abbreviate", {
        type = "toggle",
        name = L["Abbreviate"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_abbreviate_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Max Char "],
        width = WeakAuras.normalWidth,
        min = 1,
        max = 20,
        hidden = hidden,
        disabled = function()
          return not get(symbol .. "_abbreviate")
        end
      })
      addOption(symbol .. "_pad", {
        type = "toggle",
        name = L["Pad"],
        width = WeakAuras.normalWidth,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_mode", {
        type = "select",
        name = L["Pad Mode"],
        width = WeakAuras.halfWidth,
        values = Private.pad_types,
        hidden = hidden,
      })
      addOption(symbol .. "_pad_max", {
        type = "range",
        control = "WeakAurasSpinBox",
        name = L["Pad to"],
        width = WeakAuras.halfWidth,
        min = 1,
        max = 20,
        hidden = hidden,
        step = 1,
      })
    end,
    CreateFormatter = function(symbol, get, withoutColor)
      local color = not withoutColor and get(symbol .. "_color", true)
      local realm = get(symbol .. "_realm_name", "never")
      local abbreviate = get(symbol .. "_abbreviate", false)
      local abbreviateMax = get(symbol .. "_abbreviate_max", 8)
      local pad = get(symbol .. "_pad", false)
      local padMode = get(symbol .. "_pad_mode", "left")
      local padLength = get(symbol .. "_pad_max", 8)

      local nameFunc
      local colorFunc
      local abbreviateFunc
      if color == "class" then
        colorFunc = function(class, text)
          if class then
            return WrapTextInColorCode(text, WA_GetClassColor(class))
          else
            return text
          end
        end
      end

      if realm == "never" then
        nameFunc = function(name, realm)
          return WeakAuras.GetName(name)
        end
      elseif realm == "star" then
        nameFunc = function(name, realm)
          name = WeakAuras.GetName(name)
          if realm ~= "" then
            return name .. "*"
          end
          return name
        end
      elseif realm == "differentServer" then
        nameFunc = function(name, realm)
          name = WeakAuras.GetName(name)
          if realm ~= "" then
            return name .. "-" .. realm
          end
          return name
        end
      elseif realm == "always" then
        nameFunc = function(name, realm)
          name = WeakAuras.GetName(name)
          if realm == "" then
            realm = select(2, WeakAuras.UnitNameWithRealm("player"))
          end
          return name .. "-" .. realm
        end
      end

      if pad and abbreviate then
        abbreviateFunc = function(input)
          return WeakAuras.PadString(WeakAuras.WA_Utf8Sub(input, abbreviateMax), padMode, padLength)
        end
      elseif pad then
        abbreviateFunc = function(input)
          return WeakAuras.PadString(input, padMode, padLength)
        end
      elseif abbreviate then
        abbreviateFunc = function(input)
          return WeakAuras.WA_Utf8Sub(input, abbreviateMax)
        end
      end

      -- Do the checks on what is necessary here instead of inside the returned
      -- formatter
      if colorFunc then
        if abbreviateFunc then
          return function(guid)
            local ok, _, class, _, _, _, name, realm = pcall(GetPlayerInfoByGUID, guid)
            if ok and name then
              local name = abbreviateFunc(nameFunc(name, realm))
              return colorFunc(class, name)
            end
          end
        else
          return function(guid)
            local ok, _, class, _, _, _, name, realm = pcall(GetPlayerInfoByGUID, guid)
            if ok and name then
              return colorFunc(class, nameFunc(name, realm))
            end
          end
        end
      else
        if abbreviateFunc then
          return function(guid)
            local ok, _, class, _, _, _, name, realm = pcall(GetPlayerInfoByGUID, guid)
            if ok and name then
              return abbreviateFunc(nameFunc(name, realm))
            end
          end
        else
          return function(guid)
            local ok, _, class, _, _, _, name, realm = pcall(GetPlayerInfoByGUID, guid)
            if ok and name then
              return nameFunc(name, realm)
            end
          end
        end
      end
    end
  },
  GCDTime = {
    display = L["Time in GCDs"],
    AddOptions = function(symbol, hidden, addOption, get)
      addOption(symbol .. "_gcd_gcd", {
        type = "toggle",
        name = L["Subtract GCD"],
        width = WeakAuras.normalWidth,
        hidden = hidden
      })
      addOption(symbol .. "_gcd_cast", {
        type = "toggle",
        name = L["Subtract Cast"],
        width = WeakAuras.normalWidth,
        hidden = hidden
      })
      addOption(symbol .. "_gcd_channel", {
        type = "toggle",
        name = L["Subtract Channel"],
        width = WeakAuras.normalWidth,
        hidden = hidden
      })
      addOption(symbol .. "_gcd_hide_zero", {
        type = "toggle",
        name = L["Hide 0 cooldowns"],
        width = WeakAuras.normalWidth,
        hidden = hidden
      })

      addOption(symbol .. "_decimal_precision", {
        type = "select",
        name = L["Precision"],
        width = WeakAuras.normalWidth,
        values = Private.precision_types,
        hidden = hidden
      })
      addOption(symbol .. "_round_type", {
        type = "select",
        name = L["Round Mode"],
        width = WeakAuras.normalWidth,
        values = Private.round_types,
        hidden = hidden,
        disabled = function()
          return get(symbol .. "_decimal_precision") ~= 0
        end
      })
    end,
    CreateFormatter = function(symbol, get)
      local gcd = get(symbol .. "_gcd_gcd", true)
      local cast = get(symbol .. "_gcd_cast", false)
      local channel = get(symbol .. "_gcd_channel", false)
      local hideZero = get(symbol .. "_gcd_hide_zero", false)
      local precision = get(symbol .. "_decimal_precision", 1)

      local numberToStringFunc
      if precision ~= 0 then
        local format = "%." .. precision .. "f"
        numberToStringFunc = function(number)
          return string.format(format, number)
        end
      else
        local type = get(symbol .. "_round_type", "ceil")
        numberToStringFunc = simpleFormatters[type]
      end

      return function(value, state)
        if state.progressType ~= "timed" or type(value) ~= "number" then
          return value
        end

        WeakAuras.WatchGCD()
        local result = value
        local now = GetTime()
        if gcd then
          local gcdDuration, gcdExpirationTime = WeakAuras.GetGCDInfo()
          if gcdDuration ~= 0 then
            result = now + value - gcdExpirationTime
          end
        end

        if cast then
          local _, _, _, _, endTime = WeakAuras.UnitCastingInfo("player")
          local castExpirationTime = endTime and endTime > 0 and (endTime / 1000) or 0
          if castExpirationTime > 0 then
            result = min(result, now + value - castExpirationTime)
          end
        end
        if channel then
          local _, _, _, _, endTime = WeakAuras.UnitChannelInfo("player")
          local castExpirationTime = endTime and endTime > 0 and (endTime / 1000) or 0
          if castExpirationTime > 0 then
            result = min(result, now + value - castExpirationTime)
          end
        end

        if result <= 0 then
          return hideZero and "" or "0"
        end

        return numberToStringFunc(result / WeakAuras.CalculatedGcdDuration())
      end
    end
  }
}

---@type table<string, string>
Private.format_types_display = {}
for k, v in pairs(Private.format_types) do Private.format_types_display[k] = v.display end

---@type table<string, string>
Private.sound_channel_types = {
  Master = L["Master"],
  SFX = ENABLE_SOUNDFX,
  Ambience = ENABLE_AMBIENCE,
  Music = ENABLE_MUSIC,
  Dialog = ENABLE_DIALOG
}

---@type table<string, string>
Private.sound_condition_types = {
  Play = L["Play"],
  Loop = L["Loop"],
  Stop = L["Stop"]
}

---@type table<string, string>
Private.trigger_require_types = {
  any = L["Any Triggers"],
  all = L["All Triggers"],
  custom = L["Custom Function"]
}

---@type table<string, string>
Private.trigger_require_types_one = {
  any = L["Trigger 1"],
  custom = L["Custom Function"]
}

---@type table<string, number>
Private.trigger_modes = {
  ["first_active"] = -10,
}

---@type table<string, string>
Private.debuff_types = {
  HELPFUL = L["Buff"],
  HARMFUL = L["Debuff"],
  BOTH = L["Buff/Debuff"]
}

---@type table<number, string>
Private.tooltip_count = {
  [1] = L["First"],
  [2] = L["Second"],
  [3] = L["Third"]
}

---@type table<string, string>
Private.aura_types = {
  BUFF = L["Buff"],
  DEBUFF = L["Debuff"],
}

---@type table<string, string>
Private.debuff_class_types = {
  magic = L["Magic"],
  curse = L["Curse"],
  disease = L["Disease"],
  poison = L["Poison"],
  enrage = L["Enrage"],
  none = L["None"]
}

if WeakAuras.IsRetail() then
  Private.debuff_class_types.bleed = L["Bleed"]
end

---@type table<string, string>
Private.player_target_events = {
  PLAYER_TARGET_CHANGED = "target",
  PLAYER_FOCUS_CHANGED = "focus",
  PLAYER_SOFT_ENEMY_CHANGED = "softenemy",
  PLAYER_SOFT_FRIEND_CHANGED = "softfriend",
}

---@type table<string, string>
Private.soft_target_cvars = {
  softenemy = "SoftTargetEnemy",
  softfriend = "SoftTargetFriend"
}

---@type table<string, string>
local target_unit_types = {
  target = L["Target"],
  softenemy = L["Soft Enemy"],
  softfriend = L["Soft Friend"]
}

if not WeakAuras.IsClassicEra() then
  target_unit_types.focus = L["Focus"]
end

---@type table<string, string>
Private.unit_types = Mixin({
  player = L["Player"],
  group = L["Group"],
  member = L["Specific Unit"],
  pet = L["Pet"],
  multi = L["Multi-target"]
}, target_unit_types)

---@type table<string, string>
Private.unit_types_bufftrigger_2 = Mixin({
  player = L["Player"],
  group = L["Smart Group"],
  raid = L["Raid"],
  party = L["Party"],
  boss = L["Boss"],
  arena = L["Arena"],
  nameplate = L["Nameplate"],
  pet = L["Pet"],
  member = L["Specific Unit"],
  multi = L["Multi-target"]
}, target_unit_types)

---@type table<string, string>
Private.actual_unit_types = Mixin({
  player = L["Player"],
  pet = L["Pet"],
}, target_unit_types)

---@type table<string, string>
Private.actual_unit_types_with_specific = Mixin({
  player = L["Player"],
  pet = L["Pet"],
  member = L["Specific Unit"]
}, target_unit_types)

---@type table<string, string>
Private.actual_unit_types_cast = Mixin({
  player = L["Player"],
  group = L["Smart Group"],
  party = L["Party"],
  raid = L["Raid"],
  boss = L["Boss"],
  arena = L["Arena"],
  nameplate = L["Nameplate"],
  pet = L["Pet"],
  member = L["Specific Unit"],
}, target_unit_types)

---@type string
Private.actual_unit_types_cast_tooltip = L[" |cff00ff00Player|r, |cff00ff00Target|r, |cff00ff00Focus|r, and |cff00ff00Pet|r correspond directly to those individual unitIDs.\n |cff00ff00Specific Unit|r lets you provide a specific valid unitID to watch.\n|cffff0000Note|r: The game will not fire events for all valid unitIDs, making some untrackable by this trigger.\n |cffffff00Party|r, |cffffff00Raid|r, |cffffff00Boss|r, |cffffff00Arena|r, and |cffffff00Nameplate|r can match multiple corresponding unitIDs.\n |cffffff00Smart Group|r adjusts to your current group type, matching just the \"player\" when solo, \"party\" units (including \"player\") in a party or \"raid\" units in a raid.\n\n|cffffff00*|r Yellow Unit settings will create clones for each matching unit while this trigger is providing Dynamic Info to the Aura."]

---@type table<string, string>
Private.threat_unit_types = Mixin({
  nameplate = L["Nameplate"],
  boss = L["Boss"],
  member = L["Specific Unit"],
  none = L["At Least One Enemy"]
}, target_unit_types)

---@type table<string, string>
Private.unit_types_range_check = Mixin({
  pet = L["Pet"],
  member = L["Specific Unit"]
}, target_unit_types)

---@type table<number, string>
Private.unit_threat_situation_types = {
  [-1] = L["Not On Threat Table"],
  [0] = "|cFFB0B0B0"..L["Lower Than Tank"].."|r",
  [1] = "|cFFFFFF77"..L["Higher Than Tank"].."|r",
  [2] = "|cFFFF9900"..L["Tanking But Not Highest"].."|r",
  [3] = "|cFFFF0000"..L["Tanking And Highest"].."|r"
}

WeakAuras.class_types = {}
for classID = 1, 20 do -- 20 is for GetNumClasses() but that function doesn't exists on Classic
  local classInfo = C_CreatureInfo.GetClassInfo(classID)
  if classInfo and classID ~=14 then -- 14 == Adventurer
    WeakAuras.class_types[classInfo.classFile] = WrapTextInColorCode(classInfo.className, WA_GetClassColor(classInfo.classFile))
  end
end


WeakAuras.race_types = {}
do
  local races = {
    [1] = true,
    [2] = true,
    [3] = true,
    [4] = true,
    [5] = true,
    [6] = true,
    [7] = true,
    [8] = true,
    [9] = not WeakAuras.IsClassicEra() and true or nil, -- Goblin
    [10] = true,
    [11] = true,
    [22] = true,
    [24] = true,
    [25] = true,
    [26] = true,
    [27] = true,
    [28] = true,
    [29] = true,
    [30] = true,
    [31] = true,
    [32] = true,
    [34] = true,
    [35] = true,
    [36] = true,
    [37] = true,
    [52] = true, -- Dracthyr
    [70] = true, -- Dracthyr
    [84] = true, -- Earthen
    [85] = true, -- Earthen
  }

  for raceId, enabled in pairs(races) do
    local raceInfo = C_CreatureInfo.GetRaceInfo(raceId)
    if raceInfo then
      WeakAuras.race_types[raceInfo.clientFileString] = raceInfo.raceName
    end
  end
end

---@type table<number, string>
if WeakAuras.IsRetail() then
  Private.covenant_types = {}
  Private.covenant_types[0] = L["None"]
  for i = 1, 4 do
    Private.covenant_types[i] = C_Covenants.GetCovenantData(i).name
  end
end

---@type table<string, string>
Private.faction_group = {
  Alliance = L["Alliance"],
  Horde = L["Horde"],
  Neutral = L["Neutral"]
}

---@type table<number, string>
Private.form_types = {};
local function update_forms()
  local oldForms = Private.form_types
  Private.form_types = {}
  Private.form_types[0] = "0 - " .. L["Humanoid"]
  for i = 1, GetNumShapeshiftForms() do
    local _, _, _, id = GetShapeshiftFormInfo(i);
    if(id) then
      local name = Private.ExecEnv.GetSpellName(id);
      if(name) then
        Private.form_types[i] = i.." - "..name
      end
    end
  end
  if Private.OptionsFrame and not tCompare(oldForms, Private.form_types) then
    Private.OptionsFrame():ReloadOptions()
  end
end

local form_frame = CreateFrame("Frame");
form_frame:RegisterEvent("UPDATE_SHAPESHIFT_FORMS")
form_frame:RegisterEvent("PLAYER_LOGIN")
form_frame:SetScript("OnEvent", update_forms);

---@type table<string, string>
Private.blend_types = {
  ADD = L["Glow"],
  BLEND = L["Opaque"]
}

---@type table<string, string>
Private.texture_wrap_types = {
  CLAMP = L["Clamp"],
  MIRROR = L["Mirror"],
  REPEAT = L["Repeat"],
  CLAMPTOBLACKADDITIVE = L["No Extend"]
}

---@type table<string, string>
Private.slant_mode = {
  INSIDE = L["Keep Inside"],
  EXTEND = L["Extend Outside"]
}

---@type table<string, string>
Private.text_check_types = {
  update = L["Every Frame"],
  event = L["Trigger Update"]
}

---@type table<string, string>
Private.check_types = {
  update = L["Every Frame (High CPU usage)"],
  event = L["Event(s)"]
}

---@type table<string, string>
Private.point_types = {
  BOTTOMLEFT = L["Bottom Left"],
  BOTTOM = L["Bottom"],
  BOTTOMRIGHT = L["Bottom Right"],
  RIGHT = L["Right"],
  TOPRIGHT = L["Top Right"],
  TOP = L["Top"],
  TOPLEFT = L["Top Left"],
  LEFT = L["Left"],
  CENTER = L["Center"]
}

---@type table<string, table>
Private.default_types_for_anchor = {}
for k, v in pairs(Private.point_types) do
  Private.default_types_for_anchor[k] = {
    display = v,
    type = "point"
  }
end

Private.default_types_for_anchor["ALL"] = {
  display = L["Full Region"],
  type = "area"
}

Private.anchor_mode = {
  area = L["Fill Area"],
  point = L["Attach to Point"]
}

Private.inverse_point_types = {
  BOTTOMLEFT = "TOPRIGHT",
  BOTTOM = "TOP",
  BOTTOMRIGHT = "TOPLEFT",
  RIGHT = "LEFT",
  TOPRIGHT = "BOTTOMLEFT",
  TOP = "BOTTOM",
  TOPLEFT = "BOTTOMRIGHT",
  LEFT = "RIGHT",
  CENTER = "CENTER"
}

Private.anchor_frame_types = {
  SCREEN = L["Screen/Parent Group"],
  UIPARENT = L["Screen"],
  PRD = L["Personal Resource Display"],
  MOUSE = L["Mouse Cursor"],
  SELECTFRAME = L["Select Frame"],
  NAMEPLATE = L["Nameplates"],
  UNITFRAME = L["Unit Frames"],
  CUSTOM = L["Custom"]
}

Private.anchor_frame_types_group = {
  SCREEN = L["Screen/Parent Group"],
  UIPARENT = L["Screen"],
  PRD = L["Personal Resource Display"],
  MOUSE = L["Mouse Cursor"],
  SELECTFRAME = L["Select Frame"],
  CUSTOM = L["Custom"]
}

Private.spark_rotation_types = {
  AUTO = L["Automatic Rotation"],
  MANUAL = L["Manual Rotation"]
}

---@type table<string, string>
Private.spark_hide_types = {
  NEVER = L["Never"],
  FULL  = L["Full"],
  EMPTY = L["Empty"],
  BOTH  = L["Full/Empty"]
}

Private.tick_placement_modes = {
  AtValue = L["At Value"],
  AtMissingValue = L["At missing Value"],
  AtPercent = L["At Percent"],
  ValueOffset = L["Offset from progress"]
}

---@type table<string, string>
Private.font_flags = {
  None = L["None"],
  MONOCHROME = L["Monochrome"],
  OUTLINE = L["Outline"],
  THICKOUTLINE  = L["Thick Outline"],
  ["MONOCHROME|OUTLINE"] = L["Monochrome Outline"],
  ["MONOCHROME|THICKOUTLINE"] = L["Monochrome Thick Outline"]
}

---@type table<string, string>
Private.text_automatic_width = {
  Auto = L["Automatic"],
  Fixed = L["Fixed"]
}

---@type table<string, string>
Private.text_word_wrap = {
  WordWrap = L["Wrap"],
  Elide = L["Elide"]
}

---@type table<string, string>
Private.include_pets_types = {
  PlayersAndPets = L["Players and Pets"],
  PetsOnly = L["Pets only"]
}

---@type table<string, string>
Private.subevent_prefix_types = {
  SWING = L["Swing"],
  RANGE = L["Range"],
  SPELL = L["Spell"],
  SPELL_PERIODIC = L["Periodic Spell"],
  SPELL_BUILDING = L["Spell (Building)"],
  ENVIRONMENTAL = L["Environmental"],
  DAMAGE_SHIELD = L["Damage Shield"],
  DAMAGE_SPLIT = L["Damage Split"],
  DAMAGE_SHIELD_MISSED = L["Damage Shield Missed"],
  PARTY_KILL = L["Party Kill"],
  UNIT_DIED = L["Unit Died"],
  UNIT_DESTROYED = L["Unit Destroyed"],
  UNIT_DISSIPATES = L["Unit Dissipates"],
  ENCHANT_APPLIED = L["Enchant Applied"],
  ENCHANT_REMOVED = L["Enchant Removed"]
}

---@type table<string, string>
Private.subevent_actual_prefix_types = {
  SWING = L["Swing"],
  RANGE = L["Range"],
  SPELL = L["Spell"],
  SPELL_PERIODIC = L["Periodic Spell"],
  SPELL_BUILDING = L["Spell (Building)"],
  ENVIRONMENTAL = L["Environmental"]
}

---@type table<string, string>
Private.subevent_suffix_types = {
  _ABSORBED = L["Absorbed"],
  _DAMAGE = L["Damage"],
  _MISSED = L["Missed"],
  _HEAL = L["Heal"],
  _HEAL_ABSORBED = L["Heal Absorbed"],
  _ENERGIZE = L["Energize"],
  _DRAIN = L["Drain"],
  _LEECH = L["Leech"],
  _INTERRUPT = L["Interrupt"],
  _DISPEL = L["Dispel"],
  _DISPEL_FAILED = L["Dispel Failed"],
  _STOLEN = L["Stolen"],
  _EXTRA_ATTACKS = L["Extra Attacks"],
  _AURA_APPLIED = L["Aura Applied"],
  _AURA_REMOVED = L["Aura Removed"],
  _AURA_APPLIED_DOSE = L["Aura Applied Dose"],
  _AURA_REMOVED_DOSE = L["Aura Removed Dose"],
  _AURA_REFRESH = L["Aura Refresh"],
  _AURA_BROKEN = L["Aura Broken"],
  _AURA_BROKEN_SPELL = L["Aura Broken Spell"],
  _CAST_START = L["Cast Start"],
  _CAST_SUCCESS = L["Cast Success"],
  _CAST_FAILED = L["Cast Failed"],
  _EMPOWER_START = L["Empower Cast Start"],
  _EMPOWER_END = L["Empower Cast End"],
  _EMPOWER_INTERRUPT = L["Empower Cast Interrupt"],
  _INSTAKILL = L["Instakill"],
  _DURABILITY_DAMAGE = L["Durability Damage"],
  _DURABILITY_DAMAGE_ALL = L["Durability Damage All"],
  _CREATE = L["Create"],
  _SUMMON = L["Summon"],
  _RESURRECT = L["Resurrect"]
}

---@type table<number, string>
Private.power_types = {
  [0] = POWER_TYPE_MANA,
  [1] = POWER_TYPE_RED_POWER,
  [2] = POWER_TYPE_FOCUS,
  [3] = POWER_TYPE_ENERGY,
  [4] = COMBO_POINTS,
  [6] = RUNIC_POWER,
  [7] = SOUL_SHARDS_POWER,
  [8] = POWER_TYPE_LUNAR_POWER,
  [9] = HOLY_POWER,
  [11] = POWER_TYPE_MAELSTROM,
  [12] = CHI_POWER,
  [13] = POWER_TYPE_INSANITY,
  [16] = POWER_TYPE_ARCANE_CHARGES,
  [17] = POWER_TYPE_FURY_DEMONHUNTER,
  [18] = POWER_TYPE_PAIN
}
if WeakAuras.IsRetail() then
  Private.power_types[99] = STAGGER
  Private.power_types[19] = POWER_TYPE_ESSENCE
elseif WeakAuras.IsCataClassic() then
  Private.power_types[8] = nil
  Private.power_types[12] = nil
  Private.power_types[13] = nil
  Private.power_types[16] = nil
  Private.power_types[17] = nil
  Private.power_types[18] = nil
elseif WeakAuras.IsMists() then
  Private.power_types[8] = nil
  Private.power_types[14] = BURNING_EMBERS
  Private.power_types[13] = nil
  Private.power_types[15] = POWER_TYPE_DEMONIC_FURY
  Private.power_types[16] = nil
  Private.power_types[17] = nil
  Private.power_types[18] = nil
  Private.power_types[28] = SHADOW_ORBS
  Private.power_types[99] = L["Stagger"]
end

if WeakAuras.IsCataOrMists() then
  Private.power_types[26] = ECLIPSE

  ---@type table<string, string>
    Private.eclipse_direction_types = {
      none = L["None"],
      sun = L["Sun"],
      moon = L["Moon"]
    }
end

---@type table<string, string>
Private.miss_types = {
  ABSORB = L["Absorb"],
  BLOCK = L["Block"],
  DEFLECT = L["Deflect"],
  DODGE = L["Dodge"],
  EVADE = L["Evade"],
  IMMUNE = L["Immune"],
  MISS = L["Miss"],
  PARRY = L["Parry"],
  REFLECT = L["Reflect"],
  RESIST = L["Resist"]
}

---@type table<string, string>
Private.environmental_types = {
  Drowning = STRING_ENVIRONMENTAL_DAMAGE_DROWNING,
  Falling = STRING_ENVIRONMENTAL_DAMAGE_FALLING,
  Fatigue = STRING_ENVIRONMENTAL_DAMAGE_FATIGUE,
  Fire = STRING_ENVIRONMENTAL_DAMAGE_FIRE,
  Lava = STRING_ENVIRONMENTAL_DAMAGE_LAVA,
  Slime = STRING_ENVIRONMENTAL_DAMAGE_SLIME
}

---@type table<string, string>
Private.combatlog_flags_check_type = {
  Mine = L["Mine"],
  InGroup = L["In Group"],
  InParty = L["In Party"],
  NotInGroup = L["Not in Smart Group"]
}

---@type table<string, string>
Private.combatlog_flags_check_reaction = {
  Hostile = L["Hostile"],
  Neutral = L["Neutral"],
  Friendly = L["Friendly"]
}

---@type table<string, string>
Private.combatlog_flags_check_object_type = {
  Object = L["Object"],
  Guardian = L["Guardian"],
  Pet = L["Pet"],
  NPC = L["NPC"],
  Player = L["Player"]
}

---@type table<number, string>
Private.combatlog_spell_school_types = {
  [1] = STRING_SCHOOL_PHYSICAL,
  [2] = STRING_SCHOOL_HOLY,
  [4] = STRING_SCHOOL_FIRE,
  [8] = STRING_SCHOOL_NATURE,
  [16] = STRING_SCHOOL_FROST,
  [32] = STRING_SCHOOL_SHADOW,
  [64] = STRING_SCHOOL_ARCANE,
  [3] = STRING_SCHOOL_HOLYSTRIKE,
  [5] = STRING_SCHOOL_FLAMESTRIKE,
  [6] = STRING_SCHOOL_HOLYFIRE,
  [9] = STRING_SCHOOL_STORMSTRIKE,
  [10] = STRING_SCHOOL_HOLYSTORM,
  [12] = STRING_SCHOOL_FIRESTORM,
  [17] = STRING_SCHOOL_FROSTSTRIKE,
  [18] = STRING_SCHOOL_HOLYFROST,
  [20] = STRING_SCHOOL_FROSTFIRE,
  [24] = STRING_SCHOOL_FROSTSTORM,
  [33] = STRING_SCHOOL_SHADOWSTRIKE,
  [34] = STRING_SCHOOL_SHADOWLIGHT,
  [36] = STRING_SCHOOL_SHADOWFLAME,
  [40] = STRING_SCHOOL_SHADOWSTORM,
  [48] = STRING_SCHOOL_SHADOWFROST,
  [65] = STRING_SCHOOL_SPELLSTRIKE,
  [66] = STRING_SCHOOL_DIVINE,
  [68] = STRING_SCHOOL_SPELLFIRE,
  [72] = STRING_SCHOOL_SPELLSTORM,
  [80] = STRING_SCHOOL_SPELLFROST,
  [96] = STRING_SCHOOL_SPELLSHADOW,
  [28] = STRING_SCHOOL_ELEMENTAL,
  [62] = STRING_SCHOOL_CHROMATIC,
  [106] = STRING_SCHOOL_COSMIC,
  [124] = STRING_SCHOOL_CHAOS,
  [126] = STRING_SCHOOL_MAGIC,
  [127] = STRING_SCHOOL_CHAOS,
}

---@type table<number, string>
Private.combatlog_spell_school_types_for_ui = {}
for id, str in pairs(Private.combatlog_spell_school_types) do
  Private.combatlog_spell_school_types_for_ui[id] = ("%.3d - %s"):format(id, str)
end

---@type table<string, string>
Private.coin_icons = {
  ["gold"] = "|Tinterface/moneyframe/ui-goldicon:0|t",
  ["silver"] = "|Tinterface/moneyframe/ui-silvericon:0|t",
  ["copper"] = "|Tinterface/moneyframe/ui-coppericon:0|t"
}

---@type table<number, string>
Private.money_precision_types = {
  [1] = "123 " .. Private.coin_icons.gold,
  [2] = "123 " .. Private.coin_icons.gold .. " 45 " .. Private.coin_icons.silver,
  [3] = "123 " .. Private.coin_icons.gold .. " 45 " .. Private.coin_icons.silver .. " 67 " .. Private.coin_icons.copper
}

if WeakAuras.IsRetail() then
  Private.GetCurrencyListSize = C_CurrencyInfo.GetCurrencyListSize
  Private.GetCurrencyIDFromLink = C_CurrencyInfo.GetCurrencyIDFromLink
  Private.ExpandCurrencyList = C_CurrencyInfo.ExpandCurrencyList
  Private.GetCurrencyListInfo = C_CurrencyInfo.GetCurrencyListInfo
elseif WeakAuras.IsCataOrMists() then
  Private.GetCurrencyListSize = GetCurrencyListSize
  ---@type fun(currencyLink: string): number?
  Private.GetCurrencyIDFromLink = function(currencyLink)
    local currencyID = string.match(currencyLink, "|Hcurrency:(%d+):")
    return tonumber(currencyID)
  end
  ---@type fun(index: number, expand: boolean)
  Private.ExpandCurrencyList = function(index, expand)
    ExpandCurrencyList(index, expand and 1 or 0)
  end
  ---@type fun(index: number): CurrencyInfo
  Private.GetCurrencyListInfo = function(index)
    local name, isHeader, isExpanded, isUnused, isWatched, _, icon, _, hasWeeklyLimit, _, _, itemID = GetCurrencyListInfo(index)
    local currentAmount, earnedThisWeek, weeklyMax, totalMax, isDiscovered, rarity
    if itemID then
      _, currentAmount, _, earnedThisWeek, weeklyMax, totalMax, isDiscovered, rarity = GetCurrencyInfo(itemID)
    end
    local currencyInfo = {
      name = name,
      description = "",
      isHeader = isHeader,
      isHeaderExpanded = isExpanded,
      isTypeUnused = isUnused,
      isShowInBackpack = isWatched,
      quantity = currentAmount,
      trackedQuantity = 0,
      iconFileID = icon,
      maxQuantity = totalMax,
      canEarnPerWeek = hasWeeklyLimit,
      quantityEarnedThisWeek = earnedThisWeek,
      isTradeable = false,
      quality = rarity,
      maxWeeklyQuantity = weeklyMax,
      totalEarned = 0,
      discovered = isDiscovered,
      useTotalEarnedForMaxQty = false,
    }
    return currencyInfo
  end
end

local function InitializeCurrencies()
  if Private.discovered_currencies then
    return
  end
  ---@type table<number, string>
  Private.discovered_currencies = {}
  ---@type table<number, number>
  Private.discovered_currencies_sorted = {}
  ---@type table<string, boolean>
  Private.discovered_currencies_headers = {}
  local expanded = {}

  for index = Private.GetCurrencyListSize(), 1, -1 do
    local currencyInfo = Private.GetCurrencyListInfo(index)
    if currencyInfo.isHeader and not currencyInfo.isHeaderExpanded then
      Private.ExpandCurrencyList(index, true)
      expanded[currencyInfo.name] = true
    end
  end

  for index = 1, Private.GetCurrencyListSize() do
    local currencyLink = C_CurrencyInfo.GetCurrencyListLink(index)
    local currencyInfo = Private.GetCurrencyListInfo(index)

    if currencyLink then
      local currencyID = Private.GetCurrencyIDFromLink(currencyLink)
      local icon = currencyInfo.iconFileID or "Interface\\Icons\\INV_Misc_QuestionMark" --iconFileID not available on first login
      Private.discovered_currencies[currencyID] = "|T" .. icon .. ":0|t" .. currencyInfo.name
      Private.discovered_currencies_sorted[currencyID] = index
    elseif currencyInfo.isHeader then
      Private.discovered_currencies[currencyInfo.name] = currencyInfo.name
      Private.discovered_currencies_sorted[currencyInfo.name] = index
      Private.discovered_currencies_headers[currencyInfo.name] = true
    end
  end

  for index = Private.GetCurrencyListSize(), 1, -1 do
    local currencyInfo = Private.GetCurrencyListInfo(index)
    if currencyInfo.isHeader and expanded[currencyInfo.name] then
      Private.ExpandCurrencyList(index, false)
    end
  end

  Private.discovered_currencies["member"] = "|Tinterface\\common\\ui-searchbox-icon:0:0:0:-2|t"..L["Specific Currency"];
  Private.discovered_currencies_sorted["member"] = -1;
end

---@type function
Private.GetDiscoveredCurrencies = function()
  InitializeCurrencies()
  return Private.discovered_currencies
end

---@type function
Private.GetDiscoveredCurrenciesSorted  = function()
  InitializeCurrencies()
  return Private.discovered_currencies_sorted
end

---@type function
Private.GetDiscoveredCurrenciesHeaders  = function()
  InitializeCurrencies()
  return Private.discovered_currencies_headers
end

local function InitializeReputations()
  if Private.reputations then
    return
  end

  ---@type table<number, string>
  Private.reputations = {}
  ---@type table<number, number>
  Private.reputations_sorted = {}
  ---@type table<string, boolean>
  Private.reputations_headers = {}

  -- Ensure all factions are shown by adjusting filters
  local showLegacy = true
  if not Private.ExecEnv.AreLegacyReputationsShown() then
    showLegacy = false
    C_Reputation.SetLegacyReputationsShown(true)
  end
  local sortType = 0
  if Private.ExecEnv.GetReputationSortType() > 0 then
    sortType = Private.ExecEnv.GetReputationSortType()
    C_Reputation.SetReputationSortType(0)
  end

  -- Dynamic expansion of all collapsed headers
  local collapsed = {}
  local index = 1
  while index <= Private.ExecEnv.GetNumFactions() do
    local factionData = Private.ExecEnv.GetFactionDataByIndex(index)
    if factionData and factionData.isHeader and factionData.isCollapsed then
      Private.ExecEnv.ExpandFactionHeader(index)
      collapsed[factionData.name] = true
    end
    index = index + 1
  end

  -- Process all faction data
  for i = 1, Private.ExecEnv.GetNumFactions() do
    local factionData = Private.ExecEnv.GetFactionDataByIndex(i)
    if factionData then
      if factionData.currentStanding > 0 or not factionData.isHeader then
        local factionID = factionData.factionID
        if factionID then
          Private.reputations[factionID] = factionData.name
          Private.reputations_sorted[factionID] = i
        end
      else
        local name = factionData.name
        Private.reputations[name] = name
        Private.reputations_sorted[name] = i
        Private.reputations_headers[name] = true
      end
    end
  end

  -- Collapse headers back to their original state
  for i = Private.ExecEnv.GetNumFactions(), 1, -1 do
    local factionData = Private.ExecEnv.GetFactionDataByIndex(i)
    if factionData and collapsed[factionData.name] then
      Private.ExecEnv.CollapseFactionHeader(i)
    end
  end

  -- Restore filters if they were changed
  if not showLegacy then
    C_Reputation.SetLegacyReputationsShown(false)
  end
  if sortType > 0 then
    C_Reputation.SetReputationSortType(sortType)
  end
end

---@type function
Private.GetReputations = function()
  InitializeReputations()
  return Private.reputations
end

---@type function
Private.GetReputationsSorted  = function()
  InitializeReputations()
  return Private.reputations_sorted
end

---@type function
Private.GetReputationsHeaders  = function()
  InitializeReputations()
  return Private.reputations_headers
end

---@type table<number, string>
Private.combatlog_raid_mark_check_type = {
  [0] = RAID_TARGET_NONE,
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_1:14|t " .. RAID_TARGET_1, -- Star
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_2:14|t " .. RAID_TARGET_2, -- Circle
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_3:14|t " .. RAID_TARGET_3, -- Diamond
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_4:14|t " .. RAID_TARGET_4, -- Triangle
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_5:14|t " .. RAID_TARGET_5, -- Moon
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_6:14|t " .. RAID_TARGET_6, -- Square
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_7:14|t " .. RAID_TARGET_7, -- Cross
  "|TInterface\\TARGETINGFRAME\\UI-RaidTargetingIcon_8:14|t " .. RAID_TARGET_8, -- Skull
  L["Any"]
}

---@type table<number, number>
Private.combatlog_raidFlags = {
  [0] = 0,
  [1] = 1,
  [2] = 2,
  [4] = 3,
  [8] = 4,
  [16] = 5,
  [32] = 6,
  [64] = 7,
  [128] = 8,
}

---@type table<number, string>
Private.raid_mark_check_type = CopyTable(Private.combatlog_raid_mark_check_type)
Private.raid_mark_check_type[9] = nil

Private.orientation_types = {
  HORIZONTAL_INVERSE = L["Left to Right"],
  HORIZONTAL = L["Right to Left"],
  VERTICAL = L["Bottom to Top"],
  VERTICAL_INVERSE = L["Top to Bottom"]
}

---@type table<string, string>
Private.orientation_with_circle_types = {
  HORIZONTAL_INVERSE = L["Left to Right"],
  HORIZONTAL = L["Right to Left"],
  VERTICAL = L["Bottom to Top"],
  VERTICAL_INVERSE = L["Top to Bottom"],
  CLOCKWISE = L["Clockwise"],
  ANTICLOCKWISE = L["Anticlockwise"]
}

---@type table<string, string>
Private.gradient_orientations = {
  HORIZONTAL = L["Horizontal"],
  VERTICAL = L["Vertical"]
}

Private.spec_types = {
  [1] = SPECIALIZATION.." 1",
  [2] = SPECIALIZATION.." 2",
  [3] = SPECIALIZATION.." 3",
  [4] = SPECIALIZATION.." 4"
}

Private.spec_types_3 = {
  [1] = SPECIALIZATION.." 1",
  [2] = SPECIALIZATION.." 2",
  [3] = SPECIALIZATION.." 3"
}

Private.spec_types_2 = {
  [1] = SPECIALIZATION.." 1",
  [2] = SPECIALIZATION.." 2"
}

WeakAuras.spec_types_specific = {}

---@type table<number, string>
Private.spec_types_all = {}
Private.specs_sorted = {}
local function update_specs()
  for _, classFileName in pairs(WeakAuras.classes_sorted) do
    local classID = WeakAuras.class_ids[classFileName]
    WeakAuras.spec_types_specific[classFileName] = {}
    local numSpecs = WeakAuras.IsCataClassic() and 3 or Private.ExecEnv.GetNumSpecializationsForClassID(classID) -- see https://github.com/Stanzilla/WoWUIBugs/issues/559
    for i = 1, numSpecs do
      local specId, tabName, _, icon = Private.ExecEnv.GetSpecializationInfoForClassID(classID, i);
      if tabName then
        tinsert(WeakAuras.spec_types_specific[classFileName], "|T"..(icon or "error")..":0|t "..(tabName or "error"));
        local classColor = WA_GetClassColor(classFileName)
        Private.spec_types_all[specId] = CreateAtlasMarkup(GetClassAtlas(classFileName:lower()))
        .. "|T"..(icon or "error")..":0|t "..(WrapTextInColorCode(tabName, classColor) or "error");
        tinsert(Private.specs_sorted, specId)
      end
    end
  end
end

---@type table<number, string>
Private.talent_types = {}
if WeakAuras.IsCataOrMistsOrRetail() then
  local spec_frame = CreateFrame("Frame");
  spec_frame:RegisterEvent("PLAYER_LOGIN")
  spec_frame:SetScript("OnEvent", update_specs);
else
  for tab = 1, GetNumTalentTabs() do
    for num_talent = 1, GetNumTalents(tab) do
      local talentId = (tab - 1) * MAX_NUM_TALENTS + num_talent
      Private.talent_types[talentId] = L["Tab "]..tab.." - "..num_talent
    end
  end
end

---@type table<number, string>
Private.talent_extra_option_types = {
    [0] = L["Talent Known"],
    [1] = L["Talent Selected"],
    [2] = L["Talent |cFFFF0000Not|r Known"],
    [3] = L["Talent |cFFFF0000Not|r Selected"],
}

-- GetTotemInfo() only works for the first 5 totems
---@type table<number, string>
Private.totem_types = {};
local totemString = L["Totem #%i"];
for i = 1, 5 do
  Private.totem_types[i] = totemString:format(i);
end

---@type table<string, string>
Private.loss_of_control_types = {
  NONE = "NONE",
  CHARM = "CHARM",
  CONFUSE = "CONFUSE",
  DISARM = "DISARM",
  FEAR = "FEAR",
  FEAR_MECHANIC = "FEAR_MECHANIC",
  PACIFY = "PACIFY",
  SILENCE = "SILENCE",
  PACIFYSILENCE = "PACIFYSILENCE",
  POSSESS = "POSSESS",
  ROOT = "ROOT",
  SCHOOL_INTERRUPT = "SCHOOL_INTERRUPT",
  STUN = "STUN",
  STUN_MECHANIC = "STUN_MECHANIC",
}

---@type table<number, string>
Private.main_spell_schools = {
  [1] = C_Spell.GetSchoolString(1),
  [2] = C_Spell.GetSchoolString(2),
  [4] = C_Spell.GetSchoolString(4),
  [8] = C_Spell.GetSchoolString(8),
  [16] = C_Spell.GetSchoolString(16),
  [32] = C_Spell.GetSchoolString(32),
  [64] = C_Spell.GetSchoolString(64),
}

---@type table<string, table<string, string>>
Private.texture_types = {
  ["Blizzard Alerts"] = {
    ["424570"] 	= "Spell Activation Overlay 0",
    ["449486"]  = "Arcane Missiles",
    ["449487"] 	= "Blood Surge",
    ["449488"] 	= "Brain Freeze",
    ["449489"] 	= "Frozen Fingers",
    ["449490"] 	= "Hot Streak",
    ["449491"] 	= "Imp Empowerment",
    ["449492"] 	= "Nightfall",
    ["449493"] 	= "Sudden Death",
    ["449494"] 	= "Sword and Board",
    ["450913"] 	= "Art of War",
    ["450914"] 	= "Eclipse Moon",
    ["450915"] 	= "Eclipse Sun",
    ["450916"] 	= "Focus Fire",
    ["450917"] 	= "Generic Arc 1",
    ["450918"] 	= "Generic Arc 2",
    ["450919"] 	= "Generic Arc 3",
    ["450920"] 	= "Generic Arc 4",
    ["450921"] 	= "Generic Arc 5",
    ["450922"] 	= "Generic Arc 6",
    ["450923"] 	= "Generic Top 1",
    ["450924"] 	= "Generic Top 2",
    ["450925"] 	= "Grand Crusader",
    ["450926"] 	= "Lock and Load",
    ["450927"] 	= "Maelstrom Weapon",
    ["450928"] 	= "Master Marksman",
    ["450929"] 	= "Nature's Grace",
    ["450930"] 	= "Rime",
    ["450931"] 	= "Slice and Dice",
    ["450932"] 	= "Sudden Doom",
    ["450933"] 	= "Surge of Light",
    ["457658"] 	= "Impact",
    ["458740"] 	= "Killing Machine",
    ["458741"] 	= "Molten Core",
    ["459313"] 	= "Daybreak",
    ["459314"] 	= "Hand of Light",
    ["460830"] 	= "Backslash",
    ["460831"] 	= "Fury of Stormrage",
    ["461878"] 	= "Dark Transformation",
    ["463452"] 	= "Shooting Stars",
    ["467696"] 	= "Fulmination",
    ["469752"] 	= "Serendipity",
    ["510822"] 	= "Berserk",
    ["510823"] 	= "Omen of Clarity (Feral)",
    ["511104"] 	= "Blood Boil",
    ["511105"] 	= "Necropolis",
    ["511469"] 	= "Denounce",
    ["592058"] 	= "Surge of Darkness",
    ["603338"] 	= "Dark Tiger",
    ["603339"] 	= "White Tiger",
    ["623950"] 	= "Monk Ox",
    ["623951"] 	= "Monk Serpent",
    ["623952"] 	= "Monk Tiger",
    ["627609"] 	= "Shadow of Death",
    ["627610"] 	= "Ultimatum",
    ["656728"] 	= "Shadow Word Insanity",
    ["774420"] 	= "Tooth and Claw",
    ["801266"] 	= "Backlash_Green",
    ["801267"] 	= "Imp Empowerment Green",
    ["801268"] 	= "Molten Core Green",
    ["898423"] 	= "Predatory Swiftness",
    ["962497"] 	= "Raging Blow",
    ["1001511"]	= "Monk Blackout Kick",
    ["1001512"]	= "Monk Tiger Palm",
    ["1027131"]	= "Arcane Missiles 1",
    ["1027132"]	= "Arcane Missiles 2",
    ["1027133"]	= "Arcane Missiles 3",
    ["1028091"]	= "Monk Ox 2",
    ["1028092"]	= "Monk Ox 3",
    ["1028136"]	= "Maelstrom Weapon 1",
    ["1028137"]	= "Maelstrom Weapon 2",
    ["1028138"]	= "Maelstrom Weapon 3",
    ["1028139"]	= "Maelstrom Weapon 4",
    ["1029138"]	= "Thrill of the Hunt 1",
    ["1029139"]	= "Thrill of the Hunt 2",
    ["1029140"]	= "Thrill of the Hunt 3",
    ["1030393"]	= "Bandits Guile",
    ["1057288"]	= "Echo of the Elements",
    ["1518303"] = "Predatory Swiftness Green",
    ["2851787"] = "Demonic Core",
    ["2851788"] = "High Tide",
    ["2888300"] = "Demonic Core Vertical",
    ["4699056"] = "Essence Burst",
    ["4699057"] = "Snapfire",
    ["6160020"] = "Arcane Soul",
    ["6160021"] = "Hyperthermia",
  },
  ["Icons"] = {
    ["165558"] = "Paw",
    ["165605"] = "Feathers",
    ["165607"] = "Lion",
    ["165608"] = "Cheetah",
    ["165609"] = "Hawk",
    ["165610"] = "Monkey",
    ["165611"] = "Snake",
    ["165612"] = "Wolf",
    ["166036"] = "Rage",
    ["166056"] = "Eye",
    ["166058"] = "Eyes",
    ["166125"] = "Fire",
    ["166386"] = "Snowflake",
    ["166418"] = "Inner Fire",
    ["166423"] = "Intellect",
    ["166606"] = "Leaf",
    ["166662"] = "Shield",
    ["166680"] = "Rampage",
    ["166683"] = "Rapid Fire",
    ["166706"] = "Reticle",
    ["166948"] = "Spirit",
    ["166954"] = "Bull",
    ["166984"] = "Crossed Swords",
    ["166989"] = "Stun Whirl",
    ["240925"] = "Holy Ruin",
    ["240961"] = "Crescent",
    ["240972"] = "Poison Skull",
    ["241049"] = "Star",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\cancel-icon.tga"] = "Cancel Icon",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\cancel-mark.tga"] = "Cancel Mark",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\emoji.tga"] = "Emoji",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\exclamation-mark.tga"] = "Exclamation Mark",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\eyes.tga"] = "Eyes",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\ok-icon.tga"] = "Ok Icon",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\targeting-mark.tga"] = "Targeting Mark",

  },
  ["Runes"] = {
    ["165630"] = "Ringed Aura Rune",
    ["165631"] = "Square Aura Rune",
    ["165633"] = "Tri-Circle Aura Rune",
    ["165634"] = "Tri-Circle Ringed Aura Rune",
    ["165635"] = "Spike-Ringed Aura Rune",
    ["165638"] = "Small Tri-Circle Aura Rune",
    ["165639"] = "Sliced Aura Rune",
    ["165640"] = "Oblong Aura Rune",
    ["165881"] = "Dark Summon",
    ["165885"] = "Death Rune",
    ["165922"] = "Demonic Summon",
    ["165927"] = "Demon Rune",
    ["165928"] = "Demon Rune",
    ["165929"] = "Demon Rune",
    ["166340"] = "Holy Rune",
    ["166341"] = "Holy Cross Rune",
    ["166748"] = "Filled Circular Rune",
    ["166749"] = "Ringed Circular Rune",
    ["166750"] = "Sparse Circular Rune",
    ["166753"] = "Heavy BC Rune",
    ["166754"] = "Light BC Rune",
    ["166757"] = "Circular Frost Rune",
    ["166979"] = "Star Rune",
    ["241003"] = "Dual Blades",
    ["241004"] = "Octagonal Skulls",
    ["241005"] = "Dense Circular Rune",
  },
  ["PvP Emblems"] = {
    ["Interface\\PVPFrame\\PVP-Banner-Emblem-1"] = "Wheelchair",
    ["Interface\\PVPFrame\\PVP-Banner-Emblem-2"] = "Recycle",
    ["Interface\\PVPFrame\\PVP-Banner-Emblem-3"] = "Biohazard",
    ["Interface\\PVPFrame\\PVP-Banner-Emblem-4"] = "Heart",
    ["Interface\\PVPFrame\\PVP-Banner-Emblem-5"] = "Lightning Bolt",
    ["Interface\\PVPFrame\\PVP-Banner-Emblem-6"] = "Bone",
    ["Interface\\PVPFrame\\PVP-Banner-Emblem-7"] = "Glove",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-2"] = "Bull",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-3"] = "Bird Claw",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-4"] = "Canary",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-5"] = "Mushroom",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-6"] = "Cherries",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-7"] = "Ninja",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-8"] = "Dog Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-9"] = "Circled Drop",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-10"] = "Circled Glove",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-11"] = "Winged Blade",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-12"] = "Circled Cross",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-13"] = "Dynamite",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-14"] = "Intellect",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-15"] = "Feather",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-16"] = "Present",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-17"] = "Giant Jaws",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-18"] = "Drums",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-19"] = "Panda",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-20"] = "Crossed Clubs",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-21"] = "Skeleton Key",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-22"] = "Heart Potion",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-23"] = "Trophy",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-24"] = "Crossed Mallets",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-25"] = "Circled Cheetah",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-26"] = "Mutated Chicken",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-27"] = "Anvil",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-28"] = "Dwarf Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-29"] = "Brooch",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-30"] = "Spider",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-31"] = "Dual Hawks",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-32"] = "Cleaver",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-33"] = "Spiked Bull",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-34"] = "Fist of Thunder",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-35"] = "Lean Bull",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-36"] = "Mug",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-37"] = "Sliced Circle",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-38"] = "Totem",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-39"] = "Skull and Crossbones",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-40"] = "Voodoo Doll",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-41"] = "Dual Wolves",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-42"] = "Wolf",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-43"] = "Crossed Wrenches",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-44"] = "Saber-toothed Tiger",
    --["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-45"] = "Targeting Eye", -- Duplicate of 53
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-46"] = "Artifact Disc",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-47"] = "Dice",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-48"] = "Fish Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-49"] = "Crossed Axes",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-50"] = "Doughnut",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-51"] = "Human Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-52"] = "Eyeball",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-53"] = "Targeting Eye",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-54"] = "Monkey Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-55"] = "Circle Skull",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-56"] = "Tipped Glass",
    --["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-57"] = "Saber-toothed Tiger", -- Duplicate of 44
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-58"] = "Pile of Weapons",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-59"] = "Mushrooms",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-60"] = "Pounding Mallet",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-61"] = "Winged Mask",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-62"] = "Axe",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-63"] = "Spiked Shield",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-64"] = "The Horns",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-65"] = "Ice Cream Cone",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-66"] = "Ornate Lockbox",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-67"] = "Roasting Marshmallow",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-68"] = "Smiley Bomb",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-69"] = "Fist",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-70"] = "Spirit Wings",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-71"] = "Ornate Pipe",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-72"] = "Scarab",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-73"] = "Glowing Ball",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-74"] = "Circular Rune",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-75"] = "Tree",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-76"] = "Flower Pot",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-77"] = "Night Elf Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-78"] = "Nested Egg",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-79"] = "Helmed Chicken",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-80"] = "Winged Boot",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-81"] = "Skull and Cross-Wrenches",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-82"] = "Cracked Skull",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-83"] = "Rocket",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-84"] = "Wooden Whistle",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-85"] = "Cogwheel",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-86"] = "Lizard Eye",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-87"] = "Baited Hook",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-88"] = "Beast Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-89"] = "Talons",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-90"] = "Rabbit",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-91"] = "4-Toed Pawprint",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-92"] = "Paw",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-93"] = "Mask",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-94"] = "Spiked Helm",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-95"] = "Dog Treat",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-96"] = "Targeted Orc",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-97"] = "Bird Face",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-98"] = "Lollipop",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-99"] = "5-Toed Pawprint",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-100"] = "Frightened Cat",
    ["Interface\\PVPFrame\\Icons\\PVP-Banner-Emblem-101"] = "Eagle Face"
  },
  ["Beams"] = {
    ["167096"] = "Gold Chain",
    ["167097"] = "Iron Chain",
    ["167098"] = "Green Fire Beam",
    ["167099"] = "Red Fire Beam",
    ["167100"] = "Brown Smoke Beam",
    ["167101"] = "Grey Smoke Beam",
    ["167102"] = "Green Vine",
    ["167103"] = "Red Vine",
    ["167104"] = "Blue Water Beam",
    ["167105"] = "Green Water Beam",
    ["186185"] = "Purple Beam",
    ["186186"] = "Red Beam",
    ["186187"] = "Red Drops Beam",
    ["186189"] = "Drain Mana Lightning",
    ["186192"] = "Ethereal Ribbon",
    ["186193"] = "Ghost Chain",
    ["186194"] = "Purple Ghost Chain",
    ["186195"] = "Heal Beam",
    ["186198"] = "Lightning",
    ["186201"] = "Red Lightning",
    ["186202"] = "Mana Beam",
    ["186205"] = "Mana Burn Beam",
    ["186208"] = "Rope",
    ["186211"] = "Shock Lightning",
    ["186214"] = "Soul Beam",
    ["241098"] = "Spirit Link Beam",
    ["241099"] = "Summon Gargoyle Beam",
    ["369749"] = "Straight Purple Beam",
    ["369750"] = "Shadow Beam",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\rainbowbar"] = "Rainbow Bar",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\StripedTexture"] = "Striped Bar",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\stripe-bar.tga"] = "Striped Bar 2",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\stripe-rainbow-bar.tga"] = "Rainbow Bar 2",
  },
  ["Shapes"] = {
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_Smooth"] = "Smooth Circle",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_Smooth_Border"] = "Smooth Circle with Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_Squirrel"] = "Spiralled Circle",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_Squirrel_Border"] = "Spiralled Circle with Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_White"] = "Circle",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_White_Border"] = "Circle with Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_Smooth"] = "Smooth Square",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_Smooth_Border"] = "Smooth Square with Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_Smooth_Border2"] = "Smooth Square with Border 2",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_Squirrel"] = "Spiralled Square",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_Squirrel_Border"] = "Spiralled Square with Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White"] = "Square",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_White_Border"] = "Square with Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_FullWhite"] = "Full White Square",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Triangle45"] = "45 Triangle",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Trapezoid"] = "Trapezoid",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\triangle-border.tga"] = "Triangle with Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\triangle.tga"] = "Triangle",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_Smooth2.tga"] = "Smooth Circle Small",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\circle_border5.tga"] = "Circle Border",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\ring_glow3.tga"] = "Circle Border Glow",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\square_mini.tga"] = "Small Square",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\target_indicator.tga"] = "Target Indicator",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\target_indicator_glow.tga"] = "Target Indicator Glow",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\arrows_target.tga"] = "Arrows Target",

    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_AlphaGradient_In.tga"] = "Circle Alpha Gradient In",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Circle_AlphaGradient_Out.tga"] = "Circle Alpha Gradient Out",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Ring_10px.tga"] = "Ring 10px",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Ring_20px.tga"] = "Ring 20px",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Ring_30px.tga"] = "Ring 30px",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Ring_40px.tga"] = "Ring 40px",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\Square_AlphaGradient.tga"] = "Square Alpha Gradient",

    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\square_border_1px.tga"] = "Square Border 1px",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\square_border_5px.tga"] = "Square Border 5px",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\square_border_10px.tga"] = "Square Border 10px",
  },
  ["Sparks"] = {
    ["130877"] = "Blizzard Spark",
    ["Insanity-Spark"] = "Blizzard Insanity Spark",
    ["XPBarAnim-OrangeSpark"] = "Blizzard XPBar Spark",
    ["GarrMission_EncounterBar-Spark"] = "Blizzard Garrison Mission Encounter Spark",
    ["Legionfall_BarSpark"]= "Blizzard Legionfall Spark",
    ["honorsystem-bar-spark"] = "Blizzard Honor System Spark",
    ["bonusobjectives-bar-spark"] = "Bonus Objectives Spark"
  },
  [BINDING_HEADER_RAID_TARGET] = {
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_1"] = RAID_TARGET_1,
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_2"] = RAID_TARGET_2,
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_3"] = RAID_TARGET_3,
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_4"] = RAID_TARGET_4,
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_5"] = RAID_TARGET_5,
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_6"] = RAID_TARGET_6,
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_7"] = RAID_TARGET_7,
    ["Interface\\TargetingFrame\\UI-RaidTargetingIcon_8"] = RAID_TARGET_8,
  },
  ["WeakAuras"] = {
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\logo_64.tga"] = "WeakAuras logo 64px",
    ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\logo_256.tga"] = "WeakAuras logo 256px"
  }
}

if C_Texture and C_Texture.GetAtlasElements then
  if WeakAuras.buildType == "dev" and Private.AtlasList then
    WeakAuras.prettyPrint("Private.AtlasList can be removed now.")
  end

  Private.texture_types["Blizzard Atlas"] = function()
    local atlasList = C_Texture.GetAtlasElements()
    table.sort(atlasList)
    local atlasTable = {}
    for _, atlas in ipairs(atlasList) do
      atlasTable[atlas] = atlas
    end
    return atlasTable
  end
elseif Private.AtlasList then
  Private.texture_types["Blizzard Atlas"] = {}
  for _, atlas in ipairs(Private.AtlasList) do
    Private.texture_types["Blizzard Atlas"][atlas] = atlas
  end
end
local BuildInfo = select(4, GetBuildInfo())
if BuildInfo <= 80100 then -- 8.1.5
  Private.texture_types.Sparks["worldstate-capturebar-spark-green"] = "Capture Bar Green Spark"
  Private.texture_types.Sparks["worldstate-capturebar-spark-yellow"] = "Capture Bar Yellow Spark"
end
if WeakAuras.IsClassicEra() then -- Classic
  Private.texture_types["Blizzard Alerts"] = nil
  do
    local beams = Private.texture_types["Beams"]
    local beams_ids = {167096, 167097, 167098, 167099, 167100, 167101, 167102, 167103, 167104, 167105, 186192, 186193, 186194, 241098, 241099, 369749, 369750}
    for _, v in ipairs(beams_ids) do
      beams[tostring(v)] = nil
    end
  end
  do
    local icons = Private.texture_types["Icons"]
    local icons_ids = {165605, 166036, 166680, 166948, 166989, 240925, 240961, 240972, 241049}
    for _, v in ipairs(icons_ids) do
      icons[tostring(v)] = nil
    end
  end
  do
    local runes = Private.texture_types["Runes"]
    local runes_ids = {165633, 165885, 165922, 166340, 166753, 166754, 241003, 241004, 241005}
    for _, v in ipairs(runes_ids) do
      runes[tostring(v)] = nil
    end
  end
elseif WeakAuras.IsCataClassic() then
  Private.texture_types["Blizzard Alerts"] = nil
  do
    local beams = Private.texture_types["Beams"]
    local beams_ids = {186193, 186194, 241098, 241099, 369749, 369750}
    for _, v in ipairs(beams_ids) do
      beams[tostring(v)] = nil
    end
  end
  do
    local icons = Private.texture_types["Icons"]
    local icons_ids = {165605, 240925, 240961, 240972, 241049}
    for _, v in ipairs(icons_ids) do
      icons[tostring(v)] = nil
    end
  end
  do
    local runes = Private.texture_types["Runes"]
    local runes_ids = {165922, 241003, 241004, 241005}
    for _, v in ipairs(runes_ids) do
      runes[tostring(v)] = nil
    end
  end
elseif WeakAuras.IsMists() then
  Private.texture_types["Blizzard Alerts"] = {
    ["424570"] 	= "Spell Activation Overlay 0",
    ["449486"]  = "Arcane Missiles",
    ["449487"] 	= "Blood Surge",
    ["449488"] 	= "Brain Freeze",
    ["449489"] 	= "Frozen Fingers",
    ["449490"] 	= "Hot Streak",
    ["449491"] 	= "Imp Empowerment",
    ["449492"] 	= "Nightfall",
    ["449493"] 	= "Sudden Death",
    ["449494"] 	= "Sword and Board",
    ["450913"] 	= "Art of War",
    ["450914"] 	= "Eclipse Moon",
    ["450915"] 	= "Eclipse Sun",
    ["450916"] 	= "Focus Fire",
    ["450917"] 	= "Generic Arc 1",
    ["450918"] 	= "Generic Arc 2",
    ["450919"] 	= "Generic Arc 3",
    ["450920"] 	= "Generic Arc 4",
    ["450921"] 	= "Generic Arc 5",
    ["450922"] 	= "Generic Arc 6",
    ["450923"] 	= "Generic Top 1",
    ["450924"] 	= "Generic Top 2",
    ["450925"] 	= "Grand Crusader",
    ["450926"] 	= "Lock and Load",
    ["450927"] 	= "Maelstrom Weapon",
    ["450928"] 	= "Master Marksman",
    ["450929"] 	= "Nature's Grace",
    ["450930"] 	= "Rime",
    ["450931"] 	= "Slice and Dice",
    ["450932"] 	= "Sudden Doom",
    ["450933"] 	= "Surge of Light",
    ["457658"] 	= "Impact",
    ["458740"] 	= "Killing Machine",
    ["458741"] 	= "Molten Core",
    ["459313"] 	= "Daybreak",
    ["459314"] 	= "Hand of Light",
    ["460830"] 	= "Backslash",
    ["460831"] 	= "Fury of Stormrage",
    ["461878"] 	= "Dark Transformation",
    ["463452"] 	= "Shooting Stars",
    ["467696"] 	= "Fulmination",
    ["469752"] 	= "Serendipity",
    ["510822"] 	= "Berserk",
    ["510823"] 	= "Omen of Clarity (Feral)",
    ["511104"] 	= "Blood Boil",
    ["511105"] 	= "Necropolis",
    ["511469"] 	= "Denounce",
    ["592058"] 	= "Surge of Darkness",
    ["603338"] 	= "Dark Tiger",
    ["603339"] 	= "White Tiger",
    ["623950"] 	= "Monk Ox",
    ["623951"] 	= "Monk Serpent",
    ["623952"] 	= "Monk Tiger",
    ["627609"] 	= "Shadow of Death",
    ["627610"] 	= "Ultimatum",
    ["656728"] 	= "Shadow Word Insanity",
    ["774420"] 	= "Tooth and Claw",
    ["801266"] 	= "Backlash_Green",
    ["801267"] 	= "Imp Empowerment Green",
    ["801268"] 	= "Molten Core Green",
    ["898423"] 	= "Predatory Swiftness",
  }
end

local PowerAurasPath = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Auras\\"
Private.texture_types["PowerAuras Heads-Up"] = {
  [PowerAurasPath.."Aura1"] = "Runed Text",
  [PowerAurasPath.."Aura2"] = "Runed Text On Ring",
  [PowerAurasPath.."Aura3"] = "Power Waves",
  [PowerAurasPath.."Aura4"] = "Majesty",
  [PowerAurasPath.."Aura5"] = "Runed Ends",
  [PowerAurasPath.."Aura6"] = "Extra Majesty",
  [PowerAurasPath.."Aura7"] = "Triangular Highlights",
  [PowerAurasPath.."Aura11"] = "Oblong Highlights",
  [PowerAurasPath.."Aura16"] = "Thin Crescents",
  [PowerAurasPath.."Aura17"] = "Crescent Highlights",
  [PowerAurasPath.."Aura18"] = "Dense Runed Text",
  [PowerAurasPath.."Aura23"] = "Runed Spiked Ring",
  [PowerAurasPath.."Aura24"] = "Smoke",
  [PowerAurasPath.."Aura28"] = "Flourished Text",
  [PowerAurasPath.."Aura33"] = "Droplet Highlights"
}
Private.texture_types["PowerAuras Icons"] = {
  [PowerAurasPath.."Aura8"] = "Rune",
  [PowerAurasPath.."Aura9"] = "Stylized Ghost",
  [PowerAurasPath.."Aura10"] = "Skull and Crossbones",
  [PowerAurasPath.."Aura12"] = "Snowflake",
  [PowerAurasPath.."Aura13"] = "Flame",
  [PowerAurasPath.."Aura14"] = "Holy Rune",
  [PowerAurasPath.."Aura15"] = "Zig-Zag Exclamation Point",
  [PowerAurasPath.."Aura19"] = "Crossed Swords",
  [PowerAurasPath.."Aura21"] = "Shield",
  [PowerAurasPath.."Aura22"] = "Glow",
  [PowerAurasPath.."Aura25"] = "Cross",
  [PowerAurasPath.."Aura26"] = "Droplet",
  [PowerAurasPath.."Aura27"] = "Alert",
  [PowerAurasPath.."Aura29"] = "Paw",
  [PowerAurasPath.."Aura30"] = "Bull",
  --   [PowerAurasPath.."Aura31"] = "Hieroglyphics Horizontal",
  [PowerAurasPath.."Aura32"] = "Hieroglyphics",
  [PowerAurasPath.."Aura34"] = "Circled Arrow",
  [PowerAurasPath.."Aura35"] = "Short Sword",
  --   [PowerAurasPath.."Aura36"] = "Short Sword Horizontal",
  [PowerAurasPath.."Aura45"] = "Circular Glow",
  [PowerAurasPath.."Aura48"] = "Totem",
  [PowerAurasPath.."Aura49"] = "Dragon Blade",
  [PowerAurasPath.."Aura50"] = "Ornate Design",
  [PowerAurasPath.."Aura51"] = "Inverted Holy Rune",
  [PowerAurasPath.."Aura52"] = "Stylized Skull",
  [PowerAurasPath.."Aura53"] = "Exclamation Point",
  [PowerAurasPath.."Aura54"] = "Nonagon",
  [PowerAurasPath.."Aura68"] = "Wings",
  [PowerAurasPath.."Aura69"] = "Rectangle",
  [PowerAurasPath.."Aura70"] = "Low Mana",
  [PowerAurasPath.."Aura71"] = "Ghostly Eye",
  [PowerAurasPath.."Aura72"] = "Circle",
  [PowerAurasPath.."Aura73"] = "Ring",
  [PowerAurasPath.."Aura74"] = "Square",
  [PowerAurasPath.."Aura75"] = "Square Brackets",
  [PowerAurasPath.."Aura76"] = "Bob-omb",
  [PowerAurasPath.."Aura77"] = "Goldfish",
  [PowerAurasPath.."Aura78"] = "Check",
  [PowerAurasPath.."Aura79"] = "Ghostly Face",
  [PowerAurasPath.."Aura84"] = "Overlapping Boxes",
  --   [PowerAurasPath.."Aura85"] = "Overlapping Boxes 45",
  --   [PowerAurasPath.."Aura86"] = "Overlapping Boxes 270",
  [PowerAurasPath.."Aura87"] = "Fairy",
  [PowerAurasPath.."Aura88"] = "Comet",
  [PowerAurasPath.."Aura95"] = "Dual Spiral",
  [PowerAurasPath.."Aura96"] = "Japanese Character",
  [PowerAurasPath.."Aura97"] = "Japanese Character",
  [PowerAurasPath.."Aura98"] = "Japanese Character",
  [PowerAurasPath.."Aura99"] = "Japanese Character",
  [PowerAurasPath.."Aura100"] = "Japanese Character",
  [PowerAurasPath.."Aura101"] = "Ball of Flame",
  [PowerAurasPath.."Aura102"] = "Zig-Zag",
  [PowerAurasPath.."Aura103"] = "Thorny Ring",
  [PowerAurasPath.."Aura110"] = "Hunter's Mark",
  --   [PowerAurasPath.."Aura111"] = "Hunter's Mark Horizontal",
  [PowerAurasPath.."Aura112"] = "Kaleidoscope",
  [PowerAurasPath.."Aura113"] = "Jesus Face",
  [PowerAurasPath.."Aura114"] = "Green Mushroom",
  [PowerAurasPath.."Aura115"] = "Red Mushroom",
  [PowerAurasPath.."Aura116"] = "Fire Flower",
  [PowerAurasPath.."Aura117"] = "Radioactive",
  [PowerAurasPath.."Aura118"] = "X",
  [PowerAurasPath.."Aura119"] = "Flower",
  [PowerAurasPath.."Aura120"] = "Petal",
  [PowerAurasPath.."Aura130"] = "Shoop Da Woop",
  [PowerAurasPath.."Aura131"] = "8-Bit Symbol",
  [PowerAurasPath.."Aura132"] = "Cartoon Skull",
  [PowerAurasPath.."Aura138"] = "Stop",
  [PowerAurasPath.."Aura139"] = "Thumbs Up",
  [PowerAurasPath.."Aura140"] = "Palette",
  [PowerAurasPath.."Aura141"] = "Blue Ring",
  [PowerAurasPath.."Aura142"] = "Ornate Ring",
  [PowerAurasPath.."Aura143"] = "Ghostly Skull"
}
Private.texture_types["PowerAuras Separated"] = {
  [PowerAurasPath.."Aura46"] = "8-Part Ring 1",
  [PowerAurasPath.."Aura47"] = "8-Part Ring 2",
  [PowerAurasPath.."Aura55"] = "Skull on Gear 1",
  [PowerAurasPath.."Aura56"] = "Skull on Gear 2",
  [PowerAurasPath.."Aura57"] = "Skull on Gear 3",
  [PowerAurasPath.."Aura58"] = "Skull on Gear 4",
  [PowerAurasPath.."Aura59"] = "Rune Ring Full",
  [PowerAurasPath.."Aura60"] = "Rune Ring Empty",
  [PowerAurasPath.."Aura61"] = "Rune Ring Left",
  [PowerAurasPath.."Aura62"] = "Rune Ring Right",
  [PowerAurasPath.."Aura63"] = "Spiked Rune Ring Full",
  [PowerAurasPath.."Aura64"] = "Spiked Rune Ring Empty",
  [PowerAurasPath.."Aura65"] = "Spiked Rune Ring Left",
  [PowerAurasPath.."Aura66"] = "Spiked Rune Ring Bottom",
  [PowerAurasPath.."Aura67"] = "Spiked Rune Ring Right",
  [PowerAurasPath.."Aura80"] = "Spiked Helm Background",
  [PowerAurasPath.."Aura81"] = "Spiked Helm Full",
  [PowerAurasPath.."Aura82"] = "Spiked Helm Bottom",
  [PowerAurasPath.."Aura83"] = "Spiked Helm Top",
  [PowerAurasPath.."Aura89"] = "5-Part Ring 1",
  [PowerAurasPath.."Aura90"] = "5-Part Ring 2",
  [PowerAurasPath.."Aura91"] = "5-Part Ring 3",
  [PowerAurasPath.."Aura92"] = "5-Part Ring 4",
  [PowerAurasPath.."Aura93"] = "5-Part Ring 5",
  [PowerAurasPath.."Aura94"] = "5-Part Ring Full",
  [PowerAurasPath.."Aura104"] = "Shield Center",
  [PowerAurasPath.."Aura105"] = "Shield Full",
  [PowerAurasPath.."Aura106"] = "Shield Top Right",
  [PowerAurasPath.."Aura107"] = "Shield Top Left",
  [PowerAurasPath.."Aura108"] = "Shield Bottom Right",
  [PowerAurasPath.."Aura109"] = "Shield Bottom Left",
  [PowerAurasPath.."Aura121"] = "Vine Top Right Leaf",
  [PowerAurasPath.."Aura122"] = "Vine Left Leaf",
  [PowerAurasPath.."Aura123"] = "Vine Bottom Right Leaf",
  [PowerAurasPath.."Aura124"] = "Vine Stem",
  [PowerAurasPath.."Aura125"] = "Vine Thorns",
  [PowerAurasPath.."Aura126"] = "3-Part Circle 1",
  [PowerAurasPath.."Aura127"] = "3-Part Circle 2",
  [PowerAurasPath.."Aura128"] = "3-Part Circle 3",
  [PowerAurasPath.."Aura129"] = "3-Part Circle Full",
  [PowerAurasPath.."Aura133"] = "Sliced Orb 1",
  [PowerAurasPath.."Aura134"] = "Sliced Orb 2",
  [PowerAurasPath.."Aura135"] = "Sliced Orb 3",
  [PowerAurasPath.."Aura136"] = "Sliced Orb 4",
  [PowerAurasPath.."Aura137"] = "Sliced Orb 5",
  [PowerAurasPath.."Aura144"] = "Taijitu Bottom",
  [PowerAurasPath.."Aura145"] = "Taijitu Top"
}

Private.texture_types["PowerAuras Words"] = {
  [PowerAurasPath.."Aura20"] = "Power",
  [PowerAurasPath.."Aura37"] = "Slow",
  [PowerAurasPath.."Aura38"] = "Stun",
  [PowerAurasPath.."Aura39"] = "Silence",
  [PowerAurasPath.."Aura40"] = "Root",
  [PowerAurasPath.."Aura41"] = "Disorient",
  [PowerAurasPath.."Aura42"] = "Dispel",
  [PowerAurasPath.."Aura43"] = "Danger",
  [PowerAurasPath.."Aura44"] = "Buff",
  [PowerAurasPath.."Aura44"] = "Buff",
  ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\interrupt"] = "Interrupt"
}

---@type table<string, string>
Private.operator_types = {
  ["=="] = "=",
  ["~="] = "!=",
  [">"] = ">",
  ["<"] = "<",
  [">="] = ">=",
  ["<="] = "<="
}

---@type table<string, string>
Private.equality_operator_types = {
  ["=="] = "=",
  ["~="] = "!="
}

---@type table<string, string>
Private.operator_types_without_equal = {
  [">="] = ">=",
  ["<="] = "<="
}

---@type table<string, string>
Private.string_operator_types = {
  ["=="] = L["Is Exactly"],
  ["find('%s')"] = L["Contains"],
  ["match('%s')"] = L["Matches (Pattern)"]
}

---@type table<string, string>
Private.weapon_types = {
  ["main"] = MAINHANDSLOT,
  ["off"] = SECONDARYHANDSLOT
}
if WeakAuras.IsCataClassic() then
  Private.weapon_types.ranged = RANGEDSLOT
end

---@type table<string, string>
Private.swing_types = {
  ["main"] = MAINHANDSLOT,
  ["off"] = SECONDARYHANDSLOT
}

if WeakAuras.IsClassicEra() then
  Private.swing_types["ranged"] = RANGEDSLOT
end

if WeakAuras.IsCataOrMists() then
  ---@type string[]
  Private.rune_specific_types = {
    [1] = L["Blood Rune #1"],
    [2] = L["Blood Rune #2"],
    [3] = L["Unholy Rune #1"],
    [4] = L["Unholy Rune #2"],
    [5] = L["Frost Rune #1"],
    [6] = L["Frost Rune #2"],
  }
else
  ---@type string[]
  Private.rune_specific_types = {
    [1] = L["Rune #1"],
    [2] = L["Rune #2"],
    [3] = L["Rune #3"],
    [4] = L["Rune #4"],
    [5] = L["Rune #5"],
    [6] = L["Rune #6"]
  }
  ---@type string[]
  Private.essence_specific_types = {
    [1] = L["Essence #1"],
    [2] = L["Essence #2"],
    [3] = L["Essence #3"],
    [4] = L["Essence #4"],
    [5] = L["Essence #5"],
    [6] = L["Essence #6"]
  }
end

---@type table<string, string>
Private.custom_trigger_types = {
  ["event"] = L["Event"],
  ["status"] = L["Status"],
  ["stateupdate"] = L["Trigger State Updater (Advanced)"]
}

---@type table<string, string>
Private.eventend_types = {
  ["timed"] = L["Timed"],
  ["custom"] = L["Custom"]
}

---@type table<string, string>
Private.timedeventend_types = {
  ["timed"] = L["Timed"],
}

---@type table<string, string>
Private.justify_types = {
  ["LEFT"] = L["Left"],
  ["CENTER"] = L["Center"],
  ["RIGHT"] = L["Right"]
}

---@type table<string, string>
Private.grow_types = {
  ["LEFT"] = L["Left"],
  ["RIGHT"] = L["Right"],
  ["UP"] = L["Up"],
  ["DOWN"] = L["Down"],
  ["HORIZONTAL"] = L["Centered Horizontal"],
  ["VERTICAL"] = L["Centered Vertical"],
  ["CIRCLE"] = L["Counter Clockwise"],
  ["COUNTERCIRCLE"] = L["Clockwise"],
  ["GRID"] = L["Grid"],
  ["CUSTOM"] = L["Custom"],
}

-- horizontal types: R (right), L (left)
-- vertical types: U (up), D (down)
---@type table<dynamicGroupGridType, string>
Private.grid_types = {
  RU = L["Right, then Up"],
  UR = L["Up, then Right"],
  LU = L["Left, then Up"],
  UL = L["Up, then Left"],
  RD = L["Right, then Down"],
  DR = L["Down, then Right"],
  LD = L["Left, then Down"],
  DL = L["Down, then Left"],
  HD = L["Centered Horizontal, then Down"],
  HU = L["Centered Horizontal, then Up"],
  VR = L["Centered Vertical, then Right"],
  VL = L["Centered Vertical, then Left"],
  DH = L["Down, then Centered Horizontal"],
  UH = L["Up, then Centered Horizontal"],
  LV = L["Left, then Centered Vertical"],
  RV = L["Right, then Centered Vertical"],
  HV = L["Centered Horizontal, then Centered Vertical"],
  VH = L["Centered Vertical, then Centered Horizontal"]
}

---@type table<dynamicGroupCenterType, string>
Private.centered_types_h = {
  LR = L["Left to Right"],
  RL = L["Right to Left"],
  CLR =L["Center, then alternating left and right"],
  CRL = L["Center, then alternating right and left"]
}

---@type table<dynamicGroupCenterType, string>
Private.centered_types_v = {
  LR = L["Bottom to Top"],
  RL = L["Top to Bottom"],
  CLR =L["Center, then alternating bottom and top"],
  CRL = L["Center, then alternating top and bottom"]
}

---@type table<string, string>
Private.text_rotate_types = {
  ["LEFT"] = L["Left"],
  ["NONE"] = L["None"],
  ["RIGHT"] = L["Right"]
}

---@type table<string, string>
Private.align_types = {
  ["LEFT"] = L["Left"],
  ["CENTER"] = L["Center"],
  ["RIGHT"] = L["Right"]
}

---@type table<string, string>
Private.rotated_align_types = {
  ["LEFT"] = L["Top"],
  ["CENTER"] = L["Center"],
  ["RIGHT"] = L["Bottom"]
}

---@type table<string, string>
Private.icon_side_types = {
  ["LEFT"] = L["Left"],
  ["RIGHT"] = L["Right"]
}

---@type table<string, string>
Private.rotated_icon_side_types = {
  ["LEFT"] = L["Top"],
  ["RIGHT"] = L["Bottom"]
}

---@type table<string, string>
Private.anim_types = {
  none = L["None"],
  preset = L["Preset"],
  custom = L["Custom"]
}

---@type table<string, string>
Private.anim_ease_types = {
  none = L["None"],
  easeIn = L["Ease In"],
  easeOut = L["Ease Out"],
  easeOutIn = L["Ease In and Out"]
}

---@type table<string, function>
Private.anim_ease_functions = {
  none = function(percent) return percent end,
  easeIn = function(percent, power)
    return percent ^ power;
  end,
  easeOut = function(percent, power)
    return 1.0 - (1.0 - percent) ^ power;
  end,
  easeOutIn = function(percent, power)
    if percent < .5 then
        return (percent * 2.0) ^ power * .5;
    end
    return 1.0 - ((1.0 - percent) * 2.0) ^ power * .5;
  end
}

---@type table<string, string>
Private.anim_translate_types = {
  straightTranslate = L["Normal"],
  circle = L["Circle"],
  spiral = L["Spiral"],
  spiralandpulse = L["Spiral In And Out"],
  shake = L["Shake"],
  bounce = L["Bounce"],
  bounceDecay = L["Bounce with Decay"],
  custom = L["Custom Function"]
}

---@type table<string, string>
Private.anim_scale_types = {
  straightScale = L["Normal"],
  pulse = L["Pulse"],
  fauxspin = L["Spin"],
  fauxflip = L["Flip"],
  custom = L["Custom Function"]
}

---@type table<string, string>
Private.anim_alpha_types = {
  straight = L["Normal"],
  alphaPulse = L["Pulse"],
  hide = L["Hide"],
  custom = L["Custom Function"]
}

---@type table<string, string>
Private.anim_rotate_types = {
  straight = L["Normal"],
  backandforth = L["Back and Forth"],
  wobble = L["Wobble"],
  custom = L["Custom Function"]
}

---@type table<string, string>
Private.anim_color_types = {
  straightColor = L["Legacy RGB Gradient"],
  straightHSV = L["Gradient"],
  pulseColor = L["Legacy RGB Gradient Pulse"],
  pulseHSV = L["Gradient Pulse"],
  custom = L["Custom Function"]
}

---@type table<string, string>
Private.instance_types = {
  none = L["No Instance"],
  scenario = L["Scenario"],
  party = L["5 Man Dungeon"],
  ten = L["10 Man Raid"],
  twenty = L["20 Man Raid"],
  twentyfive = L["25 Man Raid"],
  fortyman = L["40 Man Raid"],
  flexible = L["Flex Raid"],
  pvp = L["Battleground"],
  arena = L["Arena"],
  ratedpvp = L["Rated Battleground"],
  ratedarena = L["Rated Arena"]
}

if WeakAuras.IsClassicEra() then
  Private.instance_types["ratedpvp"] = nil
  Private.instance_types["arena"] = nil
  Private.instance_types["ratedarena"] = nil
end

---@type table
Private.instance_difficulty_types = {}

if not WeakAuras.IsClassicEra() then
  -- Fill out instance_difficulty_types automatically.
  -- Unfortunately the names BLizzard gives are not entirely unique,
  -- so try hard to disambiguate them via the type, and if nothing works by
  -- including the plain id.

  local unused = {}

  local instance_difficulty_names = {
    [1] = L["Dungeon (Normal)"],
    [2] = L["Dungeon (Heroic)"],
    [3] = L["10 Player Raid (Normal)"],
    [4] = L["25 Player Raid (Normal)"],
    [5] = L["10 Player Raid (Heroic)"],
    [6] = L["25 Player Raid (Heroic)"],
    [7] = L["Legacy Looking for Raid"],
    [8] = L["Mythic Keystone"],
    [9] = L["40 Player Raid"],
    [11] = L["Scenario (Heroic)"],
    [12] = L["Scenario (Normal)"],
    [14] = L["Raid (Normal)"],
    [15] = L["Raid (Heroic)"],
    [16] = L["Raid (Mythic)"],
    [17] = L["Looking for Raid"],
    [18] = unused, -- Event Raid
    [19] = unused, -- Event Party
    [20] = unused, -- Event Scenario
    [23] = L["Dungeon (Mythic)"],
    [24] = L["Dungeon (Timewalking)"],
    [25] = unused, -- World PvP Scenario
    [29] = unused, -- PvEvP Scenario
    [30] = unused, -- Event Scenario
    [32] = unused, -- World PvP Scenario
    [33] = L["Raid (Timewalking)"],
    [34] = unused, -- PvP
    [38] = L["Island Expedition (Normal)"],
    [39] = L["Island Expedition (Heroic)"],
    [40] = L["Island Expedition (Mythic)"],
    [45] = L["Island Expeditions (PvP)"],
    [147] = L["Warfront (Normal)"],
    [148] = L["20 Player Raid"],
    [149] = L["Warfront (Heroic)"],
    [152] = L["Visions of N'Zoth"],
    [150] = unused, -- Normal Party
    [151] = unused, -- LfR
    [153] = unused, -- Teeming Islands
    [167] = L["Torghast"],
    [168] = L["Path of Ascension: Courage"],
    [169] = L["Path of Ascension: Loyalty"],
    [171] = L["Path of Ascension: Humility"],
    [170] = L["Path of Ascension: Wisdom"],
    [172] = unused, -- World Boss
    [173] = L["Normal Party"],
    [174] = L["Heroic Party"],
    [175] = L["10 Player Raid"],
    [176] = L["25 Player Raid"],
    [192] = L["Dungeon (Mythic+)"], -- "Challenge Level 1" TODO: check if this label is correct
    [193] = L["10 Player Raid (Heroic)"],
    [194] = L["25 Player Raid (Heroic)"],
    [205] = L["Follower Dungeon"],
    [208] = L["Delve"],
    [216] = L["Quest Party"],
    [220] = L["Story Raid"],
    [230] = unused, -- heroic party
    [231] = unused, -- normal raid dungeon
    [232] = unused, -- event party
    [236] = L["Lorewalking"],
    [237] = WeakAuras.IsMists() and L["Dungeon (Celestial)"] or unused,
  }

  Private.instance_difficulty_types[0] =L["None"]

  for i = 1, 240 do
    local name, type = GetDifficultyInfo(i)
    if name then
      if instance_difficulty_names[i] then
        if instance_difficulty_names[i] ~= unused then
          Private.instance_difficulty_types[i] = instance_difficulty_names[i]
        end
      else
        Private.instance_difficulty_types[i] = name
        WeakAuras.prettyPrint(string.format("Unknown difficulty id found. You are probably running an outdated version. Debug Information: %s %s %s", i, name, type))
      end
    end
  end
end

---@type table<number, string>
Private.TocToExpansion = {
   [1] = L["Classic"],
   [2] = L["Burning Crusade"],
   [3] = L["Wrath of the Lich King"],
   [4] = L["Cataclysm"],
   [5] = L["Mists of Pandaria"],
   [6] = L["Warlords of Draenor"],
   [7] = L["Legion"],
   [8] = L["Battle for Azeroth"],
   [9] = L["Shadowlands"],
  [10] = L["Dragonflight"],
  [11] = L["The War Within"]
}

---@type table<string, string>
Private.group_types = {
  solo = L["Not in Group"],
  group = L["In Party"],
  raid = L["In Raid"]
}

---@type table<string, string>
if WeakAuras.IsRetail() then
  Private.difficulty_types = {
    none = L["None"],
    normal = PLAYER_DIFFICULTY1,
    heroic = PLAYER_DIFFICULTY2,
    mythic = PLAYER_DIFFICULTY6,
    timewalking = PLAYER_DIFFICULTY_TIMEWALKER,
    lfr = PLAYER_DIFFICULTY3,
    challenge = PLAYER_DIFFICULTY5
  }
elseif WeakAuras.IsCataClassic() then
  Private.difficulty_types = {
    none = L["None"],
    lfr = PLAYER_DIFFICULTY3,
    normal = PLAYER_DIFFICULTY1,
    heroic = PLAYER_DIFFICULTY2,
  }
elseif WeakAuras.IsMists() then
  Private.difficulty_types = {
    none = L["None"],
    normal = PLAYER_DIFFICULTY1,
    heroic = PLAYER_DIFFICULTY2,
    mythic = PLAYER_DIFFICULTY6,
    lfr = PLAYER_DIFFICULTY3,
    challenge = PLAYER_DIFFICULTY5
  }
end

---@type table<string, string>
if WeakAuras.IsClassicOrCataOrMists() then
  Private.raid_role_types = {
    MAINTANK = "|TInterface\\GroupFrame\\UI-Group-maintankIcon:16:16|t "..MAINTANK,
    MAINASSIST = "|TInterface\\GroupFrame\\UI-Group-mainassistIcon:16:16|t "..MAINASSIST,
    NONE = L["Other"]
  }
end

---@type table<string, string>
Private.role_types = {
  TANK = INLINE_TANK_ICON.." "..TANK,
  DAMAGER = INLINE_DAMAGER_ICON.." "..DAMAGER,
  HEALER = INLINE_HEALER_ICON.." "..HEALER
}

---@type table<string, string>
Private.group_member_types = {
  LEADER = L["Leader"],
  ASSIST = L["Assist"],
  NONE = L["None"]
}

---@type table<string, string>
Private.classification_types = {
  worldboss = L["World Boss"],
  rareelite = L["Rare Elite"],
  elite = L["Elite"],
  rare = L["Rare"],
  normal = L["Normal"],
  trivial = L["Trivial (Low Level)"],
  minus = L["Minus (Small Nameplate)"]
}

if WeakAuras.IsMistsOrRetail() then
  ---@type table<number, string>
  Private.creature_type_types = {}
  for _, creatureID in ipairs(C_CreatureInfo.GetCreatureTypeIDs()) do
    local creatureInfo = C_CreatureInfo.GetCreatureTypeInfo(creatureID)
    if creatureInfo then
      Private.creature_type_types[creatureID] = creatureInfo.name
    end
  end

  ---@type table<number, string>
  Private.creature_family_types = {}
  for _, familyID in ipairs(C_CreatureInfo.GetCreatureFamilyIDs()) do
    local familyInfo = C_CreatureInfo.GetCreatureFamilyInfo(familyID)
    if familyInfo then
      Private.creature_family_types[familyID] = familyInfo.name
    end
  end
end

---@type table<string, string>
Private.anim_start_preset_types = {
  slidetop = L["Slide from Top"],
  slideleft = L["Slide from Left"],
  slideright = L["Slide from Right"],
  slidebottom = L["Slide from Bottom"],
  fade = L["Fade In"],
  shrink = L["Grow"],
  grow = L["Shrink"],
  spiral = L["Spiral"],
  bounceDecay = L["Bounce"],
  starShakeDecay = L["Star Shake"],
}

---@type table<string, string>
Private.anim_main_preset_types = {
  shake = L["Shake"],
  spin = L["Spin"],
  flip = L["Flip"],
  wobble = L["Wobble"],
  pulse = L["Pulse"],
  alphaPulse = L["Flash"],
  rotateClockwise = L["Rotate Right"],
  rotateCounterClockwise = L["Rotate Left"],
  spiralandpulse = L["Spiral"],
  orbit = L["Orbit"],
  bounce = L["Bounce"]
}

---@type table<string, string>
Private.anim_finish_preset_types = {
  slidetop = L["Slide to Top"],
  slideleft = L["Slide to Left"],
  slideright = L["Slide to Right"],
  slidebottom = L["Slide to Bottom"],
  fade = L["Fade Out"],
  shrink = L["Shrink"],
  grow =L["Grow"],
  spiral = L["Spiral"],
  bounceDecay = L["Bounce"],
  starShakeDecay = L["Star Shake"],
}

---@type table<string, string>
Private.chat_message_types = {
  CHAT_MSG_INSTANCE_CHAT = L["Instance"],
  CHAT_MSG_BG_SYSTEM_NEUTRAL = L["BG-System Neutral"],
  CHAT_MSG_BG_SYSTEM_ALLIANCE = L["BG-System Alliance"],
  CHAT_MSG_BG_SYSTEM_HORDE = L["BG-System Horde"],
  CHAT_MSG_BN_WHISPER = L["Battle.net Whisper"],
  CHAT_MSG_CHANNEL = L["Channel"],
  CHAT_MSG_COMMUNITIES_CHANNEL = L["Communities"],
  CHAT_MSG_EMOTE = L["Emote"],
  CHAT_MSG_GUILD = L["Guild"],
  CHAT_MSG_MONSTER_YELL = L["Monster Yell"],
  CHAT_MSG_MONSTER_EMOTE = L["Monster Emote"],
  CHAT_MSG_MONSTER_SAY = L["Monster Say"],
  CHAT_MSG_MONSTER_WHISPER = L["Monster Whisper"],
  CHAT_MSG_MONSTER_PARTY = L["Monster Party"],
  CHAT_MSG_OFFICER = L["Officer"],
  CHAT_MSG_PARTY = L["Party"],
  CHAT_MSG_RAID = L["Raid"],
  CHAT_MSG_RAID_BOSS_EMOTE = L["Boss Emote"],
  CHAT_MSG_RAID_BOSS_WHISPER = L["Boss Whisper"],
  CHAT_MSG_RAID_WARNING = L["Raid Warning"],
  CHAT_MSG_SAY = L["Say"],
  CHAT_MSG_WHISPER = L["Whisper"],
  CHAT_MSG_YELL = L["Yell"],
  CHAT_MSG_SYSTEM = L["System"],
  CHAT_MSG_LOOT = L["Loot"],
}

---@type table<string, string>
Private.chat_message_leader_event = {
  CHAT_MSG_INSTANCE_CHAT = "CHAT_MSG_INSTANCE_CHAT_LEADER",
  CHAT_MSG_PARTY = "CHAT_MSG_PARTY_LEADER",
  CHAT_MSG_RAID = "CHAT_MSG_RAID_LEADER"
}

---@type table<string, string>
Private.send_chat_message_types = {
  WHISPER = L["Whisper"],
  SAY = L["Say"],
  EMOTE = L["Emote"],
  YELL = L["Yell"],
  PARTY = L["Party"],
  GUILD = L["Guild"],
  OFFICER = L["Officer"],
  RAID = L["Raid"],
  SMARTRAID = L["BG>Raid>Party>Say"],
  RAID_WARNING = L["Raid Warning"],
  INSTANCE_CHAT = L["Instance"],
  COMBAT = L["Blizzard Combat Text"],
  PRINT = L["Chat Frame"],
  ERROR = L["Error Frame"]
}

Private.send_chat_message_types.TTS = L["Text-to-speech"]


---@type table<string, string>
Private.group_aura_name_info_types = {
  aura = L["Aura Name"],
  players = L["Player(s) Affected"],
  nonplayers = L["Player(s) Not Affected"]
}

---@type table<string, string>
Private.group_aura_stack_info_types = {
  count = L["Number Affected"],
  stack = L["Aura Stack"]
}

---@type table<string, string>
Private.cast_types = {
  cast = L["Cast"],
  channel = L["Channel (Spell)"]
}

-- register sounds
LSM:Register("sound", "Heartbeat Single", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\HeartbeatSingle.ogg")
LSM:Register("sound", "Batman Punch", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\BatmanPunch.ogg")
LSM:Register("sound", "Bike Horn", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\BikeHorn.ogg")
LSM:Register("sound", "Boxing Arena Gong", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\BoxingArenaSound.ogg")
LSM:Register("sound", "Bleat", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Bleat.ogg")
LSM:Register("sound", "Cartoon Hop", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\CartoonHop.ogg")
LSM:Register("sound", "Cat Meow", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\CatMeow2.ogg")
LSM:Register("sound", "Kitten Meow", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\KittenMeow.ogg")
LSM:Register("sound", "Robot Blip", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\RobotBlip.ogg")
LSM:Register("sound", "Sharp Punch", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\SharpPunch.ogg")
LSM:Register("sound", "Water Drop", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\WaterDrop.ogg")
LSM:Register("sound", "Air Horn", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\AirHorn.ogg")
LSM:Register("sound", "Applause", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Applause.ogg")
LSM:Register("sound", "Banana Peel Slip", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\BananaPeelSlip.ogg")
LSM:Register("sound", "Blast", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Blast.ogg")
LSM:Register("sound", "Cartoon Voice Baritone", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\CartoonVoiceBaritone.ogg")
LSM:Register("sound", "Cartoon Walking", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\CartoonWalking.ogg")
LSM:Register("sound", "Cow Mooing", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\CowMooing.ogg")
LSM:Register("sound", "Ringing Phone", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\RingingPhone.ogg")
LSM:Register("sound", "Roaring Lion", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\RoaringLion.ogg")
LSM:Register("sound", "Shotgun", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Shotgun.ogg")
LSM:Register("sound", "Squish Fart", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\SquishFart.ogg")
LSM:Register("sound", "Temple Bell", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\TempleBellHuge.ogg")
LSM:Register("sound", "Torch", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Torch.ogg")
LSM:Register("sound", "Warning Siren", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\WarningSiren.ogg")
LSM:Register("sound", "Lich King Apocalypse", 554003) -- Sound\Creature\LichKing\IC_Lich King_Special01.ogg
-- Sounds from freesound.org, see commits for attributions
LSM:Register("sound", "Sheep Blerping", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\SheepBleat.ogg")
LSM:Register("sound", "Rooster Chicken Call", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\RoosterChickenCalls.ogg")
LSM:Register("sound", "Goat Bleeting", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\GoatBleating.ogg")
LSM:Register("sound", "Acoustic Guitar", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\AcousticGuitar.ogg")
LSM:Register("sound", "Synth Chord", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\SynthChord.ogg")
LSM:Register("sound", "Chicken Alarm", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\ChickenAlarm.ogg")
LSM:Register("sound", "Xylophone", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Xylophone.ogg")
LSM:Register("sound", "Drums", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Drums.ogg")
LSM:Register("sound", "Tada Fanfare", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\TadaFanfare.ogg")
LSM:Register("sound", "Squeaky Toy Short", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\SqueakyToyShort.ogg")
LSM:Register("sound", "Error Beep", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\ErrorBeep.ogg")
LSM:Register("sound", "Oh No", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\OhNo.ogg")
LSM:Register("sound", "Double Whoosh", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\DoubleWhoosh.ogg")
LSM:Register("sound", "Brass", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Brass.mp3")
LSM:Register("sound", "Glass", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Glass.mp3")

LSM:Register("sound", "Voice: Adds", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Adds.ogg")
LSM:Register("sound", "Voice: Boss", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Boss.ogg")
LSM:Register("sound", "Voice: Circle", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Circle.ogg")
LSM:Register("sound", "Voice: Cross", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Cross.ogg")
LSM:Register("sound", "Voice: Diamond", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Diamond.ogg")
LSM:Register("sound", "Voice: Don't Release", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\DontRelease.ogg")
LSM:Register("sound", "Voice: Empowered", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Empowered.ogg")
LSM:Register("sound", "Voice: Focus", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Focus.ogg")
LSM:Register("sound", "Voice: Idiot", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Idiot.ogg")
LSM:Register("sound", "Voice: Left", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Left.ogg")
LSM:Register("sound", "Voice: Moon", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Moon.ogg")
LSM:Register("sound", "Voice: Next", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Next.ogg")
LSM:Register("sound", "Voice: Portal", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Portal.ogg")
LSM:Register("sound", "Voice: Protected", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Protected.ogg")
LSM:Register("sound", "Voice: Release", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Release.ogg")
LSM:Register("sound", "Voice: Right", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Right.ogg")
LSM:Register("sound", "Voice: Run Away", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\RunAway.ogg")
LSM:Register("sound", "Voice: Skull", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Skull.ogg")
LSM:Register("sound", "Voice: Spread", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Spread.ogg")
LSM:Register("sound", "Voice: Square", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Square.ogg")
LSM:Register("sound", "Voice: Stack", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Stack.ogg")
LSM:Register("sound", "Voice: Star", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Star.ogg")
LSM:Register("sound", "Voice: Switch", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Switch.ogg")
LSM:Register("sound", "Voice: Taunt", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Taunt.ogg")
LSM:Register("sound", "Voice: Triangle", "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\Triangle.ogg")

local PowerAurasSoundPath = "Interface\\Addons\\WeakAuras\\PowerAurasMedia\\Sounds\\"
LSM:Register("sound", "Aggro", PowerAurasSoundPath.."aggro.ogg")
LSM:Register("sound", "Arrow Swoosh", PowerAurasSoundPath.."Arrow_swoosh.ogg")
LSM:Register("sound", "Bam", PowerAurasSoundPath.."bam.ogg")
LSM:Register("sound", "Polar Bear", PowerAurasSoundPath.."bear_polar.ogg")
LSM:Register("sound", "Big Kiss", PowerAurasSoundPath.."bigkiss.ogg")
LSM:Register("sound", "Bite", PowerAurasSoundPath.."BITE.ogg")
LSM:Register("sound", "Burp", PowerAurasSoundPath.."burp4.ogg")
LSM:Register("sound", "Cat", PowerAurasSoundPath.."cat2.ogg")
LSM:Register("sound", "Chant Major 2nd", PowerAurasSoundPath.."chant2.ogg")
LSM:Register("sound", "Chant Minor 3rd", PowerAurasSoundPath.."chant4.ogg")
LSM:Register("sound", "Chimes", PowerAurasSoundPath.."chimes.ogg")
LSM:Register("sound", "Cookie Monster", PowerAurasSoundPath.."cookie.ogg")
LSM:Register("sound", "Electrical Spark", PowerAurasSoundPath.."ESPARK1.ogg")
LSM:Register("sound", "Fireball", PowerAurasSoundPath.."Fireball.ogg")
LSM:Register("sound", "Gasp", PowerAurasSoundPath.."Gasp.ogg")
LSM:Register("sound", "Heartbeat", PowerAurasSoundPath.."heartbeat.ogg")
LSM:Register("sound", "Hiccup", PowerAurasSoundPath.."hic3.ogg")
LSM:Register("sound", "Huh?", PowerAurasSoundPath.."huh_1.ogg")
LSM:Register("sound", "Hurricane", PowerAurasSoundPath.."hurricane.ogg")
LSM:Register("sound", "Hyena", PowerAurasSoundPath.."hyena.ogg")
LSM:Register("sound", "Kaching", PowerAurasSoundPath.."kaching.ogg")
LSM:Register("sound", "Moan", PowerAurasSoundPath.."moan.ogg")
LSM:Register("sound", "Panther", PowerAurasSoundPath.."panther1.ogg")
LSM:Register("sound", "Phone", PowerAurasSoundPath.."phone.ogg")
LSM:Register("sound", "Punch", PowerAurasSoundPath.."PUNCH.ogg")
LSM:Register("sound", "Rain", PowerAurasSoundPath.."rainroof.ogg")
LSM:Register("sound", "Rocket", PowerAurasSoundPath.."rocket.ogg")
LSM:Register("sound", "Ship's Whistle", PowerAurasSoundPath.."shipswhistle.ogg")
LSM:Register("sound", "Gunshot", PowerAurasSoundPath.."shot.ogg")
LSM:Register("sound", "Snake Attack", PowerAurasSoundPath.."snakeatt.ogg")
LSM:Register("sound", "Sneeze", PowerAurasSoundPath.."sneeze.ogg")
LSM:Register("sound", "Sonar", PowerAurasSoundPath.."sonar.ogg")
LSM:Register("sound", "Splash", PowerAurasSoundPath.."splash.ogg")
LSM:Register("sound", "Squeaky Toy", PowerAurasSoundPath.."Squeakypig.ogg")
LSM:Register("sound", "Sword Ring", PowerAurasSoundPath.."swordecho.ogg")
LSM:Register("sound", "Throwing Knife", PowerAurasSoundPath.."throwknife.ogg")
LSM:Register("sound", "Thunder", PowerAurasSoundPath.."thunder.ogg")
LSM:Register("sound", "Wicked Male Laugh", PowerAurasSoundPath.."wickedmalelaugh1.ogg")
LSM:Register("sound", "Wilhelm Scream", PowerAurasSoundPath.."wilhelm.ogg")
LSM:Register("sound", "Wicked Female Laugh", PowerAurasSoundPath.."wlaugh.ogg")
LSM:Register("sound", "Wolf Howl", PowerAurasSoundPath.."wolf5.ogg")
LSM:Register("sound", "Yeehaw", PowerAurasSoundPath.."yeehaw.ogg")

---@type table<string, string>
Private.sound_types = {
  [" custom"] = " " .. L["Custom"],
  [" KitID"] = " " .. L["Sound by Kit ID"]
}

---@type table
Private.sound_file_types = {}

for name, path in next, LSM:HashTable("sound") do
  Private.sound_types[path] = name
  Private.sound_file_types[path] = name
end

LSM.RegisterCallback(WeakAuras, "LibSharedMedia_Registered", function(_, mediatype, key)
  if mediatype == "sound" then
    local path = LSM:Fetch(mediatype, key)
    if path then
      Private.sound_types[path] = key
      Private.sound_file_types[path] = key
    end
  elseif mediatype == "statusbar" or mediatype == "statusbar_atlas" then
    local path = LSM:Fetch(mediatype, key)
    if path then
      Private.texture_types["LibSharedMedia Textures"][path] = key
    end
  end
end)

Private.texture_types["LibSharedMedia Textures"] = {}
for _, mediaType in ipairs{"statusbar", "statusbar_atlas"} do
  local mediaTable = LSM:HashTable(mediaType)
  if mediaTable then
    for name, path in pairs(mediaTable) do
      Private.texture_types["LibSharedMedia Textures"][path] = name
    end
  end
end

-- register options font
LSM:Register("font", "Fira Mono Medium", "Interface\\Addons\\WeakAuras\\Media\\Fonts\\FiraMono-Medium.ttf", LSM.LOCALE_BIT_western + LSM.LOCALE_BIT_ruRU)
-- Other Fira fonts
LSM:Register("font", "Fira Sans Black", "Interface\\Addons\\WeakAuras\\Media\\Fonts\\FiraSans-Heavy.ttf", LSM.LOCALE_BIT_western + LSM.LOCALE_BIT_ruRU)
LSM:Register("font", "Fira Sans Condensed Black", "Interface\\Addons\\WeakAuras\\Media\\Fonts\\FiraSansCondensed-Heavy.ttf", LSM.LOCALE_BIT_western + LSM.LOCALE_BIT_ruRU)
LSM:Register("font", "Fira Sans Condensed Medium", "Interface\\Addons\\WeakAuras\\Media\\Fonts\\FiraSansCondensed-Medium.ttf", LSM.LOCALE_BIT_western + LSM.LOCALE_BIT_ruRU)
LSM:Register("font", "Fira Sans Medium", "Interface\\Addons\\WeakAuras\\Media\\Fonts\\FiraSans-Medium.ttf", LSM.LOCALE_BIT_western + LSM.LOCALE_BIT_ruRU)
LSM:Register("font", "PT Sans Narrow Regular", "Interface\\Addons\\WeakAuras\\Media\\Fonts\\PTSansNarrow-Regular.ttf", LSM.LOCALE_BIT_western + LSM.LOCALE_BIT_ruRU)
LSM:Register("font", "PT Sans Narrow Bold", "Interface\\Addons\\WeakAuras\\Media\\Fonts\\PTSansNarrow-Bold.ttf", LSM.LOCALE_BIT_western + LSM.LOCALE_BIT_ruRU)

-- register plain white border
LSM:Register("border", "Square Full White", [[Interface\AddOns\WeakAuras\Media\Textures\Square_FullWhite.tga]])

LSM:Register("statusbar", "Clean", [[Interface\AddOns\WeakAuras\Media\Textures\Statusbar_Clean]])
LSM:Register("statusbar", "Stripes", [[Interface\AddOns\WeakAuras\Media\Textures\Statusbar_Stripes]])
LSM:Register("statusbar", "Thick Stripes", [[Interface\AddOns\WeakAuras\Media\Textures\Statusbar_Stripes_Thick]])
LSM:Register("statusbar", "Thin Stripes", [[Interface\AddOns\WeakAuras\Media\Textures\Statusbar_Stripes_Thin]])
LSM:Register("border", "Drop Shadow", [[Interface\AddOns\WeakAuras\Media\Textures\Border_DropShadow]])

if PowerBarColor then
  local function capitalizeFirstLetter(str)
    -- Split the string into words separated by underscores
    local words = {}
    for word in string.gmatch(str, "[^_]+") do
      table.insert(words, word)
    end
    -- Capitalize the first letter of each word
    for i, word in ipairs(words) do
      words[i] = word:sub(1, 1):upper() .. word:sub(2):lower()
    end
    return table.concat(words, " ")
  end

  for power, data in pairs(PowerBarColor) do
    local name, path
    if type(power) == "string" and data.atlas then
      name = "Blizzard " .. capitalizeFirstLetter(power)
      path = data.atlas
    elseif data.atlasElementName then
      name = "Blizzard " .. data.atlasElementName
      path = "UI-HUD-UnitFrame-Player-PortraitOff-Bar-" .. data.atlasElementName
    end
    if name and path then
      LSM:Register("statusbar_atlas", name, path)
    end
  end
end

---@type table<string, string>
Private.duration_types = {
  seconds = L["Seconds"],
  relative = L["Relative"]
}

---@type table<string, string>
Private.duration_types_no_choice = {
  seconds = L["Seconds"]
}

---@type table<number, string>
Private.gtfo_types = {
  [1] = L["High Damage"],
  [2] = L["Low Damage"],
  [3] = L["Fail Alert"],
  [4] = L["Friendly Fire"]
}

---@type table<string, string>
Private.pet_behavior_types = {
  passive = PET_MODE_PASSIVE,
  defensive = PET_MODE_DEFENSIVE,
  assist = PET_MODE_ASSIST
}

if WeakAuras.IsClassicEra() then
  Private.pet_behavior_types.aggressive = PET_MODE_AGGRESSIVE
  Private.pet_behavior_types.assist = nil
end

---@type table<number, string>
if WeakAuras.IsRetail() then
  Private.pet_spec_types = {
    [1] = select(2, GetSpecializationInfoByID(74)), -- Ferocity
    [2] = select(2, GetSpecializationInfoByID(81)), -- Tenacity
    [3] = select(2, GetSpecializationInfoByID(79)) -- Cunning
  }
else
  Private.pet_spec_types = {}
end

---@type table<string, string>
Private.cooldown_progress_behavior_types = {
  showOnCooldown = L["On Cooldown"],
  showOnReady = L["Not on Cooldown"],
  showAlways = L["Always"]
}

---@type table<string, string>
Private.cooldown_types = {
  auto = L["Auto"],
  charges = L["Charges"],
  cooldown = L["Cooldown"]
}

---@type table<string, string>
Private.bufftrigger_progress_behavior_types = {
  showOnActive = L["Buffed/Debuffed"],
  showOnMissing = L["Missing"],
  showAlways= L["Always"]
}

---@type table<string, string>
Private.bufftrigger_2_progress_behavior_types = {
  showOnActive = L["Aura(s) Found"],
  showOnMissing = L["Aura(s) Missing"],
  showAlways = L["Always"],
  showOnMatches = L["Match Count"]
}

---@type table<string, string>
Private.bufftrigger_2_preferred_match_types = {
  showLowest = L["Least remaining time"],
  showHighest = L["Most remaining time"],
  showLowestSpellId = L["Lowest Spell Id"],
  showHighestSpellId = L["Highest Spell Id"],
}

---@type table<string, string>
Private.bufftrigger_2_per_unit_mode = {
  affected = L["Affected"],
  unaffected = L["Unaffected"],
  all = L["All"]
}

Private.item_slot_types = {
  [1]  = HEADSLOT,
  [2]  = NECKSLOT,
  [3]  = SHOULDERSLOT,
  [5]  = CHESTSLOT,
  [6]  = WAISTSLOT,
  [7]  = LEGSSLOT,
  [8]  = FEETSLOT,
  [9]  = WRISTSLOT,
  [10] = HANDSSLOT,
  [11] = FINGER0SLOT_UNIQUE,
  [12] = FINGER1SLOT_UNIQUE,
  [13] = TRINKET0SLOT_UNIQUE,
  [14] = TRINKET1SLOT_UNIQUE,
  [15] = BACKSLOT,
  [16] = MAINHANDSLOT,
  [17] = SECONDARYHANDSLOT,
  [19] = TABARDSLOT,
  [20] = L["1. Professsion Tool"],
  [21] = L["1. Profession 1. Accessory"],
  [22] = L["1. Profession 2. Accessory"],
  [23] = L["2. Professsion Tool"],
  [24] = L["2. Profession 1. Accessory"],
  [25] = L["2. Profession 2. Accessory"],
  [26] = COOKINGTOOLSLOT,
  [27] = COOKINGGEAR0SLOT,
  [28] = FISHINGTOOLSLOT,
}

---@type table<string, string>
Private.charges_change_type = {
  GAINED = L["Gained"],
  LOST = L["Lost"],
  CHANGED = L["Changed"]
}

---@type table<string, string>
Private.charges_change_condition_type = {
  GAINED = L["Gained"],
  LOST = L["Lost"]
}

---@type table<string, string>
Private.combat_event_type = {
  PLAYER_REGEN_ENABLED = L["Leaving"],
  PLAYER_REGEN_DISABLED = L["Entering"]
}

---@type table<string, string>
Private.encounter_event_type = {
  ENCOUNTER_END = L["Leaving"],
  ENCOUNTER_START = L["Entering"]
}

---@type table<number, string>
Private.bool_types = {
  [0] = L["False"],
  [1] = L["True"]
}

---@type table<string, string>
Private.absorb_modes = {
  OVERLAY_FROM_START = L["Attach to Start"],
  OVERLAY_FROM_END = L["Attach to End"],
  OVERLAY_FROM_END_REVERSE = L["Attach to End, backwards"]
}

---@type table
Private.mythic_plus_affixes = {}

local mythic_plus_ignorelist = {
  [1] = true,
  [15] = true
}

if WeakAuras.IsRetail() then
  for i = 1, 255 do
    local r = not mythic_plus_ignorelist[i] and C_ChallengeMode.GetAffixInfo(i)
    if r then
      Private.mythic_plus_affixes[i] = r
    end
  end
end

---@type table<number, table<string, any>>
Private.update_categories = {
  {
    name = "anchor",
    -- Note, these are special cased for child auras and considered arrangement
    fields = {
      "xOffset",
      "yOffset",
      "selfPoint",
      "anchorPoint",
      "anchorFrameType",
      "anchorFrameFrame",
      "frameStrata",
      "height",
      "width",
      "fontSize",
      "scale",
    },
    default = false,
    label = L["Size & Position"],
  },
  {
    name = "userconfig",
    fields = {"config"},
    default = false,
    label = L["Custom Configuration"],
  },
  {
    name = "name",
    fields = {"id"},
    default = true,
    label = L["Aura Names"],
  },
  {
    name = "display",
    fields = {},
    default = true,
    label = L["Display"],
  },
  {
    name = "trigger",
    fields = {"triggers"},
    default = true,
    label = L["Trigger"],
  },
  {
    name = "conditions",
    fields = {"conditions"},
    default = true,
    label = L["Conditions"],
  },
  {
    name = "load",
    fields = {"load"},
    default = true,
    label = L["Load Conditions"],
  },
  {
    name = "action",
    fields = {"actions"},
    default = true,
    label = L["Actions"],
  },
  {
    name = "animation",
    fields = {"animation"},
    default = true,
    label = L["Animations"],
  },
  {
    name = "authoroptions",
    fields = {"authorOptions"},
    default = true,
    label = L["Author Options"]
  },
  {
    name = "arrangement",
    fields = {
      "grow",
      "space",
      "stagger",
      "sort",
      "hybridPosition",
      "radius",
      "align",
      "rotation",
      "constantFactor",
      "hybridSortMode",
    },
    default = true,
    label = L["Group Arrangement"],
  },
  {
    name = "oldchildren",
    fields = {},
    default = true,
    label = L["Remove Obsolete Auras"],
    skipInSummary = true
  },
  {
    name = "newchildren",
    fields = {},
    default = true,
    label = L["Add Missing Auras"],
    skipInSummary = true
  },
  {
    name = "metadata",
    fields = {
      "url",
      "desc",
      "version",
      "semver",
      "wagoID", -- i don't *love* that we're so closely tied to wago, but eh
    },
    default = true,
    label = L["Meta Data"],
  },
}

-- fields that are handled as special cases when importing
-- mismatch of internal fields is not counted as a difference
---@type table<string, boolean>
Private.internal_fields = {
  uid = true,
  internalVersion = true,
  sortHybridTable = true,
  tocversion = true,
  parent = true,
  controlledChildren = true,
  source = true
}

-- fields that are not included in exported data
-- these represent information which is only meaningful inside the db,
-- or are represented in other ways in exported
Private.non_transmissable_fields = {
  controlledChildren = true,
  parent = true,
  authorMode = true,
  skipWagoUpdate = true,
  ignoreWagoUpdate = true,
  preferToUpdate = true,
  information = {
    saved = true
  }
}

-- For nested groups, we do transmit parent + controlledChildren
Private.non_transmissable_fields_v2000 = {
  authorMode = true,
  skipWagoUpdate = true,
  ignoreWagoUpdate = true,
  preferToUpdate = true,
  information = {
    saved = true
  }
}

---@type table<string, any>
Private.data_stub = {
  -- note: this is the minimal data stub which prevents false positives in diff upon reimporting an aura.
  -- pending a refactor of other code which adds unnecessary fields, it is possible to shrink it
  triggers = {
    {
      trigger = {
        type = "aura2",
        names = {},
        event = "Health",
        subeventPrefix = "SPELL",
        subeventSuffix = "_CAST_START",
        spellIds = {},
        unit = "player",
        debuffType = "HELPFUL",
      },
      untrigger = {},
    },
  },
  load = {
    size = {
      multi = {},
    },
    spec = {
      multi = {},
    },
    class = {
      multi = {},
    },
    talent = {
      multi = {},
    },
  },
  actions = {
    init = {},
    start = {},
    finish = {},
  },
  animation = {
    start = {
      type = "none",
      duration_type = "seconds",
      easeType = "none",
      easeStrength = 3,
    },
    main = {
      type = "none",
      duration_type = "seconds",
      easeType = "none",
      easeStrength = 3,
    },
    finish = {
      type = "none",
      duration_type = "seconds",
      easeType = "none",
      easeStrength = 3,
    },
  },
  conditions = {},
  config = {},
  authorOptions = {},
  information = {},
}

---@type table<string, string>
Private.author_option_classes = {
  toggle = "simple",
  input = "simple",
  number = "simple",
  range = "simple",
  color = "simple",
  select = "simple",
  media = "simple",
  multiselect = "simple",
  description = "noninteractive",
  space = "noninteractive",
  header = "noninteractive",
  group = "group"
}

---@type table<string, string>
Private.author_option_types = {
  toggle = L["Toggle"],
  input = L["String"],
  number = L["Number"],
  range = L["Slider"],
  description = L["Description"],
  color = L["Color"],
  select = L["Dropdown Menu"],
  space = L["Space"],
  multiselect = L["Toggle List"],
  media = L["Media"],
  header = L["Separator"],
  group = L["Option Group"],
}

---@type table<string, table<string, any>>
Private.author_option_fields = {
  common = {
    type = true,
    name = true,
    useDesc = true,
    desc = true,
    key = true,
    width = true,
  },
  number = {
    min = 0,
    max = 1,
    step = .05,
    default = 0,
  },
  range = {
    min = 0,
    max = 1,
    step = .05,
    default = 0,
  },
  input = {
    default = "",
    useLength = false,
    length = 10,
    multiline = false,
  },
  toggle = {
    default = false,
  },
  description = {
    text = "",
    fontSize = "medium",
  },
  color = {
    default = {1, 1, 1, 1},
  },
  select = {
    values = {"val1"},
    default = 1,
  },
  space = {
    variableWidth = true,
    useHeight = false,
    height = 1,
  },
  media = {
    mediaType = "sound",
    media = "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\AirHorn.ogg"
  },
  multiselect = {
    default = {true},
    values = {"val1"},
  },
  header = {
    useName = false,
    text = "",
  },
  group = {
    groupType = "simple",
    useCollapse = true,
    collapse = false,
    limitType = "none",
    size = 10,
    nameSource = 0,
    hideReorder = true,
    entryNames = nil, -- handled as a special case in code
    subOptions = {},
    noMerge = false,
  }
}

---@type table<string, string>
Private.shared_media_types = {
  sound = L["Sound"],
  font = L["Font"],
  border = L["Border"],
  background = L["Background"],
  statusbar = L["Status Bar"]
}

---@type table<string, string>
Private.author_option_media_defaults = {
  sound = "Interface\\AddOns\\WeakAuras\\Media\\Sounds\\AirHorn.ogg",
  font = "Friz Quadrata TT",
  border = "1 Pixel",
  background = "None",
  statusbar = "Blizzard",
}

---@type table<string, string>
Private.author_option_media_controls = {
  statusbar = "LSM30_Statusbar",
  border = "LSM30_Border",
  background = "LSM30_Background",
  font = "LSM30_Font"
}

---@type table<string, string>
Private.author_option_media_itemControls = {
  sound = "WeakAurasMediaSound"
}

---@type table<number, string>
Private.array_entry_name_types = {
  [-1] = L["Fixed Names"],
  [0] = L["Entry Order"],
  -- the rest is auto-populated with indices which are valid entry name sources
}

-- option types which can be used to generate entry names on arrays
---@type table<string, boolean>
Private.name_source_option_types = {
  input = true,
  number = true,
  range = true,
}

---@type table<string, string>
Private.group_limit_types = {
  none = L["Unlimited"],
  max = L["Limited"],
  fixed = L["Fixed Size"],
}

---@type table<string, string>
Private.group_option_types = {
  simple = L["Simple"],
  array = L["Array"],
}

---@type table<number, string>
Private.difficulty_info = {
  [1] = {
    size = "party",
    difficulty = "normal",
  },
  [2] = {
    size = "party",
    difficulty = "heroic",
  },
  [3] = {
    size = "ten",
    difficulty = "normal",
  },
  [4] = {
    size = "twentyfive",
    difficulty = "normal",
  },
  [5] = {
    size = "ten",
    difficulty = "heroic",
  },
  [6] = {
    size = "twentyfive",
    difficulty = "heroic",
  },
  [7] = {
    size = "twentyfive",
    difficulty = "lfr",
  },
  [8] = {
    size = "party",
    difficulty = "challenge",
  },
  [9] = {
    size = "fortyman",
    difficulty = "normal",
  },
  [11] = {
    size = "scenario",
    difficulty = "heroic",
  },
  [12] = {
    size = "scenario",
    difficulty = "normal",
  },
  -- 13 is unused
  [14] = {
    size = "flexible",
    difficulty = "normal",
  },
  [15] = {
    size = "flexible",
    difficulty = "heroic",
  },
  [16] = {
    size = "twenty",
    difficulty = "mythic",
  },
  [17] = {
    size = "flexible",
    difficulty = "lfr",
  },
  [23] = {
    size = "party",
    difficulty = "mythic",
  },
  [24] = {
    size = "party",
    difficulty = "timewalking",
  },
  [33] = {
    size = "flexible",
    difficulty = "timewalking",
  },
  [148] = {
    size = "twenty",
    difficulty = "normal",
  },
  [173] = {
    size = "party",
    difficulty = "normal",
  },
  [174] = {
    size = "party",
    difficulty = "heroic",
  },
  [175] = {
    size = "ten",
    difficulty = "heroic",
  },
  [176] = {
    size = "twentyfive",
    difficulty = "heroic",
  },
  [186] = {
    size = "fortyman",
    difficulty = "normal",
  },
  [226] = {
    size = "twenty",
    difficulty = "normal",
  },
}

Private.glow_types = {
  ACShine = L["Autocast Shine"],
  Pixel = L["Pixel Glow"],
  buttonOverlay = L["Action Button Glow"],
}

if WeakAuras.IsMistsOrRetail() then
  Private.glow_types.Proc = L["Proc Glow"]
end

---@type table<string, string>
Private.font_sizes = {
  small = L["Small"],
  medium = L["Medium"],
  large = L["Large"],
}

-- unitIds registerable with RegisterUnitEvent
---@type table<string, boolean>
Private.baseUnitId = {
  ["player"] = true,
  ["target"] = true,
  ["pet"] = true,
  ["focus"] = true,
  ["vehicle"] = true,
  ["softenemy"] = true,
  ["softfriend"] = true
}

---@type table<string, boolean>
Private.multiUnitId = {
  ["nameplate"] = true,
  ["boss"] = true,
  ["arena"] = true,
  ["group"] = true,
  ["grouppets"] = true,
  ["grouppetsonly"] = true,
  ["party"] = true,
  ["partypets"] = true,
  ["partypetsonly"] = true,
  ["raid"] = true,
}

Private.multiUnitUnits = {
  ["nameplate"] = {},
  ["boss"] = {},
  ["arena"] = {},
  ["group"] = {},
  ["party"] = {},
  ["raid"] = {}
}

Private.multiUnitUnits.group["player"] = true
Private.multiUnitUnits.party["player"] = true

Private.multiUnitUnits.group["pet"] = true
Private.multiUnitUnits.party["pet"] = true

for i = 1, 4 do
  Private.baseUnitId["party"..i] = true
  Private.baseUnitId["partypet"..i] = true
  Private.multiUnitUnits.group["party"..i] = true
  Private.multiUnitUnits.party["party"..i] = true
  Private.multiUnitUnits.group["partypet"..i] = true
  Private.multiUnitUnits.party["partypet"..i] = true
end

if WeakAuras.IsCataOrMistsOrRetail() then
  for i = 1, 10 do
    Private.baseUnitId["boss"..i] = true
    Private.multiUnitUnits.boss["boss"..i] = true
  end
  for i = 1, 5 do
    Private.baseUnitId["arena"..i] = true
    Private.multiUnitUnits.arena["arena"..i] = true
  end
end

for i = 1, 40 do
  Private.baseUnitId["raid"..i] = true
  Private.baseUnitId["raidpet"..i] = true
  Private.baseUnitId["nameplate"..i] = true
  Private.multiUnitUnits.nameplate["nameplate"..i] = true
  Private.multiUnitUnits.group["raid"..i] = true
  Private.multiUnitUnits.raid["raid"..i] = true
  Private.multiUnitUnits.group["raidpet"..i] = true
  Private.multiUnitUnits.raid["raidpet"..i] = true
end

---@type table<number, string>
Private.dbm_types = {
  [1] = L["Add"],
  [2] = L["AOE"],
  [3] = L["Targeted"],
  [4] = L["Interrupt"],
  [5] = L["Role"],
  [6] = L["Phase"],
  [7] = L["Important"]
}

Private.bossmods_timerTypes = {
  PULL = L["Pull"],
  BREAK = L["Break"],
  TIMER = L["Timer"],
}

---@type table<string, string>
Private.weapon_enchant_types = {
  showOnActive = L["Enchant Found"],
  showOnMissing = L["Enchant Missing"],
  showAlways = L["Always"],
}

WeakAuras.EJIcons = {
  tank =      "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:7:25:7:25|t",
  dps =       "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:39:57:7:25|t",
  healer =    "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:71:89:7:25|t",
  mythic =    "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:103:121:7:25|t",
  deadly =    "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:135:153:7:25|t",
  important = "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:167:185:7:25|t",
  interrupt = "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:199:217:7:25|t",
  magic =     "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:231:249:7:25|t",
  curse =     "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:7:25:39:57|t",
  poison =    "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:39:57:39:57|t",
  disease =   "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:71:89:39:57|t",
  enrage =    "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:103:121:39:57|t",
  bleed =     "|TInterface\\EncounterJournal\\UI-EJ-Icons:::::256:64:158:192:32:64|t",
}

Private.reset_swing_spells = {}
Private.reset_ranged_swing_spells = {
  [2480] = true, -- Shoot Bow
  [7919] = true, -- Shoot Crossbow
  [7918] = true, -- Shoot Gun
  [2764] = true, -- Throw
  [5019] = true, -- Shoot Wands
  [75] = true, -- Auto Shot
  [5384] = true, -- Feign Death
  [467718] = true, -- Bleak Arrows
}

Private.noreset_swing_spells = {
  [23063] = true, -- Dense Dynamite
  [4054] = true, -- Rough Dynamite
  [4064] = true, -- Rough Copper Bomb
  [4061] = true, -- Coarse Dynamite
  [8331] = true, -- Ez-Thro Dynamite
  [4065] = true, -- Large Copper Bomb
  [4066] = true, -- Small Bronze Bomb
  [4062] = true, -- Heavy Dynamite
  [4067] = true, -- Big Bronze Bomb
  [4068] = true, -- Iron Grenade
  [23000] = true, -- Ez-Thro Dynamite II
  [12421] = true, -- Mithril Frag Bomb
  [4069] = true, -- Big Iron Bomb
  [12562] = true, -- The Big One
  [12543] = true, -- Hi-Explosive Bomb
  [19769] = true, -- Thorium Grenade
  [19784] = true, -- Dark Iron Bomb
  [30216] = true, -- Fel Iron Bomb
  [19821] = true, -- Arcane Bomb
  [39965] = true, -- Frost Grenade
  [30461] = true, -- The Bigger One
  [30217] = true, -- Adamantite Grenade
  [35476] = true, -- Drums of Battle
  [35475] = true, -- Drums of War
  [35477] = true, -- Drums of Speed
  [35478] = true, -- Drums of Restoration
  [34120] = true, -- Steady Shot (rank 1)
  [19434] = true, -- Aimed Shot (rank 1)
  [1464] = true, -- Slam (rank 1)
  [8820] = true, -- Slam (rank 2)
  [11604] = true, -- Slam (rank 3)
  [11605] = true, -- Slam (rank 4)
  [25241] = true, -- Slam (rank 5)
  [25242] = true, -- Slam (rank 6)
  --35474 Drums of Panic DO reset the swing timer, do not add
}

---@type table<number, string>
Private.item_weapon_types = {}

local skippedWeaponTypes = {}
skippedWeaponTypes[11] = true -- Bear Claws
skippedWeaponTypes[12] = true -- Cat Claws
skippedWeaponTypes[14] = true -- Misc
skippedWeaponTypes[17] = true -- Spears
if WeakAuras.IsClassicOrCataOrMists() then
  skippedWeaponTypes[9] = true -- Glaives
else
  skippedWeaponTypes[16] = true -- Thrown
end

for i = 0, 20 do
  if not skippedWeaponTypes[i] then
    Private.item_weapon_types[2 * 256 + i] = C_Item.GetItemSubClassInfo(2, i)
  end
end

-- Shields
Private.item_weapon_types[4 * 256 + 6] = C_Item.GetItemSubClassInfo(4, 6)
WeakAuras.item_weapon_types = Private.item_weapon_types

WeakAuras.StopMotion = WeakAuras.StopMotion or {}
WeakAuras.StopMotion.texture_types = WeakAuras.StopMotion.texture_types or {}
WeakAuras.StopMotion.texture_data = WeakAuras.StopMotion.texture_data or {}

WeakAuras.StopMotion.texture_types.Basic = {
  ["Interface\\AddOns\\WeakAuras\\Media\\Textures\\stopmotion"] = "Example",
}

WeakAuras.StopMotion.texture_data["Interface\\AddOns\\WeakAuras\\Media\\Textures\\stopmotion"] = { count = 64, rows = 8, columns = 8 }


WeakAuras.StopMotion.animation_types = {
  loop = L["Loop"],
  bounce = L["Forward, Reverse Loop"],
  once = L["Forward"],
  progress = L["Progress"]
}


if WeakAuras.IsClassicEra() then
  Private.baseUnitId.focus = nil
  Private.baseUnitId.vehicle = nil
  Private.multiUnitId.boss = nil
  Private.multiUnitId.arena = nil
  wipe(Private.multiUnitUnits.boss)
  wipe(Private.multiUnitUnits.arena)
  Private.unit_types_bufftrigger_2.boss = nil
  Private.unit_types_bufftrigger_2.arena = nil
  Private.actual_unit_types_cast.boss = nil
  Private.actual_unit_types_cast.arena = nil
  Private.item_slot_types[0] = AMMOSLOT
  Private.item_slot_types[18] = RANGEDSLOT
  for slot = 20, 28 do
    Private.item_slot_types[slot] = nil
  end
  Private.talent_extra_option_types[0] = nil
  Private.talent_extra_option_types[2] = nil

  local reset_swing_spell_list = {
    1464, 8820, 11604, 11605, -- Slam
    78, 284, 285, 1608, 11564, 11565, 11566, 11567, 25286, -- Heroic Strike
    845, 7369, 11608, 11609, 20569, -- Cleave
    2973, 14260, 14261, 14262, 14263, 14264, 14265, 14266, -- Raptor Strike
    6807, 6808, 6809, 8972, 9745, 9880, 9881, -- Maul
    20549, -- War Stomp
    2480, 7919, 7918, 2764, 5019, -- Shoots
    5384, -- Feign Death
  }
  for _, spellid in ipairs(reset_swing_spell_list) do
    Private.reset_swing_spells[spellid] = true
  end
end

if WeakAuras.IsCataClassic() then
  Private.item_slot_types[18] = RELICSLOT
  for slot = 20, 28 do
    Private.item_slot_types[slot] = nil
  end
  Private.talent_extra_option_types[0] = nil
  Private.talent_extra_option_types[2] = nil
end


-- ========================================
-- File: WeakAuras/Types_Cata.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local encounter_list = ""
local zoneId_list = ""
function Private.InitializeEncounterAndZoneLists()
	local currTier = EJ_GetCurrentTier()
  if encounter_list ~= "" then
    return
  end
	for tier = EJ_GetNumTiers(), EJ_GetNumTiers() do
		EJ_SelectTier(tier)
		local tierName = EJ_GetTierInfo(tier)
		for _, inRaid in ipairs({false, true}) do
			local instance_index = 1
			local instance_id = EJ_GetInstanceByIndex(instance_index, inRaid)
			local title = ("%s %s"):format(tierName , inRaid and L["Raids"] or L["Dungeons"])
			local zones = ""
			while instance_id do
				EJ_SelectInstance(instance_id)
				local instance_name, _, _, _, _, _, dungeonAreaMapID = EJ_GetInstanceInfo(instance_id)
				local ej_index = 1
				local boss, _, _, _, _, _, encounter_id = EJ_GetEncounterInfoByIndex(ej_index, instance_id)

				-- zone ids
				if dungeonAreaMapID and dungeonAreaMapID ~= 0 then
					local mapGroupId = C_Map.GetMapGroupID(dungeonAreaMapID)
					if mapGroupId then -- If there's a group id, only list that one
						zones = ("%s%s: g%d\n"):format(zones, instance_name, mapGroupId)
					else
						zones = ("%s%s: %d\n"):format(zones, instance_name, dungeonAreaMapID)
					end
				end

				-- Encounter ids
				if inRaid then
					while boss do
						if encounter_id then
							if instance_name then
								encounter_list = ("%s|cffffd200%s|r\n"):format(encounter_list, instance_name)
								instance_name = nil -- Only add it once per section
							end
							encounter_list = ("%s%s: %d\n"):format(encounter_list, boss, encounter_id)
						end
						ej_index = ej_index + 1
						boss, _, _, _, _, _, encounter_id = EJ_GetEncounterInfoByIndex(ej_index, instance_id)
					end
					encounter_list = encounter_list .. "\n"
				end
				instance_index = instance_index + 1
				instance_id = EJ_GetInstanceByIndex(instance_index, inRaid)
			end
			if zones ~= "" then
				zoneId_list = ("%s|cffffd200%s|r\n"):format(zoneId_list, title)
				zoneId_list = zoneId_list .. zones.. "\n"
			end
		end
	end
	EJ_SelectTier(currTier) -- restore previously selected tier

  encounter_list = encounter_list:sub(1, -3) .. "\n\n" .. L["Supports multiple entries, separated by commas\n"]
end

function Private.get_encounters_list()
  return encounter_list
end

function Private.get_zoneId_list()
  return zoneId_list
end

Private.talentInfo = {
  ["DEATHKNIGHT"] = {
    {
      135770, -- [1]
      4, -- [2]
      3, -- [3]
      50371, -- [4]
    }, -- [1]
    {
      135067, -- [1]
      1, -- [2]
      3, -- [3]
      49391, -- [4]
    }, -- [2]
    {
      132455, -- [1]
      1, -- [2]
      1, -- [3]
      49483, -- [4]
    }, -- [3]
    {
      237529, -- [1]
      5, -- [2]
      2, -- [3]
      48982, -- [4]
    }, -- [4]
    {
      132284, -- [1]
      2, -- [2]
      2, -- [3]
      49509, -- [4]
    }, -- [5]
    {
      132094, -- [1]
      5, -- [2]
      1, -- [3]
      81164, -- [4]
    }, -- [6]
    {
      136211, -- [1]
      4, -- [2]
      2, -- [3]
      49542, -- [4]
    }, -- [7]
    {
      135277, -- [1]
      7, -- [2]
      2, -- [3]
      49028, -- [4]
    }, -- [8]
    {
      132330, -- [1]
      1, -- [2]
      2, -- [3]
      49501, -- [4]
    }, -- [9]
    {
      136168, -- [1]
      5, -- [2]
      3, -- [3]
      55233, -- [4]
    }, -- [10]
    {
      236310, -- [1]
      3, -- [2]
      4, -- [3]
      53138, -- [4]
    }, -- [11]
    {
      237517, -- [1]
      6, -- [2]
      2, -- [3]
      81138, -- [4]
    }, -- [12]
    {
      135892, -- [1]
      3, -- [2]
      3, -- [3]
      49787, -- [4]
    }, -- [13]
    {
      458717, -- [1]
      3, -- [2]
      2, -- [3]
      49222, -- [4]
    }, -- [14]
    {
      132109, -- [1]
      3, -- [2]
      1, -- [3]
      49628, -- [4]
    }, -- [15]
    {
      458719, -- [1]
      4, -- [2]
      1, -- [3]
      81127, -- [4]
    }, -- [16]
    {
      458735, -- [1]
      2, -- [2]
      3, -- [3]
      81132, -- [4]
    }, -- [17]
    {
      237513, -- [1]
      6, -- [2]
      3, -- [3]
      81136, -- [4]
    }, -- [18]
    {
      458966, -- [1]
      2, -- [2]
      4, -- [3]
      85794, -- [4]
    }, -- [19]
    {
      237515, -- [1]
      2, -- [2]
      1, -- [3]
      94555, -- [4]
    }, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      136223, -- [1]
      2, -- [2]
      4, -- [3]
      49657, -- [4]
    }, -- [29]
    {
      458718, -- [1]
      4, -- [2]
      2, -- [3]
      51271, -- [4]
    }, -- [30]
    {
      460686, -- [1]
      4, -- [2]
      4, -- [3]
      81328, -- [4]
    }, -- [31]
    {
      135849, -- [1]
      3, -- [2]
      2, -- [3]
      50115, -- [4]
    }, -- [32]
    {
      135833, -- [1]
      7, -- [2]
      2, -- [3]
      49184, -- [4]
    }, -- [33]
    {
      135840, -- [1]
      4, -- [2]
      1, -- [3]
      59057, -- [4]
    }, -- [34]
    {
      135294, -- [1]
      3, -- [2]
      1, -- [3]
      49538, -- [4]
    }, -- [35]
    {
      135152, -- [1]
      5, -- [2]
      2, -- [3]
      49203, -- [4]
    }, -- [36]
    {
      132147, -- [1]
      1, -- [2]
      3, -- [3]
      50138, -- [4]
    }, -- [37]
    {
      135773, -- [1]
      5, -- [2]
      3, -- [3]
      50385, -- [4]
    }, -- [38]
    {
      135728, -- [1]
      1, -- [2]
      1, -- [3]
      91145, -- [4]
    }, -- [39]
    {
      135859, -- [1]
      1, -- [2]
      2, -- [3]
      55062, -- [4]
    }, -- [40]
    {
      135305, -- [1]
      3, -- [2]
      3, -- [3]
      51128, -- [4]
    }, -- [41]
    {
      135609, -- [1]
      2, -- [2]
      1, -- [3]
      51473, -- [4]
    }, -- [42]
    {
      136187, -- [1]
      2, -- [2]
      2, -- [3]
      49039, -- [4]
    }, -- [43]
    {
      252994, -- [1]
      4, -- [2]
      3, -- [3]
      55610, -- [4]
    }, -- [44]
    {
      135864, -- [1]
      5, -- [2]
      1, -- [3]
      50041, -- [4]
    }, -- [45]
    {
      132148, -- [1]
      6, -- [2]
      1, -- [3]
      66192, -- [4]
    }, -- [46]
    {
      135303, -- [1]
      6, -- [2]
      3, -- [3]
      81333, -- [4]
    }, -- [47]
    {
      132264, -- [1]
      2, -- [2]
      3, -- [3]
      51986, -- [4]
    }, -- [48]
    nil, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      136126, -- [1]
      1, -- [2]
      2, -- [3]
      49568, -- [4]
    }, -- [57]
    {
      136207, -- [1]
      1, -- [2]
      3, -- [3]
      81334, -- [4]
    }, -- [58]
    {
      136132, -- [1]
      5, -- [2]
      1, -- [3]
      49194, -- [4]
    }, -- [59]
    {
      458967, -- [1]
      7, -- [2]
      2, -- [3]
      49206, -- [4]
    }, -- [60]
    {
      136120, -- [1]
      4, -- [2]
      2, -- [3]
      49611, -- [4]
    }, -- [61]
    {
      135775, -- [1]
      5, -- [2]
      3, -- [3]
      50392, -- [4]
    }, -- [62]
    {
      237532, -- [1]
      1, -- [2]
      1, -- [3]
      49589, -- [4]
    }, -- [63]
    {
      132095, -- [1]
      6, -- [2]
      2, -- [3]
      51160, -- [4]
    }, -- [64]
    {
      252272, -- [1]
      3, -- [2]
      1, -- [3]
      51462, -- [4]
    }, -- [65]
    {
      135564, -- [1]
      4, -- [2]
      3, -- [3]
      91323, -- [4]
    }, -- [66]
    {
      342913, -- [1]
      5, -- [2]
      4, -- [3]
      63560, -- [4]
    }, -- [67]
    {
      237510, -- [1]
      5, -- [2]
      2, -- [3]
      51052, -- [4]
    }, -- [68]
    {
      136199, -- [1]
      2, -- [2]
      1, -- [3]
      55667, -- [4]
    }, -- [69]
    {
      132102, -- [1]
      2, -- [2]
      2, -- [3]
      81339, -- [4]
    }, -- [70]
    {
      136224, -- [1]
      3, -- [2]
      2, -- [3]
      49016, -- [4]
    }, -- [71]
    {
      136181, -- [1]
      6, -- [2]
      3, -- [3]
      49530, -- [4]
    }, -- [72]
    {
      136144, -- [1]
      2, -- [2]
      4, -- [3]
      49565, -- [4]
    }, -- [73]
    {
      136188, -- [1]
      3, -- [2]
      4, -- [3]
      49572, -- [4]
    }, -- [74]
    {
      136182, -- [1]
      3, -- [2]
      3, -- [3]
      91319, -- [4]
    }, -- [75]
    {
      237561, -- [1]
      4, -- [2]
      1, -- [3]
      96270, -- [4]
    }, -- [76]
    [85] = {
      "DeathKnightBlood", -- [1]
      "DeathKnightFrost", -- [2]
      "DeathKnightUnholy", -- [3]
    },
  },
  ["WARRIOR"] = {
    {
      132090, -- [1]
      2, -- [2]
      3, -- [3]
      12867, -- [4]
    }, -- [1]
    {
      236397, -- [1]
      2, -- [2]
      4, -- [3]
      12963, -- [4]
    }, -- [2]
    {
      132175, -- [1]
      2, -- [2]
      2, -- [3]
      29838, -- [4]
    }, -- [3]
    {
      132306, -- [1]
      3, -- [2]
      2, -- [3]
      12328, -- [4]
    }, -- [4]
    {
      132364, -- [1]
      6, -- [2]
      1, -- [3]
      56611, -- [4]
    }, -- [5]
    {
      132335, -- [1]
      5, -- [2]
      2, -- [3]
      64976, -- [4]
    }, -- [6]
    {
      132346, -- [1]
      5, -- [2]
      4, -- [3]
      29725, -- [4]
    }, -- [7]
    {
      236303, -- [1]
      7, -- [2]
      2, -- [3]
      46924, -- [4]
    }, -- [8]
    {
      132334, -- [1]
      4, -- [2]
      3, -- [3]
      29859, -- [4]
    }, -- [9]
    {
      458970, -- [1]
      1, -- [2]
      3, -- [3]
      80977, -- [4]
    }, -- [10]
    {
      236317, -- [1]
      1, -- [2]
      1, -- [3]
      84572, -- [4]
    }, -- [11]
    {
      236276, -- [1]
      3, -- [2]
      1, -- [3]
      56638, -- [4]
    }, -- [12]
    {
      458973, -- [1]
      5, -- [2]
      1, -- [3]
      84588, -- [4]
    }, -- [13]
    {
      132312, -- [1]
      3, -- [2]
      3, -- [3]
      16494, -- [4]
    }, -- [14]
    {
      133675, -- [1]
      1, -- [2]
      2, -- [3]
      84580, -- [4]
    }, -- [15]
    {
      133542, -- [1]
      6, -- [2]
      3, -- [3]
      85388, -- [4]
    }, -- [16]
    {
      298660, -- [1]
      4, -- [2]
      2, -- [3]
      85730, -- [4]
    }, -- [17]
    {
      136031, -- [1]
      2, -- [2]
      1, -- [3]
      12676, -- [4]
    }, -- [18]
    {
      132316, -- [1]
      3, -- [2]
      4, -- [3]
      12668, -- [4]
    }, -- [19]
    {
      132340, -- [1]
      4, -- [2]
      1, -- [3]
      12330, -- [4]
    }, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      133074, -- [1]
      1, -- [2]
      2, -- [3]
      85742, -- [4]
    }, -- [29]
    {
      132292, -- [1]
      1, -- [2]
      3, -- [3]
      12852, -- [4]
    }, -- [30]
    {
      136218, -- [1]
      1, -- [2]
      1, -- [3]
      16492, -- [4]
    }, -- [31]
    {
      136224, -- [1]
      3, -- [2]
      3, -- [3]
      13046, -- [4]
    }, -- [32]
    {
      136147, -- [1]
      2, -- [2]
      4, -- [3]
      12323, -- [4]
    }, -- [33]
    {
      136075, -- [1]
      2, -- [2]
      2, -- [3]
      12835, -- [4]
    }, -- [34]
    {
      136146, -- [1]
      3, -- [2]
      2, -- [3]
      12292, -- [4]
    }, -- [35]
    {
      236308, -- [1]
      5, -- [2]
      1, -- [3]
      46910, -- [4]
    }, -- [36]
    {
      132152, -- [1]
      3, -- [2]
      1, -- [3]
      12972, -- [4]
    }, -- [37]
    {
      460959, -- [1]
      5, -- [2]
      3, -- [3]
      12950, -- [4]
    }, -- [38]
    {
      135358, -- [1]
      2, -- [2]
      1, -- [3]
      20503, -- [4]
    }, -- [39]
    {
      460958, -- [1]
      4, -- [2]
      4, -- [3]
      60970, -- [4]
    }, -- [40]
    {
      132352, -- [1]
      4, -- [2]
      3, -- [3]
      29801, -- [4]
    }, -- [41]
    {
      236306, -- [1]
      6, -- [2]
      2, -- [3]
      46915, -- [4]
    }, -- [42]
    {
      236316, -- [1]
      7, -- [2]
      2, -- [3]
      46917, -- [4]
    }, -- [43]
    {
      458974, -- [1]
      7, -- [2]
      3, -- [3]
      81099, -- [4]
    }, -- [44]
    {
      458971, -- [1]
      5, -- [2]
      4, -- [3]
      46909, -- [4]
    }, -- [45]
    {
      458975, -- [1]
      6, -- [2]
      3, -- [3]
      29889, -- [4]
    }, -- [46]
    {
      132215, -- [1]
      4, -- [2]
      2, -- [3]
      85288, -- [4]
    }, -- [47]
    {
      135396, -- [1]
      4, -- [2]
      1, -- [3]
      81914, -- [4]
    }, -- [48]
    {
      132339, -- [1]
      2, -- [2]
      3, -- [3]
      61221, -- [4]
    }, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      236309, -- [1]
      1, -- [2]
      1, -- [3]
      50687, -- [4]
    }, -- [57]
    {
      134952, -- [1]
      2, -- [2]
      1, -- [3]
      12725, -- [4]
    }, -- [58]
    {
      132453, -- [1]
      2, -- [2]
      4, -- [3]
      12958, -- [4]
    }, -- [59]
    {
      132353, -- [1]
      4, -- [2]
      1, -- [3]
      12799, -- [4]
    }, -- [60]
    {
      132359, -- [1]
      2, -- [2]
      2, -- [3]
      84608, -- [4]
    }, -- [61]
    {
      135892, -- [1]
      1, -- [2]
      2, -- [3]
      12762, -- [4]
    }, -- [62]
    {
      132325, -- [1]
      3, -- [2]
      2, -- [3]
      12809, -- [4]
    }, -- [63]
    {
      460957, -- [1]
      1, -- [2]
      3, -- [3]
      84615, -- [4]
    }, -- [64]
    {
      135871, -- [1]
      3, -- [2]
      1, -- [3]
      12975, -- [4]
    }, -- [65]
    {
      134947, -- [1]
      5, -- [2]
      4, -- [3]
      86896, -- [4]
    }, -- [66]
    {
      135291, -- [1]
      4, -- [2]
      3, -- [3]
      20243, -- [4]
    }, -- [67]
    {
      458976, -- [1]
      5, -- [2]
      1, -- [3]
      80980, -- [4]
    }, -- [68]
    {
      236311, -- [1]
      6, -- [2]
      2, -- [3]
      46949, -- [4]
    }, -- [69]
    {
      236318, -- [1]
      5, -- [2]
      2, -- [3]
      50720, -- [4]
    }, -- [70]
    {
      236319, -- [1]
      3, -- [2]
      4, -- [3]
      57499, -- [4]
    }, -- [71]
    {
      236315, -- [1]
      6, -- [2]
      3, -- [3]
      46953, -- [4]
    }, -- [72]
    {
      236312, -- [1]
      7, -- [2]
      2, -- [3]
      46968, -- [4]
    }, -- [73]
    {
      132110, -- [1]
      3, -- [2]
      3, -- [3]
      29594, -- [4]
    }, -- [74]
    {
      236351, -- [1]
      2, -- [2]
      3, -- [3]
      84621, -- [4]
    }, -- [75]
    {
      132342, -- [1]
      4, -- [2]
      4, -- [3]
      80129, -- [4]
    }, -- [76]
    [85] = {
      "WarriorArms", -- [1]
      "WarriorFury", -- [2]
      "WarriorProtection", -- [3]
    },
  },
  ["PALADIN"] = {
    {
      135921, -- [1]
      2, -- [2]
      2, -- [3]
      20235, -- [4]
    }, -- [1]
    {
      135917, -- [1]
      1, -- [2]
      1, -- [3]
      20360, -- [4]
    }, -- [2]
    {
      135903, -- [1]
      3, -- [2]
      1, -- [3]
      85510, -- [4]
    }, -- [3]
    {
      236251, -- [1]
      4, -- [2]
      1, -- [3]
      53557, -- [4]
    }, -- [4]
    {
      135872, -- [1]
      5, -- [2]
      3, -- [3]
      31821, -- [4]
    }, -- [5]
    {
      135876, -- [1]
      6, -- [2]
      3, -- [3]
      31829, -- [4]
    }, -- [6]
    {
      236261, -- [1]
      4, -- [2]
      4, -- [3]
      53551, -- [4]
    }, -- [7]
    {
      236256, -- [1]
      1, -- [2]
      3, -- [3]
      54151, -- [4]
    }, -- [8]
    {
      236254, -- [1]
      3, -- [2]
      3, -- [3]
      53576, -- [4]
    }, -- [9]
    {
      236247, -- [1]
      4, -- [2]
      2, -- [3]
      53563, -- [4]
    }, -- [10]
    {
      236394, -- [1]
      6, -- [2]
      2, -- [3]
      85512, -- [4]
    }, -- [11]
    {
      135895, -- [1]
      3, -- [2]
      2, -- [3]
      31842, -- [4]
    }, -- [12]
    {
      461859, -- [1]
      7, -- [2]
      2, -- [3]
      85222, -- [4]
    }, -- [13]
    {
      461857, -- [1]
      2, -- [2]
      1, -- [3]
      85464, -- [4]
    }, -- [14]
    {
      460953, -- [1]
      4, -- [2]
      3, -- [3]
      85499, -- [4]
    }, -- [15]
    {
      134909, -- [1]
      3, -- [2]
      4, -- [3]
      88821, -- [4]
    }, -- [16]
    {
      460689, -- [1]
      5, -- [2]
      1, -- [3]
      20057, -- [4]
    }, -- [17]
    {
      135920, -- [1]
      2, -- [2]
      3, -- [3]
      20238, -- [4]
    }, -- [18]
    {
      135875, -- [1]
      5, -- [2]
      4, -- [3]
      93417, -- [4]
    }, -- [19]
    {
      460690, -- [1]
      1, -- [2]
      2, -- [3]
      20140, -- [4]
    }, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      133526, -- [1]
      1, -- [2]
      2, -- [3]
      20225, -- [4]
    }, -- [29]
    {
      135892, -- [1]
      2, -- [2]
      2, -- [3]
      20145, -- [4]
    }, -- [30]
    {
      253400, -- [1]
      5, -- [2]
      4, -- [3]
      70940, -- [4]
    }, -- [31]
    {
      135963, -- [1]
      2, -- [2]
      3, -- [3]
      20488, -- [4]
    }, -- [32]
    {
      236264, -- [1]
      6, -- [2]
      3, -- [3]
      84854, -- [4]
    }, -- [33]
    {
      135926, -- [1]
      3, -- [2]
      1, -- [3]
      84633, -- [4]
    }, -- [34]
    {
      136051, -- [1]
      3, -- [2]
      2, -- [3]
      84629, -- [4]
    }, -- [35]
    {
      135870, -- [1]
      7, -- [2]
      2, -- [3]
      31850, -- [4]
    }, -- [36]
    {
      135880, -- [1]
      5, -- [2]
      2, -- [3]
      20925, -- [4]
    }, -- [37]
    {
      135896, -- [1]
      6, -- [2]
      2, -- [3]
      53710, -- [4]
    }, -- [38]
    {
      236259, -- [1]
      2, -- [2]
      1, -- [3]
      53696, -- [4]
    }, -- [39]
    {
      236253, -- [1]
      3, -- [2]
      3, -- [3]
      53595, -- [4]
    }, -- [40]
    {
      135985, -- [1]
      5, -- [2]
      1, -- [3]
      26016, -- [4]
    }, -- [41]
    {
      133562, -- [1]
      3, -- [2]
      4, -- [3]
      84636, -- [4]
    }, -- [42]
    {
      135882, -- [1]
      4, -- [2]
      1, -- [3]
      20179, -- [4]
    }, -- [43]
    {
      133176, -- [1]
      4, -- [2]
      3, -- [3]
      85043, -- [4]
    }, -- [44]
    {
      236252, -- [1]
      5, -- [2]
      3, -- [3]
      85646, -- [4]
    }, -- [45]
    {
      236265, -- [1]
      4, -- [2]
      2, -- [3]
      53600, -- [4]
    }, -- [46]
    {
      135433, -- [1]
      1, -- [2]
      3, -- [3]
      87164, -- [4]
    }, -- [47]
    {
      135883, -- [1]
      1, -- [2]
      1, -- [3]
      63648, -- [4]
    }, -- [48]
    nil, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      135897, -- [1]
      5, -- [2]
      3, -- [3]
      86172, -- [4]
    }, -- [57]
    {
      132347, -- [1]
      4, -- [2]
      3, -- [3]
      85126, -- [4]
    }, -- [58]
    {
      135904, -- [1]
      1, -- [2]
      1, -- [3]
      25988, -- [4]
    }, -- [59]
    {
      135889, -- [1]
      1, -- [2]
      2, -- [3]
      31868, -- [4]
    }, -- [60]
    {
      236246, -- [1]
      3, -- [2]
      2, -- [3]
      87138, -- [4]
    }, -- [61]
    {
      135942, -- [1]
      5, -- [2]
      2, -- [3]
      20066, -- [4]
    }, -- [62]
    {
      236257, -- [1]
      3, -- [2]
      1, -- [3]
      31876, -- [4]
    }, -- [63]
    {
      236262, -- [1]
      4, -- [2]
      4, -- [3]
      53376, -- [4]
    }, -- [64]
    {
      236260, -- [1]
      6, -- [2]
      2, -- [3]
      53382, -- [4]
    }, -- [65]
    {
      236250, -- [1]
      3, -- [2]
      4, -- [3]
      53385, -- [4]
    }, -- [66]
    {
      236249, -- [1]
      4, -- [2]
      1, -- [3]
      85285, -- [4]
    }, -- [67]
    {
      236248, -- [1]
      6, -- [2]
      3, -- [3]
      85795, -- [4]
    }, -- [68]
    {
      237547, -- [1]
      7, -- [2]
      2, -- [3]
      85696, -- [4]
    }, -- [69]
    {
      134916, -- [1]
      2, -- [2]
      2, -- [3]
      87461, -- [4]
    }, -- [70]
    {
      252269, -- [1]
      5, -- [2]
      1, -- [3]
      85804, -- [4]
    }, -- [71]
    {
      237486, -- [1]
      4, -- [2]
      2, -- [3]
      25956, -- [4]
    }, -- [72]
    {
      236258, -- [1]
      3, -- [2]
      3, -- [3]
      87172, -- [4]
    }, -- [73]
    {
      135937, -- [1]
      2, -- [2]
      4, -- [3]
      26023, -- [4]
    }, -- [74]
    {
      236255, -- [1]
      1, -- [2]
      3, -- [3]
      87175, -- [4]
    }, -- [75]
    {
      135964, -- [1]
      2, -- [2]
      1, -- [3]
      20175, -- [4]
    }, -- [76]
    [85] = {
      "PALADINHOLY", -- [1]
      "PALADINPROTECTION", -- [2]
      "PALADINCOMBAT", -- [3]
    },
  },
  ["MAGE"] = {
    {
      136071, -- [1]
      4, -- [2]
      1, -- [3]
      12592, -- [4]
    }, -- [1]
    {
      136170, -- [1]
      1, -- [2]
      1, -- [3]
      12575, -- [4]
    }, -- [2]
    {
      135856, -- [1]
      1, -- [2]
      2, -- [3]
      12598, -- [4]
    }, -- [3]
    {
      135737, -- [1]
      2, -- [2]
      1, -- [3]
      55340, -- [4]
    }, -- [4]
    {
      135736, -- [1]
      2, -- [2]
      4, -- [3]
      31570, -- [4]
    }, -- [5]
    {
      136031, -- [1]
      3, -- [2]
      2, -- [3]
      12043, -- [4]
    }, -- [6]
    {
      135752, -- [1]
      3, -- [2]
      4, -- [3]
      54354, -- [4]
    }, -- [7]
    {
      135732, -- [1]
      5, -- [2]
      1, -- [3]
      31572, -- [4]
    }, -- [8]
    {
      136048, -- [1]
      7, -- [2]
      2, -- [3]
      12042, -- [4]
    }, -- [9]
    {
      236219, -- [1]
      4, -- [2]
      3, -- [3]
      44395, -- [4]
    }, -- [10]
    {
      236223, -- [1]
      3, -- [2]
      1, -- [3]
      44379, -- [4]
    }, -- [11]
    {
      134104, -- [1]
      6, -- [2]
      3, -- [3]
      31585, -- [4]
    }, -- [12]
    {
      136091, -- [1]
      5, -- [2]
      2, -- [3]
      31589, -- [4]
    }, -- [13]
    {
      236221, -- [1]
      3, -- [2]
      3, -- [3]
      54486, -- [4]
    }, -- [14]
    {
      236222, -- [1]
      1, -- [2]
      3, -- [3]
      44403, -- [4]
    }, -- [15]
    {
      135754, -- [1]
      6, -- [2]
      1, -- [3]
      54646, -- [4]
    }, -- [16]
    {
      429382, -- [1]
      4, -- [2]
      2, -- [3]
      82930, -- [4]
    }, -- [17]
    {
      136096, -- [1]
      2, -- [2]
      3, -- [3]
      83515, -- [4]
    }, -- [18]
    {
      429383, -- [1]
      2, -- [2]
      2, -- [3]
      84723, -- [4]
    }, -- [19]
    {
      135735, -- [1]
      5, -- [2]
      3, -- [3]
      86209, -- [4]
    }, -- [20]
    nil, -- [21]
    {
      136116, -- [1]
      4, -- [2]
      4, -- [3]
      90788, -- [4]
    }, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      135807, -- [1]
      1, -- [2]
      3, -- [3]
      11080, -- [4]
    }, -- [29]
    {
      135818, -- [1]
      2, -- [2]
      1, -- [3]
      12846, -- [4]
    }, -- [30]
    {
      429590, -- [1]
      1, -- [2]
      2, -- [3]
      84254, -- [4]
    }, -- [31]
    {
      135821, -- [1]
      2, -- [2]
      4, -- [3]
      12357, -- [4]
    }, -- [32]
    {
      136115, -- [1]
      6, -- [2]
      3, -- [3]
      12873, -- [4]
    }, -- [33]
    {
      135806, -- [1]
      4, -- [2]
      1, -- [3]
      11094, -- [4]
    }, -- [34]
    {
      135820, -- [1]
      1, -- [2]
      1, -- [3]
      29075, -- [4]
    }, -- [35]
    {
      135827, -- [1]
      3, -- [2]
      4, -- [3]
      11367, -- [4]
    }, -- [36]
    {
      135903, -- [1]
      3, -- [2]
      2, -- [3]
      11113, -- [4]
    }, -- [37]
    {
      135788, -- [1]
      2, -- [2]
      3, -- [3]
      31642, -- [4]
    }, -- [38]
    {
      135789, -- [1]
      6, -- [2]
      1, -- [3]
      34295, -- [4]
    }, -- [39]
    {
      135824, -- [1]
      4, -- [2]
      2, -- [3]
      11129, -- [4]
    }, -- [40]
    {
      135822, -- [1]
      5, -- [2]
      3, -- [3]
      86880, -- [4]
    }, -- [41]
    {
      134153, -- [1]
      5, -- [2]
      2, -- [3]
      31661, -- [4]
    }, -- [42]
    {
      236218, -- [1]
      3, -- [2]
      3, -- [3]
      44445, -- [4]
    }, -- [43]
    {
      236220, -- [1]
      7, -- [2]
      2, -- [3]
      44457, -- [4]
    }, -- [44]
    {
      135826, -- [1]
      5, -- [2]
      1, -- [3]
      84674, -- [4]
    }, -- [45]
    {
      236216, -- [1]
      4, -- [2]
      4, -- [3]
      86914, -- [4]
    }, -- [46]
    {
      252268, -- [1]
      3, -- [2]
      1, -- [3]
      86949, -- [4]
    }, -- [47]
    {
      135817, -- [1]
      2, -- [2]
      2, -- [3]
      54734, -- [4]
    }, -- [48]
    {
      236218, -- [1]
      4, -- [2]
      3, -- [3]
      44448, -- [4]
    }, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      135854, -- [1]
      2, -- [2]
      1, -- [3]
      55094, -- [4]
    }, -- [57]
    {
      135864, -- [1]
      2, -- [2]
      4, -- [3]
      12571, -- [4]
    }, -- [58]
    {
      135838, -- [1]
      3, -- [2]
      2, -- [3]
      12472, -- [4]
    }, -- [59]
    {
      429385, -- [1]
      3, -- [2]
      1, -- [3]
      12487, -- [4]
    }, -- [60]
    {
      135837, -- [1]
      1, -- [2]
      1, -- [3]
      83050, -- [4]
    }, -- [61]
    {
      135865, -- [1]
      4, -- [2]
      2, -- [3]
      11958, -- [4]
    }, -- [62]
    {
      236227, -- [1]
      3, -- [2]
      3, -- [3]
      83074, -- [4]
    }, -- [63]
    {
      236209, -- [1]
      5, -- [2]
      1, -- [3]
      54787, -- [4]
    }, -- [64]
    {
      135988, -- [1]
      5, -- [2]
      2, -- [3]
      11426, -- [4]
    }, -- [65]
    {
      236206, -- [1]
      4, -- [2]
      3, -- [3]
      44549, -- [4]
    }, -- [66]
    {
      135833, -- [1]
      4, -- [2]
      1, -- [3]
      86508, -- [4]
    }, -- [67]
    {
      236214, -- [1]
      7, -- [2]
      2, -- [3]
      44572, -- [4]
    }, -- [68]
    {
      429386, -- [1]
      2, -- [2]
      3, -- [3]
      83157, -- [4]
    }, -- [69]
    {
      135845, -- [1]
      1, -- [2]
      2, -- [3]
      12953, -- [4]
    }, -- [70]
    {
      135849, -- [1]
      1, -- [2]
      3, -- [3]
      12982, -- [4]
    }, -- [71]
    {
      430840, -- [1]
      6, -- [2]
      3, -- [3]
      84727, -- [4]
    }, -- [72]
    {
      135852, -- [1]
      2, -- [2]
      2, -- [3]
      12489, -- [4]
    }, -- [73]
    {
      135861, -- [1]
      3, -- [2]
      4, -- [3]
      86314, -- [4]
    }, -- [74]
    {
      135859, -- [1]
      5, -- [2]
      3, -- [3]
      86304, -- [4]
    }, -- [75]
    [85] = {
      "MageArcane", -- [1]
      "MageFire", -- [2]
      "MageFrost", -- [3]
    },
  },
  ["PRIEST"] = {
    {
      135969, -- [1]
      1, -- [2]
      2, -- [3]
      47588, -- [4]
    }, -- [1]
    {
      135926, -- [1]
      2, -- [2]
      3, -- [3]
      14771, -- [4]
    }, -- [2]
    {
      135863, -- [1]
      3, -- [2]
      4, -- [3]
      89485, -- [4]
    }, -- [3]
    {
      135895, -- [1]
      2, -- [2]
      1, -- [3]
      81662, -- [4]
    }, -- [4]
    {
      132156, -- [1]
      1, -- [2]
      3, -- [3]
      14781, -- [4]
    }, -- [5]
    {
      253400, -- [1]
      7, -- [2]
      2, -- [3]
      62618, -- [4]
    }, -- [6]
    {
      458412, -- [1]
      4, -- [2]
      4, -- [3]
      33202, -- [4]
    }, -- [7]
    {
      458722, -- [1]
      2, -- [2]
      4, -- [3]
      78500, -- [4]
    }, -- [8]
    {
      237539, -- [1]
      5, -- [2]
      2, -- [3]
      47515, -- [4]
    }, -- [9]
    {
      135939, -- [1]
      3, -- [2]
      2, -- [3]
      10060, -- [4]
    }, -- [10]
    {
      237548, -- [1]
      4, -- [2]
      2, -- [3]
      47537, -- [4]
    }, -- [11]
    {
      458227, -- [1]
      6, -- [2]
      1, -- [3]
      45243, -- [4]
    }, -- [12]
    {
      135936, -- [1]
      5, -- [2]
      3, -- [3]
      33206, -- [4]
    }, -- [13]
    {
      237543, -- [1]
      6, -- [2]
      3, -- [3]
      47517, -- [4]
    }, -- [14]
    {
      135940, -- [1]
      1, -- [2]
      1, -- [3]
      14768, -- [4]
    }, -- [15]
    {
      135923, -- [1]
      3, -- [2]
      1, -- [3]
      57472, -- [4]
    }, -- [16]
    {
      237538, -- [1]
      4, -- [2]
      3, -- [3]
      52797, -- [4]
    }, -- [17]
    {
      458225, -- [1]
      2, -- [2]
      2, -- [3]
      87151, -- [4]
    }, -- [18]
    {
      458720, -- [1]
      3, -- [2]
      3, -- [3]
      81749, -- [4]
    }, -- [19]
    {
      135871, -- [1]
      5, -- [2]
      1, -- [3]
      89489, -- [4]
    }, -- [20]
    {
      236225, -- [1]
      5, -- [2]
      4, -- [3]
      92297, -- [4]
    }, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      135971, -- [1]
      1, -- [2]
      3, -- [3]
      18533, -- [4]
    }, -- [29]
    {
      135913, -- [1]
      1, -- [2]
      2, -- [3]
      33160, -- [4]
    }, -- [30]
    {
      135928, -- [1]
      2, -- [2]
      4, -- [3]
      15362, -- [4]
    }, -- [31]
    {
      237549, -- [1]
      4, -- [2]
      4, -- [3]
      63733, -- [4]
    }, -- [32]
    {
      135905, -- [1]
      3, -- [2]
      2, -- [3]
      34859, -- [4]
    }, -- [33]
    {
      135982, -- [1]
      5, -- [2]
      1, -- [3]
      64129, -- [4]
    }, -- [34]
    {
      236254, -- [1]
      3, -- [2]
      1, -- [3]
      63542, -- [4]
    }, -- [35]
    {
      135887, -- [1]
      6, -- [2]
      3, -- [3]
      34861, -- [4]
    }, -- [36]
    {
      237550, -- [1]
      6, -- [2]
      1, -- [3]
      47560, -- [4]
    }, -- [37]
    {
      237542, -- [1]
      7, -- [2]
      2, -- [3]
      47788, -- [4]
    }, -- [38]
    {
      135953, -- [1]
      1, -- [2]
      1, -- [3]
      15020, -- [4]
    }, -- [39]
    {
      135980, -- [1]
      3, -- [2]
      3, -- [3]
      724, -- [4]
    }, -- [40]
    {
      521584, -- [1]
      5, -- [2]
      2, -- [3]
      14751, -- [4]
    }, -- [41]
    {
      458228, -- [1]
      6, -- [2]
      2, -- [3]
      87431, -- [4]
    }, -- [42]
    {
      135954, -- [1]
      2, -- [2]
      2, -- [3]
      19236, -- [4]
    }, -- [43]
    {
      132864, -- [1]
      4, -- [2]
      3, -- [3]
      20711, -- [4]
    }, -- [44]
    {
      135878, -- [1]
      5, -- [2]
      4, -- [3]
      33145, -- [4]
    }, -- [45]
    {
      458721, -- [1]
      5, -- [2]
      3, -- [3]
      88627, -- [4]
    }, -- [46]
    {
      135981, -- [1]
      2, -- [2]
      3, -- [3]
      88690, -- [4]
    }, -- [47]
    {
      133739, -- [1]
      3, -- [2]
      4, -- [3]
      81625, -- [4]
    }, -- [48]
    {
      236249, -- [1]
      4, -- [2]
      1, -- [3]
      95649, -- [4]
    }, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      458226, -- [1]
      1, -- [2]
      1, -- [3]
      15308, -- [4]
    }, -- [57]
    {
      136207, -- [1]
      1, -- [2]
      2, -- [3]
      15317, -- [4]
    }, -- [58]
    {
      136184, -- [1]
      2, -- [2]
      1, -- [3]
      15448, -- [4]
    }, -- [59]
    {
      136224, -- [1]
      2, -- [2]
      2, -- [3]
      15313, -- [4]
    }, -- [60]
    {
      135994, -- [1]
      1, -- [2]
      3, -- [3]
      15311, -- [4]
    }, -- [61]
    {
      458230, -- [1]
      4, -- [2]
      1, -- [3]
      15487, -- [4]
    }, -- [62]
    {
      136230, -- [1]
      4, -- [2]
      2, -- [3]
      15286, -- [4]
    }, -- [63]
    {
      237569, -- [1]
      4, -- [2]
      4, -- [3]
      33371, -- [4]
    }, -- [64]
    {
      252996, -- [1]
      2, -- [2]
      3, -- [3]
      63626, -- [4]
    }, -- [65]
    {
      136200, -- [1]
      3, -- [2]
      2, -- [3]
      15473, -- [4]
    }, -- [66]
    {
      237570, -- [1]
      3, -- [2]
      3, -- [3]
      47570, -- [4]
    }, -- [67]
    {
      458229, -- [1]
      6, -- [2]
      3, -- [3]
      78204, -- [4]
    }, -- [68]
    {
      237568, -- [1]
      6, -- [2]
      1, -- [3]
      64044, -- [4]
    }, -- [69]
    {
      135978, -- [1]
      5, -- [2]
      2, -- [3]
      34914, -- [4]
    }, -- [70]
    {
      237567, -- [1]
      5, -- [2]
      1, -- [3]
      47581, -- [4]
    }, -- [71]
    {
      237563, -- [1]
      7, -- [2]
      2, -- [3]
      47585, -- [4]
    }, -- [72]
    {
      135945, -- [1]
      6, -- [2]
      2, -- [3]
      87100, -- [4]
    }, -- [73]
    {
      134336, -- [1]
      3, -- [2]
      4, -- [3]
      78228, -- [4]
    }, -- [74]
    {
      132299, -- [1]
      5, -- [2]
      3, -- [3]
      87195, -- [4]
    }, -- [75]
    {
      237566, -- [1]
      2, -- [2]
      4, -- [3]
      47577, -- [4]
    }, -- [76]
    {
      136176, -- [1]
      4, -- [2]
      3, -- [3]
      88995, -- [4]
    }, -- [77]
    [85] = {
      "PriestDiscipline", -- [1]
      "PriestHoly", -- [2]
      "PriestShadow", -- [3]
    },
  },
  ["WARLOCK"] = {
    {
      136139, -- [1]
      1, -- [2]
      1, -- [3]
      18829, -- [4]
    }, -- [1]
    {
      136118, -- [1]
      1, -- [2]
      3, -- [3]
      17812, -- [4]
    }, -- [2]
    {
      136126, -- [1]
      1, -- [2]
      2, -- [3]
      18183, -- [4]
    }, -- [3]
    {
      460700, -- [1]
      2, -- [2]
      2, -- [3]
      17805, -- [4]
    }, -- [4]
    {
      136183, -- [1]
      3, -- [2]
      3, -- [3]
      53759, -- [4]
    }, -- [5]
    {
      136223, -- [1]
      5, -- [2]
      2, -- [3]
      18095, -- [4]
    }, -- [6]
    {
      136198, -- [1]
      4, -- [2]
      3, -- [3]
      32392, -- [4]
    }, -- [7]
    {
      136162, -- [1]
      3, -- [2]
      1, -- [3]
      18223, -- [4]
    }, -- [8]
    {
      236295, -- [1]
      3, -- [2]
      4, -- [3]
      47197, -- [4]
    }, -- [9]
    {
      136147, -- [1]
      4, -- [2]
      1, -- [3]
      30057, -- [4]
    }, -- [10]
    {
      237557, -- [1]
      5, -- [2]
      1, -- [3]
      47200, -- [4]
    }, -- [11]
    {
      236296, -- [1]
      6, -- [2]
      2, -- [3]
      47203, -- [4]
    }, -- [12]
    {
      236298, -- [1]
      7, -- [2]
      2, -- [3]
      48181, -- [4]
    }, -- [13]
    {
      136166, -- [1]
      6, -- [2]
      3, -- [3]
      85100, -- [4]
    }, -- [14]
    {
      460699, -- [1]
      2, -- [2]
      1, -- [3]
      85479, -- [4]
    }, -- [15]
    {
      460857, -- [1]
      4, -- [2]
      2, -- [3]
      86121, -- [4]
    }, -- [16]
    {
      136193, -- [1]
      5, -- [2]
      3, -- [3]
      86664, -- [4]
    }, -- [17]
    {
      136188, -- [1]
      2, -- [2]
      3, -- [3]
      86667, -- [4]
    }, -- [18]
    nil, -- [19]
    nil, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      460697, -- [1]
      1, -- [2]
      2, -- [3]
      85284, -- [4]
    }, -- [29]
    {
      136172, -- [1]
      1, -- [2]
      1, -- [3]
      18699, -- [4]
    }, -- [30]
    {
      136168, -- [1]
      3, -- [2]
      3, -- [3]
      18704, -- [4]
    }, -- [31]
    {
      136164, -- [1]
      2, -- [2]
      4, -- [3]
      18710, -- [4]
    }, -- [32]
    {
      136171, -- [1]
      2, -- [2]
      2, -- [3]
      85175, -- [4]
    }, -- [33]
    {
      236301, -- [1]
      4, -- [2]
      1, -- [3]
      47247, -- [4]
    }, -- [34]
    {
      135808, -- [1]
      5, -- [2]
      3, -- [3]
      63158, -- [4]
    }, -- [35]
    {
      237562, -- [1]
      6, -- [2]
      3, -- [3]
      47236, -- [4]
    }, -- [36]
    {
      237558, -- [1]
      7, -- [2]
      2, -- [3]
      59672, -- [4]
    }, -- [37]
    {
      236292, -- [1]
      3, -- [2]
      2, -- [3]
      47193, -- [4]
    }, -- [38]
    {
      460694, -- [1]
      5, -- [2]
      1, -- [3]
      85110, -- [4]
    }, -- [39]
    {
      460698, -- [1]
      5, -- [2]
      2, -- [3]
      85105, -- [4]
    }, -- [40]
    {
      136185, -- [1]
      2, -- [2]
      3, -- [3]
      30144, -- [4]
    }, -- [41]
    {
      136082, -- [1]
      3, -- [2]
      1, -- [3]
      85108, -- [4]
    }, -- [42]
    {
      460696, -- [1]
      6, -- [2]
      2, -- [3]
      85104, -- [4]
    }, -- [43]
    {
      135265, -- [1]
      4, -- [2]
      2, -- [3]
      71521, -- [4]
    }, -- [44]
    {
      237564, -- [1]
      1, -- [2]
      3, -- [3]
      47231, -- [4]
    }, -- [45]
    {
      136150, -- [1]
      2, -- [2]
      1, -- [3]
      88447, -- [4]
    }, -- [46]
    {
      136192, -- [1]
      4, -- [2]
      3, -- [3]
      89605, -- [4]
    }, -- [47]
    nil, -- [48]
    nil, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      136196, -- [1]
      1, -- [2]
      2, -- [3]
      17801, -- [4]
    }, -- [57]
    {
      136146, -- [1]
      1, -- [2]
      1, -- [3]
      17790, -- [4]
    }, -- [58]
    {
      135808, -- [1]
      3, -- [2]
      1, -- [3]
      18120, -- [4]
    }, -- [59]
    {
      136191, -- [1]
      3, -- [2]
      3, -- [3]
      17877, -- [4]
    }, -- [60]
    {
      135823, -- [1]
      4, -- [2]
      3, -- [3]
      34939, -- [4]
    }, -- [61]
    {
      135817, -- [1]
      1, -- [2]
      3, -- [3]
      17833, -- [4]
    }, -- [62]
    {
      460695, -- [1]
      6, -- [2]
      3, -- [3]
      80240, -- [4]
    }, -- [63]
    {
      136178, -- [1]
      5, -- [2]
      4, -- [3]
      30301, -- [4]
    }, -- [64]
    {
      136214, -- [1]
      4, -- [2]
      2, -- [3]
      30295, -- [4]
    }, -- [65]
    {
      236290, -- [1]
      3, -- [2]
      2, -- [3]
      47260, -- [4]
    }, -- [66]
    {
      136201, -- [1]
      5, -- [2]
      3, -- [3]
      30283, -- [4]
    }, -- [67]
    {
      236294, -- [1]
      6, -- [2]
      1, -- [3]
      47221, -- [4]
    }, -- [68]
    {
      236297, -- [1]
      5, -- [2]
      2, -- [3]
      47268, -- [4]
    }, -- [69]
    {
      236291, -- [1]
      7, -- [2]
      2, -- [3]
      50796, -- [4]
    }, -- [70]
    {
      135826, -- [1]
      2, -- [2]
      2, -- [3]
      17955, -- [4]
    }, -- [71]
    {
      460952, -- [1]
      4, -- [2]
      1, -- [3]
      85112, -- [4]
    }, -- [72]
    {
      135827, -- [1]
      2, -- [2]
      3, -- [3]
      17929, -- [4]
    }, -- [73]
    {
      135805, -- [1]
      2, -- [2]
      1, -- [3]
      85114, -- [4]
    }, -- [74]
    {
      135796, -- [1]
      4, -- [2]
      4, -- [3]
      91713, -- [4]
    }, -- [75]
    [85] = {
      "WarlockCurses", -- [1]
      "WarlockSummoning", -- [2]
      "WarlockDestruction", -- [3]
    },
  },
  ["ROGUE"] = {
    {
      132109, -- [1]
      1, -- [2]
      3, -- [3]
      14135, -- [4]
    }, -- [1]
    {
      132122, -- [1]
      2, -- [2]
      1, -- [3]
      14161, -- [4]
    }, -- [2]
    {
      132292, -- [1]
      1, -- [2]
      2, -- [3]
      14164, -- [4]
    }, -- [3]
    {
      132090, -- [1]
      2, -- [2]
      3, -- [3]
      13866, -- [4]
    }, -- [4]
    {
      132354, -- [1]
      5, -- [2]
      4, -- [3]
      14169, -- [4]
    }, -- [5]
    {
      135988, -- [1]
      3, -- [2]
      2, -- [3]
      14177, -- [4]
    }, -- [6]
    {
      132205, -- [1]
      5, -- [2]
      2, -- [3]
      58426, -- [4]
    }, -- [7]
    {
      236281, -- [1]
      4, -- [2]
      2, -- [3]
      14190, -- [4]
    }, -- [8]
    {
      132293, -- [1]
      3, -- [2]
      3, -- [3]
      16515, -- [4]
    }, -- [9]
    {
      132108, -- [1]
      5, -- [2]
      3, -- [3]
      58410, -- [4]
    }, -- [10]
    {
      132301, -- [1]
      2, -- [2]
      2, -- [3]
      31209, -- [4]
    }, -- [11]
    {
      236270, -- [1]
      3, -- [2]
      1, -- [3]
      51626, -- [4]
    }, -- [12]
    {
      236269, -- [1]
      6, -- [2]
      2, -- [3]
      51667, -- [4]
    }, -- [13]
    {
      458726, -- [1]
      7, -- [2]
      2, -- [3]
      79140, -- [4]
    }, -- [14]
    {
      458727, -- [1]
      1, -- [2]
      1, -- [3]
      79122, -- [4]
    }, -- [15]
    {
      458797, -- [1]
      2, -- [2]
      4, -- [3]
      79125, -- [4]
    }, -- [16]
    {
      136147, -- [1]
      5, -- [2]
      1, -- [3]
      14159, -- [4]
    }, -- [17]
    {
      458736, -- [1]
      6, -- [2]
      3, -- [3]
      79134, -- [4]
    }, -- [18]
    {
      132286, -- [1]
      4, -- [2]
      1, -- [3]
      31383, -- [4]
    }, -- [19]
    nil, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      132222, -- [1]
      1, -- [2]
      3, -- [3]
      13843, -- [4]
    }, -- [29]
    {
      136047, -- [1]
      3, -- [2]
      1, -- [3]
      13789, -- [4]
    }, -- [30]
    {
      136189, -- [1]
      1, -- [2]
      2, -- [3]
      79004, -- [4]
    }, -- [31]
    {
      132155, -- [1]
      3, -- [2]
      4, -- [3]
      13793, -- [4]
    }, -- [32]
    {
      136206, -- [1]
      5, -- [2]
      2, -- [3]
      13750, -- [4]
    }, -- [33]
    {
      132219, -- [1]
      2, -- [2]
      4, -- [3]
      13867, -- [4]
    }, -- [34]
    {
      132307, -- [1]
      2, -- [2]
      2, -- [3]
      13875, -- [4]
    }, -- [35]
    {
      132275, -- [1]
      2, -- [2]
      3, -- [3]
      18429, -- [4]
    }, -- [36]
    {
      132283, -- [1]
      4, -- [2]
      3, -- [3]
      31126, -- [4]
    }, -- [37]
    {
      135673, -- [1]
      4, -- [2]
      2, -- [3]
      35551, -- [4]
    }, -- [38]
    {
      132306, -- [1]
      2, -- [2]
      1, -- [3]
      14166, -- [4]
    }, -- [39]
    {
      236282, -- [1]
      5, -- [2]
      1, -- [3]
      51679, -- [4]
    }, -- [40]
    {
      132100, -- [1]
      5, -- [2]
      3, -- [3]
      58413, -- [4]
    }, -- [41]
    {
      236277, -- [1]
      7, -- [2]
      2, -- [3]
      51690, -- [4]
    }, -- [42]
    {
      457635, -- [1]
      1, -- [2]
      1, -- [3]
      79008, -- [4]
    }, -- [43]
    {
      458730, -- [1]
      3, -- [2]
      3, -- [3]
      79079, -- [4]
    }, -- [44]
    {
      458731, -- [1]
      6, -- [2]
      3, -- [3]
      79096, -- [4]
    }, -- [45]
    {
      135407, -- [1]
      3, -- [2]
      2, -- [3]
      84617, -- [4]
    }, -- [46]
    {
      236278, -- [1]
      6, -- [2]
      1, -- [3]
      84654, -- [4]
    }, -- [47]
    nil, -- [48]
    nil, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      132320, -- [1]
      1, -- [2]
      1, -- [3]
      14062, -- [4]
    }, -- [57]
    {
      136159, -- [1]
      2, -- [2]
      4, -- [3]
      13979, -- [4]
    }, -- [58]
    {
      135994, -- [1]
      2, -- [2]
      1, -- [3]
      14066, -- [4]
    }, -- [59]
    {
      236268, -- [1]
      2, -- [2]
      3, -- [3]
      79141, -- [4]
    }, -- [60]
    {
      132282, -- [1]
      1, -- [2]
      2, -- [3]
      84661, -- [4]
    }, -- [61]
    {
      460693, -- [1]
      5, -- [2]
      2, -- [3]
      14185, -- [4]
    }, -- [62]
    {
      136183, -- [1]
      4, -- [2]
      2, -- [3]
      14183, -- [4]
    }, -- [63]
    {
      136168, -- [1]
      3, -- [2]
      3, -- [3]
      16511, -- [4]
    }, -- [64]
    {
      135315, -- [1]
      6, -- [2]
      3, -- [3]
      14172, -- [4]
    }, -- [65]
    {
      132285, -- [1]
      5, -- [2]
      1, -- [3]
      31230, -- [4]
    }, -- [66]
    {
      236286, -- [1]
      2, -- [2]
      2, -- [3]
      51696, -- [4]
    }, -- [67]
    {
      236275, -- [1]
      4, -- [2]
      1, -- [3]
      51701, -- [4]
    }, -- [68]
    {
      236280, -- [1]
      6, -- [2]
      2, -- [3]
      51710, -- [4]
    }, -- [69]
    {
      236279, -- [1]
      7, -- [2]
      2, -- [3]
      51713, -- [4]
    }, -- [70]
    {
      132340, -- [1]
      1, -- [2]
      3, -- [3]
      58423, -- [4]
    }, -- [71]
    {
      132295, -- [1]
      3, -- [2]
      2, -- [3]
      91023, -- [4]
    }, -- [72]
    {
      457636, -- [1]
      5, -- [2]
      3, -- [3]
      79147, -- [4]
    }, -- [73]
    {
      132291, -- [1]
      4, -- [2]
      4, -- [3]
      31213, -- [4]
    }, -- [74]
    {
      458734, -- [1]
      3, -- [2]
      1, -- [3]
      79152, -- [4]
    }, -- [75]
    [85] = {
      "RogueAssassination", -- [1]
      "RogueCombat", -- [2]
      "RogueSubtlety", -- [3]
    },
  },
  ["DRUID"] = {
    {
      136006, -- [1]
      1, -- [2]
      2, -- [3]
      16816, -- [4]
    }, -- [1]
    {
      136087, -- [1]
      2, -- [2]
      2, -- [3]
      16847, -- [4]
    }, -- [2]
    {
      136062, -- [1]
      1, -- [2]
      1, -- [3]
      61346, -- [4]
    }, -- [3]
    {
      252188, -- [1]
      4, -- [2]
      4, -- [3]
      78675, -- [4]
    }, -- [4]
    {
      236154, -- [1]
      4, -- [2]
      3, -- [3]
      48514, -- [4]
    }, -- [5]
    {
      236205, -- [1]
      3, -- [2]
      4, -- [3]
      93399, -- [4]
    }, -- [6]
    {
      132113, -- [1]
      2, -- [2]
      3, -- [3]
      33596, -- [4]
    }, -- [7]
    {
      341763, -- [1]
      3, -- [2]
      1, -- [3]
      81062, -- [4]
    }, -- [8]
    {
      236163, -- [1]
      4, -- [2]
      2, -- [3]
      48393, -- [4]
    }, -- [9]
    {
      236704, -- [1]
      6, -- [2]
      3, -- [3]
      33605, -- [4]
    }, -- [10]
    {
      132129, -- [1]
      5, -- [2]
      2, -- [3]
      33831, -- [4]
    }, -- [11]
    {
      132371, -- [1]
      6, -- [2]
      2, -- [3]
      78789, -- [4]
    }, -- [12]
    {
      236168, -- [1]
      7, -- [2]
      2, -- [3]
      48505, -- [4]
    }, -- [13]
    {
      236150, -- [1]
      5, -- [2]
      4, -- [3]
      48506, -- [4]
    }, -- [14]
    {
      136036, -- [1]
      3, -- [2]
      2, -- [3]
      24858, -- [4]
    }, -- [15]
    {
      135138, -- [1]
      1, -- [2]
      3, -- [3]
      35364, -- [4]
    }, -- [16]
    {
      236170, -- [1]
      3, -- [2]
      3, -- [3]
      50516, -- [4]
    }, -- [17]
    {
      135730, -- [1]
      2, -- [2]
      1, -- [3]
      57812, -- [4]
    }, -- [18]
    {
      132123, -- [1]
      5, -- [2]
      1, -- [3]
      33599, -- [4]
    }, -- [19]
    {
      236216, -- [1]
      5, -- [2]
      3, -- [3]
      93401, -- [4]
    }, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      134355, -- [1]
      3, -- [2]
      4, -- [3]
      16931, -- [4]
    }, -- [29]
    {
      136095, -- [1]
      1, -- [2]
      1, -- [3]
      24866, -- [4]
    }, -- [30]
    {
      132183, -- [1]
      3, -- [2]
      2, -- [3]
      49377, -- [4]
    }, -- [31]
    {
      304501, -- [1]
      3, -- [2]
      3, -- [3]
      78893, -- [4]
    }, -- [32]
    {
      132130, -- [1]
      4, -- [2]
      4, -- [3]
      33873, -- [4]
    }, -- [33]
    {
      132134, -- [1]
      2, -- [2]
      2, -- [3]
      80553, -- [4]
    }, -- [34]
    {
      132114, -- [1]
      4, -- [2]
      3, -- [3]
      16941, -- [4]
    }, -- [35]
    {
      236169, -- [1]
      5, -- [2]
      2, -- [3]
      61336, -- [4]
    }, -- [36]
    {
      132318, -- [1]
      6, -- [2]
      3, -- [3]
      80313, -- [4]
    }, -- [37]
    {
      236159, -- [1]
      3, -- [2]
      1, -- [3]
      48495, -- [4]
    }, -- [38]
    {
      136112, -- [1]
      4, -- [2]
      2, -- [3]
      17007, -- [4]
    }, -- [39]
    {
      132242, -- [1]
      5, -- [2]
      1, -- [3]
      80317, -- [4]
    }, -- [40]
    {
      237347, -- [1]
      6, -- [2]
      1, -- [3]
      80319, -- [4]
    }, -- [41]
    {
      236164, -- [1]
      6, -- [2]
      2, -- [3]
      48434, -- [4]
    }, -- [42]
    {
      236149, -- [1]
      7, -- [2]
      2, -- [3]
      50334, -- [4]
    }, -- [43]
    {
      132091, -- [1]
      5, -- [2]
      4, -- [3]
      57880, -- [4]
    }, -- [44]
    {
      237513, -- [1]
      5, -- [2]
      3, -- [3]
      80315, -- [4]
    }, -- [45]
    {
      236158, -- [1]
      2, -- [2]
      1, -- [3]
      48484, -- [4]
    }, -- [46]
    {
      132278, -- [1]
      2, -- [2]
      3, -- [3]
      37117, -- [4]
    }, -- [47]
    {
      132185, -- [1]
      1, -- [2]
      3, -- [3]
      16974, -- [4]
    }, -- [48]
    {
      132121, -- [1]
      2, -- [2]
      4, -- [3]
      16859, -- [4]
    }, -- [49]
    {
      135881, -- [1]
      1, -- [2]
      2, -- [3]
      17059, -- [4]
    }, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      237586, -- [1]
      1, -- [2]
      1, -- [3]
      78785, -- [4]
    }, -- [57]
    {
      136116, -- [1]
      1, -- [2]
      2, -- [3]
      16834, -- [4]
    }, -- [58]
    {
      136081, -- [1]
      2, -- [2]
      3, -- [3]
      17113, -- [4]
    }, -- [59]
    {
      136076, -- [1]
      3, -- [2]
      3, -- [3]
      17116, -- [4]
    }, -- [60]
    {
      236155, -- [1]
      3, -- [2]
      1, -- [3]
      48500, -- [4]
    }, -- [61]
    {
      136085, -- [1]
      4, -- [2]
      2, -- [3]
      17076, -- [4]
    }, -- [62]
    {
      134222, -- [1]
      5, -- [2]
      1, -- [3]
      81275, -- [4]
    }, -- [63]
    {
      132124, -- [1]
      6, -- [2]
      3, -- [3]
      33886, -- [4]
    }, -- [64]
    {
      132137, -- [1]
      5, -- [2]
      4, -- [3]
      33882, -- [4]
    }, -- [65]
    {
      236166, -- [1]
      3, -- [2]
      2, -- [3]
      48544, -- [4]
    }, -- [66]
    {
      132145, -- [1]
      7, -- [2]
      2, -- [3]
      33891, -- [4]
    }, -- [67]
    {
      236161, -- [1]
      2, -- [2]
      2, -- [3]
      48411, -- [4]
    }, -- [68]
    {
      236153, -- [1]
      5, -- [2]
      2, -- [3]
      48438, -- [4]
    }, -- [69]
    {
      132125, -- [1]
      4, -- [2]
      3, -- [3]
      33880, -- [4]
    }, -- [70]
    {
      236288, -- [1]
      5, -- [2]
      3, -- [3]
      88423, -- [4]
    }, -- [71]
    {
      236740, -- [1]
      2, -- [2]
      1, -- [3]
      78736, -- [4]
    }, -- [72]
    {
      236160, -- [1]
      6, -- [2]
      1, -- [3]
      51181, -- [4]
    }, -- [73]
    {
      136041, -- [1]
      1, -- [2]
      3, -- [3]
      17070, -- [4]
    }, -- [74]
    {
      237472, -- [1]
      3, -- [2]
      4, -- [3]
      24943, -- [4]
    }, -- [75]
    {
      135879, -- [1]
      1, -- [2]
      4, -- [3]
      17005, -- [4]
    }, -- [76]
    {
      237578, -- [1]
      4, -- [2]
      4, -- [3]
      92364, -- [4]
    }, -- [77]
    [85] = {
      "DruidBalance", -- [1]
      "DruidFeralCombat", -- [2]
      "DruidRestoration", -- [3]
    },
  },
  ["SHAMAN"] = {
    {
      135817, -- [1]
      2, -- [2]
      1, -- [3]
      16160, -- [4]
    }, -- [1]
    {
      135807, -- [1]
      1, -- [2]
      3, -- [3]
      16106, -- [4]
    }, -- [2]
    {
      459025, -- [1]
      1, -- [2]
      2, -- [3]
      16109, -- [4]
    }, -- [3]
    {
      136115, -- [1]
      5, -- [2]
      2, -- [3]
      16166, -- [4]
    }, -- [4]
    {
      136170, -- [1]
      3, -- [2]
      2, -- [3]
      16164, -- [4]
    }, -- [5]
    {
      135850, -- [1]
      2, -- [2]
      3, -- [3]
      16113, -- [4]
    }, -- [6]
    {
      136094, -- [1]
      2, -- [2]
      2, -- [3]
      28998, -- [4]
    }, -- [7]
    {
      136099, -- [1]
      3, -- [2]
      3, -- [3]
      29000, -- [4]
    }, -- [8]
    {
      136028, -- [1]
      2, -- [2]
      4, -- [3]
      30674, -- [4]
    }, -- [9]
    {
      451165, -- [1]
      7, -- [2]
      2, -- [3]
      61882, -- [4]
    }, -- [10]
    {
      237576, -- [1]
      4, -- [2]
      2, -- [3]
      51470, -- [4]
    }, -- [11]
    {
      237583, -- [1]
      4, -- [2]
      3, -- [3]
      51482, -- [4]
    }, -- [12]
    {
      135829, -- [1]
      5, -- [2]
      4, -- [3]
      77746, -- [4]
    }, -- [13]
    {
      451169, -- [1]
      6, -- [2]
      3, -- [3]
      77756, -- [4]
    }, -- [14]
    {
      136011, -- [1]
      1, -- [2]
      1, -- [3]
      17487, -- [4]
    }, -- [15]
    {
      252174, -- [1]
      6, -- [2]
      2, -- [3]
      86185, -- [4]
    }, -- [16]
    {
      136014, -- [1]
      3, -- [2]
      1, -- [3]
      88764, -- [4]
    }, -- [17]
    {
      136100, -- [1]
      5, -- [2]
      3, -- [3]
      51485, -- [4]
    }, -- [18]
    {
      136111, -- [1]
      5, -- [2]
      1, -- [3]
      88766, -- [4]
    }, -- [19]
    nil, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      132152, -- [1]
      2, -- [2]
      2, -- [3]
      16282, -- [4]
    }, -- [29]
    {
      348567, -- [1]
      2, -- [2]
      3, -- [3]
      16287, -- [4]
    }, -- [30]
    {
      136051, -- [1]
      1, -- [2]
      3, -- [3]
      51881, -- [4]
    }, -- [31]
    {
      135814, -- [1]
      1, -- [2]
      1, -- [3]
      29079, -- [4]
    }, -- [32]
    {
      135892, -- [1]
      3, -- [2]
      1, -- [3]
      16307, -- [4]
    }, -- [33]
    {
      132314, -- [1]
      3, -- [2]
      2, -- [3]
      17364, -- [4]
    }, -- [34]
    {
      136110, -- [1]
      5, -- [2]
      4, -- [3]
      30808, -- [4]
    }, -- [35]
    {
      136088, -- [1]
      5, -- [2]
      2, -- [3]
      30823, -- [4]
    }, -- [36]
    {
      237587, -- [1]
      3, -- [2]
      3, -- [3]
      51527, -- [4]
    }, -- [37]
    {
      136024, -- [1]
      5, -- [2]
      1, -- [3]
      51524, -- [4]
    }, -- [38]
    {
      237584, -- [1]
      6, -- [2]
      2, -- [3]
      51530, -- [4]
    }, -- [39]
    {
      237577, -- [1]
      7, -- [2]
      2, -- [3]
      51533, -- [4]
    }, -- [40]
    {
      135825, -- [1]
      4, -- [2]
      3, -- [3]
      77657, -- [4]
    }, -- [41]
    {
      451166, -- [1]
      1, -- [2]
      2, -- [3]
      77538, -- [4]
    }, -- [42]
    {
      451168, -- [1]
      6, -- [2]
      3, -- [3]
      77701, -- [4]
    }, -- [43]
    {
      135791, -- [1]
      2, -- [2]
      1, -- [3]
      29180, -- [4]
    }, -- [44]
    {
      135776, -- [1]
      4, -- [2]
      1, -- [3]
      63374, -- [4]
    }, -- [45]
    {
      136008, -- [1]
      2, -- [2]
      4, -- [3]
      86936, -- [4]
    }, -- [46]
    {
      136027, -- [1]
      4, -- [2]
      2, -- [3]
      16544, -- [4]
    }, -- [47]
    nil, -- [48]
    nil, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      136109, -- [1]
      3, -- [2]
      1, -- [3]
      16235, -- [4]
    }, -- [57]
    {
      132315, -- [1]
      2, -- [2]
      1, -- [3]
      16196, -- [4]
    }, -- [58]
    {
      136037, -- [1]
      4, -- [2]
      2, -- [3]
      16205, -- [4]
    }, -- [59]
    {
      135861, -- [1]
      5, -- [2]
      2, -- [3]
      16190, -- [4]
    }, -- [60]
    {
      136076, -- [1]
      3, -- [2]
      2, -- [3]
      16188, -- [4]
    }, -- [61]
    {
      135859, -- [1]
      1, -- [2]
      2, -- [3]
      16215, -- [4]
    }, -- [62]
    {
      136057, -- [1]
      2, -- [2]
      2, -- [3]
      16222, -- [4]
    }, -- [63]
    {
      136059, -- [1]
      3, -- [2]
      3, -- [3]
      30869, -- [4]
    }, -- [64]
    {
      136060, -- [1]
      2, -- [2]
      4, -- [3]
      30884, -- [4]
    }, -- [65]
    {
      237573, -- [1]
      6, -- [2]
      3, -- [3]
      51555, -- [4]
    }, -- [66]
    {
      237571, -- [1]
      5, -- [2]
      1, -- [3]
      51558, -- [4]
    }, -- [67]
    {
      237590, -- [1]
      6, -- [2]
      2, -- [3]
      51564, -- [4]
    }, -- [68]
    {
      252995, -- [1]
      7, -- [2]
      2, -- [3]
      61295, -- [4]
    }, -- [69]
    {
      236288, -- [1]
      4, -- [2]
      3, -- [3]
      77130, -- [4]
    }, -- [70]
    {
      462651, -- [1]
      2, -- [2]
      3, -- [3]
      77796, -- [4]
    }, -- [71]
    {
      252271, -- [1]
      1, -- [2]
      1, -- [3]
      77830, -- [4]
    }, -- [72]
    {
      135990, -- [1]
      5, -- [2]
      3, -- [3]
      82988, -- [4]
    }, -- [73]
    {
      237556, -- [1]
      1, -- [2]
      3, -- [3]
      84848, -- [4]
    }, -- [74]
    {
      136079, -- [1]
      4, -- [2]
      4, -- [3]
      86962, -- [4]
    }, -- [75]
    {
      237586, -- [1]
      5, -- [2]
      4, -- [3]
      98008, -- [4]
    }, -- [76]
    [85] = {
      "ShamanElementalCombat", -- [1]
      "ShamanEnhancement", -- [2]
      "ShamanRestoration", -- [3]
    },
  },
  ["HUNTER"] = {
    {
      461117, -- [1]
      1, -- [2]
      2, -- [3]
      82684, -- [4]
    }, -- [1]
    {
      461112, -- [1]
      1, -- [2]
      3, -- [3]
      82687, -- [4]
    }, -- [2]
    {
      132210, -- [1]
      1, -- [2]
      1, -- [3]
      35030, -- [4]
    }, -- [3]
    {
      461118, -- [1]
      2, -- [2]
      1, -- [3]
      19560, -- [4]
    }, -- [4]
    {
      132160, -- [1]
      3, -- [2]
      2, -- [3]
      82726, -- [4]
    }, -- [5]
    {
      132179, -- [1]
      2, -- [2]
      4, -- [3]
      19573, -- [4]
    }, -- [6]
    {
      134296, -- [1]
      2, -- [2]
      3, -- [3]
      19623, -- [4]
    }, -- [7]
    {
      132121, -- [1]
      2, -- [2]
      2, -- [3]
      20895, -- [4]
    }, -- [8]
    {
      132173, -- [1]
      5, -- [2]
      3, -- [3]
      34460, -- [4]
    }, -- [9]
    {
      461846, -- [1]
      3, -- [2]
      3, -- [3]
      82692, -- [4]
    }, -- [10]
    {
      236184, -- [1]
      6, -- [2]
      3, -- [3]
      53253, -- [4]
    }, -- [11]
    {
      132127, -- [1]
      5, -- [2]
      2, -- [3]
      19574, -- [4]
    }, -- [12]
    {
      236357, -- [1]
      4, -- [2]
      3, -- [3]
      82749, -- [4]
    }, -- [13]
    {
      236177, -- [1]
      3, -- [2]
      1, -- [3]
      53260, -- [4]
    }, -- [14]
    {
      236186, -- [1]
      4, -- [2]
      1, -- [3]
      53264, -- [4]
    }, -- [15]
    {
      132166, -- [1]
      6, -- [2]
      2, -- [3]
      34692, -- [4]
    }, -- [16]
    {
      236202, -- [1]
      6, -- [2]
      1, -- [3]
      56315, -- [4]
    }, -- [17]
    {
      236175, -- [1]
      7, -- [2]
      2, -- [3]
      53270, -- [4]
    }, -- [18]
    {
      236190, -- [1]
      5, -- [2]
      1, -- [3]
      82899, -- [4]
    }, -- [19]
    nil, -- [20]
    nil, -- [21]
    nil, -- [22]
    nil, -- [23]
    nil, -- [24]
    nil, -- [25]
    nil, -- [26]
    nil, -- [27]
    nil, -- [28]
    {
      132205, -- [1]
      1, -- [2]
      3, -- [3]
      34949, -- [4]
    }, -- [29]
    {
      236179, -- [1]
      1, -- [2]
      2, -- [3]
      19418, -- [4]
    }, -- [30]
    {
      132174, -- [1]
      1, -- [2]
      1, -- [3]
      34954, -- [4]
    }, -- [31]
    {
      461121, -- [1]
      2, -- [2]
      1, -- [3]
      83356, -- [4]
    }, -- [32]
    {
      132217, -- [1]
      2, -- [2]
      3, -- [3]
      34483, -- [4]
    }, -- [33]
    {
      236182, -- [1]
      2, -- [2]
      2, -- [3]
      53224, -- [4]
    }, -- [34]
    {
      132206, -- [1]
      5, -- [2]
      4, -- [3]
      23989, -- [4]
    }, -- [35]
    {
      461115, -- [1]
      3, -- [2]
      2, -- [3]
      35102, -- [4]
    }, -- [36]
    {
      132222, -- [1]
      4, -- [2]
      1, -- [3]
      35110, -- [4]
    }, -- [37]
    {
      132329, -- [1]
      4, -- [2]
      2, -- [3]
      19506, -- [4]
    }, -- [38]
    {
      132345, -- [1]
      4, -- [2]
      3, -- [3]
      83490, -- [4]
    }, -- [39]
    {
      132177, -- [1]
      5, -- [2]
      2, -- [3]
      34487, -- [4]
    }, -- [40]
    {
      461120, -- [1]
      4, -- [2]
      4, -- [3]
      82894, -- [4]
    }, -- [41]
    {
      236201, -- [1]
      5, -- [2]
      1, -- [3]
      53232, -- [4]
    }, -- [42]
    {
      132323, -- [1]
      3, -- [2]
      1, -- [3]
      34490, -- [4]
    }, -- [43]
    {
      461119, -- [1]
      6, -- [2]
      1, -- [3]
      83560, -- [4]
    }, -- [44]
    {
      236173, -- [1]
      6, -- [2]
      3, -- [3]
      53243, -- [4]
    }, -- [45]
    {
      236176, -- [1]
      7, -- [2]
      2, -- [3]
      53209, -- [4]
    }, -- [46]
    {
      236198, -- [1]
      3, -- [2]
      3, -- [3]
      53238, -- [4]
    }, -- [47]
    nil, -- [48]
    nil, -- [49]
    nil, -- [50]
    nil, -- [51]
    nil, -- [52]
    nil, -- [53]
    nil, -- [54]
    nil, -- [55]
    nil, -- [56]
    {
      236183, -- [1]
      1, -- [2]
      2, -- [3]
      52786, -- [4]
    }, -- [57]
    {
      136100, -- [1]
      2, -- [2]
      3, -- [3]
      19387, -- [4]
    }, -- [58]
    {
      236180, -- [1]
      1, -- [2]
      1, -- [3]
      56341, -- [4]
    }, -- [59]
    {
      132293, -- [1]
      2, -- [2]
      1, -- [3]
      19287, -- [4]
    }, -- [60]
    {
      132336, -- [1]
      3, -- [2]
      2, -- [3]
      19306, -- [4]
    }, -- [61]
    {
      132204, -- [1]
      1, -- [2]
      3, -- [3]
      82834, -- [4]
    }, -- [62]
    {
      236185, -- [1]
      3, -- [2]
      3, -- [3]
      56343, -- [4]
    }, -- [63]
    {
      132207, -- [1]
      4, -- [2]
      1, -- [3]
      34493, -- [4]
    }, -- [64]
    {
      133713, -- [1]
      4, -- [2]
      3, -- [3]
      56336, -- [4]
    }, -- [65]
    {
      132378, -- [1]
      5, -- [2]
      1, -- [3]
      82833, -- [4]
    }, -- [66]
    {
      135125, -- [1]
      5, -- [2]
      2, -- [3]
      19386, -- [4]
    }, -- [67]
    {
      236199, -- [1]
      2, -- [2]
      4, -- [3]
      53299, -- [4]
    }, -- [68]
    {
      236200, -- [1]
      5, -- [2]
      3, -- [3]
      53296, -- [4]
    }, -- [69]
    {
      236181, -- [1]
      5, -- [2]
      4, -- [3]
      53290, -- [4]
    }, -- [70]
    {
      236187, -- [1]
      6, -- [2]
      1, -- [3]
      53304, -- [4]
    }, -- [71]
    {
      136181, -- [1]
      7, -- [2]
      2, -- [3]
      3674, -- [4]
    }, -- [72]
    {
      304583, -- [1]
      4, -- [2]
      2, -- [3]
      83495, -- [4]
    }, -- [73]
    {
      132216, -- [1]
      3, -- [2]
      1, -- [3]
      34499, -- [4]
    }, -- [74]
    {
      132149, -- [1]
      2, -- [2]
      2, -- [3]
      63458, -- [4]
    }, -- [75]
    {
      132209, -- [1]
      6, -- [2]
      3, -- [3]
      87935, -- [4]
    }, -- [76]
    [85] = {
      "HunterBeastMastery", -- [1]
      "HunterMarksmanship", -- [2]
      "HunterSurvival", -- [3]
    },
  },
}


-- ========================================
-- File: WeakAuras/Types_Mists.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local encounter_list = ""
local zoneId_list = ""

local journalID2EncoutnerID = {
  [655] = 1397,
  [708] = 1442,
  [660] = 1422,
  [688] = 1423,
  [659] = 1426,
  [673] = 1303,
  [693] = 1465,
  [668] = 1412,
  [672] = 1418,
  [679] = 1395,
  [689] = 1390,
  [682] = 1434,
  [687] = 1436,
  [726] = 1500,
  [677] = 1407,
  [745] = 1507,
  [744] = 1504,
  [713] = 1463,
  [741] = 1498,
  [737] = 1499,
  [743] = 1501,
  [683] = 1409,
  [742] = 1505,
  [729] = 1506,
  [709] = 1431,
  [827] = 1577,
  [819] = 1575,
  [816] = 1570,
  [825] = 1565,
  [821] = 1578,
  [828] = 1573,
  [818] = 1572,
  [820] = 1574,
  [824] = 1576,
  [817] = 1559,
  [829] = 1560,
  [832] = 1579,
  [852] = 1602,
  [849] = 1598,
  [866] = 1624,
  [867] = 1604,
  [868] = 1622,
  [864] = 1600,
  [856] = 1606,
  [850] = 1603,
  [846] = 1595,
  [870] = 1594,
  [851] = 1599,
  [865] = 1601,
  [853] = 1593,
  [869] = 1623,
} -- extracted from retail

function Private.InitializeEncounterAndZoneLists()
	local currTier = EJ_GetCurrentTier()
  if encounter_list ~= "" then
    return
  end
	for tier = EJ_GetNumTiers(), EJ_GetNumTiers() do
		EJ_SelectTier(tier)
		local tierName = EJ_GetTierInfo(tier)
		for _, inRaid in ipairs({false, true}) do
			local instance_index = 1
			local instance_id = EJ_GetInstanceByIndex(instance_index, inRaid)
			local title = ("%s %s"):format(tierName , inRaid and L["Raids"] or L["Dungeons"])
			local zones = ""
			while instance_id do
				EJ_SelectInstance(instance_id)
				local instance_name, _, _, _, _, _, dungeonAreaMapID = EJ_GetInstanceInfo(instance_id)
				local ej_index = 1
				local boss, _, journalID = EJ_GetEncounterInfoByIndex(ej_index, instance_id)

				-- zone ids
				if dungeonAreaMapID and dungeonAreaMapID ~= 0 then
					local mapGroupId = C_Map.GetMapGroupID(dungeonAreaMapID)
					if mapGroupId then -- If there's a group id, only list that one
						zones = ("%s%s: g%d\n"):format(zones, instance_name, mapGroupId)
					else
						zones = ("%s%s: %d\n"):format(zones, instance_name, dungeonAreaMapID)
					end
				end

				-- Encounter ids
				if inRaid then
					while boss do
						if journalID and journalID2EncoutnerID[journalID] then
							if instance_name then
								encounter_list = ("%s|cffffd200%s|r\n"):format(encounter_list, instance_name)
								instance_name = nil -- Only add it once per section
							end
							encounter_list = ("%s%s: %d\n"):format(encounter_list, boss, journalID2EncoutnerID[journalID])
						end
						ej_index = ej_index + 1
						boss, _, journalID = EJ_GetEncounterInfoByIndex(ej_index, instance_id)
					end
					encounter_list = encounter_list .. "\n"
				end
				instance_index = instance_index + 1
				instance_id = EJ_GetInstanceByIndex(instance_index, inRaid)
			end
			if zones ~= "" then
				zoneId_list = ("%s|cffffd200%s|r\n"):format(zoneId_list, title)
				zoneId_list = zoneId_list .. zones.. "\n"
			end
		end
	end
	EJ_SelectTier(currTier) -- restore previously selected tier

  encounter_list = encounter_list:sub(1, -3) .. "\n\n" .. L["Supports multiple entries, separated by commas\n"]
end

function Private.get_encounters_list()
  return encounter_list
end

function Private.get_zoneId_list()
  return zoneId_list
end

Private.glyph_types = {}
Private.glyph_sorted = {}

local function FillGlyphData()
  local sorted = {}
  for i = 1, GetNumGlyphs() do
    local name, glyphType, isKnown, icon, glyphID = GetGlyphInfo(i)
    if name and icon and glyphID then
      Private.glyph_types[glyphID] = "|T" .. icon .. ":0|t" .. name
      table.insert(sorted, {glyphID = glyphID, name = name})
    end
  end

  table.sort(sorted, function(a, b)
    return a.name < b.name
  end)

  for _, glyph in ipairs(sorted) do
    table.insert(Private.glyph_sorted, glyph.glyphID)
  end
end

local initGlyphFrame = CreateFrame("Frame")
initGlyphFrame:RegisterEvent("PLAYER_ENTERING_WORLD")
initGlyphFrame:SetScript("OnEvent", function()
  initGlyphFrame:UnregisterEvent("PLAYER_ENTERING_WORLD")
  FillGlyphData()
end)

Private.talentInfo = {
  ["HUNTER"] = {
    {
      461119,
      1,
      1,
      109215,
    },
    {
      237430,
      1,
      2,
      109298,
    },
    {
      236190,
      1,
      3,
      118675,
    },
    {
      462650,
      2,
      1,
      109248,
    },
    {
      135125,
      2,
      2,
      19386,
    },
    {
      132111,
      2,
      3,
      19577,
    },
    {
      461117,
      3,
      1,
      109304,
    },
    {
      612363,
      3,
      2,
      109260,
    },
    {
      132121,
      3,
      3,
      109212,
    },
    {
      132160,
      4,
      1,
      82726,
    },
    {
      461121,
      4,
      2,
      120679,
    },
    {
      132216,
      4,
      3,
      109306,
    },
    {
      645217,
      5,
      1,
      131894,
    },
    {
      135731,
      5,
      2,
      130392,
    },
    {
      132167,
      5,
      3,
      120697,
    },
    {
      648707,
      6,
      1,
      117050,
    },
    {
      461120,
      6,
      2,
      109259,
    },
    {
      236201,
      6,
      3,
      120360,
    },
  },
  ["WARRIOR"] = {
    {
      132335,
      1,
      1,
      103826,
    },
    {
      237377,
      1,
      2,
      103827,
    },
    {
      236319,
      1,
      3,
      103828,
    },
    {
      132345,
      2,
      1,
      55694,
    },
    {
      132175,
      2,
      2,
      29838,
    },
    {
      589768,
      2,
      3,
      103840,
    },
    {
      132091,
      3,
      1,
      107566,
    },
    {
      136147,
      3,
      2,
      12323,
    },
    {
      589118,
      3,
      3,
      102060,
    },
    {
      236303,
      4,
      1,
      46924,
    },
    {
      236312,
      4,
      2,
      46968,
    },
    {
      642418,
      4,
      3,
      118000,
    },
    {
      132358,
      5,
      1,
      114028,
    },
    {
      236311,
      5,
      2,
      114029,
    },
    {
      236318,
      5,
      3,
      114030,
    },
    {
      613534,
      6,
      1,
      107574,
    },
    {
      236304,
      6,
      2,
      12292,
    },
    {
      613535,
      6,
      3,
      107570,
    },
  },
  ["ROGUE"] = {
    {
      132320,
      1,
      1,
      14062,
    },
    {
      571317,
      1,
      2,
      108208,
    },
    {
      571316,
      1,
      3,
      108209,
    },
    {
      135430,
      2,
      1,
      26679,
    },
    {
      538537,
      2,
      2,
      108210,
    },
    {
      458725,
      2,
      3,
      74001,
    },
    {
      132285,
      3,
      1,
      31230,
    },
    {
      538440,
      3,
      2,
      108211,
    },
    {
      236284,
      3,
      3,
      79008,
    },
    {
      236285,
      4,
      1,
      138106,
    },
    {
      132303,
      4,
      2,
      36554,
    },
    {
      538536,
      4,
      3,
      108212,
    },
    {
      236278,
      5,
      1,
      131511,
    },
    {
      538441,
      5,
      2,
      108215,
    },
    {
      460691,
      5,
      3,
      108216,
    },
    {
      135431,
      6,
      1,
      114014,
    },
    {
      236364,
      6,
      2,
      137619,
    },
    {
      236280,
      6,
      3,
      114015,
    },
  },
  ["MAGE"] = {
    {
      136031,
      1,
      1,
      12043,
    },
    {
      135788,
      1,
      2,
      108843,
    },
    {
      610877,
      1,
      3,
      108839,
    },
    {
      610472,
      2,
      1,
      115610,
    },
    {
      132847,
      2,
      2,
      140468,
    },
    {
      135988,
      2,
      3,
      11426,
    },
    {
      464484,
      3,
      1,
      113724,
    },
    {
      135850,
      3,
      2,
      111264,
    },
    {
      538562,
      3,
      3,
      102051,
    },
    {
      575584,
      4,
      1,
      110959,
    },
    {
      252268,
      4,
      2,
      86949,
    },
    {
      135865,
      4,
      3,
      11958,
    },
    {
      610471,
      5,
      1,
      114923,
    },
    {
      236220,
      5,
      2,
      44457,
    },
    {
      609814,
      5,
      3,
      112948,
    },
    {
      135730,
      6,
      1,
      114003,
    },
    {
      609815,
      6,
      2,
      116011,
    },
    {
      136153,
      6,
      3,
      1463,
    },
  },
  ["PRIEST"] = {
    {
      537022,
      1,
      1,
      108920,
    },
    {
      537021,
      1,
      2,
      108921,
    },
    {
      136206,
      1,
      3,
      605,
    },
    {
      135982,
      2,
      1,
      64129,
    },
    {
      642580,
      2,
      2,
      121536,
    },
    {
      614257,
      2,
      3,
      108942,
    },
    {
      135981,
      3,
      1,
      109186,
    },
    {
      136214,
      3,
      2,
      123040,
    },
    {
      612968,
      3,
      3,
      139139,
    },
    {
      237550,
      4,
      1,
      19236,
    },
    {
      775463,
      4,
      2,
      112833,
    },
    {
      633042,
      4,
      3,
      108945,
    },
    {
      237566,
      5,
      1,
      109142,
    },
    {
      135939,
      5,
      2,
      10060,
    },
    {
      537078,
      5,
      3,
      109175,
    },
    {
      612098,
      6,
      1,
      121135,
    },
    {
      537026,
      6,
      2,
      110744,
    },
    {
      632352,
      6,
      3,
      120517,
    },
  },
  ["WARLOCK"] = {
    {
      537516,
      1,
      1,
      108359,
    },
    {
      571320,
      1,
      2,
      108370,
    },
    {
      537517,
      1,
      3,
      108371,
    },
    {
      236302,
      2,
      1,
      47897,
    },
    {
      607853,
      2,
      2,
      6789,
    },
    {
      607865,
      2,
      3,
      30283,
    },
    {
      607854,
      3,
      1,
      108415,
    },
    {
      538538,
      3,
      2,
      108416,
    },
    {
      538039,
      3,
      3,
      110913,
    },
    {
      538040,
      4,
      1,
      111397,
    },
    {
      538043,
      4,
      2,
      111400,
    },
    {
      571321,
      4,
      3,
      108482,
    },
    {
      538442,
      5,
      1,
      108499,
    },
    {
      538444,
      5,
      2,
      108501,
    },
    {
      538443,
      5,
      3,
      108503,
    },
    {
      236402,
      6,
      1,
      108505,
    },
    {
      236418,
      6,
      2,
      137587,
    },
    {
      236423,
      6,
      3,
      108508,
    },
  },
  ["DEATHKNIGHT"] = {
    {
      538561,
      1,
      1,
      108170,
    },
    {
      132099,
      1,
      2,
      123693,
    },
    {
      136132,
      1,
      3,
      115989,
    },
    {
      136187,
      2,
      1,
      49039,
    },
    {
      237510,
      2,
      2,
      51052,
    },
    {
      134430,
      2,
      3,
      114556,
    },
    {
      237561,
      3,
      1,
      96268,
    },
    {
      135864,
      3,
      2,
      50041,
    },
    {
      538558,
      3,
      3,
      108194,
    },
    {
      136146,
      4,
      1,
      48743,
    },
    {
      538559,
      4,
      2,
      108196,
    },
    {
      538560,
      4,
      3,
      119975,
    },
    {
      237515,
      5,
      1,
      45529,
    },
    {
      134423,
      5,
      2,
      81229,
    },
    {
      252272,
      5,
      3,
      51462,
    },
    {
      538767,
      6,
      1,
      108199,
    },
    {
      538770,
      6,
      2,
      108200,
    },
    {
      538768,
      6,
      3,
      108201,
    },
  },
  ["DRUID"] = {
    {
      538517,
      1,
      1,
      131768,
    },
    {
      538514,
      1,
      2,
      102280,
    },
    {
      538771,
      1,
      3,
      102401,
    },
    {
      134157,
      2,
      1,
      145108,
    },
    {
      136059,
      2,
      2,
      108238,
    },
    {
      132137,
      2,
      3,
      102351,
    },
    {
      538516,
      3,
      1,
      106707,
    },
    {
      538515,
      3,
      2,
      102359,
    },
    {
      236170,
      3,
      3,
      132469,
    },
    {
      236160,
      4,
      1,
      114107,
    },
    {
      571586,
      4,
      2,
      106731,
    },
    {
      132129,
      4,
      3,
      106737,
    },
    {
      132121,
      5,
      1,
      99,
    },
    {
      571588,
      5,
      2,
      102793,
    },
    {
      132114,
      5,
      3,
      5211,
    },
    {
      135879,
      6,
      1,
      108288,
    },
    {
      132123,
      6,
      2,
      108373,
    },
    {
      236764,
      6,
      3,
      124974,
    },
  },
  ["MONK"] = {
    {
      607848,
      1,
      1,
      115173,
    },
    {
      651727,
      1,
      2,
      116841,
    },
    {
      574577,
      1,
      3,
      115174,
    },
    {
      606541,
      2,
      1,
      115098,
    },
    {
      613397,
      2,
      2,
      124081,
    },
    {
      135734,
      2,
      3,
      123986,
    },
    {
      629484,
      3,
      1,
      121817,
    },
    {
      629482,
      3,
      2,
      115396,
    },
    {
      629483,
      3,
      3,
      115399,
    },
    {
      839107,
      4,
      1,
      116844,
    },
    {
      615340,
      4,
      2,
      119392,
    },
    {
      642414,
      4,
      3,
      119381,
    },
    {
      608939,
      5,
      1,
      122280,
    },
    {
      620827,
      5,
      2,
      122278,
    },
    {
      775460,
      5,
      3,
      122783,
    },
    {
      606549,
      6,
      1,
      116847,
    },
    {
      620832,
      6,
      2,
      123904,
    },
    {
      607849,
      6,
      3,
      115008,
    },
  },
  ["PALADIN"] = {
    {
      571558,
      1,
      1,
      85499,
    },
    {
      571556,
      1,
      2,
      87172,
    },
    {
      589117,
      1,
      3,
      26023,
    },
    {
      135906,
      2,
      1,
      105593,
    },
    {
      135942,
      2,
      2,
      20066,
    },
    {
      571559,
      2,
      3,
      110301,
    },
    {
      236252,
      3,
      1,
      85804,
    },
    {
      135433,
      3,
      2,
      114163,
    },
    {
      236249,
      3,
      3,
      20925,
    },
    {
      135970,
      4,
      1,
      114039,
    },
    {
      135984,
      4,
      2,
      114154,
    },
    {
      589116,
      4,
      3,
      105622,
    },
    {
      571555,
      5,
      1,
      105809,
    },
    {
      236262,
      5,
      2,
      53376,
    },
    {
      135897,
      5,
      3,
      86172,
    },
    {
      613408,
      6,
      1,
      114165,
    },
    {
      613955,
      6,
      2,
      114158,
    },
    {
      613954,
      6,
      3,
      114157,
    },
  },
  ["SHAMAN"] = {
    {
      136060,
      1,
      1,
      30884,
    },
    {
      538572,
      1,
      2,
      108270,
    },
    {
      538565,
      1,
      3,
      108271,
    },
    {
      135776,
      2,
      1,
      63374,
    },
    {
      136100,
      2,
      2,
      51485,
    },
    {
      538576,
      2,
      3,
      108273,
    },
    {
      538570,
      3,
      1,
      108285,
    },
    {
      538573,
      3,
      2,
      108284,
    },
    {
      538574,
      3,
      3,
      108287,
    },
    {
      136115,
      4,
      1,
      16166,
    },
    {
      237576,
      4,
      2,
      16188,
    },
    {
      538566,
      4,
      3,
      108283,
    },
    {
      135127,
      5,
      1,
      147074,
    },
    {
      538564,
      5,
      2,
      108281,
    },
    {
      538567,
      5,
      3,
      108282,
    },
    {
      650636,
      6,
      1,
      117012,
    },
    {
      651081,
      6,
      2,
      117013,
    },
    {
      651244,
      6,
      3,
      117014,
    },
  },
}


-- ========================================
-- File: WeakAuras/Types_Retail.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local encounter_list = ""
local zoneId_list = ""
function Private.InitializeEncounterAndZoneLists()
	local currTier = EJ_GetCurrentTier()
  if encounter_list ~= "" then
    return
  end
	for tier = EJ_GetNumTiers(), EJ_GetNumTiers() do
		EJ_SelectTier(tier)
		local tierName = EJ_GetTierInfo(tier)
		for _, inRaid in ipairs({false, true}) do
			local instance_index = 1
			local instance_id = EJ_GetInstanceByIndex(instance_index, inRaid)
			local title = ("%s %s"):format(tierName , inRaid and L["Raids"] or L["Dungeons"])
			local zones = ""
			while instance_id do
				EJ_SelectInstance(instance_id)
				local instance_name, _, _, _, _, _, dungeonAreaMapID = EJ_GetInstanceInfo(instance_id)
				local ej_index = 1
				local boss, _, _, _, _, _, encounter_id = EJ_GetEncounterInfoByIndex(ej_index, instance_id)

				-- zone ids
				if dungeonAreaMapID and dungeonAreaMapID ~= 0 then
					local mapGroupId = C_Map.GetMapGroupID(dungeonAreaMapID)
					if mapGroupId then -- If there's a group id, only list that one
						zones = ("%s%s: g%d\n"):format(zones, instance_name, mapGroupId)
					else
						zones = ("%s%s: %d\n"):format(zones, instance_name, dungeonAreaMapID)
					end
				end

				-- Encounter ids
				if inRaid then
					while boss do
						if encounter_id then
							if instance_name then
								encounter_list = ("%s|cffffd200%s|r\n"):format(encounter_list, instance_name)
								instance_name = nil -- Only add it once per section
							end
							encounter_list = ("%s%s: %d\n"):format(encounter_list, boss, encounter_id)
						end
						ej_index = ej_index + 1
						boss, _, _, _, _, _, encounter_id = EJ_GetEncounterInfoByIndex(ej_index, instance_id)
					end
					encounter_list = encounter_list .. "\n"
				end
				instance_index = instance_index + 1
				instance_id = EJ_GetInstanceByIndex(instance_index, inRaid)
			end
			if zones ~= "" then
				zoneId_list = ("%s|cffffd200%s|r\n"):format(zoneId_list, title)
				zoneId_list = zoneId_list .. zones.. "\n"
			end
		end
	end
	EJ_SelectTier(currTier) -- restore previously selected tier

  encounter_list = encounter_list:sub(1, -3) .. "\n\n" .. L["Supports multiple entries, separated by commas\n"]
end

function Private.get_encounters_list()
  return encounter_list
end

function Private.get_zoneId_list()
  return zoneId_list
end

local backgroundAlias = {
	-- DK
	[250] = "talents-background-deathknight-blood",
	[251] = "talents-background-deathknight-frost",
	[252] = "talents-background-deathknight-unholy",

	-- DH
	[577] = "talents-background-demonhunter-havoc",
	[581] = "talents-background-demonhunter-vengeance",

	-- Druid
	[102] = "talents-background-druid-balance",
	[103] = "talents-background-druid-feral",
	[104] = "talents-background-druid-guardian",
	[105] = "talents-background-druid-restoration",

	-- Evoker
	[1467] = "talents-background-evoker-devastation",
	[1468] = "talents-background-evoker-preservation",

	-- Hunter
	[253] = "talents-background-hunter-beastmastery",
	[254] = "talents-background-hunter-marksmanship",
	[255] = "talents-background-hunter-survival",

	-- Mage
	[62] = "talents-background-mage-arcane",
	[63] = "talents-background-mage-fire",
	[64] = "talents-background-mage-frost",

	-- Monk
	[268] = "talents-background-monk-brewmaster",
	[269] = "talents-background-monk-windwalker",
	[270] = "talents-background-monk-mistweaver",

	-- Paladin
	[65] = "talents-background-paladin-holy",
	[66] = "talents-background-paladin-protection",
	[70] = "talents-background-paladin-retribution",

	-- Priest
	[256] = "talents-background-priest-discipline",
	[257] = "talents-background-priest-holy",
	[258] = "talents-background-priest-shadow",

	-- Rogue
	[259] = "talents-background-rogue-assassination",
	[260] = "talents-background-rogue-outlaw",
	[261] =  "talents-background-rogue-subtlety",

	-- Shaman
	[262] = "talents-background-shaman-elemental",
	[263] = "talents-background-shaman-enhancement",
	[264] = "talents-background-shaman-restoration",

	-- Warlock
	[265] = "talents-background-warlock-affliction",
	[266] = "talents-background-warlock-demonology",
	[267] = "talents-background-warlock-destruction",

	-- Warrior
	[71] = "talents-background-warrior-arms",
	[72] = "talents-background-warrior-fury",
	[73] = "talents-background-warrior-protection",
}

local classIDToOffsets = {
	[1] = { extraOffsetX = WeakAuras.IsTWW() and 60 or 30, extraOffsetY = 31, }, -- Warrior
	[2] = { extraOffsetX = -60, extraOffsetY = -29, }, -- Paladin
	[3] = { extraOffsetX = 0, extraOffsetY = -29, }, -- Hunter
	[4] = { extraOffsetX = 30, extraOffsetY = -29, }, -- Rogue
	[5] = { extraOffsetX = -30, extraOffsetY = -29, }, -- Priest
	[6] = { extraOffsetX = 0, extraOffsetY = 1, }, -- DK
	[7] = { extraOffsetX = 0, extraOffsetY = 1, }, -- Shaman
	[8] = { extraOffsetX = 30, extraOffsetY = -29, }, -- Mage
	[9] = { extraOffsetX = 0, extraOffsetY = 1, }, -- Warlock
	[10] = { extraOffsetX = 0, extraOffsetY = -29, }, -- Monk
	[11] = { extraOffsetX = 30, extraOffsetY = -29, }, -- Druid
	[12] = { extraOffsetX = 30, extraOffsetY = -29, }, -- Demon Hunter
	[13] = { extraOffsetX = 30, extraOffsetY = -29, }, -- Evoker
}
local initialBasePanOffsetX = 4
local initialBasePanOffsetY = -30

function Private.GetTalentInfo(specId)
  local talents = {}
  local talentInfo = Private.talentInfo[specId]
  if talentInfo then
    for talentId, talentData in pairs(talentInfo) do
      local spellName, _, icon = Private.ExecEnv.GetSpellInfo(talentData[1])
      if spellName then
        talents[talentId] = ("|T"..icon..":16|t " .. spellName)
      end
    end
  end
  return talents
end

Private.talentInfo = {}
Private.talentInfoByNodeId = {}

local function GetClassId(classFile)
	for classID = 1, GetNumClasses() do
		local _, thisClassFile = GetClassInfo(classID)
		if classFile == thisClassFile then
			return classID
		end
	end
end



function Private.GetTalentData(specId)
	if Private.talentInfo[specId] then
		return unpack(Private.talentInfo[specId])
	end
	local configId = Constants.TraitConsts.VIEW_TRAIT_CONFIG_ID
	local specData = {}
  local specDataByNodeId = {}
	local heroData = {}
	C_ClassTalents.InitializeViewLoadout(specId, 70)
	C_ClassTalents.ViewLoadout({})
	local configInfo = C_Traits.GetConfigInfo(configId)
	local subTreeIDs = WeakAuras.IsTWW() and C_ClassTalents.GetHeroTalentSpecsForClassSpec(configId, specId) or {}
	if configInfo == nil then return end
	for _, treeId in ipairs(configInfo.treeIDs) do
		local nodes = C_Traits.GetTreeNodes(treeId)
		for _, nodeId in ipairs(nodes) do
			local node = C_Traits.GetNodeInfo(configId, nodeId)
			if node and node.ID ~= 0 then
				for idx, talentId in ipairs(node.entryIDs) do
					local entryInfo = C_Traits.GetEntryInfo(configId, talentId)
					if entryInfo.definitionID then
						local definitionInfo = C_Traits.GetDefinitionInfo(entryInfo.definitionID)
						if definitionInfo.spellID then
							local spellName = Private.ExecEnv.GetSpellName(definitionInfo.spellID)
							if spellName then
								local talentData = {
									talentId,
									definitionInfo.spellID,
									{ node.posX, node.posY, idx, #node.entryIDs },
									{}, -- Target if it exists,
									node.maxRanks
								}
								specDataByNodeId[node.ID] = specDataByNodeId[node.ID] or {}
								specDataByNodeId[node.ID][idx] = talentData
								for _, edge in pairs(node.visibleEdges) do
									local targetNodeId = edge.targetNode
									local targetNode = C_Traits.GetNodeInfo(configId, targetNodeId)
									local targetNodeTalentId1 = targetNode.entryIDs[1]
									if targetNodeTalentId1 then
										-- add as target 1st talentId
										-- because we don't save nodes
										tinsert(talentData[4], targetNodeTalentId1)
									end
								end
								local subTreeIndex = node.subTreeID and tIndexOf(subTreeIDs, node.subTreeID) or nil
								if subTreeIndex then
									local subTreeInfo = C_Traits.GetSubTreeInfo(configId, node.subTreeID)
									talentData[3][1] = node.posX - subTreeInfo.posX
									talentData[3][2] = node.posY - subTreeInfo.posY
									talentData[3][5] = subTreeIndex
									tinsert(heroData, talentData)
								elseif not node.subTreeID then
									tinsert(specData, talentData)
								end
							end
						end
					end
				end
			end
		end
	end

	local classFile = select(6, GetSpecializationInfoByID(specId))
	local classID = GetClassId(classFile)
	local classOffsets = classIDToOffsets[classID]
	local basePanOffsetX = initialBasePanOffsetX - (classOffsets and classOffsets.extraOffsetX or 0)
	local basePanOffsetY = initialBasePanOffsetY - (classOffsets and classOffsets.extraOffsetY or 0)
	specData[999] = backgroundAlias[specId]
	specData[1000] = { offsetX = basePanOffsetX, offsetY = basePanOffsetY }
	heroData[999] = backgroundAlias[specId]
	heroData[1001] = true
	Private.talentInfo[specId] = { specData, heroData, specDataByNodeId }
	return specData, heroData, specDataByNodeId
end

WeakAuras.StopMotion = {
	texture_data = {},
	texture_types = {
		Blizzard = {}
	}
}
local texture_data = {}

local replacementString = {}
-- Action bar GCD
texture_data["UI-HUD-ActionBar-GCD-Flipbook-2x"] = { rows = 11, columns = 2, count = 22 }
-- Arcane shock
texture_data["UF-Arcane-ShockFX"] = { rows = 5, columns = 6, count = 28 }
-- Checkmark
texture_data["activities-checkmark_flipbook-large"] = { rows = 2, columns = 4, count = 8 }
-- Chi wind
texture_data["UF-Chi-WindFX"] = { rows = 3, columns = 6, count = 17 }
-- Death knight runes
replacementString = {
	"Blood",
	"Default",
	"Frost",
	"Unholy"
}
for _, v in ipairs(replacementString) do
	local name = ("UF-DKRunes-%sDeplete"):format(v)
	texture_data[name] = { rows = 4, columns = 6, count = 23 }
end
-- Dice
texture_data["lootroll-animdice"] = { rows = 9, columns = 5, count = 44 }
-- Dragonriding vigor
texture_data["dragonriding_vigor_fill_flipbook"] = { rows = 5, columns = 4, count = 20 }
-- Druid combo points
texture_data["UF-DruidCP-Slash"] = { rows = 3, columns = 8, count = 20 }
-- Essence spinner
texture_data["UF-Essence-Flipbook-FX-Circ"] = { rows = 3, columns = 10, count = 29 }
-- Experience bars
replacementString = {
	"Rested",
	"Reputation",
	"Experience",
	"Honor",
	"ArtifactPower"
}
for _, v in ipairs(replacementString) do
	local name = ("UI-HUD-ExperienceBar-Fill-%s-2x-Flipbook"):format(v)
	texture_data[name] = { rows = 30, columns = 1, count = 30 }
end
replacementString = {
	"Rested",
	"Reputation",
	"XP",
	"Faction-Orange",
	"ArtifactPower"
}
for _, v in ipairs(replacementString) do
	local name = ("UI-HUD-ExperienceBar-Flare-%s-2x-Flipbook"):format(v)
	texture_data[name] = { rows = 7, columns = 4, count = 28 }
end
-- Great vault unlocking
texture_data["greatVault-unlocked-anim"] = { rows = 11, columns = 5, count = 54 }
-- Group finder eye
texture_data["groupfinder-eye-flipbook-initial"] = { rows = 5, columns = 11, count = 52 }
texture_data["groupfinder-eye-flipbook-searching"] = { rows = 8, columns = 11, count = 80 }
texture_data["groupfinder-eye-flipbook-mouseover"] = { rows = 1, columns = 12, count = 12 }
texture_data["groupfinder-eye-flipbook-foundfx"] = { rows = 5, columns = 15, count = 75 }
texture_data["groupfinder-eye-flipbook-found-initial"] = { rows = 7, columns = 11, count = 70 }
texture_data["groupfinder-eye-flipbook-found-loop"] = { rows = 4, columns = 11, count = 41 }
texture_data["groupfinder-eye-flipbook-poke-initial"] = { rows = 6, columns = 11, count = 66 }
texture_data["groupfinder-eye-flipbook-poke-loop"] = { rows = 6, columns = 11, count = 62 }
texture_data["groupfinder-eye-flipbook-poke-end"] = { rows = 4, columns = 11, count = 38 }
-- Holy power runes
for i = 1, 5 do
	local name = ("UF-HolyPower-DepleteRune%d"):format(i)
	texture_data[name] = { rows = 5, columns = 6, count = 26 }
end

-- Loot roll reveal
texture_data["lootroll-animreveal-a"] = { rows = 2, columns = 6, count = 12 }
-- Mail
texture_data["UI-HUD-Minimap-Mail-New-Flipbook-2x"] = { rows = 5, columns = 4, count = 20 }
texture_data["UI-HUD-Minimap-Mail-Reminder-Flipbook-2x"] = { rows = 3, columns = 4, count = 12 }
-- Ping markers
replacementString = {
	"Assist",
	"Attack",
	"OnMyWay",
	"Warning",
	"NonThreat",
	"Threat"
}
for _, v in ipairs(replacementString) do
	local name = ("Ping_Marker_FlipBook_%s"):format(v)
	texture_data[name] = { rows = 4, columns = 6, count = 21 }
end
-- Player rest
texture_data["UI-HUD-UnitFrame-Player-Rest-Flipbook"] = { rows = 7, columns = 6, count = 42 }
-- Priest void bar
texture_data["Unit_Priest_Void_Fill_Flipbook"] = { rows = 9, columns = 5, count = 45 }
-- Professions
replacementString = {
	"Alchemy",
	"Blacksmithing",
	"Cooking",
	"Engineering",
	"Fishing",
	"Herbalism",
	"Inscription",
	"Leatherworking",
	"Mining",
	"Skinning",
	"Tailoring"
}
for _, v in ipairs(replacementString) do
	local name = ("Skillbar_Fill_Flipbook_%s"):format(v)
	texture_data[name] = { rows = 30, columns = 2, count = 60 }
end
texture_data["Skillbar_Fill_Flipbook_Enchanting"] = { rows = 37, columns = 2, count = 74 }
texture_data["Skillbar_Fill_Flipbook_Jewelcrafting"] = { rows = 22, columns = 2, count = 44 }
replacementString = {
	"Alchemy",
	"Blacksmithing",
	"Enchanting",
	"Engineering",
	"Herbalism",
	"Inscription",
	"Jewelcrafting",
	"Leatherworking",
	"Mining",
	"Skinning",
	"Tailoring"
}
for _, v in ipairs(replacementString) do
	local name = ("SpecDial_Fill_Flipbook_%s"):format(v)
	texture_data[name] = { rows = 6, columns = 6, count = 36 }
	name = ("SpecDial_Pip_Flipbook_%s"):format(v)
	texture_data[name] = { rows = 4, columns = 4, count = 16 }
	name = ("SpecDial_EndPip_Flipbook_%s"):format(v)
	texture_data[name] = { rows = 4, columns = 6, count = 24 }
end
for i = 1, 5 do
	local name = ("GemAppear_T%d_Flipbook"):format(i)
	texture_data[name] = { rows = 3, columns = 4, count = 12 }
	name = ("Quality-BarFill-Flipbook-T%d-x2"):format(i)
	texture_data[name] = { rows = 15, columns = 4, count = 60 }
end
for i = 1, 4 do
	local name = ("GemDissolve_T%d_Flipbook"):format(i)
	texture_data[name] = { rows = 3, columns = 4, count = 12 }
end
-- Rogue combo points
replacementString = {
	"Red",
	"Blue"
}
for _, v in ipairs(replacementString) do
	local name = ("UF-RogueCP-Slash-%s"):format(v)
	texture_data[name] = { rows = 3, columns = 6, count = 17 }
end
-- Soul shards
replacementString = {
	"A",
	"B",
	"C"
}
for _, v in ipairs(replacementString) do
	local name = ("UF-SoulShards-Flipbook-Deplete%s"):format(v)
	texture_data[name] = { rows = 3, columns = 6, count = 15 }
end
texture_data["UF-SoulShards-Flipbook-Soul"] = { rows = 3, columns = 7, count = 18 }
-- Dragonriding
do
	local flipbooks = {
		{ pattern = "%s_fill_flipbook", duration = 1.2, rows = 5, columns = 4, count = 20 },
		{ pattern = "%s_filled_flipbook", duration = 0.6, rows = 2, columns = 4, count = 8 },
		{ pattern = "%s_burst_flipbook", duration = 0.55, rows = 4, columns = 4, count = 16 },
		{ pattern = "%s_decor_flipbook_left", duration = 0.3, rows = 2, columns = 4, count = 8 },
		{ pattern = "%s_decor_flipbook_right", duration = 0.3, rows = 2, columns = 4, count = 8 },
	}
	local kitName = "dragonriding_sgvigor"
	for _, flipbook in ipairs(flipbooks) do
		local name = flipbook.pattern:format(kitName)
		texture_data[name] = { rows = flipbook.rows, columns = flipbook.columns, count = flipbook.count }
	end
end

-- Supplement the data
for k, v in pairs(texture_data) do
	local atlasInfo = C_Texture.GetAtlasInfo(k)
	if atlasInfo then
		if atlasInfo.rawSize then
			v.tileWidth = atlasInfo.rawSize.x / v.columns
			v.tileHeight = atlasInfo.rawSize.y / v.rows
		end
		v.isBlizzardFlipbook = true
		WeakAuras.StopMotion.texture_data[k] = v
		WeakAuras.StopMotion.texture_types.Blizzard[k] = k
	end
end


-- ========================================
-- File: WeakAuras/Types_Vanilla.lua
-- ========================================

if not WeakAuras.IsLibsOK() then return end
---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

---@class WeakAuras
local WeakAuras = WeakAuras;
local L = WeakAuras.L;

local encounter_list = ""
function Private.InitializeEncounterAndZoneLists()
  if encounter_list ~= "" then
    return
  end
  local raids = {
    {
      L["World Bosses"],
      {
        { L["Kazzak"], 3026 },
        { L["Azuregos"], 3027 },
        { L["Onyxia"], 1084 }
      }
    },
    {
      L["Molten Core"],
      {
        { L["Lucifron"], 663 },
        { L["Magmadar"], 664 },
        { L["Gehennas"], 665 },
        { L["Garr"], 666 },
        { L["Shazzrah"], 667 },
        { L["Baron Geddon"], 668 },
        { L["Sulfuron Harbinger"], 669 },
        { L["Golemagg the Incinerator"], 670 },
        { L["Majordomo Executus"], 671 },
        { L["Ragnaros"], 672 }
      }
    },
    {
      L["Black Wing Lair"],
      {
          { L["Razorgore the Untamed"], 610 },
          { L["Vaelastrasz the Corrupt"], 611 },
          { L["Broodlord Lashlayer"], 612 },
          { L["Firemaw"], 613 },
          { L["Ebonroc"], 614 },
          { L["Flamegor"], 615 },
          { L["Chromaggus"], 616 },
          { L["Nefarian"], 617 }
      }
    },
    {
      L["Ahn'Qiraj"],
      {
        { L["The Prophet Skeram"], 709 },
        { L["Silithid Royalty"], 710 },
        { L["Battleguard Sartura"], 711 },
        { L["Fankriss the Unyielding"], 712 },
        { L["Viscidus"], 713 },
        { L["Princess Huhuran"], 714 },
        { L["Twin Emperors"], 715 },
        { L["Ouro"], 716 },
        { L["C'thun"], 717 }
      }
    },
    {
      L["Ruins of Ahn'Qiraj"],
      {
        { L["Kurinnaxx"], 718 },
        { L["General Rajaxx"], 719 },
        { L["Moam"], 720 },
        { L["Buru the Gorger"], 721 },
        { L["Ayamiss the Hunter"], 722 },
        { L["Ossirian the Unscarred"], 723 }
      }
    },
    {
      L["Zul'Gurub"],
      {
        { L["High Priest Venoxis"], 784 },
        { L["High Priestess Jeklik"], 785 },
        { L["High Priestess Mar'li"], 786 },
        { L["Bloodlord Mandokir"], 787 },
        { L["Edge of Madness"], 788 },
        { L["High Priest Thekal"], 789 },
        { L["Gahz'ranka"], 790 },
        { L["High Priestess Arlokk"], 791 },
        { L["Jin'do the Hexxer"], 792 },
        { L["Hakkar"], 793 }
      }
    },
    {
      L["Naxxramas"],
      {
        -- The Arachnid Quarter
        { L["Anub'Rekhan"], 1107 },
        { L["Grand Widow Faerlina"], 1110 },
        { L["Maexxna"], 1116 },
        -- The Plague Quarter
        { L["Noth the Plaguebringer"], 1117 },
        { L["Heigan the Unclean"], 1112 },
        { L["Loatheb"], 1115 },
        -- The Military Quarter
        { L["Instructor Razuvious"], 1113 },
        { L["Gothik the Harvester"], 1109 },
        { L["The Four Horsemen"], 1121 },
        -- The Construct Quarter
        { L["Patchwerk"], 1118 },
        { L["Grobbulus"], 1111 },
        { L["Gluth"], 1108 },
        { L["Thaddius"], 1120 },
        -- Frostwyrm Lair
        { L["Sapphiron"], 1119 },
        { L["Kel'Thuzad"], 1114 }
      }
    },
    {
      L["Scarlet Enclave"],
      {
        { L["Balnazzar"], 3185 },
        { L["Beatrix"], 3187 },
        { L["Solistrasza"], 3186 },
        { L["Mason"], 3197 },
        { L["Beastmaster"], 3196 },
        { L["Reborn Council"], 3188 },
        { L["Lillian Voss"], 3190 },
        { L["Caldoran"], 3189 },
      }
    }
  }

  for _, raid in ipairs(raids) do
    encounter_list = ("%s|cffffd200%s|r\n"):format(encounter_list, raid[1])
    for _, boss in ipairs(raid[2]) do
        encounter_list = ("%s%s: %d\n"):format(encounter_list, boss[1], boss[2])
    end
    encounter_list = encounter_list .. "\n"
  end

  encounter_list = encounter_list:sub(1, -3) .. "\n\n" .. L["Supports multiple entries, separated by commas\n"]
end

function Private.get_encounters_list()
  return encounter_list
end

function Private.get_zoneId_list()
  return ""
end


-- ========================================
-- File: WeakAuras/WeakAuras.lua
-- ========================================

---@type string
local AddonName = ...
---@class Private
local Private = select(2, ...)

local internalVersion = 86

-- Lua APIs
local insert = table.insert

-- WoW APIs
local GetTalentInfo, InCombatLockdown = GetTalentInfo, InCombatLockdown
local UnitName, GetRealmName, UnitRace, UnitFactionGroup, IsInRaid
  = UnitName, GetRealmName, UnitRace, UnitFactionGroup, IsInRaid
local UnitClass, UnitExists, UnitGUID, UnitAffectingCombat, GetInstanceInfo, IsInInstance
  = UnitClass, UnitExists, UnitGUID, UnitAffectingCombat, GetInstanceInfo, IsInInstance
local UnitIsUnit, GetRaidRosterInfo, GetSpecialization, UnitInVehicle, UnitHasVehicleUI
  = UnitIsUnit, GetRaidRosterInfo, GetSpecialization, UnitInVehicle, UnitHasVehicleUI
local SendChatMessage, UnitInBattleground, UnitInRaid, UnitInParty, GetTime
  = SendChatMessage, UnitInBattleground, UnitInRaid, UnitInParty, GetTime
local CreateFrame, IsShiftKeyDown, GetScreenWidth, GetScreenHeight, GetCursorPosition, UpdateAddOnCPUUsage, GetFrameCPUUsage, debugprofilestop
  = CreateFrame, IsShiftKeyDown, GetScreenWidth, GetScreenHeight, GetCursorPosition, UpdateAddOnCPUUsage, GetFrameCPUUsage, debugprofilestop
local debugstack = debugstack
local GetNumTalentTabs, GetNumTalents = GetNumTalentTabs, GetNumTalents
local MAX_NUM_TALENTS = MAX_NUM_TALENTS or 20

local ADDON_NAME = "WeakAuras"
---@class WeakAuras
local WeakAuras = WeakAuras
local L = WeakAuras.L
local versionString = WeakAuras.versionString
local prettyPrint = WeakAuras.prettyPrint

WeakAurasTimers = setmetatable({}, {__tostring=function() return "WeakAuras" end})
LibStub("AceTimer-3.0"):Embed(WeakAurasTimers)

Private.maxTimerDuration = 604800; -- A week, in seconds
local maxUpTime = 4294967; -- 2^32 / 1000

Private.watched_trigger_events = {}

-- The worlds simplest callback system.
-- That supports 1:N, but no de-registration and breaks if registering in a callback
--- @class callbacks
--- @field events table
--- @field RegisterCallback fun(self: callbacks, event: string, handler: function)
--- @field Fire fun(self: callbacks, event: string, ... : any)
Private.callbacks = {}
Private.callbacks.events = {}

function Private.callbacks:RegisterCallback(event, handler)
  self.events[event] = self.events[event] or {}
  tinsert(self.events[event], handler)
end

function Private.callbacks:Fire(event, ...)
  if self.events[event] then
    for index, f in ipairs(self.events[event]) do
      f(event, ...)
    end
  end
end

function WeakAurasTimers:ScheduleTimerFixed(func, delay, ...)
  if (delay < Private.maxTimerDuration) then
    if delay + GetTime() > maxUpTime then
      WeakAuras.prettyPrint(WeakAuras.L["Can't schedule timer with %i, due to a World of Warcraft bug with high computer uptime. (Uptime: %i). Please restart your computer."]:format(delay, GetTime()))
      return
    end
    return self:ScheduleTimer(func, delay, ...)
  end
end

local LDB = LibStub("LibDataBroker-1.1")
local LDBIcon = LibStub("LibDBIcon-1.0")
local LCG = LibStub("LibCustomGlow-1.0")
local LGF = LibStub("LibGetFrame-1.0")

local CustomNames = C_AddOns.IsAddOnLoaded("CustomNames") and LibStub("CustomNames") -- optional addon
if CustomNames then
  WeakAuras.GetName = CustomNames.Get
  WeakAuras.UnitName = CustomNames.UnitName
  WeakAuras.GetUnitName = CustomNames.GetUnitName
  WeakAuras.UnitFullName = CustomNames.UnitFullName
else
  WeakAuras.GetName = function(name) return name end
  WeakAuras.UnitName = UnitName
  WeakAuras.GetUnitName = GetUnitName
  WeakAuras.UnitFullName = UnitFullName
end

local timer = WeakAurasTimers
WeakAuras.timer = timer

local loginQueue = {}
local queueshowooc

function WeakAuras.InternalVersion()
  return internalVersion;
end

do
  local currentErrorHandlerId
  local currentErrorHandlerUid
  local currentErrorHandlerContext
  local function waErrorHandler(errorMessage)
    local juicedMessage = {}
    local data
    if currentErrorHandlerId then
      data = WeakAuras.GetData(currentErrorHandlerId)
    elseif currentErrorHandlerUid then
      data = Private.GetDataByUID(currentErrorHandlerUid)
    end
    if data then
      Private.AuraWarnings.UpdateWarning(data.uid, "LuaError", "error",
        L["This aura has caused a Lua error."] .. "\n" .. L["Install the addons BugSack and BugGrabber for detailed error logs."], true)
      table.insert(juicedMessage, L["Lua error in Aura '%s': %s"]:format(data.id, currentErrorHandlerContext or L["unknown location"]))
    else
      table.insert(juicedMessage, L["Lua error"])
    end
    table.insert(juicedMessage, L["WeakAuras Version: %s"]:format(WeakAuras.versionString))
    local version = data and (data.semver or data.version)
    if version then
      table.insert(juicedMessage, L["Aura Version: %s"]:format(version))
    end
    table.insert(juicedMessage, L["Stack trace:"])
    table.insert(juicedMessage, errorMessage)
    geterrorhandler()(table.concat(juicedMessage, "\n"))
  end

  function Private.GetErrorHandlerId(id, context)
    currentErrorHandlerUid = nil
    currentErrorHandlerId = id
    currentErrorHandlerContext = context
    return waErrorHandler
  end
  function Private.GetErrorHandlerUid(uid, context)
    currentErrorHandlerUid = uid
    currentErrorHandlerId = nil
    currentErrorHandlerContext = context
    return waErrorHandler
  end
end

function Private.LoadOptions(msg)
  if not(C_AddOns.IsAddOnLoaded("WeakAurasOptions")) then
    if not WeakAuras.IsLoginFinished() then
      prettyPrint(Private.LoginMessage())
      loginQueue[#loginQueue + 1] = WeakAuras.OpenOptions
    elseif InCombatLockdown() then
      -- inform the user and queue ooc
      prettyPrint(L["Options will finish loading after combat ends."])
      queueshowooc = msg or "";
      Private.frames["Addon Initialization Handler"]:RegisterEvent("PLAYER_REGEN_ENABLED")
      return false;
    else
      local loaded, reason = C_AddOns.LoadAddOn("WeakAurasOptions");
      if not(loaded) then
        reason = string.lower("|cffff2020" .. _G["ADDON_" .. reason] .. "|r.")
        WeakAuras.prettyPrint(string.format(L["Options could not be loaded, the addon is %s"], reason));
        return false;
      end
    end
  end
  return true;
end

function WeakAuras.OpenOptions(msg)
  if Private.NeedToRepairDatabase() then
    StaticPopup_Show("WEAKAURAS_CONFIRM_REPAIR", nil, nil, {reason = "downgrade"})
  elseif (WeakAuras.IsLoginFinished() and Private.LoadOptions(msg)) then
    WeakAuras.ToggleOptions(msg, Private);
  end
end

function Private.PrintHelp()
  print(L["Usage:"])
  print(L["/wa help - Show this message"])
  print(L["/wa minimap - Toggle the minimap icon"])
  print(L["/wa pstart - Start profiling. Optionally include a duration in seconds after which profiling automatically stops. To profile the next combat/encounter, pass a \"combat\" or \"encounter\" argument."])
  print(L["/wa pstop - Finish profiling"])
  print(L["/wa pprint - Show the results from the most recent profiling"])
  print(L["/wa repair - Repair tool"])
  print(L["If you require additional assistance, please open a ticket on GitHub or visit our Discord at https://discord.gg/weakauras!"])
end

SLASH_WEAKAURAS1, SLASH_WEAKAURAS2 = "/weakauras", "/wa";
function SlashCmdList.WEAKAURAS(input)
  local args, msg = {}, nil

  for v in string.gmatch(input, "%S+") do
    if not msg then
      msg = v:lower()
    else
      insert(args, v:lower())
    end
  end

  if msg == "pstart" then
    WeakAuras.StartProfile(args[1]);
  elseif msg == "pstop" then
    WeakAuras.StopProfile();
  elseif msg == "pprint" then
    WeakAuras.PrintProfile();
  elseif msg == "pcancel" then
    WeakAuras.CancelScheduledProfile()
  elseif msg == "pshow" or msg == "profiling" then
    WeakAurasProfilingFrame:Toggle()
  elseif msg == "minimap" then
    WeakAuras.ToggleMinimap();
  elseif msg == "help" then
    Private.PrintHelp();
  elseif msg == "repair" then
    StaticPopup_Show("WEAKAURAS_CONFIRM_REPAIR", nil, nil, {reason = "user"})
  elseif msg == "ff" or msg == "feat" or msg == "feature" then
    if #args < 2 then
      local features = Private.Features:ListFeatures()
      local summary = {}
      for _, feature in ipairs(features) do
        table.insert(summary, ("|c%s%s|r"):format(feature.enabled and "ff00ff00" or "ffff0000", feature.id))
      end
      prettyPrint(L["Syntax /wa feature <toggle|on|enable|disable|off> <feature>"])
      prettyPrint(L["Available features: %s"]:format(table.concat(summary, ", ")))
    else
      local action = ({
        toggle = "toggle",
        on = "enable",
        enable = "enable",
        disable = "disable",
        off = "disable"
      })[args[1]]
      if not action then
        prettyPrint(L["Unknown action %q"]:format(args[1]))
      else
        local feature = args[2]
        if not Private.Features:Exists(feature) then
          prettyPrint(L["Unknown feature %q"]:format(feature))
        elseif not Private.Features:Enabled(feature) then
          if action ~= "disable" then
            Private.Features:Enable(feature)
            prettyPrint(L["Enabled feature %q"]:format(feature))
          else
            prettyPrint(L["Feature %q is already disabled"]:format(feature))
          end
        elseif Private.Features:Enabled(feature) then
          if action ~= "enable" then
            Private.Features:Disable(feature)
            prettyPrint(L["Disabled feature %q"]:format(feature))
          else
            prettyPrint(L["Feature %q is already enabled"]:format(feature))
          end
        end
      end
    end
  else
    WeakAuras.OpenOptions(msg);
  end
end

if not WeakAuras.IsLibsOK() then return end

function WeakAuras.ToggleMinimap()
  WeakAurasSaved.minimap.hide = not WeakAurasSaved.minimap.hide
  if WeakAurasSaved.minimap.hide then
    LDBIcon:Hide("WeakAuras");
    prettyPrint(L["Use /wa minimap to show the minimap icon again."])
  else
    LDBIcon:Show("WeakAuras");
  end
end

BINDING_HEADER_WEAKAURAS = ADDON_NAME
BINDING_NAME_WEAKAURASTOGGLE = L["Toggle Options Window"]
BINDING_NAME_WEAKAURASPROFILINGTOGGLE = L["Toggle Performance Profiling Window"]
BINDING_NAME_WEAKAURASPRINTPROFILING = L["Print Profiling Results"]

-- An alias for WeakAurasSaved, the SavedVariables
-- Noteable properties:
--  debug: If set to true, WeakAura.debug() outputs messages to the chat frame
--  displays: All aura settings, keyed on their id

---@class WeakAurasSaved
local db;

-- While true no events are handled. E.g. WeakAuras is paused while the Options dialog is open
local paused = true;
local importing = false;

-- squelches actions and sounds from auras. is used e.g. to prevent lots of actions/sounds from triggering
-- on login or after closing the options dialog
local squelch_actions = true;
local in_loading_screen = false;

-- Load functions, keyed on id
local loadFuncs = {};
-- Load functions for the Options window that ignore various load options
local loadFuncsForOptions = {};
-- Mapping of events to ids, contains true if a aura should be checked for a certain event
local loadEvents = {}

-- All regions keyed on id, has properties: region, regionType, also see clones
Private.regions = {};

-- keyed on id, contains bool indicating whether the aura is loaded
Private.loaded = {};
local loaded = Private.loaded;

-- contains regions for clones
Private.clones = {};
local clones = Private.clones;

-- Unused regions that are kept around for clones
local clonePool = {}

-- One table per regionType, see RegisterRegionType, notable properties: create, modify and default
Private.regionTypes = {};
local regionTypes = Private.regionTypes;

Private.subRegionTypes = {}
local subRegionTypes = Private.subRegionTypes

-- One table per regionType, see RegisterRegionOptions
Private.regionOptions = {};
local regionOptions = Private.regionOptions;

Private.subRegionOptions = {}
local subRegionOptions = Private.subRegionOptions

-- Maps from trigger type to trigger system
Private.triggerTypes = {};
local triggerTypes = Private.triggerTypes;

-- Maps from trigger type to a function that can create options for the trigger
Private.triggerTypesOptions = {};

-- Trigger State, updated by trigger systems, then applied to regions by UpdatedTriggerState
-- keyed on id, triggernum, cloneid
-- cloneid can be a empty string

-- Noteable properties:
--  changed: Whether this trigger state was recently changed and its properties
--           need to be applied to a region. The glue code resets this
--           after syncing the region to the trigger state
--  show: Whether the region for this trigger state should be shown
--  progressType: Either "timed", "static"
--    duration: The duration if the progressType is timed
--    expirationTime: The expirationTime if the progressType is timed
--    autoHide: If the aura should be hidden on expiring
--    value: The value if the progressType is static
--    total: The total if the progressType is static
--    inverse: The static values should be interpreted inversely
--  name: The name information
--  icon: The icon information
--  texture: The texture information
--  stacks: The stacks information
--  index: The index of the buff/debuff for the buff trigger system, used to set the tooltip
--  spellId: spellId of the buff/debuff, used to set the tooltip

local triggerState = {}

-- Fallback states
local fallbacksStates = {};

-- List of all trigger systems, contains each system once
local triggerSystems = {}

local timers = {}; -- Timers for autohiding, keyed on id, triggernum, cloneid

WeakAuras.raidUnits = {};
WeakAuras.raidpetUnits = {};
WeakAuras.partyUnits = {};
WeakAuras.partypetUnits = {};
WeakAuras.petUnitToUnit = {
  pet = "player"
}
WeakAuras.unitToPetUnit = {
  player = "pet"
}
do
  for i=1,40 do
    WeakAuras.raidUnits[i] = "raid"..i
    WeakAuras.raidpetUnits[i] = "raidpet"..i
    WeakAuras.petUnitToUnit["raidpet"..i] = "raid"..i
    WeakAuras.unitToPetUnit["raid"..i] = "raidpet"..i
  end
  for i=1,4 do
    WeakAuras.partyUnits[i] = "party"..i
    WeakAuras.partypetUnits[i] = "partypet"..i
    WeakAuras.petUnitToUnit["partypet"..i] = "party"..i
    WeakAuras.unitToPetUnit["party"..i] = "partypet"..i
  end
end

---@param unit UnitToken
---@return boolean isPet
WeakAuras.UnitIsPet = function(unit)
  return WeakAuras.petUnitToUnit[unit] ~= nil
end

local playerLevel = UnitLevel("player");
local currentInstanceType = "none"

-- Custom Action Functions, keyed on id, "init" / "start" / "finish"
Private.customActionsFunctions = {};

-- Custom Functions used in conditions, keyed on id, condition number, "changes", property number
Private.ExecEnv.customConditionsFunctions = {};
-- Text format functions for chat messages, keyed on id, condition number, changes, property number
Private.ExecEnv.conditionTextFormatters = {}

-- Helpers for conditions, that is custom run functions and preamble objects for built in checks
-- keyed on UID not on id!
Private.ExecEnv.conditionHelpers = {}

local load_prototype = Private.load_prototype;

function Private.validate(input, default)
  for field, defaultValue in pairs(default) do
    if(type(defaultValue) == "table" and type(input[field]) ~= "table") then
      input[field] = {};
    elseif(input[field] == nil) or (type(input[field]) ~= type(defaultValue)) then
      input[field] = defaultValue;
    end
    if(type(input[field]) == "table") then
      Private.validate(input[field], defaultValue);
    end
  end
end

---@diagnostic disable-next-line: duplicate-set-field
function Private.RegisterRegionType(name, createFunction, modifyFunction, default, properties, validate)
  if not(name) then
    error("Improper arguments to Private.RegisterRegionType - name is not defined", 2);
  elseif(type(name) ~= "string") then
    error("Improper arguments to Private.RegisterRegionType - name is not a string", 2);
  elseif not(createFunction) then
    error("Improper arguments to Private.RegisterRegionType - creation function is not defined", 2);
  elseif(type(createFunction) ~= "function") then
    error("Improper arguments to Private.RegisterRegionType - creation function is not a function", 2);
  elseif not(modifyFunction) then
    error("Improper arguments to Private.RegisterRegionType - modification function is not defined", 2);
  elseif(type(modifyFunction) ~= "function") then
    error("Improper arguments to Private.RegisterRegionType - modification function is not a function", 2)
  elseif not(default) then
    error("Improper arguments to Private.RegisterRegionType - default options are not defined", 2);
  elseif(type(default) ~= "table") then
    error("Improper arguments to Private.RegisterRegionType - default options are not a table", 2);
  elseif(type(default) ~= "table" and type(default) ~= "nil") then
    error("Improper arguments to Private.RegisterRegionType - properties options are not a table", 2);
  elseif(regionTypes[name]) then
    error("Improper arguments to Private.RegisterRegionType - region type \""..name.."\" already defined", 2);
  else
    regionTypes[name] = {
      create = createFunction,
      modify = modifyFunction,
      default = default,
      validate = validate,
      properties = properties,
    };
  end
end

---@private
---@param name string
---@param displayName string
---@param supportFunction function
---@param createFunction function
---@param modifyFunction function
---@param onAcquire function
---@param onRelease function
---@param default table
---@param addDefaultsForNewAura function
---@param properties table
---@param supportsAdd? boolean
function WeakAuras.RegisterSubRegionType(name, displayName, supportFunction, createFunction, modifyFunction, onAcquire, onRelease, default, addDefaultsForNewAura, properties, supportsAdd)
  if not(name) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - name is not defined", 2);
  elseif(type(name) ~= "string") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - name is not a string", 2);
  elseif not(displayName) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - display name is not defined".." "..name, 2);
  elseif(type(displayName) ~= "string") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - display name is not a string", 2);
  elseif not(supportFunction) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - support function is not defined", 2);
  elseif(type(supportFunction) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - support function is not a function", 2);
  elseif not(createFunction) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - creation function is not defined", 2);
  elseif(type(createFunction) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - creation function is not a function", 2);
  elseif not(modifyFunction) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - modification function is not defined", 2);
  elseif(type(modifyFunction) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - modification function is not a function", 2)
  elseif not(onAcquire) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - onAcquire function is not defined", 2);
  elseif(type(onAcquire) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - onAcquire function is not a function", 2)
  elseif not(onRelease) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - onRelease function is not defined", 2);
  elseif(type(onRelease) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - onRelease function is not a function", 2)
  elseif not(default) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - default options are not defined", 2);
  elseif(type(default) ~= "table" and type(default) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - default options are not a table or a function", 2);
  elseif(addDefaultsForNewAura and type(addDefaultsForNewAura) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - addDefaultsForNewAura function is not nil or a function", 2)
  elseif(subRegionTypes[name]) then
    error("Improper arguments to WeakAuras.RegisterSubRegionType - region type \""..name.."\" already defined", 2);
  else
    local pool = CreateObjectPool(createFunction)

    subRegionTypes[name] = {
      displayName = displayName,
      supports = supportFunction,
      modify = modifyFunction,
      default = default,
      addDefaultsForNewAura = addDefaultsForNewAura,
      properties = properties,
      supportsAdd = supportsAdd == nil or supportsAdd,
      acquire = function()
        local subRegion = pool:Acquire()
        onAcquire(subRegion)
        subRegion.type = name
        return subRegion
      end,
      release = function(subRegion)
        onRelease(subRegion)
        pool:Release(subRegion)
      end
    };
  end
end

---@diagnostic disable-next-line: duplicate-set-field
function Private.RegisterRegionOptions(name, createFunction, icon, displayName, createThumbnail, modifyThumbnail, description, templates, getAnchors)
  if not(name) then
    error("Improper arguments to Private.RegisterRegionOptions - name is not defined", 2);
  elseif(type(name) ~= "string") then
    error("Improper arguments to Private.RegisterRegionOptions - name is not a string", 2);
  elseif not(createFunction) then
    error("Improper arguments to Private.RegisterRegionOptions - creation function is not defined", 2);
  elseif(type(createFunction) ~= "function") then
    error("Improper arguments to Private.RegisterRegionOptions - creation function is not a function", 2);
  elseif not(icon) then
    error("Improper arguments to Private.RegisterRegionOptions - icon is not defined", 2);
  elseif not(type(icon) == "string" or type(icon) == "function") then
    error("Improper arguments to Private.RegisterRegionOptions - icon is not a string or a function", 2)
  elseif not(displayName) then
    error("Improper arguments to Private.RegisterRegionOptions - display name is not defined".." "..name, 2);
  elseif(type(displayName) ~= "string") then
    error("Improper arguments to Private.RegisterRegionOptions - display name is not a string", 2);
  elseif (getAnchors and type(getAnchors) ~= "function") then
    error("Improper arguments to Private.RegisterRegionOptions - anchors is not a function", 2);
  elseif(regionOptions[name]) then
    error("Improper arguments to Private.RegisterRegionOptions - region type \""..name.."\" already defined", 2);
  else
    local templateIcon
    if (type(icon) == "function") then
      -- We only want to create two icons and reparent it as needed
      templateIcon = icon()
      templateIcon:Hide()
      icon = icon()
      icon:Hide()
    else
      templateIcon = icon
    end

    local acquireThumbnail, releaseThumbnail
    if createThumbnail and modifyThumbnail then
      local thumbnailPool = CreateObjectPool(createThumbnail)
      acquireThumbnail = function(parent, data)
        local thumbnail, newObject = thumbnailPool:Acquire()
        thumbnail:Show()
        modifyThumbnail(parent, thumbnail, data)
        return thumbnail
      end
      releaseThumbnail = function(thumbnail)
        thumbnail:Hide()
        thumbnailPool:Release(thumbnail)
      end
    end
    regionOptions[name] = {
      create = createFunction,
      icon = icon,
      templateIcon = templateIcon,
      displayName = displayName,
      createThumbnail = createThumbnail,
      modifyThumbnail = modifyThumbnail,
      acquireThumbnail = acquireThumbnail,
      releaseThumbnail = releaseThumbnail,
      description = description,
      templates = templates,
      getAnchors = getAnchors
    };
  end
end

---@private
---@param name string
---@param createFunction function
---@param description string
---@param getAnchors function?
function WeakAuras.RegisterSubRegionOptions(name, createFunction, description, getAnchors)
  if not(name) then
    error("Improper arguments to WeakAuras.RegisterSubRegionOptions - name is not defined", 2);
  elseif(type(name) ~= "string") then
    error("Improper arguments to WeakAuras.RegisterSubRegionOptions - name is not a string", 2);
  elseif not(createFunction) then
    error("Improper arguments to WeakAuras.RegisterSubRegionOptions - creation function is not defined", 2);
  elseif(type(createFunction) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionOptions - creation function is not a function", 2);
  elseif(getAnchors and type(getAnchors) ~= "function") then
    error("Improper arguments to WeakAuras.RegisterSubRegionOptions - getAnchors function is not a function", 2);
  elseif(subRegionOptions[name]) then
    error("Improper arguments to WeakAuras.RegisterSubRegionOptions - region type \""..name.."\" already defined", 2);
  else
    subRegionOptions[name] = {
      create = createFunction,
      getAnchors = getAnchors,
      description = description,
    };
  end
end

---@diagnostic disable-next-line: duplicate-set-field (it's replaced in WeakAurasOptions.lua)
function WeakAuras.IsOptionsOpen()
  return false;
end

function Private.ParseNumber(numString)
  if not(numString and type(numString) == "string") then
    if(type(numString) == "number") then
      return numString, "notastring";
    else
      return nil;
    end
  elseif(numString:sub(-1) == "%") then
    local percent = tonumber(numString:sub(1, -2));
    if(percent) then
      return percent / 100, "percent";
    else
      return nil;
    end
  else
    -- Matches any string with two integers separated by a forward slash
    -- Captures the two integers
    local _, _, numerator, denominator = numString:find("(%d+)%s*/%s*(%d+)");
    numerator, denominator = tonumber(numerator), tonumber(denominator);
    if(numerator and denominator) then
      if(denominator == 0) then
        return nil;
      else
        return numerator / denominator, "fraction";
      end
    else
      local num = tonumber(numString)
      if(num) then
        if(math.floor(num) ~= num) then
          return num, "decimal";
        else
          return num, "whole";
        end
      else
        return nil;
      end
    end
  end
end

local function EvalBooleanArg(arg, trigger, default)
  if(type(arg) == "function") then
    return arg(trigger);
  elseif type(arg) == "boolean" then
    return arg
  elseif type(arg) == "nil" then
    return default
  end
end

local function singleTest(arg, trigger, use, name, value, operator, use_exact, caseInsensitive)
  local number = value and tonumber(value) or nil
  if(arg.type == "tristate") then
    if(use == false) then
      return "(not "..name..")";
    elseif(use) then
      if(arg.test) then
        return "("..arg.test:format(value)..")";
      else
        return name;
      end
    end
  elseif(arg.type == "tristatestring") then
    if(use == false) then
      return "("..name.. "~=".. (number or string.format("%s", Private.QuotedString(value or ""))) .. ")"
    elseif(use) then
      return "("..name.. "==".. (number or string.format("%s", Private.QuotedString(value or ""))) .. ")"
    end
  elseif(arg.type == "multiselect") then
    if arg.multiNoSingle then
      -- convert single to multi
      -- this is a lazy migration because multiNoSingle is not set for all game versions
      if use == true then
        trigger["use_"..name] = false
        trigger[name] = trigger[name] or {}
        trigger[name].multi = {};
        if trigger[name].single ~= nil then
          trigger[name].multi[trigger[name].single] = true;
          trigger[name].single = nil
        end
      end
    end
    if(use == false) then -- multi selection
      local any = false;
      if (value and value.multi) then
        local test = "(";
        for value, positive in pairs(value.multi) do
          local arg1 = tonumber(value) or ("[["..value.."]]")
          local arg2
          if arg.extraOption then
            arg2 = trigger[name .. "_extraOption"] or 0
          elseif arg.multiTristate then
            arg2 = positive and 4 or 5
          end
          local testEnabled = true
          if type(arg.enableTest) == "function" then
            testEnabled = arg.enableTest(trigger, arg1, arg2)
          end
          if testEnabled then
            local check
            if not arg.test then
              check = name.."=="..arg1
            else
              check = arg.test:format(arg1, arg2)
            end
            if arg.multiAll then
              test = test..check.." and "
            else
              test = test..check.." or  "
            end
            any = true;
          end
        end
        if(any) then
          test = test:sub(1, -6);
        else
          test = "(false";
        end
        test = test..")"
        if arg.inverse then
          if type(arg.inverse) == "boolean" then
            test = "not " .. test
          elseif type(arg.inverse) == "function" then
            if arg.inverse(trigger) then
              test = "not " .. test
            end
          end
        end
        return test
      end
    elseif(use) then -- single selection
      local value = value and value.single or nil;
      if not arg.test then
        return value and "("..name.."=="..(tonumber(value) or ("[["..value.."]]"))..")";
      else
        return value and "("..arg.test:format(tonumber(value) or ("[["..value.."]]"))..")";
      end
    end
  elseif(arg.type == "toggle") then
    if(use) then
      if(arg.test) then
        return "("..arg.test:format(value)..")";
      else
        return name;
      end
    end
  elseif (arg.type == "spell") then
    if arg.showExactOption then
      return "("..arg.test:format(value, tostring(use_exact) or "false") ..")";
    else
      return "("..arg.test:format(value)..")";
    end
  elseif(arg.test) then
    return "("..arg.test:format(value)..")";
  elseif(arg.type == "longstring" and operator) then
    if(operator == "==") then
      if caseInsensitive then
        return ("(%s and %s:lower() == [[%s]]:lower())"):format(name, name, value)
      else
        return "("..name.."==[["..value.."]])";
      end
    else
      if caseInsensitive then
        local op = operator:format(value:lower())
        return ("(%s:lower():%s)"):format(name, op)
      else
        return "("..name..":"..operator:format(value)..")";
      end
    end
  elseif(arg.type == "number") then
    if number then
      return "("..name..(operator or "==").. number ..")";
    end
  else
    if(type(value) == "table") then
      value = "error";
    end
    return "("..name..(operator or "==")..(number or ("[["..(value or "").."]]"))..")";
  end
end

-- Used for the load function, could be simplified a bit
-- It used to be also used for the generic trigger system
local function ConstructFunction(prototype, trigger, skipOptional)
  local input = {"event"};
  local required = {};
  local tests = {};
  local debug = {};
  local events = {}
  local init;
  local preambles = ""
  local orConjunctionGroups = {}
  if(prototype.init) then
    init = prototype.init(trigger);
  else
    init = "";
  end
  for index, arg in pairs(prototype.args) do
    local enable = EvalBooleanArg(arg.enable, trigger, true)
    local init = arg.init
    local name = arg.name;
    if(arg.init == "arg") then
      tinsert(input, name);
    end

    if(enable) then
      if (arg.optional and skipOptional) then
      -- Do nothing
      elseif arg.type == "tristate"
        or arg.type == "toggle"
        or arg.type == "tristatestring"
        or (arg.type == "multiselect" and trigger["use_"..name] ~= nil)
        or ((trigger["use_"..name] or arg.required) and trigger[name])
      then
        local test;

        if arg.multiEntry then
          if type(trigger[name]) == "table" and #trigger[name] > 0 then
            test = ""
            for i, value in ipairs(trigger[name]) do
              local operator = name and type(trigger[name.."_operator"]) == "table" and trigger[name.."_operator"][i]
              local caseInsensitive = name and arg.canBeCaseInsensitive and type(trigger[name.."_caseInsensitive"]) == "table" and trigger[name.."_caseInsensitive"][i]
              local use_exact = name and type(trigger["use_exact_" .. name]) == "table" and trigger["use_exact_" .. name][i]
              local use = name and trigger["use_"..name]
              local single = singleTest(arg, trigger, use, name, value, operator, use_exact, caseInsensitive)
              if single then
                if test ~= "" then
                  test = test .. arg.multiEntry.operator
                end
                test = test .. single
              end
            end
            if test == "" then
              test = nil
            else
              test = "(" .. test .. ")"
            end
          end
        else
          local value = trigger[name]
          local operator = name and trigger[name.."_operator"]
          local caseInsensitive = name and trigger[name.."_caseInsensitive"]
          local use_exact = name and trigger["use_exact_" .. name]
          local use = name and trigger["use_"..name]
          test = singleTest(arg, trigger, use, name, value, operator, use_exact, caseInsensitive)
        end

        if (arg.preamble) then
          preambles = preambles .. arg.preamble:format(trigger[name]) .. "\n"
        end

        if test ~= "(test)" then
          if(arg.required) then
            tinsert(required, test);
          elseif test ~= nil then
            if arg.orConjunctionGroup then
              orConjunctionGroups[arg.orConjunctionGroup ] = orConjunctionGroups[arg.orConjunctionGroup ] or {}
              tinsert(orConjunctionGroups[arg.orConjunctionGroup ], test)
            else
              tinsert(tests, test);
            end
          end
        end

        if test and arg.events then
          for index, event in ipairs(arg.events) do
            events[event] = true
          end
        end

        if(arg.debug) then
          tinsert(debug, arg.debug:format(trigger[name]));
        end
      end
    end
  end

  for _, orConjunctionGroup  in pairs(orConjunctionGroups) do
    tinsert(tests, "("..table.concat(orConjunctionGroup , " or ")..")")
  end
  local ret = {preambles .. "return function("..table.concat(input, ", ")..")\n"};
  table.insert(ret, (init or ""));
  table.insert(ret, (#debug > 0 and table.concat(debug, "\n") or ""));
  table.insert(ret, "if(");
  table.insert(ret, ((#required > 0) and table.concat(required, " and ").." and " or ""));
  table.insert(ret, (#tests > 0 and table.concat(tests, " and ") or "true"));
  table.insert(ret, ") then\n");
  if(#debug > 0) then
    table.insert(ret, "print('ret: true');\n");
  end
  table.insert(ret, "return true else return false end end");

  return table.concat(ret), events;
end

function WeakAuras.GetActiveConditions(id, cloneId)
  triggerState[id].activatedConditions[cloneId] = triggerState[id].activatedConditions[cloneId] or {};
  return triggerState[id].activatedConditions[cloneId];
end

local function LoadCustomActionFunctions(data)
  local id = data.id;
  Private.customActionsFunctions[id] = {};

  if (data.actions) then
    if data.actions.init then
      if data.actions.init.do_custom and data.actions.init.custom then
        local func = WeakAuras.LoadFunction("return function() "..(data.actions.init.custom).."\n end", data.id);
        Private.customActionsFunctions[id]["init"] = func
      end
      if data.actions.init.do_custom_load and data.actions.init.customOnLoad then
        local func = WeakAuras.LoadFunction("return function() "..(data.actions.init.customOnLoad).."\n end", data.id);
        Private.customActionsFunctions[id]["load"] = func
      end
      if data.actions.init.do_custom_unload and data.actions.init.customOnUnload then
        local func = WeakAuras.LoadFunction("return function() "..(data.actions.init.customOnUnload).."\n end", data.id);
        Private.customActionsFunctions[id]["unload"] = func
      end
    end

    if (data.actions.start) then
      if (data.actions.start.do_custom and data.actions.start.custom) then
        local func = WeakAuras.LoadFunction("return function() "..(data.actions.start.custom).."\n end", data.id);
        Private.customActionsFunctions[id]["start"] = func;
      end

      if (data.actions.start.do_message and data.actions.start.message_custom) then
        local func = WeakAuras.LoadFunction("return "..(data.actions.start.message_custom), data.id);
        Private.customActionsFunctions[id]["start_message"] = func;
      end
    end

    if (data.actions.finish) then
      if (data.actions.finish.do_custom and data.actions.finish.custom) then
        local func = WeakAuras.LoadFunction("return function() "..(data.actions.finish.custom).."\n end", data.id);
        Private.customActionsFunctions[id]["finish"] = func;
      end

      if (data.actions.finish.do_message and data.actions.finish.message_custom) then
        local func = WeakAuras.LoadFunction("return "..(data.actions.finish.message_custom), data.id);
        Private.customActionsFunctions[id]["finish_message"] = func;
      end
    end
  end
end

Private.talent_types_specific = {}
Private.pvp_talent_types_specific = {}
local function CreateTalentCache()
  local _, player_class = UnitClass("player")

  Private.talent_types_specific[player_class] = Private.talent_types_specific[player_class] or {};

  if WeakAuras.IsClassicOrCata() then
    for tab = 1, GetNumTalentTabs() do
      for num_talent = 1, GetNumTalents(tab) do
        local talentName, talentIcon = Private.ExecEnv.GetTalentInfo(tab, num_talent);
        local talentId = (tab - 1) * MAX_NUM_TALENTS + num_talent
        if (talentName and talentIcon) then
          Private.talent_types_specific[player_class][talentId] = "|T"..talentIcon..":0|t "..talentName
        end
      end
    end
  elseif WeakAuras.IsMists() then
    -- unused
  else
    local spec = GetSpecialization()
    Private.talent_types_specific[player_class][spec] = Private.talent_types_specific[player_class][spec] or {};

    for tier = 1, MAX_TALENT_TIERS do
      for column = 1, NUM_TALENT_COLUMNS do
        -- Get name and icon info for the current talent of the current class and save it
        local _, talentName, talentIcon = Private.ExecEnv.GetTalentInfo(tier, column, 1)
        local talentId = (tier-1)*3+column
        -- Get the icon and name from the talent cache and record it in the table that will be used by WeakAurasOptions
        if (talentName and talentIcon) then
          Private.talent_types_specific[player_class][spec][talentId] = "|T"..talentIcon..":0|t "..talentName
        end
      end
    end
  end
end

local function CreatePvPTalentCache()
  local _, player_class = UnitClass("player")
  local spec = GetSpecialization()

  if (not player_class or not spec) then
    return;
  end

  Private.pvp_talent_types_specific[player_class] = Private.pvp_talent_types_specific[player_class] or {};
  Private.pvp_talent_types_specific[player_class][spec] = Private.pvp_talent_types_specific[player_class][spec] or {};

  --- @type fun(talentId: number): number, string
  local function formatTalent(talentId)
    local _, name, icon, _, _, spellId = GetPvpTalentInfoByID(talentId);
    return spellId, "|T"..icon..":0|t "..name
  end

  local slotInfo = C_SpecializationInfo.GetPvpTalentSlotInfo(1);
  if (slotInfo) then
    Private.pvp_talent_types_specific[player_class][spec] = {};

    local pvpSpecTalents = slotInfo.availableTalentIDs;
    for _, talentId in ipairs(pvpSpecTalents) do
      local index, displayText = formatTalent(talentId)
      Private.pvp_talent_types_specific[player_class][spec][index] = displayText
    end
  end
end

Private.CompanionData = {}
-- use this function to not overwrite data from other companion compatible addons
-- when using this function, do not name your global data table "WeakAurasCompanion"
function WeakAuras.AddCompanionData(data)
  WeakAuras.DeepMixin(Private.CompanionData, data)
end

-- add data from versions of companion compatible addon that does not use WeakAuras.AddCompanionData yet
local function AddLegacyCompanionData()
  local CompanionData = WeakAurasCompanion and WeakAurasCompanion.WeakAuras or WeakAurasCompanion
  if CompanionData then
    WeakAuras.AddCompanionData(CompanionData)
  end
end

function Private.PostAddCompanion()
  -- add data from older version of companion addons
  AddLegacyCompanionData()
  -- nag if updates
  local count = Private.CountWagoUpdates()
  if count and count > 0 then
    WeakAuras.prettyPrint(L["There are %i updates to your auras ready to be installed!"]:format(count))
  end
  -- nag if new installs
  if Private.CompanionData.stash and next(Private.CompanionData.stash) then
    WeakAuras.prettyPrint(L["You have new auras ready to be installed!"])
  end
end

function Private.CountWagoUpdates()
  if not (Private.CompanionData.slugs) then
    return 0
  end
  local updatedSlugs, updatedSlugsCount = {}, 0
  for id, aura in pairs(db.displays) do
    if not aura.ignoreWagoUpdate and aura.url and aura.url ~= "" then
      local slug, version = aura.url:match("wago.io/([^/]+)/([0-9]+)")
      if not slug and not version then
        slug = aura.url:match("wago.io/([^/]+)$")
        version = 1
      end
      if slug and version then
        local wago = Private.CompanionData.slugs[slug]
        if wago and wago.wagoVersion and tonumber(wago.wagoVersion) > tonumber(version) then
          if not updatedSlugs[slug] then
            updatedSlugs[slug] = true
            updatedSlugsCount = updatedSlugsCount + 1
          end
        end
      end
    end
  end

  return updatedSlugsCount
end

local function tooltip_draw(isAddonCompartment, blizzardTooltip)
  local tooltip
  if isAddonCompartment then
    tooltip = blizzardTooltip
  else
    tooltip = GameTooltip
  end
  tooltip:ClearLines()
  tooltip:AddDoubleLine("WeakAuras", versionString)
  if Private.CompanionData.slugs then
    local count = Private.CountWagoUpdates()
    if count > 0 then
      tooltip:AddLine(" ");
      tooltip:AddLine((L["There are %i updates to your auras ready to be installed!"]):format(count));
    end
  end
  tooltip:AddLine(" ");
  tooltip:AddLine(L["|cffeda55fLeft-Click|r to toggle showing the main window."], 0.2, 1, 0.2);
  if not WeakAuras.IsOptionsOpen() then
    if paused then
      tooltip:AddLine("|cFFFF0000"..L["Paused"].." - "..L["Shift-Click to resume addon execution."], 0.2, 1, 0.2);
    else
      tooltip:AddLine(L["|cffeda55fShift-Click|r to pause addon execution."], 0.2, 1, 0.2);
    end
  end
  tooltip:AddLine(L["|cffeda55fRight-Click|r to toggle performance profiling window."], 0.2, 1, 0.2);
  if not isAddonCompartment then
    tooltip:AddLine(L["|cffeda55fMiddle-Click|r to toggle the minimap icon on or off."], 0.2, 1, 0.2);
  end
  tooltip:Show();
end

WeakAuras.GenerateTooltip = tooltip_draw;

local colorFrame = CreateFrame("Frame");
Private.frames["LDB Icon Recoloring"] = colorFrame;

local colorElapsed = 0;
local colorDelay = 2;
local r, g, b = 0.8, 0, 1;
local r2, g2, b2 = random(2)-1, random(2)-1, random(2)-1;

local tooltip_update_frame = CreateFrame("Frame");
Private.frames["LDB Tooltip Updater"] = tooltip_update_frame;

-- function copied from LibDBIcon-1.0.lua
local function getAnchors(frame)
	local x, y = frame:GetCenter()
	if not x or not y then return "CENTER" end
	local hHalf = (x > UIParent:GetWidth()*2/3) and "RIGHT" or (x < UIParent:GetWidth()/3) and "LEFT" or ""
	local vHalf = (y > UIParent:GetHeight()/2) and "TOP" or "BOTTOM"
	return vHalf..hHalf, frame, (vHalf == "TOP" and "BOTTOM" or "TOP")..hHalf
end

local Broker_WeakAuras;
Broker_WeakAuras = LDB:NewDataObject("WeakAuras", {
  type = "launcher",
  text = "WeakAuras",
  icon = "Interface\\AddOns\\WeakAuras\\Media\\Textures\\icon.blp",
  OnClick = function(self, button)
    if button == 'LeftButton' then
      if(IsShiftKeyDown()) then
        if not(WeakAuras.IsOptionsOpen()) then
          WeakAuras.Toggle();
        end
      else
        WeakAuras.OpenOptions();
      end
    elseif(button == 'MiddleButton') then
      WeakAuras.ToggleMinimap();
    else
      WeakAurasProfilingFrame:Toggle()
    end
    tooltip_draw()
  end,
  OnEnter = function(self)
    colorFrame:SetScript("OnUpdate", function(self, elaps)
      colorElapsed = colorElapsed + elaps;
      if(colorElapsed > colorDelay) then
        colorElapsed = colorElapsed - colorDelay;
        r, g, b = r2, g2, b2;
        r2, g2, b2 = random(2)-1, random(2)-1, random(2)-1;
      end
      Broker_WeakAuras.iconR = r + (r2 - r) * colorElapsed / colorDelay;
      Broker_WeakAuras.iconG = g + (g2 - g) * colorElapsed / colorDelay;
      Broker_WeakAuras.iconB = b + (b2 - b) * colorElapsed / colorDelay;
    end);
    local elapsed = 0;
    local delay = 1;
    tooltip_update_frame:SetScript("OnUpdate", function(self, elap)
      elapsed = elapsed + elap;
      if(elapsed > delay) then
        elapsed = 0;
        tooltip_draw();
      end
    end);
    GameTooltip:SetOwner(self, "ANCHOR_NONE");
    GameTooltip:SetPoint(getAnchors(self))
    tooltip_draw();
  end,
  OnLeave = function(self)
    colorFrame:SetScript("OnUpdate", nil);
    tooltip_update_frame:SetScript("OnUpdate", nil);
    GameTooltip:Hide();
  end,
  iconR = 0.6,
  iconG = 0,
  iconB = 1
});

do -- Archive stuff
  local Archivist = select(2, ...).Archivist
  local function OpenArchive()
    if Archivist:IsInitialized() then
      return Archivist
    else
      if not C_AddOns.IsAddOnLoaded("WeakAurasArchive") then
        local ok, reason = C_AddOns.LoadAddOn("WeakAurasArchive")
        if not ok then
          reason = string.lower("|cffff2020" .. _G["ADDON_" .. reason] .. "|r.")
          error(string.format(L["Could not load WeakAuras Archive, the addon is %s"], reason))
        end
      end
      if type(WeakAurasArchive) ~= "table" then
        WeakAurasArchive = {}
      end
      Archivist:Initialize(WeakAurasArchive)
    end
    return Archivist
  end

  function WeakAuras.LoadFromArchive(storeType, storeID)
    local Archive = OpenArchive()
    return Archive:Load(storeType, storeID)
  end
end

local loginFinished, loginMessage = false, L["Options will open after the login process has completed."]

function WeakAuras.IsLoginFinished()
  return loginFinished
end

function Private.LoginMessage()
  return loginMessage
end

local function CheckForPreviousEncounter()
  if (UnitAffectingCombat ("player") or InCombatLockdown()) then
    for i = 1, 10 do
      if (UnitExists ("boss" .. i)) then
        local guid = UnitGUID ("boss" .. i)
        if (guid and db.CurrentEncounter.boss_guids [guid]) then
          -- we are in the same encounter
          WeakAuras.CurrentEncounter = db.CurrentEncounter
          return true
        end
      end
    end
    db.CurrentEncounter = nil
  else
    db.CurrentEncounter = nil
  end
end

function Private.Login(takeNewSnapshots)
  local loginThread = coroutine.create(function()
    Private.Pause();
    coroutine.yield(100)
    if db.history then
      local histRepo = WeakAuras.LoadFromArchive("Repository", "history")
      local migrationRepo = WeakAuras.LoadFromArchive("Repository", "migration")
      for uid, hist in pairs(db.history) do
        local histStore = histRepo:Set(uid, hist.data)
        local migrationStore = migrationRepo:Set(uid, hist.migration)
        coroutine.yield(1000, "login move old history")
      end
      -- history is now in archive so we can shrink WeakAurasSaved
      db.history = nil
    end


    Private.Features:Hydrate()
    coroutine.yield(3000, "login check uid corruption")

    local toAdd = {};
    loginFinished = false
    loginMessage = L["Options will open after the login process has completed."]
    for id, data in pairs(db.displays) do
      if(id ~= data.id) then
        print("|cFF8800FFWeakAuras|r detected a corrupt entry in WeakAuras saved displays - '"..tostring(id).."' vs '"..tostring(data.id).."'" );
        data.id = id;
      end

      tinsert(toAdd, data);
    end
    coroutine.yield(8000);

    Private.AddMany(toAdd, takeNewSnapshots);
    coroutine.yield(1000);

    -- check in case of a disconnect during an encounter.
    if (db.CurrentEncounter) then
      CheckForPreviousEncounter()
    end
    coroutine.yield(1000);
    Private.RegisterLoadEvents();
    coroutine.yield(10000);
    Private.Resume();
    coroutine.yield(100);

    local nextCallback = loginQueue[1];
    while nextCallback do
      tremove(loginQueue, 1);
      if type(nextCallback) == 'table' then
        nextCallback[1](unpack(nextCallback[2]))
      else
        nextCallback()
      end
      coroutine.yield(1000, "login post login callbacks");
      nextCallback = loginQueue[1];
    end

    loginFinished = true
    -- Tell Dynamic Groups that we are done with login
    for _, region in pairs(Private.regions) do
      if (region.region and region.region.RunDelayedActions) then
        region.region:RunDelayedActions();
        coroutine.yield(500, "login delayed region actions");
      end
    end
  end)

  Private.Threads:Immediate('login', loginThread, 15000, 1000)
end

local WeakAurasFrame = CreateFrame("Frame", "WeakAurasFrame", UIParent);
Private.frames["WeakAuras Main Frame"] = WeakAurasFrame;
WeakAurasFrame:SetAllPoints(UIParent);

local loadedFrame = CreateFrame("Frame");
Private.frames["Addon Initialization Handler"] = loadedFrame;
loadedFrame:RegisterEvent("ADDON_LOADED");
loadedFrame:RegisterEvent("PLAYER_LOGIN");
loadedFrame:RegisterEvent("PLAYER_LOGOUT")
loadedFrame:RegisterEvent("PLAYER_ENTERING_WORLD");
loadedFrame:RegisterEvent("LOADING_SCREEN_ENABLED");
loadedFrame:RegisterEvent("LOADING_SCREEN_DISABLED");
if WeakAuras.IsRetail() then
  loadedFrame:RegisterEvent("ACTIVE_TALENT_GROUP_CHANGED");
  loadedFrame:RegisterEvent("PLAYER_PVP_TALENT_UPDATE");
else
  loadedFrame:RegisterEvent("CHARACTER_POINTS_CHANGED");
  loadedFrame:RegisterEvent("SPELLS_CHANGED");
end
loadedFrame:SetScript("OnEvent", function(self, event, ...)
  if(event == "ADDON_LOADED") then
    if(... == ADDON_NAME) then
      ---@type WeakAurasSaved
      WeakAurasSaved = WeakAurasSaved or {};
      db = WeakAurasSaved;
      Private.db = db
      -- Defines the action squelch period after login
      -- Stored in SavedVariables so it can be changed by the user if they find it necessary
      db.login_squelch_time = db.login_squelch_time or 10;

      -- Deprecated fields with *lots* of data, clear them out
      db.iconCache = nil;
      db.iconHash = nil;
      db.tempIconCache = nil;
      db.dynamicIconCache = db.dynamicIconCache or {};

      db.displays = db.displays or {};
      db.registered = db.registered or {};
      db.features = db.features or {}
      db.migrationCutoff = db.migrationCutoff or 730
      db.historyCutoff = db.historyCutoff or 730

      Private.SyncParentChildRelationships();
      local isFirstUIDValidation = db.dbVersion == nil or db.dbVersion < 26;
      Private.ValidateUniqueDataIds(isFirstUIDValidation);

      if db.lastArchiveClear == nil then
        db.lastArchiveClear = time();
      elseif db.lastArchiveClear < time() - 2505600 --[[29 days]] then
        db.lastArchiveClear = time();
        Private.CleanArchive(db.historyCutoff, db.migrationCutoff);
      end
      db.minimap = db.minimap or { hide = false };
      LDBIcon:Register("WeakAuras", Broker_WeakAuras, db.minimap);
    end
  elseif(event == "PLAYER_LOGIN") then
    local dbIsValid, takeNewSnapshots
    if not db.dbVersion or db.dbVersion < internalVersion then
      -- db is out of date, will run any necessary migrations in AddMany
      db.dbVersion = internalVersion
      db.lastUpgrade = time()
      dbIsValid = true
      takeNewSnapshots = true
    elseif db.dbVersion > internalVersion then
      -- user has downgraded past a forwards-incompatible migration
      dbIsValid = false
    else
      -- db has same version as code, can commit to login
      dbIsValid = true
    end
    if dbIsValid then
      Private.Login(takeNewSnapshots)
    else
      -- db isn't valid. Request permission to run repair tool before logging in
      StaticPopup_Show("WEAKAURAS_CONFIRM_REPAIR", nil, nil, {reason = "downgrade"})
    end
  elseif event == "PLAYER_LOGOUT" then
    for id in pairs(db.displays) do
      Private.ClearAuraEnvironment(id)
    end
  elseif(event == "LOADING_SCREEN_ENABLED") then
    in_loading_screen = true;
  elseif(event == "LOADING_SCREEN_DISABLED") then
    in_loading_screen = false;
  else
    local callback
    if(event == "PLAYER_ENTERING_WORLD") then
      local isInitialLogin, isReloadingUi = ...
      -- Schedule events that need to be handled some time after login
      local now = GetTime()
      callback = function()
        local elapsed = GetTime() - now
        local remainingSquelch = db.login_squelch_time - elapsed
        if remainingSquelch > 0 then
          timer:ScheduleTimer(function() squelch_actions = false; end, remainingSquelch); -- No sounds while loading
        end
        CreateTalentCache() -- It seems that GetTalentInfo might give info about whatever class was previously being played, until PLAYER_ENTERING_WORLD
        Private.InitializeEncounterAndZoneLists()
      end
      if isInitialLogin or isReloadingUi then
        Private.PostAddCompanion()
      end
    elseif(event == "PLAYER_PVP_TALENT_UPDATE") then
      callback = CreatePvPTalentCache;
    elseif(event == "ACTIVE_TALENT_GROUP_CHANGED" or event == "CHARACTER_POINTS_CHANGED" or event == "SPELLS_CHANGED") then
      callback = CreateTalentCache;
    elseif(event == "PLAYER_REGEN_ENABLED") then
      callback = function()
        if (queueshowooc) then
          WeakAuras.OpenOptions(queueshowooc)
          queueshowooc = nil
          Private.frames["Addon Initialization Handler"]:UnregisterEvent("PLAYER_REGEN_ENABLED")
        end
      end
    end
    if WeakAuras.IsLoginFinished() then
      callback()
    else
      loginQueue[#loginQueue + 1] = callback
    end
  end
end)

function Private.SetImporting(b)
  importing = b;
end

function WeakAuras.IsImporting()
  return importing;
end

function WeakAuras.IsPaused()
  return paused;
end

function Private.Pause()
  for id, states in pairs(triggerState) do
    local changed
    for triggernum in ipairs(states) do
      changed = Private.SetAllStatesHidden(id, triggernum) or changed
    end
    if changed then
      Private.UpdatedTriggerState(id)
    end
  end

  paused = true;
end

function WeakAuras.Toggle()
  if(paused) then
    Private.Resume();
  else
    Private.Pause();
  end
end

function Private.SquelchingActions()
  return squelch_actions;
end

function WeakAuras.InLoadingScreen()
  return in_loading_screen;
end

function Private.PauseAllDynamicGroups()
  local suspended = {}
  for id, region in pairs(Private.regions) do
    if (region.region and region.region.Suspend) then
      region.region:Suspend();
      tinsert(suspended, id)
    end
  end
  return suspended
end

function Private.ResumeAllDynamicGroups(suspended)
  for _, id in ipairs(suspended) do
    local region = WeakAuras.GetRegion(id)
    if (region and region.Resume) then
      region:Resume();
    end
  end
end

-- Encounter stuff
local function StoreBossGUIDs()
  Private.StartProfileSystem("boss_guids")
  if (WeakAuras.CurrentEncounter and WeakAuras.CurrentEncounter.boss_guids) then
    for i = 1, 10 do
      if (UnitExists ("boss" .. i)) then
        local guid = UnitGUID ("boss" .. i)
        if (guid) then
          WeakAuras.CurrentEncounter.boss_guids [guid] = true
        end
      end
    end
    db.CurrentEncounter = WeakAuras.CurrentEncounter
  end
  Private.StopProfileSystem("boss_guids")
end

local function DestroyEncounterTable()
  if (WeakAuras.CurrentEncounter) then
    wipe(WeakAuras.CurrentEncounter)
  end
  WeakAuras.CurrentEncounter = nil
  db.CurrentEncounter = nil
end

local function CreateEncounterTable(encounter_id)
  local _, _, _, _, _, _, _, instanceId = GetInstanceInfo()
  ---@class CurrentEncounter
  ---@field encounterId number
  ---@field zone_id number
  ---@field boss_guids number[]
  WeakAuras.CurrentEncounter = {
    id = encounter_id,
    zone_id = instanceId,
    boss_guids = {},
  }
  timer:ScheduleTimer(StoreBossGUIDs, 2)

  return WeakAuras.CurrentEncounter
end

local pausedOptionsProcessing = false;
function Private.pauseOptionsProcessing(enable)
  pausedOptionsProcessing = enable;
end

function Private.IsOptionsProcessingPaused()
  return pausedOptionsProcessing;
end

function Private.ExecEnv.GroupType()
  if (IsInRaid()) then
    return "raid";
  end
  if (IsInGroup()) then
    return "group";
  end
  return "solo";
end

local function GetInstanceTypeAndSize()
  local size, difficulty
  local inInstance, Type = IsInInstance()
  local _, instanceType, difficultyIndex, _, _, _, _, instanceId = GetInstanceInfo()
  if inInstance or instanceType ~= "none" then
    size = Type
    -- WORKAROUND Tol'Viron arena returning a difficulty index of 1
    if Type == "arena" or Type == "pvp" then
      difficultyIndex = 0
    end
    local difficultyInfo = Private.difficulty_info[difficultyIndex]
    if difficultyInfo then
      size, difficulty = difficultyInfo.size, difficultyInfo.difficulty
    else
      if WeakAuras.IsRetail() then
        if size == "arena" then
          if C_PvP.IsRatedArena() and not IsArenaSkirmish() then
            size = "ratedarena"
          end
        elseif size == "pvp" then
          if C_PvP.IsRatedBattleground() then
            size = "ratedpvp"
          end
        end
      end
    end
    return size, difficulty, instanceType, instanceId, difficultyIndex
  end
  return "none", "none", nil, nil, 0
end

---@return string instanceType
function WeakAuras.InstanceType()
  return (GetInstanceTypeAndSize())
end

---@return string difficulty
function WeakAuras.InstanceDifficulty()
  return select(2, GetInstanceTypeAndSize())
end

---@return number? difficultyID
function WeakAuras.InstanceTypeRaw()
  return select(5, GetInstanceTypeAndSize())
end

local toLoad = {}
local toUnload = {};
local function scanForLoadsImpl(toCheck, event, arg1, ...)
  if (Private.IsOptionsProcessingPaused()) then
    return;
  end

  toCheck = toCheck or loadEvents[event or "SCAN_ALL"]

  -- PET_BATTLE_CLOSE fires twice at the end of a pet battle. IsInBattle evaluates to TRUE during the
  -- first firing, and FALSE during the second. I am not sure if this check is necessary, but the
  -- following IF statement limits the impact of the PET_BATTLE_CLOSE event to the second one.
  if (event == "PET_BATTLE_CLOSE" and C_PetBattles.IsInBattle()) then return end

  if (event == "PLAYER_LEVEL_UP") then
    playerLevel = arg1;
  end

  -- encounter id stuff, we are holding the current combat id to further load checks.
  -- there is three ways to unload: encounter_end / zone changed (hearthstone used) / reload or disconnect
  -- regen_enabled isn't good due to combat drop abilities such invisibility, vanish, fake death, etc.
  local encounter_id = WeakAuras.CurrentEncounter and WeakAuras.CurrentEncounter.id or 0

  if (event == "ENCOUNTER_START") then
    encounter_id = tonumber(arg1)
    CreateEncounterTable(encounter_id)
  elseif (event == "ENCOUNTER_END") then
    encounter_id = 0
    DestroyEncounterTable()
  end

  if toCheck == nil or next(toCheck) == nil then
    return
  end

  local player, realm, zone = UnitName("player"), GetRealmName(), GetRealZoneText()
  local guild = GetGuildInfo("player")
  --- @type boolean|number|nil, boolean|string|nil, boolean|string|nil, boolean|string
  local specId, role, position, raidRole = false, false, false, false
  --- @type boolean, boolean, boolean
  local inPetBattle, vehicle, vehicleUi = false, false, false
  --- @type boolean
  local dragonriding
  local zoneId = C_Map.GetBestMapForUnit("player")
  local zonegroupId = zoneId and C_Map.GetMapGroupID(zoneId)
  local minimapText = GetMinimapZoneText()
  local _, race = UnitRace("player")
  local faction = UnitFactionGroup("player")
  local _, class = UnitClass("player")
  local inCombat = UnitAffectingCombat("player")
  --- @type boolean
  local inEncounter = encounter_id ~= 0;
  local alive = not UnitIsDeadOrGhost('player')
  local raidMemberType = 0

  if UnitIsGroupLeader("player") then
    raidMemberType = 1
  end

  if UnitIsGroupAssistant("player") then
    raidMemberType = raidMemberType + 2
  end

  local mounted = IsMounted()
  if WeakAuras.IsClassicOrCataOrMists() then
    local raidID = UnitInRaid("player")
    if raidID then
      raidRole = select(10, GetRaidRosterInfo(raidID))
    end
    role = "none"
  end
  if WeakAuras.IsClassicEra() then
    vehicle = UnitOnTaxi('player')
  end
  if WeakAuras.IsCataOrMistsOrRetail() then
    vehicle = UnitInVehicle('player') or UnitOnTaxi('player') or false
    vehicleUi = UnitHasVehicleUI('player') or HasOverrideActionBar() or HasVehicleActionBar() or false
    specId, role, position = Private.LibSpecWrapper.SpecRolePositionForUnit("player")
  end
  if WeakAuras.IsMistsOrRetail() then
    inPetBattle = C_PetBattles.IsInBattle()
  end
  if WeakAuras.IsRetail() then
    dragonriding = Private.IsDragonriding()
  end

  local size, difficulty, instanceType, instanceId, difficultyIndex = GetInstanceTypeAndSize()

  if (WeakAuras.CurrentEncounter) then
    if (instanceId ~= WeakAuras.CurrentEncounter.zone_id and not inCombat) then
      encounter_id = 0
      DestroyEncounterTable()
    end
  end

  local group = Private.ExecEnv.GroupType()
  local groupSize = GetNumGroupMembers()

  local affixes, warmodeActive, effectiveLevel = 0, false, 0
  if WeakAuras.IsRetail() then
    effectiveLevel = UnitEffectiveLevel("player")
    affixes = C_ChallengeMode.IsChallengeModeActive() and select(2, C_ChallengeMode.GetActiveKeystoneInfo())
    warmodeActive = C_PvP.IsWarModeDesired();
  end

  local hardcore, runeEngraving = false, false
  if WeakAuras.IsClassicEra() then
    hardcore = C_GameRules.IsHardcoreActive()
    runeEngraving = C_Engraving.IsEngravingEnabled()
  end

  local changed = 0;
  local shouldBeLoaded, couldBeLoaded;
  local parentsToCheck = {}
  wipe(toLoad);
  wipe(toUnload);

  for id in pairs(toCheck) do
    local data = WeakAuras.GetData(id)
    if (data and not data.controlledChildren) then
      local loadFunc = loadFuncs[id];
      local loadOpt = loadFuncsForOptions[id];
      if WeakAuras.IsClassicEra() then
        shouldBeLoaded = loadFunc and loadFunc("ScanForLoads_Auras", inCombat, alive, inEncounter, vehicle, mounted, hardcore, runeEngraving, class, player, realm, guild, race, faction, playerLevel, raidRole, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size)
        couldBeLoaded =  loadOpt and loadOpt("ScanForLoads_Auras",   inCombat, alive, inEncounter, vehicle, mounted, hardcore, runeEngraving, class, player, realm, guild, race, faction, playerLevel, raidRole, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size)
      elseif WeakAuras.IsCataClassic() then
        shouldBeLoaded = loadFunc and loadFunc("ScanForLoads_Auras", inCombat, alive, inEncounter, vehicle, vehicleUi, mounted, class, specId, player, realm, guild, race, faction, playerLevel, role, position, raidRole, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size, difficulty, difficultyIndex)
        couldBeLoaded =  loadOpt and loadOpt("ScanForLoads_Auras",   inCombat, alive, inEncounter, vehicle, vehicleUi, mounted, class, specId, player, realm, guild, race, faction, playerLevel, role, position, raidRole, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size, difficulty, difficultyIndex)
      elseif WeakAuras.IsMists() then
        shouldBeLoaded = loadFunc and loadFunc("ScanForLoads_Auras", inCombat, alive, inEncounter, inPetBattle, vehicle, vehicleUi, mounted, class, specId, player, realm, guild, race, faction, playerLevel, role, position, raidRole, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size, difficulty, difficultyIndex)
        couldBeLoaded =  loadOpt and loadOpt("ScanForLoads_Auras",   inCombat, alive, inEncounter, inPetBattle, vehicle, vehicleUi, mounted, class, specId, player, realm, guild, race, faction, playerLevel, role, position, raidRole, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size, difficulty, difficultyIndex)
      elseif WeakAuras.IsRetail() then
        shouldBeLoaded = loadFunc and loadFunc("ScanForLoads_Auras", inCombat, alive, inEncounter, warmodeActive, inPetBattle, vehicle, vehicleUi, dragonriding, mounted, specId, player, realm, guild, race, faction, playerLevel, effectiveLevel, role, position, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size, difficulty, difficultyIndex, affixes)
        couldBeLoaded =  loadOpt and loadOpt("ScanForLoads_Auras",   inCombat, alive, inEncounter, warmodeActive, inPetBattle, vehicle, vehicleUi, dragonriding, mounted, specId, player, realm, guild, race, faction, playerLevel, effectiveLevel, role, position, group, groupSize, raidMemberType, zone, zoneId, zonegroupId, instanceId, minimapText, encounter_id, size, difficulty, difficultyIndex, affixes)
      end

      if(shouldBeLoaded and not loaded[id]) then
        changed = changed + 1;
        toLoad[id] = true;
        Private.EnsureRegion(id)
        for parent in Private.TraverseParents(data) do
          parentsToCheck[parent.id] = true
        end
      end

      if(loaded[id] and not shouldBeLoaded) then
        toUnload[id] = true;
        changed = changed + 1;
        for parent in Private.TraverseParents(data) do
          parentsToCheck[parent.id] = true
        end
      end
      if(shouldBeLoaded) then
        loaded[id] = true;
      elseif(couldBeLoaded) then
        loaded[id] = false;
      else
        loaded[id] = nil;
      end
    end
  end

  if(changed > 0 and not paused) then
    Private.LoadDisplays(toLoad, event, arg1, ...);
    Private.UnloadDisplays(toUnload, event, arg1, ...);
    Private.FinishLoadUnload();
  end

  Private.ScanForLoadsGroup(parentsToCheck)
  Private.callbacks:Fire("ScanForLoads")

  wipe(toLoad);
  wipe(toUnload)
end

function Private.ScanForLoadsGroup(toCheck)
  for id in pairs(toCheck) do
    local data = WeakAuras.GetData(id)
    if(data.controlledChildren) then
      if(#data.controlledChildren > 0) then
        ---@type boolean?
        local any_loaded = false;
        for child in Private.TraverseLeafs(data) do
          if(loaded[child.id] ~= nil) then
            any_loaded = true;
            break;
          else
            any_loaded = nil
          end
        end
        if any_loaded then
          Private.EnsureRegion(id)
        end
        loaded[id] = any_loaded;
      else
        Private.EnsureRegion(id)
        loaded[id] = true;
      end
    end
  end
end

function Private.ScanForLoads(toCheck, event, arg1, ...)
  if not WeakAuras.IsLoginFinished() then
    return
  end
  scanForLoadsImpl(toCheck, event, arg1, ...)
end

local loadFrame = CreateFrame("Frame");
Private.frames["Display Load Handling"] = loadFrame;

loadFrame:RegisterEvent("ENCOUNTER_START");
loadFrame:RegisterEvent("ENCOUNTER_END");

if WeakAuras.IsRetail() then
  loadFrame:RegisterEvent("PLAYER_TALENT_UPDATE");
  loadFrame:RegisterEvent("PLAYER_PVP_TALENT_UPDATE");
  loadFrame:RegisterEvent("PLAYER_DIFFICULTY_CHANGED");
  loadFrame:RegisterEvent("PET_BATTLE_OPENING_START");
  loadFrame:RegisterEvent("PET_BATTLE_CLOSE");
  loadFrame:RegisterEvent("VEHICLE_UPDATE");
  loadFrame:RegisterEvent("UPDATE_VEHICLE_ACTIONBAR")
  loadFrame:RegisterEvent("UPDATE_OVERRIDE_ACTIONBAR");
  loadFrame:RegisterEvent("CHALLENGE_MODE_COMPLETED")
  loadFrame:RegisterEvent("CHALLENGE_MODE_START")
  loadFrame:RegisterEvent("TRAIT_CONFIG_CREATED")
  loadFrame:RegisterEvent("TRAIT_CONFIG_UPDATED")
else
  loadFrame:RegisterEvent("CHARACTER_POINTS_CHANGED")
  loadFrame:RegisterEvent("PLAYER_TALENT_UPDATE");
  loadFrame:RegisterEvent("ACTIVE_TALENT_GROUP_CHANGED");
end

if WeakAuras.IsCataOrMists() then
  loadFrame:RegisterEvent("VEHICLE_UPDATE");
  loadFrame:RegisterEvent("UPDATE_VEHICLE_ACTIONBAR")
  loadFrame:RegisterEvent("UPDATE_OVERRIDE_ACTIONBAR");
end

if WeakAuras.IsMists() then
  loadFrame:RegisterEvent("PET_BATTLE_OPENING_START");
  loadFrame:RegisterEvent("PET_BATTLE_CLOSE");
end
loadFrame:RegisterEvent("GROUP_ROSTER_UPDATE");
loadFrame:RegisterEvent("ZONE_CHANGED");
loadFrame:RegisterEvent("ZONE_CHANGED_INDOORS");
loadFrame:RegisterEvent("ZONE_CHANGED_NEW_AREA");
loadFrame:RegisterEvent("PLAYER_LEVEL_UP");
loadFrame:RegisterEvent("PLAYER_REGEN_DISABLED");
loadFrame:RegisterEvent("PLAYER_REGEN_ENABLED");
loadFrame:RegisterEvent("PLAYER_ROLES_ASSIGNED");
loadFrame:RegisterEvent("SPELLS_CHANGED");
loadFrame:RegisterUnitEvent("UNIT_INVENTORY_CHANGED", "player")
loadFrame:RegisterEvent("PLAYER_EQUIPMENT_CHANGED")
loadFrame:RegisterEvent("PLAYER_DEAD")
loadFrame:RegisterEvent("PLAYER_ALIVE")
loadFrame:RegisterEvent("PLAYER_UNGHOST")
loadFrame:RegisterEvent("PARTY_LEADER_CHANGED")
loadFrame:RegisterEvent("PLAYER_MOUNT_DISPLAY_CHANGED")
loadFrame:RegisterEvent("PLAYER_GUILD_UPDATE")

if WeakAuras.IsRetail() then
  Private.callbacks:RegisterCallback("WA_DRAGONRIDING_UPDATE", function ()
    Private.StartProfileSystem("load");
    Private.ScanForLoads(nil, "WA_DRAGONRIDING_UPDATE")
    Private.StopProfileSystem("load");
  end)
end

local unitLoadFrame = CreateFrame("Frame");
Private.frames["Display Load Handling 2"] = unitLoadFrame;

unitLoadFrame:RegisterUnitEvent("UNIT_FLAGS", "player");
if WeakAuras.IsCataOrMistsOrRetail() then
  unitLoadFrame:RegisterUnitEvent("UNIT_ENTERED_VEHICLE", "player");
  unitLoadFrame:RegisterUnitEvent("UNIT_EXITED_VEHICLE", "player");
  unitLoadFrame:RegisterUnitEvent("PLAYER_FLAGS_CHANGED", "player");
end

function Private.RegisterLoadEvents()
  loadFrame:SetScript("OnEvent", function(frame, ...)
    Private.StartProfileSystem("load");
    Private.ScanForLoads(nil, ...)
    Private.StopProfileSystem("load");
  end);

  C_Timer.NewTicker(0.5, function()
    Private.StartProfileSystem("load");
    local zoneId = C_Map.GetBestMapForUnit("player");
    if loadFrame.zoneId ~= zoneId then
      Private.ScanForLoads(nil, "ZONE_CHANGED")
      loadFrame.zoneId = zoneId;
    end
    Private.StopProfileSystem("load");
  end)

  unitLoadFrame:SetScript("OnEvent", function(frame, e, arg1, ...)
    Private.StartProfileSystem("load");
    if (arg1 == "player") then
      Private.ScanForLoads(nil, e, arg1, ...)
    end
    Private.StopProfileSystem("load");
  end);
end

local function UnloadAll()
  -- Even though auras are collapsed, their finish animation can be running
  for id in pairs(loaded) do
    if Private.regions[id] and Private.regions[id].region then
      Private.CancelAnimation(Private.regions[id].region, true, true, true, true, true, true)
    end
    if clones[id] then
      for cloneId, region in pairs(clones[id]) do
        Private.CancelAnimation(region, true, true, true, true, true, true)
      end
    end
  end

  for _, v in pairs(triggerState) do
    for i = 1, v.numTriggers do
      if (v[i]) then
        wipe(v[i]);
      end
    end
  end

  for _, aura in pairs(timers) do
    for _, trigger in pairs(aura) do
      for _, record in pairs(trigger) do
        if (record.handle) then
          timer:CancelTimer(record.handle);
        end
      end
    end
  end
  wipe(timers);

  Private.UnloadAllConditions()

  for _, triggerSystem in pairs(triggerSystems) do
    triggerSystem.UnloadAll();
  end

  for id in pairs(loaded) do
    local func = Private.customActionsFunctions[id] and Private.customActionsFunctions[id]["unload"]
    if func then
      Private.ActivateAuraEnvironment(id)
      xpcall(func, Private.GetErrorHandlerId(id, "onUnload"))
      Private.ActivateAuraEnvironment(nil)
    end
  end
  wipe(loaded);
end

function Private.Resume()
  paused = false;

  local suspended = Private.PauseAllDynamicGroups()

  for id, region in pairs(Private.regions) do
    if region.region then
      region.region:Collapse();
    end
  end

  for id, cloneList in pairs(clones) do
    for cloneId, clone in pairs(cloneList) do
      clone:Collapse();
    end
  end


  UnloadAll();
  scanForLoadsImpl();
  if loadEvents["GROUP"] then
    Private.ScanForLoadsGroup(loadEvents["GROUP"])
  end

  Private.ResumeAllDynamicGroups(suspended)
end

function Private.LoadDisplays(toLoad, ...)
  for id in pairs(toLoad) do
    local uid = WeakAuras.GetData(id).uid
    Private.RegisterForGlobalConditions(uid);
    triggerState[id].triggers = {};
    triggerState[id].activationTime = {}
    triggerState[id].triggerCount = 0;
    triggerState[id].show = false;
    triggerState[id].activatedConditions = {};
    if Private.DebugLog.IsEnabled(uid) then
      WeakAuras.prettyPrint(L["Debug Logging enabled for '%s'"]:format(id))
      Private.DebugLog.Print(uid, L["Aura loaded"])
    end
  end
  for _, triggerSystem in pairs(triggerSystems) do
    triggerSystem.LoadDisplays(toLoad, ...);
  end
  for id in pairs(toLoad) do
    local func = Private.customActionsFunctions[id] and Private.customActionsFunctions[id]["load"]
    if func then
      Private.ActivateAuraEnvironment(id)
      xpcall(func, Private.GetErrorHandlerId(id, "onLoad"))
      Private.ActivateAuraEnvironment(nil)
    end
  end
end

function Private.UnloadDisplays(toUnload, ...)
  for id in pairs(toUnload) do
    local func = Private.customActionsFunctions[id] and Private.customActionsFunctions[id]["unload"]
    if func then
      Private.ActivateAuraEnvironment(id)
      xpcall(func, Private.GetErrorHandlerId(id, "onUnload"))
      Private.ActivateAuraEnvironment(nil)
    end
  end
  for _, triggerSystem in pairs(triggerSystems) do
    triggerSystem.UnloadDisplays(toUnload, ...);
  end

  for id in pairs(toUnload) do
    if triggerState[id] then
      for i = 1, triggerState[id].numTriggers do
        if (triggerState[id][i]) then
          wipe(triggerState[id][i])
        end
      end
      triggerState[id].show = nil
    end

    if (timers[id]) then
      for _, trigger in pairs(timers[id]) do
        for _, record in pairs(trigger) do
          if (record.handle) then
            timer:CancelTimer(record.handle);
          end
        end
      end
      timers[id] = nil;
    end

    local uid = WeakAuras.GetData(id).uid
    Private.UnloadConditions(uid)

    Private.regions[id].region:Collapse();
    Private.CollapseAllClones(id);

    -- Even though auras are collapsed, their finish animation can be running
    Private.CancelAnimation(Private.regions[id].region, true, true, true, true, true, true)
    if clones[id] then
      for _, region in pairs(clones[id]) do
        Private.CancelAnimation(region, true, true, true, true, true, true)
      end
    end
  end
end

function Private.FinishLoadUnload()
  for _, triggerSystem in pairs(triggerSystems) do
    triggerSystem.FinishLoadUnload();
  end
end

-- transient cache of uid => id
-- eventually, the database will be migrated to index by uid
-- and this mapping will become redundant
-- this cache is loaded lazily via pAdd()
local UIDtoID = {}

function Private.GetDataByUID(uid)
  return WeakAuras.GetData(UIDtoID[uid])
end

function Private.UIDtoID(uid)
  return UIDtoID[uid]
end

---@private
function WeakAuras.Delete(data)
  Private.TimeMachine:DestroyTheUniverse(data.id)
  local id = data.id;
  local uid = data.uid
  local parentId = data.parent
  local parentUid = data.parent and db.displays[data.parent].uid


  if loaded[id] then
    Private.UnloadDisplays({[id] = true})
  end

  Private.callbacks:Fire("AboutToDelete", uid, id, parentUid, parentId)

  if(data.parent) then
    local parentData = db.displays[data.parent];
    if(parentData and parentData.controlledChildren) then
      for index, childId in pairs(parentData.controlledChildren) do
        if(childId == id) then
          tremove(parentData.controlledChildren, index);
        end
      end
      if parentData.sortHybridTable then
        parentData.sortHybridTable[id] = nil
      end
      for parent in Private.TraverseParents(data) do
        Private.ClearAuraEnvironment(parent.id);
      end
    end
  end

  UIDtoID[data.uid] = nil
  if(data.controlledChildren) then
    for _, childId in pairs(data.controlledChildren) do
      local childData = db.displays[childId];
      if(childData) then
        childData.parent = nil;
        WeakAuras.Add(childData);
      end
    end
  end

  if Private.regions[id] and Private.regions[id].region then
    Private.regions[id].region:Collapse()
    Private.CancelAnimation(Private.regions[id].region, true, true, true, true, true, true)

    -- Groups have a empty Collapse method so, we need to hide them here
    Private.regions[id].region:Hide();

    Private.regions[id].region = nil
    Private.regions[id] = nil
  end

  if clones[id] then
    for _, region in pairs(clones[id]) do
      region:Collapse();
      Private.CancelAnimation(region, true, true, true, true, true, true)
    end
    clones[id] = nil
  end

  db.registered[id] = nil;

  for _, triggerSystem in pairs(triggerSystems) do
    triggerSystem.Delete(id);
  end


  loaded[id] = nil;
  loadFuncs[id] = nil;
  loadFuncsForOptions[id] = nil;
  for event, eventData in pairs(loadEvents) do
    eventData[id] = nil
  end

  db.displays[id] = nil;

  Private.DeleteAuraEnvironment(id)
  triggerState[id] = nil;

  if (Private.personalRessourceDisplayFrame) then
    Private.personalRessourceDisplayFrame:delete(id);
  end

  if (Private.mouseFrame) then
    Private.mouseFrame:delete(id);
  end

  Private.customActionsFunctions[id] = nil;
  Private.ExecEnv.customConditionsFunctions[id] = nil;
  Private.ExecEnv.conditionTextFormatters[id] = nil
  Private.frameLevels[id] = nil;
  Private.ExecEnv.conditionHelpers[data.uid] = nil

  Private.RemoveHistory(data.uid)

  Private.AddParents(data)
  Private.callbacks:Fire("Delete", uid, id, parentUid, parentId)
end

function WeakAuras.Rename(data, newid)
  -- since we Add() later in this function, we need to destroy the universe first
  local oldid = data.id
  if(data.parent) then
    local parentData = db.displays[data.parent];
    if(parentData.controlledChildren) then
      for index, childId in pairs(parentData.controlledChildren) do
        if(childId == data.id) then
          parentData.controlledChildren[index] = newid;
        end
      end
      if parentData.sortHybridTable and parentData.sortHybridTable[oldid] then
        parentData.sortHybridTable[newid] = true
        parentData.sortHybridTable[oldid] = nil
      end
    end
    local parentRegion = WeakAuras.GetRegion(data.parent)
    if parentRegion and parentRegion.ReloadControlledChildren then
      parentRegion:ReloadControlledChildren()
    end
  end

  UIDtoID[data.uid] = newid
  Private.regions[newid] = Private.regions[oldid];
  Private.regions[oldid] = nil;
  if Private.regions[newid] and Private.regions[newid].region then
    Private.regions[newid].region.id = newid
  end

  if(clones[oldid]) then
    clones[newid] = clones[oldid]
    clones[oldid] = nil
    for cloneid, clone in pairs(clones[newid]) do
      clone.id = newid
    end
  end

  for _, triggerSystem in pairs(triggerSystems) do
    triggerSystem.Rename(oldid, newid);
  end

  loaded[newid] = loaded[oldid];
  loaded[oldid] = nil;
  loadFuncs[newid] = loadFuncs[oldid];
  loadFuncs[oldid] = nil;

  loadFuncsForOptions[newid] = loadFuncsForOptions[oldid]
  loadFuncsForOptions[oldid] = nil;

  for event, eventData in pairs(loadEvents) do
    eventData[newid] = eventData[oldid]
    eventData[oldid] = nil
  end

  timers[newid] = timers[oldid];
  timers[oldid] = nil;

  triggerState[newid] = triggerState[oldid];
  triggerState[oldid] = nil;

  Private.RenameAuraEnvironment(oldid, newid)

  db.displays[newid] = db.displays[oldid];
  db.displays[oldid] = nil;
  db.displays[newid].id = newid;

  if(data.controlledChildren) then
    for index, childId in pairs(data.controlledChildren) do
      local childData = db.displays[childId];
      if(childData) then
        childData.parent = data.id;
      end
    end
  end

  if (Private.personalRessourceDisplayFrame) then
    Private.personalRessourceDisplayFrame:rename(oldid, newid);
  end

  if (Private.mouseFrame) then
    Private.mouseFrame:rename(oldid, newid);
  end

  Private.customActionsFunctions[newid] = Private.customActionsFunctions[oldid];
  Private.customActionsFunctions[oldid] = nil;

  Private.ExecEnv.customConditionsFunctions[newid] = Private.ExecEnv.customConditionsFunctions[oldid];
  Private.ExecEnv.customConditionsFunctions[oldid] = nil;

  Private.ExecEnv.conditionTextFormatters[newid] = Private.ExecEnv.conditionTextFormatters[oldid]
  Private.ExecEnv.conditionTextFormatters[oldid] = nil

  Private.frameLevels[newid] = Private.frameLevels[oldid];
  Private.frameLevels[oldid] = nil;

  Private.ProfileRenameAura(oldid, newid);

  -- TODO: This should not be necessary
  WeakAuras.Add(data)

  Private.callbacks:Fire("Rename", data.uid, oldid, newid)
end

function Private.Convert(data, newType)
  Private.TimeMachine:DestroyTheUniverse(data.id)
  local id = data.id;
  Private.FakeStatesFor(id, false)

  if Private.regions[id] then
    Private.regions[id].region = nil
    Private.regions[id] = nil
  end

  data.regionType = newType;

  -- Clean up sub regions
  if data.subRegions then
    for index, subRegionData in ipairs_reverse(data.subRegions) do
      local subType = subRegionData.type
      local removeSubRegion = true
      if subType and Private.subRegionTypes[subType] then
        if Private.subRegionTypes[subType].supports(data.regionType) then
          removeSubRegion = false
        end
      end
      if removeSubRegion then
        tremove(data.subRegions, index)
        -- Adjust conditions!
        if data.conditions then
          for _, condition in ipairs(data.conditions) do
            if type(condition.changes) == "table" then
              for _, change in ipairs(condition.changes) do
                if change.property then
                  local subRegionIndex, property = change.property:match("^sub%.(%d+)%.(.*)")
                  subRegionIndex = tonumber(subRegionIndex)
                  if subRegionIndex and property then
                    if subRegionIndex == index then
                      change.property = nil
                    elseif subRegionIndex > index then
                      change.property = "sub." .. subRegionIndex -1 .. "." .. property
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end


  WeakAuras.Add(data);

  Private.FakeStatesFor(id, true)

  local parentRegion = WeakAuras.GetRegion(data.parent)
  if parentRegion and parentRegion.ReloadControlledChildren then
    parentRegion:ReloadControlledChildren()
  end
end

-- The default mixin doesn't recurse, this does
function WeakAuras.DeepMixin(dest, source)
  local function recurse(source, dest)
    for i,v in pairs(source) do
      if(type(v) == "table") then
        dest[i] = type(dest[i]) == "table" and dest[i] or {};
        recurse(v, dest[i]);
      else
        dest[i] = v;
      end
    end
  end
  recurse(source, dest);
end

local function LastUpgrade()
  return db.lastUpgrade and date(nil, db.lastUpgrade) or "unknown"
end

function Private.NeedToRepairDatabase()
  return db.dbVersion and db.dbVersion > WeakAuras.InternalVersion()
end

local function RepairDatabase()
  local coro = coroutine.create(function()
    Private.SetImporting(true)
    -- set db version to current code version
    db.dbVersion = WeakAuras.InternalVersion()
    -- reinstall snapshots from history
    local newDB = Mixin({}, db.displays)
    coroutine.yield(1000)
    for id, data in pairs(db.displays) do
      local snapshot = Private.GetMigrationSnapshot(data.uid)
      if snapshot then
        newDB[id] = nil
        newDB[snapshot.id] = snapshot
        coroutine.yield(1000, "repair get snapshot")
      end
    end
    db.displays = newDB
    Private.SetImporting(false)
    -- finally, login
    Private.Login()
  end)
  Private.Threads:Add("repair", coro, 'urgent')
end

StaticPopupDialogs["WEAKAURAS_CONFIRM_REPAIR"] = {
  text = "",
  button1 = L["Repair"],
  button2 = L["Cancel"],
  OnAccept = function(self)
     RepairDatabase()
  end,
  OnShow = function(self)
    local AutomaticRepairText = L["WeakAuras has detected that it has been downgraded.\nYour saved auras may no longer work properly.\nWould you like to run the |cffff0000EXPERIMENTAL|r repair tool? This will overwrite any changes you have made since the last database upgrade.\nLast upgrade: %s\n\n|cffff0000You should BACKUP your WTF folder BEFORE pressing this button.|r"]
    local ManualRepairText = L["Are you sure you want to run the |cffff0000EXPERIMENTAL|r repair tool?\nThis will overwrite any changes you have made since the last database upgrade.\nLast upgrade: %s"]

    if self.data.reason == "user" then
      self.text:SetText(ManualRepairText:format(LastUpgrade()))
    else
      self.text:SetText(AutomaticRepairText:format(LastUpgrade()))
    end
  end,
  OnCancel = function(self)
    if self.data.reason ~= "user" then
      Private.Login()
    end
  end,
  whileDead = true,
  showAlert = true,
  timeout = 0,
  preferredindex = 4
}

function Private.ValidateUniqueDataIds(silent)
  -- ensure that there are no duplicated uids anywhere in the database
  local seenUIDs = {}
  for _, data in pairs(db.displays) do
    if type(data.uid) == "string" then
      if seenUIDs[data.uid] then
        if not silent then
          prettyPrint("Duplicate uid \""..data.uid.."\" detected in saved variables between \""..data.id.."\" and \""..seenUIDs[data.uid].id.."\".")
        end
        data.uid = WeakAuras.GenerateUniqueID()
        seenUIDs[data.uid] = data
      else
        seenUIDs[data.uid] = data
      end
    elseif data.uid ~= nil then
      if not silent then
        prettyPrint("Invalid uid detected in saved variables for \""..data.id.."\"")
      end
      data.uid = WeakAuras.GenerateUniqueID()
      seenUIDs[data.uid] = data
    end
  end
  for uid, data in pairs(seenUIDs) do
    UIDtoID[uid] = data.id
  end
end

function Private.SyncParentChildRelationships(silent)
  -- 1. Find all auras where data.parent ~= nil or data.controlledChildren ~= nil
  --    If an aura has data.parent which doesn't exist, then remove data.parent
  --    If an aura has data.parent which doesn't have data.controlledChildren, then remove data.parent
  -- 2. For each aura with data.controlledChildren, iterate through the list of children and remove entries where:
  --    The child doesn't exist in the database
  --    The child ID is duplicated in data.controlledChildren (only the first will be kept)
  --    The child's data.parent points to a different parent
  --    The parent is a dynamic group and the child is a group/dynamic group
  --    Otherwise, mark the child as having a valid parent relationship
  -- 3. For each aura with data.parent, remove data.parent if it was not marked to have a valid relationship in 2.
  local parents = {}
  local children = {}
  local childHasParent = {}
  for id, data in pairs(db.displays) do
    if data.parent then
      if not db.displays[data.parent] then
        if not(silent) then
          prettyPrint("Detected corruption in saved variables: "..id.." has a nonexistent parent.")
        end
        data.parent = nil
      elseif not db.displays[data.parent].controlledChildren then
        if not silent then
          prettyPrint("Detected corruption in saved variables: "..id.." thinks "..data.parent..
                      " controls it, but "..data.parent.." is not a group.")
        end
        data.parent = nil
      else
        children[id] = data
      end
    end
    if data.controlledChildren then
      parents[id] = data
    end
  end

  for id, data in pairs(parents) do
    local groupChildren = {}
    local childrenToRemove = {}
    local dynamicGroup = data.regionType == "dynamicgroup"
    for index, childID in ipairs(data.controlledChildren) do
      local child = children[childID]
      if not child then
        if not silent then
          prettyPrint("Detected corruption in saved variables: "..id.." thinks it controls "..childID.." which doesn't exist.")
        end
        childrenToRemove[index] = true
      elseif child.parent ~= id then
        if not silent then
          prettyPrint("Detected corruption in saved variables: "..id.." thinks it controls "..childID.." which it does not.")
        end
        childrenToRemove[index] = true
      elseif dynamicGroup and child.controlledChildren then
        if not silent then
          prettyPrint("Detected corruption in saved variables: "..id.." is a dynamic group and controls "..childID.." which is a group/dynamicgroup.")
        end
        child.parent = nil
        children[child.id] = nil
        childrenToRemove[index] = true
      elseif groupChildren[childID] then
        if not silent then
          prettyPrint("Detected corruption in saved variables: "..id.." has "..childID.." as a child in multiple positions.")
        end
        childrenToRemove[index] = true
      else
        groupChildren[childID] = index
        childHasParent[childID] = true
      end
    end
    if next(childrenToRemove) ~= nil then
      for i = #data.controlledChildren, 1, -1 do
        if childrenToRemove[i] then
          tremove(data.controlledChildren, i)
        end
      end
    end
  end

  for id, data in pairs(children) do
    if not childHasParent[id] then
      if not silent then
        prettyPrint("Detected corruption in saved variables: "..id.." should be controlled by "..data.parent.." but isn't.")
      end
      local parent = parents[data.parent]
      tinsert(parent.controlledChildren, id)
    end
  end
end

local function loadOrder(tbl, idtable)
  local order = {}

  local loaded = {};
  local function load(id, depends)
    local data = idtable[id];
    if(data.parent) then
      if(idtable[data.parent]) then
        if depends[data.parent] then
          error("Circular dependency in Private.AddMany between "..table.concat(depends, ", "));
        else
          if not(loaded[data.parent]) then
            local dependsOut = CopyTable(depends)
            dependsOut[data.parent] = true
            coroutine.yield(100, "sort deps")
            load(data.parent, dependsOut)
            coroutine.yield(100, "sort deps")
          end
        end
      else
        data.parent = nil;
      end
    end
    if not(loaded[id]) then
      coroutine.yield(100, "sort deps");
      loaded[id] = true;
      tinsert(order, idtable[id])
    end
  end

  for id in pairs(idtable) do
    load(id, {});
    coroutine.yield(100, "sort deps")
  end

  return order
end

---@type fun(data: auraData)
local pAdd

function Private.CheckForAnchorCycle(source)
  local cycle = {}
  while source do
    cycle[source] = true
    local data = WeakAuras.GetData(source)
    local target
    if data then
      if data.anchorFrameType == "SELECTFRAME" and data.anchorFrameFrame then
        if data.anchorFrameFrame:sub(1, 10) == "WeakAuras:" then
          target = data.anchorFrameFrame:sub(11)
        end
      else
        target = data.parent
      end
    end
    if target and cycle[target] then
      return true
    end
    source = target
  end
  return false
end

---@param tbl auraData[]
---@param takeSnapshots boolean
function Private.AddMany(tbl, takeSnapshots)
  --- @type table<auraId, auraData>
  local idtable = {};
  --- @type table<auraId, auraId> The anchoring targets of other auras, key is the anchor, value is the aura that is anchoring
  local anchorTargets = {}
  for _, data in ipairs(tbl) do
    -- There was an unfortunate bug in update.lua in 2022 that resulted
    -- in auras having a circular dependencies
    -- Fix one of the two known cases here
    if data.id == data.parent then
      data.parent = nil
      tDeleteItem(data.controlledChildren, data.id)
    end
    idtable[data.id] = data;
    if data.anchorFrameType == "SELECTFRAME" and data.anchorFrameFrame and data.anchorFrameFrame:sub(1, 10) == "WeakAuras:" then
      anchorTargets[data.anchorFrameFrame:sub(11)] = data.id
    end
  end

  -- Now fix up anchors, see #3971, where aura p was anchored to aura c and where c was a child of p, thus c was anchored to p
  -- And #5395, where aura a was anchored to aura b, which was anchored to aura a
  -- The game used to detect such anchoring circles. We can't detect all of them, but at least detect the one from the ticket.
  for _, source in pairs(anchorTargets) do
    -- We walk up the parent's of target, to check for source
    if Private.CheckForAnchorCycle(source) then
      WeakAuras.prettyPrint(L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"]:format(source))
      idtable[source].anchorFrameType = "UIPARENT"
      idtable[source].anchorFrameFrame = ""
    end
  end

  local order = loadOrder(tbl, idtable)
  coroutine.yield(5000)

  local oldSnapshots = {}
  local copies = {}
  if takeSnapshots then
    for _, data in ipairs(order) do
      if Private.ModernizeNeedsOldSnapshot(data) then
        oldSnapshots[data.uid] = Private.GetMigrationSnapshot(data.uid)
      end
      copies[data.uid] = CopyTable(data)
      coroutine.yield(200, "addmany prepare snapshot")
    end
    if #order > 0 then
      Private.Threads:Add("snapshot", coroutine.create(function()
        prettyPrint(L["WeakAuras is creating a rollback snapshot of your auras. This snapshot will allow you to revert to the current state of your auras if something goes wrong. This process may cause your framerate to drop until it is complete."])
        for uid, data in pairs(copies) do
          Private.SetMigrationSnapshot(uid, data)
          coroutine.yield(200, "snapshot")
        end
        prettyPrint(L["Rollback snapshot is complete. Thank you for your patience!"])
      end), 'normal')
    else
      if next(WeakAuras.LoadFromArchive("Repository", "migration").stores) ~= nil then
        C_Timer.After(1, function()
          prettyPrint(L["WeakAuras has detected empty settings. If this is unexpected, ask for assitance on https://discord.gg/weakauras."])
        end)
      end
    end
  end

  local groups = {}
  local bads = {}
  for _, data in ipairs(order) do
    if data.parent and bads[data.parent] then
      bads[data.id] = true
    else
      local oldSnapshot = oldSnapshots[data.uid] or nil
      local ok = xpcall(WeakAuras.PreAdd, Private.GetErrorHandlerUid(data.uid, "PreAdd"), data, oldSnapshot)
      if not ok then
        prettyPrint(L["Unable to modernize aura '%s'. This is probably due to corrupt data or a bad migration, please report this to the WeakAuras team."]:format(data.id))
        if data.regionType == "dynamicgroup" or data.regionType == "group" then
          prettyPrint(L["All children of this aura will also not be loaded, to minimize the chance of further corruption."])
        end
        bads[data.id] = true
      elseif data.regionType == "dynamicgroup" or data.regionType == "group" then
        groups[data] = true
      end
      coroutine.yield(1000, "addmany modernize")
    end
  end

  for _, data in ipairs(order) do
    if not bads[data.id] then
      if data.parent and bads[data.parent] then
        bads[data.id] = true
      else
        local ok = xpcall(pAdd, Private.GetErrorHandlerUid(data.uid, "pAdd"), data)
        if not ok then
          bads[data.id] = true
        end
      end
    end
    coroutine.yield(2000, "addmany add")
  end

  for id in pairs(anchorTargets) do
    local data = idtable[id]
    if data and not bads[data.id] and (data.parent == nil or idtable[data.parent].regionType ~= "dynamicgroup") then
      Private.EnsureRegion(id)
      coroutine.yield(100, "addmany ensure anchor")
    end
  end

  for data in pairs(groups) do
    if not bads[data.id] then
      if data.type == "dynamicgroup" then
        if Private.regions[data.id] and Private.regions[data.id].region then
          Private.regions[data.id].region:ReloadControlledChildren()
        end
      else
        Private.Add(data)
      end
    end
    coroutine.yield(1000, "addmany reload dynamic group");
  end
end

local function customOptionIsValid(option)
  if not option.type then
    return false
  elseif Private.author_option_classes[option.type] == "simple" then
    if not option.key
    or not option.name
    or not option.default == nil then
      return false
    end
  elseif Private.author_option_classes[option.type] == "group" then
    if not option.key
    or not option.name
    or not option.default == nil
    or not option.subOptions then
      return false
    end
  end
  return true
end

local function validateUserConfig(data, options, config)
  local authorOptionKeys, corruptOptions = {}, {}
  for index, option in ipairs(options) do
    if not customOptionIsValid(option) or authorOptionKeys[option.key] then
      prettyPrint(data.id .. " Custom Option #" .. index .. " in " .. data.id .. " has been detected as corrupt, and has been deleted.")
      corruptOptions[index] = true
    else
      local optionClass = Private.author_option_classes[option.type]
      if option.key then
        authorOptionKeys[option.key] = index
      end
      if optionClass == "simple" then
        if not option.key then
          option.key = WeakAuras.GenerateUniqueID()
        end
        if config[option.key] == nil then
          if type(option.default) ~= "table" then
            config[option.key] = option.default
          else
            config[option.key] = CopyTable(option.default)
          end
        end
      elseif optionClass == "group" then
        local subOptions = option.subOptions
        if type(config[option.key]) ~= "table" then
          config[option.key] = {}
        end
        local subConfig = config[option.key]
        if option.groupType == "array" then
          for k, v in pairs(subConfig) do
            if type(k) ~= "number" or type(v) ~= "table" then
              -- if k was not a number, then this was a simple group before
              -- if v is not a table, then this was likely a color option
              wipe(subConfig) -- second iteration will fill table with defaults
              break
            end
          end
          if option.limitType == "fixed" then
            for i = #subConfig + 1, option.size do
              -- add missing entries
              subConfig[i] = {}
            end
          end
          if option.limitType ~= "none" then
            for i = option.size + 1, #subConfig do
              -- remove excess entries
              subConfig[i] = nil
            end
          end
          for _, toValidate in pairs(subConfig) do
            validateUserConfig(data, subOptions, toValidate)
          end
        else
          if type(next(subConfig)) ~= "string" then
            -- either there are no sub options, in which case this is a noop
            -- or this group was previously an array, in which case we need to wipe
            wipe(subConfig)
          end
          validateUserConfig(data, subOptions, subConfig)
        end
      end
    end
  end
  for key, value in pairs(config) do
    if not authorOptionKeys[key] then
      config[key] = nil
    else
      local option = options[authorOptionKeys[key]]
      local optionClass = Private.author_option_classes[option.type]
      if optionClass ~= "group" then
        local option = options[authorOptionKeys[key]]
        if option.type == "media" then
          -- sounds can be number or string, other kinds of media can only be string
          if type(value) ~= "string" and (type(value) ~= "number" or option.mediaType ~= "sound") then
            config[key] = option.default
          end
        elseif type(value) ~= type(option.default) then
          -- if type mismatch then we know that it can't be right
          if type(option.default) ~= "table" then
            config[key] = option.default
          else
            config[key] = CopyTable(option.default)
          end
        elseif option.type == "input" and option.useLength then
          config[key] = config[key]:sub(1, option.length)
        elseif option.type == "number" or option.type == "range" then
          if (option.max and option.max < value) or (option.min and option.min > value) then
            config[key] = option.default
          else
            if option.type == "number" and option.step then
              local min = option.min or 0
              config[key] = option.step * Round((value - min)/option.step) + min
            end
          end
        elseif option.type == "select" then
          if value < 1 or value > #option.values then
            config[key] = option.default
          end
        elseif option.type == "multiselect" then
          local multiselect = config[key]
          for i, v in ipairs(multiselect) do
            if option.default[i] ~= nil then
              if type(v) ~= "boolean" then
                multiselect[i] = option.default[i]
              end
            else
              multiselect[i] = nil
            end
          end
          for i, v in ipairs(option.default) do
            if type(multiselect[i]) ~= "boolean" then
              multiselect[i] = v
            end
          end
        elseif option.type == "color" then
          for i = 1, 4 do
            local c = config[key][i]
            if type(c) ~= "number" or c < 0 or c > 1 then
              config[key] = option.default
              break
            end
          end
        end
      end
    end
  end
  for i = #options, 1, -1 do
    if corruptOptions[i] then
      tremove(options, i)
    end
  end
end


local oldDataStub = {
  -- note: this is the minimal data stub which prevents false positives in diff upon reimporting an aura.
  -- pending a refactor of other code which adds unnecessary fields, it is possible to shrink it
  trigger = {
    type = "aura",
    names = {},
    event = "Health",
    subeventPrefix = "SPELL",
    subeventSuffix = "_CAST_START",
    spellIds = {},
    unit = "player",
    debuffType = "HELPFUL",
  },
  numTriggers = 1,
  untrigger = {},
  load = {
    size = {
      multi = {},
    },
    spec = {
      multi = {},
    },
    class = {
      multi = {},
    },
  },
  actions = {
    init = {},
    start = {},
    finish = {},
  },
  animation = {
    start = {
      type = "none",
      duration_type = "seconds",
    },
    main = {
      type = "none",
      duration_type = "seconds",
    },
    finish = {
      type = "none",
      duration_type = "seconds",
    },
  },
  conditions = {},
}

local oldDataStub2 = {
  -- note: this is the minimal data stub which prevents false positives in diff upon reimporting an aura.
  -- pending a refactor of other code which adds unnecessary fields, it is possible to shrink it
  triggers = {
    {
      trigger = {
        type = "aura",
        names = {},
        event = "Health",
        subeventPrefix = "SPELL",
        subeventSuffix = "_CAST_START",
        spellIds = {},
        unit = "player",
        debuffType = "HELPFUL",
      },
      untrigger = {},
    },
  },
  load = {
    size = {
      multi = {},
    },
    spec = {
      multi = {},
    },
    class = {
      multi = {},
    },
  },
  actions = {
    init = {},
    start = {},
    finish = {},
  },
  animation = {
    start = {
      type = "none",
      duration_type = "seconds",
    },
    main = {
      type = "none",
      duration_type = "seconds",
    },
    finish = {
      type = "none",
      duration_type = "seconds",
    },
  },
  conditions = {},
}

--- @type fun(data: auraData)
function Private.UpdateSoundIcon(data)
  local function testConditions()
    local sound, tts
    if data.conditions then
      for _, condition in ipairs(data.conditions) do
        for changeIndex, change in ipairs(condition.changes) do
          if change.property == "sound" then
            sound = true
          end
          if change.property == "chat" and change.value and change.value.message_type == "TTS" then
            tts = true
          end
          if sound and tts then break end
        end
      end
    end
    return sound, tts
  end

  local soundCondition, ttsCondition = testConditions()

  -- sound
  if data.actions.start.do_sound or data.actions.finish.do_sound then
    Private.AuraWarnings.UpdateWarning(data.uid, "sound_action", "sound", L["This aura plays a sound via an action."])
  else
    Private.AuraWarnings.UpdateWarning(data.uid, "sound_action")
  end

  if soundCondition then
    Private.AuraWarnings.UpdateWarning(data.uid, "sound_condition", "sound", L["This aura plays a sound via a condition."])
  else
    Private.AuraWarnings.UpdateWarning(data.uid, "sound_condition")
  end

  -- tts
  if (data.actions.start.do_message and data.actions.start.message_type == "TTS")
  or (data.actions.finish.do_message and data.actions.finish.message_type == "TTS")
  then
    Private.AuraWarnings.UpdateWarning(data.uid, "tts_action", "tts", L["This aura plays a Text To Speech via an action."])
  else
    Private.AuraWarnings.UpdateWarning(data.uid, "tts_action")
  end

  if ttsCondition then
    Private.AuraWarnings.UpdateWarning(data.uid, "tts_condition", "tts", L["This aura plays a Text To Speech via a condition."])
  else
    Private.AuraWarnings.UpdateWarning(data.uid, "tts_condition")
  end
end

function Private.ClearSounds(uid, severity)
  local data = Private.GetDataByUID(uid)

  for child in Private.TraverseLeafsOrAura(data) do
    local changed = false
    if child.conditions then
      for _, condition in ipairs(child.conditions) do
        for changeIndex = #condition.changes, 1, -1 do
          local change = condition.changes[changeIndex]
          if change.property == "sound" and severity == "sound" then
            tremove(condition.changes, changeIndex)
            changed = true
          elseif change.property == "chat" and change.value and change.value.message_type == "TTS" and severity == "tts" then
            tremove(condition.changes, changeIndex)
            changed = true
          end
        end
      end
    end

    if severity == "sound" and (child.actions.start.do_sound or child.actions.finish.do_sound) then
      child.actions.start.do_sound = false
      child.actions.finish.do_sound = false
      changed = true
    elseif severity == "tts" then
      if child.actions.start.do_message and child.actions.start.message_type == "TTS" then
        child.actions.start.do_message = false
        changed = true
      end
      if child.actions.finish.do_message and child.actions.finish.message_type == "TTS" then
        child.actions.finish.do_message = false
        changed = true
      end
    end
    if changed then
      WeakAuras.Add(child)
    end
  end
  WeakAuras.ClearAndUpdateOptions(data.id, true)
  WeakAuras.FillOptions()
end

function WeakAuras.PreAdd(data, snapshot)
  if not data then return end
  -- Readd what Compress removed before version 8
  if (not data.internalVersion or data.internalVersion < 7) then
    Private.validate(data, oldDataStub)
  elseif (data.internalVersion < 8) then
    Private.validate(data, oldDataStub2)
  end

  xpcall(Private.Modernize, Private.GetErrorHandlerId(data.id, L["Modernize"]), data, snapshot)

  local default = data.regionType and Private.regionTypes[data.regionType] and Private.regionTypes[data.regionType].default
  if default then
    Private.validate(data, default)
  end

  local regionValidate = data.regionType and Private.regionTypes[data.regionType] and Private.regionTypes[data.regionType].validate
  if regionValidate then
    regionValidate(data)
  end

  Private.validate(data, Private.data_stub);
  if data.subRegions then
    for _, subRegionData in ipairs(data.subRegions) do
      local subType = subRegionData.type
      if subType and Private.subRegionTypes[subType] then
        if Private.subRegionTypes[subType].supports(data.regionType) then
          local default = Private.subRegionTypes[subType].default
          if type(default) == "function" then
            default = default(data.regionType)
          end
          if default then
            Private.validate(subRegionData, default)
          end
        else
          WeakAuras.prettyPrint(L["ERROR in '%s' unknown or incompatible sub element type '%s'"]:format(data.id, subType))
        end
      end
    end
  end
  validateUserConfig(data, data.authorOptions, data.config)
  data.init_started = nil
  data.init_completed = nil
  data.expanded = nil
end

local function cycleCheck(data)
  local id = data.id
  if data.anchorFrameType == "SELECTFRAME" and data.anchorFrameFrame and data.anchorFrameFrame:sub(1, 10) == "WeakAuras:" then
    if Private.CheckForAnchorCycle(id) then
      WeakAuras.prettyPrint(L["Warning: Anchoring in aura '%s' is imposssible, due to an anchoring cycle"]:format(id))
      db.displays[id].anchorFrameType = "UIPARENT"
      db.displays[id].anchorFrameFrame = ""
    end
  end
end

function pAdd(data, simpleChange)
  local id = data.id;
  if not(id) then
    error("Improper arguments to WeakAuras.Add - id not defined");
    return;
  end

  data.uid = data.uid or WeakAuras.GenerateUniqueID()
  if db.displays[id] and db.displays[id].uid ~= data.uid then
    print("Improper? arguments to WeakAuras.Add - id", id, "is assigned to a different uid.", data.uid, db.displays[id].uid)
  end
  if UIDtoID[data.uid] and UIDtoID[data.uid] ~= id then
    print("Improper? arguments to WeakAuras.Add - uid is assigned to a id. Uid:", data.uid, "assigned too:", UIDtoID[data.uid], "assigning now to", data.id)
  end

  local otherID = UIDtoID[data.uid]
  if not otherID then
    UIDtoID[data.uid] = id
  elseif otherID ~= id then
    -- duplicate uid
    data.uid = WeakAuras.GenerateUniqueID()
    UIDtoID[data.uid] = id
  end

  if simpleChange then
    db.displays[id] = data
    cycleCheck(data)
    if WeakAuras.GetRegion(data.id) then
      Private.SetRegion(data)
    end
    if clones[id] then
      for cloneId, region in pairs(clones[id]) do
        Private.SetRegion(data, cloneId)
      end
    end
    Private.UpdatedTriggerState(id)
    Private.callbacks:Fire("Add", data.uid, data.id, data, simpleChange)
  else
    Private.DebugLog.SetEnabled(data.uid, data.information.debugLog)

    if Private.IsGroupType(data) then
      Private.ClearAuraEnvironment(id);
      for parent in Private.TraverseParents(data) do
        Private.ClearAuraEnvironment(parent.id);
      end
      db.displays[id] = data;
      cycleCheck(data)

      if WeakAuras.GetRegion(data.id) then
        Private.SetRegion(data)
      end
      Private.ScanForLoadsGroup({[id] = true});
      loadEvents["GROUP"] = loadEvents["GROUP"] or {}
      loadEvents["GROUP"][id] = true
    else -- Non group aura
      -- Make sure that we don't have a controlledChildren member.
      data.controlledChildren = nil
      local visible
      if (WeakAuras.IsOptionsOpen()) then
        visible = Private.FakeStatesFor(id, false)
      else
        if (Private.regions[id] and Private.regions[id].region) then
          Private.regions[id].region:Collapse()
        else
          Private.CollapseAllClones(id)
        end
      end

      -- If the aura has a onHide animation we need to cancel it to ensure it's truly hidden now
      if Private.regions[id] then
        Private.CancelAnimation(Private.regions[id].region, true, true, true, true, true, true)
      end
      if clones[id] then
        for _, region in pairs(clones[id]) do
          Private.CancelAnimation(region, true, true, true, true, true, true)
        end
      end

      Private.ClearAuraEnvironment(id);
      for parent in Private.TraverseParents(data) do
        Private.ClearAuraEnvironment(parent.id);
      end

      db.displays[id] = data
      cycleCheck(data)

      if (not data.triggers.activeTriggerMode or data.triggers.activeTriggerMode > #data.triggers) then
        data.triggers.activeTriggerMode = Private.trigger_modes.first_active;
      end

      for _, triggerSystem in pairs(triggerSystems) do
        triggerSystem.Add(data);
      end

      local loadFuncStr, events = ConstructFunction(load_prototype, data.load);
      for event, eventData in pairs(loadEvents) do
        eventData[id] = nil
      end
      for event in pairs(events) do
        loadEvents[event] = loadEvents[event] or {}
        loadEvents[event][id] = true
      end
      loadEvents["SCAN_ALL"] = loadEvents["SCAN_ALL"] or {}
      loadEvents["SCAN_ALL"][id] = true

      local loadForOptionsFuncStr = ConstructFunction(load_prototype, data.load, true);
      local loadFunc = Private.LoadFunction(loadFuncStr, id);
      local loadForOptionsFunc = Private.LoadFunction(loadForOptionsFuncStr, id);
      local triggerLogicFunc;
      if data.triggers.disjunctive == "custom" then
        triggerLogicFunc = WeakAuras.LoadFunction("return "..(data.triggers.customTriggerLogic or ""), data.id);
      end

      LoadCustomActionFunctions(data);
      Private.LoadConditionPropertyFunctions(data);
      Private.LoadConditionFunction(data)

      loadFuncs[id] = loadFunc;
      loadFuncsForOptions[id] = loadForOptionsFunc;
      clones[id] = clones[id] or {};

      if (timers[id]) then
        for _, trigger in pairs(timers[id]) do
          for _, record in pairs(trigger) do
            if (record.handle) then
              timer:CancelTimer(record.handle);
            end
          end
        end
        timers[id] = nil;
      end

      if WeakAuras.GetRegion(data.id) then
        Private.SetRegion(data)
      end

      triggerState[id] = {
        disjunctive = data.triggers.disjunctive or "all",
        numTriggers = #data.triggers,
        activeTriggerMode = data.triggers.activeTriggerMode or Private.trigger_modes.first_active,
        triggerLogicFunc = triggerLogicFunc,
        triggers = {},
        activationTime = {},
        triggerCount = 0,
        activatedConditions = {},
      };

      if (WeakAuras.IsOptionsOpen()) then
        Private.FakeStatesFor(id, visible)
      end

      if not(paused) then
        Private.ScanForLoads({[id] = true});
      end
    end

    Private.UpdateSoundIcon(data)
    Private.callbacks:Fire("Add", data.uid, data.id, data, simpleChange)
  end
end

function Private.Add(data, simpleChange)
  local oldSnapshot
  if Private.ModernizeNeedsOldSnapshot(data) then
    oldSnapshot = Private.GetMigrationSnapshot(data.uid)
  end
  if (data.internalVersion or 0) < internalVersion then
    Private.SetMigrationSnapshot(data.uid, data)
  end
  local ok = xpcall(WeakAuras.PreAdd, Private.GetErrorHandlerUid(data.uid, "PreAdd"), data, oldSnapshot)
  if ok then
    pAdd(data, simpleChange)
  end
end

function WeakAuras.Add(data, simpleChange)
  Private.TimeMachine:DestroyTheUniverse(data.id)
  Private.Add(data, simpleChange)
end

function Private.AddParents(data)
  local parent = data.parent
  if (parent) then
    local parentData = WeakAuras.GetData(parent)
    WeakAuras.Add(parentData)
    Private.AddParents(parentData)
  end
end

function Private.SetRegion(data, cloneId)
  local regionType = data.regionType;
  if not(regionType) then
    error("Improper arguments to Private.SetRegion - regionType not defined in ".. data.id)
  else
    if(not regionTypes[regionType]) then
      regionType = "fallback";
      print("Improper arguments to WeakAuras.CreateRegion - regionType \""..data.regionType.."\" is not supported in ".. data.id)
    end

    local id = data.id;
    if not(id) then
      error("Improper arguments to Private.SetRegion - id not defined");
    else
      local region;
      if(cloneId) then
        region = clones[id][cloneId];
        if (not region or region.regionType ~= data.regionType) then
          if (region) then
            clonePool[region.regionType] = clonePool[region.regionType] or {};
            tinsert(clonePool[region.regionType], region);
            region:Hide();
          end
          if(clonePool[data.regionType] and clonePool[data.regionType][1]) then
            clones[id][cloneId] = tremove(clonePool[data.regionType]);
          else
            local clone = regionTypes[data.regionType].create(WeakAurasFrame, data);
            clone.regionType = data.regionType;
            clone:Hide();
            clones[id][cloneId] = clone;
          end
          region = clones[id][cloneId];
        end
      else
        if((not Private.regions[id]) or (not Private.regions[id].region) or Private.regions[id].regionType ~= regionType) then
          region = regionTypes[regionType].create(WeakAurasFrame, data);
          Private.regions[id] = {
            regionType = regionType,
            region = region
          };
          if regionType ~= "dynamicgroup" and regionType ~= "group" then
            region.toShow = false
            region:Hide()
          else
            region.toShow = true
          end
        else
          region = Private.regions[id].region
        end
      end
      region.id = id;
      region.cloneId = cloneId or "";
      Private.validate(data, regionTypes[regionType].default);

      local parent = WeakAurasFrame;
      if data.parent then
        local parentRegion = Private.EnsureRegion(data.parent)
        if parentRegion then
          parent = parentRegion
        else
          data.parent = nil;
        end
      end
      local loginFinished = WeakAuras.IsLoginFinished();
      local anim_cancelled = loginFinished and Private.CancelAnimation(region, true, true, true, true, true, true);

      regionTypes[regionType].modify(parent, region, data);
      Private.regionPrototype.AddSetDurationInfo(region, data.uid)
      Private.regionPrototype.AddExpandFunction(data, region, cloneId, parent, parent.regionType)

      data.animation = data.animation or {};
      data.animation.start = data.animation.start or {type = "none"};
      data.animation.main = data.animation.main or {type = "none"};
      data.animation.finish = data.animation.finish or {type = "none"};
      data.animation.start.duration_type = data.animation.start.duration_type or "seconds"
      data.animation.main.duration_type = data.animation.main.duration_type or "seconds"
      data.animation.finish.duration_type = data.animation.finish.duration_type or "seconds"

      if(cloneId) then
        clonePool[regionType] = clonePool[regionType] or {};
      end
      if(anim_cancelled) then
        Private.Animate("display", data.uid, "main", data.animation.main, region, false, nil, true, cloneId);
      end
      return region;
    end
  end
end

--- Ensures that a clone exists
---@param id auraId
---@param cloneId string
---@return table
local function EnsureClone(id, cloneId)
  clones[id] = clones[id] or {}
  if not(clones[id][cloneId]) then
    local data = WeakAuras.GetData(id)
    Private.SetRegion(data, cloneId)
  end
  return clones[id][cloneId]
end

local creatingRegions = false

function Private.CreatingRegions()
  return creatingRegions
end

--- Ensures that a region exists
---@param id auraId
---@return table
local function EnsureRegion(id)
  if not Private.regions[id] or not Private.regions[id].region then
    Private.regions[id] = Private.regions[id] or {}

    -- The region doesn't yet exist
    -- But we must also ensure that our parents exists

    -- So we go up the list of parents and collect auras that must be created
    -- If we find a parent already exists, we can stop
    --- @type auraId[]
    local aurasToCreate = {}

    while(id) do
      local data = WeakAuras.GetData(id)
      tinsert(aurasToCreate, data.id)
      id = data.parent

      if WeakAuras.GetRegion(id) then
        break
      end
    end

    for _, toCreateId in ipairs_reverse(aurasToCreate) do
      local data = WeakAuras.GetData(toCreateId)
      Private.SetRegion(data)
    end
  end
  return Private.regions[id] and Private.regions[id].region
end

--- Ensures that a region/clone exists and returns it
function Private.EnsureRegion(id, cloneId)
  -- Even if we are asked to only create a clone, we create the default region
  -- too.
  EnsureRegion(id)
  if(cloneId and cloneId ~= "") then
    return EnsureClone(id, cloneId);
  end
  return WeakAuras.GetRegion(id)
end

---returns the region, if it exists
---@param id auraId
---@param cloneId string|nil
---@return table|nil
function WeakAuras.GetRegion(id, cloneId)
  if(cloneId and cloneId ~= "") then
    return clones[id] and clones[id][cloneId]
  end
  return Private.regions[id] and Private.regions[id].region
end

-- Note, does not create a clone!
function Private.GetRegionByUID(uid, cloneId)
  local id = Private.UIDtoID(uid)
  if(cloneId and cloneId ~= "") then
    return id and clones[id] and clones[id][cloneId];
  end
  return id and Private.regions[id] and Private.regions[id].region
end

function Private.CollapseAllClones(id, triggernum)
  if(clones[id]) then
    for i,v in pairs(clones[id]) do
      v:Collapse();
    end
  end
end

function Private.SetAllStatesHidden(id, triggernum)
  local triggerState = WeakAuras.GetTriggerStateForTrigger(id, triggernum);
  local changed = false
  for _, state in pairs(triggerState) do
    changed = changed or state.show
    state.show = false;
    state.changed = true;
  end
  return changed
end

function Private.SetAllStatesHiddenExcept(id, triggernum, list)
  local triggerState = WeakAuras.GetTriggerStateForTrigger(id, triggernum);
  for cloneId, state in  pairs(triggerState) do
    if (not (list[cloneId])) then
      state.show = false;
      state.changed = true;
    end
  end
end

function Private.ReleaseClone(id, cloneId, regionType)
  if (not clones[id]) then
    return;
  end
  local region = clones[id][cloneId];
  clones[id][cloneId] = nil;
  if region:IsProtected() then
    WeakAuras.prettyPrint(L["Error '%s' created a secure clone. We advise deleting the aura. For more information:\nhttps://github.com/WeakAuras/WeakAuras2/wiki/Protected-Frames"]:format(id))
  else
    clonePool[regionType][#clonePool[regionType] + 1] = region;
  end
end

function Private.HandleChatAction(message_type, message, message_dest, message_dest_isunit, message_channel, r, g, b, region, customCache, when, formatters)
  local useHiddenStates = when == "finish"
  if (message:find('%%')) then
    message = Private.ReplacePlaceHolders(message, region, customCache, useHiddenStates, formatters);
  end
  if(message_type == "PRINT") then
    DEFAULT_CHAT_FRAME:AddMessage(message, r or 1, g or 1, b or 1);
  elseif message_type == "TTS" then
    if not Private.SquelchingActions() then
      pcall(function()
        local voice = TextToSpeech_GetSelectedVoice(Enum.TtsVoiceType.Standard)
        if not voice then return end
        TextToSpeech_Speak(message, voice)
      end)
    end
  elseif message_type == "ERROR" then
    UIErrorsFrame:AddMessage(message, r or 1, g or 1, b or 1)
  elseif(message_type == "COMBAT") then
    if(CombatText_AddMessage) then
      CombatText_AddMessage(message, COMBAT_TEXT_SCROLL_FUNCTION, r or 1, g or 1, b or 1);
    end
  elseif(message_type == "WHISPER") then
    if(message_dest) then
      if (message_dest:find('%%')) then
        message_dest = Private.ReplacePlaceHolders(message_dest, region, customCache, useHiddenStates, formatters);
      end
      if message_dest_isunit == true then
        message_dest = GetUnitName(message_dest, true)
      end
      pcall(function() SendChatMessage(message, "WHISPER", nil, message_dest) end);
    end
  elseif(message_type == "SMARTRAID") then
    local isInstanceGroup = IsInGroup(LE_PARTY_CATEGORY_INSTANCE)
    if UnitInBattleground("player") then
      pcall(function() SendChatMessage(message, "INSTANCE_CHAT") end)
    elseif UnitInRaid("player") then
      pcall(function() SendChatMessage(message, "RAID") end)
    elseif UnitInParty("player") then
      if isInstanceGroup then
        pcall(function() SendChatMessage(message, "INSTANCE_CHAT") end)
      else
        pcall(function() SendChatMessage(message, "PARTY") end)
      end
    else
      if IsInInstance() then
        pcall(function() SendChatMessage(message, "SAY") end)
      end
    end
  elseif(message_type == "SAY" or message_type == "YELL") then
    if IsInInstance() then
      pcall(function() SendChatMessage(message, message_type, nil, nil) end)
    end
  else
    pcall(function() SendChatMessage(message, message_type, nil, nil) end);
  end
end

local function actionGlowStop(actions, frame, id)
  if not frame.__WAGlowFrame then return end
  if actions.glow_type == "buttonOverlay" then
    LCG.ButtonGlow_Stop(frame.__WAGlowFrame)
  elseif actions.glow_type == "Pixel" then
    LCG.PixelGlow_Stop(frame.__WAGlowFrame, id)
  elseif actions.glow_type == "ACShine" then
    LCG.AutoCastGlow_Stop(frame.__WAGlowFrame, id)
  elseif actions.glow_type == "Proc" then
    LCG.ProcGlow_Stop(frame.__WAGlowFrame, id)
  end
end

local function actionGlowStart(actions, frame, id)
  if not frame.__WAGlowFrame then
    frame.__WAGlowFrame = CreateFrame("Frame", nil, frame)
    frame.__WAGlowFrame:SetAllPoints(frame)
    frame.__WAGlowFrame:SetSize(frame:GetSize())
  end
  local glow_frame = frame.__WAGlowFrame
  if glow_frame:GetWidth() < 1 or glow_frame:GetHeight() < 1 then
    actionGlowStop(actions, frame)
    return
  end
  local color = actions.use_glow_color and actions.glow_color or nil
  if actions.glow_type == "buttonOverlay" then
    LCG.ButtonGlow_Start(glow_frame, color)
  elseif actions.glow_type == "Pixel" then
    LCG.PixelGlow_Start(
      glow_frame,
      color,
      actions.glow_lines,
      actions.glow_frequency,
      actions.glow_length,
      actions.glow_thickness,
      actions.glow_XOffset,
      actions.glow_YOffset,
      actions.glow_border and true or false,
      id
    )
  elseif actions.glow_type == "ACShine" then
    LCG.AutoCastGlow_Start(
      glow_frame,
      color,
      actions.glow_lines,
      actions.glow_frequency,
      actions.glow_scale,
      actions.glow_XOffset,
      actions.glow_YOffset,
      id
    )
  elseif actions.glow_type == "Proc" then
    LCG.ProcGlow_Start(glow_frame, {
      color = color,
      startAnim = actions.glow_startAnim and true or false,
      xOffset = actions.glow_XOffset,
      yOffset = actions.glow_YOffset,
      duration = actions.glow_duration or 1,
      key = id
  })
  end
end

local glow_frame_monitor
local anchor_unitframe_monitor
Private.dyngroup_unitframe_monitor = {}
do
  local function frame_monitor_callback(event, frame, unit, previousUnit)
    local new_frame
    local FRAME_UNIT_UPDATE = event == "FRAME_UNIT_UPDATE"
    local FRAME_UNIT_ADDED = event == "FRAME_UNIT_ADDED"
    local FRAME_UNIT_REMOVED = event == "FRAME_UNIT_REMOVED"

    local dynamicGroupsToUpdate = {}

    if type(glow_frame_monitor) == "table" then
      for region, data in pairs(glow_frame_monitor) do
        if region.state and type(region.state.unit) == "string" and UnitIsUnit(region.state.unit, unit)
        and ((data.frame ~= frame) and (FRAME_UNIT_ADDED or FRAME_UNIT_UPDATE))
        or ((data.frame == frame) and FRAME_UNIT_REMOVED)
        then
          if not new_frame then
            new_frame = WeakAuras.GetUnitFrame(unit)
          end
          if new_frame ~= data.frame then
            local id = region.id .. (region.cloneId or "")
            -- remove previous glow
            if data.frame then
              actionGlowStop(data.actions, data.frame, id)
            end
            data.frame = new_frame
            if new_frame then
              -- apply the glow to new_frame
              actionGlowStart(data.actions, data.frame, id)
              -- update hidefunc
              local region = region
              region.active_glows_hidefunc = region.active_glows_hidefunc or {}
              region.active_glows_hidefunc[data.frame] = function()
                actionGlowStop(data.actions, data.frame, id)
                glow_frame_monitor[region] = nil
              end
            end
          end
        end
      end
    end
    if type(anchor_unitframe_monitor) == "table" then
      for region, data in pairs(anchor_unitframe_monitor) do
        if region.state and type(region.state.unit) == "string" and UnitIsUnit(region.state.unit, unit)
        and ((data.frame ~= frame) and (FRAME_UNIT_ADDED or FRAME_UNIT_UPDATE))
        or ((data.frame == frame) and FRAME_UNIT_REMOVED)
        then
          if not new_frame then
            new_frame = WeakAuras.GetUnitFrame(unit) or WeakAuras.HiddenFrames
          end
          if new_frame ~= data.frame then
            Private.AnchorFrame(data.data, region, data.parent)
          end
        end
      end
    end
    for regionData, data_frame in pairs(Private.dyngroup_unitframe_monitor) do
      if regionData.region.state and type(regionData.region.state.unit) == "string" and UnitIsUnit(regionData.region.state.unit, unit)
      and ((data_frame ~= frame) and (FRAME_UNIT_ADDED or FRAME_UNIT_UPDATE))
      or ((data_frame == frame) and FRAME_UNIT_REMOVED)
      then
        if not new_frame then
          new_frame = WeakAuras.GetUnitFrame(unit) or WeakAuras.HiddenFrames
        end
        if new_frame and new_frame ~= data_frame then
          dynamicGroupsToUpdate[regionData.parent] = true
        end
      end
    end

    for frame in pairs(dynamicGroupsToUpdate) do
      frame:DoPositionChildren()
    end
  end

  LGF.RegisterCallback("WeakAuras", "FRAME_UNIT_UPDATE", frame_monitor_callback)
  LGF.RegisterCallback("WeakAuras", "FRAME_UNIT_ADDED", frame_monitor_callback)
  LGF.RegisterCallback("WeakAuras", "FRAME_UNIT_REMOVED", frame_monitor_callback)
end

function Private.HandleGlowAction(actions, region)
  if actions.glow_action
  and (
    (
      (actions.glow_frame_type == "UNITFRAME" or actions.glow_frame_type == "NAMEPLATE")
      and region.state.unit
    )
    or (actions.glow_frame_type == "FRAMESELECTOR" and actions.glow_frame)
    or (actions.glow_frame_type == "PARENTFRAME" and region:GetParent())
  )
  then
    local glow_frame, should_glow_frame
    if actions.glow_frame_type == "FRAMESELECTOR" then
      if actions.glow_frame:sub(1, 10) == "WeakAuras:" then
        local frame_name = actions.glow_frame:sub(11)
        if WeakAuras.GetData(frame_name) then
          Private.EnsureRegion(frame_name)
        end
        if Private.regions[frame_name] and Private.regions[frame_name].region then
          glow_frame = Private.regions[frame_name].region
          should_glow_frame = true
        end
      else
        glow_frame = Private.GetSanitizedGlobal(actions.glow_frame)
        should_glow_frame = true
      end
    elseif actions.glow_frame_type == "UNITFRAME" and region.state.unit then
      glow_frame = WeakAuras.GetUnitFrame(region.state.unit)
      should_glow_frame = true
    elseif actions.glow_frame_type == "NAMEPLATE" and region.state.unit then
      glow_frame = WeakAuras.GetUnitNameplate(region.state.unit)
      should_glow_frame = true
    elseif actions.glow_frame_type == "PARENTFRAME" then
      glow_frame = region:GetParent()
      should_glow_frame = true
    end

    if should_glow_frame then
      local id = region.id .. (region.cloneId or "")
      if actions.glow_action == "show" then
        -- remove previous glow
        if glow_frame then
          if region.active_glows_hidefunc
          and region.active_glows_hidefunc[glow_frame]
          then
            region.active_glows_hidefunc[glow_frame]()
          end
          -- start glow
          actionGlowStart(actions, glow_frame, id)
          -- make unglow function & monitor unitframe changes
          region.active_glows_hidefunc = region.active_glows_hidefunc or {}
          if actions.glow_frame_type == "UNITFRAME" then
            region.active_glows_hidefunc[glow_frame] = function()
              actionGlowStop(actions, glow_frame, id)
              glow_frame_monitor[region] = nil
            end
          else
            region.active_glows_hidefunc[glow_frame] = function()
              actionGlowStop(actions, glow_frame, id)
            end
          end
        end
        if actions.glow_frame_type == "UNITFRAME" then
          glow_frame_monitor = glow_frame_monitor or {}
          glow_frame_monitor[region] = {
            actions = actions,
            frame = glow_frame
          }
        end
      elseif actions.glow_action == "hide"
      and glow_frame
      and region.active_glows_hidefunc
      and region.active_glows_hidefunc[glow_frame]
      then
        region.active_glows_hidefunc[glow_frame]()
        region.active_glows_hidefunc[glow_frame] = nil
      end
    end
  end
end

function Private.PerformActions(data, when, region)
  if (paused or WeakAuras.IsOptionsOpen()) then
    return;
  end;
  local actions;
  local formatters
  if(when == "start") then
    actions = data.actions.start;
    formatters = region.startFormatters
  elseif(when == "finish") then
    actions = data.actions.finish;
    formatters = region.finishFormatters
  else
    return;
  end

  if(actions.do_message and actions.message_type and actions.message) then
    local customFunc = Private.customActionsFunctions[data.id][when .. "_message"];
    Private.HandleChatAction(actions.message_type, actions.message, actions.message_dest, actions.message_dest_isunit, actions.message_channel, actions.r, actions.g, actions.b, region, {customFunc = customFunc}, when, formatters);
  end

  if (actions.stop_sound) then
    if (region.SoundStop) then
      local fadeoutTime = actions.do_sound_fade and actions.stop_sound_fade and actions.stop_sound_fade * 1000 or 0
      region:SoundStop(fadeoutTime);
    end
  end

  if(actions.do_sound and actions.sound) then
    if (region.SoundPlay) then
      region:SoundPlay(actions);
    end
  end

  if(actions.do_custom and actions.custom) then
    local func = Private.customActionsFunctions[data.id][when]
    if func then
      Private.ActivateAuraEnvironment(region.id, region.cloneId, region.state, region.states);
      xpcall(func, Private.GetErrorHandlerId(data.id, L["Custom Action"]));
      Private.ActivateAuraEnvironment(nil);
    end
  end

  -- Apply start glow actions even if squelch_actions is true, but don't apply finish glow actions
  if actions.do_glow then
    Private.HandleGlowAction(actions, region)
  end

  -- remove all glows on finish
  if when == "finish" and actions.hide_all_glows and region.active_glows_hidefunc then
    for _, hideFunc in pairs(region.active_glows_hidefunc) do
      hideFunc()
    end
    wipe(region.active_glows_hidefunc)
  end
  if when == "finish" and type(anchor_unitframe_monitor) == "table" then
    anchor_unitframe_monitor[region] = nil
  end
end

--- @type fun(id: auraId): auraData?
function WeakAuras.GetData(id)
  return id and db.displays[id];
end

local function GetTriggerSystem(data, triggernum)
  local triggerType = data.triggers[triggernum] and data.triggers[triggernum].trigger.type
  return triggerType and triggerTypes[triggerType]
end

local function wrapTriggerSystemFunction(functionName, mode)
  local func;
  func = function(data, triggernum, ...)
    if (not triggernum) then
      return func(data, data.triggers.activeTriggerMode or -1, ...);
    elseif (triggernum < 0) then
      local result;
      if (mode == "or") then
        result = false;
        for i = 1, #data.triggers do
          result = result or func(data, i);
        end
      elseif (mode == "and") then
        result = true;
        for i = 1, #data.triggers do
          result = result and func(data, i);
        end
      elseif (mode == "table") then
        result = {};
        for i = 1, #data.triggers do
          local tmp = func(data, i);
          if (tmp) then
            for k, v in pairs(tmp) do
              result[k] = v;
            end
          end
        end
      elseif (mode == "call") then
        for i = 1, #data.triggers do
          func(data, i, ...);
        end
      elseif (mode == "firstValue") then
        result = nil;
        for i = 1, #data.triggers do
          local tmp = func(data, i);
          if (tmp) then
            result = tmp;
            break;
          end
        end
      elseif (mode == "nameAndIcon") then
        for i = 1, #data.triggers do
          local tmp1, tmp2 = func(data, i);
          if (tmp1) then
            return tmp1, tmp2;
          end
        end
      end
      return result;
    else -- triggernum >= 1
      local triggerSystem = GetTriggerSystem(data, triggernum);
      if (not triggerSystem) then
        return false
      end
      return triggerSystem[functionName](data, triggernum, ...);
    end
  end
  return func;
end

Private.CanHaveTooltip = wrapTriggerSystemFunction("CanHaveTooltip", "or");
-- This has to be in WeakAuras for now, because GetNameAndIcon can be called from the options
-- before the Options has access to Private
WeakAuras.GetNameAndIcon = wrapTriggerSystemFunction("GetNameAndIcon", "nameAndIcon");
Private.GetTriggerDescription = wrapTriggerSystemFunction("GetTriggerDescription", "call");

local wrappedGetOverlayInfo = wrapTriggerSystemFunction("GetOverlayInfo", "table");

Private.GetAdditionalProperties = function(data)
  local props = {}
  for child in Private.TraverseLeafsOrAura(data) do
    for i, trigger in ipairs(child.triggers) do
      local triggerSystem = GetTriggerSystem(child, i)
      if triggerSystem then
        local triggerProps = triggerSystem.GetAdditionalProperties(child, i)
        if triggerProps and props[i] then
          MergeTable(props[i], triggerProps)
        elseif triggerProps then
          props[i] = triggerProps
        end
      end
    end
  end
  return props
end

Private.GetProgressSources = function(data)
  local values = {}
  if Private.IsGroupType(data) then
    return values
  end
  for i = 1, #data.triggers do
    local triggerSystem = GetTriggerSystem(data, i);
    if (triggerSystem) then
      triggerSystem.GetProgressSources(data, i, values)
    end
  end
  return values
end

Private.GetProgressSourceFor = function(data, trigger, property)
  local values = {}
  local triggerSystem = GetTriggerSystem(data, trigger);
  if (triggerSystem) then
    triggerSystem.GetProgressSources(data, trigger, values)
    for _, v in ipairs(values) do
      if v.property == property then
        return {trigger, v.type, v.property, v.total, v.modRate, v.inverse, v.paused, v.remaining}
      end
    end
  end
  return nil
end

-- In the aura data we only store trigger + property
-- But for the region we don't want to gather necessary meta data all the time
-- So we collect that in region:modify + on creation of the conditions function
Private.AddProgressSourceMetaData = function(data, progressSource)
  if not progressSource then
    return {}
  end
  local trigger = progressSource[1]
  local property = progressSource[2]
  if trigger == -2 then
    return {-2, "auto", ""}
  elseif trigger == -1 then
    return {-1, "auto", ""}
  elseif trigger == 0 then
    return {0, "manual", progressSource[3], progressSource[4]}
  else
    return Private.GetProgressSourceFor(data, trigger, property)
  end
end

-- ProgressSource values
-- For AceOptions to work correctly progress sources need to be comparable
-- via ==. We use a constants table so that identical tables use the same table
-- Additional while data.progressSource does contain additional data e.g. for manual progress
-- This is only for the progress source combobox, which only cares about the first or first two values
-- The greatness of the hacks knows no bounds
-- The constants table has weak keys
do
  local function CompareProgressValueTables(a, b)
    -- For auto/manual progress, only compare a[] with b[1]
    if a[1] == -1 or a[1] == 0 then
      return a[1] == b[1]
    end
    -- Only care about trigger + property
    return a[1] == b[1] and a[2] == b[2]
  end

  local progressValueConstants = {}
  setmetatable(progressValueConstants, {_mode = "v"})

  function Private.GetProgressValueConstant(v)
    if v == nil then
      return v
    end

    -- This uses pairs because there could be empty slots
    for _, constant in pairs(progressValueConstants) do
      if CompareProgressValueTables(v, constant) then
        return constant
      end
    end
    -- And this inserts into the first empty slot for the array
    tinsert(progressValueConstants, v)
    return v
  end
end

function Private.GetProgressSourcesForUi(data, subelement)
  local values

  if subelement then
    -- Sub elements Automatic means to use the main auras' progress
    values = {
      [{-2, ""}] = L["Automatic"]
    }
  else
    values = {
      [{-1, ""}] = L["Automatic"],
      [{0, ""}] = L["Manual"],
    }
  end

  local triggerValues = Private.GetProgressSources(data)
  for _, e in ipairs(triggerValues) do
    if e.trigger and e.property then
      values[{e.trigger, e.property}] = {L["Trigger %s"]:format(e.trigger), e.display}
    end
  end

  local result = {}
  for k, v in pairs(values) do
    result[Private.GetProgressValueConstant(k)] = v
  end

  return result
end


function Private.GetOverlayInfo(data, triggernum)
  local overlayInfo;
  if (data.controlledChildren) then
    overlayInfo = {};
    for child in Private.TraverseLeafs(data) do
      local tmp = wrappedGetOverlayInfo(child, triggernum);
      if (tmp) then
        for k, v in pairs(tmp) do
          overlayInfo[k] = v;
        end
      end
    end
  else
    overlayInfo = wrappedGetOverlayInfo(data, triggernum);
  end
  return overlayInfo;
end

function Private.GetTriggerConditions(data)
  local conditions = {};
  for i = 1, #data.triggers do
    local triggerSystem = GetTriggerSystem(data, i);
    if (triggerSystem) then
      conditions[i] = triggerSystem.GetTriggerConditions(data, i);
      conditions[i] = conditions[i] or {};
      conditions[i].show = {
        display = L["Active"],
        type = "bool",
        test = function(state, needle)
          return (state and state.id and triggerState[state.id].triggers[i] or false) == (needle == 1);
        end
      }
      conditions[i].activationTime = {
        display = L["Since Active"],
        type = "elapsedTimer",
        operator_types = "without_equal",

        test = function(state, needle, op)
          if state and state.id and triggerState[state.id] and triggerState[state.id].activationTime[i] then
            local activationTime = triggerState[state.id].activationTime[i]
            return (GetTime() <= activationTime + needle) == (op == "<=")
          end
        end,
        recheckTime = function(state, needle)
          if state and state.id and triggerState[state.id] and triggerState[state.id].activationTime[i] then
            return triggerState[state.id].activationTime[i] + needle
          end
        end,

      }
    end
  end
  return conditions;
end

local function CreateFallbackState(id, triggernum)
  fallbacksStates[id] = fallbacksStates[id] or {};
  fallbacksStates[id][triggernum] = fallbacksStates[id][triggernum] or {};

  local states = fallbacksStates[id][triggernum];
  states[""] = states[""] or {};
  local state = states[""];

  local data = db.displays[id];
  local triggerSystem = GetTriggerSystem(data, triggernum);
  if (triggerSystem) then
    triggerSystem.CreateFallbackState(data, triggernum, state)
    state.id = id
    state.trigger = data.triggers[triggernum].trigger
    state.triggernum = triggernum
  else
    state.show = true;
    state.changed = true;
    state.progressType = "timed";
    state.duration = 0;
    state.expirationTime = math.huge;
  end

  state.id = id

  return states;
end

local currentTooltipRegion;
local currentTooltipOwner;
local function UpdateMouseoverTooltip(region)
  if(region == currentTooltipRegion) then
    Private.ShowMouseoverTooltip(currentTooltipRegion, currentTooltipOwner);
  end
end

function Private.ShowMouseoverTooltip(region, owner)
  currentTooltipRegion = region;
  currentTooltipOwner = owner;

  GameTooltip:SetOwner(owner, "ANCHOR_NONE");
  GameTooltip:SetPoint("LEFT", owner, "RIGHT");
  GameTooltip:ClearLines();

  local triggerType;
  if (region.state) then
    triggerType = region.state.trigger.type;
  end

  local triggerSystem = triggerType and triggerTypes[triggerType];
  if (not triggerSystem) then
    GameTooltip:Hide();
    return;
  end

  if (triggerSystem.SetToolTip(region.state.trigger, region.state)) then
    GameTooltip:Show();
  else
    GameTooltip:Hide();
  end
end

function Private.HideTooltip()
  currentTooltipRegion = nil;
  currentTooltipOwner = nil;
  -- If a tooltip was shown for a "restricted" frame, that is e.g. for a aura
  -- anchored to a nameplate, then that frame is no longer clamped to the screen,
  -- because restricted frames can't be clamped. So dance to make the tooltip
  -- unrestricted and then clamp it again.
  GameTooltip:ClearAllPoints()
  GameTooltip:SetPoint("RIGHT", UIParent, "LEFT");
  GameTooltip:SetClampedToScreen(true)

  GameTooltip:Hide()
end

do
  local hiddenTooltip;
  function WeakAuras.GetHiddenTooltip()
    if not(hiddenTooltip) then
      hiddenTooltip = CreateFrame("GameTooltip", "WeakAurasTooltip", nil, "GameTooltipTemplate");
      hiddenTooltip:SetOwner(WorldFrame, "ANCHOR_NONE");
      hiddenTooltip:AddFontStrings(
        hiddenTooltip:CreateFontString("$parentTextLeft1", nil, "GameTooltipText"),
        hiddenTooltip:CreateFontString("$parentTextRight1", nil, "GameTooltipText")
      );
    end
    return hiddenTooltip;
  end
end

function WeakAuras.GetAuraInstanceTooltipInfo(unit, auraInstanceId, filter)
  if WeakAuras.IsRetail() then
    local tooltipText = ""
    local tooltipData
    if filter == "HELPFUL" then
      tooltipData = C_TooltipInfo.GetUnitBuffByAuraInstanceID(unit, auraInstanceId, filter)
    else
      tooltipData = C_TooltipInfo.GetUnitDebuffByAuraInstanceID(unit, auraInstanceId, filter)
    end
    if not tooltipData then
      return nil, "", "none", 0
    end
    local secondLine = tooltipData.lines[2] -- This is the line we want
    if secondLine and secondLine.leftText then
      tooltipText = secondLine.leftText
    end
    return tooltipData.dataInstanceID, Private.ParseTooltipText(tooltipText)
  end
end

function Private.ParseTooltipText(tooltipText)
  local debuffType = "none";
  local tooltipSize = {};
  if(tooltipText) then
    for t in tooltipText:gmatch("(-?%d[%d%.,]*)") do
      if (LARGE_NUMBER_SEPERATOR == ",") then
        t = t:gsub(",", "");
      else
        t = t:gsub("%.", "");
        t = t:gsub(",", ".");
      end
      tinsert(tooltipSize, tonumber(t));
    end
  end

  if (#tooltipSize) then
    return tooltipText, debuffType, unpack(tooltipSize);
  else
    return tooltipText, debuffType, 0;
  end
end

function WeakAuras.GetAuraTooltipInfo(unit, index, filter)
  local tooltipText = ""
  if WeakAuras.IsRetail() then
    local tooltipData = C_TooltipInfo.GetUnitAura(unit, index, filter)
    local secondLine = tooltipData and tooltipData.lines[2] -- This is the line we want
    if secondLine and secondLine.leftText then
      tooltipText = secondLine.leftText
    end
  else
    local tooltip = WeakAuras.GetHiddenTooltip();
    tooltip:ClearLines();
    tooltip:SetUnitAura(unit, index, filter);
    local tooltipTextLine = select(5, tooltip:GetRegions())
    tooltipText = tooltipTextLine and tooltipTextLine:GetObjectType() == "FontString" and tooltipTextLine:GetText() or "";
  end

  return Private.ParseTooltipText(tooltipText)
end

local FrameTimes = {};
function WeakAuras.ProfileFrames(all)
  UpdateAddOnCPUUsage();
  for name, frame in pairs(Private.frames) do
    local FrameTime = GetFrameCPUUsage(frame);
    FrameTimes[name] = FrameTimes[name] or 0;
    if(all or FrameTime > FrameTimes[name]) then
      print("|cFFFF0000"..name.."|r -", FrameTime, "-", FrameTime - FrameTimes[name]);
    end
    FrameTimes[name] = FrameTime;
  end
end

local DisplayTimes = {};
function WeakAuras.ProfileDisplays(all)
  UpdateAddOnCPUUsage();
  for id, regionData in pairs(Private.regions) do
    if regionData.region then
      local DisplayTime = GetFrameCPUUsage(regionData.region, true);
      DisplayTimes[id] = DisplayTimes[id] or 0;
      if(all or DisplayTime > DisplayTimes[id]) then
        print("|cFFFF0000"..id.."|r -", DisplayTime, "-", DisplayTime - DisplayTimes[id]);
      end
      DisplayTimes[id] = DisplayTime;
    end
  end
end

function Private.ValueFromPath(data, path)
  if not data then
    return nil
  end
  if (#path == 0) then
    return data
  elseif(#path == 1) then
    return data[path[1]];
  else
    local reducedPath = {};
    for i=2,#path do
      reducedPath[i-1] = path[i];
    end
    return Private.ValueFromPath(data[path[1]], reducedPath);
  end
end

function Private.ValueToPath(data, path, value)
  if not data then
    return
  end
  if(#path == 1) then
    data[path[1]] = value;
  else
    local reducedPath = {};
    for i=2,#path do
      reducedPath[i-1] = path[i];
    end
    Private.ValueToPath(data[path[1]], reducedPath, value);
  end
end

Private.frameLevels = {};
local function SetFrameLevel(id, frameLevel)
  if (Private.frameLevels[id] == frameLevel) then
    return;
  end
  if (Private.regions[id] and Private.regions[id].region) then
    Private.ApplyFrameLevel(Private.regions[id].region, frameLevel)
  end
  if (clones[id]) then
    for i,v in pairs(clones[id]) do
      Private.ApplyFrameLevel(v, frameLevel)
    end
  end
  Private.frameLevels[id] = frameLevel;
end

local function FixGroupChildrenOrderImpl(data, frameLevel)
  SetFrameLevel(data.id, frameLevel)
  local offset
  if data.sharedFrameLevel then
    offset = 0
  else
    offset = 4
  end
  for _, childId in ipairs(data.controlledChildren) do
    local childData = WeakAuras.GetData(childId)
    if childData.regionType ~= "group" and childData.regionType ~= "dynamicgroup" then
      frameLevel = frameLevel + offset
      SetFrameLevel(childId, frameLevel)
    else
      frameLevel = frameLevel + offset
      local endFrameLevel = FixGroupChildrenOrderImpl(childData, frameLevel)
      if not data.sharedFrameLevel then
        frameLevel = endFrameLevel
      end
    end
  end
  return frameLevel
end

function Private.FixGroupChildrenOrderForGroup(data)
  if data.parent then
    return
  end
  FixGroupChildrenOrderImpl(data, 0)
end

local function GetFrameLevelFor(id)
  return Private.frameLevels[id] or 5;
end

function Private.ApplyFrameLevel(region, frameLevel)
  frameLevel = frameLevel or GetFrameLevelFor(region.id)

  local setBackgroundFrameLevel = false
  if region.subRegions then
    for index, subRegion in pairs(region.subRegions) do
      if subRegion.type == "subbackground" then
        subRegion:SetFrameLevel(frameLevel + index)
        setBackgroundFrameLevel = true
      end
    end

    if not setBackgroundFrameLevel then
      region:SetFrameLevel(frameLevel)
    end

    for index, subRegion in pairs(region.subRegions) do
      if subRegion.type ~= "subbackground" then
        subRegion:SetFrameLevel(frameLevel + index)
      end
    end
  else
    region:SetFrameLevel(frameLevel)
  end
end

function WeakAuras.EnsureString(input)
  if (input == nil) then
    return "";
  end
  return tostring(input);
end

-- Handle coroutines
---@alias threadPriority 'urgent' | 'normal' | 'background' | 'instant'
---@alias threadPool table<string, threadData>
---@class threadData
---@field thread thread
---@field sequence table<string, number> to help debug problems in threads
---@class Threads
---@field pools table<threadPriority, threadPool>
local threads = {
  frame = CreateFrame("Frame"),
  size = 0,
  ---@type table<string, threadPriority>
  prios = {},
  pools = {
    urgent = {},
    normal = {},
    background = {},
    instant = {},
  },
};
do

  ---@type table<threadPriority, true>
  local validPriorities = {
    urgent = true,
    normal = true,
    background = true,
    instant = true,
  }

  -- Add an action to be resumed via OnUpdate
  ---@param name string
  ---@param thread thread | function
  ---@param prio threadPriority?
  function threads:Add(name, thread, prio)
    if not prio or not validPriorities[prio] then
      prio = "normal"
    end
    if type(thread) == "function" then
      thread = coroutine.create(thread)
    end
    if not self.prios[name] then
      self.prios[name] = prio
      self.pools[prio][name] = {
        thread = thread,
        sequence = {}
      }
      self.size = self.size + 1
      self.frame:Show()
    end
  end

  ---@param name string
  ---@param prio threadPriority
  function threads:SetPriority(name, prio)
    local oldPrio = self.prios[name]
    if oldPrio and oldPrio ~= prio then
      self.pools[prio][name] = self.pools[oldPrio][name]
      self.pools[oldPrio][name] = nil
      self.prios[name] = prio
    end
  end

  -- Remove an action from OnUpdate
  ---@param name string
  function threads:Remove(name)
    local prio = self.prios[name]
    if prio then
      local pool = self.pools[prio]
      pool[name] = nil
      self.prios[name] = nil
      self.size = self.size - 1
      if self.size == 0 then
        self.frame:Hide()
      end
    end
  end


  ---@param pool threadPool
  ---@param finish number
  ---@param defaultEstimate number
  local function runThreadPool(pool, finish, defaultEstimate)
    local start = debugprofilestop()
    if finish <= start then return end
    local estimates = {}
    local ok, val1, val2
    local continue = false
    repeat
      continue = false
      for name, threadData in pairs(pool) do
        local estimate = estimates[name] or defaultEstimate
        if debugprofilestop() + estimate > finish then
          break
        else
          continue = true
          ok, val1, val2 = coroutine.resume(threadData.thread)
          if not ok then
            geterrorhandler()(val1 .. '\n' .. debugstack(threadData.thread))
          end
          if coroutine.status(threadData.thread) ~= "dead" then
            estimates[name] = type(val1) == "number" and val1 or defaultEstimate
            local sequence = val2 or "" --[[@as string]]
            threadData.sequence[sequence] = (threadData.sequence[sequence] or 0) + 1
          else
            threads:Remove(name)
          end
        end
      end
    until not continue
  end


  ---@param name string
  ---@param func thread
  ---@param limit number
  ---@param defaultEstimate number?
  function threads:Immediate(name, func, limit, defaultEstimate)
    self:Add(name, func, "instant")
    runThreadPool(self.pools.instant, debugprofilestop() + limit, defaultEstimate or 1000)
    if coroutine.status(func) ~= "dead" then
      self:SetPriority(name, "urgent")
    else
      self:Remove(name)
    end
  end

  -- Setup frame
  threads.frame:Hide();
  threads.frame:SetScript("OnUpdate", function()
    local start = debugprofilestop();
    runThreadPool(threads.pools.urgent, start + 15000, 1000)
    runThreadPool(threads.pools.normal, start + 20, 1)
    runThreadPool(threads.pools.background, start + 2, 0.5)
  end);
  threads.frame:RegisterEvent("PLAYER_REGEN_ENABLED")
  threads.frame:RegisterEvent("PLAYER_REGEN_DISABLED")
  threads.frame:SetScript("OnEvent", function(self, event)
    if event == "PLAYER_REGEN_ENABLED" and self:IsShown() then
      self:Hide()
    elseif event == "PLAYER_REGEN_DISABLED" and not self:IsShown() and threads.size > 0 then
      self:Show()
    end
  end)
end

Private.Threads = threads;

function WeakAuras.RegisterTriggerSystem(types, triggerSystem)
  for _, v in ipairs(types) do
    triggerTypes[v] = triggerSystem;
  end
  tinsert(triggerSystems, triggerSystem);
end

function WeakAuras.RegisterTriggerSystemOptions(types, func)
  for _, v in ipairs(types) do
    Private.triggerTypesOptions[v] = func;
  end
end

function WeakAuras.GetTriggerStateForTrigger(id, triggernum)
  if (triggernum == -1) then
    return Private.GetGlobalConditionState();
  end
  if triggerState[id][triggernum] == nil then
    triggerState[id][triggernum] = setmetatable({}, Private.allstatesMetatable)
  end
  return triggerState[id][triggernum];
end

function WeakAuras.GetActiveStates(id)
  return triggerState[id].activeStates
end

function WeakAuras.GetActiveTriggers(id)
  return triggerState[id].triggers
end

do
  --- @type table<auraId, boolean>
  local visibleFakeStates = {}

  --- @type fun(_: any, uid: uid, id: auraId)
  local function OnDelete(_, uid, id)
    visibleFakeStates[id] = nil
  end

  --- @type fun(_: any, uid: uid, oldId: auraId, newId: auraId)
  local function OnRename(_, uid, oldId, newId)
    visibleFakeStates[newId] = visibleFakeStates[oldId]
    visibleFakeStates[oldId] = nil
  end

  Private.callbacks:RegisterCallback("Delete", OnDelete)
  Private.callbacks:RegisterCallback("Rename", OnRename)

  local UpdateFakeTimesHandle

  local function UpdateFakeTimers()
    local suspended = Private.PauseAllDynamicGroups()
    local t = GetTime()
    for id, triggers in pairs(triggerState) do
      local changed = false
      for triggernum, triggerData in ipairs(triggers) do
        for id, state in pairs(triggerData) do
          if state.progressType == "timed" then
            local expirationTime = state.expirationTime
            local duration = state.duration
            if expirationTime and type(expirationTime) == "number" and expirationTime < t
               and duration and type(duration) == "number" and duration > 0
            then
              state.expirationTime = t + state.duration
              state.changed = true
              changed = true
            end
          end
        end
      end
      if changed then
        Private.UpdatedTriggerState(id)
      end
    end
    Private.ResumeAllDynamicGroups(suspended)
  end

  function Private.SetFakeStates()
    if UpdateFakeTimesHandle then
      return
    end

    for id, states in pairs(triggerState) do
      local changed
      for triggernum in ipairs(states) do
        changed = Private.SetAllStatesHidden(id, triggernum) or changed
      end
      if changed then
        Private.UpdatedTriggerState(id)
      end
    end
    UpdateFakeTimesHandle = timer:ScheduleRepeatingTimer(UpdateFakeTimers, 1)
  end

  function Private.ClearFakeStates()
    timer:CancelTimer(UpdateFakeTimesHandle)
    for id in pairs(triggerState) do
      Private.FakeStatesFor(id, false)
    end
  end

  function Private.FakeStatesFor(id, visible)
    if visibleFakeStates[id] == visible then
      return visibleFakeStates[id]
    end
    if visible then
      visibleFakeStates[id] = true
      Private.UpdateFakeStatesFor(id)
    else
      visibleFakeStates[id] = false
      if triggerState[id] then
        local changed = false
        for triggernum in ipairs(triggerState[id]) do
          changed = Private.SetAllStatesHidden(id, triggernum) or changed
        end
        if changed then
          Private.UpdatedTriggerState(id)
        end
      end
    end
    return not visibleFakeStates[id]
  end

  function Private.UpdateFakeStatesFor(id)
    if (WeakAuras.IsOptionsOpen() and visibleFakeStates[id]) then
      local data = WeakAuras.GetData(id)
      if (data) then
        for triggernum in ipairs(data.triggers) do
          Private.SetAllStatesHidden(id, triggernum)
          local triggerSystem = GetTriggerSystem(data, triggernum)
          if triggerSystem and triggerSystem.CreateFakeStates then
            triggerSystem.CreateFakeStates(id, triggernum)
          end
        end
        Private.UpdatedTriggerState(id)
        if WeakAuras.GetMoverSizerId() == id then
          WeakAuras.SetMoverSizer(id)
        end
      end
    end
  end
end

--- @type fun(id: auraId, triggernum: integer, cloneId: string)
local function stopAutoHideTimer(id, triggernum, cloneId)
  if(timers[id] and timers[id][triggernum] and timers[id][triggernum][cloneId]) then
    local record = timers[id][triggernum][cloneId];
    if (record.handle) then
      timer:CancelTimer(record.handle);
    end
    record.handle = nil;
    record.expirationTime = nil;
    record.state = nil
  end
end

--- @type fun(id: auraId, triggernum: integer, cloneId: string, state: state)
local function startStopTimers(id, cloneId, triggernum, state)
  if not state.show or not state.autoHide then
    stopAutoHideTimer(id, triggernum, cloneId)
    return
  end

  -- state.autoHide can be a timer, or a boolean
  -- if it's a bool, for backwards compability we look at paused
  local expirationTime
  if type(state.autoHide) == "boolean" then
    if state.paused then
      stopAutoHideTimer(id, triggernum, cloneId)
      return
    else
      if state.expirationTime == nil and type(state.duration) == "number" then
        -- Set the expiration time, because users rely on that, even though it's wrong to do
        state.expirationTime = GetTime() + state.duration
      end
      expirationTime = state.expirationTime
    end
  elseif type(state.autoHide) == "number" then
    expirationTime = state.autoHide
  end

  timers[id] = timers[id] or {};
  timers[id][triggernum] = timers[id][triggernum] or {};
  timers[id][triggernum][cloneId] = timers[id][triggernum][cloneId] or {};
  local record = timers[id][triggernum][cloneId];
  if (record.expirationTime ~= expirationTime or record.state ~= state) then
    if (record.handle ~= nil) then
      timer:CancelTimer(record.handle);
    end

    if expirationTime and type(expirationTime) == "number" then
      record.handle = timer:ScheduleTimerFixed(
        function()
          if (state.show ~= false and state.show ~= nil) then
            state.show = false;
            state.changed = true;

            -- if the trigger has updated then check to see if it is flagged for WatchedTrigger and send to queue if it is
            if Private.watched_trigger_events[id] and Private.watched_trigger_events[id][triggernum] then
              Private.AddToWatchedTriggerDelay(id, triggernum)
            end
            Private.UpdatedTriggerState(id);
          end
        end,
        expirationTime - GetTime());
      record.expirationTime = expirationTime;
      record.state = state
    end
  end
end

local function ApplyStateToRegion(id, cloneId, region, parent)
  -- Force custom text function to be run again
  region.values.customTextUpdated = false
  region:Update();

  region.subRegionEvents:Notify("Update", region.state, region.states)

  UpdateMouseoverTooltip(region);
  region:Expand();
  if parent and parent.ActivateChild then
    parent:ActivateChild(id, cloneId)
  end
end

-- Fallbacks if the states are empty
local emptyState = {};
emptyState[""] = {};

local function applyToTriggerStateTriggers(stateShown, id, triggernum)
  if (stateShown and not triggerState[id].triggers[triggernum]) then
    triggerState[id].triggers[triggernum] = true;
    triggerState[id].triggerCount = triggerState[id].triggerCount + 1;
    triggerState[id].activationTime[triggernum] = GetTime()
    return true;
  elseif (not stateShown and triggerState[id].triggers[triggernum]) then
    triggerState[id].triggers[triggernum] = false;
    triggerState[id].triggerCount = triggerState[id].triggerCount - 1;
    triggerState[id].activationTime[triggernum] = nil
    return true;
  end

  return false;
end

local function evaluateTriggerStateTriggers(id)
  local result = false;

  if WeakAuras.IsOptionsOpen() then
    -- While the options are open ignore the combination function
    return triggerState[id].triggerCount > 0
  end

  if (triggerState[id].disjunctive == "any" and triggerState[id].triggerCount > 0) then
    result = true;
  elseif(triggerState[id].disjunctive == "all" and triggerState[id].triggerCount == triggerState[id].numTriggers) then
    result = true;
  else
    if (triggerState[id].disjunctive == "custom" and triggerState[id].triggerLogicFunc) then
      Private.ActivateAuraEnvironment(id)
      local ok, returnValue = xpcall(triggerState[id].triggerLogicFunc, Private.GetErrorHandlerId(id, L["Custom Trigger Combination"]), triggerState[id].triggers);
      Private.ActivateAuraEnvironment()
      result = ok and returnValue;
    end
  end

  return result;
end

local function ApplyStatesToRegions(id, activeTrigger, states)
  -- Show new clones
  local data = WeakAuras.GetData(id)
  local parent
  if data and data.parent then
    parent = Private.EnsureRegion(data.parent)
  end
  if parent and parent.Suspend then
    parent:Suspend()
  end
  for cloneId, state in pairs(states) do
    if (state.show) then
      local region = Private.EnsureRegion(id, cloneId);
      local applyChanges = not region.toShow or state.changed or region.state ~= state
      region.state = state
      region.states = region.states or {}
      for triggernum = -1, triggerState[id].numTriggers do
        local triggerState
        if triggernum == activeTrigger then
          triggerState = state
        else
          local triggerStates = WeakAuras.GetTriggerStateForTrigger(id, triggernum)
          triggerState = triggerStates[cloneId] or triggerStates[""] or {}
        end
        if triggernum > 0 then
          applyChanges = applyChanges or region.states[triggernum] ~= triggerState or (triggerState and triggerState.changed)
                       or region.states[triggernum] ~= triggerState
                       or (triggerState and triggerState.changed)
        end

        region.states[triggernum] = triggerState
      end

      if (applyChanges) then
        ApplyStateToRegion(id, cloneId, region, parent);
        Private.RunConditions(region, data.uid, not state.show)
      end
    end
  end
  if parent and parent.Resume then
    parent:Resume()
  end
end

-- handle trigger updates that have been requested to be sent into custom
-- we need the id and triggernum that's changing, but can't send the ScanEvents to the custom trigger until after UpdatedTriggerState has fired
local delayed_watched_trigger = {}
function Private.AddToWatchedTriggerDelay(id, triggernum)
  delayed_watched_trigger[id] = delayed_watched_trigger[id] or {}
  tinsert(delayed_watched_trigger[id], triggernum)
end

Private.callbacks:RegisterCallback("Delete", function(_, uid, id)
  delayed_watched_trigger[id] = nil
end)

Private.callbacks:RegisterCallback("Rename", function(_, uid, oldId, newId)
  delayed_watched_trigger[newId] = delayed_watched_trigger[oldId]
  delayed_watched_trigger[oldId] = nil
end)

function Private.SendDelayedWatchedTriggers()
  if WeakAuras.IsOptionsOpen() then
    return
  end
  for id in pairs(delayed_watched_trigger) do
    local watched = delayed_watched_trigger[id]
    -- Since the observers are themselves observable, we set the list of observers to
    -- empty here.
    delayed_watched_trigger[id] = {}
    Private.ScanEventsWatchedTrigger(id, watched)
  end
end

function Private.UpdatedTriggerState(id)
  if (not triggerState[id]) then
    return;
  end

  local changed = false;
  for triggernum = 1, triggerState[id].numTriggers do
    triggerState[id][triggernum] = triggerState[id][triggernum] or setmetatable({}, Private.allstatesMetatable)

    local anyStateShown = false;

    for cloneId, state in pairs(triggerState[id][triggernum]) do
      state.trigger = db.displays[id].triggers[triggernum] and db.displays[id].triggers[triggernum].trigger;
      state.triggernum = triggernum;
      state.id = id;

      if (state.changed) then
        startStopTimers(id, cloneId, triggernum, state);
      end
      anyStateShown = anyStateShown or state.show;
    end
    -- Update triggerState.triggers
    changed = applyToTriggerStateTriggers(anyStateShown, id, triggernum) or changed;
  end

  -- Figure out whether we should be shown or not
  local show = triggerState[id].show;

  if (changed or show == nil) then
    show = evaluateTriggerStateTriggers(id);
  end

  -- Figure out which subtrigger is active, and if it changed
  local newActiveTrigger = triggerState[id].activeTriggerMode;
  if (newActiveTrigger == Private.trigger_modes.first_active) then
    -- Mode is first active trigger, so find a active trigger
    for i = 1, triggerState[id].numTriggers do
      if (triggerState[id].triggers[i]) then
        newActiveTrigger = i;
        break;
      end
    end
  end

  local oldShow = triggerState[id].show;
  triggerState[id].show = show;
  triggerState[id].fallbackStates = nil

  local activeTriggerState = WeakAuras.GetTriggerStateForTrigger(id, newActiveTrigger);
  if (not next(activeTriggerState)) then
    if (show) then
      activeTriggerState = CreateFallbackState(id, newActiveTrigger)
    else
      activeTriggerState = emptyState;
    end
  elseif (show) then
    local needsFallback = true;
    for _, state in pairs(activeTriggerState) do
      if (state.show) then
        needsFallback = false;
        break;
      end
    end
    if (needsFallback) then
      activeTriggerState = CreateFallbackState(id, newActiveTrigger)
    end
  end
  triggerState[id].activeStates = activeTriggerState

  local region;
  -- Now apply
  if (show and not oldShow) then -- Hide => Show
    ApplyStatesToRegions(id, newActiveTrigger, activeTriggerState);
  elseif (not show and oldShow) then -- Show => Hide
    for _, clone in pairs(clones[id]) do
      clone:Collapse()
    end
    if Private.regions[id] and Private.regions[id].region then
      Private.regions[id].region:Collapse()
    end
  elseif (show and oldShow) then -- Already shown, update regions
    -- Hide old clones
    for cloneId, clone in pairs(clones[id]) do
      if (not activeTriggerState[cloneId] or not activeTriggerState[cloneId].show) then
        clone:Collapse()
      end
    end
    if (not activeTriggerState[""] or not activeTriggerState[""].show) then
      if Private.regions[id] and Private.regions[id].region then
        Private.regions[id].region:Collapse()
      end
    end
    -- Show new states
    ApplyStatesToRegions(id, newActiveTrigger, activeTriggerState);
  end

  for triggernum = 1, triggerState[id].numTriggers do
    for cloneId, state in pairs(triggerState[id][triggernum]) do
      if (not state.show) then
        triggerState[id][triggernum][cloneId] = nil;
      end
      state.changed = false;
    end
  end
  -- once updatedTriggerStates is complete, and empty states removed, etc., then check for queued watched triggers update
  Private.SendDelayedWatchedTriggers()
end

function Private.RunCustomTextFunc(region, customFunc)

  if not customFunc then
    return nil
  end

  local state = region.state

  Private.ActivateAuraEnvironment(region.id, region.cloneId, region.state, region.states);

  local progress = Private.dynamic_texts.p.func(Private.dynamic_texts.p.get(state), state, 1)
  local dur = Private.dynamic_texts.t.func(Private.dynamic_texts.t.get(state), state, 1)
  local name = Private.dynamic_texts.n.func(Private.dynamic_texts.n.get(state))
  local icon = Private.dynamic_texts.i.func(Private.dynamic_texts.i.get(state))
  local stacks = Private.dynamic_texts.s.func(Private.dynamic_texts.s.get(state))
  local expirationTime
  local duration

  if state then
    if state.progressType == "timed" then
      expirationTime = state.expirationTime
      duration = state.duration
    else
      expirationTime = state.total
      duration = state.value
    end
  end

  local custom = {select(2, xpcall(customFunc, Private.GetErrorHandlerId(region.id, L["Custom Text Function"]), expirationTime or math.huge, duration or 0, progress, dur, name, icon, stacks))}
  Private.ActivateAuraEnvironment(nil)

  return custom
end

local function ReplaceValuePlaceHolders(textStr, region, customCache, state, formatter, trigger)
  local value;

  local customIndexSubStr = textStr:match("^c(%d*)$")

  if customIndexSubStr then
    local custom
    if customCache then
      if not customCache.custom then
        customCache.custom = Private.RunCustomTextFunc(region, customCache.customFunc)
      end
      custom = customCache.custom
    else
      custom = region.values.custom
    end

    local index = tonumber(customIndexSubStr) or 1

    if custom then
      value = custom[index]
    end

    if value == nil then value = "" end

    if formatter then
      value = formatter(value, state)
    end

    if custom then
      value = WeakAuras.EnsureString(value)
    end
  else
    local variable = Private.dynamic_texts[textStr];
    if (not variable) then
      return nil;
    end
    value = variable.get(state)
    if formatter then
      value = formatter(value, state, trigger)
    elseif variable.func then
      value = variable.func(value)
    end
  end

  return type(value) ~= "table" and value or ""
end

-- States:
-- 0 Normal state, text is just appended to result. Can transition to percent start state 1 via %
-- 1 Percent start state, entered via %. Can transition to via { to braced, via % to normal, AZaz09 to percent rest state
-- 2 Percent rest state, stay in it via AZaz09, transition to normal on anything else
-- 3 Braced state, } transitions to normal, everything else stay in braced state
local function nextState(char, state)
  if state == 0 then -- Normal State
    if char == 37 then -- % sign
      return 1 -- Enter Percent state
    end
    return 0
  elseif state == 1 then -- Percent Start State
    if char == 37 then -- % sign
      return 0 -- Return to normal state
    elseif char == 123 then -- { sign
      return 3 -- Enter Braced state
    elseif (char >= 48 and char <= 57) or (char >= 65 and char <= 90) or (char >= 97 and char <= 122) or char == 46 then
        -- 0-9a-zA-Z or dot character
      return 2 -- Enter Percent rest state
    end
    return 0 -- % followed by non alpha-numeric. Back to normal state
  elseif state == 2 then
    if (char >= 48 and char <= 57) or (char >= 65 and char <= 90) or (char >= 97 and char <= 122) or char == 46 then
      return 2 -- Continue in same state
    end
    if char == 37 then
      return 1 -- End of %, but also start of new %
    end
    return 0 -- Back to normal
  elseif state == 3 then
    if char == 125 then -- } closing brace
      return 0 -- Back to normal
    end
    return 3
  end
  -- Shouldn't happen
  return state
end

local function ContainsPlaceHolders(textStr, symbolFunc, checkDoublePercent)
  if not textStr then
    return false
  end

  local endPos = textStr:len();
  local state = 0
  local currentPos = 1
  local start = 1
  local containsDoublePercent = false
  while currentPos <= endPos do
    local char = string.byte(textStr, currentPos);
    local nextState = nextState(char, state)

    if state == 1 then -- Last char was a %
      if char == 123 then -- {
        start = currentPos + 1
      elseif char == 37 then -- %
        containsDoublePercent = true
        start = currentPos
      else
        start = currentPos
      end
    elseif state == 2 or state == 3 then
      if nextState == 0 or nextState == 1 then
        local symbol = string.sub(textStr, start, currentPos - 1)
        if symbolFunc(symbol) then
          return true
        end
      end
    end

    state = nextState
    currentPos = currentPos + 1
  end

  if state == 2 then
    local symbol = string.sub(textStr, start, currentPos - 1)
    if symbolFunc(symbol) then
      return true
    end
  end

  if checkDoublePercent then
    return containsDoublePercent
  end
  return false
end

function Private.ContainsCustomPlaceHolder(textStr)
  return ContainsPlaceHolders(textStr, function(symbol)
    return string.match(symbol, "^c%d*$")
  end)
end

function Private.ContainsPlaceHolders(textStr, toCheck)
  return ContainsPlaceHolders(textStr, function(symbol)
    if symbol:len() == 1 and toCheck:find(symbol, 1, true) then
     return true
    end

   local _, last = symbol:find("^%d+%.")
   if not last then
     return false
   end

   symbol = symbol:sub(last + 1)
   if symbol:len() == 1 and toCheck:find(symbol, 1, true) then
     return true
   end
  end)
end

function Private.ContainsAnyPlaceHolders(textStr)
  return ContainsPlaceHolders(textStr, function(symbol) return true end, true)
end

Private.ContainsPlaceHoldersPredicate = ContainsPlaceHolders

local function ValueForSymbol(symbol, region, customCache, regionState, regionStates, useHiddenStates, formatters)
  local triggerNum, sym = string.match(symbol, "(.+)%.(.+)")
  triggerNum = triggerNum and tonumber(triggerNum)
  if triggerNum and sym then
    if regionStates[triggerNum] then
      if (useHiddenStates or regionStates[triggerNum].show) then
        if regionStates[triggerNum][sym] then
          local value = regionStates[triggerNum][sym]
          if formatters[symbol] then
            return tostring(formatters[symbol](value, regionStates[triggerNum], triggerNum) or "") or ""
          else
            return tostring(value) or ""
          end
        else
          local value = ReplaceValuePlaceHolders(sym, region, customCache, regionStates[triggerNum], formatters[symbol], triggerNum);
          return value or ""
        end
      end
    end
    return ""
  elseif regionState[symbol] then
    if(useHiddenStates or regionState.show) then
      local value = regionState[symbol]
      if formatters[symbol] then
        return tostring(formatters[symbol](value, regionState, regionState.triggernum) or "") or ""
      else
        return tostring(value) or ""
      end
    end
    return ""
  else
    local value = (useHiddenStates or regionState.show)
                  and ReplaceValuePlaceHolders(symbol, region, customCache, regionState, formatters[symbol], regionState.triggernum)
    return value or ""
  end
end

function Private.ReplacePlaceHolders(textStr, region, customCache, useHiddenStates, formatters)
  local regionValues = region.values;
  local regionState = region.state or {};
  local regionStates = region.states or {};
  if (not regionState and not regionValues) then
    return ""
  end
  local endPos = textStr:len();
  if (endPos < 2) then
    textStr = textStr:gsub("\\n", "\n");
    return textStr;
  end

  if (endPos == 2) then -- Two byte string, quickly check for all cases
    if string.byte(textStr, 1) == 37 then -- "%"
      local symbol = string.sub(textStr, 2)
      if symbol == "%" then
        return "%" -- Double % input
      end
      local value = ValueForSymbol(symbol, region, customCache, regionState, regionStates, useHiddenStates, formatters);
      if (value) then
        textStr = tostring(value);
      end
    end
    textStr = textStr:gsub("\\n", "\n");
    return textStr;
  end

  local result = ""
  local currentPos = 1 -- Position of the "cursor"
  local state = 0
  local start = 1 -- Start of whatever "word" we are currently considering, doesn't include % or {} symbols

  while currentPos <= endPos do
    local char = string.byte(textStr, currentPos);
    if state == 0 then -- Normal State
      if char == 37 then -- % sign
        if currentPos > start then
          result = result .. string.sub(textStr, start, currentPos - 1)
        end
      end
    elseif state == 1 then -- Percent Start State
      if char == 123 then -- { sign
        start = currentPos + 1
      else
        start = currentPos
      end
    elseif state == 2 then -- Percent Rest State
      if (char >= 48 and char <= 57) or (char >= 65 and char <= 90) or (char >= 97 and char <= 122) or char == 46 then
        -- 0-9a-zA-Z or dot character
      else -- End of variable
        local symbol = string.sub(textStr, start, currentPos - 1)
        result = result .. ValueForSymbol(symbol, region, customCache, regionState, regionStates, useHiddenStates, formatters)

        if char == 37 then
          -- Do nothing
        else
          start = currentPos
        end
      end
    elseif state == 3 then
      if char == 125 then -- } closing brace
        local symbol = string.sub(textStr, start, currentPos - 1)
        result = result .. ValueForSymbol(symbol, region, customCache, regionState, regionStates, useHiddenStates, formatters)
        start = currentPos + 1
      end
    end
    state = nextState(char, state)
    currentPos = currentPos + 1
  end

  if state == 0 and currentPos > start then
    result = result .. string.sub(textStr, start, currentPos - 1)
  elseif state == 2 and currentPos > start then
    local symbol = string.sub(textStr, start, currentPos - 1)
    result = result .. ValueForSymbol(symbol, region, customCache, regionState, regionStates, useHiddenStates, formatters)
  elseif state == 1 then
    result = result .. "%"
  end

  textStr = result:gsub("\\n", "\n");
  return textStr;
end

function Private.ParseTextStr(textStr, symbolCallback)
  if not textStr then
    return
  end
  local endPos = textStr:len();
  local currentPos = 1 -- Position of the "cursor"
  local state = 0
  local start = 1 -- Start of whatever "word" we are currently considering, doesn't include % or {} symbols

  while currentPos <= endPos do
    local char = string.byte(textStr, currentPos);
    if state == 0 then -- Normal State
    elseif state == 1 then -- Percent Start State
      if char == 123 then
        start = currentPos + 1
      else
        start = currentPos
      end
    elseif state == 2 then -- Percent Rest State
      if (char >= 48 and char <= 57) or (char >= 65 and char <= 90) or (char >= 97 and char <= 122) or char == 46 then
        -- 0-9a-zA-Z or dot character
      else -- End of variable
        local symbol = string.sub(textStr, start, currentPos - 1)
        symbolCallback(symbol)
        if char == 37 then
          -- Do nothing
        else
          start = currentPos
        end
      end
    elseif state == 3 then
      if char == 125 then -- } closing brace
        local symbol = string.sub(textStr, start, currentPos - 1)
        symbolCallback(symbol)
        start = currentPos + 1
      end
    end
    state = nextState(char, state)
    currentPos = currentPos + 1
  end

  if state == 2 and currentPos > start then
    local symbol = string.sub(textStr, start, currentPos - 1)
    symbolCallback(symbol)
  end
end

function Private.SetDefaultFormatters(data, input, keyPrefix, metaData)
  local seenSymbols = {}
  local setDefaultFormatters = function(symbol)
    if not data[keyPrefix .. symbol .. "_format"] and not seenSymbols[symbol] then
      local trigger, sym = string.match(symbol, "(.+)%.(.+)")
      sym = sym or symbol

      local formatter, args = Private.DefaultFormatterFor(metaData, trigger, sym)
      data[keyPrefix .. symbol .. "_format"] = formatter
      for arg, value in pairs(args or {}) do
        data[keyPrefix .. symbol .. "_" .. arg] = value
      end
    end
    seenSymbols[symbol] = true
  end
  Private.ParseTextStr(input, setDefaultFormatters)
end

function Private.DefaultFormatterFor(stateMetaData, trigger, sym)
  local formatter
  local args = {}
  if sym == "p" or sym == "t" then
    return "timed", { time_dynamic_threshold = 3 }
  end

  trigger = tonumber(trigger)
  if trigger then
    local metaData = stateMetaData[trigger] and stateMetaData[trigger][sym]
    if metaData then
      formatter = metaData.formatter
      if metaData.formatterArgs then
        for arg, value in pairs(metaData.formatterArgs) do
          args[arg] = value
        end
      end
    end
  else
    for index, perTriggerData in pairs(stateMetaData) do
      if perTriggerData[sym] then
        if not formatter then
          formatter = perTriggerData[sym].formatter
        else
          if formatter ~= perTriggerData[sym].formatter then
            return "none"
          end
        end
      end
    end
  end

  return formatter or "none", args
end

function Private.CreateFormatters(input, getter, withoutColor, data)
  local seenSymbols = {}
  local formatters = {}
  local everyFrameFormatters = {}

  local parseFn = function(symbol)
    if not seenSymbols[symbol] then
      local _, sym = string.match(symbol, "(.+)%.(.+)")
      sym = sym or symbol
      if sym == "i" then
        -- Do nothing
      else
        local default = (sym == "p" or sym == "t") and "timed" or "none"
        local selectedFormat = getter(symbol ..  "_format", default)
        if (Private.format_types[selectedFormat]) then
          formatters[symbol], everyFrameFormatters[symbol] = Private.format_types[selectedFormat].CreateFormatter(symbol, getter, withoutColor, data)
        end
      end
    end
    seenSymbols[symbol] = true
  end

  if type(input) == "string" then
    Private.ParseTextStr(input, parseFn)
  elseif type(input) == "table" then
    for _, v in ipairs(input) do
      Private.ParseTextStr(v, parseFn)
    end
  end

  return formatters, everyFrameFormatters
end

function Private.AnyEveryFrameFormatters(textStr, everyFrameFormatters)
  if next(everyFrameFormatters) then
    local function predicate(symbol)
      if everyFrameFormatters[symbol] then
        return true
      end
    end
    return Private.ContainsPlaceHoldersPredicate(textStr, predicate)
  end
end

function Private.IsAuraActive(uid)
  local id = Private.UIDtoID(uid)
  local active = triggerState[id];

  return active and active.show;
end

function WeakAuras.IsAuraActive(id)
  local active = triggerState[id]

  return active and active.show
end

-- Attach to Cursor/Frames code
-- Very simple function to convert a hsv angle to a color with
-- value hardcoded to 1 and saturation hardcoded to 0.75
local function colorWheel(angle)
  local hh = angle / 60;
  local i = floor(hh);
  local ff = hh - i;
  local p = 0;
  local q = 0.75 * (1.0 - ff);
  local t = 0.75 * ff;
  if (i == 0) then
    return 0.75, t, p;
  elseif (i == 1) then
    return q, 0.75, p;
  elseif (i == 2) then
    return p, 0.75, t;
  elseif (i == 3) then
    return p, q, 0.75;
  elseif (i == 4) then
    return t, p, 0.75;
  else
    return 0.75, p, q;
  end
end

local function xPositionNextToOptions()
  local xOffset;
  local optionsFrame = Private.OptionsFrame();
  local centerX = (optionsFrame:GetLeft() + optionsFrame:GetRight()) / 2;
  if (centerX > GetScreenWidth() / 2) then
    if (optionsFrame:GetLeft() > 400) then
      xOffset = optionsFrame:GetLeft() - 200;
    else
      xOffset = optionsFrame:GetLeft() / 2;
    end
  else
    if (GetScreenWidth() - optionsFrame:GetRight() > 400 ) then
      xOffset = optionsFrame:GetRight() + 200;
    else
      xOffset = (GetScreenWidth() + optionsFrame:GetRight()) / 2;
    end
  end

  return xOffset;
end

local mouseFrame;
local function ensureMouseFrame()
  if (mouseFrame) then
    return;
  end
  ---@class Frame
  mouseFrame = CreateFrame("Frame", "WeakAurasAttachToMouseFrame", UIParent);
  mouseFrame.attachedVisibleFrames = {};
  mouseFrame:SetWidth(1);
  mouseFrame:SetHeight(1);

  local moverFrame = CreateFrame("Frame", "WeakAurasMousePointerFrame", mouseFrame);
  mouseFrame.moverFrame = moverFrame;
  moverFrame:SetPoint("TOPLEFT", mouseFrame, "CENTER");
  moverFrame:SetWidth(32);
  moverFrame:SetHeight(32);
  moverFrame:SetFrameStrata("FULLSCREEN"); -- above settings dialog

  moverFrame:EnableMouse(true)
  moverFrame:SetScript("OnMouseDown", function()
    mouseFrame:SetMovable(true);
    mouseFrame:StartMoving()
  end);
  moverFrame:SetScript("OnMouseUp", function()
    mouseFrame:StopMovingOrSizing();
    mouseFrame:SetMovable(false);
    local xOffset = mouseFrame:GetRight() - GetScreenWidth();
    local yOffset = mouseFrame:GetTop() - GetScreenHeight();
    db.mousePointerFrame = db.mousePointerFrame or {};
    db.mousePointerFrame.xOffset = xOffset;
    db.mousePointerFrame.yOffset = yOffset;
  end);
  moverFrame.colorWheelAnimation = function()
    local angle = ((GetTime() - moverFrame.startTime) % 5) / 5 * 360;
    moverFrame.texture:SetVertexColor(colorWheel(angle));
  end;
  local texture = moverFrame:CreateTexture(nil, "BACKGROUND");
  moverFrame.texture = texture;
  texture:SetAllPoints(moverFrame);
  texture:SetTexture("Interface\\Cursor\\Point");

  local label = moverFrame:CreateFontString(nil, "BACKGROUND", "GameFontHighlightSmall")
  label:SetJustifyH("LEFT")
  label:SetJustifyV("TOP")
  label:SetPoint("TOPLEFT", moverFrame, "BOTTOMLEFT");
  label:SetText("WeakAuras Anchor");

  moverFrame:Hide();

  mouseFrame.OptionsOpened = function()
    if (db.mousePointerFrame) then
      -- Restore from settings
      mouseFrame:ClearAllPoints();
      mouseFrame:SetPoint("TOPRIGHT", UIParent, "TOPRIGHT", db.mousePointerFrame.xOffset, db.mousePointerFrame.yOffset);
    else
      -- Fnd a suitable position
      local optionsFrame = Private.OptionsFrame();
      local yOffset = (optionsFrame:GetTop() + optionsFrame:GetBottom()) / 2;
      local xOffset = xPositionNextToOptions();
      -- We use the top right, because the main frame uses the top right as the reference too
      mouseFrame:ClearAllPoints();
      mouseFrame:SetPoint("TOPRIGHT", UIParent, "TOPRIGHT", xOffset - GetScreenWidth(), yOffset - GetScreenHeight());
    end
    -- Change the color of the mouse cursor
    moverFrame.startTime = GetTime();
    moverFrame:SetScript("OnUpdate", moverFrame.colorWheelAnimation);
    mouseFrame:SetScript("OnUpdate", nil);
  end

  mouseFrame.moveWithMouse = function()
    local scale = 1 / UIParent:GetEffectiveScale();
    local x, y =  GetCursorPosition();
    mouseFrame:SetPoint("CENTER", UIParent, "BOTTOMLEFT", x * scale, y * scale);
  end

  mouseFrame.OptionsClosed = function()
    moverFrame:Hide();
    mouseFrame:ClearAllPoints();
    mouseFrame:SetScript("OnUpdate", mouseFrame.moveWithMouse);
    moverFrame:SetScript("OnUpdate", nil);
    wipe(mouseFrame.attachedVisibleFrames);
  end

  mouseFrame.expand = function(self, id)
    local data = WeakAuras.GetData(id);
    if (data.anchorFrameType == "MOUSE") then
      self.attachedVisibleFrames[id] = true;
      self:updateVisible();
    end
  end

  mouseFrame.collapse = function(self, id)
    self.attachedVisibleFrames[id] = nil;
    self:updateVisible();
  end

  mouseFrame.rename = function(self, oldid, newid)
    self.attachedVisibleFrames[newid] = self.attachedVisibleFrames[oldid];
    self.attachedVisibleFrames[oldid] = nil;
    self:updateVisible();
  end

  mouseFrame.delete = function(self, id)
    self.attachedVisibleFrames[id] = nil;
    self:updateVisible();
  end

  mouseFrame.anchorFrame = function(self, id, anchorFrameType)
    if (anchorFrameType == "MOUSE") then
      self.attachedVisibleFrames[id] = true;
    else
      self.attachedVisibleFrames[id] = nil;
    end
    self:updateVisible();
  end

  mouseFrame.updateVisible = function(self)
    if (not WeakAuras.IsOptionsOpen()) then
      return;
    end

    if (next(self.attachedVisibleFrames)) then
      mouseFrame.moverFrame:Show();
    else
      mouseFrame.moverFrame:Hide();
    end
  end

  if (WeakAuras.IsOptionsOpen()) then
    mouseFrame:OptionsOpened();
  else
    mouseFrame:OptionsClosed();
  end

  Private.mouseFrame = mouseFrame;
end

local personalRessourceDisplayFrame;
function Private.ensurePRDFrame()
  if (personalRessourceDisplayFrame) then
    return;
  end
  personalRessourceDisplayFrame = CreateFrame("Frame", "WeakAurasAttachToPRD", UIParent);
  personalRessourceDisplayFrame:Hide();
  personalRessourceDisplayFrame.attachedVisibleFrames = {};
  -- force an early frame draw; otherwise this frame won't be drawn until the next frame,
  -- and any attached auras won't have a valid rect
  personalRessourceDisplayFrame:SetPoint("CENTER", UIParent, "CENTER");
  personalRessourceDisplayFrame:SetSize(16, 16)
  personalRessourceDisplayFrame:GetSize()
  Private.personalRessourceDisplayFrame = personalRessourceDisplayFrame;

  local moverFrame = CreateFrame("Frame", "WeakAurasPRDMoverFrame", personalRessourceDisplayFrame);
  personalRessourceDisplayFrame.moverFrame = moverFrame;
  moverFrame:SetPoint("TOPLEFT", personalRessourceDisplayFrame, "TOPLEFT", -2, 2);
  moverFrame:SetPoint("BOTTOMRIGHT", personalRessourceDisplayFrame, "BOTTOMRIGHT", 2, -2);
  moverFrame:SetFrameStrata("FULLSCREEN"); -- above settings dialog

  moverFrame:EnableMouse(true)
  moverFrame:SetScript("OnMouseDown", function()
    personalRessourceDisplayFrame:SetMovable(true);
    personalRessourceDisplayFrame:StartMoving()
  end);
  moverFrame:SetScript("OnMouseUp", function()
    personalRessourceDisplayFrame:StopMovingOrSizing();
    personalRessourceDisplayFrame:SetMovable(false);
    local xOffset = personalRessourceDisplayFrame:GetRight();
    local yOffset = personalRessourceDisplayFrame:GetTop();

    db.personalRessourceDisplayFrame = db.personalRessourceDisplayFrame or {};
    local scale = UIParent:GetEffectiveScale() / personalRessourceDisplayFrame:GetEffectiveScale();
    db.personalRessourceDisplayFrame.xOffset = xOffset / scale - GetScreenWidth();
    db.personalRessourceDisplayFrame.yOffset = yOffset / scale - GetScreenHeight();
  end);
  moverFrame:Hide();

  local texture = moverFrame:CreateTexture(nil, "BACKGROUND");
  personalRessourceDisplayFrame.texture = texture;
  texture:SetAllPoints(moverFrame);
  texture:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\PRDFrame");

  local label = moverFrame:CreateFontString(nil, "BACKGROUND", "GameFontHighlight")
  label:SetPoint("CENTER", moverFrame, "CENTER");
  label:SetText("WeakAuras Anchor");

  personalRessourceDisplayFrame:RegisterEvent('NAME_PLATE_UNIT_ADDED');
  personalRessourceDisplayFrame:RegisterEvent('NAME_PLATE_UNIT_REMOVED');

  personalRessourceDisplayFrame.Attach = function(self, frame, frameTL, frameBR)
    self:SetParent(frame);
    self:ClearAllPoints();
    self:SetPoint("TOPLEFT", frameTL, "TOPLEFT");
    self:SetPoint("BOTTOMRIGHT", frameBR, "BOTTOMRIGHT");
    self:Show()
  end

  personalRessourceDisplayFrame.Detach = function(self, frame)
    self:ClearAllPoints();
    self:Hide()
    self:SetParent(UIParent)
  end

  personalRessourceDisplayFrame.OptionsOpened = function()
    personalRessourceDisplayFrame:Detach();
    personalRessourceDisplayFrame:SetScript("OnEvent", nil);
    personalRessourceDisplayFrame:ClearAllPoints();
    personalRessourceDisplayFrame:Show()
    local xOffset, yOffset;
    if (db.personalRessourceDisplayFrame) then
      xOffset = db.personalRessourceDisplayFrame.xOffset;
      yOffset = db.personalRessourceDisplayFrame.yOffset;
    end

    -- Calculate size of self nameplate
    local prdWidth;
    local prdHeight;

    if (KuiNameplatesCore and KuiNameplatesCore.profile) then
      prdWidth = KuiNameplatesCore.profile.frame_width_personal;
      prdHeight = KuiNameplatesCore.profile.frame_height_personal;
      if (KuiNameplatesCore.profile.ignore_uiscale) then
        local _, screenWidth = GetPhysicalScreenSize();
        local uiScale = 1;
        if (screenWidth) then
          uiScale = 768 / screenWidth;
        end
        personalRessourceDisplayFrame:SetScale(uiScale / UIParent:GetEffectiveScale());
      else
        personalRessourceDisplayFrame:SetScale(1);
      end
      personalRessourceDisplayFrame.texture:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\PRDFrameKui");
    else
      local namePlateVerticalScale = tonumber(GetCVar("NamePlateVerticalScale"));
      local zeroBasedScale = namePlateVerticalScale - 1.0;
      local clampedZeroBasedScale = Saturate(zeroBasedScale);
      local horizontalScale = tonumber(GetCVar("NamePlateHorizontalScale"));
      local baseNamePlateWidth = NamePlateDriverFrame.baseNamePlateWidth;
      prdWidth = baseNamePlateWidth * horizontalScale * Lerp(1.1, 1.0, clampedZeroBasedScale) - 24;
      prdHeight = 4 * namePlateVerticalScale * Lerp(1.2, 1.0, clampedZeroBasedScale) * 2  + 1;
      personalRessourceDisplayFrame:SetScale(1 / UIParent:GetEffectiveScale());
      personalRessourceDisplayFrame.texture:SetTexture("Interface\\AddOns\\WeakAuras\\Media\\Textures\\PRDFrame");
    end

    local scale = UIParent:GetEffectiveScale() / personalRessourceDisplayFrame:GetEffectiveScale();
    if (not xOffset or not yOffset) then
      local optionsFrame = Private.OptionsFrame();
      yOffset = optionsFrame:GetBottom() + prdHeight / scale - GetScreenHeight();
      xOffset = xPositionNextToOptions() + prdWidth / 2 / scale - GetScreenWidth();
    end

    xOffset = xOffset * scale;
    yOffset = yOffset * scale;

    personalRessourceDisplayFrame:SetPoint("TOPRIGHT", UIParent, "TOPRIGHT", xOffset, yOffset);
    personalRessourceDisplayFrame:SetPoint("BOTTOMLEFT", UIParent, "TOPRIGHT", xOffset - prdWidth, yOffset - prdHeight);
  end

  personalRessourceDisplayFrame.OptionsClosed = function()
    personalRessourceDisplayFrame:SetScale(1);
    local frame = C_NamePlate.GetNamePlateForUnit("player");
    if (frame) then
      if (Plater and frame.unitFrame.PlaterOnScreen) then
        personalRessourceDisplayFrame:Attach(frame, frame.unitFrame.healthBar, frame.unitFrame.powerBar);
      elseif (frame.kui and frame.kui.bg and frame.kui:IsShown()) then
        personalRessourceDisplayFrame:Attach(frame.kui, frame.kui.bg, frame.kui.bg);
      elseif (ElvUIPlayerNamePlateAnchor) then
        personalRessourceDisplayFrame:Attach(ElvUIPlayerNamePlateAnchor, ElvUIPlayerNamePlateAnchor, ElvUIPlayerNamePlateAnchor);
      else
        personalRessourceDisplayFrame:Attach(frame, frame.UnitFrame.healthBar, NamePlateDriverFrame.classNamePlatePowerBar);
      end
    else
      personalRessourceDisplayFrame:Detach();
      personalRessourceDisplayFrame:Hide();
    end

    personalRessourceDisplayFrame:SetScript("OnEvent", personalRessourceDisplayFrame.eventHandler);
    personalRessourceDisplayFrame.texture:Hide();
    personalRessourceDisplayFrame.moverFrame:Hide();
    wipe(personalRessourceDisplayFrame.attachedVisibleFrames);
  end

  personalRessourceDisplayFrame.eventHandler = function(self, event, nameplate)
    Private.StartProfileSystem("prd");
    if (event == "NAME_PLATE_UNIT_ADDED") then
      if (UnitIsUnit(nameplate, "player")) then
        local frame = C_NamePlate.GetNamePlateForUnit("player");
        if (frame) then
          if (Plater and frame.unitFrame.PlaterOnScreen) then
            personalRessourceDisplayFrame:Attach(frame, frame.unitFrame.healthBar, frame.unitFrame.powerBar);
          elseif (frame.kui and frame.kui.bg and frame.kui:IsShown()) then
            personalRessourceDisplayFrame:Attach(frame.kui, KuiNameplatesPlayerAnchor, KuiNameplatesPlayerAnchor);
          elseif (ElvUIPlayerNamePlateAnchor) then
            personalRessourceDisplayFrame:Attach(ElvUIPlayerNamePlateAnchor, ElvUIPlayerNamePlateAnchor, ElvUIPlayerNamePlateAnchor);
          else
            personalRessourceDisplayFrame:Attach(frame, frame.UnitFrame.healthBar, NamePlateDriverFrame.classNamePlatePowerBar);
          end
          personalRessourceDisplayFrame:Show();
          db.personalRessourceDisplayFrame = db.personalRessourceDisplayFrame or {};
        else
          personalRessourceDisplayFrame:Detach();
          personalRessourceDisplayFrame:Hide();
        end
      end
    elseif (event == "NAME_PLATE_UNIT_REMOVED") then
      if (UnitIsUnit(nameplate, "player")) then
        personalRessourceDisplayFrame:Detach();
        personalRessourceDisplayFrame:Hide();
      end
    end
    Private.StopProfileSystem("prd");
  end

  personalRessourceDisplayFrame.expand = function(self, id)
    local data = WeakAuras.GetData(id);
    if (data.anchorFrameType == "PRD") then
      self.attachedVisibleFrames[id] = true;
      self:updateVisible();
    end
  end

  personalRessourceDisplayFrame.collapse = function(self, id)
    self.attachedVisibleFrames[id] = nil;
    self:updateVisible();
  end

  personalRessourceDisplayFrame.rename = function(self, oldid, newid)
    self.attachedVisibleFrames[newid] = self.attachedVisibleFrames[oldid];
    self.attachedVisibleFrames[oldid] = nil;
    self:updateVisible();
  end

  personalRessourceDisplayFrame.delete = function(self, id)
    self.attachedVisibleFrames[id] = nil;
    self:updateVisible();
  end

  personalRessourceDisplayFrame.anchorFrame = function(self, id, anchorFrameType)
    if (anchorFrameType == "PRD" or anchorFrameType == "NAMEPLATE") then
      self.attachedVisibleFrames[id] = true;
    else
      self.attachedVisibleFrames[id] = nil;
    end
    self:updateVisible();
  end

  personalRessourceDisplayFrame.updateVisible = function(self)
    if (not WeakAuras.IsOptionsOpen()) then
      return;
    end

    if (next(self.attachedVisibleFrames)) then
      personalRessourceDisplayFrame.texture:Show();
      personalRessourceDisplayFrame.moverFrame:Show();
      personalRessourceDisplayFrame:Show();
    else
      personalRessourceDisplayFrame.texture:Hide();
      personalRessourceDisplayFrame.moverFrame:Hide();
      personalRessourceDisplayFrame:Hide();
    end
  end

  if (WeakAuras.IsOptionsOpen()) then
    personalRessourceDisplayFrame.OptionsOpened();
  else
    personalRessourceDisplayFrame.OptionsClosed();
  end
  Private.personalRessourceDisplayFrame = personalRessourceDisplayFrame
end

local postPonedAnchors = {};
local anchorTimer

local function tryAnchorAgain()
  local delayed = postPonedAnchors;
  postPonedAnchors = {};
  anchorTimer = nil;

  for id, _ in pairs(delayed) do
    local data = WeakAuras.GetData(id);
    local region = WeakAuras.GetRegion(id);
    if (data and region) then
      local parent = WeakAurasFrame;
      local parentData
      if data.parent then
        parentData = WeakAuras.GetData(data.parent)
        if parentData and Private.EnsureRegion(data.parent) then
          parent = Private.regions[data.parent].region
        end
      end
      if not parentData or parentData.regionType ~= "dynamicgroup" then
        Private.AnchorFrame(data, region, parent)
      end
    end
  end
end

local function postponeAnchor(id)
  postPonedAnchors[id] = true;
  if (not anchorTimer) then
    anchorTimer = timer:ScheduleTimer(tryAnchorAgain, 1);
  end
end

local HiddenFrames = CreateFrame("Frame", "WeakAurasHiddenFrames")
HiddenFrames:Hide()
WeakAuras.HiddenFrames = HiddenFrames

local function GetAnchorFrame(data, region, parent)
  local id = region.id
  local anchorFrameType = data.anchorFrameType
  local anchorFrameFrame = data.anchorFrameFrame
  if not id then return end
  if (personalRessourceDisplayFrame) then
    personalRessourceDisplayFrame:anchorFrame(id, anchorFrameType);
  end

  if (mouseFrame) then
    mouseFrame:anchorFrame(id, anchorFrameType);
  end

  if (anchorFrameType == "SCREEN") then
    return parent;
  end

  if (anchorFrameType == "UIPARENT") then
    return UIParent;
  end

  if (anchorFrameType == "PRD") then
    Private.ensurePRDFrame();
    personalRessourceDisplayFrame:anchorFrame(id, anchorFrameType);
    return personalRessourceDisplayFrame;
  end

  if (anchorFrameType == "MOUSE") then
    ensureMouseFrame();
    mouseFrame:anchorFrame(id, anchorFrameType);
    return mouseFrame;
  end

  if (anchorFrameType == "NAMEPLATE") then
    local unit = region.state and region.state.unit
    if unit then
      local frame = unit and WeakAuras.GetUnitNameplate(unit)
      if frame then return frame end
    end
    if WeakAuras.IsOptionsOpen() then
      Private.ensurePRDFrame()
      personalRessourceDisplayFrame:anchorFrame(id, anchorFrameType)
      return personalRessourceDisplayFrame
    end
  end

  if (anchorFrameType == "UNITFRAME") then
    local unit = region.state and region.state.unit
    if unit then
      local frame = WeakAuras.GetUnitFrame(unit) or WeakAuras.HiddenFrames
      if frame then
        anchor_unitframe_monitor = anchor_unitframe_monitor or {}
        anchor_unitframe_monitor[region] = {
          data = data,
          parent = parent,
          frame = frame
        }
        return frame
      end
    end
  end

  if (anchorFrameType == "SELECTFRAME" and anchorFrameFrame) then
    if(anchorFrameFrame:sub(1, 10) == "WeakAuras:") then
      local frame_name = anchorFrameFrame:sub(11);
      if (frame_name == id) then
        return parent;
      end

      if Private.regions[frame_name] and Private.regions[frame_name].region then
        return Private.regions[frame_name].region;
      end
      postponeAnchor(id);
    else
      if (Private.GetSanitizedGlobal(anchorFrameFrame)) then
        return Private.GetSanitizedGlobal(anchorFrameFrame);
      end
      postponeAnchor(id);
      return parent;
    end
  end

  if (anchorFrameType == "CUSTOM" and region.customAnchorFunc) then
    Private.StartProfileSystem("custom region anchor")
    Private.StartProfileAura(region.id)
    Private.ActivateAuraEnvironment(region.id, region.cloneId, region.state)
    local ok, frame = xpcall(region.customAnchorFunc, Private.GetErrorHandlerId(region.id, L["Custom Anchor"]))
    Private.ActivateAuraEnvironment()
    Private.StopProfileSystem("custom region anchor")
    Private.StopProfileAura(region.id)
    if ok and frame then
      return frame
    elseif WeakAuras.IsOptionsOpen() then
      return parent
    else
      return HiddenFrames
    end
  end
  -- Fallback
  return parent;
end

local anchorFrameDeferred = {}

function Private.AnchorFrame(data, region, parent, force)
  if data.anchorFrameType == "CUSTOM"
  and (data.regionType == "group" or data.regionType == "dynamicgroup")
  and not WeakAuras.IsLoginFinished()
  and not force
  then
    if not anchorFrameDeferred[data.id] then
      loginQueue[#loginQueue + 1] = {Private.AnchorFrame, {data, region, parent, true}}
      anchorFrameDeferred[data.id] = true
    end
  else
    local anchorParent = GetAnchorFrame(data, region, parent);
    if not anchorParent then return end
    if (data.anchorFrameParent or data.anchorFrameParent == nil
        or data.anchorFrameType == "SCREEN" or data.anchorFrameType == "UIPARENT" or data.anchorFrameType == "MOUSE") then
      xpcall(region.SetParent, Private.GetErrorHandlerId(data.id, L["Anchoring"]), region, anchorParent);
    else
      region:SetParent(parent or WeakAurasFrame);
    end

    local anchorPoint = data.anchorPoint
    if data.parent then
      if data.anchorFrameType == "SCREEN" or data.anchorFrameType == "MOUSE" then
        anchorPoint = "CENTER"
      end
    else
      if data.anchorFrameType == "MOUSE" then
        anchorPoint = "CENTER"
      end
    end

    region:SetAnchor(data.selfPoint, anchorParent, anchorPoint);

    if(data.frameStrata == 1) then
      region:SetFrameStrata(region:GetParent():GetFrameStrata());
    else
      region:SetFrameStrata(Private.frame_strata_types[data.frameStrata]);
    end
    Private.ApplyFrameLevel(region)
    anchorFrameDeferred[data.id] = nil
  end
end

function Private.FindUnusedId(prefix)
  prefix = prefix or "New"
  local num = 2;
  local id = prefix
  while(db.displays[id]) do
    id = prefix .. " " .. num;
    num = num + 1;
  end
  return id
end

function WeakAuras.SetModel(frame, unused, model_fileId, isUnit, isDisplayInfo)
  if isDisplayInfo then
    pcall(frame.SetDisplayInfo, frame, tonumber(model_fileId))
  elseif isUnit then
    pcall(frame.SetUnit, frame, model_fileId)
  else
    pcall(frame.SetModel, frame, tonumber(model_fileId))
  end
end

function Private.IsCLEUSubevent(subevent)
  if Private.subevent_prefix_types[subevent] then
     return true
  else
    for prefix in pairs(Private.subevent_prefix_types) do
      if subevent:match(prefix) then
        local suffix = subevent:sub(#prefix + 1)
        if Private.subevent_suffix_types[suffix] then
          return true
        end
      end
    end
  end
  return false
end

--- SafeToNumber converts a string to number, but only if it fits into a unsigned 32bit integer
--- The C api often takes only 32bit values, and complains if passed a value outside
---@param input any
---@return number|nil number
function WeakAuras.SafeToNumber(input)
  local nr = tonumber(input)
  return nr and (nr < 2147483648 and nr > -2147483649) and nr or nil
end

local textSymbols = {
  ["{rt1}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_1:0|t",
  ["{rt2}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_2:0|t",
  ["{rt3}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_3:0|t",
  ["{rt4}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_4:0|t",
  ["{rt5}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_5:0|t",
  ["{rt6}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_6:0|t",
  ["{rt7}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_7:0|t",
  ["{rt8}"] = "|TInterface\\TargetingFrame\\UI-RaidTargetingIcon_8:0|t"
}

---@param txt string
---@return string result
function WeakAuras.ReplaceRaidMarkerSymbols(txt)
  local start = 1

  while true do
    local firstChar = txt:find("{", start, true)
    if not firstChar then
      return txt
    end
    local lastChar = txt:find("}", firstChar, true)
    if not lastChar then
      return txt
    end
    local replace = textSymbols[txt:sub(firstChar, lastChar)]
    if replace then
      txt = txt:sub(1, firstChar - 1) .. replace .. txt:sub(lastChar + 1)
      start = firstChar + #replace
    else
      start = lastChar
    end
  end
end

function Private.ReplaceLocalizedRaidMarkers(txt)
  local start = 1

  while true do
    local firstChar = txt:find("{", start, true)
    if not firstChar then
      return txt
    end
    local lastChar = txt:find("}", firstChar, true)
    if not lastChar then
      return txt
    end

    local symbol = strlower(txt:sub(firstChar + 1, lastChar - 1))
    if ICON_TAG_LIST[symbol] then
      local replace = "rt" .. ICON_TAG_LIST[symbol]
      if replace then
        txt = txt:sub(1, firstChar) .. replace .. txt:sub(lastChar)
        start = firstChar + #replace
      else
        start = lastChar
      end
    else
      start  = lastChar
    end
  end
end

-- WORKAROUND
-- UnitPlayerControlled doesn't work if the target is "too" far away
--- @return boolean?
function Private.UnitPlayerControlledFixed(unit)
  local guid = UnitGUID(unit)
  return guid and guid:sub(1, 6) == "Player"
end

do
  local trackableUnits = {}
  trackableUnits["player"] = true
  trackableUnits["target"] = true
  trackableUnits["focus"] = true
  trackableUnits["pet"] = true
  trackableUnits["vehicle"] = true
  trackableUnits["softenemy"] = true
  trackableUnits["softfriend"] = true
  for i = 1, 5 do
    trackableUnits["arena" .. i] = true
    trackableUnits["arenapet" .. i] = true
  end

  for i = 1, 4 do
    trackableUnits["party" .. i] = true
    trackableUnits["partypet" .. i] = true
  end

  for i = 1, 10 do
    trackableUnits["boss" .. i] = true
  end

  for i = 1, 40 do
    trackableUnits["raid" .. i] = true
    trackableUnits["raidpet" .. i] = true
    trackableUnits["nameplate" .. i] = true
  end

  ---@param unit UnitToken
  ---@return boolean? result
  function WeakAuras.IsUntrackableSoftTarget(unit)
    if not Private.soft_target_cvars[unit] then return end
    -- technically this is incorrect if user doesn't have KBM and sets CVar to "2" (KBM only)
    -- but, there doesn't seem to be a way to detect 'user lacks KBM'
    -- anyways, the intersection of people who know how to set cvars and also don't have KBM for WoW is probably nil
    -- that might change if WoW ever ends up on playstation & friends, but also hell might freeze over so who knows
    local threshold = C_GamePad.IsEnabled() and 1 or 2
    return (tonumber(C_CVar.GetCVar(Private.soft_target_cvars[unit])) or 0) < threshold
  end

  ---@param unit UnitToken
  ---@return boolean result
  function WeakAuras.UntrackableUnit(unit)
    return not trackableUnits[unit]
  end
end

do
  local ownRealm = select(2, UnitFullName("player"))
  ---@param unit UnitToken
  ---@return string name
  ---@return string realm
  function WeakAuras.UnitNameWithRealm(unit)
    ownRealm = ownRealm or select(2, UnitFullName("player"))
    local name, realm = UnitFullName(unit)
    return name or "", realm or ownRealm or ""
  end

  function WeakAuras.UnitNameWithRealmCustomName(unit)
    ownRealm = ownRealm or select(2, UnitFullName("player"))
    local name, realm =  WeakAuras.UnitFullName(unit)
    return name or "", realm or ownRealm or ""
  end
end

function Private.ExecEnv.ParseNameCheck(name)
  local matches = {
    name = {},
    realm = {},
    full = {},
    AddMatch = function(self, input, start, last)
      local match = strtrim(input:sub(start, last))

      -- state: 1: In name
      -- state: 2: In Realm
      -- state: -1: Escape Name
      -- state: -2: In Escape Realm
      local state = 1
      local name = ""
      local realm = ""


      for index = 1, #match do
        local c = match:sub(index, index)

        if state == -1 then
          name = name .. c
          state = 1
        elseif state == -2 then
          realm = realm .. c
          state = 2
        elseif state == 1 then
          if c == "\\" then
            state = -1
          elseif c == "-" then
            state = 2
          else
            name = name .. c
          end
        elseif state == 2 then
          if c == "\\" then
            state = -2
          else
            realm = realm .. c
          end
        end
      end

      if name == "" then
        if realm == "" then
          -- Do nothing
        else
          self.realm[realm] = true
        end
      else
        if realm == "" then
          self.name[name] = true
        else
          self.full[name .. "-" .. realm] = true
        end
      end
    end,
    Check = function(self, name, realm)
      if not name or not realm then
        return false
      end
      return self.name[name] or self.realm[realm] or self.full[name .. "-" .. realm]
    end
  }

  if not name then return end
  local start = 1
  local last = name:find(',', start, true)

  while (last) do
    matches:AddMatch(name, start, last - 1)
    start = last + 1
    last = name:find(',', start, true)
  end

  last = #name
  matches:AddMatch(name, start, last)

  return matches
end

function Private.ExecEnv.ParseZoneCheck(input)
  if not input then return end

  local matcher = {
    Check = function(self)
      return false
    end,
    CheckBoth = function(self, zoneId, zonegroupId, instanceId, minimapZoneText)
      return self:CheckPositive(zoneId, zonegroupId, instanceId, minimapZoneText)
             and self:CheckNegative(zoneId, zonegroupId, instanceId, minimapZoneText)
    end,
    CheckPositive = function(self, zoneId, zonegroupId, instanceId, minimapZoneText)
      return self.zoneIds[zoneId] or self.zoneGroupIds[zonegroupId] or (instanceId and self.instanceIds[instanceId]) or self.areaNames[minimapZoneText]
    end,
    CheckNegative = function(self, zoneId, zonegroupId, instanceId, minimapZoneText)
      return not (self.negZoneIds[zoneId]
                  or self.negZoneGroupIds[zonegroupId]
                  or (instanceId and self.negInstanceIds[instanceId])
                  or self.negAreaNames[minimapZoneText])
    end,
    AddId = function(self, input, start, last)
      local id = tonumber(strtrim(input:sub(start, last)))
      if id then
        local prevChar = input:sub(start - 1, start - 1)
        local prevPrevchar = input:sub(start - 2, start - 2)
        if prevChar == 'g' or prevChar == 'G' then
          if prevPrevchar == "-" then
            self.negZoneGroupIds[id] = true
          else
            self.zoneGroupIds[id] = true
          end
        elseif prevChar == 'c' or prevChar == 'C' then
          local addTo = self.zoneIds
          if prevPrevchar == "-" then
            addTo = self.negZoneIds
          end
          addTo[id] = true
          local info = C_Map.GetMapChildrenInfo(id, nil, true)
          if info then
            for _,childInfo in pairs(info) do
              addTo[childInfo.mapID] = true
            end
          end
        elseif prevChar == 'a' or prevChar == 'A' then
          local areaName = C_Map.GetAreaInfo(id)
          if areaName then
            if prevPrevchar == "-" then
              self.negAreaNames[areaName] = true
            else
              self.areaNames[areaName] = true
            end
          end
        elseif prevChar == 'i' or prevChar == 'I' then
          if prevPrevchar == "-" then
            self.negInstanceIds[id] = true
          else
            self.instanceIds[id] = true
          end
        else
          if prevChar == "-" then
            self.negZoneIds[id] = true
          else
            self.zoneIds[id] = true
          end
        end
      end
    end,
    zoneIds = {},
    zoneGroupIds = {},
    instanceIds = {},
    areaNames = {},
    negZoneIds = {},
    negZoneGroupIds = {},
    negInstanceIds = {},
    negAreaNames = {},
  }

  local start = input:find('%d', 1)
  if start then
    local last = input:find('%D', start)
    while (last) do
      matcher:AddId(input, start, last - 1)
      start = input:find('%d', last + 1) or #input + 1
      last = input:find('%D', start)
    end

    last = #input
    matcher:AddId(input, start, last)
  end
  local hasPositive = next(matcher.zoneIds) or next(matcher.zoneGroupIds) or next(matcher.instanceIds) or next(matcher.areaNames)
  local hasNegative = next(matcher.negZoneIds) or next(matcher.negZoneGroupIds) or next(matcher.negInstanceIds) or next(matcher.negAreaNames)
  if hasPositive and hasNegative then
    matcher.Check = matcher.CheckBoth
  elseif hasPositive then
    matcher.Check = matcher.CheckPositive
  elseif hasNegative then
    matcher.Check = matcher.CheckNegative
  end
  return matcher
end

function WeakAuras.IsAuraLoaded(id)
  return Private.loaded[id]
end

function Private.ExecEnv.CreateSpellChecker()
  local matcher = {
    names = {},
    spellIds = {},
    AddName = function(self, name)
      local spellId = tonumber(name)
      if spellId then
        name = Private.ExecEnv.GetSpellName(spellId)
        if name then
          self.names[name] = true
        end
      else
        self.names[name] = true
      end
    end,
    AddExact = function(self, spellId)
      spellId = tonumber(spellId)
      self.spellIds[spellId] = true
    end,
    Check = function(self, spellId)
      if spellId then
        return self.spellIds[spellId] or self.names[Private.ExecEnv.GetSpellName(spellId)]
      end
    end,
    CheckName = function(self, name)
      return self.names[name]
    end
  }
  return matcher
end

function Private.IconSources(data)
  local values = {
    [-1] = L["Automatic"],
    [0] = L["Manual Icon"],
  }

  for i = 1, #data.triggers do
    values[i] = string.format(L["Trigger %i"], i)
  end
  return values
end

-- This should be used instead of string.format("...%q...", input)
-- e.g. string.format("...%s...", Private.QuotedString(input))
-- If the string is passed to loadstring.
-- It escapes --, which loadstring would otherwise interpret as comment starts
function Private.QuotedString(input)
  local str = string.format("%q", input)
  return (str:gsub("%-%-", "-\\-"))
end

-- Helper function to make the templates not care, how the generic triggers
-- are categorized
---@private
function WeakAuras.GetTriggerCategoryFor(triggerType)
  local prototype = Private.event_prototypes[triggerType]
  return prototype and prototype.type
end

function Private.SortOrderForValues(values)
  local sortOrder = {}
  for key, value in pairs(values) do
    tinsert(sortOrder, key)
  end
  table.sort(sortOrder, function(aKey, bKey)
    local aValue = values[aKey]
    local bValue = values[bKey]

    if type(aValue) == "string" and aValue:sub(1, #WeakAuras.newFeatureString) == WeakAuras.newFeatureString then
      aValue = aValue:sub(#WeakAuras.newFeatureString + 1)
    end

    if type(bValue) == "string" and bValue:sub(1, #WeakAuras.newFeatureString) == WeakAuras.newFeatureString then
      bValue = bValue:sub(#WeakAuras.newFeatureString + 1)
    end

    return aValue < bValue
  end)
  return sortOrder
end

do
  local function shouldInclude(data, includeGroups, includeLeafs)
    if data.controlledChildren then
      return includeGroups
    else
      return includeLeafs
    end
  end

  local function Traverse(data, includeSelf, includeGroups, includeLeafs)
    if includeSelf and shouldInclude(data, includeGroups, includeLeafs) then
      coroutine.yield(data)
    end

    if data.controlledChildren then
      for _, child in ipairs(data.controlledChildren) do
        Traverse(WeakAuras.GetData(child), true, includeGroups, includeLeafs)
      end
    end
  end

  local function TraverseLeafs(data)
    return Traverse(data, false, false, true)
  end

  local function TraverseLeafsOrAura(data)
    return Traverse(data, true, false, true)
  end

  local function TraverseGroups(data)
    return Traverse(data, true, true, false)
  end

  local function TraverseSubGroups(data)
    return Traverse(data, false, true, false)
  end

  local function TraverseAllChildren(data)
    return Traverse(data, false, true, true)
  end

  local function TraverseAll(data)
    return Traverse(data, true, true, true)
  end

  local function TraverseParents(data)
    while data.parent do
      local parentData = WeakAuras.GetData(data.parent)
      coroutine.yield(parentData)
      data = parentData
    end
  end

  -- Only non-group auras, not include self
  function Private.TraverseLeafs(data)
    return coroutine.wrap(TraverseLeafs), data
  end

  -- The root if it is a non-group, otherwise non-group children
  function Private.TraverseLeafsOrAura(data)
    return coroutine.wrap(TraverseLeafsOrAura), data
  end

  -- All groups, includes self
  function Private.TraverseGroups(data)
    return coroutine.wrap(TraverseGroups), data
  end

  -- All groups, excludes self
  function Private.TraverseSubGroups(data)
    return coroutine.wrap(TraverseSubGroups), data
  end

  -- All Children, excludes self
  function Private.TraverseAllChildren(data)
    return coroutine.wrap(TraverseAllChildren), data
  end

  -- All Children and self
  function Private.TraverseAll(data)
    return coroutine.wrap(TraverseAll), data
  end

  function Private.TraverseParents(data)
    return coroutine.wrap(TraverseParents), data
  end

  --- Returns whether the data is a group or dynamicgroup
  ---@param data auraData
  ---@return boolean
  function Private.IsGroupType(data)
    return data.regionType == "group" or data.regionType == "dynamicgroup"
  end
end



